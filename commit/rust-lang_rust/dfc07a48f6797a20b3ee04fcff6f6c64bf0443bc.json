{"sha": "dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYzA3YTQ4ZjY3OTdhMjBiM2VlMDRmY2ZmNmY2YzY0YmYwNDQzYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-18T02:58:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-18T02:58:13Z"}, "message": "Auto merge of #50847 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #50387 (Remove leftover tab in libtest outputs)\n - #50553 (Add Option::xor method)\n - #50610 (Improve format string errors)\n - #50649 (Tweak `nearest_common_ancestor()`.)\n - #50790 (Fix grammar documentation wrt Unicode identifiers)\n - #50791 (Fix null exclusions in grammar docs)\n - #50806 (Add `bless` x.py subcommand for easy ui test replacement)\n - #50818 (Speed up `opt_normalize_projection_type`)\n - #50837 (Revert #49767)\n - #50839 (Make sure people know the book is free oline)\n\nFailed merges:", "tree": {"sha": "b0356d0003fb9a5038bb884761df87d496b1b836", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0356d0003fb9a5038bb884761df87d496b1b836"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "html_url": "https://github.com/rust-lang/rust/commit/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bedbf727855d099963b66cf6619a53d3c073f52a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bedbf727855d099963b66cf6619a53d3c073f52a", "html_url": "https://github.com/rust-lang/rust/commit/bedbf727855d099963b66cf6619a53d3c073f52a"}, {"sha": "faa1f212981d46d7bddd25c9b633193f4227d526", "url": "https://api.github.com/repos/rust-lang/rust/commits/faa1f212981d46d7bddd25c9b633193f4227d526", "html_url": "https://github.com/rust-lang/rust/commit/faa1f212981d46d7bddd25c9b633193f4227d526"}], "stats": {"total": 1286, "additions": 595, "deletions": 691}, "files": [{"sha": "4607ca5cf9f48e72b32672d424f97c48399c2e6c", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -297,7 +297,12 @@ fn main() {\n     }\n \n     if verbose > 1 {\n-        eprintln!(\"rustc command: {:?}\", cmd);\n+        eprintln!(\n+            \"rustc command: {:?}={:?} {:?}\",\n+            bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap(),\n+            cmd,\n+        );\n         eprintln!(\"sysroot: {:?}\", sysroot);\n         eprintln!(\"libdir: {:?}\", libdir);\n     }"}, {"sha": "cd646b76e832e980b13de2110543a93e76c8dd86", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -1460,6 +1460,7 @@ mod __test {\n             rustc_args: vec![],\n             fail_fast: true,\n             doc_tests: DocTests::No,\n+            bless: false,\n         };\n \n         let build = Build::new(config);"}, {"sha": "90dd5d819b0da2a79330881bb85d5c425a584fc0", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -59,6 +59,8 @@ pub enum Subcommand {\n     },\n     Test {\n         paths: Vec<PathBuf>,\n+        /// Whether to automatically update stderr/stdout files\n+        bless: bool,\n         test_args: Vec<String>,\n         rustc_args: Vec<String>,\n         fail_fast: bool,\n@@ -173,6 +175,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 );\n                 opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n                 opts.optflag(\"\", \"doc\", \"only run doc tests\");\n+                opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n             },\n             \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n             \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n@@ -258,6 +261,7 @@ Arguments:\n         ./x.py test src/test/run-pass\n         ./x.py test src/libstd --test-args hash_map\n         ./x.py test src/libstd --stage 0\n+        ./x.py test src/test/ui --bless\n \n     If no arguments are passed then the complete artifacts for that stage are\n     compiled and tested.\n@@ -322,6 +326,7 @@ Arguments:\n             \"test\" => {\n                 Subcommand::Test {\n                     paths,\n+                    bless: matches.opt_present(\"bless\"),\n                     test_args: matches.opt_strs(\"test-args\"),\n                     rustc_args: matches.opt_strs(\"rustc-args\"),\n                     fail_fast: !matches.opt_present(\"no-fail-fast\"),\n@@ -424,6 +429,13 @@ impl Subcommand {\n             _ => DocTests::Yes,\n         }\n     }\n+\n+    pub fn bless(&self) -> bool {\n+        match *self {\n+            Subcommand::Test { bless, .. } => bless,\n+            _ => false,\n+        }\n+    }\n }\n \n fn split(s: Vec<String>) -> Vec<String> {"}, {"sha": "7a4924f03c8d23eef3cb1ee26cb5b6c690673fcb", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -47,6 +47,16 @@ pub enum TestKind {\n     Bench,\n }\n \n+impl From<Kind> for TestKind {\n+    fn from(kind: Kind) -> Self {\n+        match kind {\n+            Kind::Test => TestKind::Test,\n+            Kind::Bench => TestKind::Bench,\n+            _ => panic!(\"unexpected kind in crate: {:?}\", kind)\n+        }\n+    }\n+}\n+\n impl TestKind {\n     // Return the cargo subcommand for this test kind\n     fn subcommand(self) -> &'static str {\n@@ -951,6 +961,10 @@ impl Step for Compiletest {\n         cmd.arg(\"--host\").arg(&*compiler.host);\n         cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n \n+        if builder.config.cmd.bless() {\n+            cmd.arg(\"--bless\");\n+        }\n+\n         if let Some(ref nodejs) = builder.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }\n@@ -1342,13 +1356,7 @@ impl Step for CrateLibrustc {\n \n         for krate in builder.in_tree_crates(\"rustc-main\") {\n             if run.path.ends_with(&krate.path) {\n-                let test_kind = if builder.kind == Kind::Test {\n-                    TestKind::Test\n-                } else if builder.kind == Kind::Bench {\n-                    TestKind::Bench\n-                } else {\n-                    panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-                };\n+                let test_kind = builder.kind.into();\n \n                 builder.ensure(CrateLibrustc {\n                     compiler,\n@@ -1394,13 +1402,7 @@ impl Step for CrateNotDefault {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n+        let test_kind = builder.kind.into();\n \n         builder.ensure(CrateNotDefault {\n             compiler,\n@@ -1461,13 +1463,7 @@ impl Step for Crate {\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n         let make = |mode: Mode, krate: &CargoCrate| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n+            let test_kind = builder.kind.into();\n \n             builder.ensure(Crate {\n                 compiler,\n@@ -1625,13 +1621,7 @@ impl Step for CrateRustdoc {\n     fn make_run(run: RunConfig) {\n         let builder = run.builder;\n \n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n+        let test_kind = builder.kind.into();\n \n         builder.ensure(CrateRustdoc {\n             host: run.host,"}, {"sha": "ee9135b6578f6071e7f43fbbe6f2214f1253dbf6", "filename": "src/doc/grammar.md", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -101,29 +101,24 @@ properties: `ident`, `non_null`, `non_eol`, `non_single_quote` and\n \n ### Identifiers\n \n-The `ident` production is any nonempty Unicode[^non_ascii_idents] string of\n+The `ident` production is any nonempty Unicode string of\n the following form:\n \n-[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n-  gated. This is expected to improve soon.\n+- The first character is in one of the following ranges `U+0041` to `U+005A`\n+(\"A\" to \"Z\"), `U+0061` to `U+007A` (\"a\" to \"z\"), or `U+005F` (\"\\_\").\n+- The remaining characters are in the range `U+0030` to `U+0039` (\"0\" to \"9\"),\n+or any of the prior valid initial characters.\n \n-- The first character has property `XID_start`\n-- The remaining characters have property `XID_continue`\n-\n-that does _not_ occur in the set of [keywords](#keywords).\n-\n-> **Note**: `XID_start` and `XID_continue` as character properties cover the\n-> character ranges used to form the more familiar C and Java language-family\n-> identifiers.\n+as long as the identifier does _not_ occur in the set of [keywords](#keywords).\n \n ### Delimiter-restricted productions\n \n Some productions are defined by exclusion of particular Unicode characters:\n \n - `non_null` is any single Unicode character aside from `U+0000` (null)\n-- `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n-- `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n-- `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n+- `non_eol` is any single Unicode character aside from `U+000A` (`'\\n'`)\n+- `non_single_quote` is any single Unicode character aside from `U+0027`  (`'`)\n+- `non_double_quote` is any single Unicode character aside from `U+0022` (`\"`)\n \n ## Comments\n "}, {"sha": "320283f31b51feb3e3fd24a632195fcb42a5181a", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -1,3 +1,3 @@\n % The Rust Tutorial\n \n-This tutorial has been deprecated in favor of [the Book](book/index.html). Go check that out instead!\n+This tutorial has been deprecated in favor of [the Book](book/index.html), which is available free online and in dead tree form. Go check that out instead!"}, {"sha": "0663409c992f42e064a40a2ec1451209691d305f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 31, "deletions": 130, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -962,122 +962,59 @@ extern \"rust-intrinsic\" {\n     /// value is not necessarily valid to be used to actually access memory.\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-    /// and destination must *not* overlap.\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n+    /// and destination may *not* overlap.\n     ///\n-    /// For regions of memory which might overlap, use [`copy`] instead.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`].\n-    ///\n-    /// [`copy`]: ./fn.copy.html\n-    /// [`memcpy`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memcpy\n+    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n     ///\n     /// # Safety\n     ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * The region of memory which begins at `src` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n-    ///\n-    /// * The region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n-    ///   initialized).\n-    ///\n-    /// * The two regions of memory must *not* overlap.\n-    ///\n-    /// * `src` must be properly aligned.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n-    /// region at `dst` can be used or dropped after calling\n-    /// `copy_nonoverlapping`.  `copy_nonoverlapping` creates bitwise copies of\n-    /// `T`, regardless of whether `T: Copy`, which can result in undefined\n-    /// behavior if both copies are used.\n-    ///\n-    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// Beyond requiring that the program must be allowed to access both regions\n+    /// of memory, it is Undefined Behavior for source and destination to\n+    /// overlap. Care must also be taken with the ownership of `src` and\n+    /// `dst`. This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents\n+    /// of `src` from being dropped or used.\n     ///\n     /// # Examples\n     ///\n-    /// Manually implement [`Vec::append`]:\n+    /// A safe swap function:\n     ///\n     /// ```\n+    /// use std::mem;\n     /// use std::ptr;\n     ///\n-    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n-    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n-    ///     let src_len = src.len();\n-    ///     let dst_len = dst.len();\n-    ///\n-    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n-    ///     dst.reserve(src_len);\n-    ///\n+    /// # #[allow(dead_code)]\n+    /// fn swap<T>(x: &mut T, y: &mut T) {\n     ///     unsafe {\n-    ///         // The call to offset is always safe because `Vec` will never\n-    ///         // allocate more than `isize::MAX` bytes.\n-    ///         let dst = dst.as_mut_ptr().offset(dst_len as isize);\n-    ///         let src = src.as_ptr();\n-    ///\n-    ///         // The two regions cannot overlap becuase mutable references do\n-    ///         // not alias, and two different vectors cannot own the same\n-    ///         // memory.\n-    ///         ptr::copy_nonoverlapping(src, dst, src_len);\n-    ///     }\n+    ///         // Give ourselves some scratch space to work with\n+    ///         let mut t: T = mem::uninitialized();\n     ///\n-    ///     unsafe {\n-    ///         // Truncate `src` without dropping its contents.\n-    ///         src.set_len(0);\n+    ///         // Perform the swap, `&mut` pointers never alias\n+    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n+    ///         ptr::copy_nonoverlapping(y, x, 1);\n+    ///         ptr::copy_nonoverlapping(&t, y, 1);\n     ///\n-    ///         // Notify `dst` that it now holds the contents of `src`.\n-    ///         dst.set_len(dst_len + src_len);\n+    ///         // y and t now point to the same thing, but we need to completely forget `t`\n+    ///         // because it's no longer relevant.\n+    ///         mem::forget(t);\n     ///     }\n     /// }\n-    ///\n-    /// let mut a = vec!['r'];\n-    /// let mut b = vec!['u', 's', 't'];\n-    ///\n-    /// append(&mut a, &mut b);\n-    ///\n-    /// assert_eq!(a, &['r', 'u', 's', 't']);\n-    /// assert!(b.is_empty());\n     /// ```\n-    ///\n-    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n-    /// If the source and destination will *never* overlap,\n-    /// [`copy_nonoverlapping`] can be used instead.\n-    ///\n-    /// `copy` is semantically equivalent to C's [`memmove`].\n-    ///\n-    /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n-    /// [`memmove`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memmove\n+    /// `copy` is semantically equivalent to C's `memmove`.\n     ///\n     /// # Safety\n     ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * The region of memory which begins at `src` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n-    ///\n-    /// * The region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n-    ///   initialized).\n-    ///\n-    /// * `src` must be properly aligned.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n-    /// region at `dst` can be used or dropped after calling `copy`. `copy`\n-    /// creates bitwise copies of `T`, regardless of whether `T: Copy`, which\n-    /// can result in undefined behavior if both copies are used.\n-    ///\n-    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// Care must be taken with the ownership of `src` and `dst`.\n+    /// This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n+    /// from being dropped or used.\n     ///\n     /// # Examples\n     ///\n@@ -1094,34 +1031,15 @@ extern \"rust-intrinsic\" {\n     ///     dst\n     /// }\n     /// ```\n+    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n-    /// `val`.\n-    ///\n-    /// `write_bytes` is semantically equivalent to C's [`memset`].\n-    ///\n-    /// [`memset`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memset\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * The region of memory which begins at `dst` and has a length of\n-    ///   `count` bytes must be valid.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, the caller must ensure that writing `count` bytes to the\n-    /// given region of memory results in a valid value of `T`. Creating an\n-    /// invalid value of `T` can result in undefined behavior. An example is\n-    /// provided below.\n+    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n+    /// bytes of memory starting at `dst` to `val`.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// use std::ptr;\n     ///\n@@ -1132,23 +1050,6 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n     /// ```\n-    ///\n-    /// Creating an invalid value:\n-    ///\n-    /// ```no_run\n-    /// use std::{mem, ptr};\n-    ///\n-    /// let mut v = Box::new(0i32);\n-    ///\n-    /// unsafe {\n-    ///     // Leaks the previously held value by overwriting the `Box<T>` with\n-    ///     // a null pointer.\n-    ///     ptr::write_bytes(&mut v, 0, mem::size_of::<Box<i32>>());\n-    /// }\n-    ///\n-    /// // At this point, using or dropping `v` results in undefined behavior.\n-    /// // v = Box::new(0i32); // ERROR\n-    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "28f37f72d6f9df33172b5eced84265de40414126", "filename": "src/libcore/option.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -705,6 +705,42 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns `None`.\n+    ///\n+    /// [`Some`]: #variant.Some\n+    /// [`None`]: #variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_xor)]\n+    ///\n+    /// let x = Some(2);\n+    /// let y: Option<u32> = None;\n+    /// assert_eq!(x.xor(y), Some(2));\n+    ///\n+    /// let x: Option<u32> = None;\n+    /// let y = Some(2);\n+    /// assert_eq!(x.xor(y), Some(2));\n+    ///\n+    /// let x = Some(2);\n+    /// let y = Some(2);\n+    /// assert_eq!(x.xor(y), None);\n+    ///\n+    /// let x: Option<u32> = None;\n+    /// let y: Option<u32> = None;\n+    /// assert_eq!(x.xor(y), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"option_xor\", issue = \"50512\")]\n+    pub fn xor(self, optb: Option<T>) -> Option<T> {\n+        match (self, optb) {\n+            (Some(a), None) => Some(a),\n+            (None, Some(b)) => Some(b),\n+            _ => None,\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Entry-like operations to insert if None and return a reference\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "5f778482f42f2bc2fa9a87943712ffd3760b2d1f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 70, "deletions": 300, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -10,7 +10,7 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Manually manage memory through raw pointers.\n+//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n \n@@ -38,62 +38,21 @@ pub use intrinsics::write_bytes;\n \n /// Executes the destructor (if any) of the pointed-to value.\n ///\n-/// This is semantically equivalent to calling [`ptr::read`] and discarding\n-/// the result, but has the following advantages:\n+/// This has two use cases:\n ///\n /// * It is *required* to use `drop_in_place` to drop unsized types like\n ///   trait objects, because they can't be read out onto the stack and\n ///   dropped normally.\n ///\n-/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n+/// * It is friendlier to the optimizer to do this over `ptr::read` when\n ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n-/// [`ptr::read`]: ../ptr/fn.read.html\n-///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `to_drop` must point to valid memory.\n-///\n-/// * `to_drop` must be properly aligned.\n-///\n-/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n-/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n-/// foo` counts as a use because it will cause the the value to be dropped\n-/// again. [`write`] can be used to overwrite data without causing it to be\n-/// dropped.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write`]: ../ptr/fn.write.html\n-///\n-/// # Examples\n-///\n-/// Manually remove the last item from a vector:\n-///\n-/// ```\n-/// use std::ptr;\n-/// use std::rc::Rc;\n-///\n-/// let last = Rc::new(1);\n-/// let weak = Rc::downgrade(&last);\n-///\n-/// let mut v = vec![Rc::new(0), last];\n-///\n-/// unsafe {\n-///     // Without a call `drop_in_place`, the last item would never be dropped,\n-///     // and the memory it manages would be leaked.\n-///     ptr::drop_in_place(&mut v[1]);\n-///     v.set_len(1);\n-/// }\n-///\n-/// assert_eq!(v, &[0.into()]);\n-///\n-/// // Ensure that the last item was dropped.\n-/// assert!(weak.upgrade().is_none());\n-/// ```\n+/// This has all the same safety problems as `ptr::read` with respect to\n+/// invalid pointers, types, and double drops.\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n@@ -134,25 +93,17 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// But for the following two exceptions, this function is semantically\n-/// equivalent to [`mem::swap`]:\n-///\n-/// * It operates on raw pointers instead of references. When references are\n-///   available, [`mem::swap`] should be preferred.\n-///\n-/// * The two pointed-to values may overlap. If the values do overlap, then the\n-///   overlapping region of memory from `x` will be used. This is demonstrated\n-///   in the examples below.\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n+/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n+/// is otherwise equivalent. If the values do overlap, then the overlapping\n+/// region of memory from `x` will be used. This is demonstrated in the\n+/// examples section below.\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n+/// This function copies the memory through the raw pointers passed to it\n+/// as arguments.\n ///\n-/// * `x` and `y` must point to valid, initialized memory.\n-///\n-/// * `x` and `y` must be properly aligned.\n+/// Ensure that these pointers are valid before calling `swap`.\n ///\n /// # Examples\n ///\n@@ -288,39 +239,13 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     }\n }\n \n-/// Replaces the value at `dest` with `src`, returning the old value, without\n-/// dropping either.\n-///\n-/// This function is semantically equivalent to [`mem::replace`] except that it\n-/// operates on raw pointers instead of references. When references are\n-/// available, [`mem::replace`] should be preferred.\n-///\n-/// [`mem::replace`]: ../mem/fn.replace.html\n+/// Replaces the value at `dest` with `src`, returning the old\n+/// value, without dropping either.\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `dest` must point to valid, initialized memory.\n-///\n-/// * `dest` must be properly aligned.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// let mut rust = vec!['b', 'u', 's', 't'];\n-///\n-/// // `mem::replace` would have the same effect without requiring the unsafe\n-/// // block.\n-/// let b = unsafe {\n-///     ptr::replace(&mut rust[0], 'r')\n-/// };\n-///\n-/// assert_eq!(b, 'b');\n-/// assert_eq!(rust, &['r', 'u', 's', 't']);\n-/// ```\n+/// This is only unsafe because it accepts a raw pointer.\n+/// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n@@ -333,23 +258,14 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n ///\n-/// * `src` must point to valid, initialized memory.\n-///\n-/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n-///   case.\n-///\n-/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n-/// pointed-to value can be used or dropped after calling `read`. `read` creates\n-/// a bitwise copy of `T`, regardless of whether `T: Copy`, which can result\n-/// in undefined behavior if both copies are used. Note that `*src = foo` counts\n-/// as a use because it will attempt to drop the value previously at `*src`.\n-/// [`write`] can be used to overwrite data without causing it to be dropped.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-/// [`write`]: ./fn.write.html\n+/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n ///\n /// # Examples\n ///\n@@ -363,44 +279,6 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n-///\n-/// Manually implement [`mem::swap`]:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// fn swap<T>(a: &mut T, b: &mut T) {\n-///     unsafe {\n-///         // Create a bitwise copy of the value at `a` in `tmp`.\n-///         let tmp = ptr::read(a);\n-///\n-///         // Exiting at this point (either by explicitly returning or by\n-///         // calling a function which panics) would cause the value in `tmp` to\n-///         // be dropped while the same value is still referenced by `a`. This\n-///         // could trigger undefined behavior if `T` is not `Copy`.\n-///\n-///         // Create a bitwise copy of the value at `b` in `a`.\n-///         // This is safe because mutable references cannot alias.\n-///         ptr::copy_nonoverlapping(b, a, 1);\n-///\n-///         // As above, exiting here could trigger undefined behavior because\n-///         // the same value is referenced by `a` and `b`.\n-///\n-///         // Move `tmp` into `b`.\n-///         ptr::write(b, tmp);\n-///     }\n-/// }\n-///\n-/// let mut foo = \"foo\".to_owned();\n-/// let mut bar = \"bar\".to_owned();\n-///\n-/// swap(&mut foo, &mut bar);\n-///\n-/// assert_eq!(foo, \"bar\");\n-/// assert_eq!(bar, \"foo\");\n-/// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -412,62 +290,28 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// Reads the value from `src` without moving it. This leaves the\n /// memory in `src` unchanged.\n ///\n-/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n-///\n-/// [`read`]: ./fn.read.html\n+/// Unlike `read`, the pointer may be unaligned.\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must point to valid, initialized memory.\n-///\n-/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n-/// pointed-to value can be used or dropped after calling `read_unaligned`.\n-/// `read_unaligned` creates a bitwise copy of `T`, regardless of whether `T:\n-/// Copy`, and this can result in undefined behavior if both copies are used.\n-/// Note that `*src = foo` counts as a use because it will attempt to drop the\n-/// value previously at `*src`.  [`write_unaligned`] can be used to overwrite\n-/// data without causing it to be dropped.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n ///\n /// # Examples\n ///\n-/// Access members of a packed struct by reference:\n+/// Basic usage:\n ///\n /// ```\n-/// use std::ptr;\n+/// let x = 12;\n+/// let y = &x as *const i32;\n ///\n-/// #[repr(packed, C)]\n-/// #[derive(Default)]\n-/// struct Packed {\n-///     _padding: u8,\n-///     unaligned: u32,\n+/// unsafe {\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n /// }\n-///\n-/// let x = Packed {\n-///     _padding: 0x00,\n-///     unaligned: 0x01020304,\n-/// };\n-///\n-/// let v = unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &x.unaligned;\n-///\n-///     // Dereferencing normally will emit an unaligned load instruction,\n-///     // causing undefined behavior.\n-///     // let v = *unaligned; // ERROR\n-///\n-///     // Instead, use `read_unaligned` to read improperly aligned values.\n-///     let v = ptr::read_unaligned(unaligned);\n-///\n-///     v\n-/// };\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n@@ -482,28 +326,21 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n+/// # Safety\n+///\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n /// allocations or resources, so care must be taken not to overwrite an object\n /// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been [`read`] from.\n-///\n-/// [`read`]: ./fn.read.html\n-///\n-/// # Safety\n+/// memory that has previously been `read` from.\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `dst` must point to valid memory.\n-///\n-/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n-///   case.\n-///\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n ///\n /// # Examples\n ///\n@@ -519,30 +356,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n-///\n-/// Manually implement [`mem::swap`]:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// fn swap<T>(a: &mut T, b: &mut T) {\n-///     unsafe {\n-///         let tmp = ptr::read(a);\n-///         ptr::copy_nonoverlapping(b, a, 1);\n-///         ptr::write(b, tmp);\n-///     }\n-/// }\n-///\n-/// let mut foo = \"foo\".to_owned();\n-/// let mut bar = \"bar\".to_owned();\n-///\n-/// swap(&mut foo, &mut bar);\n-///\n-/// assert_eq!(foo, \"bar\");\n-/// assert_eq!(bar, \"foo\");\n-/// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -552,58 +365,36 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike [`write`], the pointer may be unaligned.\n+/// Unlike `write`, the pointer may be unaligned.\n+///\n+/// # Safety\n ///\n-/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n-/// could leak allocations or resources, so care must be taken not to overwrite\n-/// an object that should be dropped.\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been read with [`read_unaligned`].\n-///\n-/// [`write`]: ./fn.write.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `dst` must point to valid memory.\n+/// memory that has previously been `read` from.\n ///\n /// # Examples\n ///\n-/// Access fields in a packed struct:\n+/// Basic usage:\n ///\n /// ```\n-/// use std::{mem, ptr};\n-///\n-/// #[repr(packed, C)]\n-/// #[derive(Default)]\n-/// struct Packed {\n-///     _padding: u8,\n-///     unaligned: u32,\n-/// }\n-///\n-/// let v = 0x01020304;\n-/// let mut x: Packed = unsafe { mem::zeroed() };\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n ///\n /// unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &mut x.unaligned;\n-///\n-///     // Dereferencing normally will emit an unaligned store instruction,\n-///     // causing undefined behavior.\n-///     // *unaligned = v; // ERROR\n-///\n-///     // Instead, use `write_unaligned` to write improperly aligned values.\n-///     ptr::write_unaligned(unaligned, v);\n+///     std::ptr::write_unaligned(y, z);\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n /// }\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n+/// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n@@ -620,11 +411,6 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// Memory read with `read_volatile` should almost always be written to using\n-/// [`write_volatile`].\n-///\n-/// [`write_volatile`]: ./fn.write_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -641,19 +427,12 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must point to valid, initialized memory.\n-///\n-/// * `src` must be properly aligned.\n-///\n-/// Like [`read`], `read_volatile` creates a bitwise copy of the pointed-to\n-/// object, regardless of whether `T` is [`Copy`]. Using both values can cause\n-/// undefined behavior. However, storing non-[`Copy`] data in I/O memory is\n-/// almost certainly incorrect.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n ///\n /// # Examples\n ///\n@@ -680,18 +459,6 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// Memory written with `write_volatile` should almost always be read from using\n-/// [`read_volatile`].\n-///\n-/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n-/// could leak allocations or resources, so care must be taken not to overwrite\n-/// an object that should be dropped.\n-///\n-/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n-/// location pointed to by `dst`.\n-///\n-/// [`read_volatile`]: ./fn.read_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -708,11 +475,14 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n+/// This operation is marked unsafe because it accepts a raw pointer.\n ///\n-/// * `dst` must point to valid memory.\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n ///\n-/// * `dst` must be properly aligned.\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n+/// memory that has previously been `read` from.\n ///\n /// # Examples\n ///"}, {"sha": "a77751d65d08c3c7f164526688356acd35fd82ce", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -127,6 +127,14 @@ pub enum Count<'a> {\n     CountImplied,\n }\n \n+pub struct ParseError {\n+    pub description: string::String,\n+    pub note: Option<string::String>,\n+    pub label: string::String,\n+    pub start: usize,\n+    pub end: usize,\n+}\n+\n /// The parser structure for interpreting the input format string. This is\n /// modeled as an iterator over `Piece` structures to form a stream of tokens\n /// being output.\n@@ -137,7 +145,7 @@ pub struct Parser<'a> {\n     input: &'a str,\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<(string::String, Option<string::String>)>,\n+    pub errors: Vec<ParseError>,\n     /// Current position of implicit positional argument pointer\n     curarg: usize,\n }\n@@ -160,12 +168,17 @@ impl<'a> Iterator for Parser<'a> {\n                 }\n                 '}' => {\n                     self.cur.next();\n+                    let pos = pos + 1;\n                     if self.consume('}') {\n-                        Some(String(self.string(pos + 1)))\n+                        Some(String(self.string(pos)))\n                     } else {\n-                        self.err_with_note(\"unmatched `}` found\",\n-                                           \"if you intended to print `}`, \\\n-                                           you can escape it using `}}`\");\n+                        self.err_with_note(\n+                            \"unmatched `}` found\",\n+                            \"unmatched `}`\",\n+                            \"if you intended to print `}`, you can escape it using `}}`\",\n+                            pos,\n+                            pos,\n+                        );\n                         None\n                     }\n                 }\n@@ -191,15 +204,40 @@ impl<'a> Parser<'a> {\n     /// Notifies of an error. The message doesn't actually need to be of type\n     /// String, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n-    fn err(&mut self, msg: &str) {\n-        self.errors.push((msg.to_owned(), None));\n+    fn err<S1: Into<string::String>, S2: Into<string::String>>(\n+        &mut self,\n+        description: S1,\n+        label: S2,\n+        start: usize,\n+        end: usize,\n+    ) {\n+        self.errors.push(ParseError {\n+            description: description.into(),\n+            note: None,\n+            label: label.into(),\n+            start,\n+            end,\n+        });\n     }\n \n     /// Notifies of an error. The message doesn't actually need to be of type\n     /// String, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n-    fn err_with_note(&mut self, msg: &str, note: &str) {\n-        self.errors.push((msg.to_owned(), Some(note.to_owned())));\n+    fn err_with_note<S1: Into<string::String>, S2: Into<string::String>, S3: Into<string::String>>(\n+        &mut self,\n+        description: S1,\n+        label: S2,\n+        note: S3,\n+        start: usize,\n+        end: usize,\n+    ) {\n+        self.errors.push(ParseError {\n+            description: description.into(),\n+            note: Some(note.into()),\n+            label: label.into(),\n+            start,\n+            end,\n+        });\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n@@ -222,19 +260,26 @@ impl<'a> Parser<'a> {\n     /// found, an error is emitted.\n     fn must_consume(&mut self, c: char) {\n         self.ws();\n-        if let Some(&(_, maybe)) = self.cur.peek() {\n+        if let Some(&(pos, maybe)) = self.cur.peek() {\n             if c == maybe {\n                 self.cur.next();\n             } else {\n-                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c, maybe));\n+                self.err(format!(\"expected `{:?}`, found `{:?}`\", c, maybe),\n+                         format!(\"expected `{}`\", c),\n+                         pos + 1,\n+                         pos + 1);\n             }\n         } else {\n-            let msg = &format!(\"expected `{:?}` but string was terminated\", c);\n+            let msg = format!(\"expected `{:?}` but string was terminated\", c);\n+            let pos = self.input.len() + 1; // point at closing `\"`\n             if c == '}' {\n                 self.err_with_note(msg,\n-                                   \"if you intended to print `{`, you can escape it using `{{`\");\n+                                   format!(\"expected `{:?}`\", c),\n+                                   \"if you intended to print `{`, you can escape it using `{{`\",\n+                                   pos,\n+                                   pos);\n             } else {\n-                self.err(msg);\n+                self.err(msg, format!(\"expected `{:?}`\", c), pos, pos);\n             }\n         }\n     }\n@@ -300,6 +345,15 @@ impl<'a> Parser<'a> {\n         } else {\n             match self.cur.peek() {\n                 Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+                Some(&(pos, c)) if c == '_' => {\n+                    let invalid_name = self.string(pos);\n+                    self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n+                                       \"invalid argument name\",\n+                                       \"argument names cannot start with an underscore\",\n+                                       pos + 1, // add 1 to account for leading `{`\n+                                       pos + 1 + invalid_name.len());\n+                    Some(ArgumentNamed(invalid_name))\n+                },\n \n                 // This is an `ArgumentNext`.\n                 // Record the fact and do the resolution after parsing the"}, {"sha": "42a08afe305a5acfff45baeb68996b42612414ce", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -542,18 +542,6 @@ impl<'tcx> ScopeTree {\n         assert!(previous.is_none());\n     }\n \n-    fn closure_is_enclosed_by(&self,\n-                              mut sub_closure: hir::ItemLocalId,\n-                              sup_closure: hir::ItemLocalId) -> bool {\n-        loop {\n-            if sub_closure == sup_closure { return true; }\n-            match self.closure_tree.get(&sub_closure) {\n-                Some(&s) => { sub_closure = s; }\n-                None => { return false; }\n-            }\n-        }\n-    }\n-\n     fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.item_local_id());\n@@ -688,65 +676,37 @@ impl<'tcx> ScopeTree {\n         // requires a hash table lookup, and we often have very long scope\n         // chains (10s or 100s of scopes) that only differ by a few elements at\n         // the start. So this algorithm is faster.\n-        let mut ma = Some(scope_a);\n-        let mut mb = Some(scope_b);\n-        let mut seen_a: SmallVec<[Scope; 32]> = SmallVec::new();\n-        let mut seen_b: SmallVec<[Scope; 32]> = SmallVec::new();\n+\n+        let mut ma = Some(&scope_a);\n+        let mut mb = Some(&scope_b);\n+\n+        // A HashSet<Scope> is a more obvious choice for these, but SmallVec is\n+        // faster because the set size is normally small so linear search is\n+        // as good or better than a hash table lookup, plus the size is usually\n+        // small enough to avoid a heap allocation.\n+        let mut seen_a: SmallVec<[&Scope; 32]> = SmallVec::new();\n+        let mut seen_b: SmallVec<[&Scope; 32]> = SmallVec::new();\n+\n         loop {\n             if let Some(a) = ma {\n-                if seen_b.iter().position(|s| *s == a).is_some() {\n-                    return a;\n+                if seen_b.iter().any(|s| *s == a) {\n+                    return *a;\n                 }\n                 seen_a.push(a);\n-                ma = self.parent_map.get(&a).map(|s| *s);\n+                ma = self.parent_map.get(&a);\n             }\n \n             if let Some(b) = mb {\n-                if seen_a.iter().position(|s| *s == b).is_some() {\n-                    return b;\n+                if seen_a.iter().any(|s| *s == b) {\n+                    return *b;\n                 }\n                 seen_b.push(b);\n-                mb = self.parent_map.get(&b).map(|s| *s);\n+                mb = self.parent_map.get(&b);\n             }\n \n             if ma.is_none() && mb.is_none() {\n-                break;\n-            }\n-        };\n-\n-        fn outermost_scope(parent_map: &FxHashMap<Scope, Scope>, scope: Scope) -> Scope {\n-            let mut scope = scope;\n-            loop {\n-               match parent_map.get(&scope) {\n-                   Some(&superscope) => scope = superscope,\n-                   None => break scope,\n-               }\n-            }\n-        }\n-\n-        // In this (rare) case, the two regions belong to completely different\n-        // functions. Compare those fn for lexical nesting. The reasoning\n-        // behind this is subtle. See the \"Modeling closures\" section of the\n-        // README in infer::region_constraints for more details.\n-        let a_root_scope = outermost_scope(&self.parent_map, scope_a);\n-        let b_root_scope = outermost_scope(&self.parent_map, scope_b);\n-        match (a_root_scope.data(), b_root_scope.data()) {\n-            (ScopeData::Destruction(a_root_id),\n-             ScopeData::Destruction(b_root_id)) => {\n-                if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n-                    // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n-                    scope_b\n-                } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n-                    // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n-                    scope_a\n-                } else {\n-                    // neither fn encloses the other\n-                    bug!()\n-                }\n-            }\n-            _ => {\n-                // root ids are always Node right now\n-                bug!()\n+                // No nearest common ancestor found.\n+                bug!();\n             }\n         }\n     }"}, {"sha": "97ce730c59ec508f76e16a0c824529207e2270d0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -203,17 +203,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     data);\n-                let normalized = super::normalize_projection_type(\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n                     &mut selcx,\n                     obligation.param_env,\n                     data.projection_ty,\n                     obligation.cause.clone(),\n-                    0\n+                    0,\n+                    &mut obligations\n                 );\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n-                                        .eq(normalized.value, data.ty) {\n+                                        .eq(normalized_ty, data.ty) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n-                        expected: normalized.value,\n+                        expected: normalized_ty,\n                         found: data.ty,\n                     }));\n                     err_buf = error;"}, {"sha": "4447a2b6ed14081086f05b13cf1adfea05674f08", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -161,19 +161,18 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         // FIXME(#20304) -- cache\n \n         let mut selcx = SelectionContext::new(infcx);\n-        let normalized = project::normalize_projection_type(&mut selcx,\n-                                                            param_env,\n-                                                            projection_ty,\n-                                                            cause,\n-                                                            0);\n-\n-        for obligation in normalized.obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-\n-        debug!(\"normalize_projection_type: result={:?}\", normalized.value);\n-\n-        normalized.value\n+        let mut obligations = vec![];\n+        let normalized_ty = project::normalize_projection_type(&mut selcx,\n+                                                               param_env,\n+                                                               projection_ty,\n+                                                               cause,\n+                                                               0,\n+                                                               &mut obligations);\n+        self.register_predicate_obligations(infcx, obligations);\n+\n+        debug!(\"normalize_projection_type: result={:?}\", normalized_ty);\n+\n+        normalized_ty\n     }\n \n     /// Requires that `ty` must implement the trait with `def_id` in"}, {"sha": "174c35d1d69bfc5bc25b4ec5e9db82c90fd3c9d6", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 90, "deletions": 55, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -225,12 +225,14 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n \n-    let Normalized { value: normalized_ty, mut obligations } =\n+    let mut obligations = vec![];\n+    let normalized_ty =\n         match opt_normalize_projection_type(selcx,\n                                             obligation.param_env,\n                                             obligation.predicate.projection_ty,\n                                             obligation.cause.clone(),\n-                                            obligation.recursion_depth) {\n+                                            obligation.recursion_depth,\n+                                            &mut obligations) {\n             Some(n) => n,\n             None => return Ok(None),\n         };\n@@ -386,16 +388,15 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 // binder). It would be better to normalize in a\n                 // binding-aware fashion.\n \n-                let Normalized { value: normalized_ty, obligations } =\n-                    normalize_projection_type(self.selcx,\n-                                              self.param_env,\n-                                              data.clone(),\n-                                              self.cause.clone(),\n-                                              self.depth);\n-                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?} \\\n-                        with {} add'l obligations\",\n-                       self.depth, ty, normalized_ty, obligations.len());\n-                self.obligations.extend(obligations);\n+                let normalized_ty = normalize_projection_type(self.selcx,\n+                                                              self.param_env,\n+                                                              data.clone(),\n+                                                              self.cause.clone(),\n+                                                              self.depth,\n+                                                              &mut self.obligations);\n+                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n+                        now with {} obligations\",\n+                       self.depth, ty, normalized_ty, self.obligations.len());\n                 normalized_ty\n             }\n \n@@ -471,10 +472,12 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> NormalizedTy<'tcx>\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Ty<'tcx>\n {\n-    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth)\n+    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth,\n+                                  obligations)\n         .unwrap_or_else(move || {\n             // if we bottom out in ambiguity, create a type variable\n             // and a deferred predicate to resolve this when more type\n@@ -490,24 +493,29 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             });\n             let obligation = Obligation::with_depth(\n                 cause, depth + 1, param_env, projection.to_predicate());\n-            Normalized {\n-                value: ty_var,\n-                obligations: vec![obligation]\n-            }\n+            obligations.push(obligation);\n+            ty_var\n         })\n }\n \n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n /// which indicates that there are unbound type variables.\n+///\n+/// This function used to return `Option<NormalizedTy<'tcx>>`, which contains a\n+/// `Ty<'tcx>` and an obligations vector. But that obligation vector was very\n+/// often immediately appended to another obligations vector. So now this\n+/// function takes an obligations vector and appends to it directly, which is\n+/// slightly uglier but avoids the need for an extra short-lived allocation.\n fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> Option<NormalizedTy<'tcx>>\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Option<Ty<'tcx>>\n {\n     let infcx = selcx.infcx();\n \n@@ -579,7 +587,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(mut ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+            // This is the hottest path in this function.\n+            //\n             // If we find the value in the cache, then return it along\n             // with the obligations that went along with it. Note\n             // that, when using a fulfillment context, these\n@@ -596,29 +606,32 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if !infcx.any_unresolved_type_vars(&ty.value) {\n-                infcx.projection_cache.borrow_mut().complete(cache_key);\n-                ty.obligations = vec![];\n+                infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n+                // No need to extend `obligations`.\n+            } else {\n+                obligations.extend(ty.obligations);\n             }\n \n-            push_paranoid_cache_value_obligation(infcx,\n-                                                 param_env,\n-                                                 projection_ty,\n-                                                 cause,\n-                                                 depth,\n-                                                 &mut ty);\n-\n-            return Some(ty);\n+            obligations.push(get_paranoid_cache_value_obligation(infcx,\n+                                                                 param_env,\n+                                                                 projection_ty,\n+                                                                 cause,\n+                                                                 depth));\n+            return Some(ty.value);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     found error\");\n-            return Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth));\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            return Some(result.value)\n         }\n     }\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress { ty: projected_ty, mut obligations })) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n+                                            obligations: mut projected_obligations })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n@@ -627,10 +640,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     projected_ty={:?} \\\n                     depth={} \\\n-                    obligations={:?}\",\n+                    projected_obligations={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations);\n+                   projected_obligations);\n \n             let result = if projected_ty.has_projections() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n@@ -644,22 +657,22 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                        normalized_ty,\n                        depth);\n \n-                obligations.extend(normalizer.obligations);\n+                projected_obligations.extend(normalizer.obligations);\n                 Normalized {\n                     value: normalized_ty,\n-                    obligations,\n+                    obligations: projected_obligations,\n                 }\n             } else {\n                 Normalized {\n                     value: projected_ty,\n-                    obligations,\n+                    obligations: projected_obligations,\n                 }\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n             infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n-\n-            Some(result)\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -670,7 +683,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 obligations: vec![]\n             };\n             infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n-            Some(result)\n+            // No need to extend `obligations`.\n+            Some(result.value)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -688,7 +702,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n             infcx.projection_cache.borrow_mut()\n                                   .error(cache_key);\n-            Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth))\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n         }\n     }\n }\n@@ -737,7 +753,7 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// may or may not be necessary -- in principle, all the obligations\n /// that must be proven to show that `T: Trait` were also returned\n /// when the cache was first populated. But there are some vague concerns,\n-/// and so we take the precatuionary measure of including `T: Trait` in\n+/// and so we take the precautionary measure of including `T: Trait` in\n /// the result:\n ///\n /// Concern #1. The current setup is fragile. Perhaps someone could\n@@ -754,19 +770,21 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// that may yet turn out to be wrong.  This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n /// can occur yet.  But it seems risky at best.\n-fn push_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                                                        param_env: ty::ParamEnv<'tcx>,\n-                                                        projection_ty: ty::ProjectionTy<'tcx>,\n-                                                        cause: ObligationCause<'tcx>,\n-                                                        depth: usize,\n-                                                        result: &mut NormalizedTy<'tcx>)\n+fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize)\n+    -> PredicateObligation<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    let trait_obligation = Obligation { cause,\n-                                        recursion_depth: depth,\n-                                        param_env,\n-                                        predicate: trait_ref.to_predicate() };\n-    result.obligations.push(trait_obligation);\n+    Obligation {\n+        cause,\n+        recursion_depth: depth,\n+        param_env,\n+        predicate: trait_ref.to_predicate(),\n+    }\n }\n \n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n@@ -1682,6 +1700,23 @@ impl<'tcx> ProjectionCache<'tcx> {\n         }));\n     }\n \n+    /// A specialized version of `complete` for when the key's value is known\n+    /// to be a NormalizedTy.\n+    pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n+        // We want to insert `ty` with no obligations. If the existing value\n+        // already has no obligations (as is common) we can use `insert_noop`\n+        // to do a minimal amount of work -- the HashMap insertion is skipped,\n+        // and minimal changes are made to the undo log.\n+        if ty.obligations.is_empty() {\n+            self.map.insert_noop();\n+        } else {\n+            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(Normalized {\n+                value: ty.value,\n+                obligations: vec![]\n+            }));\n+        }\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will"}, {"sha": "6ee8c3579f5437c4d0f4602dd5bc339a2abebaee", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -67,6 +67,12 @@ impl<K, V> SnapshotMap<K, V>\n         }\n     }\n \n+    pub fn insert_noop(&mut self) {\n+        if !self.undo_log.is_empty() {\n+            self.undo_log.push(UndoLog::Noop);\n+        }\n+    }\n+\n     pub fn remove(&mut self, key: K) -> bool {\n         match self.map.remove(&key) {\n             Some(old_value) => {"}, {"sha": "a9ac53972e4756cad51c3490b767a73936b89b10", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use rustc::infer::canonical::{Canonical, QueryResult};\n-use rustc::traits::{self, FulfillmentContext, Normalized, ObligationCause,\n-                    SelectionContext};\n+use rustc::traits::{self, FulfillmentContext, ObligationCause, SelectionContext};\n use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n@@ -37,10 +36,9 @@ crate fn normalize_projection_ty<'tcx>(\n         let fulfill_cx = &mut FulfillmentContext::new();\n         let selcx = &mut SelectionContext::new(infcx);\n         let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n-        let Normalized {\n-            value: answer,\n-            obligations,\n-        } = traits::normalize_projection_type(selcx, param_env, goal, cause, 0);\n+        let mut obligations = vec![];\n+        let answer =\n+            traits::normalize_projection_type(selcx, param_env, goal, cause, 0, &mut obligations);\n         fulfill_cx.register_predicate_obligations(infcx, obligations);\n \n         // Now that we have fulfilled as much as we can, create a solution"}, {"sha": "4274e5c1e1f7562d75d70d54059f5f758b3c68ac", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -129,20 +129,20 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         let mut selcx = traits::SelectionContext::new(self.fcx);\n-        let normalized = traits::normalize_projection_type(&mut selcx,\n-                                                           self.fcx.param_env,\n-                                                           ty::ProjectionTy::from_ref_and_name(\n-                                                               tcx,\n-                                                               trait_ref,\n-                                                               Symbol::intern(\"Target\"),\n-                                                           ),\n-                                                           cause,\n-                                                           0);\n-\n-        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized);\n-        self.obligations.extend(normalized.obligations);\n-\n-        Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n+        let normalized_ty = traits::normalize_projection_type(&mut selcx,\n+                                                              self.fcx.param_env,\n+                                                              ty::ProjectionTy::from_ref_and_name(\n+                                                                  tcx,\n+                                                                  trait_ref,\n+                                                                  Symbol::intern(\"Target\"),\n+                                                              ),\n+                                                              cause,\n+                                                              0,\n+                                                              &mut self.obligations);\n+\n+        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized_ty);\n+\n+        Some(self.fcx.resolve_type_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an"}, {"sha": "b22098408a332f06623bc2e29aeede2c28b3fa8e", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -767,9 +767,12 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     }\n \n     if !parser.errors.is_empty() {\n-        let (err, note) = parser.errors.remove(0);\n-        let mut e = cx.ecx.struct_span_err(cx.fmtsp, &format!(\"invalid format string: {}\", err));\n-        if let Some(note) = note {\n+        let err = parser.errors.remove(0);\n+        let sp = cx.fmtsp.from_inner_byte_pos(err.start, err.end);\n+        let mut e = cx.ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n+                                                        err.description));\n+        e.span_label(sp, err.label + \" in format string\");\n+        if let Some(note) = err.note {\n             e.note(&note);\n         }\n         e.emit();"}, {"sha": "73f0e6a60181f489e51dd4d2a29f8d378f80aede", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -428,6 +428,13 @@ impl Span {\n         )\n     }\n \n+    pub fn from_inner_byte_pos(self, start: usize, end: usize) -> Span {\n+        let span = self.data();\n+        Span::new(span.lo + BytePos::from_usize(start),\n+                  span.lo + BytePos::from_usize(end),\n+                  span.ctxt)\n+    }\n+\n     #[inline]\n     pub fn apply_mark(self, mark: Mark) -> Span {\n         let span = self.data();"}, {"sha": "f94780682a0c0f33893651b8ad4f7864abfaa271", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -101,7 +101,7 @@ impl<T: Write> PrettyFormatter<T> {\n         for &(ref f, ref stdout) in &state.not_failures {\n             successes.push(f.name.to_string());\n             if !stdout.is_empty() {\n-                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 stdouts.push_str(&output);\n                 stdouts.push_str(\"\\n\");\n@@ -127,7 +127,7 @@ impl<T: Write> PrettyFormatter<T> {\n         for &(ref f, ref stdout) in &state.failures {\n             failures.push(f.name.to_string());\n             if !stdout.is_empty() {\n-                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 fail_out.push_str(&output);\n                 fail_out.push_str(\"\\n\");"}, {"sha": "22a06b9f605dbdc66f5b70bdfb2fd84b5b079141", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -105,7 +105,7 @@ impl<T: Write> TerseFormatter<T> {\n         for &(ref f, ref stdout) in &state.not_failures {\n             successes.push(f.name.to_string());\n             if !stdout.is_empty() {\n-                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 stdouts.push_str(&output);\n                 stdouts.push_str(\"\\n\");\n@@ -131,7 +131,7 @@ impl<T: Write> TerseFormatter<T> {\n         for &(ref f, ref stdout) in &state.failures {\n             failures.push(f.name.to_string());\n             if !stdout.is_empty() {\n-                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 fail_out.push_str(&output);\n                 fail_out.push_str(\"\\n\");"}, {"sha": "7dabb1bddea77e1877837d4bdcba726c261bd477", "filename": "src/test/COMPILER_TESTS.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2FCOMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2FCOMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2FCOMPILER_TESTS.md?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -140,13 +140,9 @@ check that the test compiles successfully.\n ### Editing and updating the reference files\n \n If you have changed the compiler's output intentionally, or you are\n-making a new test, you can use the script `ui/update-references.sh` to\n-update the references. When you run the test framework, it will report\n-various errors: in those errors is a command you can use to run the\n-`ui/update-references.sh` script, which will then copy over the files\n-from the build directory and use them as the new reference. You can\n-also just run `ui/update-all-references.sh`. In both cases, you can run\n-the script with `--help` to get a help message.\n+making a new test, you can pass `--bless` to the command you used to\n+run the tests. This will then copy over the files\n+from the build directory and use them as the new reference.\n \n ### Normalization\n "}, {"sha": "28403644a234af55a0ee3760042cd9a711d01f3e", "filename": "src/test/ui/E0508.ast.nll.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.ast.nll.stderr?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -0,0 +1,9 @@\n+error[E0508]: cannot move out of type `[NonCopy; 1]`, a non-copy array\n+  --> $DIR/E0508.rs:18:18\n+   |\n+LL |     let _value = array[0];  //[ast]~ ERROR [E0508]\n+   |                  ^^^^^^^^ cannot move out of here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "5878b795b771ca30432e1160020474a08058bf18", "filename": "src/test/ui/E0508.ast.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.ast.stderr?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -0,0 +1,12 @@\n+error[E0508]: cannot move out of type `[NonCopy; 1]`, a non-copy array\n+  --> $DIR/E0508.rs:18:18\n+   |\n+LL |     let _value = array[0];  //[ast]~ ERROR [E0508]\n+   |                  ^^^^^^^^\n+   |                  |\n+   |                  cannot move out of here\n+   |                  help: consider using a reference instead: `&array[0]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "28403644a234af55a0ee3760042cd9a711d01f3e", "filename": "src/test/ui/E0508.mir.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.mir.stderr?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -0,0 +1,9 @@\n+error[E0508]: cannot move out of type `[NonCopy; 1]`, a non-copy array\n+  --> $DIR/E0508.rs:18:18\n+   |\n+LL |     let _value = array[0];  //[ast]~ ERROR [E0508]\n+   |                  ^^^^^^^^ cannot move out of here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "0c3dce6b0346a78950348aa5acfd47d733ee0ccc", "filename": "src/test/ui/E0508.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2FE0508.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = array[0];  //[ast]~ ERROR [E0508]\n+                            //[mir]~^ ERROR [E0508]\n+}"}, {"sha": "5b13686240e7c0de46e71ec8a31c981b6f55782d", "filename": "src/test/ui/fmt/format-string-error.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -12,5 +12,14 @@ fn main() {\n     println!(\"{\");\n     println!(\"{{}}\");\n     println!(\"}\");\n+    let _ = format!(\"{_foo}\", _foo = 6usize);\n+    //~^ ERROR invalid format string: invalid argument name `_foo`\n+    let _ = format!(\"{_}\", _ = 6usize);\n+    //~^ ERROR invalid format string: invalid argument name `_`\n+    let _ = format!(\"{\");\n+    //~^ ERROR invalid format string: expected `'}'` but string was terminated\n+    let _ = format!(\"}\");\n+    //~^ ERROR invalid format string: unmatched `}` found\n+    let _ = format!(\"{\\\\}\");\n+    //~^ ERROR invalid format string: expected `'}'`, found `'\\\\'`\n }\n-"}, {"sha": "ff766ddc8fa67ad132d1d1e137e4fc7ca427760a", "filename": "src/test/ui/fmt/format-string-error.stderr", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -2,7 +2,7 @@ error: invalid format string: expected `'}'` but string was terminated\n   --> $DIR/format-string-error.rs:12:5\n    |\n LL |     println!(\"{\");\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ expected `'}'` in format string\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n@@ -11,10 +11,48 @@ error: invalid format string: unmatched `}` found\n   --> $DIR/format-string-error.rs:14:5\n    |\n LL |     println!(\"}\");\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ unmatched `}` in format string\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: aborting due to 2 previous errors\n+error: invalid format string: invalid argument name `_foo`\n+  --> $DIR/format-string-error.rs:15:23\n+   |\n+LL |     let _ = format!(\"{_foo}\", _foo = 6usize);\n+   |                       ^^^^ invalid argument name in format string\n+   |\n+   = note: argument names cannot start with an underscore\n+\n+error: invalid format string: invalid argument name `_`\n+  --> $DIR/format-string-error.rs:17:23\n+   |\n+LL |     let _ = format!(\"{_}\", _ = 6usize);\n+   |                       ^ invalid argument name in format string\n+   |\n+   = note: argument names cannot start with an underscore\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/format-string-error.rs:19:23\n+   |\n+LL |     let _ = format!(\"{\");\n+   |                       ^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/format-string-error.rs:21:22\n+   |\n+LL |     let _ = format!(\"}\");\n+   |                      ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: invalid format string: expected `'}'`, found `'/'`\n+  --> $DIR/format-string-error.rs:23:23\n+   |\n+LL |     let _ = format!(\"{/}\");\n+   |                       ^ expected `}` in format string\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "b2ce5ce52f719ef2c073f83e946e3370150cecba", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -118,6 +118,9 @@ impl CompareMode {\n \n #[derive(Clone)]\n pub struct Config {\n+    /// Whether to overwrite stderr/stdout files instead of complaining about changes in output\n+    pub bless: bool,\n+\n     /// The library paths required for running the compiler\n     pub compile_lib_path: PathBuf,\n "}, {"sha": "2bfc1ece09590687d7df1001a544b861cbccad22", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -166,6 +166,11 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             \"FLAGS\",\n         )\n         .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n+        .optflag(\n+            \"\",\n+            \"bless\",\n+            \"overwrite stderr/stdout files instead of complaining about a mismatch\",\n+        )\n         .optflag(\n             \"\",\n             \"quiet\",\n@@ -290,6 +295,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n     let src_base = opt_path(matches, \"src-base\");\n     let run_ignored = matches.opt_present(\"ignored\");\n     Config {\n+        bless: matches.opt_present(\"bless\"),\n         compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n         run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n         rustc_path: opt_path(matches, \"rustc-path\"),"}, {"sha": "49d3dec0a58b29e23bcd379174d212d4b9ec5137", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 62, "deletions": 34, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "patch": "@@ -2596,15 +2596,13 @@ impl<'test> TestCx<'test> {\n         }\n \n         if errors > 0 {\n-            println!(\"To update references, run this command from build directory:\");\n+            println!(\"To update references, rerun the tests and pass the `--bless` flag\");\n             let relative_path_to_file = self.testpaths\n                 .relative_dir\n                 .join(self.testpaths.file.file_name().unwrap());\n             println!(\n-                \"{}/update-references.sh '{}' '{}'\",\n-                self.config.src_base.display(),\n-                self.config.build_base.display(),\n-                relative_path_to_file.display()\n+                \"To only update this specific test, also pass `--test-args {}`\",\n+                relative_path_to_file.display(),\n             );\n             self.fatal_proc_rec(\n                 &format!(\"{} errors occurred comparing output.\", errors),\n@@ -2926,29 +2924,31 @@ impl<'test> TestCx<'test> {\n             return 0;\n         }\n \n-        if expected.is_empty() {\n-            println!(\"normalized {}:\\n{}\\n\", kind, actual);\n-        } else {\n-            println!(\"diff of {}:\\n\", kind);\n-            let diff_results = make_diff(expected, actual, 3);\n-            for result in diff_results {\n-                let mut line_number = result.line_number;\n-                for line in result.lines {\n-                    match line {\n-                        DiffLine::Expected(e) => {\n-                            println!(\"-\\t{}\", e);\n-                            line_number += 1;\n-                        }\n-                        DiffLine::Context(c) => {\n-                            println!(\"{}\\t{}\", line_number, c);\n-                            line_number += 1;\n-                        }\n-                        DiffLine::Resulting(r) => {\n-                            println!(\"+\\t{}\", r);\n+        if !self.config.bless {\n+            if expected.is_empty() {\n+                println!(\"normalized {}:\\n{}\\n\", kind, actual);\n+            } else {\n+                println!(\"diff of {}:\\n\", kind);\n+                let diff_results = make_diff(expected, actual, 3);\n+                for result in diff_results {\n+                    let mut line_number = result.line_number;\n+                    for line in result.lines {\n+                        match line {\n+                            DiffLine::Expected(e) => {\n+                                println!(\"-\\t{}\", e);\n+                                line_number += 1;\n+                            }\n+                            DiffLine::Context(c) => {\n+                                println!(\"{}\\t{}\", line_number, c);\n+                                line_number += 1;\n+                            }\n+                            DiffLine::Resulting(r) => {\n+                                println!(\"+\\t{}\", r);\n+                            }\n                         }\n                     }\n+                    println!(\"\");\n                 }\n-                println!(\"\");\n             }\n         }\n \n@@ -2958,19 +2958,47 @@ impl<'test> TestCx<'test> {\n             .with_extra_extension(mode)\n             .with_extra_extension(kind);\n \n-        match File::create(&output_file).and_then(|mut f| f.write_all(actual.as_bytes())) {\n-            Ok(()) => {}\n-            Err(e) => self.fatal(&format!(\n-                \"failed to write {} to `{}`: {}\",\n+        let mut files = vec![output_file];\n+        if self.config.bless {\n+            files.push(expected_output_path(\n+                self.testpaths,\n+                self.revision,\n+                &self.config.compare_mode,\n                 kind,\n-                output_file.display(),\n-                e\n-            )),\n+            ));\n+        }\n+\n+        for output_file in &files {\n+            if actual.is_empty() {\n+                if let Err(e) = ::std::fs::remove_file(output_file) {\n+                    self.fatal(&format!(\n+                        \"failed to delete `{}`: {}\",\n+                        output_file.display(),\n+                        e,\n+                    ));\n+                }\n+            } else {\n+                match File::create(&output_file).and_then(|mut f| f.write_all(actual.as_bytes())) {\n+                    Ok(()) => {}\n+                    Err(e) => self.fatal(&format!(\n+                        \"failed to write {} to `{}`: {}\",\n+                        kind,\n+                        output_file.display(),\n+                        e\n+                    )),\n+                }\n+            }\n         }\n \n         println!(\"\\nThe actual {0} differed from the expected {0}.\", kind);\n-        println!(\"Actual {} saved to {}\", kind, output_file.display());\n-        1\n+        for output_file in files {\n+            println!(\"Actual {} saved to {}\", kind, output_file.display());\n+        }\n+        if self.config.bless {\n+            0\n+        } else {\n+            1\n+        }\n     }\n \n     fn create_stamp(&self) {"}]}