{"sha": "b9f4e0dbfd3181f9f57a650e7451c807116c5921", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZjRlMGRiZmQzMTgxZjlmNTdhNjUwZTc0NTFjODA3MTE2YzU5MjE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-06-26T09:02:43Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-06-28T10:03:19Z"}, "message": "Erase all block-only locals at the end of every block, even if they have not been touched.", "tree": {"sha": "33ea71f44f6ff44decc3291ab04d14ce78e255d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ea71f44f6ff44decc3291ab04d14ce78e255d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9f4e0dbfd3181f9f57a650e7451c807116c5921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9f4e0dbfd3181f9f57a650e7451c807116c5921", "html_url": "https://github.com/rust-lang/rust/commit/b9f4e0dbfd3181f9f57a650e7451c807116c5921", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9f4e0dbfd3181f9f57a650e7451c807116c5921/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "394e1b40d264aa6928811919c1124fa248e7d802", "url": "https://api.github.com/repos/rust-lang/rust/commits/394e1b40d264aa6928811919c1124fa248e7d802", "html_url": "https://github.com/rust-lang/rust/commit/394e1b40d264aa6928811919c1124fa248e7d802"}], "stats": {"total": 106, "additions": 90, "deletions": 16}, "files": [{"sha": "c828931808138232ba2ec573b63e7db1b4b128c8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b9f4e0dbfd3181f9f57a650e7451c807116c5921", "patch": "@@ -131,6 +131,10 @@ pub enum LocalValue<Tag = ()> {\n }\n \n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n+    /// Read the local's value or error if the local is not yet live or not live anymore.\n+    ///\n+    /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n+    /// anywhere else. You may be invalidating machine invariants if you do!\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n             LocalValue::Dead => throw_ub!(DeadLocal),\n@@ -143,6 +147,9 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n \n     /// Overwrite the local.  If the local can be overwritten in place, return a reference\n     /// to do so; otherwise return the `MemPlace` to consult instead.\n+    ///\n+    /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n+    /// anywhere else. You may be invalidating machine invariants if you do!\n     pub fn access_mut(\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {"}, {"sha": "ec1c93c81657ee2e733c7306239d072f580be88d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b9f4e0dbfd3181f9f57a650e7451c807116c5921", "patch": "@@ -11,7 +11,7 @@ use rustc_span::def_id::DefId;\n \n use super::{\n     AllocId, Allocation, AllocationExtra, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult,\n-    Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n+    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -192,6 +192,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx>;\n \n     /// Called to read the specified `local` from the `frame`.\n+    /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n+    /// for ZST reads.\n     #[inline]\n     fn access_local(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n@@ -201,6 +203,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame.locals[local].access()\n     }\n \n+    /// Called to write the specified `local` from the `frame`.\n+    /// Since writing a ZST is not actually accessing memory or locals, this is never invoked\n+    /// for ZST reads.\n+    #[inline]\n+    fn access_local_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+        frame: usize,\n+        local: mir::Local,\n+    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    where\n+        'tcx: 'mir,\n+    {\n+        ecx.stack_mut()[frame].locals[local].access_mut()\n+    }\n+\n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n     #[inline]"}, {"sha": "402bfc93361cf96d1268e2d9aed4c969d6f1ce66", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b9f4e0dbfd3181f9f57a650e7451c807116c5921", "patch": "@@ -432,7 +432,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n-    /// This is used by [priroda](https://github.com/oli-obk/priroda) to get an OpTy from a local\n+    /// Read from a local. Will not actually access the local if reading from a ZST.\n+    /// Will not access memory, instead an indirect `Operand` is returned.\n+    ///\n+    /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n+    /// OpTy from a local\n     pub fn access_local(\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,"}, {"sha": "f9729c5ad2feeafd3e5702af8705f306eac136c7", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b9f4e0dbfd3181f9f57a650e7451c807116c5921", "patch": "@@ -740,7 +740,7 @@ where\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match self.stack_mut()[frame].locals[local].access_mut()? {\n+                match M::access_local_mut(self, frame, local)? {\n                     Ok(local) => {\n                         // Local can be updated in-place.\n                         *local = LocalValue::Live(Operand::Immediate(src));\n@@ -973,7 +973,7 @@ where\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n-                match self.stack_mut()[frame].locals[local].access_mut()? {\n+                match M::access_local_mut(self, frame, local)? {\n                     Ok(&mut local_val) => {\n                         // We need to make an allocation.\n \n@@ -997,7 +997,7 @@ where\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n-                        *self.stack_mut()[frame].locals[local].access_mut().unwrap().unwrap() =\n+                        *M::access_local_mut(self, frame, local).unwrap().unwrap() =\n                             LocalValue::Live(Operand::Indirect(mplace));\n                         (mplace, Some(size))\n                     }"}, {"sha": "5da36ac1cf66e0275bf2c4235caf0f13c4aaf1fa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f4e0dbfd3181f9f57a650e7451c807116c5921/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b9f4e0dbfd3181f9f57a650e7451c807116c5921", "patch": "@@ -4,6 +4,7 @@\n use std::cell::Cell;\n \n use rustc_ast::ast::Mutability;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n@@ -28,7 +29,7 @@ use rustc_trait_selection::traits;\n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx, LocalState,\n-    LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n+    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n@@ -151,11 +152,19 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n+    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n+    written_only_inside_own_block_locals: FxHashSet<Local>,\n+    /// Locals that need to be cleared after every block terminates.\n+    only_propagate_inside_block_locals: BitSet<Local>,\n }\n \n impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n-    fn new() -> Self {\n-        Self { stack: Vec::new() }\n+    fn new(only_propagate_inside_block_locals: BitSet<Local>) -> Self {\n+        Self {\n+            stack: Vec::new(),\n+            written_only_inside_own_block_locals: Default::default(),\n+            only_propagate_inside_block_locals,\n+        }\n     }\n }\n \n@@ -227,6 +236,18 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         l.access()\n     }\n \n+    fn access_local_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+        frame: usize,\n+        local: Local,\n+    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    {\n+        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n+            ecx.machine.written_only_inside_own_block_locals.insert(local);\n+        }\n+        ecx.machine.stack[frame].locals[local].access_mut()\n+    }\n+\n     fn before_access_global(\n         _memory_extra: &(),\n         _alloc_id: AllocId,\n@@ -274,8 +295,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,\n-    // Locals we need to forget at the end of the current block\n-    locals_of_current_block: BitSet<Local>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -313,8 +332,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx, span, param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n+        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n+        for (l, mode) in can_const_prop.iter_enumerated() {\n+            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n+                only_propagate_inside_block_locals.insert(l);\n+            }\n+        }\n+        let mut ecx = InterpCx::new(\n+            tcx,\n+            span,\n+            param_env,\n+            ConstPropMachine::new(only_propagate_inside_block_locals),\n+            (),\n+        );\n \n         let ret = ecx\n             .layout_of(body.return_ty().subst(tcx, substs))\n@@ -345,7 +376,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             source_info: None,\n-            locals_of_current_block: BitSet::new_empty(body.local_decls.len()),\n         }\n     }\n \n@@ -899,7 +929,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n                                 place.local\n                             );\n-                            self.locals_of_current_block.insert(place.local);\n                         }\n                         ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n                             trace!(\"can't propagate into {:?}\", place);\n@@ -1088,10 +1117,27 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 }\n             }\n         }\n-        // We remove all Locals which are restricted in propagation to their containing blocks.\n-        for local in self.locals_of_current_block.iter() {\n+\n+        // We remove all Locals which are restricted in propagation to their containing blocks and\n+        // which were modified in the current block.\n+        // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`\n+        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n+        for &local in locals.iter() {\n             Self::remove_const(&mut self.ecx, local);\n         }\n-        self.locals_of_current_block.clear();\n+        locals.clear();\n+        // Put it back so we reuse the heap of the storage\n+        self.ecx.machine.written_only_inside_own_block_locals = locals;\n+        if cfg!(debug_assertions) {\n+            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n+            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n+                assert!(\n+                    self.get_const(local.into()).is_none()\n+                        || self\n+                            .layout_of(self.local_decls[local].ty)\n+                            .map_or(true, |layout| layout.is_zst())\n+                )\n+            }\n+        }\n     }\n }"}]}