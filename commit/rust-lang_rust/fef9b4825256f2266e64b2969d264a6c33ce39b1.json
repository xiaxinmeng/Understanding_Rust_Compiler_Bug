{"sha": "fef9b4825256f2266e64b2969d264a6c33ce39b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZjliNDgyNTI1NmYyMjY2ZTY0YjI5NjlkMjY0YTZjMzNjZTM5YjE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-23T16:03:40Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-24T15:05:27Z"}, "message": "Make dist equivalent to old build system.", "tree": {"sha": "fc1c28ea88a0b6b0304657c9950cc164a87932ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc1c28ea88a0b6b0304657c9950cc164a87932ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fef9b4825256f2266e64b2969d264a6c33ce39b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fef9b4825256f2266e64b2969d264a6c33ce39b1", "html_url": "https://github.com/rust-lang/rust/commit/fef9b4825256f2266e64b2969d264a6c33ce39b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fef9b4825256f2266e64b2969d264a6c33ce39b1/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a88a09c7162b2a5011bb20b9b0c76d080207fe12", "url": "https://api.github.com/repos/rust-lang/rust/commits/a88a09c7162b2a5011bb20b9b0c76d080207fe12", "html_url": "https://github.com/rust-lang/rust/commit/a88a09c7162b2a5011bb20b9b0c76d080207fe12"}], "stats": {"total": 170, "additions": 82, "deletions": 88}, "files": [{"sha": "472bfafc20a368d3cc4bdea812090ca922d31af6", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fef9b4825256f2266e64b2969d264a6c33ce39b1/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fef9b4825256f2266e64b2969d264a6c33ce39b1/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=fef9b4825256f2266e64b2969d264a6c33ce39b1", "patch": "@@ -535,7 +535,7 @@ impl Step for Compiletest {\n \n             builder.ensure(dist::DebuggerScripts {\n                 sysroot: builder.sysroot(compiler),\n-                target: target\n+                host: target\n             });\n         }\n "}, {"sha": "e9256c6b3f2b698af013e432e51df25813dd2e1e", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 77, "deletions": 85, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fef9b4825256f2266e64b2969d264a6c33ce39b1/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fef9b4825256f2266e64b2969d264a6c33ce39b1/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fef9b4825256f2266e64b2969d264a6c33ce39b1", "patch": "@@ -28,7 +28,7 @@ use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, exe};\n+use util::{cp_r, libdir, is_dylib, cp_filtered, copy};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use tool::{self, Tool};\n@@ -60,11 +60,11 @@ fn rust_installer(builder: &Builder) -> Command {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n     pub stage: u32,\n-    pub target: Interned<String>,\n+    pub host: Interned<String>,\n }\n \n impl Step for Docs {\n-    type Output = Option<PathBuf>;\n+    type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n@@ -75,33 +75,31 @@ impl Step for Docs {\n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Docs {\n             stage: run.builder.top_stage,\n-            target: run.target,\n+            host: run.target,\n         });\n     }\n \n     /// Builds the `rust-docs` installer component.\n-    ///\n-    /// Slurps up documentation from the `stage`'s `target`.\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        let stage = self.stage;\n-        let target = self.target;\n+        let host = self.host;\n \n-        builder.default_doc(None);\n+        let name = pkgname(build, \"rust-docs\");\n \n-        println!(\"Dist docs stage{} ({})\", stage, target);\n+        println!(\"Dist docs ({})\", host);\n         if !build.config.docs {\n             println!(\"\\tskipping - docs disabled\");\n-            return None;\n+            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n-        let name = pkgname(build, \"rust-docs\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        builder.default_doc(None);\n+\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.out.join(target).join(\"doc\");\n+        let src = build.out.join(host).join(\"doc\");\n         cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n@@ -112,7 +110,7 @@ impl Step for Docs {\n            .arg(\"--image-dir\").arg(&image)\n            .arg(\"--work-dir\").arg(&tmpdir(build))\n            .arg(\"--output-dir\").arg(&distdir(build))\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rust-docs\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n@@ -121,13 +119,13 @@ impl Step for Docs {\n \n         // As part of this step, *also* copy the docs directory to a directory which\n         // buildbot typically uploads.\n-        if target == build.build {\n+        if host == build.build {\n             let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n             t!(fs::create_dir_all(&dst));\n             cp_r(&src, &dst);\n         }\n \n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n \n@@ -261,7 +259,7 @@ fn make_win_dist(\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    target: Interned<String>,\n+    host: Interned<String>,\n }\n \n impl Step for Mingw {\n@@ -274,7 +272,7 @@ impl Step for Mingw {\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Mingw { target: run.target });\n+        run.builder.ensure(Mingw { host: run.target });\n     }\n \n     /// Build the `rust-mingw` installer component.\n@@ -283,23 +281,23 @@ impl Step for Mingw {\n     /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n-        let target = self.target;\n+        let host = self.host;\n \n-        if !target.contains(\"pc-windows-gnu\") {\n+        if !host.contains(\"pc-windows-gnu\") {\n             return None;\n         }\n \n-        println!(\"Dist mingw ({})\", target);\n+        println!(\"Dist mingw ({})\", host);\n         let name = pkgname(build, \"rust-mingw\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n         t!(fs::create_dir_all(&image));\n \n         // The first argument is a \"temporary directory\" which is just\n         // thrown away (this contains the runtime DLLs included in the rustc package\n         // above) and the second argument is where to place all the MinGW components\n         // (which is what we want).\n-        make_win_dist(&tmpdir(build), &image, target, &build);\n+        make_win_dist(&tmpdir(build), &image, host, &build);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -309,19 +307,18 @@ impl Step for Mingw {\n            .arg(\"--image-dir\").arg(&image)\n            .arg(\"--work-dir\").arg(&tmpdir(build))\n            .arg(\"--output-dir\").arg(&distdir(build))\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rust-mingw\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, host)))\n     }\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n-    pub stage: u32,\n-    pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Rustc {\n@@ -336,30 +333,25 @@ impl Step for Rustc {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Rustc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n+            compiler: run.builder.compiler(run.builder.top_stage, run.target),\n         });\n     }\n \n     /// Creates the `rustc` installer component.\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        let stage = self.stage;\n-        let target = self.target;\n-\n-        let compiler = builder.ensure(compile::Assemble {\n-            target_compiler: builder.compiler(stage, build.build),\n-        });\n+        let compiler = self.compiler;\n+        let host = self.compiler.host;\n \n-        println!(\"Dist rustc stage{} ({})\", stage, target);\n+        println!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host);\n         let name = pkgname(build, \"rustc\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n-        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, target));\n+        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, host));\n         let _ = fs::remove_dir_all(&overlay);\n \n         // Prepare the rustc \"image\", what will actually end up getting installed\n-        prepare_image(builder, compiler, target, &image);\n+        prepare_image(builder, compiler, &image);\n \n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n@@ -384,8 +376,8 @@ impl Step for Rustc {\n         // anything requiring us to distribute a license, but it's likely the\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n-        if target.contains(\"pc-windows-gnu\") {\n-            make_win_dist(&image, &tmpdir(build), target, build);\n+        if host.contains(\"pc-windows-gnu\") {\n+            make_win_dist(&image, &tmpdir(build), host, build);\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n@@ -402,21 +394,20 @@ impl Step for Rustc {\n            .arg(\"--work-dir\").arg(&tmpdir(build))\n            .arg(\"--output-dir\").arg(&distdir(build))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n         t!(fs::remove_dir_all(&overlay));\n \n-        return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n+        return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n \n-        fn prepare_image(\n-            builder: &Builder, compiler: Compiler, target: Interned<String>, image: &Path\n-        ) {\n+        fn prepare_image(builder: &Builder, compiler: Compiler, image: &Path) {\n+            let host = compiler.host;\n             let build = builder.build;\n             let src = builder.sysroot(compiler);\n-            let libdir = libdir(&target);\n+            let libdir = libdir(&host);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n@@ -441,7 +432,7 @@ impl Step for Rustc {\n             // Debugger scripts\n             builder.ensure(DebuggerScripts {\n                 sysroot: INTERNER.intern_path(image.to_owned()),\n-                target: target,\n+                host,\n             });\n \n             // Misc license info\n@@ -459,7 +450,7 @@ impl Step for Rustc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct DebuggerScripts {\n     pub sysroot: Interned<PathBuf>,\n-    pub target: Interned<String>,\n+    pub host: Interned<String>,\n }\n \n impl Step for DebuggerScripts {\n@@ -472,21 +463,21 @@ impl Step for DebuggerScripts {\n     fn make_run(run: RunConfig) {\n         run.builder.ensure(DebuggerScripts {\n             sysroot: run.builder.sysroot(run.builder.compiler(run.builder.top_stage, run.host)),\n-            target: run.target,\n+            host: run.target,\n         });\n     }\n \n     /// Copies debugger scripts for `target` into the `sysroot` specified.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let target = self.target;\n+        let host = self.host;\n         let sysroot = self.sysroot;\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n             install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n-        if target.contains(\"windows-msvc\") {\n+        if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n             install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n@@ -519,7 +510,7 @@ pub struct Std {\n }\n \n impl Step for Std {\n-    type Output = Option<PathBuf>;\n+    type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n@@ -534,19 +525,19 @@ impl Step for Std {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host,\n-                 target);\n+        let name = pkgname(build, \"rust-std\");\n+        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target);\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n         if compiler.host != build.build {\n             println!(\"\\tskipping, not a build host\");\n-            return None;\n+            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n         // We want to package up as many target libraries as possible\n@@ -558,7 +549,6 @@ impl Step for Std {\n             builder.ensure(compile::Test { compiler, target });\n         }\n \n-        let name = pkgname(build, \"rust-std\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n \n@@ -581,7 +571,7 @@ impl Step for Std {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -592,7 +582,7 @@ pub struct Analysis {\n }\n \n impl Step for Analysis {\n-    type Output = Option<PathBuf>;\n+    type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n@@ -609,18 +599,21 @@ impl Step for Analysis {\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(build.config.extended);\n         println!(\"Dist analysis\");\n+        let name = pkgname(build, \"rust-analysis\");\n \n         if &compiler.host != build.build {\n             println!(\"\\tskipping, not a build host\");\n-            return None;\n+            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n+        builder.ensure(Std { compiler, target });\n+\n         // Package save-analysis from stage1 if not doing a full bootstrap, as the\n         // stage2 artifacts is simply copied from stage1 in that case.\n         let compiler = if build.force_use_stage1(compiler, target) {\n@@ -629,7 +622,6 @@ impl Step for Analysis {\n             compiler.clone()\n         };\n \n-        let name = pkgname(build, \"rust-analysis\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n \n         let src = build.stage_out(compiler, Mode::Libstd)\n@@ -654,7 +646,7 @@ impl Step for Analysis {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -956,11 +948,7 @@ impl Step for Cargo {\n         let stage = self.stage;\n         let target = self.target;\n \n-        builder.ensure(tool::Cargo { stage, target });\n-\n         println!(\"Dist cargo stage{} ({})\", stage, target);\n-        let compiler = builder.compiler(stage, build.build);\n-\n         let src = build.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = build.release_num(\"cargo\");\n@@ -975,8 +963,7 @@ impl Step for Cargo {\n         // Prepare the image directory\n         t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n         t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n-        let cargo = build.cargo_out(compiler, Mode::Tool, target)\n-                         .join(exe(\"cargo\", &target));\n+        let cargo = builder.ensure(tool::Cargo { stage, target });\n         install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n@@ -1047,11 +1034,7 @@ impl Step for Rls {\n         let target = self.target;\n         assert!(build.config.extended);\n \n-        builder.ensure(tool::Rls { stage, target });\n-\n         println!(\"Dist RLS stage{} ({})\", stage, target);\n-        let compiler = builder.compiler(stage, build.build);\n-\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n         let name = pkgname(build, \"rls\");\n@@ -1063,8 +1046,7 @@ impl Step for Rls {\n         t!(fs::create_dir_all(&image));\n \n         // Prepare the image directory\n-        let rls = build.cargo_out(compiler, Mode::Tool, target)\n-                         .join(exe(\"rls\", &target));\n+        let rls = builder.ensure(tool::Rls { stage, target });\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n         install(&src.join(\"README.md\"), &doc, 0o644);\n@@ -1101,6 +1083,7 @@ impl Step for Rls {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n+    host: Interned<String>,\n     target: Interned<String>,\n }\n \n@@ -1112,12 +1095,13 @@ impl Step for Extended {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"cargo\").default_condition(builder.config.extended)\n+        run.path(\"extended\").default_condition(builder.config.extended)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n+            host: run.host,\n             target: run.target,\n         });\n     }\n@@ -1127,17 +1111,25 @@ impl Step for Extended {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        let compiler = builder.compiler(stage, build.build);\n \n         println!(\"Dist extended stage{} ({})\", stage, target);\n \n-        let rustc_installer = builder.ensure(Rustc { stage, target });\n+        let rustc_installer = builder.ensure(Rustc {\n+            compiler: builder.compiler(stage, target),\n+        });\n         let cargo_installer = builder.ensure(Cargo { stage, target });\n         let rls_installer = builder.ensure(Rls { stage, target });\n-        let analysis_installer = builder.ensure(Analysis { compiler, target }).unwrap();\n-        let docs_installer = builder.ensure(Docs { stage, target }).unwrap();\n-        let mingw_installer = builder.ensure(Mingw { target });\n-        let std_installer = builder.ensure(Std { compiler, target }).unwrap();\n+        let mingw_installer = builder.ensure(Mingw { host: target });\n+        let analysis_installer = builder.ensure(Analysis {\n+            compiler: builder.compiler(stage, self.host),\n+            target\n+        });\n+\n+        let docs_installer = builder.ensure(Docs { stage, host: target, });\n+        let std_installer = builder.ensure(Std {\n+            compiler: builder.compiler(stage, self.host),\n+            target,\n+        });\n \n         let tmp = tmpdir(build);\n         let overlay = tmp.join(\"extended-overlay\");"}, {"sha": "ebfda1e619bd80cae0f56d95b98007a3699abdac", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fef9b4825256f2266e64b2969d264a6c33ce39b1/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fef9b4825256f2266e64b2969d264a6c33ce39b1/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=fef9b4825256f2266e64b2969d264a6c33ce39b1", "patch": "@@ -171,7 +171,7 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { stage: self.stage, target: self.target });\n+        builder.ensure(dist::Docs { stage: self.stage, host: self.target });\n         install_docs(builder, self.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n@@ -201,7 +201,9 @@ install!((self, builder, _config),\n         install_src(builder, self.stage);\n     }, ONLY_BUILD;\n     Rustc, \"src/librustc\", _config.extended, only_hosts: true, {\n-        builder.ensure(dist::Rustc { stage: self.stage, target: self.target });\n+        builder.ensure(dist::Rustc {\n+            compiler: builder.compiler(self.stage, self.target),\n+        });\n         install_rustc(builder, self.stage, self.target);\n     };\n );"}]}