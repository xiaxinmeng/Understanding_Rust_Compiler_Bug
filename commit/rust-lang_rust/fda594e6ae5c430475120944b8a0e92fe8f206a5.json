{"sha": "fda594e6ae5c430475120944b8a0e92fe8f206a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYTU5NGU2YWU1YzQzMDQ3NTEyMDk0NGI4YTBlOTJmZThmMjA2YTU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-10T09:03:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-10T09:03:40Z"}, "message": "Rollup merge of #72890 - davidtwco:issue-66202-normalize-and-transparent-improper-ctypes, r=varkor\n\nimproper ctypes: normalize return types and transparent structs\n\nFixes #66202.\n\nSee each commit individually (except the first which adds a test) for more detailed explanations on the changes made.\n\nIn summary, this PR ensures that return types are normalized before being checked for FFI-safety, and that transparent newtype wrappers are FFI-safe if the type being wrapped is FFI-safe (often true previously, but not if, after substitution, all types in a transparent newtype were zero sized).", "tree": {"sha": "30f9257724dfd7072f029e2f845309824f0b9ca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30f9257724dfd7072f029e2f845309824f0b9ca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fda594e6ae5c430475120944b8a0e92fe8f206a5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4KHsCRBK7hj4Ov3rIwAAdHIIAK4TNKAukuSpkXhRGA6NQhge\n/Fh2BnN9GqfQlE6rUIkRk/VU1CeVHVvAZWCqdq3wUxBTEE8laZb8Ze6WM+XsAL87\nleC0NxjgLKtfL8ozblaZJrGYsyQg1RZSHoWrdB+zw/oMIFLplvYqZx6oty91PHa4\nr8ZjyhvEpeajTBMgLUsZ1y8Vfxuw/sk9zUTXpgTPUFkojbeQ+I6cQs687gqdcXxI\n11gm4gNJ/0svtk5y9Vp1ljhSHFFGowdHLPvmPvlqYTDF2Opqa5UzfT8Fwm1B4P8v\nrlp6SFEtT5qXccDxa9wsP8AO0Ec+CpHfLWdM9XnrJ1IUwfH1UNu/AvGYS1rCFRc=\n=L3T6\n-----END PGP SIGNATURE-----\n", "payload": "tree 30f9257724dfd7072f029e2f845309824f0b9ca3\nparent 78d08a2269e359aa54f997a0fefe1eb828899a5c\nparent d4d3d7de68d331829b5dcd08be3d4aec1a7a7f2b\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591779820 +0200\ncommitter GitHub <noreply@github.com> 1591779820 +0200\n\nRollup merge of #72890 - davidtwco:issue-66202-normalize-and-transparent-improper-ctypes, r=varkor\n\nimproper ctypes: normalize return types and transparent structs\n\nFixes #66202.\n\nSee each commit individually (except the first which adds a test) for more detailed explanations on the changes made.\n\nIn summary, this PR ensures that return types are normalized before being checked for FFI-safety, and that transparent newtype wrappers are FFI-safe if the type being wrapped is FFI-safe (often true previously, but not if, after substitution, all types in a transparent newtype were zero sized).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fda594e6ae5c430475120944b8a0e92fe8f206a5", "html_url": "https://github.com/rust-lang/rust/commit/fda594e6ae5c430475120944b8a0e92fe8f206a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fda594e6ae5c430475120944b8a0e92fe8f206a5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78d08a2269e359aa54f997a0fefe1eb828899a5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/78d08a2269e359aa54f997a0fefe1eb828899a5c", "html_url": "https://github.com/rust-lang/rust/commit/78d08a2269e359aa54f997a0fefe1eb828899a5c"}, {"sha": "d4d3d7de68d331829b5dcd08be3d4aec1a7a7f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d3d7de68d331829b5dcd08be3d4aec1a7a7f2b", "html_url": "https://github.com/rust-lang/rust/commit/d4d3d7de68d331829b5dcd08be3d4aec1a7a7f2b"}], "stats": {"total": 145, "additions": 105, "deletions": 40}, "files": [{"sha": "cdb0eda645a48a4ea3ecd1c4c10cd266ae48fe8d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fda594e6ae5c430475120944b8a0e92fe8f206a5", "patch": "@@ -6,7 +6,6 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::{is_range_literal, ExprKind, Node};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n@@ -511,10 +510,6 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: &'static str, help: Option<&'static str> },\n }\n \n-fn is_zst<'tcx>(tcx: TyCtxt<'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n-    tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n-}\n-\n fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n         ty::FnPtr(_) => true,\n@@ -523,7 +518,7 @@ fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             for field in field_def.all_fields() {\n                 let field_ty =\n                     tcx.normalize_erasing_regions(ParamEnv::reveal_all(), field.ty(tcx, substs));\n-                if is_zst(tcx, field.did, field_ty) {\n+                if field_ty.is_zst(tcx, field.did) {\n                     continue;\n                 }\n \n@@ -653,32 +648,43 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             };\n                         }\n \n-                        // We can't completely trust repr(C) and repr(transparent) markings;\n-                        // make sure the fields are actually safe.\n-                        let mut all_phantom = true;\n-                        for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.normalize_erasing_regions(\n-                                ParamEnv::reveal_all(),\n-                                field.ty(cx, substs),\n-                            );\n-                            // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n-                            // PhantomData -- skip checking all ZST fields\n-                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n-                                continue;\n+                        if def.repr.transparent() {\n+                            // Can assume that only one field is not a ZST, so only check\n+                            // that field's type for FFI-safety.\n+                            if let Some(field) =\n+                                def.transparent_newtype_field(cx, self.cx.param_env)\n+                            {\n+                                let field_ty = cx.normalize_erasing_regions(\n+                                    self.cx.param_env,\n+                                    field.ty(cx, substs),\n+                                );\n+                                self.check_type_for_ffi(cache, field_ty)\n+                            } else {\n+                                FfiSafe\n                             }\n-                            let r = self.check_type_for_ffi(cache, field_ty);\n-                            match r {\n-                                FfiSafe => {\n-                                    all_phantom = false;\n-                                }\n-                                FfiPhantom(..) => {}\n-                                FfiUnsafe { .. } => {\n-                                    return r;\n+                        } else {\n+                            // We can't completely trust repr(C) markings; make sure the fields are\n+                            // actually safe.\n+                            let mut all_phantom = true;\n+                            for field in &def.non_enum_variant().fields {\n+                                let field_ty = cx.normalize_erasing_regions(\n+                                    self.cx.param_env,\n+                                    field.ty(cx, substs),\n+                                );\n+                                let r = self.check_type_for_ffi(cache, field_ty);\n+                                match r {\n+                                    FfiSafe => {\n+                                        all_phantom = false;\n+                                    }\n+                                    FfiPhantom(..) => {}\n+                                    FfiUnsafe { .. } => {\n+                                        return r;\n+                                    }\n                                 }\n                             }\n-                        }\n \n-                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                        }\n                     }\n                     AdtKind::Union => {\n                         if !def.repr.c() && !def.repr.transparent() {\n@@ -708,7 +714,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             );\n                             // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n                             // PhantomData -- skip checking all ZST fields.\n-                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                            if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n                                 continue;\n                             }\n                             let r = self.check_type_for_ffi(cache, field_ty);\n@@ -774,7 +780,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 );\n                                 // repr(transparent) types are allowed to have arbitrary ZSTs, not\n                                 // just PhantomData -- skip checking all ZST fields.\n-                                if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                                if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n                                     continue;\n                                 }\n                                 let r = self.check_type_for_ffi(cache, field_ty);\n@@ -946,7 +952,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>, is_static: bool) {\n+    fn check_type_for_ffi_and_report_errors(\n+        &mut self,\n+        sp: Span,\n+        ty: Ty<'tcx>,\n+        is_static: bool,\n+        is_return_type: bool,\n+    ) {\n         // We have to check for opaque types before `normalize_erasing_regions`,\n         // which will replace opaque types with their underlying concrete type.\n         if self.check_for_opaque_ty(sp, ty) {\n@@ -957,19 +969,29 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-        // C doesn't really support passing arrays by value.\n-        // The only way to pass an array by value is through a struct.\n-        // So we first test that the top level isn't an array,\n-        // and then recursively check the types inside.\n+\n+        // C doesn't really support passing arrays by value - the only way to pass an array by value\n+        // is through a struct. So, first test that the top level isn't an array, and then\n+        // recursively check the types inside.\n         if !is_static && self.check_for_array_ty(sp, ty) {\n             return;\n         }\n \n+        // Don't report FFI errors for unit return types. This check exists here, and not in\n+        // `check_foreign_fn` (where it would make more sense) so that normalization has definitely\n+        // happened.\n+        if is_return_type && ty.is_unit() {\n+            return;\n+        }\n+\n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n             }\n+            // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n+            // argument, which after substitution, is `()`, then this branch can be hit.\n+            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n             }\n@@ -982,21 +1004,19 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n         }\n \n         if let hir::FnRetTy::Return(ref ret_hir) = decl.output {\n             let ret_ty = sig.output();\n-            if !ret_ty.is_unit() {\n-                self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, false);\n-            }\n+            self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, false, true);\n         }\n     }\n \n     fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, ty, true);\n+        self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n }\n "}, {"sha": "caa1b4cb375fe03f44c8a4941058b874c35072e3", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=fda594e6ae5c430475120944b8a0e92fe8f206a5", "patch": "@@ -2390,6 +2390,29 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n+\n+    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+    /// field.\n+    pub fn transparent_newtype_field(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<&FieldDef> {\n+        assert!(self.is_struct() && self.repr.transparent());\n+\n+        for field in &self.non_enum_variant().fields {\n+            let field_ty = tcx.normalize_erasing_regions(\n+                param_env,\n+                field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.did)),\n+            );\n+\n+            if !field_ty.is_zst(tcx, self.did) {\n+                return Some(field);\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n impl<'tcx> FieldDef {"}, {"sha": "7550be39d4ab0443673a7e4102195742a7666fb3", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=fda594e6ae5c430475120944b8a0e92fe8f206a5", "patch": "@@ -2186,6 +2186,11 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n     }\n+\n+    /// Is this a zero-sized type?\n+    pub fn is_zst(&'tcx self, tcx: TyCtxt<'tcx>, did: DefId) -> bool {\n+        tcx.layout_of(tcx.param_env(did).and(self)).map(|layout| layout.is_zst()).unwrap_or(false)\n+    }\n }\n \n /// Typed constant value."}, {"sha": "ebab41d143e675b2e37dcfd87144c5f45105859e", "filename": "src/test/ui/lint/lint-ctypes-66202.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Ftest%2Fui%2Flint%2Flint-ctypes-66202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda594e6ae5c430475120944b8a0e92fe8f206a5/src%2Ftest%2Fui%2Flint%2Flint-ctypes-66202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-66202.rs?ref=fda594e6ae5c430475120944b8a0e92fe8f206a5", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![deny(improper_ctypes)]\n+\n+// This test checks that return types are normalized before being checked for FFI-safety, and that\n+// transparent newtype wrappers are FFI-safe if the type being wrapped is FFI-safe.\n+\n+#[repr(transparent)]\n+pub struct W<T>(T);\n+\n+extern \"C\" {\n+    pub fn bare() -> ();\n+    pub fn normalize() -> <() as ToOwned>::Owned;\n+    pub fn transparent() -> W<()>;\n+}\n+\n+fn main() {}"}]}