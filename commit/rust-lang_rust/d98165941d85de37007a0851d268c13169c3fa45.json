{"sha": "d98165941d85de37007a0851d268c13169c3fa45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ODE2NTk0MWQ4NWRlMzcwMDdhMDg1MWQyNjhjMTMxNjljM2ZhNDU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-17T13:04:18Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-01T14:45:41Z"}, "message": "add a cross-reference index\n\nit still does not *do* anything", "tree": {"sha": "ae7fbf77530f5fe07dc2f2db1a4f67e9de874bc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae7fbf77530f5fe07dc2f2db1a4f67e9de874bc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d98165941d85de37007a0851d268c13169c3fa45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d98165941d85de37007a0851d268c13169c3fa45", "html_url": "https://github.com/rust-lang/rust/commit/d98165941d85de37007a0851d268c13169c3fa45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d98165941d85de37007a0851d268c13169c3fa45/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67e60bf283fbfb4b6b93b41e3e45e9fba835386c", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e60bf283fbfb4b6b93b41e3e45e9fba835386c", "html_url": "https://github.com/rust-lang/rust/commit/67e60bf283fbfb4b6b93b41e3e45e9fba835386c"}], "stats": {"total": 254, "additions": 149, "deletions": 105}, "files": [{"sha": "30f0485d7d17424781ea099c1f5591680d4a71bc", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=d98165941d85de37007a0851d268c13169c3fa45", "patch": "@@ -43,9 +43,11 @@ pub const tag_items_data_parent_item: usize = 0x28;\n \n pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n-pub const tag_index: usize = 0x2a;\n+pub const tag_index: usize = 0x110; // top-level only\n+pub const tag_xref_index: usize = 0x111; // top-level only\n+pub const tag_xref_data: usize = 0x112; // top-level only\n \n-// GAP 0x2b, 0x2c, 0x2d, 0x2e\n+// GAP 0x2a, 0x2b, 0x2c, 0x2d, 0x2e\n \n pub const tag_meta_item_name_value: usize = 0x2f;\n "}, {"sha": "c40eb56917d2404e34c238f31e4cb7d6acb7ae88", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=d98165941d85de37007a0851d268c13169c3fa45", "patch": "@@ -326,6 +326,7 @@ impl<'a> CrateReader<'a> {\n             name: name.to_string(),\n             local_path: RefCell::new(SmallVector::zero()),\n             index: decoder::load_index(metadata.as_slice()),\n+            xref_index: decoder::load_xrefs(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,"}, {"sha": "9ffe8cd1d111da246dc051ef483744718d5136e1", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=d98165941d85de37007a0851d268c13169c3fa45", "patch": "@@ -65,7 +65,9 @@ pub struct crate_metadata {\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub span: codemap::Span,\n     pub staged_api: bool,\n+\n     pub index: index::Index,\n+    pub xref_index: index::DenseIndex,\n \n     /// Flag if this crate is required by an rlib version of this crate, or in\n     /// other words whether it was explicitly linked to. An example of a crate"}, {"sha": "64858d99b7e8a6af9d04a2c562ca628a4d703bd8", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d98165941d85de37007a0851d268c13169c3fa45", "patch": "@@ -82,6 +82,11 @@ pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n     reader::maybe_get_doc(doc, tag_rustc_version).map(|s| s.as_str())\n }\n \n+pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n+    let index = reader::get_doc(rbml::Doc::new(data), tag_xref_index);\n+    index::DenseIndex::from_buf(index.data, index.start, index.end)\n+}\n+\n #[derive(Debug, PartialEq)]\n enum Family {\n     ImmStatic,             // c"}, {"sha": "d5ef8b962c846139b7ded87f7d2baf76e7204e42", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 103, "deletions": 100, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d98165941d85de37007a0851d268c13169c3fa45", "patch": "@@ -74,6 +74,24 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub reachable: &'a NodeSet,\n }\n \n+/// \"interned\" entries referenced by id\n+#[derive(PartialEq, Eq, Hash)]\n+pub enum XRef<'tcx> { Unused(&'tcx ()) }\n+\n+struct CrateIndex<'tcx> {\n+    items: Vec<IndexEntry>,\n+    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n+}\n+\n+impl<'tcx> CrateIndex<'tcx> {\n+    fn index_item(&mut self, rbml_w: &mut Encoder, id: NodeId) {\n+        self.items.push(IndexEntry {\n+            node: id,\n+            pos: rbml_w.mark_stable_position(),\n+        });\n+    }\n+}\n+\n fn encode_name(rbml_w: &mut Encoder, name: Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n@@ -263,11 +281,11 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n     }\n }\n \n-fn encode_enum_variant_info(ecx: &EncodeContext,\n-                            rbml_w: &mut Encoder,\n-                            id: NodeId,\n-                            vis: hir::Visibility,\n-                            index: &mut Vec<IndexEntry>) {\n+fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                      rbml_w: &mut Encoder,\n+                                      id: NodeId,\n+                                      vis: hir::Visibility,\n+                                      index: &mut CrateIndex<'tcx>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n@@ -284,10 +302,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             }\n         }\n \n-        index.push(IndexEntry {\n-            node: vid.node,\n-            pos: rbml_w.mark_stable_position(),\n-        });\n+        index.index_item(rbml_w, vid.node);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, vid);\n         encode_family(rbml_w, match variant.kind() {\n@@ -593,15 +608,11 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n-                          global_index: &mut Vec<IndexEntry>) {\n+                          index: &mut CrateIndex<'tcx>) {\n     let nm = field.name;\n     let id = field.did.node;\n \n-    let pos = rbml_w.mark_stable_position();\n-    global_index.push(IndexEntry {\n-        node: id,\n-        pos: pos,\n-    });\n+    index.index_item(rbml_w, id);\n     rbml_w.start_tag(tag_items_data_item);\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n@@ -615,17 +626,13 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n-                               rbml_w: &mut Encoder,\n-                               name: Name,\n-                               ctor_id: NodeId,\n-                               index: &mut Vec<IndexEntry>,\n-                               struct_id: NodeId) {\n-    index.push(IndexEntry {\n-        node: ctor_id,\n-        pos: rbml_w.mark_stable_position(),\n-    });\n-\n+fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                         rbml_w: &mut Encoder,\n+                                         name: Name,\n+                                         ctor_id: NodeId,\n+                                         index: &mut CrateIndex<'tcx>,\n+                                         struct_id: NodeId) {\n+    index.index_item(rbml_w, ctor_id);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, DefId::local(ctor_id));\n     encode_family(rbml_w, 'o');\n@@ -952,21 +959,24 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     });\n }\n \n-fn encode_info_for_item(ecx: &EncodeContext,\n-                        rbml_w: &mut Encoder,\n-                        item: &hir::Item,\n-                        index: &mut Vec<IndexEntry>,\n-                        path: PathElems,\n-                        vis: hir::Visibility) {\n-    let tcx = ecx.tcx;\n+fn encode_xrefs<'a, 'tcx>(_ecx: &EncodeContext<'a, 'tcx>,\n+                          rbml_w: &mut Encoder,\n+                          _xrefs: FnvHashMap<XRef<'tcx>, u32>)\n+{\n+    rbml_w.start_tag(tag_xref_data);\n+    rbml_w.end_tag();\n \n-    fn add_to_index(item: &hir::Item, rbml_w: &mut Encoder,\n-                    index: &mut Vec<IndexEntry>) {\n-        index.push(IndexEntry {\n-            node: item.id,\n-            pos: rbml_w.mark_stable_position(),\n-        });\n-    }\n+    rbml_w.start_tag(tag_xref_index);\n+    rbml_w.end_tag();\n+}\n+\n+fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                  rbml_w: &mut Encoder,\n+                                  item: &hir::Item,\n+                                  index: &mut CrateIndex<'tcx>,\n+                                  path: PathElems,\n+                                  vis: hir::Visibility) {\n+    let tcx = ecx.tcx;\n \n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n@@ -976,7 +986,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         if m == hir::MutMutable {\n@@ -994,7 +1004,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemConst(_, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n@@ -1008,7 +1018,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n@@ -1031,7 +1041,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemMod(ref m) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n@@ -1042,7 +1052,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n@@ -1059,7 +1069,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n@@ -1071,7 +1081,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n \n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1104,12 +1114,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n-        for field in &variant.fields {\n-            encode_field(ecx, rbml_w, field, index);\n-        }\n-\n         /* Index the class*/\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n \n         /* Now, make an item for the class itself */\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1137,6 +1143,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         rbml_w.end_tag();\n \n+        for field in &variant.fields {\n+            encode_field(ecx, rbml_w, field, index);\n+        }\n+\n         // If this is a tuple-like struct, encode the type of the constructor.\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n@@ -1147,7 +1157,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {\n-          add_to_index(item, rbml_w, index);\n+          index.index_item(rbml_w, item.id);\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id(rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n@@ -1164,7 +1174,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let impl_items = tcx.impl_items.borrow();\n         let items = impl_items.get(&def_id).unwrap();\n \n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n@@ -1220,11 +1230,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 None\n             };\n \n-            index.push(IndexEntry {\n-                node: trait_item_def_id.def_id().node,\n-                pos: rbml_w.mark_stable_position(),\n-            });\n-\n+            index.index_item(rbml_w, trait_item_def_id.def_id().node);\n             match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n                     encode_info_for_associated_const(ecx,\n@@ -1255,7 +1261,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       hir::ItemTrait(_, _, _, ref ms) => {\n-        add_to_index(item, rbml_w, index);\n+        index.index_item(rbml_w, item.id);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n@@ -1311,11 +1317,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            index.push(IndexEntry {\n-                node: item_def_id.def_id().node,\n-                pos: rbml_w.mark_stable_position(),\n-            });\n-\n+            index.index_item(rbml_w, item_def_id.def_id().node);\n             rbml_w.start_tag(tag_items_data_item);\n \n             encode_parent_item(rbml_w, def_id);\n@@ -1431,17 +1433,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: &EncodeContext,\n-                                rbml_w: &mut Encoder,\n-                                nitem: &hir::ForeignItem,\n-                                index: &mut Vec<IndexEntry>,\n-                                path: PathElems,\n-                                abi: abi::Abi) {\n-    index.push(IndexEntry {\n-        node: nitem.id,\n-        pos: rbml_w.mark_stable_position(),\n-    });\n-\n+fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                          rbml_w: &mut Encoder,\n+                                          nitem: &hir::ForeignItem,\n+                                          index: &mut CrateIndex<'tcx>,\n+                                          path: PathElems,\n+                                          abi: abi::Abi) {\n+    index.index_item(rbml_w, nitem.id);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, DefId::local(nitem.id));\n     encode_visibility(rbml_w, nitem.vis);\n@@ -1479,19 +1477,19 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n fn my_visit_expr(_e: &hir::Expr) { }\n \n-fn my_visit_item(i: &hir::Item,\n-                 rbml_w: &mut Encoder,\n-                 ecx: &EncodeContext,\n-                 index: &mut Vec<IndexEntry>) {\n+fn my_visit_item<'a, 'tcx>(i: &hir::Item,\n+                           rbml_w: &mut Encoder,\n+                           ecx: &EncodeContext<'a, 'tcx>,\n+                           index: &mut CrateIndex<'tcx>) {\n     ecx.tcx.map.with_path(i.id, |path| {\n         encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n     });\n }\n \n-fn my_visit_foreign_item(ni: &hir::ForeignItem,\n-                         rbml_w: &mut Encoder,\n-                         ecx: &EncodeContext,\n-                         index: &mut Vec<IndexEntry>) {\n+fn my_visit_foreign_item<'a, 'tcx>(ni: &hir::ForeignItem,\n+                                   rbml_w: &mut Encoder,\n+                                   ecx: &EncodeContext<'a, 'tcx>,\n+                                   index: &mut CrateIndex<'tcx>) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n             ni.name);\n@@ -1507,7 +1505,7 @@ fn my_visit_foreign_item(ni: &hir::ForeignItem,\n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx: &'a EncodeContext<'c,'tcx>,\n-    index: &'a mut Vec<IndexEntry>,\n+    index: &'a mut CrateIndex<'tcx>,\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n@@ -1531,16 +1529,17 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     }\n }\n \n-fn encode_info_for_items(ecx: &EncodeContext,\n-                         rbml_w: &mut Encoder,\n-                         krate: &hir::Crate)\n-                         -> Vec<IndexEntry> {\n-    let mut index = Vec::new();\n+fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                   rbml_w: &mut Encoder,\n+                                   krate: &hir::Crate)\n+                                   -> CrateIndex<'tcx> {\n+    let mut index = CrateIndex {\n+        items: Vec::new(),\n+        xrefs: FnvHashMap()\n+    };\n     rbml_w.start_tag(tag_items_data);\n-    index.push(IndexEntry {\n-        node: CRATE_NODE_ID,\n-        pos: rbml_w.mark_stable_position(),\n-    });\n+\n+    index.index_item(rbml_w, CRATE_NODE_ID);\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n@@ -1560,10 +1559,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     index\n }\n \n-\n-\n-\n-fn encode_index(rbml_w: &mut Encoder, index: Vec<IndexEntry>)\n+fn encode_item_index(rbml_w: &mut Encoder, index: Vec<IndexEntry>)\n {\n     rbml_w.start_tag(tag_index);\n     index::write_index(index, rbml_w.writer);\n@@ -1978,6 +1974,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         misc_bytes: u64,\n         item_bytes: u64,\n         index_bytes: u64,\n+        xref_bytes: u64,\n         zero_bytes: u64,\n         total_bytes: u64,\n     }\n@@ -1993,6 +1990,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         misc_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n+        xref_bytes: 0,\n         zero_bytes: 0,\n         total_bytes: 0,\n     };\n@@ -2074,14 +2072,18 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let items_index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n+    let index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_index(&mut rbml_w, items_index);\n+    encode_item_index(&mut rbml_w, index.items);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_xrefs(&ecx, &mut rbml_w, index.xrefs);\n+    stats.xref_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+\n     encode_struct_field_attrs(&mut rbml_w, krate);\n \n     stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n@@ -2105,6 +2107,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         println!(\"            misc bytes: {}\", stats.misc_bytes);\n         println!(\"            item bytes: {}\", stats.item_bytes);\n         println!(\"           index bytes: {}\", stats.index_bytes);\n+        println!(\"            xref bytes: {}\", stats.xref_bytes);\n         println!(\"            zero bytes: {}\", stats.zero_bytes);\n         println!(\"           total bytes: {}\", stats.total_bytes);\n     }"}, {"sha": "1cfb201023bc43ec57f6ee26145d9c3ac175568c", "filename": "src/librustc/metadata/index.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98165941d85de37007a0851d268c13169c3fa45/src%2Flibrustc%2Fmetadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Findex.rs?ref=d98165941d85de37007a0851d268c13169c3fa45", "patch": "@@ -33,8 +33,8 @@ impl IndexArrayEntry {\n \n     fn decode_from(b: &[u32]) -> Self {\n         IndexArrayEntry {\n-            bits: b[0].to_be(),\n-            first_pos: b[1].to_be()\n+            bits: u32::from_be(b[0]),\n+            first_pos: u32::from_be(b[1])\n         }\n     }\n }\n@@ -106,7 +106,7 @@ impl Index {\n     }\n \n     fn item_from_pos(&self, positions: &[u32], pos: u32) -> u32 {\n-        positions[pos as usize].to_be()\n+        u32::from_be(positions[pos as usize])\n     }\n \n     #[inline(never)]\n@@ -149,6 +149,37 @@ impl Index {\n     }\n }\n \n+/// A dense index with integer keys\n+pub struct DenseIndex {\n+    start: usize,\n+    end: usize\n+}\n+\n+impl DenseIndex {\n+    pub fn lookup(&self, buf: &[u8], ix: u32) -> Option<u32> {\n+        let data = bytes_to_words(&buf[self.start..self.end]);\n+        data.get(ix as usize).map(|d| u32::from_be(*d))\n+    }\n+    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n+        assert!((end-start)%4 == 0 && start <= end && end <= buf.len());\n+        DenseIndex {\n+            start: start,\n+            end: end\n+        }\n+    }\n+}\n+\n+pub fn write_dense_index(entries: Vec<u32>, buf: &mut Cursor<Vec<u8>>) {\n+    let elen = entries.len();\n+    assert!(elen < u32::MAX as usize);\n+\n+    for entry in entries {\n+        write_be_u32(buf, entry);\n+    }\n+\n+    info!(\"write_dense_index: {} entries\", elen);\n+}\n+\n fn write_be_u32<W: Write>(w: &mut W, u: u32) {\n     let _ = w.write_all(&[\n         (u >> 24) as u8,"}]}