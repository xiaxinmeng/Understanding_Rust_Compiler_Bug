{"sha": "f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MmM5NDc0MGE3YWFkY2FhZWJjOWU2ZmU4ZDc5OGNlMTdmYzI0ZWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-10T04:13:25Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-10T04:13:25Z"}, "message": "rustc: Make rust-intrinsics take an explicit return pointer", "tree": {"sha": "662c7da76686adb499568c7f9388e589d9b5a3e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/662c7da76686adb499568c7f9388e589d9b5a3e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "html_url": "https://github.com/rust-lang/rust/commit/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e823ca496518c1dea4c6f2b3e90e32d38df8540c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e823ca496518c1dea4c6f2b3e90e32d38df8540c", "html_url": "https://github.com/rust-lang/rust/commit/e823ca496518c1dea4c6f2b3e90e32d38df8540c"}], "stats": {"total": 181, "additions": 133, "deletions": 48}, "files": [{"sha": "7170aac794a289860c553ca181dc97d358a18426", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "patch": "@@ -8878,31 +8878,44 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n     // wide. This is obviously wildly unsafe. We should have a better FFI\n     // that allows types of different sizes to be returned.\n \n-    auto rty_is_nil =\n-        ty::type_is_nil(ccx.tcx, ty::ty_fn_ret(ccx.tcx, fn_type));\n+    auto rty = ty::ty_fn_ret(ccx.tcx, fn_type);\n+    auto rty_is_nil = ty::type_is_nil(ccx.tcx, rty);\n+\n     auto pass_task;\n+    auto uses_retptr;\n     auto cast_to_i32;\n     alt (abi) {\n-        case (ast::native_abi_rust) { pass_task = true; cast_to_i32 = true; }\n-        case (ast::native_abi_rust_intrinsic) {\n-            pass_task = true;\n-            cast_to_i32 = false;\n-        }\n-        case (ast::native_abi_cdecl) {\n-            pass_task = false;\n-            cast_to_i32 = true;\n-        }\n-        case (ast::native_abi_llvm) {\n-            pass_task = false;\n-            cast_to_i32 = false;\n-        }\n+      case (ast::native_abi_rust) {\n+        pass_task = true;\n+        uses_retptr = false;\n+        cast_to_i32 = true;\n+      }\n+      case (ast::native_abi_rust_intrinsic) {\n+        pass_task = true;\n+        uses_retptr = true;\n+        cast_to_i32 = false;\n+      }\n+      case (ast::native_abi_cdecl) {\n+        pass_task = false;\n+        uses_retptr = false;\n+        cast_to_i32 = true;\n+      }\n+      case (ast::native_abi_llvm) {\n+        pass_task = false;\n+        uses_retptr = false;\n+        cast_to_i32 = false;\n+      }\n     }\n+\n     auto lltaskptr;\n     if (cast_to_i32) {\n         lltaskptr = vp2i(bcx, fcx.lltaskptr);\n     } else { lltaskptr = fcx.lltaskptr; }\n+\n     let ValueRef[] call_args = ~[];\n     if (pass_task) { call_args += ~[lltaskptr]; }\n+    if (uses_retptr) { call_args += ~[bcx.fcx.llretptr]; }\n+\n     auto arg_n = 3u;\n     for each (uint i in uint::range(0u, num_ty_param)) {\n         auto llarg = llvm::LLVMGetParam(fcx.llfn, arg_n);\n@@ -8931,23 +8944,33 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n         }\n         ret vp2i(cx, v);\n     }\n+\n     fn trans_simple_native_abi(&@block_ctxt bcx, str name,\n                                &mutable ValueRef[] call_args,\n-                               ty::t fn_type, uint first_arg_n) ->\n+                               ty::t fn_type, uint first_arg_n,\n+                               bool uses_retptr) ->\n        tup(ValueRef, ValueRef) {\n         let TypeRef[] call_arg_tys = ~[];\n         for (ValueRef arg in call_args) { call_arg_tys += ~[val_ty(arg)]; }\n-        auto llnativefnty =\n-            T_fn(call_arg_tys,\n-                 type_of(bcx.fcx.lcx.ccx, bcx.sp,\n-                         ty::ty_fn_ret(bcx.fcx.lcx.ccx.tcx, fn_type)));\n+\n+        auto llnativefnty;\n+        if (uses_retptr) {\n+            llnativefnty = T_fn(call_arg_tys, T_void());\n+        } else {\n+            llnativefnty =\n+                T_fn(call_arg_tys,\n+                     type_of(bcx.fcx.lcx.ccx, bcx.sp,\n+                             ty::ty_fn_ret(bcx.fcx.lcx.ccx.tcx, fn_type)));\n+        }\n+\n         auto llnativefn =\n             get_extern_fn(bcx.fcx.lcx.ccx.externs, bcx.fcx.lcx.ccx.llmod,\n                           name, lib::llvm::LLVMCCallConv, llnativefnty);\n         auto r = bcx.build.Call(llnativefn, call_args);\n         auto rptr = bcx.fcx.llretptr;\n         ret tup(r, rptr);\n     }\n+\n     auto args = ty::ty_fn_args(ccx.tcx, fn_type);\n     // Build up the list of arguments.\n \n@@ -8970,15 +8993,16 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n     alt (abi) {\n         case (ast::native_abi_llvm) {\n             auto result =\n-                trans_simple_native_abi(bcx, name, call_args, fn_type, arg_n);\n+                trans_simple_native_abi(bcx, name, call_args, fn_type, arg_n,\n+                                        uses_retptr);\n             r = result._0;\n             rptr = result._1;\n         }\n         case (ast::native_abi_rust_intrinsic) {\n             auto external_name = \"rust_intrinsic_\" + name;\n             auto result =\n                 trans_simple_native_abi(bcx, external_name, call_args,\n-                                        fn_type, arg_n);\n+                                        fn_type, arg_n, uses_retptr);\n             r = result._0;\n             rptr = result._1;\n         }\n@@ -8994,7 +9018,8 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n     // pointer. This is the only concession made to non-i32 return values. See\n     // the FIXME above.\n \n-    if (!rty_is_nil) { bcx.build.Store(r, rptr); }\n+    if (!rty_is_nil && !uses_retptr) { bcx.build.Store(r, rptr); }\n+\n     for (tup(ValueRef, ty::t) d in drop_args) {\n         bcx = drop_ty(bcx, d._0, d._1).bcx;\n     }"}, {"sha": "54f0352b996316c82fc118beff157ba1974f2b2d", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "patch": "@@ -7,7 +7,7 @@ import uint::next_power_of_two;\n type operator2[T,U,V] = fn(&T, &U) -> V;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn ivec_len[T](&T[] v) -> uint;\n+    fn ivec_len_2[T](&T[] v) -> uint;\n }\n \n native \"rust\" mod rustrt {\n@@ -32,7 +32,7 @@ fn to_ptr[T](&T[] v) -> *T {\n }\n \n fn len[T](&T[mutable?] v) -> uint {\n-    ret rusti::ivec_len(v);\n+    ret rusti::ivec_len_2(v);\n }\n \n type init_op[T] = fn(uint) -> T;"}, {"sha": "5cd7ea99b02a70bf58a85c944f9138d0d80c4f84", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "patch": "@@ -27,23 +27,44 @@ rust_intrinsic_ivec_len(rust_task *task, type_desc *ty, rust_ivec *v)\n     return fill / ty->size;\n }\n \n-extern \"C\" void *\n-rust_intrinsic_ptr_offset(rust_task *task, type_desc *ty, void *ptr,\n-                          uintptr_t count)\n+extern \"C\" void\n+rust_intrinsic_vec_len_2(rust_task *task, size_t *retptr, type_desc *ty,\n+                         rust_vec *v)\n+{\n+    *retptr = v->fill / ty->size;\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_ivec_len_2(rust_task *task, size_t *retptr, type_desc *ty,\n+                          rust_ivec *v)\n+{\n+    size_t fill;\n+    if (v->fill)\n+        fill = v->fill;\n+    else if (v->payload.ptr)\n+        fill = v->payload.ptr->fill;\n+    else\n+        fill = 0;\n+    *retptr = fill / ty->size;\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_ptr_offset(rust_task *task, void **retptr, type_desc *ty,\n+                          void *ptr, uintptr_t count)\n {\n-    return &((uint8_t *)ptr)[ty->size * count];\n+    *retptr = &((uint8_t *)ptr)[ty->size * count];\n }\n \n extern \"C\" void\n-rust_intrinsic_cast(rust_task *task, type_desc *t1, type_desc *t2, void *dest,\n-                    void *src)\n+rust_intrinsic_cast(rust_task *task, void *retptr, type_desc *t1,\n+                    type_desc *t2, void *src)\n {\n     if (t1->size != t2->size) {\n         upcall_fail(task, \"attempt to cast values of differing sizes\",\n                     __FILE__, __LINE__);\n         return;\n     }\n \n-    memmove(dest, src, t1->size);\n+    memmove(retptr, src, t1->size);\n }\n "}, {"sha": "7364cf670fdc42776c66e9fa9e7944cf2153be4e", "filename": "src/rt/intrinsics/intrinsics.ll.in", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in?ref=f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "patch": "@@ -100,16 +100,55 @@ if.end17:                                         ; preds = %if.else, %entry, %i\n   ret i32 %div\n }\n \n-define linkonce_odr i8* @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind readonly {\n+define linkonce_odr void @rust_intrinsic_vec_len_2(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec* nocapture %v) nounwind {\n+entry:\n+  %fill = getelementptr inbounds %struct.rust_vec* %v, i32 0, i32 2\n+  %tmp1 = load i32* %fill, align 4, !tbaa !0\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %tmp3 = load i32* %size, align 4, !tbaa !0\n+  %div = udiv i32 %tmp1, %tmp3\n+  store i32 %div, i32* %retptr, align 4, !tbaa !0\n+  ret void\n+}\n+\n+define linkonce_odr void @rust_intrinsic_ivec_len_2(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_ivec* nocapture %v) nounwind {\n+entry:\n+  %fill1 = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 0\n+  %tmp2 = load i32* %fill1, align 4, !tbaa !0\n+  %tobool = icmp eq i32 %tmp2, 0\n+  br i1 %tobool, label %if.else, label %if.end17\n+\n+if.else:                                          ; preds = %entry\n+  %ptr = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 2, i32 0\n+  %tmp7 = load %struct.rust_ivec_heap** %ptr, align 4, !tbaa !3\n+  %tobool8 = icmp eq %struct.rust_ivec_heap* %tmp7, null\n+  br i1 %tobool8, label %if.end17, label %if.then9\n+\n+if.then9:                                         ; preds = %if.else\n+  %fill14 = getelementptr inbounds %struct.rust_ivec_heap* %tmp7, i32 0, i32 0\n+  %tmp15 = load i32* %fill14, align 4, !tbaa !0\n+  br label %if.end17\n+\n+if.end17:                                         ; preds = %if.else, %entry, %if.then9\n+  %fill.0 = phi i32 [ %tmp15, %if.then9 ], [ %tmp2, %entry ], [ 0, %if.else ]\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %tmp20 = load i32* %size, align 4, !tbaa !0\n+  %div = udiv i32 %fill.0, %tmp20\n+  store i32 %div, i32* %retptr, align 4, !tbaa !0\n+  ret void\n+}\n+\n+define linkonce_odr void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n entry:\n   %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n   %tmp1 = load i32* %size, align 4, !tbaa !0\n   %mul = mul i32 %tmp1, %count\n   %arrayidx = getelementptr inbounds i8* %ptr, i32 %mul\n-  ret i8* %arrayidx\n+  store i8* %arrayidx, i8** %retptr, align 4, !tbaa !3\n+  ret void\n }\n \n-define linkonce_odr void @rust_intrinsic_cast(%struct.rust_task* %task, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %dest, i8* nocapture %src) {\n+define linkonce_odr void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n entry:\n   %size = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n   %tmp1 = load i32* %size, align 4, !tbaa !0\n@@ -119,11 +158,11 @@ entry:\n   br i1 %cmp, label %if.end, label %if.then\n \n if.then:                                          ; preds = %entry\n-  tail call void @upcall_fail(%struct.rust_task* %task, i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str1, i32 0, i32 0), i32 43)\n+  tail call void @upcall_fail(%struct.rust_task* %task, i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str1, i32 0, i32 0), i32 64)\n   br label %return\n \n if.end:                                           ; preds = %entry\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %dest, i8* %src, i32 %tmp1, i32 1, i1 false)\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %tmp1, i32 1, i1 false)\n   br label %return\n \n return:                                           ; preds = %if.end, %if.then"}, {"sha": "a431e59dba16aa08f1ad36eb394972def538da55", "filename": "src/test/run-pass/interior-vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finterior-vec.rs?ref=f42c94740a7aadcaaebc9e6fe8d798ce17fc24ee", "patch": "@@ -1,31 +1,31 @@\n // xfail-stage0\n \n-import rusti::ivec_len;\n+import rusti::ivec_len_2;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn ivec_len[T](&T[] v) -> uint;\n+    fn ivec_len_2[T](&T[] v) -> uint;\n }\n \n fn main() {\n     let int[] v = ~[];\n-    assert (ivec_len(v) == 0u);     // zero-length\n+    assert (ivec_len_2(v) == 0u);     // zero-length\n     auto x = ~[ 1, 2 ];\n-    assert (ivec_len(x) == 2u);     // on stack\n+    assert (ivec_len_2(x) == 2u);     // on stack\n     auto y = ~[ 1, 2, 3, 4, 5 ];\n-    assert (ivec_len(y) == 5u);     // on heap\n+    assert (ivec_len_2(y) == 5u);     // on heap\n \n     v += ~[];\n-    assert (ivec_len(v) == 0u);     // zero-length append\n+    assert (ivec_len_2(v) == 0u);     // zero-length append\n     x += ~[ 3 ];\n-    assert (ivec_len(x) == 3u);     // on-stack append\n+    assert (ivec_len_2(x) == 3u);     // on-stack append\n     y += ~[ 6, 7, 8, 9 ];\n-    assert (ivec_len(y) == 9u);     // on-heap append\n+    assert (ivec_len_2(y) == 9u);     // on-heap append\n \n     auto vv = v + v;\n-    assert (ivec_len(vv) == 0u);     // zero-length add\n+    assert (ivec_len_2(vv) == 0u);     // zero-length add\n     auto xx = x + ~[ 4 ];\n-    assert (ivec_len(xx) == 4u);     // on-stack add\n+    assert (ivec_len_2(xx) == 4u);     // on-stack add\n     auto yy = y + ~[ 10, 11 ];\n-    assert (ivec_len(yy) == 11u);    // on-heap add\n+    assert (ivec_len_2(yy) == 11u);    // on-heap add\n }\n "}]}