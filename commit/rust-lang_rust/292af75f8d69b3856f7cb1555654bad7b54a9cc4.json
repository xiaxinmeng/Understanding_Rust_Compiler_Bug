{"sha": "292af75f8d69b3856f7cb1555654bad7b54a9cc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MmFmNzVmOGQ2OWIzODU2ZjdjYjE1NTU2NTRiYWQ3YjU0YTljYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-20T17:19:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-20T17:19:21Z"}, "message": "Auto merge of #30872 - pitdicker:expand_open_options, r=alexcrichton\n\nTracking issue: #30014\n\nThis implements the RFC and makes a few other changes.\nI have added a few extra tests, and made the Windows and\nUnix code as similar as possible.\n\nPart of the RFC mentions the unstable OpenOptionsExt trait\non Windows (see #27720). I have added a few extra methods\nto future-proof it for CreateFile2.", "tree": {"sha": "937bd35b65822cce760088ea50ec1b3906fd986a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/937bd35b65822cce760088ea50ec1b3906fd986a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/292af75f8d69b3856f7cb1555654bad7b54a9cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/292af75f8d69b3856f7cb1555654bad7b54a9cc4", "html_url": "https://github.com/rust-lang/rust/commit/292af75f8d69b3856f7cb1555654bad7b54a9cc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/292af75f8d69b3856f7cb1555654bad7b54a9cc4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4c9628de7d4e970b2cb43d0f1a4c8f9ad03aca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c9628de7d4e970b2cb43d0f1a4c8f9ad03aca1", "html_url": "https://github.com/rust-lang/rust/commit/c4c9628de7d4e970b2cb43d0f1a4c8f9ad03aca1"}, {"sha": "ae30294771e3c5c65a2d70be0e09b5bec2490c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae30294771e3c5c65a2d70be0e09b5bec2490c66", "html_url": "https://github.com/rust-lang/rust/commit/ae30294771e3c5c65a2d70be0e09b5bec2490c66"}], "stats": {"total": 657, "additions": 480, "deletions": 177}, "files": [{"sha": "414a0ebd11fa27ce0cc8c4b79f68b45a252229cc", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 162, "deletions": 47, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=292af75f8d69b3856f7cb1555654bad7b54a9cc4", "patch": "@@ -375,7 +375,7 @@ impl<'a> Seek for &'a File {\n }\n \n impl OpenOptions {\n-    /// Creates a blank net set of options ready for configuration.\n+    /// Creates a blank new set of options ready for configuration.\n     ///\n     /// All options are initially set to `false`.\n     ///\n@@ -384,7 +384,8 @@ impl OpenOptions {\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n     ///\n-    /// let file = OpenOptions::new().open(\"foo.txt\");\n+    /// let mut options = OpenOptions::new();\n+    /// let file = options.read(true).open(\"foo.txt\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> OpenOptions {\n@@ -413,6 +414,9 @@ impl OpenOptions {\n     /// This option, when true, will indicate that the file should be\n     /// `write`-able if opened.\n     ///\n+    /// If a file already exist, any write calls on the file will overwrite its\n+    /// contents, without truncating it.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -429,13 +433,30 @@ impl OpenOptions {\n     ///\n     /// This option, when true, means that writes will append to a file instead\n     /// of overwriting previous contents.\n+    /// Note that setting `.write(true).append(true)` has the same effect as\n+    /// setting only `.append(true)`.\n+    ///\n+    /// For most filesystems the operating system guarantees all writes are\n+    /// atomic: no writes get mangled because another process writes at the same\n+    /// time.\n+    ///\n+    /// One maybe obvious note when using append-mode: make sure that all data\n+    /// that belongs together, is written the the file in one operation. This\n+    /// can be done by concatenating strings before passing them to `write()`,\n+    /// or using a buffered writer (with a more than adequately sized buffer)\n+    /// and calling `flush()` when the message is complete.\n+    ///\n+    /// If a file is opened with both read and append access, beware that after\n+    /// opening and after every write the position for reading may be set at the\n+    /// end of the file. So before writing save the current position (using\n+    /// `seek(SeekFrom::Current(0))`, and restore it before the next read.\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n     ///\n-    /// let file = OpenOptions::new().write(true).append(true).open(\"foo.txt\");\n+    /// let file = OpenOptions::new().append(true).open(\"foo.txt\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n@@ -447,6 +468,8 @@ impl OpenOptions {\n     /// If a file is successfully opened with this option set it will truncate\n     /// the file to 0 length if it already exists.\n     ///\n+    /// The file must be opened with write access for truncate to work.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -464,29 +487,68 @@ impl OpenOptions {\n     /// This option indicates whether a new file will be created if the file\n     /// does not yet already exist.\n     ///\n+    /// The file must be opened with write or append access in order to create\n+    /// a new file.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n     ///\n-    /// let file = OpenOptions::new().create(true).open(\"foo.txt\");\n+    /// let file = OpenOptions::new().write(true).create(true).open(\"foo.txt\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n         self.0.create(create); self\n     }\n \n+    /// Sets the option to always create a new file.\n+    ///\n+    /// This option indicates whether a new file will be created.\n+    /// No file is allowed to exist at the target location, also no (dangling)\n+    /// symlink.\n+    ///\n+    /// This option is usefull because it as atomic. Otherwise between checking\n+    /// whether a file exists and creating a new one, the file may have been\n+    /// created by another process (a TOCTOU race condition / attack).\n+    ///\n+    /// If `.create_new(true)` is set, `.create()` and `.truncate()` are\n+    /// ignored.\n+    ///\n+    /// The file must be opened with write or append access in order to create\n+    /// a new file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(expand_open_options)]\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().write(true)\n+    ///                              .create_new(true)\n+    ///                              .open(\"foo.txt\");\n+    /// ```\n+    #[unstable(feature = \"expand_open_options\",\n+               reason = \"recently added\",\n+               issue = \"30014\")]\n+    pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions {\n+        self.0.create_new(create_new); self\n+    }\n+\n     /// Opens a file at `path` with the options specified by `self`.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an error under a number of different\n     /// circumstances, to include but not limited to:\n     ///\n-    /// * Opening a file that does not exist with read access.\n+    /// * Opening a file that does not exist without setting `create` or\n+    ///   `create_new`.\n     /// * Attempting to open a file with access that the user lacks\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n+    /// * Invalid combinations of open options (truncate without write access,\n+    ///   no access mode set, etc)\n     ///\n     /// # Examples\n     ///\n@@ -2098,61 +2160,114 @@ mod tests {\n \n         let mut r = OO::new(); r.read(true);\n         let mut w = OO::new(); w.write(true);\n-        let mut rw = OO::new(); rw.write(true).read(true);\n-\n-        match r.open(&tmpdir.join(\"a\")) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-\n-        // Perform each one twice to make sure that it succeeds the second time\n-        // (where the file exists)\n-        check!(c(&w).create(true).open(&tmpdir.join(\"b\")));\n-        assert!(tmpdir.join(\"b\").exists());\n-        check!(c(&w).create(true).open(&tmpdir.join(\"b\")));\n-        check!(w.open(&tmpdir.join(\"b\")));\n-\n+        let mut rw = OO::new(); rw.read(true).write(true);\n+        let mut a = OO::new(); a.append(true);\n+        let mut ra = OO::new(); ra.read(true).append(true);\n+\n+        let invalid_options = if cfg!(windows) { \"The parameter is incorrect\" }\n+                              else { \"Invalid argument\" };\n+\n+        // Test various combinations of creation modes and access modes.\n+        //\n+        // Allowed:\n+        // creation mode           | read  | write | read-write | append | read-append |\n+        // :-----------------------|:-----:|:-----:|:----------:|:------:|:-----------:|\n+        // not set (open existing) |   X   |   X   |     X      |   X    |      X      |\n+        // create                  |       |   X   |     X      |   X    |      X      |\n+        // truncate                |       |   X   |     X      |        |             |\n+        // create and truncate     |       |   X   |     X      |        |             |\n+        // create_new              |       |   X   |     X      |   X    |      X      |\n+        //\n+        // tested in reverse order, so 'create_new' creates the file, and 'open existing' opens it.\n+\n+        // write-only\n+        check!(c(&w).create_new(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).create(true).truncate(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).truncate(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).create(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).open(&tmpdir.join(\"a\")));\n+\n+        // read-only\n+        error!(c(&r).create_new(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        error!(c(&r).create(true).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        error!(c(&r).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        error!(c(&r).create(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        check!(c(&r).open(&tmpdir.join(\"a\"))); // try opening the file created with write_only\n+\n+        // read-write\n+        check!(c(&rw).create_new(true).open(&tmpdir.join(\"c\")));\n+        check!(c(&rw).create(true).truncate(true).open(&tmpdir.join(\"c\")));\n+        check!(c(&rw).truncate(true).open(&tmpdir.join(\"c\")));\n         check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n-        assert!(tmpdir.join(\"c\").exists());\n-        check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n-        check!(rw.open(&tmpdir.join(\"c\")));\n-\n-        check!(c(&w).append(true).create(true).open(&tmpdir.join(\"d\")));\n-        assert!(tmpdir.join(\"d\").exists());\n-        check!(c(&w).append(true).create(true).open(&tmpdir.join(\"d\")));\n-        check!(c(&w).append(true).open(&tmpdir.join(\"d\")));\n-\n-        check!(c(&rw).append(true).create(true).open(&tmpdir.join(\"e\")));\n-        assert!(tmpdir.join(\"e\").exists());\n-        check!(c(&rw).append(true).create(true).open(&tmpdir.join(\"e\")));\n-        check!(c(&rw).append(true).open(&tmpdir.join(\"e\")));\n-\n-        check!(c(&w).truncate(true).create(true).open(&tmpdir.join(\"f\")));\n-        assert!(tmpdir.join(\"f\").exists());\n-        check!(c(&w).truncate(true).create(true).open(&tmpdir.join(\"f\")));\n-        check!(c(&w).truncate(true).open(&tmpdir.join(\"f\")));\n-\n-        check!(c(&rw).truncate(true).create(true).open(&tmpdir.join(\"g\")));\n-        assert!(tmpdir.join(\"g\").exists());\n-        check!(c(&rw).truncate(true).create(true).open(&tmpdir.join(\"g\")));\n-        check!(c(&rw).truncate(true).open(&tmpdir.join(\"g\")));\n-\n-        check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foo\".as_bytes()));\n+        check!(c(&rw).open(&tmpdir.join(\"c\")));\n+\n+        // append\n+        check!(c(&a).create_new(true).open(&tmpdir.join(\"d\")));\n+        error!(c(&a).create(true).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n+        error!(c(&a).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n+        check!(c(&a).create(true).open(&tmpdir.join(\"d\")));\n+        check!(c(&a).open(&tmpdir.join(\"d\")));\n+\n+        // read-append\n+        check!(c(&ra).create_new(true).open(&tmpdir.join(\"e\")));\n+        error!(c(&ra).create(true).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n+        error!(c(&ra).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n+        check!(c(&ra).create(true).open(&tmpdir.join(\"e\")));\n+        check!(c(&ra).open(&tmpdir.join(\"e\")));\n+\n+        // Test opening a file without setting an access mode\n+        let mut blank = OO::new();\n+         error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n+\n+        // Test write works\n+        check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foobar\".as_bytes()));\n+\n+        // Test write fails for read-only\n         check!(r.open(&tmpdir.join(\"h\")));\n         {\n             let mut f = check!(r.open(&tmpdir.join(\"h\")));\n             assert!(f.write(\"wut\".as_bytes()).is_err());\n         }\n+\n+        // Test write overwrites\n+        {\n+            let mut f = check!(c(&w).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"baz\".as_bytes()));\n+        }\n+        {\n+            let mut f = check!(c(&r).open(&tmpdir.join(\"h\")));\n+            let mut b = vec![0; 6];\n+            check!(f.read(&mut b));\n+            assert_eq!(b, \"bazbar\".as_bytes());\n+        }\n+\n+        // Test truncate works\n+        {\n+            let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"foo\".as_bytes()));\n+        }\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+\n+        // Test append works\n         assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n         {\n-            let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n+            let mut f = check!(c(&a).open(&tmpdir.join(\"h\")));\n             check!(f.write(\"bar\".as_bytes()));\n         }\n         assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 6);\n+\n+        // Test .append(true) equals .write(true).append(true)\n         {\n-            let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n-            check!(f.write(\"bar\".as_bytes()));\n+            let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"baz\".as_bytes()));\n         }\n-        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 9);\n+    }\n+\n+    #[test]\n+    fn _assert_send_sync() {\n+        fn _assert_send_sync<T: Send + Sync>() {}\n+        _assert_send_sync::<OpenOptions>();\n     }\n \n     #[test]"}, {"sha": "2a3117864d06336584490f11dd4593ad91bedb3a", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=292af75f8d69b3856f7cb1555654bad7b54a9cc4", "patch": "@@ -118,15 +118,49 @@ pub trait OpenOptionsExt {\n     ///\n     /// If a new file is created as part of a `File::open_opts` call then this\n     /// specified `mode` will be used as the permission bits for the new file.\n+    /// If no `mode` is set, the default of `0o666` will be used.\n+    /// The operating system masks out bits with the systems `umask`, to produce\n+    /// the final permissions.\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: raw::mode_t) -> &mut Self;\n+\n+    /// Pass custom flags to the `flags` agument of `open`.\n+    ///\n+    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n+    /// ensure they do not interfere with the access mode set by Rusts options.\n+    ///\n+    /// Custom flags can only set flags, not remove flags set by Rusts options.\n+    /// This options overwrites any previously set custom flags.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.write(true);\n+    /// if cfg!(unix) {\n+    ///     options.custom_flags(libc::O_NOFOLLOW);\n+    /// }\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[unstable(feature = \"expand_open_options\",\n+               reason = \"recently added\",\n+               issue = \"30014\")]\n+    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n }\n \n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n impl OpenOptionsExt for OpenOptions {\n     fn mode(&mut self, mode: raw::mode_t) -> &mut OpenOptions {\n         self.as_inner_mut().mode(mode); self\n     }\n+\n+    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().custom_flags(flags); self\n+    }\n }\n \n // Hm, why are there casts here to the returned type, shouldn't the types always\n@@ -281,4 +315,3 @@ impl DirBuilderExt for fs::DirBuilder {\n         self\n     }\n }\n-"}, {"sha": "d2d2ce35d84a0adfe401f80935293cb91929f701", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=292af75f8d69b3856f7cb1555654bad7b54a9cc4", "patch": "@@ -50,9 +50,15 @@ pub struct DirEntry {\n \n #[derive(Clone)]\n pub struct OpenOptions {\n-    flags: c_int,\n+    // generic\n     read: bool,\n     write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: i32,\n     mode: mode_t,\n }\n \n@@ -233,43 +239,60 @@ impl DirEntry {\n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n         OpenOptions {\n-            flags: libc::O_CLOEXEC,\n+            // generic\n             read: false,\n             write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n             mode: 0o666,\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) {\n-        self.read = read;\n-    }\n-\n-    pub fn write(&mut self, write: bool) {\n-        self.write = write;\n-    }\n-\n-    pub fn append(&mut self, append: bool) {\n-        self.flag(libc::O_APPEND, append);\n-    }\n-\n-    pub fn truncate(&mut self, truncate: bool) {\n-        self.flag(libc::O_TRUNC, truncate);\n-    }\n-\n-    pub fn create(&mut self, create: bool) {\n-        self.flag(libc::O_CREAT, create);\n-    }\n-\n-    pub fn mode(&mut self, mode: raw::mode_t) {\n-        self.mode = mode as mode_t;\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }\n+    pub fn mode(&mut self, mode: raw::mode_t) { self.mode = mode as mode_t; }\n+\n+    fn get_access_mode(&self) -> io::Result<c_int> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(libc::O_RDONLY),\n+            (false, true,  false) => Ok(libc::O_WRONLY),\n+            (true,  true,  false) => Ok(libc::O_RDWR),\n+            (false, _,     true)  => Ok(libc::O_WRONLY | libc::O_APPEND),\n+            (true,  _,     true)  => Ok(libc::O_RDWR | libc::O_APPEND),\n+            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n+        }\n     }\n \n-    fn flag(&mut self, bit: c_int, on: bool) {\n-        if on {\n-            self.flags |= bit;\n-        } else {\n-            self.flags &= !bit;\n+    fn get_creation_mode(&self) -> io::Result<c_int> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                },\n         }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => libc::O_CREAT,\n+                (false, true,  false) => libc::O_TRUNC,\n+                (true,  true,  false) => libc::O_CREAT | libc::O_TRUNC,\n+                (_,      _,    true)  => libc::O_CREAT | libc::O_EXCL,\n+           })\n     }\n }\n \n@@ -280,12 +303,10 @@ impl File {\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = opts.flags | match (opts.read, opts.write) {\n-            (true, true) => libc::O_RDWR,\n-            (false, true) => libc::O_WRONLY,\n-            (true, false) |\n-            (false, false) => libc::O_RDONLY,\n-        };\n+        let flags = libc::O_CLOEXEC |\n+                    try!(opts.get_access_mode()) |\n+                    try!(opts.get_creation_mode()) |\n+                    (opts.custom_flags as c_int & !libc::O_ACCMODE);\n         let fd = try!(cvt_r(|| unsafe {\n             libc::open(path.as_ptr(), flags, opts.mode as c_int)\n         }));"}, {"sha": "6e8090a223516434662df5b4f5497422cce35a2b", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=292af75f8d69b3856f7cb1555654bad7b54a9cc4", "patch": "@@ -93,16 +93,30 @@ pub const CREATE_NEW: DWORD = 1;\n pub const OPEN_ALWAYS: DWORD = 4;\n pub const OPEN_EXISTING: DWORD = 3;\n pub const TRUNCATE_EXISTING: DWORD = 5;\n-pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n+\n pub const FILE_READ_DATA: DWORD = 0x00000001;\n pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n-pub const STANDARD_RIGHTS_READ: DWORD = 0x20000;\n-pub const STANDARD_RIGHTS_WRITE: DWORD = 0x20000;\n-pub const FILE_WRITE_EA: DWORD = 0x00000010;\n+pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n pub const FILE_READ_EA: DWORD = 0x00000008;\n-pub const SYNCHRONIZE: DWORD = 0x00100000;\n-pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+pub const FILE_WRITE_EA: DWORD = 0x00000010;\n+pub const FILE_EXECUTE: DWORD = 0x00000020;\n pub const FILE_READ_ATTRIBUTES: DWORD = 0x00000080;\n+pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+\n+pub const DELETE: DWORD = 0x00008000;\n+pub const READ_CONTROL: DWORD = 0x00020000;\n+pub const WRITE_DAC: DWORD = 0x00040000;\n+pub const WRITE_OWNER: DWORD = 0x00080000;\n+pub const SYNCHRONIZE: DWORD = 0x00100000;\n+\n+pub const GENERIC_READ: DWORD = 0x80000000;\n+pub const GENERIC_WRITE: DWORD = 0x40000000;\n+pub const GENERIC_EXECUTE: DWORD = 0x20000000;\n+pub const GENERIC_ALL: DWORD = 0x10000000;\n+\n+pub const STANDARD_RIGHTS_READ: DWORD = READ_CONTROL;\n+pub const STANDARD_RIGHTS_WRITE: DWORD = READ_CONTROL;\n+pub const STANDARD_RIGHTS_EXECUTE: DWORD = READ_CONTROL;\n pub const FILE_GENERIC_READ: DWORD = STANDARD_RIGHTS_READ | FILE_READ_DATA |\n                                      FILE_READ_ATTRIBUTES |\n                                      FILE_READ_EA |\n@@ -113,6 +127,14 @@ pub const FILE_GENERIC_WRITE: DWORD = STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA |\n                                       FILE_APPEND_DATA |\n                                       SYNCHRONIZE;\n \n+pub const SECURITY_ANONYMOUS: DWORD = 0 << 16;\n+pub const SECURITY_IDENTIFICATION: DWORD = 1 << 16;\n+pub const SECURITY_IMPERSONATION: DWORD = 2 << 16;\n+pub const SECURITY_DELEGATION: DWORD = 3 << 16;\n+pub const SECURITY_CONTEXT_TRACKING: DWORD = 0x00040000;\n+pub const SECURITY_EFFECTIVE_ONLY: DWORD = 0x00080000;\n+pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {"}, {"sha": "d060c902fba2fe27a38feef827a2fe6f6cb291ca", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 109, "deletions": 23, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=292af75f8d69b3856f7cb1555654bad7b54a9cc4", "patch": "@@ -25,45 +25,131 @@ use sys_common::{AsInnerMut, AsInner};\n pub trait OpenOptionsExt {\n     /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n     /// with the specified value.\n-    fn desired_access(&mut self, access: u32) -> &mut Self;\n-\n-    /// Overrides the `dwCreationDisposition` argument to the call to\n-    /// `CreateFile` with the specified value.\n     ///\n-    /// This will override any values of the standard `create` flags, for\n-    /// example.\n-    fn creation_disposition(&mut self, val: u32) -> &mut Self;\n-\n-    /// Overrides the `dwFlagsAndAttributes` argument to the call to\n-    /// `CreateFile` with the specified value.\n+    /// This will override the `read`, `write`, and `append` flags on the\n+    /// `OpenOptions` structure. This method provides fine-grained control over\n+    /// the permissions to read, write and append data, attributes (like hidden\n+    /// and system) and extended attributes.\n+    ///\n+    /// # Examples\n     ///\n-    /// This will override any values of the standard flags on the\n-    /// `OpenOptions` structure.\n-    fn flags_and_attributes(&mut self, val: u32) -> &mut Self;\n+    /// ```no_run\n+    /// #![feature(open_options_ext)]\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// // Open without read and write permission, for example if you only need\n+    /// // to call `stat()` on the file\n+    /// let file = OpenOptions::new().access_mode(0).open(\"foo.txt\");\n+    /// ```\n+    fn access_mode(&mut self, access: u32) -> &mut Self;\n \n     /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n     /// the specified value.\n     ///\n-    /// This will override any values of the standard flags on the\n-    /// `OpenOptions` structure.\n+    /// By default `share_mode` is set to\n+    /// `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`. Specifying\n+    /// less permissions denies others to read from, write to and/or delete the\n+    /// file while it is open.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(open_options_ext)]\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// // Do not allow others to read or modify this file while we have it open\n+    /// // for writing\n+    /// let file = OpenOptions::new().write(true)\n+    ///                              .share_mode(0)\n+    ///                              .open(\"foo.txt\");\n+    /// ```\n     fn share_mode(&mut self, val: u32) -> &mut Self;\n+\n+    /// Sets extra flags for the `dwFileFlags` argument to the call to\n+    /// `CreateFile2` (or combines it with `attributes` and `security_qos_flags`\n+    /// to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    ///\n+    /// Custom flags can only set flags, not remove flags set by Rusts options.\n+    /// This options overwrites any previously set custom flags.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate winapi;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.create(true).write(true);\n+    /// if cfg!(windows) {\n+    ///     options.custom_flags(winapi::FILE_FLAG_DELETE_ON_CLOSE);\n+    /// }\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[unstable(feature = \"expand_open_options\",\n+               reason = \"recently added\",\n+               issue = \"30014\")]\n+    fn custom_flags(&mut self, flags: u32) -> &mut Self;\n+\n+    /// Sets the `dwFileAttributes` argument to the call to `CreateFile2` to\n+    /// the specified value (or combines it with `custom_flags` and\n+    /// `security_qos_flags` to set the `dwFlagsAndAttributes` for\n+    /// `CreateFile`).\n+    ///\n+    /// If a _new_ file is created because it does not yet exist and\n+    ///`.create(true)` or `.create_new(true)` are specified, the new file is\n+    /// given the attributes declared with `.attributes()`.\n+    ///\n+    /// If an _existing_ file is opened with `.create(true).truncate(true)`, its\n+    /// existing attributes are preserved and combined with the ones declared\n+    /// with `.attributes()`.\n+    ///\n+    /// In all other cases the attributes get ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// #![feature(open_options_ext)]\n+    /// extern crate winapi;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// let file = OpenOptions::new().write(true).create(true)\n+    ///                              .attributes(winapi::FILE_ATTRIBUTE_HIDDEN)\n+    ///                              .open(\"foo.txt\");\n+    /// ```\n+    fn attributes(&mut self, val: u32) -> &mut Self;\n+\n+    /// Sets the `dwSecurityQosFlags` argument to the call to `CreateFile2` to\n+    /// the specified value (or combines it with `custom_flags` and `attributes`\n+    /// to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions;\n }\n \n #[unstable(feature = \"open_options_ext\",\n            reason = \"may require more thought/methods\",\n            issue = \"27720\")]\n impl OpenOptionsExt for OpenOptions {\n-    fn desired_access(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().desired_access(access); self\n+    fn access_mode(&mut self, access: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().access_mode(access); self\n     }\n-    fn creation_disposition(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().creation_disposition(access); self\n+\n+    fn share_mode(&mut self, share: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().share_mode(share); self\n     }\n-    fn flags_and_attributes(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().flags_and_attributes(access); self\n+\n+    fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().custom_flags(flags); self\n     }\n-    fn share_mode(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().share_mode(access); self\n+\n+    fn attributes(&mut self, attributes: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().attributes(attributes); self\n+    }\n+\n+    fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().security_qos_flags(flags); self\n     }\n }\n "}, {"sha": "60e3f7c22bd58c0484be6c0ba684e1e6fb714f0b", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 91, "deletions": 65, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292af75f8d69b3856f7cb1555654bad7b54a9cc4/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=292af75f8d69b3856f7cb1555654bad7b54a9cc4", "patch": "@@ -54,18 +54,22 @@ pub struct DirEntry {\n     data: c::WIN32_FIND_DATAW,\n }\n \n-#[derive(Clone, Default)]\n+#[derive(Clone)]\n pub struct OpenOptions {\n-    create: bool,\n-    append: bool,\n+    // generic\n     read: bool,\n     write: bool,\n+    append: bool,\n     truncate: bool,\n-    desired_access: Option<c::DWORD>,\n-    share_mode: Option<c::DWORD>,\n-    creation_disposition: Option<c::DWORD>,\n-    flags_and_attributes: Option<c::DWORD>,\n-    security_attributes: usize, // *mut T doesn't have a Default impl\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: u32,\n+    access_mode: Option<c::DWORD>,\n+    attributes: c::DWORD,\n+    share_mode: c::DWORD,\n+    security_qos_flags: c::DWORD,\n+    security_attributes: usize, // FIXME: should be a reference\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -151,68 +155,86 @@ impl DirEntry {\n }\n \n impl OpenOptions {\n-    pub fn new() -> OpenOptions { Default::default() }\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n+            access_mode: None,\n+            share_mode: c::FILE_SHARE_READ | c::FILE_SHARE_WRITE | c::FILE_SHARE_DELETE,\n+            attributes: 0,\n+            security_qos_flags: 0,\n+            security_attributes: 0,\n+        }\n+    }\n+\n     pub fn read(&mut self, read: bool) { self.read = read; }\n     pub fn write(&mut self, write: bool) { self.write = write; }\n     pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n     pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn creation_disposition(&mut self, val: u32) {\n-        self.creation_disposition = Some(val);\n-    }\n-    pub fn flags_and_attributes(&mut self, val: u32) {\n-        self.flags_and_attributes = Some(val);\n-    }\n-    pub fn desired_access(&mut self, val: u32) {\n-        self.desired_access = Some(val);\n-    }\n-    pub fn share_mode(&mut self, val: u32) {\n-        self.share_mode = Some(val);\n-    }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    pub fn custom_flags(&mut self, flags: u32) { self.custom_flags = flags; }\n+    pub fn access_mode(&mut self, access_mode: u32) { self.access_mode = Some(access_mode); }\n+    pub fn share_mode(&mut self, share_mode: u32) { self.share_mode = share_mode; }\n+    pub fn attributes(&mut self, attrs: u32) { self.attributes = attrs; }\n+    pub fn security_qos_flags(&mut self, flags: u32) { self.security_qos_flags = flags; }\n     pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {\n         self.security_attributes = attrs as usize;\n     }\n \n-    fn get_desired_access(&self) -> c::DWORD {\n-        self.desired_access.unwrap_or({\n-            let mut base = if self.read {c::FILE_GENERIC_READ} else {0} |\n-                           if self.write {c::FILE_GENERIC_WRITE} else {0};\n-            if self.append {\n-                base &= !c::FILE_WRITE_DATA;\n-                base |= c::FILE_APPEND_DATA;\n-            }\n-            base\n-        })\n+    fn get_access_mode(&self) -> io::Result<c::DWORD> {\n+        const ERROR_INVALID_PARAMETER: i32 = 87;\n+\n+        match (self.read, self.write, self.append, self.access_mode) {\n+            (_, _, _, Some(mode)) => Ok(mode),\n+            (true,  false, false, None) => Ok(c::GENERIC_READ),\n+            (false, true,  false, None) => Ok(c::GENERIC_WRITE),\n+            (true,  true,  false, None) => Ok(c::GENERIC_READ | c::GENERIC_WRITE),\n+            (false, _,     true,  None) => Ok(c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA),\n+            (true,  _,     true,  None) => Ok(c::GENERIC_READ |\n+                                              (c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA)),\n+            (false, false, false, None) => Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER)),\n+        }\n     }\n \n-    fn get_share_mode(&self) -> c::DWORD {\n-        // libuv has a good comment about this, but the basic idea is that\n-        // we try to emulate unix semantics by enabling all sharing by\n-        // allowing things such as deleting a file while it's still open.\n-        self.share_mode.unwrap_or(c::FILE_SHARE_READ |\n-                                  c::FILE_SHARE_WRITE |\n-                                  c::FILE_SHARE_DELETE)\n-    }\n-\n-    fn get_creation_disposition(&self) -> c::DWORD {\n-        self.creation_disposition.unwrap_or({\n-            match (self.create, self.truncate) {\n-                (true, true) => c::CREATE_ALWAYS,\n-                (true, false) => c::OPEN_ALWAYS,\n-                (false, false) => c::OPEN_EXISTING,\n-                (false, true) => {\n-                    if self.write && !self.append {\n-                        c::CREATE_ALWAYS\n-                    } else {\n-                        c::TRUNCATE_EXISTING\n-                    }\n-                }\n-            }\n-        })\n+    fn get_creation_mode(&self) -> io::Result<c::DWORD> {\n+        const ERROR_INVALID_PARAMETER: i32 = 87;\n+\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n+                },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => c::OPEN_EXISTING,\n+                (true,  false, false) => c::OPEN_ALWAYS,\n+                (false, true,  false) => c::TRUNCATE_EXISTING,\n+                (true,  true,  false) => c::CREATE_ALWAYS,\n+                (_,      _,    true)  => c::CREATE_NEW,\n+           })\n     }\n \n     fn get_flags_and_attributes(&self) -> c::DWORD {\n-        self.flags_and_attributes.unwrap_or(c::FILE_ATTRIBUTE_NORMAL)\n+        self.custom_flags |\n+        self.attributes |\n+        self.security_qos_flags |\n+        if self.security_qos_flags != 0 { c::SECURITY_SQOS_PRESENT } else { 0 } |\n+        if self.create_new { c::FILE_FLAG_OPEN_REPARSE_POINT } else { 0 }\n     }\n }\n \n@@ -221,19 +243,19 @@ impl File {\n         let mut opts = OpenOptions::new();\n         opts.read(!write);\n         opts.write(write);\n-        opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT |\n-                                  c::FILE_FLAG_BACKUP_SEMANTICS);\n+        opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT |\n+                          c::FILE_FLAG_BACKUP_SEMANTICS);\n         File::open(path, &opts)\n     }\n \n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n         let path = try!(to_u16s(path));\n         let handle = unsafe {\n             c::CreateFileW(path.as_ptr(),\n-                           opts.get_desired_access(),\n-                           opts.get_share_mode(),\n+                           try!(opts.get_access_mode()),\n+                           opts.share_mode,\n                            opts.security_attributes as *mut _,\n-                           opts.get_creation_disposition(),\n+                           try!(opts.get_creation_mode()),\n                            opts.get_flags_and_attributes(),\n                            ptr::null_mut())\n         };\n@@ -533,7 +555,10 @@ pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     // metadata information is.\n     if attr.is_reparse_point() {\n         let mut opts = OpenOptions::new();\n-        opts.flags_and_attributes(c::FILE_FLAG_BACKUP_SEMANTICS);\n+        // No read or write permissions are necessary\n+        opts.access_mode(0);\n+        // This flag is so we can open directories too\n+        opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n         let file = try!(File::open(p, &opts));\n         file.file_attr()\n     } else {\n@@ -577,9 +602,10 @@ fn get_path(f: &File) -> io::Result<PathBuf> {\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let mut opts = OpenOptions::new();\n-    opts.read(true);\n+    // No read or write permissions are necessary\n+    opts.access_mode(0);\n     // This flag is so we can open directories too\n-    opts.flags_and_attributes(c::FILE_FLAG_BACKUP_SEMANTICS);\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n     let f = try!(File::open(p, &opts));\n     get_path(&f)\n }"}]}