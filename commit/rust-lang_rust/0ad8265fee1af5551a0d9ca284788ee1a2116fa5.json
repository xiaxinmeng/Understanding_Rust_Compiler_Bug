{"sha": "0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZDgyNjVmZWUxYWY1NTUxYTBkOWNhMjg0Nzg4ZWUxYTIxMTZmYTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-09T19:47:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-10T01:24:55Z"}, "message": "rustdoc: Add the concept of 'sections'", "tree": {"sha": "4bc49dbb24458c11704dda9ab36eec7b306ce17b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bc49dbb24458c11704dda9ab36eec7b306ce17b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "html_url": "https://github.com/rust-lang/rust/commit/0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ffcb959744194413ca20223274d2c351ad7686c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ffcb959744194413ca20223274d2c351ad7686c", "html_url": "https://github.com/rust-lang/rust/commit/4ffcb959744194413ca20223274d2c351ad7686c"}], "stats": {"total": 339, "additions": 337, "deletions": 2}, "files": [{"sha": "256baf7e50fdcc9a59a9212bb1f780c549de74a3", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "patch": "@@ -11,6 +11,15 @@ enum page {\n     itempage(itemtag)\n }\n \n+#[doc = \"\n+Most rustdocs can be parsed into 'sections' according to their markdown\n+headers\n+\"]\n+type section = {\n+    header: str,\n+    body: str\n+};\n+\n // FIXME: We currently give topmod the name of the crate.  There would\n // probably be fewer special cases if the crate had its own name and\n // topmod's name was the empty string.\n@@ -36,6 +45,7 @@ type itemdoc = {\n     path: [str],\n     brief: option<str>,\n     desc: option<str>,\n+    sections: [section],\n     // Indicates that this node is a reexport of a different item\n     reexport: bool\n };\n@@ -99,6 +109,7 @@ type methoddoc = {\n     name: str,\n     brief: option<str>,\n     desc: option<str>,\n+    sections: [section],\n     args: [argdoc],\n     return: retdoc,\n     failure: option<str>,\n@@ -400,4 +411,8 @@ impl util<A:item> for A {\n     fn desc() -> option<str> {\n         self.item().desc\n     }\n+\n+    fn sections() -> [section] {\n+        self.item().sections\n+    }\n }\n\\ No newline at end of file"}, {"sha": "3aadfbaa40c2169a9d2e2b6233690f62a6544da6", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "patch": "@@ -44,6 +44,7 @@ fn mk_itemdoc(id: ast::node_id, name: ast::ident) -> doc::itemdoc {\n         path: [],\n         brief: none,\n         desc: none,\n+        sections: [],\n         reexport: false\n     }\n }\n@@ -250,6 +251,7 @@ fn ifacedoc_from_iface(\n                 name: method.ident,\n                 brief: none,\n                 desc: none,\n+                sections: [],\n                 args: argdocs_from_args(method.decl.inputs),\n                 return: {\n                     desc: none\n@@ -292,6 +294,7 @@ fn impldoc_from_impl(\n                 name: method.ident,\n                 brief: none,\n                 desc: none,\n+                sections: [],\n                 args: argdocs_from_args(method.decl.inputs),\n                 return: {\n                     desc: none"}, {"sha": "c879846eb162f00f0016e9f7859983c7e78c0067", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "patch": "@@ -40,3 +40,4 @@ mod sort_item_type_pass;\n mod reexport_pass;\n mod par;\n mod page_pass;\n+mod sectionalize_pass;\n\\ No newline at end of file"}, {"sha": "a893dccfa714c74e6223438464a110078c140290", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "patch": "@@ -148,8 +148,9 @@ fn run(config: config::config) {\n             // prune_undoc_items_pass::mk_pass(),\n             prune_hidden_pass::mk_pass(),\n             desc_to_brief_pass::mk_pass(),\n-            trim_pass::mk_pass(),\n             unindent_pass::mk_pass(),\n+            sectionalize_pass::mk_pass(),\n+            trim_pass::mk_pass(),\n             sort_item_name_pass::mk_pass(),\n             sort_item_type_pass::mk_pass(),\n             markdown_index_pass::mk_pass(config),"}, {"sha": "fc957835822a2ecacaf91b639d823d919f2017e0", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "patch": "@@ -0,0 +1,237 @@\n+#[doc = \"Breaks rustdocs into sections according to their headers\"];\n+\n+export mk_pass;\n+\n+fn mk_pass() -> pass {\n+    {\n+        name: \"sectionalize\",\n+        f: run\n+    }\n+}\n+\n+fn run(_srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+    let fold = fold::fold({\n+        fold_item: fold_item,\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n+        with *fold::default_any_fold(())\n+    });\n+    fold.fold_doc(fold, doc)\n+}\n+\n+fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n+    let doc = fold::default_seq_fold_item(fold, doc);\n+    let (desc, sections) = sectionalize(doc.desc);\n+\n+    {\n+        desc: desc,\n+        sections: sections\n+        with doc\n+    }\n+}\n+\n+fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n+    let doc = fold::default_seq_fold_iface(fold, doc);\n+\n+    {\n+        methods: par::anymap(doc.methods) {|method|\n+            let (desc, sections) = sectionalize(method.desc);\n+\n+            {\n+                desc: desc,\n+                sections: sections\n+                with method\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n+fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n+    let doc = fold::default_seq_fold_impl(fold, doc);\n+\n+    {\n+        methods: par::anymap(doc.methods) {|method|\n+            let (desc, sections) = sectionalize(method.desc);\n+\n+            {\n+                desc: desc,\n+                sections: sections\n+                with method\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n+fn sectionalize(desc: option<str>) -> (option<str>, [doc::section]) {\n+\n+    #[doc = \"\n+\n+    Take a description of the form\n+\n+        General text\n+\n+        # Section header\n+\n+        Section text\n+\n+        # Section header\n+\n+        Section text\n+\n+    and remove each header and accompanying text into section records.\n+\n+    \"];\n+\n+    if option::is_none(desc) {\n+        ret (none, []);\n+    }\n+\n+    let lines = str::lines(option::get(desc));\n+\n+    let new_desc = none;\n+    let current_section = none;\n+    let sections = [];\n+\n+    for line in lines {\n+        alt parse_header(line) {\n+          some(header) {\n+            if option::is_some(current_section) {\n+                sections += [option::get(current_section)];\n+            }\n+            current_section = some({\n+                header: header,\n+                body: \"\"\n+            });\n+          }\n+          none {\n+            alt current_section {\n+              some(section) {\n+                current_section = some({\n+                    body: section.body + \"\\n\" + line\n+                    with section\n+                });\n+              }\n+              none {\n+                alt new_desc {\n+                  some(desc) {\n+                    new_desc = some(desc + \"\\n\" + line);\n+                  }\n+                  none {\n+                    new_desc = some(line);\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+    }\n+\n+    if option::is_some(current_section) {\n+        sections += [option::get(current_section)];\n+    }\n+\n+    (new_desc, sections)\n+}\n+\n+fn parse_header(line: str) -> option<str> {\n+    if str::starts_with(line, \"# \") {\n+        some(str::slice(line, 2u, str::len(line)))\n+    } else {\n+        none\n+    }\n+}\n+\n+#[test]\n+fn should_create_section_headers() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert str::contains(\n+        doc.cratemod().mods()[0].item.sections[0].header,\n+        \"Header\");\n+}\n+\n+#[test]\n+fn should_create_section_bodies() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert str::contains(\n+        doc.cratemod().mods()[0].item.sections[0].body,\n+        \"Body\");\n+}\n+\n+#[test]\n+fn should_not_create_sections_from_indented_headers() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\n\\\n+         Text\\n             # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert vec::is_empty(doc.cratemod().mods()[0].item.sections);\n+}\n+\n+#[test]\n+fn should_remove_section_text_from_main_desc() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         Description\\n\\n\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert !str::contains(\n+        option::get(doc.cratemod().mods()[0].desc()),\n+        \"Header\");\n+    assert !str::contains(\n+        option::get(doc.cratemod().mods()[0].desc()),\n+        \"Body\");\n+}\n+\n+#[test]\n+fn should_eliminate_desc_if_it_is_just_whitespace() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert doc.cratemod().mods()[0].desc() == none;\n+}\n+\n+#[test]\n+fn should_sectionalize_iface_methods() {\n+    let doc = test::mk_doc(\n+        \"iface i {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         fn a(); }\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sections.len() == 1u;\n+}\n+\n+#[test]\n+fn should_sectionalize_impl_methods() {\n+    let doc = test::mk_doc(\n+        \"impl i for bool {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].sections.len() == 1u;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::doc {\n+        astsrv::from_str(source) {|srv|\n+            let doc = extract::from_srv(srv, \"\");\n+            let doc = attr_pass::mk_pass().f(srv, doc);\n+            run(srv, doc)\n+        }\n+    }\n+}"}, {"sha": "cb19788333151067ee5b96fe1ca86a06b5e40e87", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad8265fee1af5551a0d9ca284788ee1a2116fa5/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=0ad8265fee1af5551a0d9ca284788ee1a2116fa5", "patch": "@@ -39,11 +39,21 @@ fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n \n     {\n         brief: maybe_apply_op(fold.ctxt, doc.brief),\n-        desc: maybe_apply_op(fold.ctxt, doc.desc)\n+        desc: maybe_apply_op(fold.ctxt, doc.desc),\n+        sections: apply_to_sections(fold.ctxt, doc.sections)\n         with doc\n     }\n }\n \n+fn apply_to_sections(op: op, sections: [doc::section]) -> [doc::section] {\n+    par::anymap(sections) {|section|\n+        {\n+            header: op(section.header),\n+            body: op(section.body)\n+        }\n+    }\n+}\n+\n fn fold_fn(fold: fold::fold<op>, doc: doc::fndoc) -> doc::fndoc {\n     let fold_ctxt = fold.ctxt;\n     let doc = fold::default_seq_fold_fn(fold, doc);\n@@ -108,6 +118,7 @@ fn apply_to_methods(op: op, docs: [doc::methoddoc]) -> [doc::methoddoc] {\n         {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n+            sections: apply_to_sections(op, doc.sections),\n             args: par::anymap(doc.args) {|doc|\n                 {\n                     desc: maybe_apply_op(op, doc.desc)\n@@ -282,12 +293,79 @@ fn should_execute_op_on_type_desc() {\n     assert doc.cratemod().types()[0].desc() == some(\"a\");\n }\n \n+#[test]\n+fn should_execute_on_item_section_headers() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         #    Header    \\n\\\n+         Body\\\"]\\\n+         fn a() { }\");\n+    assert doc.cratemod().fns()[0].sections()[0].header == \"Header\";\n+}\n+\n+#[test]\n+fn should_execute_on_item_section_bodies() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body      \\\"]\\\n+         fn a() { }\");\n+    assert doc.cratemod().fns()[0].sections()[0].body == \"Body\";\n+}\n+\n+#[test]\n+fn should_execute_on_iface_method_section_headers() {\n+    let doc = test::mk_doc(\n+        \"iface i {\n+         #[doc = \\\"\\\n+         # Header    \\n\\\n+         Body\\\"]\\\n+         fn a(); }\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sections[0].header\n+        == \"Header\";\n+}\n+\n+#[test]\n+fn should_execute_on_iface_method_section_bodies() {\n+    let doc = test::mk_doc(\n+        \"iface i {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body     \\\"]\\\n+         fn a(); }\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sections[0].body == \"Body\";\n+}\n+\n+#[test]\n+fn should_execute_on_impl_method_section_headers() {\n+    let doc = test::mk_doc(\n+        \"impl i for bool {\n+         #[doc = \\\"\\\n+         # Header   \\n\\\n+         Body\\\"]\\\n+         fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].sections[0].header\n+        == \"Header\";\n+}\n+\n+#[test]\n+fn should_execute_on_impl_method_section_bodies() {\n+    let doc = test::mk_doc(\n+        \"impl i for bool {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body    \\\"]\\\n+         fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].sections[0].body == \"Body\";\n+}\n+\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n+            let doc = sectionalize_pass::mk_pass().f(srv, doc);\n             mk_pass(\"\", {|s| str::trim(s)}).f(srv, doc)\n         }\n     }"}]}