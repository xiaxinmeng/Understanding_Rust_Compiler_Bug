{"sha": "861b8f0107fe55941df7ca391dee51fe338b0bd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MWI4ZjAxMDdmZTU1OTQxZGY3Y2EzOTFkZWU1MWZlMzM4YjBiZDg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-18T15:03:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-18T15:28:31Z"}, "message": "Fill out some parts of the reference docs", "tree": {"sha": "604d1d5a1b1c8ae555715fda7fbc394801f7074c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/604d1d5a1b1c8ae555715fda7fbc394801f7074c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/861b8f0107fe55941df7ca391dee51fe338b0bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/861b8f0107fe55941df7ca391dee51fe338b0bd8", "html_url": "https://github.com/rust-lang/rust/commit/861b8f0107fe55941df7ca391dee51fe338b0bd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/861b8f0107fe55941df7ca391dee51fe338b0bd8/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e40cd654b957969e47285b9298aa16908b215c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40cd654b957969e47285b9298aa16908b215c20", "html_url": "https://github.com/rust-lang/rust/commit/e40cd654b957969e47285b9298aa16908b215c20"}], "stats": {"total": 525, "additions": 489, "deletions": 36}, "files": [{"sha": "fd7d4bf63d0d20b0ddc39bd480bb898ee9ad05bf", "filename": "doc/rust.md", "status": "modified", "additions": 489, "deletions": 36, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/861b8f0107fe55941df7ca391dee51fe338b0bd8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/861b8f0107fe55941df7ca391dee51fe338b0bd8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=861b8f0107fe55941df7ca391dee51fe338b0bd8", "patch": "@@ -208,25 +208,28 @@ import export use mod dir\n \n The keywords in [source files](#source-files) are the following strings:\n \n+*TODO* split these between type keywords and regular (value) keywords,\n+ and define two different `identifier` productions for the different\n+ contexts.\n+\n ~~~~~~~~ {.keyword}\n alt any as assert\n be bind block bool break\n char check claim const cont\n do\n else export\n f32 f64 fail false float fn for\n-i16 i32 i64 i8 if import in int\n+i16 i32 i64 i8 if iface impl import in int\n let log\n mod mutable\n native note\n-obj  \n prove pure\n resource ret\n self str syntax\n tag true type\n u16 u32 u64 u8 uint unchecked unsafe use\n vec\n-while with\n+while\n ~~~~~~~~\n \n Any of these have special meaning in their respective grammars, and are\n@@ -377,11 +380,12 @@ A _floating-point literal_ has one of two forms:\n   second decimal literal.\n * A single _decimal literal_ followed by an _exponent_.\n \n-By default, a floating-point literal is of type `float`. A floating-point\n-literal may be followed (immediately, without any spaces) by a\n-_floating-point suffix_, which changes the type of the literal. There are\n-only two floating-point suffixes: `f32` and `f64`. Each of these gives the\n-floating point literal the associated type, rather than `float`.\n+By default, a floating-point literal is of type `float`. A\n+floating-point literal may be followed (immediately, without any\n+spaces) by a _floating-point suffix_, which changes the type of the\n+literal. There are three floating-point suffixes: `f` (for the base\n+`float` type), `f32`, and `f64` (the 32-bit and 64-bit floating point\n+types).\n \n A set of suffixes are also reserved to accommodate literal support for\n types corresponding to reserved tokens. The reserved suffixes are `f16`,\n@@ -392,10 +396,17 @@ Examples of floating-point literals of various forms:\n ~~~~\n 123.0;                             // type float\n 0.1;                               // type float\n+3f;                                // type float\n 0.1f32;                            // type f32\n 12E+99_f64;                        // type f64\n ~~~~\n \n+##### Nil and boolean literals\n+\n+The _nil value_, the only value of the type by the same name, is\n+written as `()`. The two values of the boolean type are written `true`\n+and `false`.\n+\n ### Symbols\n \n ~~~~~~~~ {.ebnf .gram}\n@@ -898,9 +909,9 @@ A non-boolean function may also be declared with `pure fn`. This allows\n predicates to call non-boolean functions as long as they are pure. For example:\n \n ~~~~\n-pure fn pure_length<@T>(ls: list<T>) -> uint { /* ... */ }\n+pure fn pure_length<T>(ls: list<T>) -> uint { /* ... */ }\n \n-pure fn nonempty_list<@T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n ~~~~\n \n In this example, `nonempty_list` is a predicate---it can be used in a\n@@ -928,14 +939,14 @@ verify the semantics of the predicates they write.\n An example of a predicate that uses an unchecked block:\n \n ~~~~\n-fn pure_foldl<@T, @U>(ls: list<T>, u: U, f: block(&T, &U) -> U) -> U {\n+fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: block(&T, &U) -> U) -> U {\n     alt ls {\n       nil. { u }\n       cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n     }\n }\n \n-pure fn pure_length<@T>(ls: list<T>) -> uint {\n+pure fn pure_length<T>(ls: list<T>) -> uint {\n     fn count<T>(_t: T, u: uint) -> uint { u + 1u }\n     unchecked {\n         pure_foldl(ls, 0u, count)\n@@ -949,6 +960,45 @@ function. So, to use `foldl` in a pure list length function that a predicate\n could then use, we must use an `unchecked` block wrapped around the call to\n `pure_foldl` in the definition of `pure_length`.\n \n+#### Generic functions\n+\n+A _generic function_ allows one or more _parameterized types_ to\n+appear in its signature. Each type parameter must be explicitly\n+declared, in an angle-bracket-enclosed, comma-separated list following\n+the function name.\n+\n+~~~~\n+fn iter<T>(seq: [T], f: block(T)) {\n+    for elt: T in seq { f(elt); }\n+}\n+fn map<T, U>(seq: [T], f: block(T) -> U) -> [U] {\n+    let acc = [];\n+    for elt in seq { acc += [f(elt)]; }\n+    acc\n+}\n+~~~~\n+\n+Inside the function signature and body, the name of the type parameter\n+can be used as a type name.\n+\n+When a generic function is referenced, its type is instantiated based\n+on the context of the reference. For example, calling the `iter`\n+function defined above on `[1, 2]` will instantiate type parameter `T`\n+with `int`, and require the closure parameter to have type\n+`block(int)`.\n+\n+Since a parameter type is opaque to the generic function, the set of\n+operations that can be performed on it is limited. Values of parameter\n+type can always be moved, but they can only be copied when the\n+parameter is given a [`copy` bound](#type-kinds).\n+\n+~~~~\n+fn id<T: copy>(x: T) -> T { x }\n+~~~~\n+\n+Similarly, [interface](#interfaces) bounds can be specified for type\n+parameters to allow methods of that interface to be called on values\n+of that type.\n \n ### Type definitions\n \n@@ -1012,14 +1062,147 @@ let a: list<int> = cons(7, @cons(13, @nil));\n ~~~~\n \n ### Resources\n-*TODO*.\n+\n+_Resources_ are values that have a destructor associated with them. A\n+_resource item_ is used to declare resource type and constructor.\n+\n+~~~~\n+resource file_descriptor(fd: int) {\n+    std::os::libc::close(fd);\n+}\n+~~~~\n+\n+Calling the `file_descriptor` constructor function on an integer will\n+produce a value with the `file_descriptor` type. Resource types have a\n+noncopyable [type kind](#type-kinds), and thus may not be copied. It\n+is guaranteed, barring drastic program termination that somehow\n+prevents unwinding from taking place, that for each constucted\n+resource value, the destructor will run once, when the value is\n+disposed of. For stack-allocated values, this happens when the value\n+goes out of scope. For values in shared boxes, it happens when the\n+reference count of the box reaches zero.\n+\n+The argument to the resource constructor is stored in the resulting\n+value, and can be accessed using the dereference (`*`) [unary\n+operator](#unary-operator-expressions).\n \n ### Interfaces\n-*TODO*.\n+\n+An _interface item_ describes a set of method types. _[implementation\n+items](#implementations)_ can be used to provide implementations of\n+those methods for a specific type.\n+\n+~~~~\n+iface shape {\n+    fn draw(surface);\n+    fn bounding_box() -> bounding_box;\n+}\n+~~~~\n+\n+This defines an interface with two methods. All values which have\n+[implementations](#implementations) of this interface in scope can\n+have their `draw` and `bounding_box` methods called, using\n+`value.bounding_box()` [syntax](#field-expressions).\n+\n+Type parameters can be specified for an interface to make it generic.\n+These appear after the name, using the same syntax used in [generic\n+functions](#generic-functions).\n+\n+~~~~\n+iface seq<T> {\n+   fn len() -> uint;\n+   fn elt_at(n: uint) -> T;\n+   fn iter(block(T));\n+}\n+~~~~\n+\n+Generic functions may use interfaces as bounds on their type\n+parameters. This will have two effects: only types that implement the\n+interface can be used to instantiate the parameter, and within the\n+generic function, the methods of the interface can be called on values\n+that have the parameter's type. For example:\n+\n+~~~~\n+fn draw_twice<T: shape>(surface: surface, sh: T) {\n+    sh.draw(surface);\n+    sh.draw(surface);\n+}\n+~~~~\n+\n+Interface items also define a type with the same name as the\n+interface. Values of this type are created by\n+[casting](#type-cast-expressions) values (of a type for which an\n+implementation of the given interface is in scope) to the interface\n+type.\n+\n+~~~~\n+let myshape: shape = mycircle as shape;\n+~~~~\n+\n+The resulting value is a reference counted box containing the value\n+that was cast along with information that identify the methods of the\n+implementation that was used. Values with an interface type can always\n+have methods of their interface called on them, and can be used to\n+instantiate type parameters that are bounded on their interface.\n \n ### Implementations\n-*TODO*.\n \n+An _implementation item_ provides an implementation of an\n+[interfaces](#interfaces) for a type.\n+\n+~~~~\n+type circle = {radius: float, center: point};\n+    \n+impl circle_shape of shape for circle {\n+    fn draw(s: surface) { do_draw_circle(s, self); }\n+    fn bounding_box() -> bounding_box {\n+        let r = self.radius;\n+        {x: self.center.x - r, y: self.center.y - r,\n+         width: 2 * r, height: 2 * r}\n+    }\n+}\n+~~~~\n+\n+This defines an implementation named `circle_shape` of interface\n+`shape` for type `circle`. The name of the implementation is the name\n+by which it is imported and exported, but has no further significance.\n+It may be left off to default to the name of the interface that was\n+implemented. Implementation names do not conflict the way other names\n+do\u2014multiple implementations with the same name may exist in a scope at\n+the same time.\n+\n+It is possible to define an implementation without referencing an\n+interface. The methods in such an implementation can only be used\n+statically (as direct calls on the values of the type that the\n+implementation targets). In such an implementation, the `of` clause is\n+not given, and the name is mandatory.\n+\n+~~~~\n+impl uint_loops for uint {\n+    fn times(f: block(uint)) {\n+        let i = 0;\n+        while i < self { f(i); i += 1u; }\n+    }\n+}\n+~~~~\n+\n+_When_ an interface is specified, all methods declared as part of the\n+interface must be present, with matching types and type parameter\n+counts, in the implementation.\n+\n+An implementation can take type parameters, which can be different\n+from the type parameters taken by the interface it implements. They\n+are written after the name of the implementation, or if that is not\n+specified, after the `impl` keyword.\n+\n+~~~~\n+impl <T> of seq<T> for [T] {\n+    /* ... */\n+}\n+impl of seq<bool> for u32 {\n+   /* Treat the integer as a sequence of bits */\n+}\n+~~~~\n \n ## Attributes\n \n@@ -1161,7 +1344,7 @@ scope.\n The former form, with no type annotation, causes the compiler to infer the\n static type of the slot through unification with the types of values assigned\n to the slot in the remaining code in the block scope. Inference only occurs on\n-frame-local slots, not argument slots. Function and object signatures must\n+frame-local slots, not argument slots. Function signatures must\n always declared types for all argument slots.\n \n \n@@ -1175,39 +1358,206 @@ the side effects of the expression's evaluation.\n \n ### Literal expressions\n \n-*TODO*.\n+A _literal expression_ consists of one of the [literal](#literals)\n+forms described earlier. It directly describes a number, character,\n+string, boolean value, or the nil value.\n+\n+~~~~~~~~ {.literals}\n+();        // nil type\n+\"hello\";   // string type\n+'5';       // character type\n+5;         // integer type\n+~~~~~~~~\n \n ### Tuple expressions\n \n-*TODO*.\n+Tuples are written by enclosing two or more comma-separated\n+expressions in parentheses. They are used to create [tuple\n+typed](#tuple-types) values.\n+\n+~~~~~~~~ {.tuple}\n+(0f, 4.5f);\n+(\"a\", 4u, true)\n+~~~~~~~~\n \n ### Record expressions\n \n-*TODO*.\n+A _[record](#record-types) expression_ is one or more comma-separated\n+name-value pairs enclosed by braces. A fieldname can be any identifier\n+(including reserved words), and is separated from its value expression\n+by a colon. To indicate that a field is mutable, the `mutable` keyword\n+is written before its name.\n+\n+~~~~\n+{x: 10f, y: 20f};\n+{name: \"Joe\", age: 35u, score: 100_000};\n+{ident: \"X\", mutable count: 0u};\n+~~~~\n+\n+The order of the fields in a record expression is significant, and\n+determines the type of the resulting value. `{a: u8, b: u8}` and `{b:\n+u8, a: u8}` are two different fields.\n+\n+A record expression can be ended with the word `with` followed by an\n+expression to denote a functional update. The expression following\n+`with` (the base) be of a record type that includes at least all the\n+fields mentioned in the record expression. A new record will be\n+created, of the same type as the base expression, with the given\n+values for the fields that were explicitly specified, and the values\n+in the base record for all other fields. The ordering of the fields in\n+such a record expression is not significant.\n+\n+~~~~\n+let base = {x: 1, y: 2, z: 3};\n+{y: 0, z: 10 with base};\n+~~~~\n+\n+### Field expressions\n+\n+A dot can be used to access a field in a record.\n+\n+~~~~~~~~ {.field}\n+myrecord.myfield;\n+{a: 10, b: 20}.a;\n+~~~~~~~~\n+\n+A field access on a record is an _lval_ referring to the value of that\n+field. When the field is mutable, it can be\n+[assigned](#assignment-expressions) to.\n+\n+When the type of the expression to the left of the dot is a boxed\n+record, it is automatically derferenced to make the field access\n+possible.\n+\n+Field access syntax is overloaded for [interface method](#interfaces)\n+access. When no matching field is found, or the expression to the left\n+of the dot is not a (boxed) record, an\n+[implementation](#implementations) that matches this type and the\n+given method name is looked up instead, and the result of the\n+expression is this method, with its _self_ argument bound to the\n+expression on the left of the dot.\n \n ### Vector expressions\n \n-*TODO*.\n+A _[vector](#vector-types) expression_ is written by enclosing zero or\n+more comma-separated expressions of uniform type in square brackets.\n+The keyword `mutable` can be written after the opening bracket to\n+indicate that the elements of the resulting vector may be mutated.\n+When no mutability is specified, the vector is immutable.\n+\n+~~~~\n+[1, 2, 3, 4];\n+[\"a\", \"b\", \"c\", \"d\"];\n+[mutable 0u8, 0u8, 0u8, 0u8];\n+~~~~\n+\n+### Index expressions\n+\n+[Vector](#vector-types)-typed expressions can be indexed by writing a\n+square-bracket-enclosed expression (the index) after them. When the\n+vector is mutable, the resulting _lval_ can be assigned to.\n+\n+Indices are zero-based, and may be of any integral type. Vector access\n+is bounds-checked at run-time. When the check fails, it will put the\n+task in a _failing state_.\n \n+~~~~\n+[1, 2, 3, 4][0];\n+[mutable 'x', 'y'][1] = 'z';\n+[\"a\", \"b\"][10]; // fails\n+~~~~\n \n ### Unary operator expressions\n \n-~~~~~~~~ {.unop}\n-+ - * ! @ ~\n-~~~~~~~~\n+Rust defines five unary operators. They are all written a prefix\n+operators, before the expression they apply to.\n+\n+`-`\n+  : Negation. May only be applied to numeric types.\n+`*`\n+  : Dereference. When applied to a [box](#box-types) or\n+    [resource](#resources) type, it accesses the inner value. For\n+    mutable boxes, the resulting _lval_ can be assigned to. For\n+    [enums](#enumerated-types) that have only a single variant,\n+    containing a single parameter, the dereference operator accesses\n+    this parameter.\n+`!`\n+  : Logical negation. On the boolean type, this flips between `true` and\n+    `false`. On integer types, this inverts the individual bits in the\n+    two's complement representation of the value.\n+`@` and `~`\n+  :  [Boxing](#box-types) operators. Allocate a box to hold the value\n+     they are applied to, and store the value in it. `@` creates a\n+     shared, reference-counted box, whereas `~` creates a unique box.\n \n ### Binary operator expressions\n \n-~~~~~~~~ {.binop}\n-.\n-+ - * / %\n-& | ^\n-|| &&\n-< <= == >= >\n-<< >> >>>\n-as\n-<- <-> = += -= *= /= %= &= |= ^= <<= >>= >>>=\n-~~~~~~~~\n+#### Arithmetic operators\n+\n+Binary arithmetic expressions require both their operands to be of the\n+same type, and can be applied only to numeric types, with the\n+exception of `+`, which acts both as addition operator on numbers and\n+as concatenate operator on vectors and strings.\n+\n+`+`\n+  : Addition and vector/string concatenation.\n+`-`\n+  : Subtraction.\n+`*`\n+  : Multiplication.\n+`/`\n+  : Division.\n+`%`\n+  : Remainder.\n+\n+#### Bitwise operators\n+\n+Bitwise operators apply only to integer types, and perform their\n+operation on the bits of the two's complement representation of the\n+values.\n+\n+`&`\n+  : And.\n+`|`\n+  : Inclusive or.\n+`^`\n+  : Exclusive or.\n+`<<`\n+  : Logical left shift.\n+`>>`\n+  : Logical right shift.\n+`>>>`\n+  : Arithmetic right shift.\n+\n+#### Lazy boolean operators\n+\n+The operators `||` and `&&` may be applied to operands of boolean\n+type. The first performs the 'or' operation, and the second the 'and'\n+operation. They differ from `|` and `&` in that the right-hand operand\n+is only evaluated when the left-hand operand does not already\n+determine the outcome of the expression. That is, `||` only evaluates\n+it right-hand operand when the left-hand operand evaluates to `false`,\n+and `&&` only when it evaluates to `true`.\n+\n+#### Comparison operators\n+\n+`==`\n+  : Equal to.\n+`!=`\n+  : Unequal to.\n+`<`\n+  : Less than.\n+`>`\n+  : Greater than.\n+`<=`\n+  : Less than or equal.\n+`>=`\n+  : Greater than or equal.\n+\n+The binary comparison operators can be applied to any two operands of\n+the same type, and produce a boolean value.\n+\n+*TODO* details on how types are descended during comparison.\n \n #### Type cast expressions\n \n@@ -1299,6 +1649,31 @@ x <- copy y\n \n The former is just more terse and familiar.\n \n+#### Operator-assignment expressions\n+\n+The `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`, and `>>>`\n+operators may be composed with the `=` operator. The expression `lval\n+OP= val` is equivalent to `lval = lval OP val`. For example, `x = x +\n+1` may be written as `x += 1`.\n+\n+#### Operator precedence\n+\n+The precedence of Rust binary operators is ordered as follows, going\n+from strong to weak:\n+\n+~~~~ {.precedence}\n+* / %\n++ -\n+<< >> >>>\n+&\n+^ |\n+as\n+< > <= >=\n+== !=\n+&&\n+||\n+~~~~\n+\n ### Unary copy expressions\n \n A _unary copy expression_ consists of the unary `copy` operator applied to\n@@ -1332,8 +1707,18 @@ assert v[0] == 1; // Original was not modified\n \n ### Unary move expressions\n \n-*TODO*.\n+This is used to indicate that the referenced _lval_ must be moved out,\n+rather than copied, when evaluating this expression. It will only have\n+effect when the expression is _stored_ somewhere or passed to a\n+function that takes ownership of it.\n+\n+~~~~\n+let x = ~10;\n+let y = [move x];\n+~~~~\n \n+Any access to `y` after applying the `move` operator to it is invalid,\n+since it is no longer initialized at that point.\n \n ### Call expressions\n \n@@ -2049,7 +2434,25 @@ denoted by named reference to an [*enumeration* item](#enumerations).\n \n ### Box types\n \n-*TODO*.\n+Box types are represented as pointers. There are three flavours of\n+pointers:\n+\n+Shared boxes (`@`)\n+  : These are reference-counted boxes. Their type is written\n+    `@content`, for example `@int` means a shared box containing an\n+    integer. Copying a value of such a type means copying the pointer\n+    and increasing the reference count.\n+\n+Unique boxes (`~`)\n+  : Unique boxes have only a single owner, and are freed when their\n+    owner releases them. They are written `~content`. Copying a\n+    unique box involves copying the contents into a new box.\n+\n+Unsafe pointers (`*`)\n+  : Unsafe pointers are pointers without safety guarantees or\n+    language-enforced semantics. Their type is written `*content`.\n+    They can be copied and dropped freely. Dereferencing an unsafe\n+    pointer is part of the unsafe sub-dialect of Rust.\n \n ### Function types\n \n@@ -2072,6 +2475,56 @@ let bo: binop = add;\n x = bo(5,7);\n ~~~~~~~~\n \n+## Type kinds\n+\n+Types in Rust are categorized into three kinds, based on whether they\n+allow copying of their values, and sending to different tasks. The\n+kinds are:\n+\n+Sendable\n+  : Values with a sendable type can be safely sent to another task.\n+    This kind includes scalars, unique pointers, unique closures, and\n+    structural types containing only other sendable types.\n+Copyable\n+  : This kind includes all types that can be copied. All types with\n+    sendable kind are copyable, as are shared boxes, shared closures,\n+    interface types, and structural types built out of these.\n+Noncopyable\n+  : [Resource](#resources) types, and every type that includes a\n+    resource without storing it in a shared box, may not be copied.\n+    Types of sendable or copyable type can always be used in places\n+    where a noncopyable type is expected, so in effect this kind\n+    includes all types.\n+\n+These form a hierarchy. The noncopyable kind is the widest, including\n+all types in the language. The copyable kind is a subset of that, and\n+the sendable kind is a subset of the copyable kind.\n+\n+Any operation that causes a value to be copied requires the type of\n+that value to be of copyable kind. Type parameter types are assumed to\n+be noncopyable, unless one of the special bounds `send` or `copy` is\n+declared for it. For example, this is not a valid program:\n+\n+~~~~\n+fn box<T>(x: T) -> @T { @x }\n+~~~~\n+\n+Putting `x` into a shared box involves copying, and the `T` parameter\n+is assumed to be noncopyable. To change that, a bound is declared:\n+\n+~~~~\n+fn box<T: copy>(x: T) -> @T { @x }\n+~~~~\n+\n+Calling this second version of `box` on a noncopyable type is not\n+allowed. When instantiating a type parameter, the kind bounds on the\n+parameter are checked to be the same or narrower than the kind of the\n+type that it is instantiated with.\n+\n+Sending operations are not part of the Rust language, but are\n+implemented in the library. Generic functions that send values bound\n+the kind of these values to sendable.\n+\n \n \n ## Typestate system\n@@ -2305,7 +2758,7 @@ consist of *boxes*.\n \n ### Memory allocation and lifetime\n \n-The _items_ of a program are those functions, objects, modules and types\n+The _items_ of a program are those functions, modules and types\n that have their value calculated at compile-time and stored uniquely in the\n memory image of the rust process. Items are neither dynamically allocated nor\n freed."}]}