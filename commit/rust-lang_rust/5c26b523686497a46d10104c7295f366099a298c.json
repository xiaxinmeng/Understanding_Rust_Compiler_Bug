{"sha": "5c26b523686497a46d10104c7295f366099a298c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMjZiNTIzNjg2NDk3YTQ2ZDEwMTA0YzcyOTVmMzY2MDk5YTI5OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-19T21:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-19T21:11:23Z"}, "message": "Auto merge of #62705 - petrochenkov:oh-bye-mark, r=matthewjasper\n\nlibsyntax: Rename `Mark` into `ExpnId`\n\n\"`Mark`\" is an ID that identifies both a macro invocation (`foo!()`), and expansion process, and expansion result of that macro invocation.\nThe problem is that it's pretty hard to infer that from its name.\n\nThis PR renames it into `ExpnId` reflecting its meaning in most contexts.\n(The contexts where it's meaning is closer to \"macro invocation ID\" are rarer.)\n\nI've kept \"mark\" in the names of functions that add or remove marks to/from syntactic contexts, those marks are not just expansion IDs, but something more complex.", "tree": {"sha": "dca53611133677adf1316b97433535c8a0c8808a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dca53611133677adf1316b97433535c8a0c8808a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c26b523686497a46d10104c7295f366099a298c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c26b523686497a46d10104c7295f366099a298c", "html_url": "https://github.com/rust-lang/rust/commit/5c26b523686497a46d10104c7295f366099a298c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c26b523686497a46d10104c7295f366099a298c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01", "html_url": "https://github.com/rust-lang/rust/commit/e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01"}, {"sha": "8f30d260304ffc260764e51b2d3e40d1734df502", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f30d260304ffc260764e51b2d3e40d1734df502", "html_url": "https://github.com/rust-lang/rust/commit/8f30d260304ffc260764e51b2d3e40d1734df502"}], "stats": {"total": 750, "additions": 378, "deletions": 372}, "files": [{"sha": "c228bc2cf6b8c33d22bbba60258c93e0c84a5f4e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -60,7 +60,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n use syntax::std_inject;\n@@ -437,7 +437,7 @@ impl<'a> LoweringContext<'a> {\n                                 owner,\n                                 id,\n                                 DefPathData::Misc,\n-                                Mark::root(),\n+                                ExpnId::root(),\n                                 tree.prefix.span,\n                             );\n                             self.lctx.allocate_hir_id_counter(id);\n@@ -875,7 +875,7 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.fresh_expansion(Mark::root(), ExpnInfo {\n+        span.fresh_expansion(ExpnId::root(), ExpnInfo {\n             def_site: span,\n             allow_internal_unstable,\n             ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n@@ -968,7 +968,7 @@ impl<'a> LoweringContext<'a> {\n             parent_index,\n             node_id,\n             DefPathData::LifetimeNs(str_name),\n-            Mark::root(),\n+            ExpnId::root(),\n             span,\n         );\n \n@@ -1462,7 +1462,7 @@ impl<'a> LoweringContext<'a> {\n                         parent_def_index,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n-                        Mark::root(),\n+                        ExpnId::root(),\n                         DUMMY_SP\n                     );\n \n@@ -1921,7 +1921,7 @@ impl<'a> LoweringContext<'a> {\n                         self.parent,\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().as_interned_str()),\n-                        Mark::root(),\n+                        ExpnId::root(),\n                         lifetime.span);\n \n                     let (name, kind) = match name {"}, {"sha": "d02aab54127a650694a5d9d1a7006e390602d80e", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -2,7 +2,7 @@ use crate::hir::map::definitions::*;\n use crate::hir::def_id::DefIndex;\n \n use syntax::ast::*;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::visit;\n use syntax::symbol::{kw, sym};\n use syntax::parse::token::{self, Token};\n@@ -12,11 +12,11 @@ use syntax_pos::Span;\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: DefIndex,\n-    expansion: Mark,\n+    expansion: ExpnId,\n }\n \n impl<'a> DefCollector<'a> {\n-    pub fn new(definitions: &'a mut Definitions, expansion: Mark) -> Self {\n+    pub fn new(definitions: &'a mut Definitions, expansion: ExpnId) -> Self {\n         let parent_def = definitions.invocation_parent(expansion);\n         DefCollector { definitions, parent_def, expansion }\n     }\n@@ -75,7 +75,7 @@ impl<'a> DefCollector<'a> {\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId) {\n-        self.definitions.set_invocation_parent(id.placeholder_to_mark(), self.parent_def);\n+        self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }\n "}, {"sha": "8ee8c6d0e898368be2dc6974d39c5fadfb487b2d", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -15,7 +15,7 @@ use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::util::nodemap::NodeMap;\n@@ -93,16 +93,16 @@ pub struct Definitions {\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: Vec<ast::NodeId>,\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n-    /// If `Mark` is an ID of some macro expansion,\n+    /// If `ExpnId` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n-    parent_modules_of_macro_defs: FxHashMap<Mark, DefId>,\n-    /// Item with a given `DefIndex` was defined during macro expansion with ID `Mark`.\n-    expansions_that_defined: FxHashMap<DefIndex, Mark>,\n+    parent_modules_of_macro_defs: FxHashMap<ExpnId, DefId>,\n+    /// Item with a given `DefIndex` was defined during macro expansion with ID `ExpnId`.\n+    expansions_that_defined: FxHashMap<DefIndex, ExpnId>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n-    /// When collecting definitions from an AST fragment produced by a macro invocation `Mark`\n+    /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table.\n-    invocation_parents: FxHashMap<Mark, DefIndex>,\n+    invocation_parents: FxHashMap<ExpnId, DefIndex>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -437,7 +437,7 @@ impl Definitions {\n         assert!(self.def_index_to_node.is_empty());\n         self.def_index_to_node.push(ast::CRATE_NODE_ID);\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n-        self.set_invocation_parent(Mark::root(), root_index);\n+        self.set_invocation_parent(ExpnId::root(), root_index);\n \n         // Allocate some other DefIndices that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n@@ -450,7 +450,7 @@ impl Definitions {\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n-                                  expansion: Mark,\n+                                  expn_id: ExpnId,\n                                   span: Span)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n@@ -498,8 +498,8 @@ impl Definitions {\n             self.node_to_def_index.insert(node_id, index);\n         }\n \n-        if expansion != Mark::root() {\n-            self.expansions_that_defined.insert(index, expansion);\n+        if expn_id != ExpnId::root() {\n+            self.expansions_that_defined.insert(index, expn_id);\n         }\n \n         // The span is added if it isn't dummy\n@@ -519,23 +519,23 @@ impl Definitions {\n         self.node_to_hir_id = mapping;\n     }\n \n-    pub fn expansion_that_defined(&self, index: DefIndex) -> Mark {\n-        self.expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n+    pub fn expansion_that_defined(&self, index: DefIndex) -> ExpnId {\n+        self.expansions_that_defined.get(&index).cloned().unwrap_or(ExpnId::root())\n     }\n \n-    pub fn parent_module_of_macro_def(&self, mark: Mark) -> DefId {\n-        self.parent_modules_of_macro_defs[&mark]\n+    pub fn parent_module_of_macro_def(&self, expn_id: ExpnId) -> DefId {\n+        self.parent_modules_of_macro_defs[&expn_id]\n     }\n \n-    pub fn add_parent_module_of_macro_def(&mut self, mark: Mark, module: DefId) {\n-        self.parent_modules_of_macro_defs.insert(mark, module);\n+    pub fn add_parent_module_of_macro_def(&mut self, expn_id: ExpnId, module: DefId) {\n+        self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n \n-    pub fn invocation_parent(&self, invoc_id: Mark) -> DefIndex {\n+    pub fn invocation_parent(&self, invoc_id: ExpnId) -> DefIndex {\n         self.invocation_parents[&invoc_id]\n     }\n \n-    pub fn set_invocation_parent(&mut self, invoc_id: Mark, parent: DefIndex) {\n+    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n         assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n     }\n@@ -624,7 +624,7 @@ macro_rules! define_global_metadata_kind {\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n                         DefPathData::GlobalMetaData(instance.name().as_interned_str()),\n-                        Mark::root(),\n+                        ExpnId::root(),\n                         DUMMY_SP\n                     );\n "}, {"sha": "ae7d82c2020acc6f5bbbec3a0b67d16878496eaa", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -359,21 +359,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n             // times, we cache a stable hash of it and hash that instead of\n             // recursing every time.\n             thread_local! {\n-                static CACHE: RefCell<FxHashMap<hygiene::Mark, u64>> = Default::default();\n+                static CACHE: RefCell<FxHashMap<hygiene::ExpnId, u64>> = Default::default();\n             }\n \n             let sub_hash: u64 = CACHE.with(|cache| {\n-                let mark = span.ctxt.outer();\n+                let expn_id = span.ctxt.outer_expn();\n \n-                if let Some(&sub_hash) = cache.borrow().get(&mark) {\n+                if let Some(&sub_hash) = cache.borrow().get(&expn_id) {\n                     return sub_hash;\n                 }\n \n                 let mut hasher = StableHasher::new();\n-                mark.expn_info().hash_stable(hcx, &mut hasher);\n+                expn_id.expn_info().hash_stable(hcx, &mut hasher);\n                 let sub_hash: Fingerprint = hasher.finish();\n                 let sub_hash = sub_hash.to_smaller_hash();\n-                cache.borrow_mut().insert(mark, sub_hash);\n+                cache.borrow_mut().insert(expn_id, sub_hash);\n                 sub_hash\n             });\n "}, {"sha": "538afa6054ff9611ad635915e35bc1f3d8fb3598", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -44,7 +44,7 @@ use std::{mem, ptr};\n use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{kw, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n@@ -3071,10 +3071,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                                          self.expansion_that_defined(def_parent_def_id))\n     }\n \n-    fn expansion_that_defined(self, scope: DefId) -> Mark {\n+    fn expansion_that_defined(self, scope: DefId) -> ExpnId {\n         match scope.krate {\n             LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n-            _ => Mark::root(),\n+            _ => ExpnId::root(),\n         }\n     }\n "}, {"sha": "a25c1e34cf15438bc822e913af1ceb9c29b832c6", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnInfo};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -588,13 +588,13 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n \n         let expn_info_tag = u8::decode(self)?;\n \n-        // FIXME(mw): This method does not restore `MarkData::parent` or\n+        // FIXME(mw): This method does not restore `InternalExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n         let location = || Span::new(lo, hi, SyntaxContext::empty());\n         let recover_from_expn_info = |this: &Self, expn_info, pos| {\n-            let span = location().fresh_expansion(Mark::root(), expn_info);\n+            let span = location().fresh_expansion(ExpnId::root(), expn_info);\n             this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -725,7 +725,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n+    expn_info_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n@@ -819,15 +819,15 @@ where\n         if span_data.ctxt == SyntaxContext::empty() {\n             TAG_NO_EXPANSION_INFO.encode(self)\n         } else {\n-            let (mark, expn_info) = span_data.ctxt.outer_and_expn_info();\n+            let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();\n             if let Some(expn_info) = expn_info {\n-                if let Some(pos) = self.expn_info_shorthands.get(&mark).cloned() {\n+                if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n                     TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n                     pos.encode(self)\n                 } else {\n                     TAG_EXPANSION_INFO_INLINE.encode(self)?;\n                     let pos = AbsoluteBytePos::new(self.position());\n-                    self.expn_info_shorthands.insert(mark, pos);\n+                    self.expn_info_shorthands.insert(expn_id, pos);\n                     expn_info.encode(self)\n                 }\n             } else {"}, {"sha": "87373364c4d9e3d26753f667c03ac52d86774f84", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n         base::{ExtCtxt, MacroKind, Resolver},\n         build::AstBuilder,\n         expand::ExpansionConfig,\n-        hygiene::Mark,\n+        hygiene::ExpnId,\n     },\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n@@ -85,7 +85,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n         self.found = true;\n \n         // Create a new expansion for the generated allocator code.\n-        let span = item.span.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        let span = item.span.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n             ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n             [sym::rustc_attrs][..].into(),\n         ));"}, {"sha": "9763d523a2ac405ecf1d75261c378893e557d91d", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -102,7 +102,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             let kind = llvm::LLVMGetMDKindIDInContext(self.llcx,\n                 key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-            let val: &'ll Value = self.const_i32(ia.ctxt.outer().as_u32() as i32);\n+            let val: &'ll Value = self.const_i32(ia.ctxt.outer_expn().as_u32() as i32);\n \n             llvm::LLVMSetMetadata(r, kind,\n                 llvm::LLVMMDNodeInContext(self.llcx, &val, 1));"}, {"sha": "c9e4663fdbddfa2eb688e3b4c330a33d47db732d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -26,7 +26,7 @@ use rustc_errors::{Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n use rustc_errors::emitter::{Emitter};\n use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n@@ -1775,7 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match Mark::from_u32(cookie).expn_info() {\n+                    match ExpnId::from_u32(cookie).expn_info() {\n                         Some(ei) => sess.span_err(ei.call_site, &msg),\n                         None     => sess.err(&msg),\n                     }"}, {"sha": "6bf56bf85155312c60343b7cefd296bd45c6aaec", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -572,7 +572,7 @@ pub fn lower_to_hir(\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !sess.opts.debugging_opts.keep_hygiene_data {\n-        syntax::ext::hygiene::clear_markings();\n+        syntax::ext::hygiene::clear_syntax_context_map();\n     }\n \n     Ok(hir_forest)"}, {"sha": "8e76dbb882e3bdce6cc5a3fabe1fc7ef7bf9851a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -31,7 +31,7 @@ use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n use log::debug;\n \n@@ -458,7 +458,7 @@ crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n             crate_root,\n             ast::DUMMY_NODE_ID,\n             DefPathData::MacroNs(name.as_interned_str()),\n-            Mark::root(),\n+            ExpnId::root(),\n             DUMMY_SP);\n         debug!(\"definition for {:?} is {:?}\", name, def_index);\n         assert_eq!(def_index, DefIndex::from_proc_macro_index(index));"}, {"sha": "ee11228654b6fb4f8ad1065d09be3a7b7e318942", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -30,7 +30,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n@@ -45,7 +45,7 @@ use log::debug;\n \n type Res = def::Res<NodeId>;\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n+impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, ExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n@@ -57,7 +57,7 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, false),\n@@ -71,7 +71,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark) {\n \n pub(crate) struct IsMacroExport;\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark, IsMacroExport) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, true),\n@@ -397,7 +397,7 @@ impl<'a> Resolver<'a> {\n                 let imported_binding = self.import(binding, directive);\n                 if ptr::eq(self.current_module, self.graph_root) {\n                     if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n-                        if expansion != Mark::root() && orig_name.is_some() &&\n+                        if expansion != ExpnId::root() && orig_name.is_some() &&\n                            entry.extern_crate_item.is_none() {\n                             self.session.span_err(item.span, \"macro-expanded `extern crate` items \\\n                                                               cannot shadow names passed with \\\n@@ -571,13 +571,13 @@ impl<'a> Resolver<'a> {\n                                        variant: &Variant,\n                                        parent: Module<'a>,\n                                        vis: ty::Visibility,\n-                                       expansion: Mark) {\n+                                       expn_id: ExpnId) {\n         let ident = variant.node.ident;\n \n         // Define a name in the type namespace.\n         let def_id = self.definitions.local_def_id(variant.node.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n-        self.define(parent, ident, TypeNS, (res, vis, variant.span, expansion));\n+        self.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n@@ -596,11 +596,11 @@ impl<'a> Resolver<'a> {\n         let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expn_id: ExpnId) {\n         let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n@@ -615,16 +615,16 @@ impl<'a> Resolver<'a> {\n         };\n         let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        self.define(parent, item.ident, ns, (res, vis, item.span, expn_id));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: Mark) {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, expn_id: ExpnId) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n             let module = self.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n-                                         expansion,\n+                                         expn_id,\n                                          block.span);\n             self.block_map.insert(block.id, module);\n             self.current_module = module; // Descend into the block.\n@@ -642,7 +642,7 @@ impl<'a> Resolver<'a> {\n         // but metadata cannot encode gensyms currently, so we create it here.\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n-        let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n+        let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n             | Res::Def(kind @ DefKind::Enum, def_id) => {\n@@ -734,14 +734,15 @@ impl<'a> Resolver<'a> {\n         };\n \n         let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n-        let module =\n-            self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n+        let module = self.arenas.alloc_module(ModuleData::new(\n+            parent, kind, def_id, ExpnId::root(), DUMMY_SP\n+        ));\n         self.extern_module_map.insert((def_id, macros_only), module);\n         module\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n-        let def_id = match self.macro_defs.get(&expansion) {\n+    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+        let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n             None => return self.graph_root,\n         };\n@@ -858,7 +859,7 @@ impl<'a> Resolver<'a> {\n             used: Cell::new(false),\n         });\n \n-        let allow_shadowing = parent_scope.expansion == Mark::root();\n+        let allow_shadowing = parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(span);\n             self.potentially_unused_imports.push(directive);\n@@ -918,12 +919,12 @@ impl<'a> Resolver<'a> {\n pub struct BuildReducedGraphVisitor<'a, 'b> {\n     pub resolver: &'a mut Resolver<'b>,\n     pub current_legacy_scope: LegacyScope<'b>,\n-    pub expansion: Mark,\n+    pub expansion: ExpnId,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let invoc_id = id.placeholder_to_mark();\n+        let invoc_id = id.placeholder_to_expn_id();\n \n         self.resolver.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n "}, {"sha": "d718d3f78f4e221237c545bd1c61df53a717dcab", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -39,7 +39,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n use syntax::source_map::SourceMap;\n-use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n+use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::MacroKind;\n@@ -141,7 +141,7 @@ enum ScopeSet {\n #[derive(Clone, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n-    expansion: Mark,\n+    expansion: ExpnId,\n     legacy: LegacyScope<'a>,\n     derives: Vec<ast::Path>,\n }\n@@ -1178,7 +1178,7 @@ pub struct ModuleData<'a> {\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<Mark>>,\n+    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -1196,7 +1196,7 @@ pub struct ModuleData<'a> {\n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n \n-    expansion: Mark,\n+    expansion: ExpnId,\n }\n \n type Module<'a> = &'a ModuleData<'a>;\n@@ -1205,7 +1205,7 @@ impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>,\n            kind: ModuleKind,\n            normal_ancestor_id: DefId,\n-           expansion: Mark,\n+           expansion: ExpnId,\n            span: Span) -> Self {\n         ModuleData {\n             parent,\n@@ -1304,7 +1304,7 @@ impl<'a> fmt::Debug for ModuleData<'a> {\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n     ambiguity: Option<(&'a NameBinding<'a>, AmbiguityKind)>,\n-    expansion: Mark,\n+    expansion: ExpnId,\n     span: Span,\n     vis: ty::Visibility,\n }\n@@ -1513,7 +1513,7 @@ impl<'a> NameBinding<'a> {\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding<'_>) -> bool {\n+    fn may_appear_after(&self, invoc_parent_expansion: ExpnId, binding: &NameBinding<'_>) -> bool {\n         // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n@@ -1686,13 +1686,13 @@ pub struct Resolver<'a> {\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n-    macro_defs: FxHashMap<Mark, DefId>,\n+    macro_defs: FxHashMap<ExpnId, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n \n-    /// Maps the `Mark` of an expansion to its containing module or block.\n-    invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n+    /// Maps the `ExpnId` of an expansion to its containing module or block.\n+    invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -1918,7 +1918,7 @@ impl<'a> Resolver<'a> {\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n-            ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n+            ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n         let mut module_map = FxHashMap::default();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n@@ -1941,11 +1941,11 @@ impl<'a> Resolver<'a> {\n         }\n \n         let mut invocations = FxHashMap::default();\n-        invocations.insert(Mark::root(),\n+        invocations.insert(ExpnId::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         let mut macro_defs = FxHashMap::default();\n-        macro_defs.insert(Mark::root(), root_def_id);\n+        macro_defs.insert(ExpnId::root(), root_def_id);\n \n         let features = session.features_untracked();\n         let non_macro_attr =\n@@ -2014,7 +2014,7 @@ impl<'a> Resolver<'a> {\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Res(Res::Err, false),\n                 ambiguity: None,\n-                expansion: Mark::root(),\n+                expansion: ExpnId::root(),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n@@ -2070,7 +2070,7 @@ impl<'a> Resolver<'a> {\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {\n         loop {\n-            match self.macro_defs.get(&ctxt.outer()) {\n+            match self.macro_defs.get(&ctxt.outer_expn()) {\n                 Some(&def_id) => return def_id,\n                 None => ctxt.remove_mark(),\n             };\n@@ -2095,10 +2095,10 @@ impl<'a> Resolver<'a> {\n         parent: Module<'a>,\n         kind: ModuleKind,\n         normal_ancestor_id: DefId,\n-        expansion: Mark,\n+        expn_id: ExpnId,\n         span: Span,\n     ) -> Module<'a> {\n-        let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expansion, span);\n+        let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expn_id, span);\n         self.arenas.alloc_module(module)\n     }\n \n@@ -2243,7 +2243,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n-                        ident.span.adjust(Mark::root());\n+                        ident.span.adjust(ExpnId::root());\n                         Scope::ExternPrelude\n                     }\n                     ValueNS | MacroNS => break,\n@@ -2253,7 +2253,7 @@ impl<'a> Resolver<'a> {\n                     match self.hygienic_lexical_parent(module, &mut ident.span) {\n                         Some(parent_module) => Scope::Module(parent_module),\n                         None => {\n-                            ident.span.adjust(Mark::root());\n+                            ident.span.adjust(ExpnId::root());\n                             match ns {\n                                 TypeNS => Scope::ExternPrelude,\n                                 ValueNS => Scope::StdLibPrelude,\n@@ -2399,15 +2399,15 @@ impl<'a> Resolver<'a> {\n         }\n \n         if !module.no_implicit_prelude {\n-            ident.span.adjust(Mark::root());\n+            ident.span.adjust(ExpnId::root());\n             if ns == TypeNS {\n                 if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n             if ns == TypeNS && KNOWN_TOOLS.contains(&ident.name) {\n                 let binding = (Res::ToolMod, ty::Visibility::Public,\n-                               DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                               DUMMY_SP, ExpnId::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n             if let Some(prelude) = self.prelude {\n@@ -2428,7 +2428,7 @@ impl<'a> Resolver<'a> {\n \n     fn hygienic_lexical_parent(&mut self, module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n-        if !module.expansion.outer_is_descendant_of(span.ctxt()) {\n+        if !module.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n             return Some(self.macro_def_scope(span.remove_mark()));\n         }\n \n@@ -2464,7 +2464,7 @@ impl<'a> Resolver<'a> {\n             module.expansion.is_descendant_of(parent.expansion) {\n                 // The macro is a proc macro derive\n                 if module.expansion.looks_like_proc_macro_derive() {\n-                    if parent.expansion.outer_is_descendant_of(span.ctxt()) {\n+                    if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n                         *poisoned = Some(node_id);\n                         return module.parent;\n                     }\n@@ -2506,7 +2506,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.modernize_and_adjust(Mark::root());\n+                ident.span.modernize_and_adjust(ExpnId::root());\n             }\n             ModuleOrUniformRoot::CrateRootAndExternPrelude |\n             ModuleOrUniformRoot::CurrentScope => {\n@@ -2552,7 +2552,7 @@ impl<'a> Resolver<'a> {\n             result\n         } else {\n             ctxt = ctxt.modern();\n-            ctxt.adjust(Mark::root())\n+            ctxt.adjust(ExpnId::root())\n         };\n         let module = match mark {\n             Some(def) => self.macro_def_scope(def),\n@@ -5063,7 +5063,7 @@ impl<'a> Resolver<'a> {\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(&crate_root);\n-                Some((crate_root, ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                Some((crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                     .to_name_binding(self.arenas))\n             }\n         })"}, {"sha": "3760cabcd898a8b1821e6b9270fa9baf96f4e226", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -16,7 +16,7 @@ use syntax::attr::{self, StabilityLevel};\n use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark, ExpnInfo, ExpnKind};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n@@ -135,19 +135,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n-        let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::default(\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n+        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         ));\n-        let mark = span.ctxt().outer();\n+        let expn_id = span.ctxt().outer_expn();\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n-        self.definitions.set_invocation_parent(mark, module.def_id().unwrap().index);\n-        self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n+        self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n+        self.invocations.insert(expn_id, self.arenas.alloc_invocation_data(InvocationData {\n             module,\n             parent_legacy_scope: LegacyScope::Empty,\n             output_legacy_scope: Cell::new(None),\n         }));\n-        mark\n+        expn_id\n     }\n \n     fn resolve_dollar_crates(&mut self) {\n@@ -160,23 +160,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n-                                            derives: &[Mark]) {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, mark));\n+    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n+                                            derives: &[ExpnId]) {\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n \n-        let invocation = self.invocations[&mark];\n+        let invocation = self.invocations[&expn_id];\n         self.current_module = invocation.module;\n-        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&expn_id);\n         self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n-        let parent_def = self.definitions.invocation_parent(mark);\n+        let parent_def = self.definitions.invocation_parent(expn_id);\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             current_legacy_scope: invocation.parent_legacy_scope,\n-            expansion: mark,\n+            expansion: expn_id,\n         };\n         fragment.visit_with(&mut visitor);\n         invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n@@ -194,7 +194,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             ambiguity: None,\n             span: DUMMY_SP,\n             vis: ty::Visibility::Public,\n-            expansion: Mark::root(),\n+            expansion: ExpnId::root(),\n         });\n         if self.builtin_macros.insert(ident.name, binding).is_some() {\n             self.session.span_err(ident.span,\n@@ -206,7 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         ImportResolver { resolver: self }.resolve_imports()\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n         let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n@@ -223,16 +223,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.mark.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n+        invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(span, \"macro attributes must be placed before `#[derive]`\");\n             }\n-            self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n+            self.macro_defs.insert(invoc.expansion_data.id, def_id);\n             let normal_module_def_id =\n-                self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n-            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n+                self.macro_def_scope(invoc.expansion_data.id).normal_ancestor_id;\n+            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.id,\n                                                             normal_module_def_id);\n         }\n \n@@ -250,10 +250,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n-        self.invoc_parent_scope(Mark::root(), Vec::new())\n+        self.invoc_parent_scope(ExpnId::root(), Vec::new())\n     }\n \n-    fn invoc_parent_scope(&self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n+    fn invoc_parent_scope(&self, invoc_id: ExpnId, derives: Vec<ast::Path>) -> ParentScope<'a> {\n         let invoc = self.invocations[&invoc_id];\n         ParentScope {\n             module: invoc.module.nearest_item_scope(),\n@@ -460,7 +460,7 @@ impl<'a> Resolver<'a> {\n                                                       &parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                               ty::Visibility::Public, derive.span, Mark::root())\n+                                               ty::Visibility::Public, derive.span, ExpnId::root())\n                                                .to_name_binding(this.arenas);\n                                 result = Ok((binding, Flags::empty()));\n                                 break;\n@@ -541,7 +541,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n                     let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                                    .to_name_binding(this.arenas);\n                     Ok((binding, Flags::PRELUDE))\n                 } else {\n@@ -550,7 +550,7 @@ impl<'a> Resolver<'a> {\n                 Scope::LegacyPluginHelpers => if this.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == *name) {\n                     let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                                    .to_name_binding(this.arenas);\n                     Ok((binding, Flags::PRELUDE))\n                 } else {\n@@ -563,7 +563,7 @@ impl<'a> Resolver<'a> {\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {\n-                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                                    .to_name_binding(this.arenas);\n                     Ok((binding, Flags::PRELUDE))\n                 } else {\n@@ -588,7 +588,7 @@ impl<'a> Resolver<'a> {\n                                                  .get(&ident.name).cloned() {\n                     Some(prim_ty) => {\n                         let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n-                                       DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n+                                       DUMMY_SP, ExpnId::root()).to_name_binding(this.arenas);\n                         Ok((binding, Flags::PRELUDE))\n                     }\n                     None => Err(Determinacy::Determined)\n@@ -688,7 +688,7 @@ impl<'a> Resolver<'a> {\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Res::NonMacroAttr(NonMacroAttrKind::Custom),\n-                           ty::Visibility::Public, orig_ident.span, Mark::root())\n+                           ty::Visibility::Public, orig_ident.span, ExpnId::root())\n                            .to_name_binding(self.arenas);\n             Ok(binding)\n         } else {\n@@ -846,7 +846,7 @@ impl<'a> Resolver<'a> {\n \n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n-                        expansion: Mark,\n+                        expansion: ExpnId,\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {"}, {"sha": "1960c06e86e4c7487f75543631da94ad4584b741", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -28,7 +28,7 @@ use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n@@ -221,7 +221,7 @@ impl<'a> Resolver<'a> {\n                         ident.name == kw::DollarCrate {\n                         let module = self.resolve_crate_root(ident);\n                         let binding = (module, ty::Visibility::Public,\n-                                        module.span, Mark::root())\n+                                        module.span, ExpnId::root())\n                                         .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == kw::Super ||\n@@ -246,7 +246,7 @@ impl<'a> Resolver<'a> {\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n         if let Some(binding) = resolution.binding {\n-            if !restricted_shadowing && binding.expansion != Mark::root() {\n+            if !restricted_shadowing && binding.expansion != ExpnId::root() {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n@@ -286,7 +286,7 @@ impl<'a> Resolver<'a> {\n                     if let Some(shadowed_glob) = resolution.shadowed_glob {\n                         // Forbid expanded shadowing to avoid time travel.\n                         if restricted_shadowing &&\n-                        binding.expansion != Mark::root() &&\n+                        binding.expansion != ExpnId::root() &&\n                         binding.res() != shadowed_glob.res() {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 kind: AmbiguityKind::GlobVsExpanded,\n@@ -525,7 +525,7 @@ impl<'a> Resolver<'a> {\n                             (binding, old_binding)\n                         };\n                         if glob_binding.res() != nonglob_binding.res() &&\n-                           ns == MacroNS && nonglob_binding.expansion != Mark::root() {\n+                           ns == MacroNS && nonglob_binding.expansion != ExpnId::root() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsExpanded,\n                                                                     nonglob_binding, glob_binding));\n                         } else {\n@@ -1248,7 +1248,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target: Ident,\n     ) {\n         // Skip if the import was produced by a macro.\n-        if directive.parent_scope.expansion != Mark::root() {\n+        if directive.parent_scope.expansion != ExpnId::root() {\n             return;\n         }\n "}, {"sha": "b9b43c89346c7e372327ab8dd1a9ee346967251f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -5,7 +5,7 @@ pub use UnsafeSource::*;\n pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n-use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext};\n use crate::parse::token::{self, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n@@ -251,12 +251,12 @@ mod node_id_inner {\n pub use node_id_inner::NodeId;\n \n impl NodeId {\n-    pub fn placeholder_from_mark(mark: Mark) -> Self {\n-        NodeId::from_u32(mark.as_u32())\n+    pub fn placeholder_from_expn_id(expn_id: ExpnId) -> Self {\n+        NodeId::from_u32(expn_id.as_u32())\n     }\n \n-    pub fn placeholder_to_mark(self) -> Mark {\n-        Mark::from_u32(self.as_u32())\n+    pub fn placeholder_to_expn_id(self) -> ExpnId {\n+        ExpnId::from_u32(self.as_u32())\n     }\n }\n "}, {"sha": "926c9e88efe157eecf5cc6a3ef17a206588e7396", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{Mark, SyntaxContext, Transparency};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n@@ -682,16 +682,16 @@ pub struct Indeterminate;\n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n-    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n-                                            derives: &[Mark]);\n+    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n+                                            derives: &[ExpnId]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n \n     fn check_unused_macros(&self);\n@@ -705,7 +705,7 @@ pub struct ModuleData {\n \n #[derive(Clone)]\n pub struct ExpansionData {\n-    pub mark: Mark,\n+    pub id: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n     pub directory_ownership: DirectoryOwnership,\n@@ -735,7 +735,7 @@ impl<'a> ExtCtxt<'a> {\n             root_path: PathBuf::new(),\n             resolver,\n             current_expansion: ExpansionData {\n-                mark: Mark::root(),\n+                id: ExpnId::root(),\n                 depth: 0,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n@@ -763,13 +763,13 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        match self.current_expansion.mark.expn_info() {\n+        match self.current_expansion.id.expn_info() {\n             Some(expn_info) => expn_info.call_site,\n             None => DUMMY_SP,\n         }\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::empty().apply_mark(self.current_expansion.mark)\n+        SyntaxContext::empty().apply_mark(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n@@ -877,7 +877,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n-        let def_site = DUMMY_SP.apply_mark(self.current_expansion.mark);\n+        let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|&s| Ident::with_empty_ctxt(s)))\n             .collect()\n@@ -900,7 +900,7 @@ pub fn expr_to_spanned_string<'a>(\n     err_msg: &str,\n ) -> Result<Spanned<(Symbol, ast::StrStyle)>, Option<DiagnosticBuilder<'a>>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n-    expr.span = expr.span.apply_mark(cx.current_expansion.mark);\n+    expr.span = expr.span.apply_mark(cx.current_expansion.id);\n \n     // we want to be able to handle e.g., `concat!(\"foo\", \"bar\")`\n     cx.expander().visit_expr(&mut expr);"}, {"sha": "ff9ad46deecc078c0d3a7cf1683d2f08f502bb2d", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -54,7 +54,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n     }\n \n-    let span = span.fresh_expansion(cx.current_expansion.mark, ExpnInfo::allow_unstable(\n+    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n         cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n     ));"}, {"sha": "ae72f1fd108ed99f87b76ef9c244992d42db887b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -5,7 +5,7 @@ use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n-use crate::ext::hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n@@ -304,7 +304,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<Mark, Vec<_>> = FxHashMap::default();\n+        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -319,7 +319,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n \n             let scope =\n-                if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n+                if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n             let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n                 Ok(ext) => ext,\n                 Err(Indeterminate) => {\n@@ -329,9 +329,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n \n             progress = true;\n-            let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n+            let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n-            self.cx.current_expansion.mark = scope;\n+            self.cx.current_expansion.id = scope;\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n@@ -362,13 +362,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n                 let mut item_with_markers = item.clone();\n                 add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n-                let derives = derives.entry(invoc.expansion_data.mark).or_default();\n+                let derives = derives.entry(invoc.expansion_data.id).or_default();\n \n                 derives.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let mark = Mark::fresh(self.cx.current_expansion.mark, None);\n-                    derives.push(mark);\n+                    let expn_id = ExpnId::fresh(self.cx.current_expansion.id, None);\n+                    derives.push(expn_id);\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive {\n                             path,\n@@ -377,7 +377,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         },\n                         fragment_kind: invoc.fragment_kind,\n                         expansion_data: ExpansionData {\n-                            mark,\n+                            id: expn_id,\n                             ..invoc.expansion_data.clone()\n                         },\n                     });\n@@ -392,7 +392,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             if expanded_fragments.len() < depth {\n                 expanded_fragments.push(Vec::new());\n             }\n-            expanded_fragments[depth - 1].push((mark, expanded_fragment));\n+            expanded_fragments[depth - 1].push((expn_id, expanded_fragment));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -405,7 +405,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n             for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n                 let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_mark(mark),\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n                                          expanded_fragment, derives);\n             }\n         }\n@@ -423,7 +423,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[Mark])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -444,7 +444,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.mark, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, derives);\n         }\n \n         (fragment, invocations)\n@@ -493,7 +493,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.mark.expn_info().unwrap();\n+            let info = self.cx.current_expansion.id.expn_info().unwrap();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n             let mut err = self.cx.struct_span_err(info.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n@@ -822,17 +822,17 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             )),\n             _ => None,\n         };\n-        let mark = Mark::fresh(self.cx.current_expansion.mark, expn_info);\n+        let expn_id = ExpnId::fresh(self.cx.current_expansion.id, expn_info);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n             expansion_data: ExpansionData {\n-                mark,\n+                id: expn_id,\n                 depth: self.cx.current_expansion.depth + 1,\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(fragment_kind, NodeId::placeholder_from_mark(mark))\n+        placeholder(fragment_kind, NodeId::placeholder_from_expn_id(expn_id))\n     }\n \n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n@@ -1402,7 +1402,7 @@ impl<'feat> ExpansionConfig<'feat> {\n \n // A Marker adds the given mark to the syntax context.\n #[derive(Debug)]\n-pub struct Marker(pub Mark);\n+pub struct Marker(pub ExpnId);\n \n impl MutVisitor for Marker {\n     fn visit_span(&mut self, span: &mut Span) {"}, {"sha": "17d8bf3ab175ffe31b4b45f63e4899d929dc2961", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -2,7 +2,7 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::Mark;\n+use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -84,11 +84,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<Mark>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n             for derive in derives {\n-                match self.remove(NodeId::placeholder_from_mark(derive)) {\n+                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "845dac557e8216b61b1e8ed6af6b722c868b1fc4", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -219,7 +219,7 @@ pub fn transcribe(\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.apply_mark(cx.current_expansion.mark);\n+                            sp = sp.apply_mark(cx.current_expansion.id);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n@@ -234,8 +234,8 @@ pub fn transcribe(\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n                     let ident =\n-                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.mark));\n-                    sp = sp.apply_mark(cx.current_expansion.mark);\n+                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.id));\n+                    sp = sp.apply_mark(cx.current_expansion.id);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n                     result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n@@ -247,15 +247,15 @@ pub fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.apply_mark(cx.current_expansion.mark);\n+                span = span.apply_mark(cx.current_expansion.id);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n             quoted::TokenTree::Token(token) => {\n-                let mut marker = Marker(cx.current_expansion.mark);\n+                let mut marker = Marker(cx.current_expansion.id);\n                 let mut tt = TokenTree::Token(token);\n                 noop_visit_tt(&mut tt, &mut marker);\n                 result.push(tt.into());"}, {"sha": "3fba81c0b691149f6d4a2726804236069e97b041", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -1,7 +1,7 @@\n use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n-use crate::ext::hygiene::{Mark, MacroKind};\n+use crate::ext::hygiene::{ExpnId, MacroKind};\n use crate::symbol::{Ident, Symbol, kw, sym};\n use crate::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n use crate::ptr::P;\n@@ -75,7 +75,7 @@ pub fn maybe_inject_crates_ref(\n \n     INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n \n-    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n     ));"}, {"sha": "d82cdce2ce92b1bce72a7550f26beb0e6072f50c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -21,7 +21,7 @@ use crate::entry::{self, EntryPointType};\n use crate::ext::base::{ExtCtxt, Resolver};\n use crate::ext::build::AstBuilder;\n use crate::ext::expand::ExpansionConfig;\n-use crate::ext::hygiene::{self, Mark, SyntaxContext, MacroKind};\n+use crate::ext::hygiene::{self, ExpnId, SyntaxContext, MacroKind};\n use crate::mut_visit::{*, ExpectOne};\n use crate::feature_gate::Features;\n use crate::util::map_in_place::MapInPlace;\n@@ -232,7 +232,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n \n     let name = Ident::from_str(\"__test_reexports\").gensym();\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n-    cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n+    cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n         ident: name,\n         attrs: Vec::new(),\n@@ -303,7 +303,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+    let sp = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n         [sym::main, sym::test, sym::rustc_attrs][..].into(),\n     ));"}, {"sha": "88142344d79e02bf2b2a593aa802b1b6d71606c0", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -19,7 +19,7 @@ use crate::parse::Directory;\n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n use crate::print::pprust;\n \n-use syntax_pos::{BytePos, Mark, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, ExpnId, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n@@ -545,10 +545,10 @@ impl DelimSpan {\n         self.open.with_hi(self.close.hi())\n     }\n \n-    pub fn apply_mark(self, mark: Mark) -> Self {\n+    pub fn apply_mark(self, expn_id: ExpnId) -> Self {\n         DelimSpan {\n-            open: self.open.apply_mark(mark),\n-            close: self.close.apply_mark(mark),\n+            open: self.open.apply_mark(expn_id),\n+            close: self.close.apply_mark(expn_id),\n         }\n     }\n }"}, {"sha": "235565314f5e29e891bec55c74b17a8c7058d8f1", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -25,7 +25,7 @@ pub fn expand_assert<'cx>(\n         }\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n     let panic_call = Mac_ {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {"}, {"sha": "2b64f558be0a0223f2eff73723bfbf07ee42ed66", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -17,7 +17,7 @@ pub fn expand_cfg(\n     sp: Span,\n     tts: &[tokenstream::TokenTree],\n ) -> Box<dyn base::MacResult + 'static> {\n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {"}, {"sha": "dbc985fd8599a679c4623805be55f80499a24b04", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -60,6 +60,6 @@ pub fn expand_syntax_ext(\n     } else if has_errors {\n         return base::DummyResult::expr(sp);\n     }\n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "8184fc442676dc517464e4588288d97c2a4b4ced", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -39,7 +39,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         }\n     }\n \n-    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.mark));\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.id));\n \n     struct ConcatIdentsResult { ident: ast::Ident }\n "}, {"sha": "fef1b4eebcf965d30691b9937b9dcfa6196a401e", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -85,7 +85,7 @@ impl<'a> Path<'a> {\n             PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n             PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n             PathKind::Std => {\n-                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.mark);\n+                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.id);\n                 idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n                 cx.path_all(span, false, idents, params, Vec::new())\n             }"}, {"sha": "03c60e3f11f03b7d411b3276000a92cbec15b53d", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -21,7 +21,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         Some(v) => v,\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.mark);\n+    let sp = sp.apply_mark(cx.current_expansion.id);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             let lt = cx.lifetime(sp, Ident::with_empty_ctxt(kw::StaticLifetime));"}, {"sha": "2f0d995098510ea2319c13b6f98a07e7d854172c", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         for (i, e) in self.args.into_iter().enumerate() {\n             let name = names_pos[i];\n             let span =\n-                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.mark));\n+                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.id));\n             pats.push(self.ecx.pat_ident(span, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n                 locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n@@ -652,7 +652,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   ty: &ArgumentType,\n                   arg: ast::Ident)\n                   -> P<ast::Expr> {\n-        sp = sp.apply_mark(ecx.current_expansion.mark);\n+        sp = sp.apply_mark(ecx.current_expansion.id);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n@@ -691,7 +691,7 @@ fn expand_format_args_impl<'cx>(\n     tts: &[tokenstream::TokenTree],\n     nl: bool,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    sp = sp.apply_mark(ecx.current_expansion.mark);\n+    sp = sp.apply_mark(ecx.current_expansion.id);\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, nl))\n@@ -734,7 +734,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n \n     let mut macsp = ecx.call_site();\n-    macsp = macsp.apply_mark(ecx.current_expansion.mark);\n+    macsp = macsp.apply_mark(ecx.current_expansion.id);\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;"}, {"sha": "08c40dde56c858283a5250054474ff9228927f00", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -8,7 +8,7 @@ use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n@@ -346,7 +346,7 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n         [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));"}, {"sha": "e94d79a140da889ff7fcace3fc8dd24bf9ebc849", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -364,11 +364,11 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n+        let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n                 SyntaxContext::empty()\n-                    .apply_mark_with_transparency(cx.current_expansion.mark, transparency),\n+                    .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n             )\n         };\n         Rustc {"}, {"sha": "f8755a1d1d791131dbf46354fa08db2875cfa4ca", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -59,7 +59,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.mark);\n+    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.id);\n     let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names"}, {"sha": "355f2428e0806d1d66e92e26ceab1680ee1019c7", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -25,7 +25,7 @@ pub fn expand(\n ) -> Vec<Annotatable> {\n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.mark));\n+    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);"}, {"sha": "944b1da36d038fb48f795adbafa86d7d21c542b7", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 163, "deletions": 158, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -11,14 +11,14 @@\n // ensuring that multiple HygieneData accesses are combined into a single\n // `HygieneData::with`.\n //\n-// This explains why `HygieneData`, `SyntaxContext` and `Mark` have interfaces\n+// This explains why `HygieneData`, `SyntaxContext` and `ExpnId` have interfaces\n // with a certain amount of redundancy in them. For example,\n // `SyntaxContext::outer_expn_info` combines `SyntaxContext::outer` and\n-// `Mark::expn_info` so that two `HygieneData` accesses can be performed within\n+// `ExpnId::expn_info` so that two `HygieneData` accesses can be performed within\n // a single `HygieneData::with` call.\n //\n // It also explains why many functions appear in `HygieneData` and again in\n-// `SyntaxContext` or `Mark`. For example, `HygieneData::outer` and\n+// `SyntaxContext` or `ExpnId`. For example, `HygieneData::outer` and\n // `SyntaxContext::outer` do the same thing, but the former is for use within a\n // `HygieneData::with` call while the latter is for use outside such a call.\n // When modifying this file it is important to understand this distinction,\n@@ -35,33 +35,34 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n \n-/// A SyntaxContext represents a chain of macro expansions (represented by marks).\n+/// A `SyntaxContext` represents a chain of pairs `(ExpnId, Transparency)` named \"marks\".\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n #[derive(Debug)]\n struct SyntaxContextData {\n-    outer_mark: Mark,\n-    transparency: Transparency,\n-    prev_ctxt: SyntaxContext,\n-    /// This context, but with all transparent and semi-transparent marks filtered away.\n+    outer_expn: ExpnId,\n+    outer_transparency: Transparency,\n+    parent: SyntaxContext,\n+    /// This context, but with all transparent and semi-transparent expansions filtered away.\n     opaque: SyntaxContext,\n-    /// This context, but with all transparent marks filtered away.\n+    /// This context, but with all transparent expansions filtered away.\n     opaque_and_semitransparent: SyntaxContext,\n     /// Name of the crate to which `$crate` with this context would resolve.\n     dollar_crate_name: Symbol,\n }\n \n-/// A mark is a unique ID associated with a macro expansion.\n+/// A unique ID associated with a macro invocation and expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct Mark(u32);\n+pub struct ExpnId(u32);\n \n+// FIXME: Find a way to merge this with `ExpnInfo`.\n #[derive(Debug)]\n-struct MarkData {\n-    parent: Mark,\n-    /// Each mark should have an associated expansion info, but sometimes there's a delay between\n-    /// creation of a mark and obtaining its info (e.g. macros are collected first and then\n-    /// resolved later), so we use an `Option` here.\n+struct InternalExpnData {\n+    parent: ExpnId,\n+    /// Each expansion should have an associated expansion info, but sometimes there's a delay\n+    /// between creation of an expansion ID and obtaining its info (e.g. macros are collected\n+    /// first and then resolved later), so we use an `Option` here.\n     expn_info: Option<ExpnInfo>,\n }\n \n@@ -84,15 +85,15 @@ pub enum Transparency {\n     Opaque,\n }\n \n-impl Mark {\n-    pub fn fresh(parent: Mark, expn_info: Option<ExpnInfo>) -> Self {\n-        HygieneData::with(|data| data.fresh_mark(parent, expn_info))\n+impl ExpnId {\n+    pub fn fresh(parent: ExpnId, expn_info: Option<ExpnInfo>) -> Self {\n+        HygieneData::with(|data| data.fresh_expn(parent, expn_info))\n     }\n \n-    /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n     #[inline]\n     pub fn root() -> Self {\n-        Mark(0)\n+        ExpnId(0)\n     }\n \n     #[inline]\n@@ -101,13 +102,13 @@ impl Mark {\n     }\n \n     #[inline]\n-    pub fn from_u32(raw: u32) -> Mark {\n-        Mark(raw)\n+    pub fn from_u32(raw: u32) -> ExpnId {\n+        ExpnId(raw)\n     }\n \n     #[inline]\n-    pub fn parent(self) -> Mark {\n-        HygieneData::with(|data| data.marks[self.0 as usize].parent)\n+    pub fn parent(self) -> ExpnId {\n+        HygieneData::with(|data| data.parent_expn(self))\n     }\n \n     #[inline]\n@@ -118,20 +119,20 @@ impl Mark {\n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n         HygieneData::with(|data| {\n-            let old_info = &mut data.marks[self.0 as usize].expn_info;\n-            assert!(old_info.is_none(), \"expansion info is reset for a mark\");\n+            let old_info = &mut data.expn_data[self.0 as usize].expn_info;\n+            assert!(old_info.is_none(), \"expansion info is reset for an expansion ID\");\n             *old_info = Some(info);\n         })\n     }\n \n-    pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n+    pub fn is_descendant_of(self, ancestor: ExpnId) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n     }\n \n-    /// `mark.outer_is_descendant_of(ctxt)` is equivalent to but faster than\n-    /// `mark.is_descendant_of(ctxt.outer())`.\n-    pub fn outer_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n-        HygieneData::with(|data| data.is_descendant_of(self, data.outer(ctxt)))\n+    /// `expn_id.outer_expn_is_descendant_of(ctxt)` is equivalent to but faster than\n+    /// `expn_id.is_descendant_of(ctxt.outer_expn())`.\n+    pub fn outer_expn_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n+        HygieneData::with(|data| data.is_descendant_of(self, data.outer_expn(ctxt)))\n     }\n \n     // Used for enabling some compatibility fallback in resolve.\n@@ -152,43 +153,47 @@ impl Mark {\n \n #[derive(Debug)]\n crate struct HygieneData {\n-    marks: Vec<MarkData>,\n-    syntax_contexts: Vec<SyntaxContextData>,\n-    markings: FxHashMap<(SyntaxContext, Mark, Transparency), SyntaxContext>,\n+    expn_data: Vec<InternalExpnData>,\n+    syntax_context_data: Vec<SyntaxContextData>,\n+    syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n-            marks: vec![MarkData {\n-                parent: Mark::root(),\n+            expn_data: vec![InternalExpnData {\n+                parent: ExpnId::root(),\n                 expn_info: Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition)),\n             }],\n-            syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark::root(),\n-                transparency: Transparency::Opaque,\n-                prev_ctxt: SyntaxContext(0),\n+            syntax_context_data: vec![SyntaxContextData {\n+                outer_expn: ExpnId::root(),\n+                outer_transparency: Transparency::Opaque,\n+                parent: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n                 dollar_crate_name: kw::DollarCrate,\n             }],\n-            markings: FxHashMap::default(),\n+            syntax_context_map: FxHashMap::default(),\n         }\n     }\n \n     fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_mark(&mut self, parent: Mark, expn_info: Option<ExpnInfo>) -> Mark {\n-        self.marks.push(MarkData { parent, expn_info });\n-        Mark(self.marks.len() as u32 - 1)\n+    fn fresh_expn(&mut self, parent: ExpnId, expn_info: Option<ExpnInfo>) -> ExpnId {\n+        self.expn_data.push(InternalExpnData { parent, expn_info });\n+        ExpnId(self.expn_data.len() as u32 - 1)\n     }\n \n-    fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n-        if mark != Mark::root() {\n-            Some(self.marks[mark.0 as usize].expn_info.as_ref()\n-                     .expect(\"no expansion info for a mark\"))\n+    fn parent_expn(&self, expn_id: ExpnId) -> ExpnId {\n+        self.expn_data[expn_id.0 as usize].parent\n+    }\n+\n+    fn expn_info(&self, expn_id: ExpnId) -> Option<&ExpnInfo> {\n+        if expn_id != ExpnId::root() {\n+            Some(self.expn_data[expn_id.0 as usize].expn_info.as_ref()\n+                     .expect(\"no expansion info for an expansion ID\"))\n         } else {\n             // FIXME: Some code relies on `expn_info().is_none()` meaning \"no expansion\".\n             // Introduce a method for checking for \"no expansion\" instead and always return\n@@ -197,64 +202,61 @@ impl HygieneData {\n         }\n     }\n \n-    fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n-        while mark != ancestor {\n-            if mark == Mark::root() {\n+    fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n+        while expn_id != ancestor {\n+            if expn_id == ExpnId::root() {\n                 return false;\n             }\n-            mark = self.marks[mark.0 as usize].parent;\n+            expn_id = self.parent_expn(expn_id);\n         }\n         true\n     }\n \n-    fn default_transparency(&self, mark: Mark) -> Transparency {\n-        self.expn_info(mark).map_or(\n+    fn default_transparency(&self, expn_id: ExpnId) -> Transparency {\n+        self.expn_info(expn_id).map_or(\n             Transparency::SemiTransparent, |einfo| einfo.default_transparency\n         )\n     }\n \n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n-        self.syntax_contexts[ctxt.0 as usize].opaque\n+        self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n \n     fn modern_and_legacy(&self, ctxt: SyntaxContext) -> SyntaxContext {\n-        self.syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent\n+        self.syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent\n     }\n \n-    fn outer(&self, ctxt: SyntaxContext) -> Mark {\n-        self.syntax_contexts[ctxt.0 as usize].outer_mark\n+    fn outer_expn(&self, ctxt: SyntaxContext) -> ExpnId {\n+        self.syntax_context_data[ctxt.0 as usize].outer_expn\n     }\n \n-    fn transparency(&self, ctxt: SyntaxContext) -> Transparency {\n-        self.syntax_contexts[ctxt.0 as usize].transparency\n+    fn outer_transparency(&self, ctxt: SyntaxContext) -> Transparency {\n+        self.syntax_context_data[ctxt.0 as usize].outer_transparency\n     }\n \n-    fn prev_ctxt(&self, ctxt: SyntaxContext) -> SyntaxContext {\n-        self.syntax_contexts[ctxt.0 as usize].prev_ctxt\n+    fn parent_ctxt(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+        self.syntax_context_data[ctxt.0 as usize].parent\n     }\n \n-    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> Mark {\n-        let outer_mark = self.syntax_contexts[ctxt.0 as usize].outer_mark;\n-        *ctxt = self.prev_ctxt(*ctxt);\n-        outer_mark\n+    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> ExpnId {\n+        let outer_expn = self.outer_expn(*ctxt);\n+        *ctxt = self.parent_ctxt(*ctxt);\n+        outer_expn\n     }\n \n-    fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(Mark, Transparency)> {\n+    fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n         while ctxt != SyntaxContext::empty() {\n-            let outer_mark = self.outer(ctxt);\n-            let transparency = self.transparency(ctxt);\n-            let prev_ctxt = self.prev_ctxt(ctxt);\n-            marks.push((outer_mark, transparency));\n-            ctxt = prev_ctxt;\n+            marks.push((self.outer_expn(ctxt), self.outer_transparency(ctxt)));\n+            ctxt = self.parent_ctxt(ctxt);\n         }\n         marks.reverse();\n         marks\n     }\n \n     fn walk_chain(&self, mut span: Span, to: SyntaxContext) -> Span {\n         while span.ctxt() != crate::NO_EXPANSION && span.ctxt() != to {\n-            if let Some(info) = self.expn_info(self.outer(span.ctxt())) {\n+            if let Some(info) = self.expn_info(self.outer_expn(span.ctxt())) {\n                 span = info.call_site;\n             } else {\n                 break;\n@@ -263,39 +265,39 @@ impl HygieneData {\n         span\n     }\n \n-    fn adjust(&self, ctxt: &mut SyntaxContext, expansion: Mark) -> Option<Mark> {\n+    fn adjust(&self, ctxt: &mut SyntaxContext, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut scope = None;\n-        while !self.is_descendant_of(expansion, self.outer(*ctxt)) {\n+        while !self.is_descendant_of(expn_id, self.outer_expn(*ctxt)) {\n             scope = Some(self.remove_mark(ctxt));\n         }\n         scope\n     }\n \n-    fn apply_mark(&mut self, ctxt: SyntaxContext, mark: Mark) -> SyntaxContext {\n-        assert_ne!(mark, Mark::root());\n-        self.apply_mark_with_transparency(ctxt, mark, self.default_transparency(mark))\n+    fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n+        assert_ne!(expn_id, ExpnId::root());\n+        self.apply_mark_with_transparency(ctxt, expn_id, self.default_transparency(expn_id))\n     }\n \n-    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, mark: Mark,\n+    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n                                     transparency: Transparency) -> SyntaxContext {\n-        assert_ne!(mark, Mark::root());\n+        assert_ne!(expn_id, ExpnId::root());\n         if transparency == Transparency::Opaque {\n-            return self.apply_mark_internal(ctxt, mark, transparency);\n+            return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n         let call_site_ctxt =\n-            self.expn_info(mark).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+            self.expn_info(expn_id).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n             self.modern_and_legacy(call_site_ctxt)\n         };\n \n         if call_site_ctxt == SyntaxContext::empty() {\n-            return self.apply_mark_internal(ctxt, mark, transparency);\n+            return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n-        // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n+        // Otherwise, `expn_id` is a macros 1.0 definition and the call site is in a\n         // macros 2.0 expansion, i.e., a macros 1.0 invocation is in a macros 2.0 definition.\n         //\n         // In this case, the tokens from the macros 1.0 definition inherit the hygiene\n@@ -304,27 +306,29 @@ impl HygieneData {\n         // so that the macros 2.0 definition remains hygienic.\n         //\n         // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n-        for (mark, transparency) in self.marks(ctxt) {\n-            call_site_ctxt = self.apply_mark_internal(call_site_ctxt, mark, transparency);\n+        for (expn_id, transparency) in self.marks(ctxt) {\n+            call_site_ctxt = self.apply_mark_internal(call_site_ctxt, expn_id, transparency);\n         }\n-        self.apply_mark_internal(call_site_ctxt, mark, transparency)\n+        self.apply_mark_internal(call_site_ctxt, expn_id, transparency)\n     }\n \n-    fn apply_mark_internal(&mut self, ctxt: SyntaxContext, mark: Mark, transparency: Transparency)\n-                           -> SyntaxContext {\n-        let syntax_contexts = &mut self.syntax_contexts;\n-        let mut opaque = syntax_contexts[ctxt.0 as usize].opaque;\n+    fn apply_mark_internal(\n+        &mut self, ctxt: SyntaxContext, expn_id: ExpnId, transparency: Transparency\n+    ) -> SyntaxContext {\n+        let syntax_context_data = &mut self.syntax_context_data;\n+        let mut opaque = syntax_context_data[ctxt.0 as usize].opaque;\n         let mut opaque_and_semitransparent =\n-            syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent;\n+            syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent;\n \n         if transparency >= Transparency::Opaque {\n-            let prev_ctxt = opaque;\n-            opaque = *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n-                let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n-                syntax_contexts.push(SyntaxContextData {\n-                    outer_mark: mark,\n-                    transparency,\n-                    prev_ctxt,\n+            let parent = opaque;\n+            opaque = *self.syntax_context_map.entry((parent, expn_id, transparency))\n+                                             .or_insert_with(|| {\n+                let new_opaque = SyntaxContext(syntax_context_data.len() as u32);\n+                syntax_context_data.push(SyntaxContextData {\n+                    outer_expn: expn_id,\n+                    outer_transparency: transparency,\n+                    parent,\n                     opaque: new_opaque,\n                     opaque_and_semitransparent: new_opaque,\n                     dollar_crate_name: kw::DollarCrate,\n@@ -334,15 +338,16 @@ impl HygieneData {\n         }\n \n         if transparency >= Transparency::SemiTransparent {\n-            let prev_ctxt = opaque_and_semitransparent;\n+            let parent = opaque_and_semitransparent;\n             opaque_and_semitransparent =\n-                    *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+                    *self.syntax_context_map.entry((parent, expn_id, transparency))\n+                                            .or_insert_with(|| {\n                 let new_opaque_and_semitransparent =\n-                    SyntaxContext(syntax_contexts.len() as u32);\n-                syntax_contexts.push(SyntaxContextData {\n-                    outer_mark: mark,\n-                    transparency,\n-                    prev_ctxt,\n+                    SyntaxContext(syntax_context_data.len() as u32);\n+                syntax_context_data.push(SyntaxContextData {\n+                    outer_expn: expn_id,\n+                    outer_transparency: transparency,\n+                    parent,\n                     opaque,\n                     opaque_and_semitransparent: new_opaque_and_semitransparent,\n                     dollar_crate_name: kw::DollarCrate,\n@@ -351,14 +356,14 @@ impl HygieneData {\n             });\n         }\n \n-        let prev_ctxt = ctxt;\n-        *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+        let parent = ctxt;\n+        *self.syntax_context_map.entry((parent, expn_id, transparency)).or_insert_with(|| {\n             let new_opaque_and_semitransparent_and_transparent =\n-                SyntaxContext(syntax_contexts.len() as u32);\n-            syntax_contexts.push(SyntaxContextData {\n-                outer_mark: mark,\n-                transparency,\n-                prev_ctxt,\n+                SyntaxContext(syntax_context_data.len() as u32);\n+            syntax_context_data.push(SyntaxContextData {\n+                outer_expn: expn_id,\n+                outer_transparency: transparency,\n+                parent,\n                 opaque,\n                 opaque_and_semitransparent,\n                 dollar_crate_name: kw::DollarCrate,\n@@ -368,8 +373,8 @@ impl HygieneData {\n     }\n }\n \n-pub fn clear_markings() {\n-    HygieneData::with(|data| data.markings = FxHashMap::default());\n+pub fn clear_syntax_context_map() {\n+    HygieneData::with(|data| data.syntax_context_map = FxHashMap::default());\n }\n \n pub fn walk_chain(span: Span, to: SyntaxContext) -> Span {\n@@ -379,8 +384,8 @@ pub fn walk_chain(span: Span, to: SyntaxContext) -> Span {\n pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symbol) {\n     // The new contexts that need updating are at the end of the list and have `$crate` as a name.\n     let (len, to_update) = HygieneData::with(|data| (\n-        data.syntax_contexts.len(),\n-        data.syntax_contexts.iter().rev()\n+        data.syntax_context_data.len(),\n+        data.syntax_context_data.iter().rev()\n             .take_while(|scdata| scdata.dollar_crate_name == kw::DollarCrate).count()\n     ));\n     // The callback must be called from outside of the `HygieneData` lock,\n@@ -389,7 +394,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n     let names: Vec<_> =\n         range_to_update.clone().map(|idx| get_name(SyntaxContext::from_u32(idx as u32))).collect();\n     HygieneData::with(|data| range_to_update.zip(names.into_iter()).for_each(|(idx, name)| {\n-        data.syntax_contexts[idx].dollar_crate_name = name;\n+        data.syntax_context_data[idx].dollar_crate_name = name;\n     }))\n }\n \n@@ -409,15 +414,15 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    /// Extend a syntax context with a given mark and default transparency for that mark.\n-    pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark(self, mark))\n+    /// Extend a syntax context with a given expansion and default transparency for that expansion.\n+    pub fn apply_mark(self, expn_id: ExpnId) -> SyntaxContext {\n+        HygieneData::with(|data| data.apply_mark(self, expn_id))\n     }\n \n-    /// Extend a syntax context with a given mark and transparency\n-    pub fn apply_mark_with_transparency(self, mark: Mark, transparency: Transparency)\n+    /// Extend a syntax context with a given expansion and transparency.\n+    pub fn apply_mark_with_transparency(self, expn_id: ExpnId, transparency: Transparency)\n                                         -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark_with_transparency(self, mark, transparency))\n+        HygieneData::with(|data| data.apply_mark_with_transparency(self, expn_id, transparency))\n     }\n \n     /// Pulls a single mark off of the syntax context. This effectively moves the\n@@ -436,11 +441,11 @@ impl SyntaxContext {\n     /// of g (call it g1), calling remove_mark will result in the SyntaxContext for the\n     /// invocation of f that created g1.\n     /// Returns the mark that was removed.\n-    pub fn remove_mark(&mut self) -> Mark {\n+    pub fn remove_mark(&mut self) -> ExpnId {\n         HygieneData::with(|data| data.remove_mark(self))\n     }\n \n-    pub fn marks(self) -> Vec<(Mark, Transparency)> {\n+    pub fn marks(self) -> Vec<(ExpnId, Transparency)> {\n         HygieneData::with(|data| data.marks(self))\n     }\n \n@@ -452,13 +457,13 @@ impl SyntaxContext {\n     /// m!(f);\n     /// macro m($f:ident) {\n     ///     mod bar {\n-    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `ExpnId` from `m`.\n     ///         pub fn $f() {} // `$f`'s `SyntaxContext` is empty.\n     ///     }\n-    ///     foo::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     foo::f(); // `f`'s `SyntaxContext` has a single `ExpnId` from `m`\n     ///     //^ Since `mod foo` is outside this expansion, `adjust` removes the mark from `f`,\n     ///     //| and it resolves to `::foo::f`.\n-    ///     bar::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     bar::f(); // `f`'s `SyntaxContext` has a single `ExpnId` from `m`\n     ///     //^ Since `mod bar` not outside this expansion, `adjust` does not change `f`,\n     ///     //| and it resolves to `::bar::f`.\n     ///     bar::$f(); // `f`'s `SyntaxContext` is empty.\n@@ -468,15 +473,15 @@ impl SyntaxContext {\n     /// ```\n     /// This returns the expansion whose definition scope we use to privacy check the resolution,\n     /// or `None` if we privacy check as usual (i.e., not w.r.t. a macro definition scope).\n-    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n-        HygieneData::with(|data| data.adjust(self, expansion))\n+    pub fn adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+        HygieneData::with(|data| data.adjust(self, expn_id))\n     }\n \n     /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n-    pub fn modernize_and_adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| {\n             *self = data.modern(*self);\n-            data.adjust(self, expansion)\n+            data.adjust(self, expn_id)\n         })\n     }\n \n@@ -488,7 +493,7 @@ impl SyntaxContext {\n     /// m!(f);\n     /// macro m($i:ident) {\n     ///     mod foo {\n-    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `ExpnId` from `m`.\n     ///         pub fn $i() {} // `$i`'s `SyntaxContext` is empty.\n     ///     }\n     ///     n(f);\n@@ -505,17 +510,17 @@ impl SyntaxContext {\n     /// ```\n     /// This returns `None` if the context cannot be glob-adjusted.\n     /// Otherwise, it returns the scope to use when privacy checking (see `adjust` for details).\n-    pub fn glob_adjust(&mut self, expansion: Mark, glob_span: Span) -> Option<Option<Mark>> {\n+    pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             let mut scope = None;\n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n-            while !data.is_descendant_of(expansion, data.outer(glob_ctxt)) {\n+            while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 scope = Some(data.remove_mark(&mut glob_ctxt));\n                 if data.remove_mark(self) != scope.unwrap() {\n                     return None;\n                 }\n             }\n-            if data.adjust(self, expansion).is_some() {\n+            if data.adjust(self, expn_id).is_some() {\n                 return None;\n             }\n             Some(scope)\n@@ -529,16 +534,16 @@ impl SyntaxContext {\n     ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n     /// }\n     /// ```\n-    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_span: Span)\n-                               -> Option<Option<Mark>> {\n+    pub fn reverse_glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span)\n+                               -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n-            if data.adjust(self, expansion).is_some() {\n+            if data.adjust(self, expn_id).is_some() {\n                 return None;\n             }\n \n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n             let mut marks = Vec::new();\n-            while !data.is_descendant_of(expansion, data.outer(glob_ctxt)) {\n+            while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n             }\n \n@@ -550,10 +555,10 @@ impl SyntaxContext {\n         })\n     }\n \n-    pub fn hygienic_eq(self, other: SyntaxContext, mark: Mark) -> bool {\n+    pub fn hygienic_eq(self, other: SyntaxContext, expn_id: ExpnId) -> bool {\n         HygieneData::with(|data| {\n             let mut self_modern = data.modern(self);\n-            data.adjust(&mut self_modern, mark);\n+            data.adjust(&mut self_modern, expn_id);\n             self_modern == data.modern(other)\n         })\n     }\n@@ -569,29 +574,29 @@ impl SyntaxContext {\n     }\n \n     #[inline]\n-    pub fn outer(self) -> Mark {\n-        HygieneData::with(|data| data.outer(self))\n+    pub fn outer_expn(self) -> ExpnId {\n+        HygieneData::with(|data| data.outer_expn(self))\n     }\n \n     /// `ctxt.outer_expn_info()` is equivalent to but faster than\n-    /// `ctxt.outer().expn_info()`.\n+    /// `ctxt.outer_expn().expn_info()`.\n     #[inline]\n     pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer(self)).cloned())\n+        HygieneData::with(|data| data.expn_info(data.outer_expn(self)).cloned())\n     }\n \n-    /// `ctxt.outer_and_expn_info()` is equivalent to but faster than\n-    /// `{ let outer = ctxt.outer(); (outer, outer.expn_info()) }`.\n+    /// `ctxt.outer_expn_with_info()` is equivalent to but faster than\n+    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_info()) }`.\n     #[inline]\n-    pub fn outer_and_expn_info(self) -> (Mark, Option<ExpnInfo>) {\n+    pub fn outer_expn_with_info(self) -> (ExpnId, Option<ExpnInfo>) {\n         HygieneData::with(|data| {\n-            let outer = data.outer(self);\n+            let outer = data.outer_expn(self);\n             (outer, data.expn_info(outer).cloned())\n         })\n     }\n \n     pub fn dollar_crate_name(self) -> Symbol {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].dollar_crate_name)\n+        HygieneData::with(|data| data.syntax_context_data[self.0 as usize].dollar_crate_name)\n     }\n }\n \n@@ -607,10 +612,10 @@ impl Span {\n     /// other compiler-generated code to set per-span properties like allowed unstable features.\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n-    pub fn fresh_expansion(self, parent: Mark, expn_info: ExpnInfo) -> Span {\n+    pub fn fresh_expansion(self, parent: ExpnId, expn_info: ExpnInfo) -> Span {\n         HygieneData::with(|data| {\n-            let mark = data.fresh_mark(parent, Some(expn_info));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), mark))\n+            let expn_id = data.fresh_expn(parent, Some(expn_info));\n+            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), expn_id))\n         })\n     }\n }\n@@ -638,7 +643,7 @@ pub struct ExpnInfo {\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for mark with this expansion info by default.\n+    /// Transparency used by `apply_mark` for the expansion with this expansion info by default.\n     pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n@@ -681,7 +686,7 @@ impl ExpnInfo {\n /// Expansion kind.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ExpnKind {\n-    /// No expansion, aka root expansion. Only `Mark::root()` has this kind.\n+    /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n     /// Expansion produced by a macro.\n     /// FIXME: Some code injected by the compiler before HIR lowering also gets this kind."}, {"sha": "b9a062c0765f092aed056e881100b2fc3f1ee7fa", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26b523686497a46d10104c7295f366099a298c/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=5c26b523686497a46d10104c7295f366099a298c", "patch": "@@ -27,7 +27,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n+pub use hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -516,48 +516,48 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn apply_mark(self, mark: Mark) -> Span {\n+    pub fn apply_mark(self, mark: ExpnId) -> Span {\n         let span = self.data();\n         span.with_ctxt(span.ctxt.apply_mark(mark))\n     }\n \n     #[inline]\n-    pub fn remove_mark(&mut self) -> Mark {\n+    pub fn remove_mark(&mut self) -> ExpnId {\n         let mut span = self.data();\n         let mark = span.ctxt.remove_mark();\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.adjust(expansion);\n+        let mark = span.ctxt.adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn modernize_and_adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.modernize_and_adjust(expansion);\n+        let mark = span.ctxt.modernize_and_adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn glob_adjust(&mut self, expansion: Mark, glob_span: Span) -> Option<Option<Mark>> {\n+    pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         let mut span = self.data();\n-        let mark = span.ctxt.glob_adjust(expansion, glob_span);\n+        let mark = span.ctxt.glob_adjust(expn_id, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_span: Span)\n-                               -> Option<Option<Mark>> {\n+    pub fn reverse_glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span)\n+                               -> Option<Option<ExpnId>> {\n         let mut span = self.data();\n-        let mark = span.ctxt.reverse_glob_adjust(expansion, glob_span);\n+        let mark = span.ctxt.reverse_glob_adjust(expn_id, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }"}]}