{"sha": "4e92f761fe54fc602ec2bf63819e8c973d1facd5", "node_id": "C_kwDOAAsO6NoAKDRlOTJmNzYxZmU1NGZjNjAyZWMyYmY2MzgxOWU4Yzk3M2QxZmFjZDU", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-04-25T08:07:44Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-05-12T10:26:50Z"}, "message": "Use the opaque_types_defined_by query to cheaply check for whether a hidden type may be registered for an opaque type", "tree": {"sha": "ad4824e716785fd097f0c53e5ff4ce74c61770eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad4824e716785fd097f0c53e5ff4ce74c61770eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e92f761fe54fc602ec2bf63819e8c973d1facd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e92f761fe54fc602ec2bf63819e8c973d1facd5", "html_url": "https://github.com/rust-lang/rust/commit/4e92f761fe54fc602ec2bf63819e8c973d1facd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e92f761fe54fc602ec2bf63819e8c973d1facd5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ae803eedfeb57944cd0d2930d9a8b7a606baf4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae803eedfeb57944cd0d2930d9a8b7a606baf4a", "html_url": "https://github.com/rust-lang/rust/commit/6ae803eedfeb57944cd0d2930d9a8b7a606baf4a"}], "stats": {"total": 530, "additions": 368, "deletions": 162}, "files": [{"sha": "9e78e6acba54b206e76eb19af794b1af0a5bcbfc", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -735,7 +735,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n                     && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n-                    && self.opaque_type_origin(def_id, self.param_env).is_some() {\n+                    && self.opaque_type_origin(def_id).is_some() {\n                     return None;\n                 }\n             }"}, {"sha": "421eb807a141f479d82873af941923e49d6b0c81", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -1,10 +1,9 @@\n-use crate::infer::opaque_types::may_define_impl_trait_in_assoc_ty_modulo_sig;\n-\n use super::TypeErrCtxt;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n-use rustc_middle::traits::ObligationCauseCode::{self, MiscObligation};\n+use rustc_hir::def::DefKind;\n+use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::Printer;\n use rustc_middle::{\n@@ -258,9 +257,9 @@ impl<T> Trait<T> for X {\n                             );\n                         }\n                     }\n-                    (ty::Alias(ty::Opaque, alias), _) | (_, ty::Alias(ty::Opaque, alias)) if matches!(cause.code(), MiscObligation) => {\n-                        if let Some(def_id) = alias.def_id.as_local() {\n-                            if may_define_impl_trait_in_assoc_ty_modulo_sig(tcx, body_owner_def_id.expect_local(), def_id).is_some() {\n+                    (ty::Alias(ty::Opaque, alias), _) | (_, ty::Alias(ty::Opaque, alias)) if alias.def_id.is_local() && matches!(tcx.def_kind(body_owner_def_id), DefKind::AssocFn | DefKind::AssocConst) => {\n+                        if tcx.is_type_alias_impl_trait(alias.def_id) {\n+                            if !tcx.opaque_types_defined_by(body_owner_def_id.expect_local()).contains(&alias.def_id.expect_local()) {\n                                 diag.span_note(tcx.def_span(body_owner_def_id), \"\\\n                                     this item must have the opaque type in its signature \\\n                                     in order to be able to register hidden types\");"}, {"sha": "545310ad3516732385e750230be92dbf7e6ed42b", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 8, "deletions": 118, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -3,10 +3,9 @@ use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n-use hir::def::DefKind;\n use hir::def_id::{DefId, LocalDefId};\n use hir::OpaqueTyOrigin;\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_middle::traits::ObligationCause;\n@@ -54,9 +53,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n-            def_id\n-                .as_local()\n-                .map_or(false, |def_id| self.opaque_type_origin(def_id, param_env).is_some())\n+            def_id.as_local().map_or(false, |def_id| self.opaque_type_origin(def_id).is_some())\n         };\n         let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n@@ -141,7 +138,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                         //     let x = || foo(); // returns the Opaque assoc with `foo`\n                         // }\n                         // ```\n-                        self.opaque_type_origin(def_id, param_env)?\n+                        self.opaque_type_origin(def_id)?\n                     }\n                     DefiningAnchor::Bubble => self.opaque_type_origin_unchecked(def_id),\n                     DefiningAnchor::Error => return None,\n@@ -152,9 +149,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias { .. }) = b_def_id\n-                        .as_local()\n-                        .and_then(|b_def_id| self.opaque_type_origin(b_def_id, param_env))\n+                    if let Some(OpaqueTyOrigin::TyAlias { .. }) =\n+                        b_def_id.as_local().and_then(|b_def_id| self.opaque_type_origin(b_def_id))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n                             span: cause.span,\n@@ -370,12 +366,8 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Returns the origin of the opaque type `def_id` if we're currently\n     /// in its defining scope.\n-    #[instrument(skip(self, param_env), level = \"trace\", ret)]\n-    pub fn opaque_type_origin(\n-        &self,\n-        def_id: LocalDefId,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> Option<OpaqueTyOrigin> {\n+    #[instrument(skip(self), level = \"trace\", ret)]\n+    pub fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = match self.defining_use_anchor {\n             DefiningAnchor::Bubble | DefiningAnchor::Error => return None,\n@@ -391,7 +383,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             // Named `type Foo = impl Bar;`\n             hir::OpaqueTyOrigin::TyAlias { in_assoc_ty } => {\n                 if in_assoc_ty {\n-                    may_define_impl_trait_in_assoc_ty(self.tcx, parent_def_id, def_id, param_env)\n+                    self.tcx.opaque_types_defined_by(parent_def_id).contains(&def_id)\n                 } else {\n                     may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n                 }\n@@ -654,105 +646,3 @@ fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hi\n     );\n     res\n }\n-\n-#[derive(Debug, TypeVisitable, Clone)]\n-/// Helper datastructure containing the signature\n-/// that the opaque type extraction logic uses for determining\n-/// whether an opaque type may have its hidden types registered\n-/// by an item.\n-enum FnSigOrTy<'tcx> {\n-    FnSig(ty::PolyFnSig<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-/// Checks that the item may register hidden types for the\n-/// opaque type, if the opaque type shows up in its signature.\n-#[instrument(level = \"debug\", skip(tcx), ret)]\n-pub fn may_define_impl_trait_in_assoc_ty_modulo_sig<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    opaque_def_id: LocalDefId,\n-) -> Option<impl TypeVisitable<TyCtxt<'tcx>>> {\n-    let sig = match tcx.def_kind(def_id) {\n-        DefKind::AssocFn => FnSigOrTy::FnSig(tcx.fn_sig(def_id).subst_identity()),\n-        DefKind::AssocConst | DefKind::AssocTy => {\n-            FnSigOrTy::Ty(tcx.type_of(def_id).subst_identity())\n-        }\n-        _ => return None,\n-    };\n-    let impl_id = tcx.local_parent(def_id);\n-    trace!(?impl_id);\n-    let mut assoc_id = opaque_def_id;\n-    // Peel nested opaque types.\n-    while let DefKind::OpaqueTy = tcx.def_kind(assoc_id) {\n-        trace!(?assoc_id);\n-        assoc_id = tcx.local_parent(assoc_id);\n-    }\n-    trace!(?assoc_id);\n-    if !matches!(tcx.def_kind(assoc_id), DefKind::AssocTy) {\n-        tcx.sess\n-            .delay_span_bug(tcx.def_span(opaque_def_id), format!(\"{:?}\", tcx.def_kind(assoc_id)));\n-    }\n-    let assoc_impl_id = tcx.local_parent(assoc_id);\n-    trace!(?assoc_impl_id);\n-\n-    if impl_id != assoc_impl_id {\n-        return None;\n-    }\n-\n-    Some(sig)\n-}\n-\n-#[instrument(level = \"debug\", skip(tcx, param_env), ret)]\n-fn may_define_impl_trait_in_assoc_ty<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    opaque_def_id: LocalDefId,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    let Some(sig) = may_define_impl_trait_in_assoc_ty_modulo_sig(tcx, def_id, opaque_def_id) else {\n-        return false;\n-    };\n-\n-    struct Visitor<'tcx> {\n-        opaque_def_id: LocalDefId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-        seen: FxHashSet<LocalDefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for Visitor<'tcx> {\n-        type BreakTy = ();\n-        #[instrument(level = \"trace\", skip(self), ret)]\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n-            // FIXME(oli-obk): We should be checking if the associated type\n-            // is mentioned instead of normalizing to find the opaque type.\n-            // But that requires a way to figure out that a projection refers\n-            // to a specific opaque type. That is probably doable by checking for\n-            // `Self` as the `substs[0]`.\n-            let normalized_ty = self.tcx.normalize_erasing_regions(self.param_env, ty);\n-            if let ty::Alias(ty::Opaque, alias) = normalized_ty.kind() {\n-                if let Some(def_id) = alias.def_id.as_local() {\n-                    trace!(?alias.def_id);\n-                    if def_id == self.opaque_def_id {\n-                        return ControlFlow::Break(());\n-                    }\n-\n-                    if self.seen.insert(def_id) {\n-                        // Look into nested obligations like `impl Trait<Assoc = impl OtherTrait>`.\n-                        for (pred, _) in self\n-                            .tcx\n-                            .explicit_item_bounds(alias.def_id)\n-                            .subst_iter_copied(self.tcx, alias.substs)\n-                        {\n-                            pred.visit_with(self)?;\n-                        }\n-                    }\n-                }\n-            }\n-            normalized_ty.super_visit_with(self)\n-        }\n-    }\n-    sig.visit_with(&mut Visitor { opaque_def_id, param_env, tcx, seen: Default::default() })\n-        .is_break()\n-}"}, {"sha": "b45f7caaabe08945346173ad5c37d81d77643b0c", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -172,6 +172,10 @@ impl EraseType for ty::Binder<'_, ty::FnSig<'_>> {\n     type Result = [u8; size_of::<ty::Binder<'static, ty::FnSig<'static>>>()];\n }\n \n+impl EraseType for ty::Binder<'_, &'_ ty::List<Ty<'_>>> {\n+    type Result = [u8; size_of::<ty::Binder<'static, &'static ty::List<Ty<'static>>>>()];\n+}\n+\n impl<T0, T1> EraseType for (&'_ T0, &'_ T1) {\n     type Result = [u8; size_of::<(&'static (), &'static ())>()];\n }"}, {"sha": "31929e4f4f6291b59ee0b2a65834460926756398", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -1265,7 +1265,7 @@ impl<'tcx> AliasTy<'tcx> {\n \n     /// Extracts the underlying trait reference and own substs from this projection.\n     /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n-    /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n+    /// then this function would return a `T: StreamingIterator` trait reference and `['a]` as the own substs\n     pub fn trait_ref_and_own_substs(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "9bab693156b3df6bf0b7345d8205b29221915dee", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -36,7 +36,12 @@ pub struct Discr<'tcx> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CheckRegions {\n     No,\n+    /// Only permit early bound regions. This is useful for Adts which\n+    /// can never have late bound regions.\n     OnlyEarlyBound,\n+    /// Permit both late bound and early bound regions. Use this for functions,\n+    /// which frequently have late bound regions.\n+    Bound,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -471,15 +476,21 @@ impl<'tcx> TyCtxt<'tcx> {\n         ignore_regions: CheckRegions,\n     ) -> Result<(), NotUniqueParam<'tcx>> {\n         let mut seen = GrowableBitSet::default();\n+        let mut seen_late = FxHashSet::default();\n         for arg in substs {\n             match arg.unpack() {\n                 GenericArgKind::Lifetime(lt) => match (ignore_regions, lt.kind()) {\n-                    (CheckRegions::OnlyEarlyBound, ty::ReEarlyBound(p)) => {\n+                    (CheckRegions::Bound, ty::ReLateBound(di, reg)) => {\n+                        if !seen_late.insert((di, reg)) {\n+                            return Err(NotUniqueParam::DuplicateParam(lt.into()));\n+                        }\n+                    }\n+                    (CheckRegions::OnlyEarlyBound | CheckRegions::Bound, ty::ReEarlyBound(p)) => {\n                         if !seen.insert(p.index) {\n                             return Err(NotUniqueParam::DuplicateParam(lt.into()));\n                         }\n                     }\n-                    (CheckRegions::OnlyEarlyBound, _) => {\n+                    (CheckRegions::OnlyEarlyBound | CheckRegions::Bound, _) => {\n                         return Err(NotUniqueParam::NotParam(lt.into()));\n                     }\n                     (CheckRegions::No, _) => {}"}, {"sha": "5bc3e3c00c9af857ff1a9d8cb64f6993b9fa2b89", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -55,3 +55,11 @@ ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with\n ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n \n ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n+\n+ty_utils_impl_trait_duplicate_arg = non-defining opaque type use in defining scope\n+    .label = generic argument `{$arg}` used twice\n+    .note = for this opaque type\n+\n+ty_utils_impl_trait_not_param = non-defining opaque type use in defining scope\n+    .label = argument `{$arg}` is not a generic parameter\n+    .note = for this opaque type"}, {"sha": "553bf40ef3a48afb320ba14626dc6a519160c24c", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -1,7 +1,7 @@\n //! Errors emitted by ty_utils\n \n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{GenericArg, Ty};\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n@@ -100,3 +100,25 @@ pub struct NonPrimitiveSimdType<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub e_ty: Ty<'tcx>,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_impl_trait_duplicate_arg)]\n+pub struct DuplicateArg<'tcx> {\n+    pub arg: GenericArg<'tcx>,\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note]\n+    pub opaque_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_impl_trait_not_param)]\n+pub struct NotParam<'tcx> {\n+    pub arg: GenericArg<'tcx>,\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note]\n+    pub opaque_span: Span,\n+}"}, {"sha": "25ebb333bf74ac6edc9062f6fed2b966c3ef63b4", "filename": "compiler/rustc_ty_utils/src/opaque_types.rs", "status": "modified", "additions": 141, "deletions": 24, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_ty_utils%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/compiler%2Frustc_ty_utils%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fopaque_types.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -1,46 +1,165 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::{def::DefKind, def_id::LocalDefId};\n-use rustc_middle::ty::util::CheckRegions;\n+use rustc_middle::ty::util::{CheckRegions, NotUniqueParam};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_span::Span;\n use rustc_type_ir::AliasKind;\n use std::ops::ControlFlow;\n \n+use crate::errors::{DuplicateArg, NotParam};\n+\n struct OpaqueTypeCollector<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaques: Vec<LocalDefId>,\n+    /// The `DefId` of the item which we are collecting opaque types for.\n+    item: LocalDefId,\n+\n+    /// Avoid infinite recursion due to recursive declarations.\n+    seen: FxHashSet<LocalDefId>,\n+}\n+\n+impl<'tcx> OpaqueTypeCollector<'tcx> {\n+    fn collect(\n+        tcx: TyCtxt<'tcx>,\n+        item: LocalDefId,\n+        val: ty::Binder<'tcx, impl TypeVisitable<TyCtxt<'tcx>>>,\n+    ) -> Vec<LocalDefId> {\n+        let mut collector = Self { tcx, opaques: Vec::new(), item, seen: Default::default() };\n+        val.skip_binder().visit_with(&mut collector);\n+        collector.opaques\n+    }\n+\n+    fn span(&self) -> Span {\n+        self.tcx.def_span(self.item)\n+    }\n+\n+    fn parent(&self) -> Option<LocalDefId> {\n+        match self.tcx.def_kind(self.item) {\n+            DefKind::Fn => None,\n+            DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n+                Some(self.tcx.local_parent(self.item))\n+            }\n+            other => span_bug!(\n+                self.tcx.def_span(self.item),\n+                \"unhandled item with opaque types: {other:?}\"\n+            ),\n+        }\n+    }\n }\n \n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OpaqueTypeCollector<'tcx> {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<!> {\n+    type BreakTy = ErrorGuaranteed;\n+\n+    #[instrument(skip(self), ret, level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<ErrorGuaranteed> {\n         match t.kind() {\n-            ty::Alias(AliasKind::Opaque, alias_ty) => {\n-                if let Some(def_id) = alias_ty.def_id.as_local() {\n-                    if self\n-                        .tcx\n-                        .uses_unique_generic_params(alias_ty.substs, CheckRegions::OnlyEarlyBound)\n-                        .is_ok()\n-                    {\n-                        self.opaques.push(def_id);\n-                        return ControlFlow::Continue(());\n-                    } else {\n-                        warn!(?t, \"opaque types with non-unique params in sig: {t:?}\");\n+            ty::Alias(AliasKind::Opaque, alias_ty) if alias_ty.def_id.is_local() => {\n+                if !self.seen.insert(alias_ty.def_id.expect_local()) {\n+                    return ControlFlow::Continue(());\n+                }\n+                match self.tcx.uses_unique_generic_params(alias_ty.substs, CheckRegions::Bound) {\n+                    Ok(()) => {\n+                        // FIXME: implement higher kinded lifetime bounds on nested opaque types. They are not\n+                        // supported at all, so this is sound to do, but once we want to support them, you'll\n+                        // start seeing the error below.\n+\n+                        self.opaques.push(alias_ty.def_id.expect_local());\n+\n+                        // Collect opaque types nested within the associated type bounds of this opaque type.\n+                        for (pred, _span) in self\n+                            .tcx\n+                            .explicit_item_bounds(alias_ty.def_id)\n+                            .subst_iter_copied(self.tcx, alias_ty.substs)\n+                        {\n+                            trace!(?pred);\n+                            pred.visit_with(self)?;\n+                        }\n+\n+                        ControlFlow::Continue(())\n+                    }\n+                    Err(NotUniqueParam::NotParam(arg)) => {\n+                        let err = self.tcx.sess.emit_err(NotParam {\n+                            arg,\n+                            span: self.span(),\n+                            opaque_span: self.tcx.def_span(alias_ty.def_id),\n+                        });\n+                        ControlFlow::Break(err)\n+                    }\n+                    Err(NotUniqueParam::DuplicateParam(arg)) => {\n+                        let err = self.tcx.sess.emit_err(DuplicateArg {\n+                            arg,\n+                            span: self.span(),\n+                            opaque_span: self.tcx.def_span(alias_ty.def_id),\n+                        });\n+                        ControlFlow::Break(err)\n                     }\n                 }\n             }\n-            _ => {}\n+            ty::Alias(AliasKind::Projection, alias_ty) => {\n+                if let Some(parent) = self.parent() {\n+                    trace!(?alias_ty);\n+                    let (trait_ref, own_substs) = alias_ty.trait_ref_and_own_substs(self.tcx);\n+\n+                    trace!(?trait_ref, ?own_substs);\n+                    // This avoids having to do normalization of `Self::AssocTy` by only\n+                    // supporting the case of a method defining opaque types from assoc types\n+                    // in the same impl block.\n+                    if trait_ref.self_ty() == self.tcx.type_of(parent).subst_identity() {\n+                        for assoc in self.tcx.associated_items(parent).in_definition_order() {\n+                            trace!(?assoc);\n+                            if assoc.trait_item_def_id == Some(alias_ty.def_id) {\n+                                // We reconstruct the generic args of the associated type within the impl\n+                                // from the impl's generics and the generic args passed to the type via the\n+                                // projection.\n+                                let substs = ty::InternalSubsts::identity_for_item(\n+                                    self.tcx,\n+                                    parent.to_def_id(),\n+                                );\n+                                trace!(?substs);\n+                                let substs: Vec<_> =\n+                                    substs.iter().chain(own_substs.iter().copied()).collect();\n+                                trace!(?substs);\n+                                // Find opaque types in this associated type.\n+                                return self\n+                                    .tcx\n+                                    .type_of(assoc.def_id)\n+                                    .subst(self.tcx, &substs)\n+                                    .visit_with(self);\n+                            }\n+                        }\n+                    }\n+                }\n+                t.super_visit_with(self)\n+            }\n+            _ => t.super_visit_with(self),\n         }\n-        t.super_visit_with(self)\n     }\n }\n \n fn opaque_types_defined_by<'tcx>(tcx: TyCtxt<'tcx>, item: LocalDefId) -> &'tcx [LocalDefId] {\n-    // FIXME(type_alias_impl_trait): This is definitely still wrong except for RPIT.\n-    match tcx.def_kind(item) {\n-        DefKind::Fn | DefKind::AssocFn => {\n-            let sig = tcx.fn_sig(item).subst_identity();\n-            let mut collector = OpaqueTypeCollector { tcx, opaques: Vec::new() };\n-            sig.visit_with(&mut collector);\n-            tcx.arena.alloc_from_iter(collector.opaques)\n+    let kind = tcx.def_kind(item);\n+    trace!(?kind);\n+    // FIXME(type_alias_impl_trait): This is definitely still wrong except for RPIT and impl trait in assoc types.\n+    match kind {\n+        // We're also doing this for `AssocTy` for the wf checks in `check_opaque_meets_bounds`\n+        DefKind::Fn | DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n+            let defined_opaques = match kind {\n+                DefKind::Fn => {\n+                    OpaqueTypeCollector::collect(tcx, item, tcx.fn_sig(item).subst_identity())\n+                }\n+                DefKind::AssocFn => {\n+                    OpaqueTypeCollector::collect(tcx, item, tcx.fn_sig(item).subst_identity())\n+                }\n+                DefKind::AssocTy | DefKind::AssocConst => OpaqueTypeCollector::collect(\n+                    tcx,\n+                    item,\n+                    ty::Binder::dummy(tcx.type_of(item).subst_identity()),\n+                ),\n+                _ => unreachable!(),\n+            };\n+            tcx.arena.alloc_from_iter(defined_opaques)\n         }\n         DefKind::Mod\n         | DefKind::Struct\n@@ -51,13 +170,11 @@ fn opaque_types_defined_by<'tcx>(tcx: TyCtxt<'tcx>, item: LocalDefId) -> &'tcx [\n         | DefKind::TyAlias\n         | DefKind::ForeignTy\n         | DefKind::TraitAlias\n-        | DefKind::AssocTy\n         | DefKind::TyParam\n         | DefKind::Const\n         | DefKind::ConstParam\n         | DefKind::Static(_)\n         | DefKind::Ctor(_, _)\n-        | DefKind::AssocConst\n         | DefKind::Macro(_)\n         | DefKind::ExternCrate\n         | DefKind::Use"}, {"sha": "7de906e7ef3f3e663615c94f0eebfd4416ee23d0", "filename": "tests/ui/generic-associated-types/issue-88595.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -19,4 +19,5 @@ impl<'a> A<'a> for C {\n     type B<'b> = impl Clone;\n \n     fn a(&'a self) -> Self::B<'a> {} //~ ERROR: non-defining opaque type use in defining scope\n+    //~^ ERROR: mismatched types\n }"}, {"sha": "d6caed854599325d773e546918471bf918e0ee1a", "filename": "tests/ui/generic-associated-types/issue-88595.stderr", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -1,16 +1,34 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-88595.rs:21:35\n+  --> $DIR/issue-88595.rs:21:5\n    |\n LL |     fn a(&'a self) -> Self::B<'a> {}\n-   |                                   ^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ generic argument `'a` used twice\n    |\n-note: lifetime used multiple times\n-  --> $DIR/issue-88595.rs:18:6\n+note: for this opaque type\n+  --> $DIR/issue-88595.rs:19:18\n    |\n-LL | impl<'a> A<'a> for C {\n-   |      ^^\n LL |     type B<'b> = impl Clone;\n-   |            ^^\n+   |                  ^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-88595.rs:21:23\n+   |\n+LL |     type B<'b> = impl Clone;\n+   |                  ---------- the expected opaque type\n+LL |\n+LL |     fn a(&'a self) -> Self::B<'a> {}\n+   |        -              ^^^^^^^^^^^ expected opaque type, found `()`\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected opaque type `<C as A<'a>>::B<'a>`\n+                found unit type `()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/issue-88595.rs:21:5\n+   |\n+LL |     fn a(&'a self) -> Self::B<'a> {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c395b4195a05fcbfcac2b2366134239cb42caf6f", "filename": "tests/ui/impl-trait/in-assoc-type-unconstrained.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -0,0 +1,27 @@\n+#![feature(impl_trait_in_assoc_type)]\n+\n+mod compare_ty {\n+    trait Trait {\n+        type Ty: IntoIterator<Item = ()>;\n+    }\n+    impl Trait for () {\n+        type Ty = Option<impl Sized>;\n+        //~^ ERROR: unconstrained opaque type\n+        //~| ERROR: type mismatch resolving `<Option<<() as Trait>::Ty::{opaque#0}> as IntoIterator>::Item == ()`\n+    }\n+}\n+\n+mod compare_method {\n+    trait Trait {\n+        type Ty;\n+        fn method() -> Self::Ty;\n+    }\n+    impl Trait for () {\n+        type Ty = impl Sized;\n+        //~^ ERROR: unconstrained opaque type\n+        fn method() -> () {}\n+        //~^ ERROR: method `method` has an incompatible type for trait\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1097cd0f452a870b542c43fbcb91c52708641eaf", "filename": "tests/ui/impl-trait/in-assoc-type-unconstrained.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.stderr?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -0,0 +1,59 @@\n+error[E0271]: type mismatch resolving `<Option<<() as Trait>::Ty::{opaque#0}> as IntoIterator>::Item == ()`\n+  --> $DIR/in-assoc-type-unconstrained.rs:8:19\n+   |\n+LL |         type Ty = Option<impl Sized>;\n+   |                   ^^^^^^^^^^^^^^^^^^ expected `()`, found opaque type\n+   |\n+   = note: expected unit type `()`\n+            found opaque type `<() as compare_ty::Trait>::Ty::{opaque#0}`\n+note: required by a bound in `compare_ty::Trait::Ty`\n+  --> $DIR/in-assoc-type-unconstrained.rs:5:31\n+   |\n+LL |         type Ty: IntoIterator<Item = ()>;\n+   |                               ^^^^^^^^^ required by this bound in `Trait::Ty`\n+\n+error: unconstrained opaque type\n+  --> $DIR/in-assoc-type-unconstrained.rs:8:26\n+   |\n+LL |         type Ty = Option<impl Sized>;\n+   |                          ^^^^^^^^^^\n+   |\n+   = note: `Ty` must be used in combination with a concrete type within the same impl\n+\n+error[E0053]: method `method` has an incompatible type for trait\n+  --> $DIR/in-assoc-type-unconstrained.rs:22:24\n+   |\n+LL |         type Ty = impl Sized;\n+   |                   ---------- the expected opaque type\n+LL |\n+LL |         fn method() -> () {}\n+   |                        ^^\n+   |                        |\n+   |                        expected opaque type, found `()`\n+   |                        help: change the output type to match the trait: `<() as compare_method::Trait>::Ty`\n+   |\n+note: type in trait\n+  --> $DIR/in-assoc-type-unconstrained.rs:17:24\n+   |\n+LL |         fn method() -> Self::Ty;\n+   |                        ^^^^^^^^\n+   = note: expected signature `fn() -> <() as compare_method::Trait>::Ty`\n+              found signature `fn()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/in-assoc-type-unconstrained.rs:22:9\n+   |\n+LL |         fn method() -> () {}\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: unconstrained opaque type\n+  --> $DIR/in-assoc-type-unconstrained.rs:20:19\n+   |\n+LL |         type Ty = impl Sized;\n+   |                   ^^^^^^^^^^\n+   |\n+   = note: `Ty` must be used in combination with a concrete type within the same impl\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0053, E0271.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "36c54bdd6de346f83056f3b7bc2de8134cc587fb", "filename": "tests/ui/impl-trait/in-assoc-type.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -0,0 +1,21 @@\n+#![feature(impl_trait_in_assoc_type)]\n+\n+trait Foo<T> {\n+    type Bar;\n+    fn foo(&self) -> <Self as Foo<()>>::Bar\n+    where\n+        Self: Foo<()>;\n+}\n+\n+impl Foo<()> for () {\n+    type Bar = impl std::fmt::Debug;\n+    fn foo(&self) -> Self::Bar {}\n+}\n+\n+impl Foo<i32> for () {\n+    type Bar = u32;\n+    fn foo(&self) -> <Self as Foo<()>>::Bar {}\n+    //~^ ERROR: mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "f0a272dc2d5d1e267d2e55353aef81148908fb1e", "filename": "tests/ui/impl-trait/in-assoc-type.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.stderr?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: mismatched types\n+  --> $DIR/in-assoc-type.rs:17:22\n+   |\n+LL |     type Bar = impl std::fmt::Debug;\n+   |                -------------------- the expected opaque type\n+...\n+LL |     fn foo(&self) -> <Self as Foo<()>>::Bar {}\n+   |        ---           ^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found `()`\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected opaque type `<() as Foo<()>>::Bar`\n+                found unit type `()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/in-assoc-type.rs:17:5\n+   |\n+LL |     fn foo(&self) -> <Self as Foo<()>>::Bar {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "fe62a8f32888b3a5212d7709ede9574ca332c473", "filename": "tests/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -43,6 +43,11 @@ LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n    |\n    = note: expected signature `fn(&b::Bar, &(b::Foo, i32)) -> _`\n               found signature `fn(&b::Bar, &(b::Bar, i32)) -> _`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:24:9\n+   |\n+LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "58eaa9c2c42635a4227808b3ec1ce6918e928d50", "filename": "tests/ui/type-alias-impl-trait/associated-type-impl-trait-lifetime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e92f761fe54fc602ec2bf63819e8c973d1facd5/tests%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs?ref=4e92f761fe54fc602ec2bf63819e8c973d1facd5", "patch": "@@ -12,7 +12,9 @@ impl<'a> Trait for &'a () {\n     type Opaque1 = impl Sized;\n     type Opaque2 = impl Sized + 'a;\n     fn constrain(self) -> (Self::Opaque1, Self::Opaque2) {\n-        ((), self)\n+        let a: Self::Opaque1 = ();\n+        let b: Self::Opaque2 = self;\n+        (a, b)\n     }\n }\n "}]}