{"sha": "96cf7999ab64ead0c06384da51eb8586ffebfc1e", "node_id": "C_kwDOAAsO6NoAKDk2Y2Y3OTk5YWI2NGVhZDBjMDYzODRkYTUxZWI4NTg2ZmZlYmZjMWU", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-18T14:37:31Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-24T11:18:21Z"}, "message": "Introduce Bx::switch_to_block", "tree": {"sha": "cdfaed89f7ad40550e40560013125b9026d8a8b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdfaed89f7ad40550e40560013125b9026d8a8b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96cf7999ab64ead0c06384da51eb8586ffebfc1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96cf7999ab64ead0c06384da51eb8586ffebfc1e", "html_url": "https://github.com/rust-lang/rust/commit/96cf7999ab64ead0c06384da51eb8586ffebfc1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96cf7999ab64ead0c06384da51eb8586ffebfc1e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0edcf1e2496caed074187c3c5ffac14537e633cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0edcf1e2496caed074187c3c5ffac14537e633cf", "html_url": "https://github.com/rust-lang/rust/commit/0edcf1e2496caed074187c3c5ffac14537e633cf"}], "stats": {"total": 189, "additions": 95, "deletions": 94}, "files": [{"sha": "b430dc329cb9aacc7f79bd1a4a9f4bca4259b1eb", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=96cf7999ab64ead0c06384da51eb8586ffebfc1e", "patch": "@@ -404,6 +404,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         func.new_block(name)\n     }\n \n+    fn switch_to_block(&mut self, block: Self::BasicBlock) {\n+        *self.cx.current_block.borrow_mut() = Some(block);\n+        self.block = Some(block);\n+    }\n+\n     fn ret_void(&mut self) {\n         self.llbb().end_with_void_return(None)\n     }\n@@ -886,19 +891,20 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n         self.br(header_bb);\n \n-        let mut header_bx = Builder::build(self.cx, header_bb);\n-        let keep_going = header_bx.icmp(IntPredicate::IntNE, current_val, end);\n-        header_bx.cond_br(keep_going, body_bb, next_bb);\n+        self.switch_to_block(header_bb);\n+        let keep_going = self.icmp(IntPredicate::IntNE, current_val, end);\n+        self.cond_br(keep_going, body_bb, next_bb);\n \n-        let mut body_bx = Builder::build(self.cx, body_bb);\n+        self.switch_to_block(body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n-        cg_elem.val.store(&mut body_bx, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n+        cg_elem.val.store(&mut self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n-        let next = body_bx.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n-        body_bx.llbb().add_assignment(None, current, next);\n-        body_bx.br(header_bb);\n+        let next = self.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n+        self.llbb().add_assignment(None, current, next);\n+        self.br(header_bb);\n \n-        Builder::build(self.cx, next_bb)\n+        self.switch_to_block(next_bb);\n+        self\n     }\n \n     fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {"}, {"sha": "780af5bc2af8b444f9004dacfa0faedfe393de91", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=96cf7999ab64ead0c06384da51eb8586ffebfc1e", "patch": "@@ -166,6 +166,10 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Self::append_block(self.cx, self.llfn(), name)\n     }\n \n+    fn switch_to_block(&mut self, llbb: Self::BasicBlock) {\n+        *self = Self::build(self.cx, llbb)\n+    }\n+\n     fn ret_void(&mut self) {\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);"}, {"sha": "e7c13e793d92e3150cca00f3d9b8f33243d73989", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=96cf7999ab64ead0c06384da51eb8586ffebfc1e", "patch": "@@ -522,11 +522,11 @@ fn codegen_msvc_try<'ll>(\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n         bx.invoke(try_func_ty, try_func, &[data], normal, catchswitch, None);\n \n-        let mut normal = Builder::build(bx.cx, normal);\n-        normal.ret(bx.const_i32(0));\n+        bx.switch_to_block(normal);\n+        bx.ret(bx.const_i32(0));\n \n-        let mut catchswitch = Builder::build(bx.cx, catchswitch);\n-        let cs = catchswitch.catch_switch(None, None, &[catchpad_rust, catchpad_foreign]);\n+        bx.switch_to_block(catchswitch);\n+        let cs = bx.catch_switch(None, None, &[catchpad_rust, catchpad_foreign]);\n \n         // We can't use the TypeDescriptor defined in libpanic_unwind because it\n         // might be in another DLL and the SEH encoding only supports specifying\n@@ -559,24 +559,24 @@ fn codegen_msvc_try<'ll>(\n         // since our exception object effectively contains a Box.\n         //\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n-        let mut catchpad_rust = Builder::build(bx.cx, catchpad_rust);\n+        bx.switch_to_block(catchpad_rust);\n         let flags = bx.const_i32(8);\n-        let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n-        let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n+        let funclet = bx.catch_pad(cs, &[tydesc, flags, slot]);\n+        let ptr = bx.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        catchpad_rust.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n-        catchpad_rust.catch_ret(&funclet, caught);\n+        bx.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n+        bx.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n-        let mut catchpad_foreign = Builder::build(bx.cx, catchpad_foreign);\n+        bx.switch_to_block(catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n-        let funclet = catchpad_foreign.catch_pad(cs, &[null, flags, null]);\n-        catchpad_foreign.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n-        catchpad_foreign.catch_ret(&funclet, caught);\n+        let funclet = bx.catch_pad(cs, &[null, flags, null]);\n+        bx.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n+        bx.catch_ret(&funclet, caught);\n \n-        let mut caught = Builder::build(bx.cx, caught);\n-        caught.ret(bx.const_i32(1));\n+        bx.switch_to_block(caught);\n+        bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -626,24 +626,24 @@ fn codegen_gnu_try<'ll>(\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n         bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n \n-        let mut then = Builder::build(bx.cx, then);\n-        then.ret(bx.const_i32(0));\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let mut catch = Builder::build(bx.cx, catch);\n+        bx.switch_to_block(catch);\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n-        let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 1);\n+        let vals = bx.landing_pad(lpad_ty, bx.eh_personality(), 1);\n         let tydesc = bx.const_null(bx.type_i8p());\n-        catch.add_clause(vals, tydesc);\n-        let ptr = catch.extract_value(vals, 0);\n+        bx.add_clause(vals, tydesc);\n+        let ptr = bx.extract_value(vals, 0);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        catch.call(catch_ty, catch_func, &[data, ptr], None);\n-        catch.ret(bx.const_i32(1));\n+        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -690,51 +690,45 @@ fn codegen_emcc_try<'ll>(\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n         bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n \n-        let mut then = Builder::build(bx.cx, then);\n-        then.ret(bx.const_i32(0));\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n-        let mut catch = Builder::build(bx.cx, catch);\n+        bx.switch_to_block(catch);\n         let tydesc = bx.eh_catch_typeinfo();\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n-        let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 2);\n-        catch.add_clause(vals, tydesc);\n-        catch.add_clause(vals, bx.const_null(bx.type_i8p()));\n-        let ptr = catch.extract_value(vals, 0);\n-        let selector = catch.extract_value(vals, 1);\n+        let vals = bx.landing_pad(lpad_ty, bx.eh_personality(), 2);\n+        bx.add_clause(vals, tydesc);\n+        bx.add_clause(vals, bx.const_null(bx.type_i8p()));\n+        let ptr = bx.extract_value(vals, 0);\n+        let selector = bx.extract_value(vals, 1);\n \n         // Check if the typeid we got is the one for a Rust panic.\n-        let rust_typeid = catch.call_intrinsic(\"llvm.eh.typeid.for\", &[tydesc]);\n-        let is_rust_panic = catch.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n-        let is_rust_panic = catch.zext(is_rust_panic, bx.type_bool());\n+        let rust_typeid = bx.call_intrinsic(\"llvm.eh.typeid.for\", &[tydesc]);\n+        let is_rust_panic = bx.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n+        let is_rust_panic = bx.zext(is_rust_panic, bx.type_bool());\n \n         // We need to pass two values to catch_func (ptr and is_rust_panic), so\n         // create an alloca and pass a pointer to that.\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let i8_align = bx.tcx().data_layout.i8_align.abi;\n         let catch_data_type = bx.type_struct(&[bx.type_i8p(), bx.type_bool()], false);\n-        let catch_data = catch.alloca(catch_data_type, ptr_align);\n-        let catch_data_0 = catch.inbounds_gep(\n-            catch_data_type,\n-            catch_data,\n-            &[bx.const_usize(0), bx.const_usize(0)],\n-        );\n-        catch.store(ptr, catch_data_0, ptr_align);\n-        let catch_data_1 = catch.inbounds_gep(\n-            catch_data_type,\n-            catch_data,\n-            &[bx.const_usize(0), bx.const_usize(1)],\n-        );\n-        catch.store(is_rust_panic, catch_data_1, i8_align);\n-        let catch_data = catch.bitcast(catch_data, bx.type_i8p());\n+        let catch_data = bx.alloca(catch_data_type, ptr_align);\n+        let catch_data_0 =\n+            bx.inbounds_gep(catch_data_type, catch_data, &[bx.const_usize(0), bx.const_usize(0)]);\n+        bx.store(ptr, catch_data_0, ptr_align);\n+        let catch_data_1 =\n+            bx.inbounds_gep(catch_data_type, catch_data, &[bx.const_usize(0), bx.const_usize(1)]);\n+        bx.store(is_rust_panic, catch_data_1, i8_align);\n+        let catch_data = bx.bitcast(catch_data, bx.type_i8p());\n \n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        catch.call(catch_ty, catch_func, &[data, catch_data], None);\n-        catch.ret(bx.const_i32(1));\n+        bx.call(catch_ty, catch_func, &[data, catch_data], None);\n+        bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function"}, {"sha": "ceb3d5a84abf3ecf795eae8b82cacddb8014e6ef", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=96cf7999ab64ead0c06384da51eb8586ffebfc1e", "patch": "@@ -131,51 +131,47 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     // it could be on the stack so we have to update the offset and then check\n     // the offset again.\n \n-    let mut maybe_reg = Builder::build(bx.cx, maybe_reg);\n+    bx.switch_to_block(maybe_reg);\n     if gr_type && layout.align.abi.bytes() > 8 {\n-        reg_off_v = maybe_reg.add(reg_off_v, bx.const_i32(15));\n-        reg_off_v = maybe_reg.and(reg_off_v, bx.const_i32(-16));\n+        reg_off_v = bx.add(reg_off_v, bx.const_i32(15));\n+        reg_off_v = bx.and(reg_off_v, bx.const_i32(-16));\n     }\n-    let new_reg_off_v = maybe_reg.add(reg_off_v, bx.const_i32(slot_size as i32));\n+    let new_reg_off_v = bx.add(reg_off_v, bx.const_i32(slot_size as i32));\n \n-    maybe_reg.store(new_reg_off_v, reg_off, offset_align);\n+    bx.store(new_reg_off_v, reg_off, offset_align);\n \n     // Check to see if we have overflowed the registers as a result of this.\n     // If we have then we need to use the stack for this value\n-    let use_stack = maybe_reg.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n-    maybe_reg.cond_br(use_stack, on_stack, in_reg);\n+    let use_stack = bx.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n+    bx.cond_br(use_stack, on_stack, in_reg);\n \n-    let mut in_reg = Builder::build(bx.cx, in_reg);\n+    bx.switch_to_block(in_reg);\n     let top_type = bx.type_i8p();\n-    let top = in_reg.struct_gep(va_list_ty, va_list_addr, reg_top_index);\n-    let top = in_reg.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n+    let top = bx.struct_gep(va_list_ty, va_list_addr, reg_top_index);\n+    let top = bx.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n \n     // reg_value = *(@top + reg_off_v);\n-    let mut reg_addr = in_reg.gep(bx.type_i8(), top, &[reg_off_v]);\n+    let mut reg_addr = bx.gep(bx.type_i8(), top, &[reg_off_v]);\n     if bx.tcx().sess.target.endian == Endian::Big && layout.size.bytes() != slot_size {\n         // On big-endian systems the value is right-aligned in its slot.\n         let offset = bx.const_i32((slot_size - layout.size.bytes()) as i32);\n-        reg_addr = in_reg.gep(bx.type_i8(), reg_addr, &[offset]);\n+        reg_addr = bx.gep(bx.type_i8(), reg_addr, &[offset]);\n     }\n     let reg_type = layout.llvm_type(bx);\n-    let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n-    let reg_value = in_reg.load(reg_type, reg_addr, layout.align.abi);\n-    in_reg.br(end);\n+    let reg_addr = bx.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n+    let reg_value = bx.load(reg_type, reg_addr, layout.align.abi);\n+    bx.br(end);\n \n     // On Stack block\n-    let mut on_stack = Builder::build(bx.cx, on_stack);\n+    bx.switch_to_block(on_stack);\n     let stack_value =\n-        emit_ptr_va_arg(&mut on_stack, list, target_ty, false, Align::from_bytes(8).unwrap(), true);\n-    on_stack.br(end);\n+        emit_ptr_va_arg(bx, list, target_ty, false, Align::from_bytes(8).unwrap(), true);\n+    bx.br(end);\n \n-    let mut end = Builder::build(bx.cx, end);\n-    let val = end.phi(\n-        layout.immediate_llvm_type(bx),\n-        &[reg_value, stack_value],\n-        &[in_reg.llbb(), on_stack.llbb()],\n-    );\n+    bx.switch_to_block(end);\n+    let val =\n+        bx.phi(layout.immediate_llvm_type(bx), &[reg_value, stack_value], &[in_reg, on_stack]);\n \n-    *bx = end;\n     val\n }\n "}, {"sha": "39375b95b19f690827c6fa10ad27252a08346788", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=96cf7999ab64ead0c06384da51eb8586ffebfc1e", "patch": "@@ -170,10 +170,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n \n             if let Some((ret_dest, target)) = destination {\n-                let target_llbb = fx.llbb(target);\n-                let mut ret_bx = Bx::build(fx.cx, target_llbb);\n-                fx.set_debug_loc(&mut ret_bx, self.terminator.source_info);\n-                fx.store_return(&mut ret_bx, ret_dest, &fn_abi.ret, invokeret);\n+                bx.switch_to_block(fx.llbb(target));\n+                fx.set_debug_loc(bx, self.terminator.source_info);\n+                fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n             let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n@@ -462,7 +461,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         // After this point, bx is the block for the call to panic.\n-        bx = Bx::build(self.cx, panic_block);\n+        bx.switch_to_block(panic_block);\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n@@ -914,20 +913,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let bb_fail = bx.append_sibling_block(\"type_test.fail\");\n             bx.cond_br(cond, bb_pass, bb_fail);\n \n-            let mut bx_pass = Bx::build(self.cx, bb_pass);\n+            bx.switch_to_block(bb_pass);\n             helper.do_call(\n                 self,\n-                &mut bx_pass,\n+                &mut bx,\n                 fn_abi,\n                 fn_ptr,\n                 &llargs,\n                 destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                 cleanup,\n             );\n \n-            let mut bx_fail = Bx::build(self.cx, bb_fail);\n-            bx_fail.abort();\n-            bx_fail.unreachable();\n+            bx.switch_to_block(bb_fail);\n+            bx.abort();\n+            bx.unreachable();\n \n             return;\n         }"}, {"sha": "1c7fe060ea4fb1300b35e15e68a5ed0d32c25e4e", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96cf7999ab64ead0c06384da51eb8586ffebfc1e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=96cf7999ab64ead0c06384da51eb8586ffebfc1e", "patch": "@@ -53,6 +53,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn append_sibling_block(&mut self, name: &str) -> Self::BasicBlock;\n \n+    fn switch_to_block(&mut self, llbb: Self::BasicBlock);\n+\n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);\n     fn br(&mut self, dest: Self::BasicBlock);"}]}