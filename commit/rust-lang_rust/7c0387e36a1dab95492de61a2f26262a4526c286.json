{"sha": "7c0387e36a1dab95492de61a2f26262a4526c286", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMDM4N2UzNmExZGFiOTU0OTJkZTYxYTJmMjYyNjJhNDUyNmMyODY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-11-21T14:49:15Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-11-24T15:34:31Z"}, "message": "Do not rewind parser and ignore following blocks\n\nWhen encountering `pub ident`, attempt to identify the code that comes\nafterwards, wether it is a brace block (assume it is a struct), a paren\nlist followed by a colon (assume struct) or a paren list followed by a\nblock (assume a fn). Consume those blocks to avoid any further parser\nerrors and return a `Placeholder` item in order to allow the parser to\ncontinue. In the case of unenclosed blocks, the behavior is the same as\nit is currently: no further errors are processed.", "tree": {"sha": "074202e3afa04e46273552fa09b80cb9f41f24ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/074202e3afa04e46273552fa09b80cb9f41f24ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c0387e36a1dab95492de61a2f26262a4526c286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0387e36a1dab95492de61a2f26262a4526c286", "html_url": "https://github.com/rust-lang/rust/commit/7c0387e36a1dab95492de61a2f26262a4526c286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c0387e36a1dab95492de61a2f26262a4526c286/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547873aa54e787cbb7c266fb6e7337ea4e8a9331", "url": "https://api.github.com/repos/rust-lang/rust/commits/547873aa54e787cbb7c266fb6e7337ea4e8a9331", "html_url": "https://github.com/rust-lang/rust/commit/547873aa54e787cbb7c266fb6e7337ea4e8a9331"}], "stats": {"total": 435, "additions": 380, "deletions": 55}, "files": [{"sha": "0fd2ae9dbc8aa252da0bfcbbcfb08c5262ccd2f0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -1757,7 +1757,9 @@ impl<'a> LoweringContext<'a> {\n                                bounds,\n                                items)\n             }\n-            ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n+            ItemKind::Placeholder | ItemKind::MacroDef(..) | ItemKind::Mac(..) => {\n+                panic!(\"Shouldn't still be around\")\n+            }\n         }\n \n         // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to"}, {"sha": "c2dd7edbb105370392c05d12808766c1f1be3897", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -113,6 +113,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 return visit::walk_item(self, i);\n             }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n+            ItemKind::Placeholder |\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n             ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),"}, {"sha": "1492c817ffd3999c174ea96c614394cf1f3c4cd7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -269,7 +269,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, imported_binding);\n             }\n \n-            ItemKind::GlobalAsm(..) => {}\n+            ItemKind::GlobalAsm(..) | ItemKind::Placeholder => {}\n \n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n "}, {"sha": "64d242307a7d8694315156396a00a38af62b643c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -1947,7 +1947,8 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n \n-            ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(_)=> {\n+            ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(_) |\n+            ItemKind::Placeholder => {\n                 // do nothing, these are just around to be encoded\n             }\n "}, {"sha": "e7cf5782290addca53d1164c7de09f241e6f9ebd", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -548,6 +548,7 @@ impl Sig for ast::Item {\n             // FIXME should implement this (e.g., pub use).\n             ast::ItemKind::Use(_) => Err(\"import\"),\n             ast::ItemKind::Mac(..) | ast::ItemKind::MacroDef(_) => Err(\"Macro\"),\n+            ast::ItemKind::Placeholder => Err(\"placeholder\"),\n         }\n     }\n }"}, {"sha": "a09cfbec879aa7c9dac2c2bc5ea53c95304b2998", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -1977,6 +1977,7 @@ pub enum ItemKind {\n \n     /// A macro definition.\n     MacroDef(MacroDef),\n+    Placeholder,\n }\n \n impl ItemKind {\n@@ -1998,6 +1999,7 @@ impl ItemKind {\n             ItemKind::Mac(..) |\n             ItemKind::MacroDef(..) |\n             ItemKind::Impl(..) |\n+            ItemKind::Placeholder |\n             ItemKind::AutoImpl(..) => \"item\"\n         }\n     }"}, {"sha": "40370eb809688cf93eec38e6ec9daca37674fbad", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -935,6 +935,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n         ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n         ItemKind::MacroDef(def) => ItemKind::MacroDef(folder.fold_macro_def(def)),\n+        ItemKind::Placeholder => ItemKind::Placeholder,\n     }\n }\n "}, {"sha": "0eda8e4d66b310d8809996d7100c7f76ac5deafc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 179, "deletions": 52, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -72,6 +72,50 @@ bitflags! {\n \n type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n+enum HasRecovered<'a, T> {\n+    Success(T),\n+    Recovered(T, DiagnosticBuilder<'a>),\n+}\n+\n+impl<'a, T> HasRecovered<'a, T> {\n+    fn new(t: T, err: Option<DiagnosticBuilder<'a>>) -> HasRecovered<'a, T> {\n+        if let Some(err) = err {\n+            HasRecovered::Recovered(t, err)\n+        } else {\n+            HasRecovered::Success(t)\n+        }\n+    }\n+\n+    fn map<O, F: FnOnce(T) -> O>(self, f: F) -> HasRecovered<'a, O> {\n+        let (t, e) = self.full_unwrap();\n+        HasRecovered::new(f(t), e)\n+    }\n+\n+    fn emit(self) -> T {\n+        match self {\n+            HasRecovered::Recovered(t, mut err) => {\n+                err.emit();\n+                t\n+            }\n+            HasRecovered::Success(t) => t,\n+        }\n+    }\n+\n+    fn full_unwrap(self) -> (T, Option<DiagnosticBuilder<'a>>) {\n+        match self {\n+            HasRecovered::Recovered(t, err) => (t, Some(err)),\n+            HasRecovered::Success(t) => (t, None),\n+        }\n+    }\n+\n+    fn into_result(self) -> PResult<'a, T> {\n+        match self {\n+            HasRecovered::Recovered(_, err) => Err(err),\n+            HasRecovered::Success(t) => Ok(t),\n+        }\n+    }\n+}\n+\n /// How to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n pub enum PathStyle {\n@@ -1156,6 +1200,7 @@ impl<'a> Parser<'a> {\n             None => token::CloseDelim(self.token_cursor.frame.delim),\n         })\n     }\n+\n     fn look_ahead_span(&self, dist: usize) -> Span {\n         if dist == 0 {\n             return self.span\n@@ -1366,6 +1411,7 @@ impl<'a> Parser<'a> {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     *at_end = true;\n                     let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    let body = body.emit();\n                     attrs.extend(inner_attrs.iter().cloned());\n                     Some(body)\n                 }\n@@ -2401,7 +2447,7 @@ impl<'a> Parser<'a> {\n         let mut attrs = outer_attrs;\n         attrs.extend(self.parse_inner_attributes()?);\n \n-        let blk = self.parse_block_tail(lo, blk_mode)?;\n+        let blk = self.parse_block_tail(lo, blk_mode)?.emit();\n         return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), attrs));\n     }\n \n@@ -3157,7 +3203,9 @@ impl<'a> Parser<'a> {\n         attrs.extend(iattrs);\n \n         let hi = self.prev_span;\n-        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_ident), attrs))\n+        Ok(self.mk_expr(span_lo.to(hi),\n+                        ExprKind::ForLoop(pat, expr, loop_block.emit(), opt_ident),\n+                        attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n@@ -3169,6 +3217,7 @@ impl<'a> Parser<'a> {\n         }\n         let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        let body = body.emit();\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n         return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_ident), attrs));\n@@ -3184,6 +3233,7 @@ impl<'a> Parser<'a> {\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n+        let body = body.emit();\n         let span = span_lo.to(body.span);\n         return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n@@ -3193,6 +3243,7 @@ impl<'a> Parser<'a> {\n                            span_lo: Span,\n                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        let body = body.emit();\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n         Ok(self.mk_expr(span, ExprKind::Loop(body, opt_ident), attrs))\n@@ -3203,6 +3254,7 @@ impl<'a> Parser<'a> {\n         -> PResult<'a, P<Expr>>\n     {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        let body = body.emit();\n         attrs.extend(iattrs);\n         Ok(self.mk_expr(span_lo.to(body.span), ExprKind::Catch(body), attrs))\n     }\n@@ -4249,12 +4301,14 @@ impl<'a> Parser<'a> {\n             return Err(e);\n         }\n \n-        self.parse_block_tail(lo, BlockCheckMode::Default)\n+        Ok(self.parse_block_tail(lo, BlockCheckMode::Default)?.emit())\n     }\n \n     /// Parse a block. Inner attrs are allowed.\n-    fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n-        maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n+    fn parse_inner_attrs_and_block(&mut self)\n+        -> PResult<'a, (Vec<Attribute>, HasRecovered<'a, P<Block>>)>\n+    {\n+        maybe_whole!(self, NtBlock, |x| (Vec::new(), HasRecovered::Success(x)));\n \n         let lo = self.span;\n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -4264,11 +4318,22 @@ impl<'a> Parser<'a> {\n \n     /// Parse the rest of a block expression or function body\n     /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n+    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode)\n+        -> PResult<'a, HasRecovered<'a, P<Block>>>\n+    {\n         let mut stmts = vec![];\n \n+        let mut error = None;\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            if let Some(stmt) = self.parse_full_stmt(false)? {\n+            let stmt = match self.parse_full_stmt(false) {\n+                Err(err) => {\n+                    error = Some(err);\n+                    self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Break);\n+                    break;\n+                }\n+                Ok(stmt) => stmt,\n+            };\n+            if let Some(stmt) = stmt {\n                 stmts.push(stmt);\n             } else if self.token == token::Eof {\n                 break;\n@@ -4277,13 +4342,14 @@ impl<'a> Parser<'a> {\n                 continue;\n             };\n         }\n-\n-        Ok(P(ast::Block {\n+        let block = HasRecovered::new(P(ast::Block {\n             stmts,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n             span: lo.to(self.prev_span),\n-        }))\n+        }), error);\n+\n+        Ok(block)\n     }\n \n     /// Parse a statement, including the trailing semicolon.\n@@ -4918,11 +4984,22 @@ impl<'a> Parser<'a> {\n                      constness: Spanned<Constness>,\n                      abi: abi::Abi)\n                      -> PResult<'a, ItemInfo> {\n+\n+        self.parse_item_fn_recoverable(unsafety, constness, abi)?.into_result()\n+    }\n+\n+    fn parse_item_fn_recoverable(&mut self,\n+                                 unsafety: Unsafety,\n+                                 constness: Spanned<Constness>,\n+                                 abi: abi::Abi)\n+                                 -> PResult<'a, HasRecovered<'a, ItemInfo>> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(false)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        Ok((ident, ItemKind::Fn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n+        Ok(body.map(|body| (ident,\n+                            ItemKind::Fn(decl, unsafety, constness, abi, generics, body),\n+                            Some(inner_attrs))))\n     }\n \n     /// true if we are looking at `const ID`, false for things like `const fn` etc\n@@ -5106,6 +5183,7 @@ impl<'a> Parser<'a> {\n             generics.where_clause = self.parse_where_clause()?;\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+            let body = body.into_result()?;\n             Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(ast::MethodSig {\n                 abi,\n                 unsafety,\n@@ -5325,18 +5403,54 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics), None))\n     }\n \n+    fn consume_block(&mut self, delim: token::DelimToken) {\n+        debug!(\"consuming {:?}\", delim);\n+        debug!(\"self.token {:?}\", self.token);\n+        let mut brace_depth = 0;\n+        if !self.eat(&token::OpenDelim(delim)) {\n+            debug!(\"didn't eat delim\");\n+            return;\n+        }\n+        loop {\n+            if self.eat(&token::OpenDelim(delim)) {\n+                debug!(\"add depth\");\n+                brace_depth += 1;\n+            } else if self.eat(&token::CloseDelim(delim)) {\n+                debug!(\"found closing\");\n+                if brace_depth == 0 {\n+                    debug!(\"ending\");\n+                    return;\n+                } else {\n+                    debug!(\"decrease\");\n+                    brace_depth -= 1;\n+                    continue;\n+                }\n+            } else if self.eat(&token::Eof) || self.eat(&token::CloseDelim(token::NoDelim)) {\n+                debug!(\"eof or nodelim\");\n+                return;\n+            } else {\n+                debug!(\"bump\");\n+                self.bump();\n+            }\n+        }\n+    }\n+\n     pub fn parse_record_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n         let mut fields = Vec::new();\n         if self.eat(&token::OpenDelim(token::Brace)) {\n             while self.token != token::CloseDelim(token::Brace) {\n-                fields.push(self.parse_struct_decl_field().map_err(|e| {\n+                let field = self.parse_struct_decl_field().map_err(|e| {\n                     self.recover_stmt();\n-                    self.eat(&token::CloseDelim(token::Brace));\n                     e\n-                })?);\n+                });\n+                match field {\n+                    Ok(field) => fields.push(field),\n+                    Err(mut err) => {\n+                        err.emit();\n+                    }\n+                }\n             }\n-\n-            self.bump();\n+            self.eat(&token::CloseDelim(token::Brace));\n         } else {\n             let token_str = self.this_token_to_string();\n             return Err(self.fatal(&format!(\"expected `where`, or `{{` after struct \\\n@@ -6238,11 +6352,10 @@ impl<'a> Parser<'a> {\n \n         // Verify wether we have encountered a struct or method definition where the user forgot to\n         // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility == Visibility::Public && self.check_ident() {\n-            // Keep the current state of the parser to rollback after an unsuccessful attempt to\n-            // parse an entire method or struct body.\n-            let parser_snapshot = self.clone();\n-\n+        if visibility == Visibility::Public &&\n+            self.check_ident() &&\n+            self.look_ahead(1, |t| *t != token::Not)\n+        {\n             // Space between `pub` keyword and the identifier\n             //\n             //     pub   S {}\n@@ -6251,40 +6364,54 @@ impl<'a> Parser<'a> {\n             if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n                 // possible public struct definition where `struct` was forgotten\n                 let ident = self.parse_ident().unwrap();\n-                match self.parse_record_struct_body() {\n-                    Err(mut err) => {\n-                        // couldn't parse a struct body, continue parsing as if it were a macro\n-                        err.cancel();\n-                        mem::replace(self, parser_snapshot);\n-                    }\n-                    Ok(_) => {\n-                        let msg = format!(\"add `struct` here to parse `{}` as a public struct\",\n-                                          ident);\n-                        let mut err = self.diagnostic()\n-                            .struct_span_err(sp, \"missing `struct` for struct definition\");\n-                        err.span_suggestion_short(sp, &msg, \" struct \".into());\n-                        return Err(err);\n-                    }\n-                }\n+                let msg = format!(\"add `struct` here to parse `{}` as a public struct\",\n+                                  ident);\n+                let mut err = self.diagnostic()\n+                    .struct_span_err(sp, \"missing `struct` for struct definition\");\n+                err.span_suggestion_short(sp, &msg, \" struct \".into());\n+                err.emit();\n+                self.consume_block(token::Brace);\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        ItemKind::Placeholder,\n+                                        visibility,\n+                                        vec![]);\n+                return Ok(Some(item));\n             } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n-                // possible public method definition where `fn` was forgotten\n                 let ident = self.parse_ident().unwrap();\n-                match self.parse_fn_decl(false)\n-                    .and_then(|_| self.parse_where_clause())\n-                    .and_then(|_| self.parse_inner_attrs_and_block()) {\n-                    Err(mut err) => {\n-                        // couldn't parse method arguments or body, continue parsing\n-                        err.cancel();\n-                        mem::replace(self, parser_snapshot);\n-                    }\n-                    Ok(_) => {\n-                        let msg = format!(\"add `fn` here to parse `{}` as a public method\", ident);\n-                        let mut err = self.diagnostic()\n-                            .struct_span_err(sp, \"missing `fn` for method definition\");\n-                        err.span_suggestion_short(sp, &msg, \" fn \".into());\n-                        return Err(err);\n-                    }\n+                self.consume_block(token::Paren);\n+                let (kw, ambiguous) = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.consume_block(token::Brace);\n+                    (\"fn\", false)\n+                } else if self.check(&token::Colon) {\n+                    let kw = \"struct\";\n+                    (kw, false)\n+                } else {\n+                    (\"fn` or `struct\", true)\n+                };\n+\n+                let msg = format!(\"missing `{}`{}\", kw,\n+                                   if ambiguous {\n+                                       \"\".to_string()\n+                                   } else {\n+                                       format!(\" for {} definition\", kw)\n+                                   });\n+                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                if !ambiguous {\n+                    let suggestion = format!(\"add `{kw}` here to parse `{}` as a public {kw}\",\n+                                             ident,\n+                                             kw=kw);\n+                    err.span_suggestion_short(sp, &suggestion, format!(\" {} \", kw));\n                 }\n+                err.emit();\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        ItemKind::Placeholder,\n+                                        visibility,\n+                                        vec![]);\n+                return Ok(Some(item));\n             }\n         }\n         self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, visibility)"}, {"sha": "926bdd2a95776bdb2e09fea74ad02debf535873d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -1386,6 +1386,12 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?;\n             }\n+            ast::ItemKind::Placeholder => {\n+                self.s.word(\"<placeholder \")?;\n+                self.print_ident(item.ident)?;\n+                self.s.word(\">\")?;\n+                self.end()?;\n+            }\n         }\n         self.ann.post(self, NodeItem(item))\n     }"}, {"sha": "5a6fbe0a8f89a48a446efdf2ff5c4d71aab1812b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -307,6 +307,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         }\n         ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n         ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n+        ItemKind::Placeholder => (),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }"}, {"sha": "ceaaa0315d2e01382eb5a525fffa0e935e528245", "filename": "src/test/ui/suggestions/pub-ident-missing-kw-unclosed-block.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw-unclosed-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw-unclosed-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw-unclosed-block.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub Struct {\n+    y: usize,\n+}\n+\n+pub Y {\n+    x: usize,\n+\n+\n+pub struct X {\n+    foo();\n+}\n+\n+pub Z {\n+    x->foo(),\n+}\n+\n+pub foo(foo) {\n+    foo\n+}\n+\n+pub struct X {\n+    foo();\n+}\n+\n+pub Z {\n+    x->foo(),\n+}\n+\n+fn main(){}"}, {"sha": "a580aaac8deba9df7805b4db694c5d62405b90e9", "filename": "src/test/ui/suggestions/pub-ident-missing-kw-unclosed-block.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw-unclosed-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw-unclosed-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw-unclosed-block.stderr?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -0,0 +1,36 @@\n+error: this file contains an un-closed delimiter\n+  --> $DIR/pub-ident-missing-kw-unclosed-block.rs:29:13\n+   |\n+39 | fn main(){}\n+   |             ^\n+   |\n+help: did you mean to close this delimiter?\n+  --> $DIR/pub-ident-missing-kw-unclosed-block.rs:5:7\n+   |\n+15 | pub Y {\n+   |       ^\n+\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-missing-kw-unclosed-block.rs:1:4\n+   |\n+11 | pub Struct {\n+   |    ^\n+   |\n+help: add `struct` here to parse `Struct` as a public struct\n+   |\n+11 | pub struct Struct {\n+   |     ^^^^^^\n+\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-missing-kw-unclosed-block.rs:5:4\n+   |\n+15 | pub Y {\n+   |    ^\n+   |\n+help: add `struct` here to parse `Y` as a public struct\n+   |\n+15 | pub struct Y {\n+   |     ^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "e2a7c394ec94b47e7ba9ad6ece2d60ff5076aabc", "filename": "src/test/ui/suggestions/pub-ident-missing-kw.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw.rs?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub Struct {\n+    y: usize,\n+}\n+\n+pub Y {\n+    x: usize,\n+}\n+\n+pub struct X {\n+    foo();\n+}\n+\n+pub Z {\n+    x->foo(),\n+}\n+\n+pub foo(foo) {\n+    foo\n+}\n+\n+pub struct X {\n+    foo();\n+}\n+\n+pub Z {\n+    x->foo(),\n+}\n+\n+fn main(){}"}, {"sha": "23ac4eca2b42f1681cf5c03a0b272ffc2b2a9a09", "filename": "src/test/ui/suggestions/pub-ident-missing-kw.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c0387e36a1dab95492de61a2f26262a4526c286/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpub-ident-missing-kw.stderr?ref=7c0387e36a1dab95492de61a2f26262a4526c286", "patch": "@@ -0,0 +1,69 @@\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-missing-kw.rs:11:4\n+   |\n+11 | pub Struct {\n+   |    ^\n+   |\n+help: add `struct` here to parse `Struct` as a public struct\n+   |\n+11 | pub struct Struct {\n+   |     ^^^^^^\n+\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-missing-kw.rs:15:4\n+   |\n+15 | pub Y {\n+   |    ^\n+   |\n+help: add `struct` here to parse `Y` as a public struct\n+   |\n+15 | pub struct Y {\n+   |     ^^^^^^\n+\n+error: expected `:`, found `(`\n+  --> $DIR/pub-ident-missing-kw.rs:20:8\n+   |\n+20 |     foo();\n+   |        ^\n+\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-missing-kw.rs:23:4\n+   |\n+23 | pub Z {\n+   |    ^\n+   |\n+help: add `struct` here to parse `Z` as a public struct\n+   |\n+23 | pub struct Z {\n+   |     ^^^^^^\n+\n+error: missing `fn` for fn definition\n+  --> $DIR/pub-ident-missing-kw.rs:27:4\n+   |\n+27 | pub foo(foo) {\n+   |    ^\n+   |\n+help: add `fn` here to parse `foo` as a public fn\n+   |\n+27 | pub fn foo(foo) {\n+   |     ^^\n+\n+error: expected `:`, found `(`\n+  --> $DIR/pub-ident-missing-kw.rs:32:8\n+   |\n+32 |     foo();\n+   |        ^\n+\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-missing-kw.rs:35:4\n+   |\n+35 | pub Z {\n+   |    ^\n+   |\n+help: add `struct` here to parse `Z` as a public struct\n+   |\n+35 | pub struct Z {\n+   |     ^^^^^^\n+\n+error: aborting due to 7 previous errors\n+"}]}