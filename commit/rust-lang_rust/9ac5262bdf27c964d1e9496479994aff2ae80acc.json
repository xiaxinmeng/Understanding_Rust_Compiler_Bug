{"sha": "9ac5262bdf27c964d1e9496479994aff2ae80acc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYzUyNjJiZGYyN2M5NjRkMWU5NDk2NDc5OTk0YWZmMmFlODBhY2M=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-19T05:25:44Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-25T15:27:01Z"}, "message": "libsyntax: convert visit to pass ty_params by reference", "tree": {"sha": "0daddb3ce5a23947598d6882743a34d402a07457", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0daddb3ce5a23947598d6882743a34d402a07457"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ac5262bdf27c964d1e9496479994aff2ae80acc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ac5262bdf27c964d1e9496479994aff2ae80acc", "html_url": "https://github.com/rust-lang/rust/commit/9ac5262bdf27c964d1e9496479994aff2ae80acc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ac5262bdf27c964d1e9496479994aff2ae80acc/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "297c6e11bb362901b5a511057497a80eb255d2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/297c6e11bb362901b5a511057497a80eb255d2b4", "html_url": "https://github.com/rust-lang/rust/commit/297c6e11bb362901b5a511057497a80eb255d2b4"}], "stats": {"total": 638, "additions": 354, "deletions": 284}, "files": [{"sha": "0c043dac2167f33c051ab34c02ae5717bf2616f4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -579,7 +579,7 @@ impl CheckLoanCtxt {\n     }\n }\n \n-fn check_loans_in_fn(fk: visit::fn_kind,\n+fn check_loans_in_fn(fk: &visit::fn_kind,\n                      decl: ast::fn_decl,\n                      body: ast::blk,\n                      sp: span,\n@@ -590,7 +590,7 @@ fn check_loans_in_fn(fk: visit::fn_kind,\n     let fty = ty::node_id_to_type(self.tcx(), id);\n \n     let declared_purity;\n-    match fk {\n+    match *fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n             declared_purity = ty::ty_fn_purity(fty);\n@@ -611,7 +611,7 @@ fn check_loans_in_fn(fk: visit::fn_kind,\n         do save_and_restore_managed(self.fn_args) {\n             *self.declared_purity = declared_purity;\n \n-            match fk {\n+            match *fk {\n                 visit::fk_anon(*) |\n                 visit::fk_fn_block(*) if is_stack_closure => {\n                     // inherits the fn_args from enclosing ctxt"}, {"sha": "1b9c935cf7501c5e6408d4f9390d5717d51934be", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -95,7 +95,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n     return glcx.req_maps;\n }\n \n-fn req_loans_in_fn(fk: visit::fn_kind,\n+fn req_loans_in_fn(fk: &visit::fn_kind,\n                    decl: ast::fn_decl,\n                    body: ast::blk,\n                    sp: span,\n@@ -107,7 +107,7 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n     let old_root_ub = self.root_ub;\n     self.root_ub = body.node.id;\n \n-    match fk {\n+    match *fk {\n         visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {"}, {"sha": "ce44ef9c071753f9461f756c7d5809b30e26c36e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -669,7 +669,7 @@ pub fn check_local(cx: @MatchCheckCtxt,\n }\n \n pub fn check_fn(cx: @MatchCheckCtxt,\n-                kind: visit::fn_kind,\n+                kind: &visit::fn_kind,\n                 decl: fn_decl,\n                 body: blk,\n                 sp: span,"}, {"sha": "81c4b1ae70c99308d292cd10665c5fd09902add8", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -100,7 +100,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = HashMap();\n \n-    let walk_fn = fn@(_fk: visit::fn_kind, _decl: ast::fn_decl,\n+    let walk_fn = fn@(_fk: &visit::fn_kind, _decl: ast::fn_decl,\n                       blk: ast::blk, _sp: span, nid: ast::node_id) {\n         let vars = collect_freevars(def_map, blk);\n         freevars.insert(nid, vars);"}, {"sha": "2d87f0419799c5ec8dbe4a5cc98daacc3ffe4ac4", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -153,7 +153,7 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: fn(check_fn)) {\n \n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n-fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n+fn check_fn(fk: &visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             fn_id: node_id, cx: Context, v: visit::vt<Context>) {\n \n     // Check kinds on free variables:"}, {"sha": "95be98be776807517a251e24dada6b45a982ee0e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -923,13 +923,13 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n-fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n+fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: ast::fn_decl,\n             _body: ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n \n     // don't complain about blocks, since they tend to get their modes\n     // specified from the outside\n-    match fk {\n+    match *fk {\n       visit::fk_fn_block(*) => { return; }\n       _ => {}\n     }"}, {"sha": "739882258b2d7d46fc2740ea57dfb35102eb5fd2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -435,7 +435,7 @@ impl IrMaps {\n     }\n }\n \n-fn visit_fn(fk: visit::fn_kind,\n+fn visit_fn(fk: &visit::fn_kind,\n             decl: fn_decl,\n             body: blk,\n             sp: span,\n@@ -465,7 +465,7 @@ fn visit_fn(fk: visit::fn_kind,\n     };\n \n     // Add `self`, whether explicit or implicit.\n-    match fk {\n+    match *fk {\n         fk_method(_, _, method) => {\n             match method.self_ty.node {\n                 sty_by_ref => {\n@@ -1639,7 +1639,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     }\n }\n \n-fn check_fn(_fk: visit::fn_kind, _decl: fn_decl,\n+fn check_fn(_fk: &visit::fn_kind, _decl: fn_decl,\n             _body: blk, _sp: span, _id: node_id,\n             &&_self: @Liveness, _v: vt<@Liveness>) {\n     // do not check contents of nested fns\n@@ -1653,7 +1653,7 @@ enum ReadKind {\n }\n \n impl @Liveness {\n-    fn check_ret(&self, id: node_id, sp: span, _fk: visit::fn_kind,\n+    fn check_ret(&self, id: node_id, sp: span, _fk: &visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the"}, {"sha": "7782a58356b307b5b3e50f60a3de481c2cfd2041", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -316,14 +316,14 @@ pub fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_item(item, new_cx, visitor);\n }\n \n-pub fn resolve_fn(fk: visit::fn_kind,\n+pub fn resolve_fn(fk: &visit::fn_kind,\n                   decl: ast::fn_decl,\n                   body: ast::blk,\n                   sp: span,\n                   id: ast::node_id,\n                   cx: ctxt,\n                   visitor: visit::vt<ctxt>) {\n-    let fn_cx = match fk {\n+    let fn_cx = match *fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n             // Top-level functions are a root scope.\n@@ -337,7 +337,7 @@ pub fn resolve_fn(fk: visit::fn_kind,\n     };\n \n     // Record the ID of `self`.\n-    match fk {\n+    match *fk {\n         visit::fk_method(_, _, method) => {\n             cx.region_map.insert(method.self_id, body.node.id);\n         }\n@@ -607,7 +607,7 @@ pub fn determine_rp_in_item(item: @ast::item,\n     }\n }\n \n-pub fn determine_rp_in_fn(fk: visit::fn_kind,\n+pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           decl: ast::fn_decl,\n                           body: ast::blk,\n                           _: span,"}, {"sha": "afcc0298a95d619c6cc139edafa2be7eb95251ef", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -1079,7 +1079,7 @@ pub impl Resolver {\n         let privacy = visibility_to_privacy(item.vis);\n \n         match /*bad*/copy item.node {\n-            item_mod(module_) => {\n+            item_mod(ref module_) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n@@ -3725,7 +3725,7 @@ pub impl Resolver {\n                                    visitor);\n             }\n \n-            item_mod(module_) => {\n+            item_mod(ref module_) => {\n                 do self.with_scope(Some(item.ident)) {\n                     self.resolve_module(module_, item.span, item.ident,\n                                         item.id, visitor);\n@@ -4098,7 +4098,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_module(@mut self,\n-                      module_: _mod,\n+                      module_: &_mod,\n                       span: span,\n                       _name: ident,\n                       id: node_id,"}, {"sha": "9723e2cda26b8176a63159b6a0f8f717f890645f", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -3008,8 +3008,12 @@ pub fn trans_crate(sess: session::Session,\n     let symbol_hasher = @hash::default_state();\n     let link_meta =\n         link::build_link_meta(sess, crate, output, symbol_hasher);\n-    let reachable = reachable::find_reachable(crate.node.module, emap2, tcx,\n-                                              maps.method_map);\n+    let reachable = reachable::find_reachable(\n+        &crate.node.module,\n+        emap2,\n+        tcx,\n+        maps.method_map\n+    );\n \n     // Append \".rc\" to crate name as LLVM module identifier.\n     //"}, {"sha": "b917021add224b1f3dd1892fed11de2d6d443e95", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -38,7 +38,7 @@ struct ctx {\n     rmap: map\n }\n \n-pub fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n+pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n                       tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n     let rmap = HashMap();\n     let cx = ctx {\n@@ -85,10 +85,10 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     }\n }\n \n-fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n+fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n-        for vec::each(m.items) |item| {\n+        for m.items.each |item| {\n             traverse_public_item(cx, *item);\n         }\n     }\n@@ -98,10 +98,10 @@ fn traverse_public_item(cx: ctx, item: @item) {\n     if cx.rmap.contains_key(&item.id) { return; }\n     cx.rmap.insert(item.id, ());\n     match /*bad*/copy item.node {\n-      item_mod(m) => traverse_public_mod(cx, item.id, m),\n+      item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(nm) => {\n           if !traverse_exports(cx, item.id) {\n-              for vec::each(nm.items) |item| {\n+              for nm.items.each |item| {\n                   cx.rmap.insert(item.id, ());\n               }\n           }\n@@ -224,9 +224,12 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     }));\n }\n \n-fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n+fn traverse_all_resources_and_impls(cx: ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n-        crate_mod, codemap::dummy_sp(), 0, cx,\n+        crate_mod,\n+        codemap::dummy_sp(),\n+        0,\n+        cx,\n         visit::mk_vt(@visit::Visitor {\n             visit_expr: |_e, _cx, _v| { },\n             visit_item: |i, cx, v| {"}, {"sha": "9d14030d2617a6a8bdb76be3bb9b66562515dfe9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -469,7 +469,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Don't descend into fns and items\n-        fn visit_fn(_fk: visit::fn_kind, _decl: ast::fn_decl,\n+        fn visit_fn(_fk: &visit::fn_kind, _decl: ast::fn_decl,\n                     _body: ast::blk, _sp: span,\n                     _id: ast::node_id, &&_t: (), _v: visit::vt<()>) {\n         }"}, {"sha": "96cee422630220d821217c3ccdbd8e34fbed453c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -628,7 +628,7 @@ pub impl CoherenceChecker {\n         visit_crate(*crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n                 match /*bad*/copy item.node {\n-                    item_mod(module_) => {\n+                    item_mod(ref module_) => {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n                     }"}, {"sha": "8386f3c0498c30e9d249a480d7e3a7c46030c165", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 92, "deletions": 70, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -118,7 +118,7 @@ pub struct Ctx {\n pub type vt = visit::vt<@mut Ctx>;\n \n pub fn extend(cx: @mut Ctx, +elt: ident) -> @path {\n-    @(vec::append(cx.path, ~[path_name(elt)]))\n+    @(vec::append(copy cx.path, ~[path_name(elt)]))\n }\n \n pub fn mk_ast_map_visitor() -> vt {\n@@ -160,7 +160,7 @@ pub fn map_decoded_item(diag: span_handler,\n     // variables that are simultaneously in scope).\n     let cx = @mut Ctx {\n         map: @map,\n-        path: path,\n+        path: copy path,\n         local_id: 0,\n         diag: diag,\n     };\n@@ -173,46 +173,56 @@ pub fn map_decoded_item(diag: span_handler,\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n-                                             @path));\n+                                              @/*bad*/ copy path));\n       }\n       ii_method(impl_did, m) => {\n-        map_method(impl_did, @path, m, cx);\n+        map_method(impl_did, @/*bad*/ copy path, m, cx);\n       }\n     }\n \n     // visit the item / method contents and add those to the map:\n     ii.accept(cx, v);\n }\n \n-pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-              sp: codemap::span, id: node_id, &&cx: @mut Ctx, v: vt) {\n+pub fn map_fn(\n+    fk: &visit::fn_kind,\n+    decl: fn_decl,\n+    body: blk,\n+    sp: codemap::span,\n+    id: node_id,\n+    &&cx: @mut Ctx,\n+    v: visit::vt<@mut Ctx>\n+) {\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id,\n-                      node_arg(/* FIXME (#2543) */\n-                          copy *a, cx.local_id));\n+                      node_arg(/* FIXME (#2543) */ copy *a, cx.local_id));\n         cx.local_id += 1u;\n     }\n-    match fk {\n-        visit::fk_dtor(ref tps, ref attrs, self_id, parent_id) => {\n+    match *fk {\n+        visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n             let dt = @spanned {\n                 node: ast::struct_dtor_ {\n                     id: id,\n-                    attrs: (*attrs),\n+                    attrs: /* FIXME (#2543) */ vec::from_slice(*attrs),\n                     self_id: self_id,\n                     body: /* FIXME (#2543) */ copy body,\n                 },\n                 span: sp,\n             };\n-            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy *tps, dt,\n-                                        parent_id,\n-                                        @/* FIXME (#2543) */ copy cx.path));\n+            cx.map.insert(\n+                id,\n+                node_dtor(\n+                    /* FIXME (#2543) */ vec::from_slice(tps),\n+                    dt,\n+                    parent_id,\n+                    @/* FIXME (#2543) */ copy cx.path));\n       }\n       _ => ()\n     }\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-pub fn map_block(b: blk, &&cx: @mut Ctx, v: vt) {\n+pub fn map_block(b: blk, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n     visit::visit_block(b, cx, v);\n }\n@@ -229,12 +239,12 @@ pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n     };\n }\n \n-pub fn map_local(loc: @local, &&cx: @mut Ctx, v: vt) {\n+pub fn map_local(loc: @local, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n-pub fn map_arm(arm: arm, &&cx: @mut Ctx, v: vt) {\n+pub fn map_arm(arm: arm, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n@@ -246,70 +256,82 @@ pub fn map_method(impl_did: def_id, impl_path: @path,\n     cx.local_id += 1u;\n }\n \n-pub fn map_item(i: @item, &&cx: @mut Ctx, v: vt) {\n+pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n-      item_impl(_, _, _, ms) => {\n-        let impl_did = ast_util::local_def(i.id);\n-        for ms.each |m| {\n-            map_method(impl_did, extend(cx, i.ident), *m, cx);\n+        item_impl(_, _, _, ref ms) => {\n+            let impl_did = ast_util::local_def(i.id);\n+            for ms.each |m| {\n+                map_method(impl_did, extend(cx, i.ident), *m, cx);\n+            }\n         }\n-      }\n-      item_enum(ref enum_definition, _) => {\n-        for (*enum_definition).variants.each |v| {\n-            cx.map.insert(v.node.id, node_variant(\n-                /* FIXME (#2543) */ copy *v, i,\n-                extend(cx, i.ident)));\n+        item_enum(ref enum_definition, _) => {\n+            for (*enum_definition).variants.each |v| {\n+                cx.map.insert(v.node.id, node_variant(\n+                    /* FIXME (#2543) */ copy *v, i,\n+                    extend(cx, i.ident)));\n+            }\n         }\n-      }\n-      item_foreign_mod(nm) => {\n-        let abi = match attr::foreign_abi(i.attrs) {\n-          either::Left(ref msg) => cx.diag.span_fatal(i.span, (*msg)),\n-          either::Right(abi) => abi\n-        };\n-        for nm.items.each |nitem| {\n-            cx.map.insert(nitem.id,\n-                          node_foreign_item(*nitem, abi,\n-                                           /* FIXME (#2543) */\n-                                            if nm.sort == ast::named {\n-                                                extend(cx, i.ident)\n-                                            }\n-                                            else {\n-                                                /* Anonymous extern mods go\n-                                                in the parent scope */\n-                                                @copy cx.path\n-                                            }));\n+        item_foreign_mod(ref nm) => {\n+            let abi = match attr::foreign_abi(i.attrs) {\n+                Left(ref msg) => cx.diag.span_fatal(i.span, (*msg)),\n+                Right(abi) => abi\n+            };\n+            for nm.items.each |nitem| {\n+                cx.map.insert(nitem.id,\n+                    node_foreign_item(\n+                        *nitem,\n+                        abi,\n+                        // FIXME (#2543)\n+                        if nm.sort == ast::named {\n+                            extend(cx, i.ident)\n+                        } else {\n+                            // Anonymous extern mods go in the parent scope\n+                            @copy cx.path\n+                        }\n+                    )\n+                );\n+            }\n         }\n-      }\n-      item_struct(struct_def, _) => {\n-        map_struct_def(struct_def, node_item(i, item_path), i.ident, cx,\n-                       v);\n-      }\n-      item_trait(_, ref traits, ref methods) => {\n-        for traits.each |p| {\n-            cx.map.insert(p.ref_id, node_item(i, item_path));\n+        item_struct(struct_def, _) => {\n+            map_struct_def(\n+                struct_def,\n+                node_item(i, item_path),\n+                i.ident,\n+                cx,\n+                v\n+            );\n         }\n-        for (*methods).each |tm| {\n-            let id = ast_util::trait_method_to_ty_method(*tm).id;\n-            let d_id = ast_util::local_def(i.id);\n-            cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n+        item_trait(_, ref traits, ref methods) => {\n+            for traits.each |p| {\n+                cx.map.insert(p.ref_id, node_item(i, item_path));\n+            }\n+            for methods.each |tm| {\n+                let id = ast_util::trait_method_to_ty_method(*tm).id;\n+                let d_id = ast_util::local_def(i.id);\n+                cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n+            }\n         }\n-      }\n-      _ => ()\n+        _ => ()\n     }\n     match i.node {\n-      item_mod(_) | item_foreign_mod(_) => {\n-        cx.path.push(path_mod(i.ident));\n-      }\n-      _ => cx.path.push(path_name(i.ident))\n+        item_mod(_) | item_foreign_mod(_) => {\n+            cx.path.push(path_mod(i.ident));\n+        }\n+        _ => cx.path.push(path_name(i.ident))\n     }\n     visit::visit_item(i, cx, v);\n     cx.path.pop();\n }\n \n-pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n-                      ident: ast::ident, cx: @mut Ctx, _v: vt) {\n+pub fn map_struct_def(\n+    struct_def: @ast::struct_def,\n+    parent_node: ast_node,\n+    ident: ast::ident,\n+    cx: @mut Ctx,\n+    _v: visit::vt<@mut Ctx>\n+) {\n     let p = extend(cx, ident);\n     // If this is a tuple-like struct, register the constructor.\n     match struct_def.ctor_id {\n@@ -326,12 +348,12 @@ pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n }\n \n-pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: vt) {\n+pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n }\n \n-pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: vt) {\n+pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(stmt_id(*stmt), node_stmt(stmt));\n     visit::visit_stmt(stmt, cx, v);\n }\n@@ -400,8 +422,8 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n }\n \n pub fn node_item_query<Result>(items: map, id: node_id,\n-                           query: fn(@item) -> Result,\n-                           error_msg: ~str) -> Result {\n+                               query: fn(@item) -> Result,\n+                               +error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(node_item(it, _)) => query(it),\n         _ => fail!(error_msg)"}, {"sha": "3830c81f084177778425b55f1eb0f0cd707ee069", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -263,13 +263,13 @@ pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     match method {\n         required(ref m) => (*m),\n-        provided(m) => {\n+        provided(ref m) => {\n             ty_method {\n                 ident: m.ident,\n-                attrs: m.attrs,\n+                attrs: copy m.attrs,\n                 purity: m.purity,\n-                decl: m.decl,\n-                tps: m.tps,\n+                decl: copy m.decl,\n+                tps: copy m.tps,\n                 self_ty: m.self_ty,\n                 id: m.id,\n                 span: m.span,\n@@ -396,8 +396,8 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_view_item: fn@(vi: @view_item) {\n             match vi.node {\n               view_item_extern_mod(_, _, id) => vfn(id),\n-              view_item_use(vps) => {\n-                  for vec::each(vps) |vp| {\n+              view_item_use(ref vps) => {\n+                  for vps.each |vp| {\n                       match vp.node {\n                           view_path_simple(_, _, _, id) => vfn(id),\n                           view_path_glob(_, id) => vfn(id),\n@@ -457,29 +457,29 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_ty_params: fn@(ps: ~[ty_param]) {\n-            for vec::each(ps) |p| {\n+        visit_ty_params: fn@(ps: &[ty_param]) {\n+            for ps.each |p| {\n                 vfn(p.id);\n             }\n         },\n \n-        visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n+        visit_fn: fn@(fk: &visit::fn_kind, d: ast::fn_decl,\n                       _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n-            match fk {\n-                visit::fk_dtor(tps, _, self_id, parent_id) => {\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n+            match *fk {\n+                visit::fk_dtor(ref tps, _, self_id, parent_id) => {\n+                    for tps.each |tp| { vfn(tp.id); }\n                     vfn(id);\n                     vfn(self_id);\n                     vfn(parent_id.node);\n                 }\n-                visit::fk_item_fn(_, tps, _) => {\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                visit::fk_item_fn(_, ref tps, _) => {\n+                    for tps.each |tp| { vfn(tp.id); }\n                 }\n-                visit::fk_method(_, tps, m) => {\n+                visit::fk_method(_, ref tps, m) => {\n                     vfn(m.self_id);\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                    for tps.each |tp| { vfn(tp.id); }\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n@@ -497,7 +497,7 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_trait_method: fn@(_ty_m: trait_method) {\n         },\n \n-        visit_struct_def: fn@(_sd: @struct_def, _id: ident, _tps: ~[ty_param],\n+        visit_struct_def: fn@(_sd: @struct_def, _id: ident, _tps: &[ty_param],\n                               _id: node_id) {\n         },\n \n@@ -539,30 +539,29 @@ pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n-        pat_rec(fields, _) | pat_struct(_, fields, _) => {\n+        pat_rec(ref fields, _) | pat_struct(_, ref fields, _) => {\n             for fields.each |f| {\n                 walk_pat(f.pat, it)\n             }\n         }\n-        pat_enum(_, Some(s)) | pat_tup(s) => {\n+        pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n             for s.each |p| {\n                 walk_pat(*p, it)\n             }\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n-        pat_vec(elts, tail) => {\n+        pat_vec(ref elts, ref tail) => {\n             for elts.each |p| {\n                 walk_pat(*p, it)\n             }\n-            do option::iter(&tail) |tail| {\n+            do tail.iter |tail| {\n                 walk_pat(*tail, it)\n             }\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n-        pat_enum(_, _) => {\n-        }\n+        pat_enum(_, _) => { }\n     }\n }\n "}, {"sha": "dad1c2a7feafe174b1f72bcd97002865a28b71c8", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -123,8 +123,8 @@ pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@~str> {\n pub fn get_meta_item_list(meta: @ast::meta_item)\n                        -> Option<~[@ast::meta_item]> {\n     match meta.node {\n-      ast::meta_list(_, l) => option::Some(/* FIXME (#2543) */ copy l),\n-      _ => option::None\n+        ast::meta_list(_, ref l) => Some(/* FIXME (#2543) */ copy *l),\n+        _ => None\n     }\n }\n "}, {"sha": "8d99c43d43d20e37e88c6edcc98a6590e89d6d1b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -46,7 +46,7 @@ pub struct SyntaxExpanderTT {\n }\n \n pub type SyntaxExpanderTTFun\n-    = fn@(ext_ctxt, span, ~[ast::token_tree]) -> MacResult;\n+    = fn@(ext_ctxt, span, &[ast::token_tree]) -> MacResult;\n \n pub struct SyntaxExpanderTTItem {\n     expander: SyntaxExpanderTTItemFun,\n@@ -333,11 +333,11 @@ pub fn get_single_str_from_tts(cx: ext_ctxt,\n     }\n }\n \n-pub fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n+pub fn get_exprs_from_tts(cx: ext_ctxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n-                                       tts);\n+                                       vec::from_slice(tts));\n     let mut es = ~[];\n     while *p.token != token::EOF {\n         if es.len() != 0 {"}, {"sha": "d4104c3a14af55cf9f4b6dac623b4f80e50e2ad7", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use ext::base::*;\n use ext::base;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for tts.eachi |i, e| {"}, {"sha": "f546c718393b6b71d13e77171326ec9c9cf28432", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -22,7 +22,7 @@ use ext::build::mk_uniq_str;\n use core::option;\n use core::os;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n \n     let var = get_single_str_from_tts(cx, sp, tts, \"env!\");"}, {"sha": "d15b228365ce5aa533cb81a0eeda37692eed1afd", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -25,9 +25,9 @@ use ext::base;\n use ext::build::*;\n use private::extfmt::ct::*;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n-    let args = get_exprs_from_tts(cx, copy tts);\n+    let args = get_exprs_from_tts(cx, tts);\n     if args.len() == 0 {\n         cx.span_fatal(sp, \"fmt! takes at least 1 argument.\");\n     }"}, {"sha": "a59e43b1c1a159422a80a69d64b354071bce3d3b", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -19,12 +19,14 @@ use core::option;\n \n pub fn expand_syntax_ext(cx: ext_ctxt,\n                          sp: codemap::span,\n-                         tt: ~[ast::token_tree])\n+                         tt: &[ast::token_tree])\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n     io::stdout().write_line(\n-        print::pprust::tt_to_str(ast::tt_delim(tt),cx.parse_sess().interner));\n+        print::pprust::tt_to_str(\n+            ast::tt_delim(vec::from_slice(tt)),\n+            cx.parse_sess().interner));\n \n     //trivial expression\n     MRExpr(@ast::expr {"}, {"sha": "6d1ab58444693707e983ff13dfca90ce4c321e79", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -219,43 +219,43 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: ext_ctxt,\n                            sp: span,\n-                           tts: ~[ast::token_tree]) -> base::MacResult {\n+                           tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_tts(cx, sp, tts))\n }\n \n pub fn expand_quote_expr(cx: ext_ctxt,\n                          sp: span,\n-                         tts: ~[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_expr\", ~[], tts))\n }\n \n pub fn expand_quote_item(cx: ext_ctxt,\n                          sp: span,\n-                         tts: ~[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n pub fn expand_quote_pat(cx: ext_ctxt,\n                         sp: span,\n-                        tts: ~[ast::token_tree]) -> base::MacResult {\n+                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n pub fn expand_quote_ty(cx: ext_ctxt,\n                        sp: span,\n-                       tts: ~[ast::token_tree]) -> base::MacResult {\n+                       tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n pub fn expand_quote_stmt(cx: ext_ctxt,\n                          sp: span,\n-                         tts: ~[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_stmt\",\n                                     ~[e_attrs], tts))\n@@ -506,15 +506,19 @@ fn mk_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n \n fn expand_tts(cx: ext_ctxt,\n               sp: span,\n-              tts: ~[ast::token_tree]) -> @ast::expr {\n+              tts: &[ast::token_tree]) -> @ast::expr {\n \n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n \n-    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts);\n+    let p = parse::new_parser_from_tts(\n+        cx.parse_sess(),\n+        cx.cfg(),\n+        vec::from_slice(tts)\n+    );\n     *p.quote_depth += 1u;\n     let tts = p.parse_all_token_trees();\n     p.abort_if_errors();\n@@ -578,7 +582,7 @@ fn expand_parse_call(cx: ext_ctxt,\n                      sp: span,\n                      parse_method: ~str,\n                      arg_exprs: ~[@ast::expr],\n-                     tts: ~[ast::token_tree]) -> @ast::expr {\n+                     tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n     let cfg_call = || build::mk_call_("}, {"sha": "c4049b796c5502311c299d4a3c6e4408458c1e97", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -54,7 +54,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n }\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_line(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -65,7 +65,7 @@ pub fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_col(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -77,7 +77,7 @@ pub fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_file(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -87,21 +87,21 @@ pub fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_stringify(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n     base::MRExpr(mk_base_str(cx, sp, s))\n }\n \n-pub fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_mod(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(mk_base_str(cx, sp,\n                               str::connect(cx.mod_path().map(\n                                   |x| cx.str_of(*x)), ~\"::\")))\n }\n \n-pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -110,7 +110,7 @@ pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(p.parse_expr())\n }\n \n-pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -124,7 +124,7 @@ pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n }\n \n-pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {"}, {"sha": "842727f092a296e977e0a7582bac21e28a839ec3", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+\n use ast::tt_delim;\n use ast;\n use codemap::span;\n@@ -16,14 +18,16 @@ use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n \n-use core::option::None;\n-\n pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n-                           tt: ~[ast::token_tree]) -> base::MacResult {\n+                           tt: &[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, None, tt);\n+    let tt_rdr = new_tt_reader(\n+        copy cx.parse_sess().span_diagnostic,\n+        cx.parse_sess().interner,\n+        None,\n+        vec::from_slice(tt)\n+    );\n     let rdr = tt_rdr as reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());\n "}, {"sha": "cfb6e45cb5bb9f817d7670e2780f09a6ed7efa41", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -71,15 +71,15 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n     fn generic_extension(cx: ext_ctxt, sp: span, name: ident,\n-                         arg: ~[ast::token_tree],\n+                         arg: &[ast::token_tree],\n                          lhses: ~[@named_match], rhses: ~[@named_match])\n     -> MacResult {\n \n         if cx.trace_macros() {\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 ast::tt_delim(arg),\n+                                 ast::tt_delim(vec::from_slice(arg)),\n                                  cx.parse_sess().interner)));\n         }\n \n@@ -94,7 +94,12 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating\n-                let arg_rdr = new_tt_reader(s_d, itr, None, arg) as reader;\n+                let arg_rdr = new_tt_reader(\n+                    s_d,\n+                    itr,\n+                    None,\n+                    vec::from_slice(arg)\n+                ) as reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, (*mtcs)) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n@@ -136,7 +141,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(ext_ctxt, span, ~[ast::token_tree]) -> MacResult =\n+    let exp: @fn(ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, lhses, rhses);\n \n     return MRDef(MacroDef{"}, {"sha": "d79a2bbf174698e5138c7092be556aaa873d7f28", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 149, "deletions": 122, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5262bdf27c964d1e9496479994aff2ae80acc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9ac5262bdf27c964d1e9496479994aff2ae80acc", "patch": "@@ -30,17 +30,21 @@ use core::vec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind {\n-    fk_item_fn(ident, ~[ty_param], purity), // fn foo()\n-    fk_method(ident, ~[ty_param], @method), // fn foo(&self)\n+    fk_item_fn(ident, &[ty_param], purity), // fn foo()\n+    fk_method(ident, &[ty_param], &method), // fn foo(&self)\n     fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n     fk_fn_block,                            // |x, y| ...\n-    fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n-            def_id /* parent class id */) // class destructor\n+    fk_dtor( // class destructor\n+        &[ty_param],\n+        &[attribute],\n+        node_id /* self id */,\n+        def_id /* parent class id */\n+    )\n \n }\n \n-pub fn name_of_fn(fk: fn_kind) -> ident {\n-    match fk {\n+pub fn name_of_fn(fk: &fn_kind) -> ident {\n+    match *fk {\n       fk_item_fn(name, _, _) | fk_method(name, _, _) => {\n           /* FIXME (#2543) */ copy name\n       }\n@@ -49,18 +53,16 @@ pub fn name_of_fn(fk: fn_kind) -> ident {\n     }\n }\n \n-pub fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n-    match fk {\n+pub fn tps_of_fn(fk: &fn_kind) -> ~[ty_param] {\n+    match *fk {\n         fk_item_fn(_, tps, _) | fk_method(_, tps, _) |\n-        fk_dtor(tps, _, _, _) => {\n-            /* FIXME (#2543) */ copy tps\n-        }\n+        fk_dtor(tps, _, _, _) => /* FIXME (#2543) */ vec::from_slice(tps),\n         fk_anon(*) | fk_fn_block(*) => ~[]\n     }\n }\n \n pub struct Visitor<E> {\n-    visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n+    visit_mod: fn@(&_mod, span, node_id, E, vt<E>),\n     visit_view_item: fn@(@view_item, E, vt<E>),\n     visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n     visit_item: fn@(@item, E, vt<E>),\n@@ -73,11 +75,11 @@ pub struct Visitor<E> {\n     visit_expr: fn@(@expr, E, vt<E>),\n     visit_expr_post: fn@(@expr, E, vt<E>),\n     visit_ty: fn@(@Ty, E, vt<E>),\n-    visit_ty_params: fn@(~[ty_param], E, vt<E>),\n-    visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n+    visit_ty_params: fn@(&[ty_param], E, vt<E>),\n+    visit_fn: fn@(&fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n     visit_ty_method: fn@(ty_method, E, vt<E>),\n     visit_trait_method: fn@(trait_method, E, vt<E>),\n-    visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id, E,\n+    visit_struct_def: fn@(@struct_def, ident, &[ty_param], node_id, E,\n                           vt<E>),\n     visit_struct_field: fn@(@struct_field, E, vt<E>),\n     visit_struct_method: fn@(@method, E, vt<E>)\n@@ -112,10 +114,10 @@ pub fn default_visitor<E>() -> visitor<E> {\n }\n \n pub fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n-    (v.visit_mod)(c.node.module, c.span, crate_node_id, e, v);\n+    (v.visit_mod)(&c.node.module, c.span, crate_node_id, e, v);\n }\n \n-pub fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_mod<E>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n     for m.items.each |i| { (v.visit_item)(*i, e, v); }\n }\n@@ -133,65 +135,65 @@ pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n \n pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n-      item_const(t, ex) => {\n-        (v.visit_ty)(t, e, v);\n-        (v.visit_expr)(ex, e, v);\n-      }\n-      item_fn(ref decl, purity, ref tp, ref body) => {\n-        (v.visit_fn)(\n-            fk_item_fn(\n-                /* FIXME (#2543) */ copy i.ident,\n-                /* FIXME (#2543) */ copy *tp,\n-                purity\n-            ),\n-            /* FIXME (#2543) */ copy *decl,\n-            (*body),\n-            i.span,\n-            i.id,\n-            e,\n-            v\n-        );\n-      }\n-      item_mod(m) => (v.visit_mod)(m, i.span, i.id, e, v),\n-      item_foreign_mod(nm) => {\n-        for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n-        for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n-      }\n-      item_ty(t, tps) => {\n-        (v.visit_ty)(t, e, v);\n-        (v.visit_ty_params)(tps, e, v);\n-      }\n-      item_enum(ref enum_definition, ref tps) => {\n-        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n-        visit_enum_def(\n-            *enum_definition,\n-            /* FIXME (#2543) */ copy *tps,\n-            e,\n-            v\n-        );\n-      }\n-      item_impl(tps, traits, ty, methods) => {\n-        (v.visit_ty_params)(tps, e, v);\n-        for traits.each |p| {\n-            visit_path(p.path, e, v);\n+        item_const(t, ex) => {\n+            (v.visit_ty)(t, e, v);\n+            (v.visit_expr)(ex, e, v);\n         }\n-        (v.visit_ty)(ty, e, v);\n-        for methods.each |m| {\n-            visit_method_helper(*m, e, v)\n+        item_fn(ref decl, purity, ref tps, ref body) => {\n+            (v.visit_fn)(\n+                &fk_item_fn(\n+                    /* FIXME (#2543) */ copy i.ident,\n+                    *tps,\n+                    purity\n+                ),\n+                /* FIXME (#2543) */ copy *decl,\n+                *body,\n+                i.span,\n+                i.id,\n+                e,\n+                v\n+            );\n         }\n-      }\n-      item_struct(struct_def, tps) => {\n-        (v.visit_ty_params)(tps, e, v);\n-        (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n-      }\n-      item_trait(ref tps, ref traits, ref methods) => {\n-        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n-        for traits.each |p| { visit_path(p.path, e, v); }\n-        for (*methods).each |m| {\n-            (v.visit_trait_method)(*m, e, v);\n+        item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, e, v),\n+        item_foreign_mod(ref nm) => {\n+            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n+            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n         }\n-      }\n-      item_mac(ref m) => visit_mac((*m), e, v)\n+        item_ty(t, ref tps) => {\n+            (v.visit_ty)(t, e, v);\n+            (v.visit_ty_params)(*tps, e, v);\n+        }\n+        item_enum(ref enum_definition, ref tps) => {\n+            (v.visit_ty_params)(*tps, e, v);\n+            visit_enum_def(\n+                *enum_definition,\n+                /* FIXME (#2543) */ copy *tps,\n+                e,\n+                v\n+            );\n+        }\n+        item_impl(ref tps, ref traits, ty, ref methods) => {\n+            (v.visit_ty_params)(*tps, e, v);\n+            for traits.each |p| {\n+                visit_path(p.path, e, v);\n+            }\n+            (v.visit_ty)(ty, e, v);\n+            for methods.each |m| {\n+                visit_method_helper(*m, e, v)\n+            }\n+        }\n+        item_struct(struct_def, ref tps) => {\n+            (v.visit_ty_params)(*tps, e, v);\n+            (v.visit_struct_def)(struct_def, i.ident, *tps, i.id, e, v);\n+        }\n+        item_trait(ref tps, ref traits, ref methods) => {\n+            (v.visit_ty_params)(*tps, e, v);\n+            for traits.each |p| { visit_path(p.path, e, v); }\n+            for (*methods).each |m| {\n+                (v.visit_trait_method)(*m, e, v);\n+            }\n+        }\n+        item_mac(ref m) => visit_mac((*m), e, v)\n     }\n }\n \n@@ -296,13 +298,13 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n \n pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n-      foreign_item_fn(fd, _, tps) => {\n-        (v.visit_ty_params)(tps, e, v);\n-        visit_fn_decl(fd, e, v);\n-      }\n-      foreign_item_const(t) => {\n-        (v.visit_ty)(t, e, v);\n-      }\n+        foreign_item_fn(fd, _, ref tps) => {\n+            (v.visit_ty_params)(*tps, e, v);\n+            visit_fn_decl(fd, e, v);\n+        }\n+        foreign_item_const(t) => {\n+            (v.visit_ty)(t, e, v);\n+        }\n     }\n }\n \n@@ -315,7 +317,7 @@ pub fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n+pub fn visit_ty_params<E>(tps: &[ty_param], e: E, v: vt<E>) {\n     for tps.each |tp| {\n         visit_ty_param_bounds(tp.bounds, e, v);\n     }\n@@ -333,21 +335,42 @@ pub fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    (v.visit_fn)(fk_method(/* FIXME (#2543) */ copy m.ident,\n-                         /* FIXME (#2543) */ copy m.tps, m),\n-               m.decl, m.body, m.span, m.id, e, v);\n-}\n-\n-pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: ~[ty_param],\n+pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n+    (v.visit_fn)(\n+        &fk_method(\n+            /* FIXME (#2543) */ copy m.ident,\n+            m.tps,\n+            m\n+        ),\n+        m.decl,\n+        m.body,\n+        m.span,\n+        m.id,\n+        e,\n+        v\n+    );\n+}\n+\n+pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: &[ty_param],\n                                    parent_id: def_id, e: E, v: vt<E>) {\n-    (v.visit_fn)(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n-                       dtor.node.self_id, parent_id), ast_util::dtor_dec(),\n-               dtor.node.body, dtor.span, dtor.node.id, e, v)\n-\n-}\n-\n-pub fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n+    (v.visit_fn)(\n+        &fk_dtor(\n+            tps,\n+            dtor.node.attrs,\n+            dtor.node.self_id,\n+            parent_id\n+        ),\n+        ast_util::dtor_dec(),\n+        dtor.node.body,\n+        dtor.span,\n+        dtor.node.id,\n+        e,\n+        v\n+    )\n+\n+}\n+\n+pub fn visit_fn<E>(fk: &fn_kind, decl: fn_decl, body: blk, _sp: span,\n                    _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n     (v.visit_ty_params)(tps_of_fn(fk), e, v);\n@@ -367,13 +390,13 @@ pub fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n+pub fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: &[ty_param],\n                            id: node_id, e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n-    do option::iter(&sd.dtor) |dtor| {\n-      visit_struct_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n+    do sd.dtor.iter |dtor| {\n+        visit_struct_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n     };\n }\n \n@@ -476,7 +499,7 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_fn(proto, ref decl, ref body, _) => {\n         (v.visit_fn)(\n-            fk_anon(proto),\n+            &fk_anon(proto),\n             /* FIXME (#2543) */ copy *decl,\n             *body,\n             ex.span,\n@@ -487,7 +510,7 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_fn_block(ref decl, ref body) => {\n         (v.visit_fn)(\n-            fk_fn_block,\n+            &fk_fn_block,\n             /* FIXME (#2543) */ copy *decl,\n             *body,\n             ex.span,\n@@ -539,7 +562,7 @@ pub fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n // calls the given functions on the nodes.\n \n pub struct SimpleVisitor {\n-    visit_mod: fn@(_mod, span, node_id),\n+    visit_mod: fn@(&_mod, span, node_id),\n     visit_view_item: fn@(@view_item),\n     visit_foreign_item: fn@(@foreign_item),\n     visit_item: fn@(@item),\n@@ -552,11 +575,11 @@ pub struct SimpleVisitor {\n     visit_expr: fn@(@expr),\n     visit_expr_post: fn@(@expr),\n     visit_ty: fn@(@Ty),\n-    visit_ty_params: fn@(~[ty_param]),\n-    visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n+    visit_ty_params: fn@(&[ty_param]),\n+    visit_fn: fn@(&fn_kind, fn_decl, blk, span, node_id),\n     visit_ty_method: fn@(ty_method),\n     visit_trait_method: fn@(trait_method),\n-    visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id),\n+    visit_struct_def: fn@(@struct_def, ident, &[ty_param], node_id),\n     visit_struct_field: fn@(@struct_field),\n     visit_struct_method: fn@(@method)\n }\n@@ -580,21 +603,27 @@ pub fn default_simple_visitor() -> @SimpleVisitor {\n         visit_expr: |_e| { },\n         visit_expr_post: |_e| { },\n         visit_ty: simple_ignore_ty,\n-        visit_ty_params: fn@(_ps: ~[ty_param]) { },\n-        visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n+        visit_ty_params: fn@(_ps: &[ty_param]) { },\n+        visit_fn: fn@(_fk: &fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                       _id: node_id) { },\n         visit_ty_method: fn@(_m: ty_method) { },\n         visit_trait_method: fn@(_m: trait_method) { },\n         visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n-                              _tps: ~[ty_param], _id: node_id) { },\n+                              _tps: &[ty_param], _id: node_id) { },\n         visit_struct_field: fn@(_f: @struct_field) { },\n         visit_struct_method: fn@(_m: @method) { }\n     }\n }\n \n pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n-    fn v_mod(f: fn@(_mod, span, node_id), m: _mod, sp: span, id: node_id,\n-             &&e: (), v: vt<()>) {\n+    fn v_mod(\n+        f: fn@(&_mod, span, node_id),\n+        m: &_mod,\n+        sp: span,\n+        id: node_id,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(m, sp, id);\n         visit_mod(m, sp, id, e, v);\n     }\n@@ -655,20 +684,21 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(m);\n         visit_trait_method(m, e, v);\n     }\n-    fn v_struct_def(f: fn@(@struct_def, ident, ~[ty_param], node_id),\n-                    sd: @struct_def, nm: ident, tps: ~[ty_param], id: node_id,\n+    fn v_struct_def(f: fn@(@struct_def, ident, &[ty_param], node_id),\n+                    sd: @struct_def, nm: ident, tps: &[ty_param], id: node_id,\n                     &&e: (), v: vt<()>) {\n         f(sd, nm, tps, id);\n         visit_struct_def(sd, nm, tps, id, e, v);\n     }\n-    fn v_ty_params(f: fn@(~[ty_param]),\n-                   ps: ~[ty_param],\n-                   &&e: (), v: vt<()>) {\n+    fn v_ty_params(f: fn@(&[ty_param]),\n+                   ps: &[ty_param],\n+                   &&e: (),\n+                   v: vt<()>) {\n         f(ps);\n         visit_ty_params(ps, e, v);\n     }\n-    fn v_fn(f: fn@(fn_kind, fn_decl, blk, span, node_id),\n-            fk: fn_kind, decl: fn_decl, body: blk, sp: span,\n+    fn v_fn(f: fn@(&fn_kind, fn_decl, blk, span, node_id),\n+            fk: &fn_kind, decl: fn_decl, body: blk, sp: span,\n             id: node_id, &&e: (), v: vt<()>) {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, e, v);\n@@ -700,12 +730,9 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_expr_post: |a,b,c| v_expr_post(v.visit_expr_post,\n                                              a, b, c),\n         visit_ty: visit_ty,\n-        visit_ty_params: |a,b,c|\n-            v_ty_params(v.visit_ty_params, a, b, c),\n-        visit_fn: |a,b,c,d,e,f,g|\n-            v_fn(v.visit_fn, a, b, c, d, e, f, g),\n-        visit_ty_method: |a,b,c|\n-            v_ty_method(v.visit_ty_method, a, b, c),\n+        visit_ty_params: |a,b,c| v_ty_params(v.visit_ty_params, a, b, c),\n+        visit_fn: |a,b,c,d,e,f,g| v_fn(v.visit_fn, a, b, c, d, e, f, g),\n+        visit_ty_method: |a,b,c| v_ty_method(v.visit_ty_method, a, b, c),\n         visit_trait_method: |a,b,c|\n             v_trait_method(v.visit_trait_method, a, b, c),\n         visit_struct_def: |a,b,c,d,e,f|"}]}