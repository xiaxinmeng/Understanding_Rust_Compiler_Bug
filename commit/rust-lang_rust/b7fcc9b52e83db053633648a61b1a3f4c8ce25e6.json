{"sha": "b7fcc9b52e83db053633648a61b1a3f4c8ce25e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZmNjOWI1MmU4M2RiMDUzNjMzNjQ4YTYxYjFhM2Y0YzhjZTI1ZTY=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-11-17T12:41:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-29T20:09:10Z"}, "message": "Use `biased_match!` to avoid over-deep indentation in expand.rs.", "tree": {"sha": "9d1230412364a067e8fe85eb39acbc6610f213e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d1230412364a067e8fe85eb39acbc6610f213e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7fcc9b52e83db053633648a61b1a3f4c8ce25e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fcc9b52e83db053633648a61b1a3f4c8ce25e6", "html_url": "https://github.com/rust-lang/rust/commit/b7fcc9b52e83db053633648a61b1a3f4c8ce25e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7fcc9b52e83db053633648a61b1a3f4c8ce25e6/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf26a7d7b952cf94fb4bb185c2eb0cb47e4551ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf26a7d7b952cf94fb4bb185c2eb0cb47e4551ce", "html_url": "https://github.com/rust-lang/rust/commit/cf26a7d7b952cf94fb4bb185c2eb0cb47e4551ce"}], "stats": {"total": 166, "additions": 89, "deletions": 77}, "files": [{"sha": "f919c1f03c0d8c5c9dfb6dfa474fb3e96d39ddbe", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 89, "deletions": 77, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/b7fcc9b52e83db053633648a61b1a3f4c8ce25e6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fcc9b52e83db053633648a61b1a3f4c8ce25e6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b7fcc9b52e83db053633648a61b1a3f4c8ce25e6", "patch": "@@ -10,6 +10,7 @@ use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n \n use codemap::{span, ExpandedFrom};\n \n+\n fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                e: expr_, s: span, fld: ast_fold,\n                orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n@@ -191,113 +192,124 @@ fn expand_item(exts: HashMap<~str, syntax_extension>,\n     }\n }\n \n+// avoid excess indentation when a series of nested `match`es\n+// has only one \"good\" outcome\n+macro_rules! biased_match (\n+    (   ($e    :expr) ~ ($p    :pat) else $err    :stmt ;\n+     $( ($e_cdr:expr) ~ ($p_cdr:pat) else $err_cdr:stmt ; )*\n+     => $body:expr\n+    ) => (\n+        match $e {\n+            $p => {\n+                biased_match!($( ($e_cdr) ~ ($p_cdr) else $err_cdr ; )*\n+                              => $body)\n+            }\n+            _ => { $err }\n+        }\n+    );\n+    ( => $body:expr ) => ( $body )\n+)\n+\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> Option<@ast::item> {\n-    match it.node {\n-      item_mac({node: mac_invoc_tt(pth, tts), _}) => {\n-        let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-        let (expanded, ex_span) = match exts.find(*extname) {\n-          None => {\n-            cx.span_fatal(pth.span,\n-                          fmt!(\"macro undefined: '%s!'\", *extname))\n-          }\n-          Some(normal_tt(expand)) => {\n+    let (pth, tts) = biased_match!(\n+        (it.node) ~ (item_mac({node: mac_invoc_tt(pth, tts), _})) else {\n+            cx.span_bug(it.span, ~\"invalid item macro invocation\")\n+        };\n+        => (pth, tts)\n+    );\n+\n+    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n+    let (expanded, ex_span) = match exts.find(*extname) {\n+        None => cx.span_fatal(pth.span,\n+                              fmt!(\"macro undefined: '%s!'\", *extname)),\n+\n+        Some(normal_tt(expand)) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n                                     given '%s'\", *extname,\n                                    *cx.parse_sess().interner.get(it.ident)));\n             }\n             (expand.expander(cx, it.span, tts), expand.span)\n-          }\n-          Some(item_tt(expand)) => {\n+        }\n+        Some(item_tt(expand)) => {\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n                                    *extname));\n             }\n             (expand.expander(cx, it.span, it.ident, tts), expand.span)\n-          }\n-          _ => cx.span_fatal(\n-              it.span, fmt!(\"%s! is not legal in item position\", *extname))\n-        };\n+        }\n+        _ => cx.span_fatal(\n+            it.span, fmt!(\"%s! is not legal in item position\", *extname))\n+    };\n \n-        cx.bt_push(ExpandedFrom({call_site: it.span,\n-                                  callie: {name: *extname,\n-                                           span: ex_span}}));\n-        let maybe_it = match expanded {\n-            mr_item(it) => fld.fold_item(it),\n-            mr_expr(_) => cx.span_fatal(pth.span,\n-                                        ~\"expr macro in item position: \" +\n-                                        *extname),\n-            mr_any(_, item_maker, _) =>\n-                option::chain(item_maker(), |i| {fld.fold_item(i)}),\n-            mr_def(mdef) => {\n-                exts.insert(mdef.name, mdef.ext);\n-                None\n-            }\n-        };\n-        cx.bt_pop();\n-        return maybe_it;\n-      }\n-      _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n-    }\n+    cx.bt_push(ExpandedFrom({call_site: it.span,\n+                              callie: {name: *extname, span: ex_span}}));\n+    let maybe_it = match expanded {\n+        mr_item(it) => fld.fold_item(it),\n+        mr_expr(_) => cx.span_fatal(pth.span,\n+                                    ~\"expr macro in item position: \"\n+                                    + *extname),\n+        mr_any(_, item_maker, _) =>\n+            option::chain(item_maker(), |i| {fld.fold_item(i)}),\n+        mr_def(mdef) => {\n+            exts.insert(mdef.name, mdef.ext);\n+            None\n+        }\n+    };\n+    cx.bt_pop();\n+    return maybe_it;\n }\n \n fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                && s: stmt_, sp: span, fld: ast_fold,\n                orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n     -> (stmt_, span)\n {\n-    return match s {\n-        stmt_mac(mac) => {\n-            match mac.node {\n-                mac_invoc_tt(pth, tts) => {\n-                    assert(vec::len(pth.idents) == 1u);\n-                    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                    match exts.find(*extname) {\n-                        None => {\n-                            cx.span_fatal(\n-                                pth.span,\n-                                fmt!(\"macro undefined: '%s'\", *extname))\n-                        }\n-                        Some(normal_tt({expander: exp, span: exp_sp})) => {\n-                            let expanded = match exp(cx, mac.span, tts) {\n-                                mr_expr(e) =>\n-                                @{node: ast::stmt_expr(e, cx.next_id()),\n-                                  span: e.span},\n-                                mr_any(_,_,stmt_mkr) => stmt_mkr(),\n-                                _ => cx.span_fatal(\n-                                    pth.span,\n-                                    fmt!(\"non-stmt macro in stmt pos: %s\",\n-                                         *extname))\n-                            };\n+    let (mac, pth, tts) = biased_match! (\n+        (s)        ~ (stmt_mac(mac))          else return orig(s, sp, fld);\n+        (mac.node) ~ (mac_invoc_tt(pth, tts)) else {\n+            cx.span_bug(mac.span, ~\"naked syntactic bit\")\n+        };\n+        => (mac, pth, tts));\n+\n+    assert(vec::len(pth.idents) == 1u);\n+    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n+    match exts.find(*extname) {\n+        None =>\n+            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n+\n+        Some(normal_tt({expander: exp, span: exp_sp})) => {\n+            let expanded = match exp(cx, mac.span, tts) {\n+                mr_expr(e) =>\n+                    @{node: ast::stmt_expr(e, cx.next_id()), span: e.span},\n+                mr_any(_,_,stmt_mkr) => stmt_mkr(),\n+                _ => cx.span_fatal(\n+                    pth.span,\n+                    fmt!(\"non-stmt macro in stmt pos: %s\", *extname))\n+            };\n \n-                            cx.bt_push(ExpandedFrom(\n-                                {call_site: sp,\n-                                 callie: {name: *extname, span: exp_sp}}));\n-                            //keep going, outside-in\n-                            let fully_expanded = fld.fold_stmt(expanded).node;\n-                            cx.bt_pop();\n+            cx.bt_push(ExpandedFrom(\n+                {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n+            //keep going, outside-in\n+            let fully_expanded = fld.fold_stmt(expanded).node;\n+            cx.bt_pop();\n \n-                            (fully_expanded, sp)\n-                        }\n-                        _ => {\n-                            cx.span_fatal(pth.span,\n-                                          fmt!(\"'%s' is not a tt-style macro\",\n-                                               *extname))\n-                        }\n-                    }\n-                }\n-                _ => cx.span_bug(mac.span, ~\"naked syntactic bit\")\n-            }\n+            return (fully_expanded, sp)\n         }\n-        _ => orig(s, sp, fld)\n-    };\n+        _ => {\n+            cx.span_fatal(pth.span,\n+                          fmt!(\"'%s' is not a tt-style macro\",\n+                               *extname))\n+        }\n+    }\n+\n }\n \n "}]}