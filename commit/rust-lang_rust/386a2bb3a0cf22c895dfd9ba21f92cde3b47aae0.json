{"sha": "386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NmEyYmIzYTBjZjIyYzg5NWRmZDliYTIxZjkyY2RlM2I0N2FhZTA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-30T09:28:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-12-02T08:03:16Z"}, "message": "fat -> wide", "tree": {"sha": "b9687a0d6534e1c8d7857dcd7b0982119d5f8cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9687a0d6534e1c8d7857dcd7b0982119d5f8cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0", "html_url": "https://github.com/rust-lang/rust/commit/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96ea142c89ad34c00d803d91ee0b08689599c65d", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ea142c89ad34c00d803d91ee0b08689599c65d", "html_url": "https://github.com/rust-lang/rust/commit/96ea142c89ad34c00d803d91ee0b08689599c65d"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "9e94ae2c1608131cebb5c9465d687bd9920960af", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0", "patch": "@@ -24,7 +24,7 @@ use rustc_macros::HashStable;\n ///\n /// For optimization of a few very common cases, there is also a representation for a pair of\n /// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's codegen.\n+/// operations and wide pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n@@ -74,7 +74,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n-            Immediate::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n+            Immediate::ScalarPair(..) => bug!(\"Got a wide pointer where a scalar was expected\"),\n         }\n     }\n \n@@ -331,7 +331,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(self.read_immediate(op)?.to_scalar_or_undef())\n     }\n \n-    // Turn the fat MPlace into a string (must already be dereferenced!)\n+    // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,"}, {"sha": "8da20a4bba288dc82ecc6765bb1da6ee56c5f1ef", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=386a2bb3a0cf22c895dfd9ba21f92cde3b47aae0", "patch": "@@ -125,7 +125,7 @@ impl<Tag> MemPlace<Tag> {\n         Self::from_scalar_ptr(ptr.into(), align)\n     }\n \n-    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// Turn a mplace into a (thin or wide) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     #[inline(always)]\n     pub fn to_ref(self) -> Immediate<Tag> {\n@@ -278,7 +278,7 @@ where\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n {\n-    /// Take a value, which represents a (thin or fat) reference, and make it a place.\n+    /// Take a value, which represents a (thin or wide) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n     ///\n     /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n@@ -1034,7 +1034,7 @@ where\n         MPlaceTy::from_aligned_ptr(ptr, layout)\n     }\n \n-    /// Returns a fat MPlace.\n+    /// Returns a wide MPlace.\n     pub fn allocate_str(\n         &mut self,\n         str: &str,"}]}