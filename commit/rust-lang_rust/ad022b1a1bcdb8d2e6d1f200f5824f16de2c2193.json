{"sha": "ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMDIyYjFhMWJjZGI4ZDJlNmQxZjIwMGY1ODI0ZjE2ZGUyYzIxOTM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-14T21:40:34Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-21T01:19:13Z"}, "message": "Remove Runtime trait\n\nThis commit removes most of the remaining runtime infrastructure related\nto the green/native split. In particular, it removes the `Runtime` trait\nand instead inlines the native implementation.\n\nCloses #17325\n\n[breaking-change]", "tree": {"sha": "338f3174030da4f17c484a27536f75f6ee97786b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/338f3174030da4f17c484a27536f75f6ee97786b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "html_url": "https://github.com/rust-lang/rust/commit/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "770378a313a573776b16237a46b75bafa49072c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/770378a313a573776b16237a46b75bafa49072c1", "html_url": "https://github.com/rust-lang/rust/commit/770378a313a573776b16237a46b75bafa49072c1"}], "stats": {"total": 675, "additions": 172, "deletions": 503}, "files": [{"sha": "02fb5b31c0d1cabe510328f00ffb6088eab770dd", "filename": "src/libnative/task.rs", "status": "modified", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -24,252 +24,6 @@ use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt::thread::Thread;\n use std::rt;\n \n-use std::task::{TaskBuilder, Spawner};\n-\n-/// Creates a new Task which is ready to execute as a 1:1 task.\n-pub fn new(stack_bounds: (uint, uint), stack_guard: uint) -> Box<Task> {\n-    let mut task = box Task::new();\n-    let mut ops = ops();\n-    ops.stack_bounds = stack_bounds;\n-    ops.stack_guard = stack_guard;\n-    task.put_runtime(ops);\n-    return task;\n-}\n-\n-fn ops() -> Box<Ops> {\n-    box Ops {\n-        lock: unsafe { NativeMutex::new() },\n-        awoken: false,\n-        // these *should* get overwritten\n-        stack_bounds: (0, 0),\n-        stack_guard: 0\n-    }\n-}\n-\n-/// A spawner for native tasks\n-pub struct NativeSpawner;\n-\n-impl Spawner for NativeSpawner {\n-    fn spawn(self, opts: TaskOpts, f: proc():Send) {\n-        let TaskOpts { name, stack_size, on_exit } = opts;\n-\n-        let mut task = box Task::new();\n-        task.name = name;\n-        task.death.on_exit = on_exit;\n-\n-        let stack = stack_size.unwrap_or(rt::min_stack());\n-        let task = task;\n-        let ops = ops();\n-\n-        // Note that this increment must happen *before* the spawn in order to\n-        // guarantee that if this task exits it will always end up waiting for\n-        // the spawned task to exit.\n-        let token = bookkeeping::increment();\n-\n-        // Spawning a new OS thread guarantees that __morestack will never get\n-        // triggered, but we must manually set up the actual stack bounds once\n-        // this function starts executing. This raises the lower limit by a bit\n-        // because by the time that this function is executing we've already\n-        // consumed at least a little bit of stack (we don't know the exact byte\n-        // address at which our stack started).\n-        Thread::spawn_stack(stack, proc() {\n-            let something_around_the_top_of_the_stack = 1;\n-            let addr = &something_around_the_top_of_the_stack as *const int;\n-            let my_stack = addr as uint;\n-            unsafe {\n-                stack::record_os_managed_stack_bounds(my_stack - stack + 1024,\n-                                                      my_stack);\n-            }\n-            let mut ops = ops;\n-            ops.stack_guard = rt::thread::current_guard_page();\n-            ops.stack_bounds = (my_stack - stack + 1024, my_stack);\n-\n-            let mut f = Some(f);\n-            let mut task = task;\n-            task.put_runtime(ops);\n-            drop(task.run(|| { f.take().unwrap()() }).destroy());\n-            drop(token);\n-        })\n-    }\n-}\n-\n-/// An extension trait adding a `native` configuration method to `TaskBuilder`.\n-pub trait NativeTaskBuilder {\n-    fn native(self) -> TaskBuilder<NativeSpawner>;\n-}\n-\n-impl<S: Spawner> NativeTaskBuilder for TaskBuilder<S> {\n-    fn native(self) -> TaskBuilder<NativeSpawner> {\n-        self.spawner(NativeSpawner)\n-    }\n-}\n-\n-// This structure is the glue between channels and the 1:1 scheduling mode. This\n-// structure is allocated once per task.\n-struct Ops {\n-    lock: NativeMutex,       // native synchronization\n-    awoken: bool,      // used to prevent spurious wakeups\n-\n-    // This field holds the known bounds of the stack in (lo, hi) form. Not all\n-    // native tasks necessarily know their precise bounds, hence this is\n-    // optional.\n-    stack_bounds: (uint, uint),\n-\n-    stack_guard: uint\n-}\n-\n-impl rt::Runtime for Ops {\n-    fn yield_now(self: Box<Ops>, mut cur_task: Box<Task>) {\n-        // put the task back in TLS and then invoke the OS thread yield\n-        cur_task.put_runtime(self);\n-        Local::put(cur_task);\n-        Thread::yield_now();\n-    }\n-\n-    fn maybe_yield(self: Box<Ops>, mut cur_task: Box<Task>) {\n-        // just put the task back in TLS, on OS threads we never need to\n-        // opportunistically yield b/c the OS will do that for us (preemption)\n-        cur_task.put_runtime(self);\n-        Local::put(cur_task);\n-    }\n-\n-    fn wrap(self: Box<Ops>) -> Box<Any+'static> {\n-        self as Box<Any+'static>\n-    }\n-\n-    fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }\n-\n-    fn stack_guard(&self) -> Option<uint> {\n-        if self.stack_guard != 0 {\n-            Some(self.stack_guard)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn can_block(&self) -> bool { true }\n-\n-    // This function gets a little interesting. There are a few safety and\n-    // ownership violations going on here, but this is all done in the name of\n-    // shared state. Additionally, all of the violations are protected with a\n-    // mutex, so in theory there are no races.\n-    //\n-    // The first thing we need to do is to get a pointer to the task's internal\n-    // mutex. This address will not be changing (because the task is allocated\n-    // on the heap). We must have this handle separately because the task will\n-    // have its ownership transferred to the given closure. We're guaranteed,\n-    // however, that this memory will remain valid because *this* is the current\n-    // task's execution thread.\n-    //\n-    // The next weird part is where ownership of the task actually goes. We\n-    // relinquish it to the `f` blocking function, but upon returning this\n-    // function needs to replace the task back in TLS. There is no communication\n-    // from the wakeup thread back to this thread about the task pointer, and\n-    // there's really no need to. In order to get around this, we cast the task\n-    // to a `uint` which is then used at the end of this function to cast back\n-    // to a `Box<Task>` object. Naturally, this looks like it violates\n-    // ownership semantics in that there may be two `Box<Task>` objects.\n-    //\n-    // The fun part is that the wakeup half of this implementation knows to\n-    // \"forget\" the task on the other end. This means that the awakening half of\n-    // things silently relinquishes ownership back to this thread, but not in a\n-    // way that the compiler can understand. The task's memory is always valid\n-    // for both tasks because these operations are all done inside of a mutex.\n-    //\n-    // You'll also find that if blocking fails (the `f` function hands the\n-    // BlockedTask back to us), we will `mem::forget` the handles. The\n-    // reasoning for this is the same logic as above in that the task silently\n-    // transfers ownership via the `uint`, not through normal compiler\n-    // semantics.\n-    //\n-    // On a mildly unrelated note, it should also be pointed out that OS\n-    // condition variables are susceptible to spurious wakeups, which we need to\n-    // be ready for. In order to accommodate for this fact, we have an extra\n-    // `awoken` field which indicates whether we were actually woken up via some\n-    // invocation of `reawaken`. This flag is only ever accessed inside the\n-    // lock, so there's no need to make it atomic.\n-    fn deschedule(mut self: Box<Ops>,\n-                  times: uint,\n-                  mut cur_task: Box<Task>,\n-                  f: |BlockedTask| -> Result<(), BlockedTask>) {\n-        let me = &mut *self as *mut Ops;\n-        cur_task.put_runtime(self);\n-\n-        unsafe {\n-            let cur_task_dupe = &mut *cur_task as *mut Task;\n-            let task = BlockedTask::block(cur_task);\n-\n-            if times == 1 {\n-                let guard = (*me).lock.lock();\n-                (*me).awoken = false;\n-                match f(task) {\n-                    Ok(()) => {\n-                        while !(*me).awoken {\n-                            guard.wait();\n-                        }\n-                    }\n-                    Err(task) => { mem::forget(task.wake()); }\n-                }\n-            } else {\n-                let iter = task.make_selectable(times);\n-                let guard = (*me).lock.lock();\n-                (*me).awoken = false;\n-\n-                // Apply the given closure to all of the \"selectable tasks\",\n-                // bailing on the first one that produces an error. Note that\n-                // care must be taken such that when an error is occurred, we\n-                // may not own the task, so we may still have to wait for the\n-                // task to become available. In other words, if task.wake()\n-                // returns `None`, then someone else has ownership and we must\n-                // wait for their signal.\n-                match iter.map(f).filter_map(|a| a.err()).next() {\n-                    None => {}\n-                    Some(task) => {\n-                        match task.wake() {\n-                            Some(task) => {\n-                                mem::forget(task);\n-                                (*me).awoken = true;\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n-                while !(*me).awoken {\n-                    guard.wait();\n-                }\n-            }\n-            // re-acquire ownership of the task\n-            cur_task = mem::transmute(cur_task_dupe);\n-        }\n-\n-        // put the task back in TLS, and everything is as it once was.\n-        Local::put(cur_task);\n-    }\n-\n-    // See the comments on `deschedule` for why the task is forgotten here, and\n-    // why it's valid to do so.\n-    fn reawaken(mut self: Box<Ops>, mut to_wake: Box<Task>) {\n-        unsafe {\n-            let me = &mut *self as *mut Ops;\n-            to_wake.put_runtime(self);\n-            mem::forget(to_wake);\n-            let guard = (*me).lock.lock();\n-            (*me).awoken = true;\n-            guard.signal();\n-        }\n-    }\n-\n-    fn spawn_sibling(self: Box<Ops>,\n-                     mut cur_task: Box<Task>,\n-                     opts: TaskOpts,\n-                     f: proc():Send) {\n-        cur_task.put_runtime(self);\n-        Local::put(cur_task);\n-\n-        NativeSpawner.spawn(opts, f);\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::rt::local::Local;"}, {"sha": "387b430b8f8b9603bba171bdc248b7bd039233f6", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -39,11 +39,6 @@ pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n-use core::any::Any;\n-\n-use task::{Task, BlockedTask, TaskOpts};\n-\n mod macros;\n \n mod at_exit_imp;\n@@ -60,46 +55,11 @@ pub mod exclusive;\n pub mod local;\n pub mod local_data;\n pub mod mutex;\n-pub mod rtio;\n pub mod stack;\n pub mod task;\n pub mod thread;\n pub mod unwind;\n \n-/// The interface to the current runtime.\n-///\n-/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n-/// two independent crates, libnative and libgreen, both have objects which\n-/// implement this trait. The goal of this trait is to encompass all the\n-/// fundamental differences in functionality between the 1:1 and M:N runtime\n-/// modes.\n-pub trait Runtime {\n-    // Necessary scheduling functions, used for channels and blocking I/O\n-    // (sometimes).\n-    fn yield_now(self: Box<Self>, cur_task: Box<Task>);\n-    fn maybe_yield(self: Box<Self>, cur_task: Box<Task>);\n-    fn deschedule(self: Box<Self>,\n-                  times: uint,\n-                  cur_task: Box<Task>,\n-                  f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(self: Box<Self>, to_wake: Box<Task>);\n-\n-    // Miscellaneous calls which are very different depending on what context\n-    // you're in.\n-    fn spawn_sibling(self: Box<Self>,\n-                     cur_task: Box<Task>,\n-                     opts: TaskOpts,\n-                     f: proc():Send);\n-    /// The (low, high) edges of the current stack.\n-    fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n-    /// The last writable byte of the stack next to the guard page\n-    fn stack_guard(&self) -> Option<uint>;\n-    fn can_block(&self) -> bool;\n-\n-    // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(self: Box<Self>) -> Box<Any+'static>;\n-}\n-\n /// The default error code of the rust runtime if the main task panics instead\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: int = 101;"}, {"sha": "86de8168189ca77afe962f35ef4f9a7ff1554602", "filename": "src/librustrt/rtio.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/770378a313a573776b16237a46b75bafa49072c1/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/770378a313a573776b16237a46b75bafa49072c1/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=770378a313a573776b16237a46b75bafa49072c1", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The EventLoop and internal synchronous I/O interface.\n-\n-use core::prelude::*;\n-use alloc::boxed::Box;\n-\n-pub trait EventLoop {\n-    fn run(&mut self);\n-    fn callback(&mut self, arg: proc(): Send);\n-    fn pausable_idle_callback(&mut self, Box<Callback + Send>)\n-                              -> Box<PausableIdleCallback + Send>;\n-    fn remote_callback(&mut self, Box<Callback + Send>)\n-                       -> Box<RemoteCallback + Send>;\n-\n-    // last vestige of IoFactory\n-    fn has_active_io(&self) -> bool;\n-}\n-\n-pub trait Callback {\n-    fn call(&mut self);\n-}\n-\n-pub trait RemoteCallback {\n-    /// Trigger the remote callback. Note that the number of times the\n-    /// callback is run is not guaranteed. All that is guaranteed is\n-    /// that, after calling 'fire', the callback will be called at\n-    /// least once, but multiple callbacks may be coalesced and\n-    /// callbacks may be called more often requested. Destruction also\n-    /// triggers the callback.\n-    fn fire(&mut self);\n-}\n-\n-pub trait PausableIdleCallback {\n-    fn pause(&mut self);\n-    fn resume(&mut self);\n-}"}, {"sha": "34c913c5bcb40e52305350f1e2469c34e9ae5492", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 170, "deletions": 172, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -16,92 +16,45 @@ pub use self::BlockedTask::*;\n use self::TaskState::*;\n \n use alloc::arc::Arc;\n-use alloc::boxed::{BoxAny, Box};\n+use alloc::boxed::Box;\n use core::any::Any;\n use core::atomic::{AtomicUint, SeqCst};\n use core::iter::Take;\n use core::kinds::marker;\n use core::mem;\n use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n use core::prelude::{drop};\n-use core::raw;\n \n+use bookkeeping;\n+use mutex::NativeMutex;\n use local_data;\n-use Runtime;\n use local::Local;\n+use thread::{mod, Thread};\n+use stack;\n use unwind;\n use unwind::Unwinder;\n use collections::str::SendStr;\n \n /// State associated with Rust tasks.\n ///\n-/// Rust tasks are primarily built with two separate components. One is this\n-/// structure which handles standard services such as TLD, unwinding support,\n-/// naming of a task, etc. The second component is the runtime of this task, a\n-/// `Runtime` trait object.\n-///\n-/// The `Runtime` object instructs this task how it can perform critical\n-/// operations such as blocking, rescheduling, I/O constructors, etc. The two\n-/// halves are separately owned, but one is often found contained in the other.\n-/// A task's runtime can be reflected upon with the `maybe_take_runtime` method,\n-/// and otherwise its ownership is managed with `take_runtime` and\n-/// `put_runtime`.\n-///\n-/// In general, this structure should not be used. This is meant to be an\n-/// unstable internal detail of the runtime itself. From time-to-time, however,\n-/// it is useful to manage tasks directly. An example of this would be\n-/// interoperating with the Rust runtime from FFI callbacks or such. For this\n-/// reason, there are two methods of note with the `Task` structure.\n-///\n-/// * `run` - This function will execute a closure inside the context of a task.\n-///           Failure is caught and handled via the task's on_exit callback. If\n-///           this panics, the task is still returned, but it can no longer be\n-///           used, it is poisoned.\n-///\n-/// * `destroy` - This is a required function to call to destroy a task. If a\n-///               task falls out of scope without calling `destroy`, its\n-///               destructor bomb will go off, aborting the process.\n-///\n-/// With these two methods, tasks can be re-used to execute code inside of its\n-/// context while having a point in the future where destruction is allowed.\n-/// More information can be found on these specific methods.\n-///\n-/// # Example\n-///\n-/// ```no_run\n-/// extern crate native;\n-/// use std::uint;\n-/// # fn main() {\n-///\n-/// // Create a task using a native runtime\n-/// let task = native::task::new((0, uint::MAX), 0);\n-///\n-/// // Run some code, catching any possible panic\n-/// let task = task.run(|| {\n-///     // Run some code inside this task\n-///     println!(\"Hello with a native runtime!\");\n-/// });\n-///\n-/// // Run some code again, catching the panic\n-/// let task = task.run(|| {\n-///     panic!(\"oh no, what to do!\");\n-/// });\n-///\n-/// // Now that the task has panicked, it can never be used again\n-/// assert!(task.is_destroyed());\n-///\n-/// // Deallocate the resources associated with this task\n-/// task.destroy();\n-/// # }\n-/// ```\n+/// This structure is currently undergoing major changes, and is\n+/// likely to be move/be merged with a `Thread` structure.\n pub struct Task {\n     pub storage: LocalStorage,\n     pub unwinder: Unwinder,\n     pub death: Death,\n     pub name: Option<SendStr>,\n \n     state: TaskState,\n-    imp: Option<Box<Runtime + Send + 'static>>,\n+    lock: NativeMutex,       // native synchronization\n+    awoken: bool,            // used to prevent spurious wakeups\n+\n+    // This field holds the known bounds of the stack in (lo, hi) form. Not all\n+    // native tasks necessarily know their precise bounds, hence this is\n+    // optional.\n+    stack_bounds: (uint, uint),\n+\n+    stack_guard: uint\n }\n \n // Once a task has entered the `Armed` state it must be destroyed via `drop`,\n@@ -152,23 +105,60 @@ pub struct BlockedTasks {\n \n impl Task {\n     /// Creates a new uninitialized task.\n-    ///\n-    /// This method cannot be used to immediately invoke `run` because the task\n-    /// itself will likely require a runtime to be inserted via `put_runtime`.\n-    ///\n-    /// Note that you likely don't want to call this function, but rather the\n-    /// task creation functions through libnative or libgreen.\n-    pub fn new() -> Task {\n+    pub fn new(stack_bounds: Option<(uint, uint)>, stack_guard: Option<uint>) -> Task {\n         Task {\n             storage: LocalStorage(None),\n             unwinder: Unwinder::new(),\n             death: Death::new(),\n             state: New,\n             name: None,\n-            imp: None,\n+            lock: unsafe { NativeMutex::new() },\n+            awoken: false,\n+            // these *should* get overwritten\n+            stack_bounds: stack_bounds.unwrap_or((0, 0)),\n+            stack_guard: stack_guard.unwrap_or(0)\n         }\n     }\n \n+    pub fn spawn(opts: TaskOpts, f: proc():Send) {\n+        let TaskOpts { name, stack_size, on_exit } = opts;\n+\n+        let mut task = box Task::new(None, None);\n+        task.name = name;\n+        task.death.on_exit = on_exit;\n+\n+        // FIXME: change this back after moving rustrt into std\n+        // let stack = stack_size.unwrap_or(rt::min_stack());\n+        let stack = stack_size.unwrap_or(2 * 1024 * 1024);\n+\n+        // Note that this increment must happen *before* the spawn in order to\n+        // guarantee that if this task exits it will always end up waiting for\n+        // the spawned task to exit.\n+        let token = bookkeeping::increment();\n+\n+        // Spawning a new OS thread guarantees that __morestack will never get\n+        // triggered, but we must manually set up the actual stack bounds once\n+        // this function starts executing. This raises the lower limit by a bit\n+        // because by the time that this function is executing we've already\n+        // consumed at least a little bit of stack (we don't know the exact byte\n+        // address at which our stack started).\n+        Thread::spawn_stack(stack, proc() {\n+            let something_around_the_top_of_the_stack = 1;\n+            let addr = &something_around_the_top_of_the_stack as *const int;\n+            let my_stack = addr as uint;\n+            unsafe {\n+                stack::record_os_managed_stack_bounds(my_stack - stack + 1024,\n+                                                      my_stack);\n+            }\n+            task.stack_guard = thread::current_guard_page();\n+            task.stack_bounds = (my_stack - stack + 1024, my_stack);\n+\n+            let mut f = Some(f);\n+            drop(task.run(|| { f.take().unwrap()() }).destroy());\n+            drop(token);\n+        })\n+    }\n+\n     /// Consumes ownership of a task, runs some code, and returns the task back.\n     ///\n     /// This function can be used as an emulated \"try/catch\" to interoperate\n@@ -190,23 +180,6 @@ impl Task {\n     ///\n     /// It is invalid to call this function with a task that has been previously\n     /// destroyed via a failed call to `run`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// extern crate native;\n-    /// use std::uint;\n-    /// # fn main() {\n-    ///\n-    /// // Create a new native task\n-    /// let task = native::task::new((0, uint::MAX), 0);\n-    ///\n-    /// // Run some code once and then destroy this task\n-    /// task.run(|| {\n-    ///     println!(\"Hello with a native runtime!\");\n-    /// }).destroy();\n-    /// # }\n-    /// ```\n     pub fn run(mut self: Box<Task>, f: ||) -> Box<Task> {\n         assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n \n@@ -329,111 +302,136 @@ impl Task {\n     /// Queries whether this can be destroyed or not.\n     pub fn is_destroyed(&self) -> bool { self.state == Destroyed }\n \n-    /// Inserts a runtime object into this task, transferring ownership to the\n-    /// task. It is illegal to replace a previous runtime object in this task\n-    /// with this argument.\n-    pub fn put_runtime(&mut self, ops: Box<Runtime + Send + 'static>) {\n-        assert!(self.imp.is_none());\n-        self.imp = Some(ops);\n-    }\n-\n-    /// Removes the runtime from this task, transferring ownership to the\n-    /// caller.\n-    pub fn take_runtime(&mut self) -> Box<Runtime + Send + 'static> {\n-        assert!(self.imp.is_some());\n-        self.imp.take().unwrap()\n-    }\n-\n-    /// Attempts to extract the runtime as a specific type. If the runtime does\n-    /// not have the provided type, then the runtime is not removed. If the\n-    /// runtime does have the specified type, then it is removed and returned\n-    /// (transfer of ownership).\n-    ///\n-    /// It is recommended to only use this method when *absolutely necessary*.\n-    /// This function may not be available in the future.\n-    pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<Box<T>> {\n-        // This is a terrible, terrible function. The general idea here is to\n-        // take the runtime, cast it to Box<Any>, check if it has the right\n-        // type, and then re-cast it back if necessary. The method of doing\n-        // this is pretty sketchy and involves shuffling vtables of trait\n-        // objects around, but it gets the job done.\n-        //\n-        // FIXME: This function is a serious code smell and should be avoided at\n-        //      all costs. I have yet to think of a method to avoid this\n-        //      function, and I would be saddened if more usage of the function\n-        //      crops up.\n-        unsafe {\n-            let imp = self.imp.take().unwrap();\n-            let vtable = mem::transmute::<_, &raw::TraitObject>(&imp).vtable;\n-            match imp.wrap().downcast::<T>() {\n-                Ok(t) => Some(t),\n-                Err(t) => {\n-                    let data = mem::transmute::<_, raw::TraitObject>(t).data;\n-                    let obj: Box<Runtime + Send + 'static> =\n-                        mem::transmute(raw::TraitObject {\n-                            vtable: vtable,\n-                            data: data,\n-                        });\n-                    self.put_runtime(obj);\n-                    None\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Spawns a sibling to this task. The newly spawned task is configured with\n-    /// the `opts` structure and will run `f` as the body of its code.\n-    pub fn spawn_sibling(mut self: Box<Task>,\n-                         opts: TaskOpts,\n-                         f: proc(): Send) {\n-        let ops = self.imp.take().unwrap();\n-        ops.spawn_sibling(self, opts, f)\n-    }\n-\n     /// Deschedules the current task, invoking `f` `amt` times. It is not\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n+    //\n+    // This function gets a little interesting. There are a few safety and\n+    // ownership violations going on here, but this is all done in the name of\n+    // shared state. Additionally, all of the violations are protected with a\n+    // mutex, so in theory there are no races.\n+    //\n+    // The first thing we need to do is to get a pointer to the task's internal\n+    // mutex. This address will not be changing (because the task is allocated\n+    // on the heap). We must have this handle separately because the task will\n+    // have its ownership transferred to the given closure. We're guaranteed,\n+    // however, that this memory will remain valid because *this* is the current\n+    // task's execution thread.\n+    //\n+    // The next weird part is where ownership of the task actually goes. We\n+    // relinquish it to the `f` blocking function, but upon returning this\n+    // function needs to replace the task back in TLS. There is no communication\n+    // from the wakeup thread back to this thread about the task pointer, and\n+    // there's really no need to. In order to get around this, we cast the task\n+    // to a `uint` which is then used at the end of this function to cast back\n+    // to a `Box<Task>` object. Naturally, this looks like it violates\n+    // ownership semantics in that there may be two `Box<Task>` objects.\n+    //\n+    // The fun part is that the wakeup half of this implementation knows to\n+    // \"forget\" the task on the other end. This means that the awakening half of\n+    // things silently relinquishes ownership back to this thread, but not in a\n+    // way that the compiler can understand. The task's memory is always valid\n+    // for both tasks because these operations are all done inside of a mutex.\n+    //\n+    // You'll also find that if blocking fails (the `f` function hands the\n+    // BlockedTask back to us), we will `mem::forget` the handles. The\n+    // reasoning for this is the same logic as above in that the task silently\n+    // transfers ownership via the `uint`, not through normal compiler\n+    // semantics.\n+    //\n+    // On a mildly unrelated note, it should also be pointed out that OS\n+    // condition variables are susceptible to spurious wakeups, which we need to\n+    // be ready for. In order to accommodate for this fact, we have an extra\n+    // `awoken` field which indicates whether we were actually woken up via some\n+    // invocation of `reawaken`. This flag is only ever accessed inside the\n+    // lock, so there's no need to make it atomic.\n     pub fn deschedule(mut self: Box<Task>,\n-                      amt: uint,\n+                      times: uint,\n                       f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n-        let ops = self.imp.take().unwrap();\n-        ops.deschedule(amt, self, f)\n+        unsafe {\n+            let me = &mut *self as *mut Task;\n+            let task = BlockedTask::block(self);\n+\n+            if times == 1 {\n+                let guard = (*me).lock.lock();\n+                (*me).awoken = false;\n+                match f(task) {\n+                    Ok(()) => {\n+                        while !(*me).awoken {\n+                            guard.wait();\n+                        }\n+                    }\n+                    Err(task) => { mem::forget(task.wake()); }\n+                }\n+            } else {\n+                let iter = task.make_selectable(times);\n+                let guard = (*me).lock.lock();\n+                (*me).awoken = false;\n+\n+                // Apply the given closure to all of the \"selectable tasks\",\n+                // bailing on the first one that produces an error. Note that\n+                // care must be taken such that when an error is occurred, we\n+                // may not own the task, so we may still have to wait for the\n+                // task to become available. In other words, if task.wake()\n+                // returns `None`, then someone else has ownership and we must\n+                // wait for their signal.\n+                match iter.map(f).filter_map(|a| a.err()).next() {\n+                    None => {}\n+                    Some(task) => {\n+                        match task.wake() {\n+                            Some(task) => {\n+                                mem::forget(task);\n+                                (*me).awoken = true;\n+                            }\n+                            None => {}\n+                        }\n+                    }\n+                }\n+                while !(*me).awoken {\n+                    guard.wait();\n+                }\n+            }\n+            // put the task back in TLS, and everything is as it once was.\n+            Local::put(mem::transmute(me));\n+        }\n     }\n \n-    /// Wakes up a previously blocked task, optionally specifying whether the\n-    /// current task can accept a change in scheduling. This function can only\n-    /// be called on tasks that were previously blocked in `deschedule`.\n+    /// Wakes up a previously blocked task. This function can only be\n+    /// called on tasks that were previously blocked in `deschedule`.\n+    //\n+    // See the comments on `deschedule` for why the task is forgotten here, and\n+    // why it's valid to do so.\n     pub fn reawaken(mut self: Box<Task>) {\n-        let ops = self.imp.take().unwrap();\n-        ops.reawaken(self);\n+        unsafe {\n+            let me = &mut *self as *mut Task;\n+            mem::forget(self);\n+            let guard = (*me).lock.lock();\n+            (*me).awoken = true;\n+            guard.signal();\n+        }\n     }\n \n     /// Yields control of this task to another task. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n     /// opportunity to allow other tasks a chance to run.\n-    pub fn yield_now(mut self: Box<Task>) {\n-        let ops = self.imp.take().unwrap();\n-        ops.yield_now(self);\n-    }\n-\n-    /// Similar to `yield_now`, except that this function may immediately return\n-    /// without yielding (depending on what the runtime decides to do).\n-    pub fn maybe_yield(mut self: Box<Task>) {\n-        let ops = self.imp.take().unwrap();\n-        ops.maybe_yield(self);\n+    pub fn yield_now() {\n+        Thread::yield_now();\n     }\n \n     /// Returns the stack bounds for this task in (lo, hi) format. The stack\n     /// bounds may not be known for all tasks, so the return value may be\n     /// `None`.\n     pub fn stack_bounds(&self) -> (uint, uint) {\n-        self.imp.as_ref().unwrap().stack_bounds()\n+        self.stack_bounds\n     }\n \n-    /// Returns whether it is legal for this task to block the OS thread that it\n-    /// is running on.\n-    pub fn can_block(&self) -> bool {\n-        self.imp.as_ref().unwrap().can_block()\n+    /// Returns the stack guard for this task, if known.\n+    pub fn stack_guard(&self) -> Option<uint> {\n+        if self.stack_guard != 0 {\n+            Some(self.stack_guard)\n+        } else {\n+            None\n+        }\n     }\n \n     /// Consume this task, flagging it as a candidate for destruction."}, {"sha": "8701fadf65c04c9389252b3501f95cc64f100157", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -54,6 +54,8 @@ Several modules in `core` are clients of `rt`:\n // FIXME: this should not be here.\n #![allow(missing_docs)]\n \n+#![allow(dead_code)]\n+\n use failure;\n use rustrt;\n "}]}