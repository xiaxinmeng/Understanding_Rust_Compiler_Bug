{"sha": "263edd43c5255084292329423c61a9d69715ebfa", "node_id": "C_kwDOAAsO6NoAKDI2M2VkZDQzYzUyNTUwODQyOTIzMjk0MjNjNjFhOWQ2OTcxNWViZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-17T19:28:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-17T19:28:01Z"}, "message": "Auto merge of #99033 - 5225225:interpreter-validity-checks, r=oli-obk\n\nUse constant eval to do strict mem::uninit/zeroed validity checks\n\nI'm not sure about the code organisation here, I just dumped the check in rustc_const_eval at the root. Not hard to move it elsewhere, in any case.\n\nAlso, this means cranelift codegen intrinsics lose the strict checks, since they don't seem to depend on rustc_const_eval, and I didn't see a point in keeping around two copies.\n\nI also left comments in the is_zero_valid methods about \"uhhh help how do i do this\", those apply to both methods equally.\n\nAlso rustc_codegen_ssa now depends on rustc_const_eval... is this okay?\n\nPinging `@RalfJung` since you were the one who mentioned this to me, so I'm assuming you're interested.\n\nHaven't had a chance to run full tests on this since it's really warm, and it's 1AM, I'll check out any failures/comments in the morning :)", "tree": {"sha": "da4b05f8e9170da406ef68de2a281e7060eb07fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da4b05f8e9170da406ef68de2a281e7060eb07fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/263edd43c5255084292329423c61a9d69715ebfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/263edd43c5255084292329423c61a9d69715ebfa", "html_url": "https://github.com/rust-lang/rust/commit/263edd43c5255084292329423c61a9d69715ebfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/263edd43c5255084292329423c61a9d69715ebfa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ecd3af87477147695aa3f6e1237e3185044e62", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ecd3af87477147695aa3f6e1237e3185044e62", "html_url": "https://github.com/rust-lang/rust/commit/c2ecd3af87477147695aa3f6e1237e3185044e62"}, {"sha": "27412d1e3e128349bc515c16ce882860e20f037d", "url": "https://api.github.com/repos/rust-lang/rust/commits/27412d1e3e128349bc515c16ce882860e20f037d", "html_url": "https://github.com/rust-lang/rust/commit/27412d1e3e128349bc515c16ce882860e20f037d"}], "stats": {"total": 255, "additions": 161, "deletions": 94}, "files": [{"sha": "3a0bff2ee4defa5a095fadb08021f953900ca7f6", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -3752,6 +3752,7 @@ dependencies = [\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n+ \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_fs_util\","}, {"sha": "4b2207f375879add06b4fbaff0ba8b7fe9cf14a9", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -58,7 +58,6 @@ pub(crate) use llvm::codegen_llvm_intrinsic_call;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_target::abi::InitKind;\n \n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n@@ -672,12 +671,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid\n-                && !layout.might_permit_raw_init(\n-                    fx,\n-                    InitKind::Zero,\n-                    fx.tcx.sess.opts.unstable_opts.strict_init_checks) {\n-\n+            if intrinsic == sym::assert_zero_valid && !fx.tcx.permits_zero_init(layout) {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n@@ -688,12 +682,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid\n-                && !layout.might_permit_raw_init(\n-                    fx,\n-                    InitKind::Uninit,\n-                    fx.tcx.sess.opts.unstable_opts.strict_init_checks) {\n-\n+            if intrinsic == sym::assert_uninit_valid && !fx.tcx.permits_uninit_init(layout) {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,"}, {"sha": "81c8b9ceb136e7b75bc64cc483b0e6f103031186", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -40,6 +40,7 @@ rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n+rustc_const_eval = { path = \"../rustc_const_eval\" }\n \n [dependencies.object]\n version = \"0.29.0\""}, {"sha": "773c55cf551d5c6c5556d9294f7c4ccab4de9408", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -22,7 +22,7 @@ use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid_for_fnabi;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::abi::{self, HasDataLayout, InitKind, WrappingRange};\n+use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n@@ -528,7 +528,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo,\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n-        strict_validity: bool,\n     ) -> bool {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n         // These are intrinsics that compile to panics so that we can get a message\n@@ -547,12 +546,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         });\n         if let Some(intrinsic) = panic_intrinsic {\n             use AssertIntrinsic::*;\n+\n             let ty = instance.unwrap().substs.type_at(0);\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                ZeroValid => !layout.might_permit_raw_init(bx, InitKind::Zero, strict_validity),\n-                UninitValid => !layout.might_permit_raw_init(bx, InitKind::Uninit, strict_validity),\n+                ZeroValid => !bx.tcx().permits_zero_init(layout),\n+                UninitValid => !bx.tcx().permits_uninit_init(layout),\n             };\n             if do_panic {\n                 let msg_str = with_no_visible_paths!({\n@@ -687,7 +687,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             source_info,\n             target,\n             cleanup,\n-            self.cx.tcx().sess.opts.unstable_opts.strict_init_checks,\n         ) {\n             return;\n         }"}, {"sha": "e00e667fb71e2da2f0b53002c40af619c93b1357", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -104,7 +104,7 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(super) fn new(const_eval_limit: Limit, can_access_statics: bool) -> Self {\n+    pub(crate) fn new(const_eval_limit: Limit, can_access_statics: bool) -> Self {\n         CompileTimeInterpreter {\n             steps_remaining: const_eval_limit.0,\n             stack: Vec::new(),"}, {"sha": "242e3879e3a15324d4e48b9c2b52621602fc4b71", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::layout::LayoutOf as _;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, Align, InitKind, Primitive, Size};\n+use rustc_target::abi::{Abi, Align, Primitive, Size};\n \n use super::{\n     util::ensure_monomorphic_enough, CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy,\n@@ -411,35 +411,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         ),\n                     )?;\n                 }\n-                if intrinsic_name == sym::assert_zero_valid\n-                    && !layout.might_permit_raw_init(\n-                        self,\n-                        InitKind::Zero,\n-                        self.tcx.sess.opts.unstable_opts.strict_init_checks,\n-                    )\n-                {\n-                    M::abort(\n-                        self,\n-                        format!(\n-                            \"aborted execution: attempted to zero-initialize type `{}`, which is invalid\",\n-                            ty\n-                        ),\n-                    )?;\n+\n+                if intrinsic_name == sym::assert_zero_valid {\n+                    let should_panic = !self.tcx.permits_zero_init(layout);\n+\n+                    if should_panic {\n+                        M::abort(\n+                            self,\n+                            format!(\n+                                \"aborted execution: attempted to zero-initialize type `{}`, which is invalid\",\n+                                ty\n+                            ),\n+                        )?;\n+                    }\n                 }\n-                if intrinsic_name == sym::assert_uninit_valid\n-                    && !layout.might_permit_raw_init(\n-                        self,\n-                        InitKind::Uninit,\n-                        self.tcx.sess.opts.unstable_opts.strict_init_checks,\n-                    )\n-                {\n-                    M::abort(\n-                        self,\n-                        format!(\n-                            \"aborted execution: attempted to leave type `{}` uninitialized, which is invalid\",\n-                            ty\n-                        ),\n-                    )?;\n+\n+                if intrinsic_name == sym::assert_uninit_valid {\n+                    let should_panic = !self.tcx.permits_uninit_init(layout);\n+\n+                    if should_panic {\n+                        M::abort(\n+                            self,\n+                            format!(\n+                                \"aborted execution: attempted to leave type `{}` uninitialized, which is invalid\",\n+                                ty\n+                            ),\n+                        )?;\n+                    }\n                 }\n             }\n             sym::simd_insert => {"}, {"sha": "1063f03d0e2191826e3a3e98d130edceaf7978e1", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -33,11 +33,13 @@ extern crate rustc_middle;\n pub mod const_eval;\n mod errors;\n pub mod interpret;\n+mod might_permit_raw_init;\n pub mod transform;\n pub mod util;\n \n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n+use rustc_target::abi::InitKind;\n \n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);\n@@ -59,4 +61,8 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n+    providers.permits_uninit_init =\n+        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Uninit);\n+    providers.permits_zero_init =\n+        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Zero);\n }"}, {"sha": "f971c2238c7bbec27afa577af641142bdbd24f9c", "filename": "compiler/rustc_const_eval/src/might_permit_raw_init.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -0,0 +1,40 @@\n+use crate::const_eval::CompileTimeInterpreter;\n+use crate::interpret::{InterpCx, MemoryKind, OpTy};\n+use rustc_middle::ty::layout::LayoutCx;\n+use rustc_middle::ty::{layout::TyAndLayout, ParamEnv, TyCtxt};\n+use rustc_session::Limit;\n+use rustc_target::abi::InitKind;\n+\n+pub fn might_permit_raw_init<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: TyAndLayout<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    let strict = tcx.sess.opts.unstable_opts.strict_init_checks;\n+\n+    if strict {\n+        let machine = CompileTimeInterpreter::new(Limit::new(0), false);\n+\n+        let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n+\n+        let allocated = cx\n+            .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n+            .expect(\"OOM: failed to allocate for uninit check\");\n+\n+        if kind == InitKind::Zero {\n+            cx.write_bytes_ptr(\n+                allocated.ptr,\n+                std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n+            )\n+            .expect(\"failed to write bytes for zero valid check\");\n+        }\n+\n+        let ot: OpTy<'_, _> = allocated.into();\n+\n+        // Assume that if it failed, it's a validation failure.\n+        cx.validate_operand(&ot).is_ok()\n+    } else {\n+        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n+        ty.might_permit_raw_init(&layout_cx, kind)\n+    }\n+}"}, {"sha": "0581ef41f66c2c4c6f0f33b096146267645b5316", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -2053,4 +2053,12 @@ rustc_queries! {\n         desc { |tcx| \"looking up generator diagnostic data of `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }\n+\n+    query permits_uninit_init(key: TyAndLayout<'tcx>) -> bool {\n+        desc { \"checking to see if {:?} permits being left uninit\", key.ty }\n+    }\n+\n+    query permits_zero_init(key: TyAndLayout<'tcx>) -> bool {\n+        desc { \"checking to see if {:?} permits being left zeroed\", key.ty }\n+    }\n }"}, {"sha": "2452bcf6a61b8f3aa456f9c4d65344185502f0d4", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -28,6 +28,7 @@ use crate::traits::query::{\n use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::layout::TyAndLayout;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;"}, {"sha": "54774314313746b2c64bcb16e35913c65fad2c71", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::mir;\n use rustc_middle::traits;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -385,6 +385,16 @@ impl<'tcx> Key for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for TyAndLayout<'tcx> {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for (Ty<'tcx>, Ty<'tcx>) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "6f4d073d7048696488ad91a94fe096532583e492", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -1372,7 +1372,7 @@ pub struct PointeeInfo {\n \n /// Used in `might_permit_raw_init` to indicate the kind of initialisation\n /// that is checked to be valid\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum InitKind {\n     Zero,\n     Uninit,\n@@ -1487,14 +1487,18 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     ///\n     /// `init_kind` indicates if the memory is zero-initialized or left uninitialized.\n     ///\n-    /// `strict` is an opt-in debugging flag added in #97323 that enables more checks.\n+    /// This code is intentionally conservative, and will not detect\n+    /// * zero init of an enum whose 0 variant does not allow zero initialization\n+    /// * making uninitialized types who have a full valid range (ints, floats, raw pointers)\n+    /// * Any form of invalid value being made inside an array (unless the value is uninhabited)\n     ///\n-    /// This is conservative: in doubt, it will answer `true`.\n+    /// A strict form of these checks that uses const evaluation exists in\n+    /// `rustc_const_eval::might_permit_raw_init`, and a tracking issue for making these checks\n+    /// stricter is <https://github.com/rust-lang/rust/issues/66151>.\n     ///\n-    /// FIXME: Once we removed all the conservatism, we could alternatively\n-    /// create an all-0/all-undef constant and run the const value validator to see if\n-    /// this is a valid value for the given type.\n-    pub fn might_permit_raw_init<C>(self, cx: &C, init_kind: InitKind, strict: bool) -> bool\n+    /// FIXME: Once all the conservatism is removed from here, and the checks are ran by default,\n+    /// we can use the const evaluation checks always instead.\n+    pub fn might_permit_raw_init<C>(self, cx: &C, init_kind: InitKind) -> bool\n     where\n         Self: Copy,\n         Ty: TyAbiInterface<'a, C>,\n@@ -1507,13 +1511,8 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n                     s.valid_range(cx).contains(0)\n                 }\n                 InitKind::Uninit => {\n-                    if strict {\n-                        // The type must be allowed to be uninit (which means \"is a union\").\n-                        s.is_uninit_valid()\n-                    } else {\n-                        // The range must include all values.\n-                        s.is_always_valid(cx)\n-                    }\n+                    // The range must include all values.\n+                    s.is_always_valid(cx)\n                 }\n             }\n         };\n@@ -1534,19 +1533,12 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         // If we have not found an error yet, we need to recursively descend into fields.\n         match &self.fields {\n             FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n-            FieldsShape::Array { count, .. } => {\n+            FieldsShape::Array { .. } => {\n                 // FIXME(#66151): For now, we are conservative and do not check arrays by default.\n-                if strict\n-                    && *count > 0\n-                    && !self.field(cx, 0).might_permit_raw_init(cx, init_kind, strict)\n-                {\n-                    // Found non empty array with a type that is unhappy about this kind of initialization\n-                    return false;\n-                }\n             }\n             FieldsShape::Arbitrary { offsets, .. } => {\n                 for idx in 0..offsets.len() {\n-                    if !self.field(cx, idx).might_permit_raw_init(cx, init_kind, strict) {\n+                    if !self.field(cx, idx).might_permit_raw_init(cx, init_kind) {\n                         // We found a field that is unhappy with this kind of initialization.\n                         return false;\n                     }"}, {"sha": "255151a96032c016eccb4305c614925306e1b79b", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/263edd43c5255084292329423c61a9d69715ebfa/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263edd43c5255084292329423c61a9d69715ebfa/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=263edd43c5255084292329423c61a9d69715ebfa", "patch": "@@ -57,6 +57,13 @@ enum LR_NonZero {\n \n struct ZeroSized;\n \n+#[allow(dead_code)]\n+#[repr(i32)]\n+enum ZeroIsValid {\n+    Zero(u8) = 0,\n+    One(NonNull<()>) = 1,\n+}\n+\n fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     let err = panic::catch_unwind(op).err();\n     assert_eq!(\n@@ -152,33 +159,12 @@ fn main() {\n             \"attempted to zero-initialize type `*const dyn core::marker::Send`, which is invalid\"\n         );\n \n-        /* FIXME(#66151) we conservatively do not error here yet.\n-        test_panic_msg(\n-            || mem::uninitialized::<LR_NonZero>(),\n-            \"attempted to leave type `LR_NonZero` uninitialized, which is invalid\"\n-        );\n-        test_panic_msg(\n-            || mem::zeroed::<LR_NonZero>(),\n-            \"attempted to zero-initialize type `LR_NonZero`, which is invalid\"\n-        );\n-\n-        test_panic_msg(\n-            || mem::uninitialized::<ManuallyDrop<LR_NonZero>>(),\n-            \"attempted to leave type `std::mem::ManuallyDrop<LR_NonZero>` uninitialized, \\\n-             which is invalid\"\n-        );\n-        test_panic_msg(\n-            || mem::zeroed::<ManuallyDrop<LR_NonZero>>(),\n-            \"attempted to zero-initialize type `std::mem::ManuallyDrop<LR_NonZero>`, \\\n-             which is invalid\"\n-        );\n-        */\n-\n         test_panic_msg(\n             || mem::uninitialized::<(NonNull<u32>, u32, u32)>(),\n             \"attempted to leave type `(core::ptr::non_null::NonNull<u32>, u32, u32)` uninitialized, \\\n                 which is invalid\"\n         );\n+\n         test_panic_msg(\n             || mem::zeroed::<(NonNull<u32>, u32, u32)>(),\n             \"attempted to zero-initialize type `(core::ptr::non_null::NonNull<u32>, u32, u32)`, \\\n@@ -196,11 +182,23 @@ fn main() {\n                 which is invalid\"\n         );\n \n+        test_panic_msg(\n+            || mem::uninitialized::<LR_NonZero>(),\n+            \"attempted to leave type `LR_NonZero` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::uninitialized::<ManuallyDrop<LR_NonZero>>(),\n+            \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>` uninitialized, \\\n+             which is invalid\"\n+        );\n+\n         test_panic_msg(\n             || mem::uninitialized::<NoNullVariant>(),\n             \"attempted to leave type `NoNullVariant` uninitialized, \\\n                 which is invalid\"\n         );\n+\n         test_panic_msg(\n             || mem::zeroed::<NoNullVariant>(),\n             \"attempted to zero-initialize type `NoNullVariant`, \\\n@@ -212,10 +210,12 @@ fn main() {\n             || mem::uninitialized::<bool>(),\n             \"attempted to leave type `bool` uninitialized, which is invalid\"\n         );\n+\n         test_panic_msg(\n             || mem::uninitialized::<LR>(),\n             \"attempted to leave type `LR` uninitialized, which is invalid\"\n         );\n+\n         test_panic_msg(\n             || mem::uninitialized::<ManuallyDrop<LR>>(),\n             \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR>` uninitialized, which is invalid\"\n@@ -229,6 +229,7 @@ fn main() {\n         let _val = mem::zeroed::<Option<&'static i32>>();\n         let _val = mem::zeroed::<MaybeUninit<NonNull<u32>>>();\n         let _val = mem::zeroed::<[!; 0]>();\n+        let _val = mem::zeroed::<ZeroIsValid>();\n         let _val = mem::uninitialized::<MaybeUninit<bool>>();\n         let _val = mem::uninitialized::<[!; 0]>();\n         let _val = mem::uninitialized::<()>();\n@@ -259,12 +260,33 @@ fn main() {\n                 || mem::zeroed::<[NonNull<()>; 1]>(),\n                 \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n             );\n+\n+            // FIXME(#66151) we conservatively do not error here yet (by default).\n+            test_panic_msg(\n+                || mem::zeroed::<LR_NonZero>(),\n+                \"attempted to zero-initialize type `LR_NonZero`, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::zeroed::<ManuallyDrop<LR_NonZero>>(),\n+                \"attempted to zero-initialize type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>`, \\\n+                 which is invalid\"\n+            );\n         } else {\n             // These are UB because they have not been officially blessed, but we await the resolution\n             // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n             // anything about that.\n             let _val = mem::uninitialized::<i32>();\n             let _val = mem::uninitialized::<*const ()>();\n+\n+            // These are UB, but best to test them to ensure we don't become unintentionally\n+            // stricter.\n+\n+            // It's currently unchecked to create invalid enums and values inside arrays.\n+            let _val = mem::zeroed::<LR_NonZero>();\n+            let _val = mem::zeroed::<[LR_NonZero; 1]>();\n+            let _val = mem::zeroed::<[NonNull<()>; 1]>();\n+            let _val = mem::uninitialized::<[NonNull<()>; 1]>();\n         }\n     }\n }"}]}