{"sha": "3809bbf47c8557bd149b3e52ceb47434ca8378d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MDliYmY0N2M4NTU3YmQxNDliM2U1MmNlYjQ3NDM0Y2E4Mzc4ZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-16T23:19:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-16T23:19:41Z"}, "message": "Auto merge of #49488 - alexcrichton:small-wasm-panic, r=sfackler\n\nstd: Minimize size of panicking on wasm\n\nThis commit applies a few code size optimizations for the wasm target to\nthe standard library, namely around panics. We notably know that in most\nconfigurations it's impossible for us to print anything in\nwasm32-unknown-unknown so we can skip larger portions of panicking that\nare otherwise simply informative. This allows us to get quite a nice\nsize reduction.\n\nFinally we can also tweak where the allocation happens for the\n`Box<Any>` that we panic with. By only allocating once unwinding starts\nwe can reduce the size of a panicking wasm module from 44k to 350 bytes.", "tree": {"sha": "cb1af67dda415a8c9c9b31ea64100725dafa3221", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb1af67dda415a8c9c9b31ea64100725dafa3221"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3809bbf47c8557bd149b3e52ceb47434ca8378d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3809bbf47c8557bd149b3e52ceb47434ca8378d5", "html_url": "https://github.com/rust-lang/rust/commit/3809bbf47c8557bd149b3e52ceb47434ca8378d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3809bbf47c8557bd149b3e52ceb47434ca8378d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a3ab8b234cd848b673b64758e4d94bc690f98e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3ab8b234cd848b673b64758e4d94bc690f98e0", "html_url": "https://github.com/rust-lang/rust/commit/4a3ab8b234cd848b673b64758e4d94bc690f98e0"}, {"sha": "46d16b66e0b017430eb50b247926ea447c60ef07", "url": "https://api.github.com/repos/rust-lang/rust/commits/46d16b66e0b017430eb50b247926ea447c60ef07", "html_url": "https://github.com/rust-lang/rust/commit/46d16b66e0b017430eb50b247926ea447c60ef07"}], "stats": {"total": 368, "additions": 296, "deletions": 72}, "files": [{"sha": "56eda5480715bc1b5517f4d916f5b27b7718ad34", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -25,6 +25,12 @@ ENV RUST_CONFIGURE_ARGS \\\n   --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n   --set rust.lld\n \n+# Some run-make tests have assertions about code size, and enabling debug\n+# assertions in libstd causes the binary to be much bigger than it would\n+# otherwise normally be. We already test libstd with debug assertions in lots of\n+# other contexts as well\n+ENV NO_DEBUG_ASSERTIONS=1\n+\n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n   src/test/run-make \\\n   src/test/ui \\"}, {"sha": "24b7cd3db0cc67e27569fcc4bf821f808abee812", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -86,8 +86,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-            alloc_guard(alloc_size).expect(\"capacity overflow\");\n+            let alloc_size = cap.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n+            alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n@@ -310,7 +310,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n-                    alloc_guard(new_size).expect(\"capacity overflow\");\n+                    alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n                                                  cur,\n                                                  new_size);\n@@ -369,7 +369,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n-            alloc_guard(new_size).expect(\"capacity overflow\");\n+            alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n             match self.a.grow_in_place(NonNull::from(self.ptr).as_opaque(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n@@ -441,7 +441,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve_exact(used_cap, needed_extra_cap) {\n-            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocErr) => self.a.oom(),\n             Ok(()) => { /* yay */ }\n          }\n@@ -551,7 +551,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// The same as try_reserve, but errors are lowered to a call to oom().\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve(used_cap, needed_extra_cap) {\n-            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocErr) => self.a.oom(),\n             Ok(()) => { /* yay */ }\n          }\n@@ -592,15 +592,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n             }\n \n             let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n-                              .expect(\"capacity overflow\");\n+                .unwrap_or_else(|_| capacity_overflow());\n \n             // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n             // (regardless of whether `self.cap - used_cap` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n+            alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n             match self.a.grow_in_place(\n                 NonNull::from(self.ptr).as_opaque(), old_layout, new_layout.size(),\n             ) {\n@@ -732,6 +732,13 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n     }\n }\n \n+// One central function responsible for reporting capacity overflows. This'll\n+// ensure that the code generation related to these panics is minimal as there's\n+// only one location which panics rather than a bunch throughout the module.\n+fn capacity_overflow() -> ! {\n+    panic!(\"capacity overflow\")\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "277bef2bf661a6488a8321d00429da8c73e77250", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -1212,7 +1212,11 @@ impl<'a> Formatter<'a> {\n             // truncation. However other flags like `fill`, `width` and `align`\n             // must act as always.\n             if let Some((i, _)) = s.char_indices().skip(max).next() {\n-                &s[..i]\n+                // LLVM here can't prove that `..i` won't panic `&s[..i]`, but\n+                // we know that it can't panic. Use `get` + `unwrap_or` to avoid\n+                // `unsafe` and otherwise don't emit any panic-related code\n+                // here.\n+                s.get(..i).unwrap_or(&s)\n             } else {\n                 &s\n             }"}, {"sha": "27ec4aaac75dec3a9ed09cc4f268a880f97f3896", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -49,11 +49,17 @@ impl<'a> PanicInfo<'a> {\n                           and related macros\",\n                 issue = \"0\")]\n     #[doc(hidden)]\n-    pub fn internal_constructor(payload: &'a (Any + Send),\n-                                message: Option<&'a fmt::Arguments<'a>>,\n+    #[inline]\n+    pub fn internal_constructor(message: Option<&'a fmt::Arguments<'a>>,\n                                 location: Location<'a>)\n                                 -> Self {\n-        PanicInfo { payload, location, message }\n+        PanicInfo { payload: &(), location, message }\n+    }\n+\n+    #[doc(hidden)]\n+    #[inline]\n+    pub fn set_payload(&mut self, info: &'a (Any + Send)) {\n+        self.payload = info;\n     }\n \n     /// Returns the payload associated with the panic.\n@@ -251,3 +257,13 @@ impl<'a> fmt::Display for Location<'a> {\n         write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n     }\n }\n+\n+/// An internal trait used by libstd to pass data from libstd to `panic_unwind`\n+/// and other panic runtimes. Not intended to be stabilized any time soon, do\n+/// not use.\n+#[unstable(feature = \"std_internals\", issue = \"0\")]\n+#[doc(hidden)]\n+pub unsafe trait BoxMeUp {\n+    fn box_me_up(&mut self) -> *mut (Any + Send);\n+    fn get(&mut self) -> &(Any + Send);\n+}"}, {"sha": "392bf17968fbdfc28f648b7b9f94f2c5d16e403f", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -52,7 +52,7 @@ pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // now hopefully.\n #[no_mangle]\n #[rustc_std_internal_symbol]\n-pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n+pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n     abort();\n \n     #[cfg(any(unix, target_os = \"cloudabi\"))]"}, {"sha": "6c52c0fa10cc0b534536ed0f19ef3f602801082f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -29,13 +29,15 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n \n+#![feature(allocator_api)]\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(panic_unwind)]\n #![feature(raw)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(unwind_attributes)]\n #![cfg_attr(target_env = \"msvc\", feature(raw))]\n \n@@ -47,9 +49,11 @@ extern crate libc;\n #[cfg(not(any(target_env = \"msvc\", all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))))]\n extern crate unwind;\n \n+use alloc::boxed::Box;\n use core::intrinsics;\n use core::mem;\n use core::raw;\n+use core::panic::BoxMeUp;\n \n // Rust runtime's startup objects depend on these symbols, so make them public.\n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n@@ -112,9 +116,7 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // implementation.\n #[no_mangle]\n #[unwind(allowed)]\n-pub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n-    imp::panic(mem::transmute(raw::TraitObject {\n-        data: data as *mut (),\n-        vtable: vtable as *mut (),\n-    }))\n+pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n+    let payload = payload as *mut &mut BoxMeUp;\n+    imp::panic(Box::from_raw((*payload).box_me_up()))\n }"}, {"sha": "dd96c57538c7943f3fe807d125ea777c53909810", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -292,6 +292,7 @@\n #![feature(rand)]\n #![feature(raw)]\n #![feature(rustc_attrs)]\n+#![feature(std_internals)]\n #![feature(stdsimd)]\n #![feature(shrink_to)]\n #![feature(slice_bytes)]"}, {"sha": "24eae6a4c821e1db50005be285519f85510a2eb3", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 110, "deletions": 36, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -17,6 +17,8 @@\n //! * Executing a panic up to doing the actual implementation\n //! * Shims around \"try\"\n \n+use core::panic::BoxMeUp;\n+\n use io::prelude::*;\n \n use any::Any;\n@@ -27,7 +29,7 @@ use intrinsics;\n use mem;\n use ptr;\n use raw;\n-use sys::stdio::Stderr;\n+use sys::stdio::{Stderr, stderr_prints_nothing};\n use sys_common::rwlock::RWLock;\n use sys_common::thread_info;\n use sys_common::util;\n@@ -56,7 +58,7 @@ extern {\n                                 data_ptr: *mut usize,\n                                 vtable_ptr: *mut usize) -> u32;\n     #[unwind(allowed)]\n-    fn __rust_start_panic(data: usize, vtable: usize) -> u32;\n+    fn __rust_start_panic(payload: usize) -> u32;\n }\n \n #[derive(Copy, Clone)]\n@@ -177,9 +179,6 @@ fn default_hook(info: &PanicInfo) {\n     };\n \n     let location = info.location().unwrap();  // The current implementation always returns Some\n-    let file = location.file();\n-    let line = location.line();\n-    let col = location.column();\n \n     let msg = match info.payload().downcast_ref::<&'static str>() {\n         Some(s) => *s,\n@@ -193,8 +192,8 @@ fn default_hook(info: &PanicInfo) {\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut ::io::Write| {\n-        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}:{}\",\n-                         name, msg, file, line, col);\n+        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}\",\n+                         name, msg, location);\n \n         #[cfg(feature = \"backtrace\")]\n         {\n@@ -212,15 +211,15 @@ fn default_hook(info: &PanicInfo) {\n \n     let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n     match (prev, err.as_mut()) {\n-        (Some(mut stderr), _) => {\n-            write(&mut *stderr);\n-            let mut s = Some(stderr);\n-            LOCAL_STDERR.with(|slot| {\n-                *slot.borrow_mut() = s.take();\n-            });\n-        }\n-        (None, Some(ref mut err)) => { write(err) }\n-        _ => {}\n+       (Some(mut stderr), _) => {\n+           write(&mut *stderr);\n+           let mut s = Some(stderr);\n+           LOCAL_STDERR.with(|slot| {\n+               *slot.borrow_mut() = s.take();\n+           });\n+       }\n+       (None, Some(ref mut err)) => { write(err) }\n+       _ => {}\n     }\n }\n \n@@ -342,9 +341,38 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n     // panic + OOM properly anyway (see comment in begin_panic\n     // below).\n \n-    let mut s = String::new();\n-    let _ = s.write_fmt(*msg);\n-    rust_panic_with_hook(Box::new(s), Some(msg), file_line_col)\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), Some(msg), file_line_col);\n+\n+    struct PanicPayload<'a> {\n+        inner: &'a fmt::Arguments<'a>,\n+        string: Option<String>,\n+    }\n+\n+    impl<'a> PanicPayload<'a> {\n+        fn new(inner: &'a fmt::Arguments<'a>) -> PanicPayload<'a> {\n+            PanicPayload { inner, string: None }\n+        }\n+\n+        fn fill(&mut self) -> &mut String {\n+            let inner = self.inner;\n+            self.string.get_or_insert_with(|| {\n+                let mut s = String::new();\n+                drop(s.write_fmt(*inner));\n+                s\n+            })\n+        }\n+    }\n+\n+    unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n+        fn box_me_up(&mut self) -> *mut (Any + Send) {\n+            let contents = mem::replace(self.fill(), String::new());\n+            Box::into_raw(Box::new(contents))\n+        }\n+\n+        fn get(&mut self) -> &(Any + Send) {\n+            self.fill()\n+        }\n+    }\n }\n \n /// This is the entry point of panicking for panic!() and assert!().\n@@ -360,18 +388,42 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n     // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n-    rust_panic_with_hook(Box::new(msg), None, file_line_col)\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), None, file_line_col);\n+\n+    struct PanicPayload<A> {\n+        inner: Option<A>,\n+    }\n+\n+    impl<A: Send + 'static> PanicPayload<A> {\n+        fn new(inner: A) -> PanicPayload<A> {\n+            PanicPayload { inner: Some(inner) }\n+        }\n+    }\n+\n+    unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n+        fn box_me_up(&mut self) -> *mut (Any + Send) {\n+            let data = match self.inner.take() {\n+                Some(a) => Box::new(a) as Box<Any + Send>,\n+                None => Box::new(()),\n+            };\n+            Box::into_raw(data)\n+        }\n+\n+        fn get(&mut self) -> &(Any + Send) {\n+            match self.inner {\n+                Some(ref a) => a,\n+                None => &(),\n+            }\n+        }\n+    }\n }\n \n-/// Executes the primary logic for a panic, including checking for recursive\n-/// panics and panic hooks.\n+/// Central point for dispatching panics.\n ///\n-/// This is the entry point or panics from libcore, formatted panics, and\n-/// `Box<Any>` panics. Here we'll verify that we're not panicking recursively,\n-/// run panic hooks, and then delegate to the actual implementation of panics.\n-#[inline(never)]\n-#[cold]\n-fn rust_panic_with_hook(payload: Box<Any + Send>,\n+/// Executes the primary logic for a panic, including checking for recursive\n+/// panics, panic hooks, and finally dispatching to the panic runtime to either\n+/// abort or unwind.\n+fn rust_panic_with_hook(payload: &mut BoxMeUp,\n                         message: Option<&fmt::Arguments>,\n                         file_line_col: &(&'static str, u32, u32)) -> ! {\n     let (file, line, col) = *file_line_col;\n@@ -390,15 +442,24 @@ fn rust_panic_with_hook(payload: Box<Any + Send>,\n     }\n \n     unsafe {\n-        let info = PanicInfo::internal_constructor(\n-            &*payload,\n+        let mut info = PanicInfo::internal_constructor(\n             message,\n             Location::internal_constructor(file, line, col),\n         );\n         HOOK_LOCK.read();\n         match HOOK {\n-            Hook::Default => default_hook(&info),\n-            Hook::Custom(ptr) => (*ptr)(&info),\n+            // Some platforms know that printing to stderr won't ever actually\n+            // print anything, and if that's the case we can skip the default\n+            // hook.\n+            Hook::Default if stderr_prints_nothing() => {}\n+            Hook::Default => {\n+                info.set_payload(payload.get());\n+                default_hook(&info);\n+            }\n+            Hook::Custom(ptr) => {\n+                info.set_payload(payload.get());\n+                (*ptr)(&info);\n+            }\n         }\n         HOOK_LOCK.read_unlock();\n     }\n@@ -419,16 +480,29 @@ fn rust_panic_with_hook(payload: Box<Any + Send>,\n /// Shim around rust_panic. Called by resume_unwind.\n pub fn update_count_then_panic(msg: Box<Any + Send>) -> ! {\n     update_panic_count(1);\n-    rust_panic(msg)\n+\n+    struct RewrapBox(Box<Any + Send>);\n+\n+    unsafe impl BoxMeUp for RewrapBox {\n+        fn box_me_up(&mut self) -> *mut (Any + Send) {\n+            Box::into_raw(mem::replace(&mut self.0, Box::new(())))\n+        }\n+\n+        fn get(&mut self) -> &(Any + Send) {\n+            &*self.0\n+        }\n+    }\n+\n+    rust_panic(&mut RewrapBox(msg))\n }\n \n /// A private no-mangle function on which to slap yer breakpoints.\n #[no_mangle]\n #[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints\n-pub fn rust_panic(msg: Box<Any + Send>) -> ! {\n+pub fn rust_panic(mut msg: &mut BoxMeUp) -> ! {\n     let code = unsafe {\n-        let obj = mem::transmute::<_, raw::TraitObject>(msg);\n-        __rust_start_panic(obj.data as usize, obj.vtable as usize)\n+        let obj = &mut msg as *mut &mut BoxMeUp;\n+        __rust_start_panic(obj as usize)\n     };\n     rtabort!(\"failed to initiate panic, error {}\", code)\n }"}, {"sha": "1d7344f921c9d564d30bac0c09f86bcf7b682995", "filename": "src/libstd/sys/cloudabi/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -77,3 +77,7 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n }\n \n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n+\n+pub fn stderr_prints_nothing() -> bool {\n+    false\n+}"}, {"sha": "7a4d11b0ecb9a8c64f2845898755d6883608544e", "filename": "src/libstd/sys/redox/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -75,3 +75,7 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n }\n \n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n+\n+pub fn stderr_prints_nothing() -> bool {\n+    false\n+}"}, {"sha": "87ba2aef4f1d3dfe1e499f089b55adc4e6df5bba", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -75,3 +75,7 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n }\n \n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n+\n+pub fn stderr_prints_nothing() -> bool {\n+    false\n+}"}, {"sha": "6516010af475940f0d2f6cc0c8209db0a5cd4f76", "filename": "src/libstd/sys/wasm/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fwasm%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fwasm%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Frwlock.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -30,7 +30,7 @@ impl RWLock {\n         if *mode >= 0 {\n             *mode += 1;\n         } else {\n-            panic!(\"rwlock locked for writing\");\n+            rtabort!(\"rwlock locked for writing\");\n         }\n     }\n \n@@ -51,7 +51,7 @@ impl RWLock {\n         if *mode == 0 {\n             *mode = -1;\n         } else {\n-            panic!(\"rwlock locked for reading\")\n+            rtabort!(\"rwlock locked for reading\")\n         }\n     }\n "}, {"sha": "023f29576a27d9c4dd667b1a035d9966de5efcfe", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -69,3 +69,7 @@ pub const STDIN_BUF_SIZE: usize = 0;\n pub fn is_ebadf(_err: &io::Error) -> bool {\n     true\n }\n+\n+pub fn stderr_prints_nothing() -> bool {\n+    !cfg!(feature = \"wasm_syscall\")\n+}"}, {"sha": "81b89da21d3c60f0cf9d1574932e48403a12cc83", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -227,3 +227,7 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n // idea is that on windows we use a slightly smaller buffer that's\n // been seen to be acceptable.\n pub const STDIN_BUF_SIZE: usize = 8 * 1024;\n+\n+pub fn stderr_prints_nothing() -> bool {\n+    false\n+}"}, {"sha": "20109d2d0d5aceb5790c6d063c7c6d9b331e72eb", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -139,22 +139,21 @@ pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\n /// Controls how the backtrace should be formatted.\n #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n pub enum PrintFormat {\n-    /// Show all the frames with absolute path for files.\n-    Full = 2,\n     /// Show only relevant data from the backtrace.\n-    Short = 3,\n+    Short = 2,\n+    /// Show all the frames with absolute path for files.\n+    Full = 3,\n }\n \n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> Option<PrintFormat> {\n     static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n     match ENABLED.load(Ordering::SeqCst) {\n-        0 => {},\n+        0 => {}\n         1 => return None,\n-        2 => return Some(PrintFormat::Full),\n-        3 => return Some(PrintFormat::Short),\n-        _ => unreachable!(),\n+        2 => return Some(PrintFormat::Short),\n+        _ => return Some(PrintFormat::Full),\n     }\n \n     let val = match env::var_os(\"RUST_BACKTRACE\") {"}, {"sha": "d0c4d6a773746e70cc175de3a0866085532d6609", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -28,6 +28,16 @@\n use sync::Once;\n use sys;\n \n+macro_rules! rtabort {\n+    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n+}\n+\n+macro_rules! rtassert {\n+    ($e:expr) => (if !$e {\n+        rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n+    })\n+}\n+\n pub mod at_exit_imp;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;\n@@ -101,10 +111,6 @@ pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n     if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n }\n \n-macro_rules! rtabort {\n-    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n-}\n-\n /// One-time runtime cleanup.\n pub fn cleanup() {\n     static CLEANUP: Once = Once::new();"}, {"sha": "d0d6224de0a151376ab1e8407a9c68766c52399a", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -169,7 +169,7 @@ impl StaticKey {\n                 self.key.store(key, Ordering::SeqCst);\n             }\n             INIT_LOCK.unlock();\n-            assert!(key != 0);\n+            rtassert!(key != 0);\n             return key\n         }\n \n@@ -190,7 +190,7 @@ impl StaticKey {\n             imp::destroy(key1);\n             key2\n         };\n-        assert!(key != 0);\n+        rtassert!(key != 0);\n         match self.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n             // The CAS succeeded, so we've created the actual key\n             0 => key as usize,"}, {"sha": "a373e980b970d21263aa8389ddece4cb26442365", "filename": "src/libstd/sys_common/util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -10,10 +10,13 @@\n \n use fmt;\n use io::prelude::*;\n-use sys::stdio::Stderr;\n+use sys::stdio::{Stderr, stderr_prints_nothing};\n use thread;\n \n pub fn dumb_print(args: fmt::Arguments) {\n+    if stderr_prints_nothing() {\n+        return\n+    }\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n "}, {"sha": "40d3280baa687da385fe43d2f36b52962f67ffc7", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -172,12 +172,16 @@ macro_rules! __thread_local_inner {\n                 &'static $crate::cell::UnsafeCell<\n                     $crate::option::Option<$t>>>\n             {\n+                #[cfg(target_arch = \"wasm32\")]\n+                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n+                    $crate::thread::__StaticLocalKeyInner::new();\n+\n                 #[thread_local]\n-                #[cfg(target_thread_local)]\n+                #[cfg(all(target_thread_local, not(target_arch = \"wasm32\")))]\n                 static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                     $crate::thread::__FastLocalKeyInner::new();\n \n-                #[cfg(not(target_thread_local))]\n+                #[cfg(all(not(target_thread_local), not(target_arch = \"wasm32\")))]\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n \n@@ -295,6 +299,39 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n+/// On some platforms like wasm32 there's no threads, so no need to generate\n+/// thread locals and we can instead just use plain statics!\n+#[doc(hidden)]\n+#[cfg(target_arch = \"wasm32\")]\n+pub mod statik {\n+    use cell::UnsafeCell;\n+    use fmt;\n+\n+    pub struct Key<T> {\n+        inner: UnsafeCell<Option<T>>,\n+    }\n+\n+    unsafe impl<T> ::marker::Sync for Key<T> { }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.pad(\"Key { .. }\")\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key {\n+                inner: UnsafeCell::new(None),\n+            }\n+        }\n+\n+        pub unsafe fn get(&self) -> Option<&'static UnsafeCell<Option<T>>> {\n+            Some(&*(&self.inner as *const _))\n+        }\n+    }\n+}\n+\n #[doc(hidden)]\n #[cfg(target_thread_local)]\n pub mod fast {"}, {"sha": "1b976b79b4c989f8cc63f9470faec10bae0e8c30", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -202,6 +202,9 @@ pub use self::local::{LocalKey, AccessError};\n // where fast TLS was not available; end-user code is compiled with fast TLS\n // where available, but both are needed.\n \n+#[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n+#[cfg(target_arch = \"wasm32\")]\n+#[doc(hidden)] pub use self::local::statik::Key as __StaticLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]\n #[doc(hidden)] pub use self::local::fast::Key as __FastLocalKeyInner;"}, {"sha": "330ae300c445ee4334e67ed60e88ad53fe383243", "filename": "src/test/run-make/wasm-panic-small/Makefile", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Ftest%2Frun-make%2Fwasm-panic-small%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Ftest%2Frun-make%2Fwasm-panic-small%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-panic-small%2FMakefile?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -0,0 +1,17 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),wasm32-unknown-unknown)\n+all:\n+\t$(RUSTC) foo.rs -C lto -O --target wasm32-unknown-unknown --cfg a\n+\twc -c < $(TMPDIR)/foo.wasm\n+\t[ \"`wc -c < $(TMPDIR)/foo.wasm`\" -lt \"1024\" ]\n+\t$(RUSTC) foo.rs -C lto -O --target wasm32-unknown-unknown --cfg b\n+\twc -c < $(TMPDIR)/foo.wasm\n+\t[ \"`wc -c < $(TMPDIR)/foo.wasm`\" -lt \"5120\" ]\n+\t$(RUSTC) foo.rs -C lto -O --target wasm32-unknown-unknown --cfg c\n+\twc -c < $(TMPDIR)/foo.wasm\n+\t[ \"`wc -c < $(TMPDIR)/foo.wasm`\" -lt \"5120\" ]\n+else\n+all:\n+endif\n+"}, {"sha": "1ea724ca94d477951407704d3b4ae957d43d0429", "filename": "src/test/run-make/wasm-panic-small/foo.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Ftest%2Frun-make%2Fwasm-panic-small%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src%2Ftest%2Frun-make%2Fwasm-panic-small%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-panic-small%2Ffoo.rs?ref=3809bbf47c8557bd149b3e52ceb47434ca8378d5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"cdylib\"]\n+\n+#[no_mangle]\n+#[cfg(a)]\n+pub fn foo() {\n+    panic!(\"test\");\n+}\n+\n+#[no_mangle]\n+#[cfg(b)]\n+pub fn foo() {\n+    panic!(\"{}\", 1);\n+}\n+\n+#[no_mangle]\n+#[cfg(c)]\n+pub fn foo() {\n+    panic!(\"{}\", \"a\");\n+}"}]}