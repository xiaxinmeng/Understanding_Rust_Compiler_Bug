{"sha": "3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZTA5OWJhOGQyZjZmNGQwODVlNzQ4MGYwMjBmOWY4N2U2YjM5ZTg=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-04T13:50:53Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:37:16Z"}, "message": "move iter_next_slice to its own module", "tree": {"sha": "98a3f8ae8adfe05a01c4af3a7f0dc0a811860f7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a3f8ae8adfe05a01c4af3a7f0dc0a811860f7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8", "html_url": "https://github.com/rust-lang/rust/commit/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db91d9cf9a620cc258ab84a152a9333351ac166e", "url": "https://api.github.com/repos/rust-lang/rust/commits/db91d9cf9a620cc258ab84a152a9333351ac166e", "html_url": "https://github.com/rust-lang/rust/commit/db91d9cf9a620cc258ab84a152a9333351ac166e"}], "stats": {"total": 134, "additions": 73, "deletions": 61}, "files": [{"sha": "3c03a949cfed09138abaedf02b9f500db27ca92b", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8", "patch": "@@ -0,0 +1,68 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{get_parent_expr, higher, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::ITER_NEXT_SLICE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+    let caller_expr = &iter_args[0];\n+\n+    // Skip lint if the `iter().next()` expression is a for loop argument,\n+    // since it is already covered by `&loops::ITER_NEXT_LOOP`\n+    let mut parent_expr_opt = get_parent_expr(cx, expr);\n+    while let Some(parent_expr) = parent_expr_opt {\n+        if higher::for_loop(parent_expr).is_some() {\n+            return;\n+        }\n+        parent_expr_opt = get_parent_expr(cx, parent_expr);\n+    }\n+\n+    if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n+        // caller is a Slice\n+        if_chain! {\n+            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n+            if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n+                = higher::range(index_expr);\n+            if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n+            if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_NEXT_SLICE,\n+                    expr.span,\n+                    \"using `.iter().next()` on a Slice without end index\",\n+                    \"try calling\",\n+                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n+                    applicability,\n+                );\n+            }\n+        }\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n+        || matches!(\n+            &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n+            ty::Array(_, _)\n+        )\n+    {\n+        // caller is a Vec or an Array\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_NEXT_SLICE,\n+            expr.span,\n+            \"using `.iter().next()` on an array\",\n+            \"try calling\",\n+            format!(\n+                \"{}.get(0)\",\n+                snippet_with_applicability(cx, caller_expr.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "46c9524af553649c37d8b52f5db60a8c8672014a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 61, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=3fe099ba8d2f6f4d085e7480f020f9f87e6b39e8", "patch": "@@ -10,6 +10,7 @@ mod inefficient_to_string;\n mod inspect_for_each;\n mod iter_cloned_collect;\n mod iter_count;\n+mod iter_next_slice;\n mod manual_saturating_arithmetic;\n mod map_collect_result_unit;\n mod ok_expect;\n@@ -46,9 +47,9 @@ use crate::consts::{constant, Constant};\n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    contains_return, contains_ty, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    in_macro, is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path,\n-    match_qpath, match_trait_method, match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths,\n+    contains_return, contains_ty, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro,\n+    is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n+    match_trait_method, match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths,\n     remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n     span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, strip_pat_refs, sugg, walk_ptrs_ty_depth,\n     SpanlessEq,\n@@ -1688,7 +1689,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             },\n             [\"next\", \"filter\"] => filter_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => skip_while_next::check(cx, expr, arg_lists[1]),\n-            [\"next\", \"iter\"] => lint_iter_next(cx, expr, arg_lists[1]),\n+            [\"next\", \"iter\"] => iter_next_slice::check(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, false),\n             [\"map\", \"filter_map\"] => lint_filter_map_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1], self.msrv.as_ref()),\n@@ -2598,63 +2599,6 @@ fn lint_step_by<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx\n     }\n }\n \n-fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n-    let caller_expr = &iter_args[0];\n-\n-    // Skip lint if the `iter().next()` expression is a for loop argument,\n-    // since it is already covered by `&loops::ITER_NEXT_LOOP`\n-    let mut parent_expr_opt = get_parent_expr(cx, expr);\n-    while let Some(parent_expr) = parent_expr_opt {\n-        if higher::for_loop(parent_expr).is_some() {\n-            return;\n-        }\n-        parent_expr_opt = get_parent_expr(cx, parent_expr);\n-    }\n-\n-    if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n-        // caller is a Slice\n-        if_chain! {\n-            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n-            if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n-                = higher::range(index_expr);\n-            if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n-            if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    ITER_NEXT_SLICE,\n-                    expr.span,\n-                    \"using `.iter().next()` on a Slice without end index\",\n-                    \"try calling\",\n-                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n-                    applicability,\n-                );\n-            }\n-        }\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n-        || matches!(\n-            &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n-            ty::Array(_, _)\n-        )\n-    {\n-        // caller is a Vec or an Array\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            ITER_NEXT_SLICE,\n-            expr.span,\n-            \"using `.iter().next()` on an array\",\n-            \"try calling\",\n-            format!(\n-                \"{}.get(0)\",\n-                snippet_with_applicability(cx, caller_expr.span, \"..\", &mut applicability)\n-            ),\n-            applicability,\n-        );\n-    }\n-}\n-\n fn lint_iter_nth<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,"}]}