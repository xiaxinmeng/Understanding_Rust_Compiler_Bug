{"sha": "c36dcff0056a4a48651b778ed272aba80f6edd93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNmRjZmYwMDU2YTRhNDg2NTFiNzc4ZWQyNzJhYmE4MGY2ZWRkOTM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-14T08:34:54Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-14T08:34:54Z"}, "message": "forbid calling functions through pointers of a different type", "tree": {"sha": "9b22d65037acd10176b63a8ad3433f8706ef191a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b22d65037acd10176b63a8ad3433f8706ef191a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c36dcff0056a4a48651b778ed272aba80f6edd93", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXX8GuAAoJEFbW7qD8Z6xGsIoP/1F4XKKorX110XG0MJ6jmGz1\njVciYQt7gT6LSAVQZ/eiMLf18hvV3HpNbrRmn9GVcV1koih+ngbEMJoPYeZVmnpi\nxo+mfsn/hWHrG2ooq6wBB9l1Yd2EaOFiMuYajqN9oDcUmirM21frCBvW2wyyw858\nElpHvL5HpDFesVTRNVyeHPjEVqHbJ5oJu9u+Hd212j23eJHYrXkf/21l6WC6nSpL\nJMPUmbrW28GGvUWrB9hfQ+68IRvyKIljz/gQF+v+M7RqiX1SnA4G3OdWFlP4iyh7\ne6uMnyGABLO7joaZgjyQZO1ktP//M0epwn3Dg75QPA++3c34XCl702sJTEMTE2EJ\nwO0dmt77/F5id8TpjgWXF9ND5Yr63YpR1FUqu/EWCSpe3xwbawaA9UT1GndZoYiw\nr4R09/cnVkZtxEw7XlumkRphE+VCd4PaoiPWt9uIc180+tN+ArEPRQdTtw//074c\nHs6kcPXvgx6G5OhLNYCjrDnxHnsQxWPzA9Bbq0BvnlijinxF0BbjZp35De7mNbtm\npJBAMcyZEOlno8Sg8yyZhJGannySkx/8Nf2GY8/j1MdyJurcwQKA+fWIkKZnwKe0\naN7B1Eg2JqtZzcAse+eMx4tgG7FldHMnMtpS+FKL8xMKZObWdFAWYPhBPxK7q/31\nneQuoWeSZYSYu9bqsWyD\n=Iy4o\n-----END PGP SIGNATURE-----", "payload": "tree 9b22d65037acd10176b63a8ad3433f8706ef191a\nparent 55fd060cd885023f918f4e5c5f910523fa7dfd52\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465893294 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465893294 +0200\n\nforbid calling functions through pointers of a different type"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c36dcff0056a4a48651b778ed272aba80f6edd93", "html_url": "https://github.com/rust-lang/rust/commit/c36dcff0056a4a48651b778ed272aba80f6edd93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c36dcff0056a4a48651b778ed272aba80f6edd93/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55fd060cd885023f918f4e5c5f910523fa7dfd52", "url": "https://api.github.com/repos/rust-lang/rust/commits/55fd060cd885023f918f4e5c5f910523fa7dfd52", "html_url": "https://github.com/rust-lang/rust/commit/55fd060cd885023f918f4e5c5f910523fa7dfd52"}], "stats": {"total": 170, "additions": 100, "deletions": 70}, "files": [{"sha": "35a978f2d2ea043965c943e31cee16ab833d81ae", "filename": "src/error.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=c36dcff0056a4a48651b778ed272aba80f6edd93", "patch": "@@ -1,10 +1,12 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir::repr as mir;\n+use rustc::ty::BareFnTy;\n use memory::Pointer;\n \n #[derive(Clone, Debug)]\n-pub enum EvalError {\n+pub enum EvalError<'tcx> {\n+    FunctionPointerTyMismatch(&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>),\n     DanglingPointerDeref,\n     InvalidFunctionPointer,\n     InvalidBool,\n@@ -24,11 +26,13 @@ pub enum EvalError {\n     ExecuteMemory,\n }\n \n-pub type EvalResult<T> = Result<T, EvalError>;\n+pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n \n-impl Error for EvalError {\n+impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n         match *self {\n+            EvalError::FunctionPointerTyMismatch(..) =>\n+                \"tried to call a function through a function pointer of a different type\",\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n             EvalError::InvalidFunctionPointer =>\n@@ -60,13 +64,15 @@ impl Error for EvalError {\n     fn cause(&self) -> Option<&Error> { None }\n }\n \n-impl fmt::Display for EvalError {\n+impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             EvalError::PointerOutOfBounds { ptr, size, allocation_size } => {\n                 write!(f, \"memory access of {}..{} outside bounds of allocation {} which has size {}\",\n                        ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n             },\n+            EvalError::FunctionPointerTyMismatch(expected, got) =>\n+                write!(f, \"tried to call a function of type {:?} through a function pointer of type {:?}\", expected, got),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "4acefb91130a44ac4f2b1e3bed03b3b44de60e50", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=c36dcff0056a4a48651b778ed272aba80f6edd93", "patch": "@@ -18,14 +18,14 @@ use syntax::attr;\n use syntax::codemap::{self, DUMMY_SP, Span};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, Pointer, FunctionDefinition};\n use primval::{self, PrimVal};\n \n use std::collections::HashMap;\n \n mod stepper;\n \n-pub fn step<'ecx, 'a: 'ecx, 'tcx: 'a>(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> EvalResult<bool> {\n+pub fn step<'ecx, 'a: 'ecx, 'tcx: 'a>(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> EvalResult<'tcx, bool> {\n     stepper::Stepper::new(ecx).step()\n }\n \n@@ -159,7 +159,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     // TODO(solson): Try making const_to_primval instead.\n-    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n+    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<'tcx, Pointer> {\n         use rustc::middle::const_val::ConstVal::*;\n         match *const_val {\n             Float(_f) => unimplemented!(),\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>)\n-            -> EvalResult<()> {\n+            -> EvalResult<'tcx, ()> {\n         use rustc::mir::repr::TerminatorKind::*;\n         match terminator.kind {\n             Return => self.pop_stack_frame(),\n@@ -434,7 +434,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let ptr = self.eval_operand(func)?;\n                         assert_eq!(ptr.offset, 0);\n                         let fn_ptr = self.memory.read_ptr(ptr)?;\n-                        let (def_id, substs) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        if fn_ty != bare_fn_ty {\n+                            return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n+                        }\n                         self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n                                           terminator.source_info.span)?\n                     },\n@@ -480,7 +483,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         return_ptr: Option<Pointer>,\n         args: &[mir::Operand<'tcx>],\n         span: Span,\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         use syntax::abi::Abi;\n         match fn_ty.abi {\n             Abi::RustIntrinsic => {\n@@ -559,7 +562,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n+    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n             return Ok(());\n@@ -601,7 +604,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n+    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty);\n \n@@ -629,7 +632,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<u64> {\n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<'tcx, u64> {\n         let not_null = match self.memory.read_usize(ptr) {\n             Ok(0) => false,\n             Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n@@ -646,7 +649,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n         dest_size: usize\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n@@ -792,7 +795,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n         dest_size: usize,\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n@@ -855,7 +858,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Pointer,\n         offsets: I,\n         operands: &[mir::Operand<'tcx>],\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         for (offset, operand) in offsets.into_iter().zip(operands) {\n             let src = self.eval_operand(operand)?;\n             let src_ty = self.operand_ty(operand);\n@@ -866,7 +869,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n-        -> EvalResult<()>\n+        -> EvalResult<'tcx, ()>\n     {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n@@ -1095,8 +1098,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs, _) => {\n-                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs);\n+                        ty::TyFnDef(def_id, substs, fn_ty) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, fn_ty);\n                             self.memory.write_ptr(dest, fn_ptr)?;\n                         },\n                         ref other => panic!(\"reify fn pointer on {:?}\", other),\n@@ -1112,7 +1115,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<Size> {\n+    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, Size> {\n         // Skip the constant 0 at the start meant for LLVM GEP.\n         let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n \n@@ -1133,7 +1136,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.field_path_offset(inner_ty, path)\n     }\n \n-    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<Size> {\n+    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<'tcx, Size> {\n         let mut offset = Size::from_bytes(0);\n \n         // Skip the initial 0 intended for LLVM GEP.\n@@ -1146,7 +1149,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(offset)\n     }\n \n-    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Ty<'tcx>> {\n+    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n         match ty.sty {\n             ty::TyStruct(adt_def, substs) => {\n                 Ok(adt_def.struct_variant().fields[field_index].ty(self.tcx, substs))\n@@ -1162,7 +1165,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n+    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Size> {\n         let layout = self.type_layout(ty);\n \n         use rustc::ty::layout::Layout::*;\n@@ -1179,7 +1182,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n+    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) => Ok(self.eval_lvalue(lvalue)?.to_ptr()),\n@@ -1213,7 +1216,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Lvalue> {\n+    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n             ReturnPointer => self.frame().return_ptr\n@@ -1321,7 +1324,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(self.mir().operand_ty(self.tcx, operand), self.substs())\n     }\n \n-    fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n+    fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         let size = self.type_size(ty);\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n@@ -1330,7 +1333,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n+    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n         let val = match (self.memory.pointer_size, &ty.sty) {\n             (_, &ty::TyBool)              => PrimVal::Bool(self.memory.read_bool(ptr)?),"}, {"sha": "367119438411482f0a4f5af7b6d38ce358dbc774", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=c36dcff0056a4a48651b778ed272aba80f6edd93", "patch": "@@ -23,15 +23,15 @@ impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n         }\n     }\n \n-    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<()> {\n+    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx, ()> {\n         trace!(\"{:?}\", stmt);\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n         self.ecx.eval_assignment(lvalue, rvalue)?;\n         self.ecx.frame_mut().stmt += 1;\n         Ok(())\n     }\n \n-    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<()> {\n+    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx, ()> {\n         // after a terminator we go to a new block\n         self.ecx.frame_mut().stmt = 0;\n         trace!(\"{:?}\", terminator.kind);\n@@ -43,7 +43,7 @@ impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n     }\n \n     // returns true as long as there are more things to do\n-    pub(super) fn step(&mut self) -> EvalResult<bool> {\n+    pub(super) fn step(&mut self) -> EvalResult<'tcx, bool> {\n         if self.ecx.stack.is_empty() {\n             return Ok(false);\n         }"}, {"sha": "e20d92207dbf2fe06a46daf10b58f44da1159e81", "filename": "src/memory.rs", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c36dcff0056a4a48651b778ed272aba80f6edd93", "patch": "@@ -4,6 +4,7 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, mem, ptr};\n \n use rustc::hir::def_id::DefId;\n+use rustc::ty::BareFnTy;\n use rustc::ty::subst::Substs;\n \n use error::{EvalError, EvalResult};\n@@ -41,6 +42,13 @@ impl Pointer {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+pub struct FunctionDefinition<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub fn_ty: &'tcx BareFnTy<'tcx>,\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -50,7 +58,7 @@ pub struct Memory<'tcx> {\n     alloc_map: HashMap<AllocId, Allocation>,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, (DefId, &'tcx Substs<'tcx>)>,\n+    functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n     next_id: AllocId,\n     pub pointer_size: usize,\n }\n@@ -68,11 +76,15 @@ impl<'tcx> Memory<'tcx> {\n \n     // FIXME: never create two pointers to the same def_id + substs combination\n     // maybe re-use the statics cache of the EvalContext?\n-    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Pointer {\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n-        self.functions.insert(id, (def_id, substs));\n+        self.functions.insert(id, FunctionDefinition {\n+            def_id: def_id,\n+            substs: substs,\n+            fn_ty: fn_ty,\n+        });\n         Pointer {\n             alloc_id: id,\n             offset: 0,\n@@ -96,7 +108,7 @@ impl<'tcx> Memory<'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<()> {\n+    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<'tcx, ()> {\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -120,7 +132,7 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<()> {\n+    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx, ()> {\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -139,7 +151,7 @@ impl<'tcx> Memory<'tcx> {\n     // Allocation accessors\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    pub fn get(&self, id: AllocId) -> EvalResult<&Allocation> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -149,7 +161,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<&mut Allocation> {\n+    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -159,7 +171,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<(DefId, &'tcx Substs<'tcx>)> {\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n             Some(&fn_id) => Ok(fn_id),\n@@ -229,7 +241,7 @@ impl<'tcx> Memory<'tcx> {\n     // Byte accessors\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n+    fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds {\n@@ -241,7 +253,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n+    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds {\n@@ -253,15 +265,15 @@ impl<'tcx> Memory<'tcx> {\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n         self.get_bytes_unchecked(ptr, size)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size)\n@@ -271,7 +283,7 @@ impl<'tcx> Memory<'tcx> {\n     // Reading and writing\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked_mut(src, size)?.as_mut_ptr();\n@@ -294,27 +306,27 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n+    pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         self.get_bytes(ptr, size)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<()> {\n+    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx, ()> {\n         let bytes = self.get_bytes_mut(ptr, src.len())?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<()> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<'tcx, ()> {\n         let bytes = self.get_bytes_mut(ptr, count)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }\n \n-    pub fn drop_fill(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    pub fn drop_fill(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         self.write_repeat(ptr, mem::POST_DROP_U8, size)\n     }\n \n-    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<Pointer> {\n+    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, Pointer> {\n         let size = self.pointer_size;\n         self.check_defined(ptr, size)?;\n         let offset = self.get_bytes_unchecked(ptr, size)?\n@@ -326,7 +338,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<()> {\n+    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx, ()> {\n         {\n             let size = self.pointer_size;\n             let mut bytes = self.get_bytes_mut(dest, size)?;\n@@ -336,7 +348,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<()> {\n+    pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n         let pointer_size = self.pointer_size;\n         match val {\n             PrimVal::Bool(b) => self.write_bool(ptr, b),\n@@ -353,7 +365,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<bool> {\n+    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n         let bytes = self.get_bytes(ptr, 1)?;\n         match bytes[0] {\n             0 => Ok(false),\n@@ -362,40 +374,40 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<()> {\n+    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx, ()> {\n         self.get_bytes_mut(ptr, 1).map(|bytes| bytes[0] = b as u8)\n     }\n \n-    pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<i64> {\n+    pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, i64> {\n         self.get_bytes(ptr, size).map(|mut b| b.read_int::<NativeEndian>(size).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<()> {\n+    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<'tcx, ()> {\n         self.get_bytes_mut(ptr, size).map(|mut b| b.write_int::<NativeEndian>(n, size).unwrap())\n     }\n \n-    pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<u64> {\n+    pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, u64> {\n         self.get_bytes(ptr, size).map(|mut b| b.read_uint::<NativeEndian>(size).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<()> {\n+    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<'tcx, ()> {\n         self.get_bytes_mut(ptr, size).map(|mut b| b.write_uint::<NativeEndian>(n, size).unwrap())\n     }\n \n-    pub fn read_isize(&self, ptr: Pointer) -> EvalResult<i64> {\n+    pub fn read_isize(&self, ptr: Pointer) -> EvalResult<'tcx, i64> {\n         self.read_int(ptr, self.pointer_size)\n     }\n \n-    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<()> {\n+    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx, ()> {\n         let size = self.pointer_size;\n         self.write_int(ptr, n, size)\n     }\n \n-    pub fn read_usize(&self, ptr: Pointer) -> EvalResult<u64> {\n+    pub fn read_usize(&self, ptr: Pointer) -> EvalResult<'tcx, u64> {\n         self.read_uint(ptr, self.pointer_size)\n     }\n \n-    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<()> {\n+    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx, ()> {\n         let size = self.pointer_size;\n         self.write_uint(ptr, n, size)\n     }\n@@ -405,14 +417,14 @@ impl<'tcx> Memory<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     fn relocations(&self, ptr: Pointer, size: usize)\n-        -> EvalResult<btree_map::Range<usize, AllocId>>\n+        -> EvalResult<'tcx, btree_map::Range<usize, AllocId>>\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Included(&start), Excluded(&end)))\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n@@ -436,7 +448,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n         let overlapping_end = self.relocations(ptr.offset(size as isize), 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n@@ -445,7 +457,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -461,7 +473,7 @@ impl<'tcx> Memory<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         let mut v = Vec::with_capacity(size);\n         for i in 0..size {\n@@ -474,7 +486,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n@@ -483,7 +495,7 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer, size: usize, new_state: bool)\n-        -> EvalResult<()>\n+        -> EvalResult<'tcx, ()>\n     {\n         let mut alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);"}, {"sha": "5e1cdac45a1fb2fd68e3fd1818e85f0c3c6fa471", "filename": "src/primval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36dcff0056a4a48651b778ed272aba80f6edd93/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=c36dcff0056a4a48651b778ed272aba80f6edd93", "patch": "@@ -13,7 +13,7 @@ pub enum PrimVal {\n     IntegerPtr(u64),\n }\n \n-pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<PrimVal> {\n+pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::repr::BinOp::*;\n     use self::PrimVal::*;\n \n@@ -43,7 +43,7 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n         })\n     }\n \n-    fn unrelated_ptr_ops(bin_op: mir::BinOp) -> EvalResult<PrimVal> {\n+    fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n         use rustc::mir::repr::BinOp::*;\n         match bin_op {\n             Eq => Ok(Bool(false)),\n@@ -108,7 +108,7 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n     Ok(val)\n }\n \n-pub fn unary_op(un_op: mir::UnOp, val: PrimVal) -> EvalResult<PrimVal> {\n+pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::repr::UnOp::*;\n     use self::PrimVal::*;\n     match (un_op, val) {"}, {"sha": "db87e9e422bd86f9f5381b797824a18071ff996d", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c36dcff0056a4a48651b778ed272aba80f6edd93/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36dcff0056a4a48651b778ed272aba80f6edd93/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=c36dcff0056a4a48651b778ed272aba80f6edd93", "patch": "@@ -0,0 +1,9 @@\n+fn main() { //~ ERROR tried to call a function of type\n+    fn f() {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn(), fn(i32)>(f)\n+    };\n+\n+    g(42)\n+}"}]}