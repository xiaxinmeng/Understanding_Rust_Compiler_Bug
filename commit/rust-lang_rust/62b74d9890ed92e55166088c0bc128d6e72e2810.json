{"sha": "62b74d9890ed92e55166088c0bc128d6e72e2810", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYjc0ZDk4OTBlZDkyZTU1MTY2MDg4YzBiYzEyOGQ2ZTcyZTI4MTA=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@composition.al", "date": "2014-01-02T05:22:50Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@composition.al", "date": "2014-01-06T03:03:12Z"}, "message": "Write up default methods for the tutorial.", "tree": {"sha": "1bf228b97f2711b809b7e0d480a86ec8bd8c616c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bf228b97f2711b809b7e0d480a86ec8bd8c616c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62b74d9890ed92e55166088c0bc128d6e72e2810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62b74d9890ed92e55166088c0bc128d6e72e2810", "html_url": "https://github.com/rust-lang/rust/commit/62b74d9890ed92e55166088c0bc128d6e72e2810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62b74d9890ed92e55166088c0bc128d6e72e2810/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8adbb383c456f2040e6d0cc3b487cdf6a70a7e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/8adbb383c456f2040e6d0cc3b487cdf6a70a7e13", "html_url": "https://github.com/rust-lang/rust/commit/8adbb383c456f2040e6d0cc3b487cdf6a70a7e13"}], "stats": {"total": 153, "additions": 111, "deletions": 42}, "files": [{"sha": "03370bd6bd0064761f62be85a24d216a2424aadc", "filename": "doc/tutorial.md", "status": "modified", "additions": 111, "deletions": 42, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/62b74d9890ed92e55166088c0bc128d6e72e2810/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/62b74d9890ed92e55166088c0bc128d6e72e2810/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=62b74d9890ed92e55166088c0bc128d6e72e2810", "patch": "@@ -2035,28 +2035,30 @@ C++ templates.\n \n ## Traits\n \n-Within a generic function the operations available on generic types\n-are very limited. After all, since the function doesn't know what\n-types it is operating on, it can't safely modify or query their\n-values. This is where _traits_ come into play. Traits are Rust's most\n-powerful tool for writing polymorphic code. Java developers will see\n-them as similar to Java interfaces, and Haskellers will notice their\n-similarities to type classes. Rust's traits are a form of *bounded\n-polymorphism*: a trait is a way of limiting the set of possible types\n-that a type parameter could refer to.\n-\n-As motivation, let us consider copying in Rust.\n-The `clone` method is not defined for all Rust types.\n-One reason is user-defined destructors:\n-copying a type that has a destructor\n-could result in the destructor running multiple times.\n-Therefore, types with destructors cannot be copied\n-unless you explicitly implement `Clone` for them.\n+Within a generic function -- that is, a function parameterized by a\n+type parameter, say, `T` -- the operations we can do on arguments of\n+type `T` are quite limited.  After all, since we don't know what type\n+`T` will be instantiated with, we can't safely modify or query values\n+of type `T`.  This is where _traits_ come into play. Traits are Rust's\n+most powerful tool for writing polymorphic code. Java developers will\n+see them as similar to Java interfaces, and Haskellers will notice\n+their similarities to type classes. Rust's traits give us a way to\n+express *bounded polymorphism*: by limiting the set of possible types\n+that a type parameter could refer to, they expand the number of\n+operations we can safely perform on arguments of that type.\n+\n+As motivation, let us consider copying of values in Rust.  The `clone`\n+method is not defined for values of every type.  One reason is\n+user-defined destructors: copying a value of a type that has a\n+destructor could result in the destructor running multiple times.\n+Therefore, values of types that have destructors cannot be copied\n+unless we explicitly implement `clone` for them.\n \n This complicates handling of generic functions.\n-If you have a type parameter `T`, can you copy values of that type?\n-In Rust, you can't,\n-and if you try to run the following code the compiler will complain.\n+If we have a function with a type parameter `T`,\n+can we copy values of type `T` inside that function?\n+In Rust, we can't,\n+and if we try to run the following code the compiler will complain.\n \n ~~~~ {.xfail-test}\n // This does not compile\n@@ -2066,11 +2068,10 @@ fn head_bad<T>(v: &[T]) -> T {\n ~~~~\n \n However, we can tell the compiler\n-that the `head` function is only for copyable types:\n-that is, those that implement the `Clone` trait.\n-In that case,\n-we can explicitly create a second copy of the value we are returning\n-using the `clone` keyword:\n+that the `head` function is only for copyable types.\n+In Rust, copyable types are those that _implement the `Clone` trait_.  \n+We can then explicitly create a second copy of the value we are returning\n+by calling the `clone` method:\n \n ~~~~\n // This does\n@@ -2079,12 +2080,13 @@ fn head<T: Clone>(v: &[T]) -> T {\n }\n ~~~~\n \n-This says that we can call `head` on any type `T`\n-as long as that type implements the `Clone` trait.\n+The bounded type parameter `T: Clone` says that `head` is polymorphic\n+over any type `T`, so long as there is an implementation of the\n+`Clone` trait for that type.\n When instantiating a generic function,\n-you can only instantiate it with types\n+we can only instantiate it with types\n that implement the correct trait,\n-so you could not apply `head` to a type\n+so we could not apply `head` to a vector whose elements are of some type\n that does not implement `Clone`.\n \n While most traits can be defined and implemented by user code,\n@@ -2110,7 +2112,7 @@ have the `'static` lifetime.\n > iterations of the language, and often still are.\n \n Additionally, the `Drop` trait is used to define destructors. This\n-trait defines one method called `drop`, which is automatically\n+trait provides one method called `drop`, which is automatically\n called when a value of the type that implements this trait is\n destroyed, either because the value went out of scope or because the\n garbage collector reclaimed it.\n@@ -2134,43 +2136,110 @@ may call it.\n \n ## Declaring and implementing traits\n \n-A trait consists of a set of methods without bodies,\n-or may be empty, as is the case with `Send` and `Freeze`.\n+At its simplest, a trait is a set of zero or more _method signatures_.\n For example, we could declare the trait\n `Printable` for things that can be printed to the console,\n-with a single method:\n+with a single method signature:\n \n ~~~~\n trait Printable {\n     fn print(&self);\n }\n ~~~~\n \n-Traits may be implemented for specific types with [impls]. An impl\n-that implements a trait includes the name of the trait at the start of\n-the definition, as in the following impls of `Printable` for `int`\n-and `~str`.\n+We say that the `Printable` trait _provides_ a `print` method with the\n+given signature.  This means that we can call `print` on an argument\n+of any type that implements the `Printable` trait.\n+\n+Rust's built-in `Send` and `Freeze` types are examples of traits that\n+don't provide any methods.\n+\n+Traits may be implemented for specific types with [impls]. An impl for\n+a particular trait gives an implementation of the methods that that\n+trait provides.  For instance, the following the following impls of\n+`Printable` for `int` and `~str` give implementations of the `print`\n+method.\n \n [impls]: #methods\n \n ~~~~\n # trait Printable { fn print(&self); }\n impl Printable for int {\n-    fn print(&self) { println!(\"{}\", *self) }\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for ~str {\n+    fn print(&self) { println(*self) }\n+}\n+\n+# 1.print();\n+# (~\"foo\").print();\n+~~~~\n+\n+Methods defined in an impl for a trait may be called just like\n+any other method, using dot notation, as in `1.print()`.\n+\n+## Default method implementations in trait definitions\n+\n+Sometimes, a method that a trait provides will have the same\n+implementation for most or all of the types that implement that trait.\n+For instance, suppose that we wanted `bool`s and `float`s to be\n+printable, and that we wanted the implementation of `print` for those\n+types to be exactly as it is for `int`, above:\n+\n+~~~~\n+impl Printable for float {\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for bool {\n+    fn print(&self) { println!(\"{:?}\", *self) }\n }\n \n+# true.print();\n+# 3.14159.print();\n+~~~~\n+\n+This works fine, but we've now repeated the same definition of `print`\n+in three places.  Instead of doing that, we can simply include the\n+definition of `print` right in the trait definition, instead of just\n+giving its signature.  That is, we can write the following:\n+\n+~~~~\n+trait Printable {\n+\t// Default method implementation\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for int {}\n+\n impl Printable for ~str {\n     fn print(&self) { println(*self) }\n }\n \n+impl Printable for bool {}\n+\n+impl Printable for float {}\n+\n # 1.print();\n # (~\"foo\").print();\n+# true.print();\n+# 3.14159.print();\n ~~~~\n \n-Methods defined in an implementation of a trait may be called just like\n-any other method, using dot notation, as in `1.print()`. Traits may\n-themselves contain type parameters. A trait for generalized sequence\n-types might look like the following:\n+Here, the impls of `Printable` for `int`, `bool`, and `float` don't\n+need to provide an implementation of `print`, because in the absence\n+of a specific implementation, Rust just uses the _default method_\n+provided in the trait definition.  Depending on the trait, default\n+methods can save a great deal of boilerplate code from having to be\n+written in impls.  Of course, individual impls can still override the\n+default method for `print`, as is being done above in the impl for\n+`~str`.\n+\n+## Type-parameterized traits\n+\n+Traits may be parameterized by type variables.  For example, a trait\n+for generalized sequence types might look like the following:\n \n ~~~~\n trait Seq<T> {"}]}