{"sha": "1be9ec54437c396acf64ed9be75270752ab5abad", "node_id": "C_kwDOAAsO6NoAKDFiZTllYzU0NDM3YzM5NmFjZjY0ZWQ5YmU3NTI3MDc1MmFiNWFiYWQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-29T12:43:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-29T12:43:19Z"}, "message": "Rollup merge of #102336 - compiler-errors:issue-102333, r=jackh726\n\nFix associated type bindings with anon const in GAT position\n\nThe first commit formats `type_of.rs`, which is really hard to maintain since it uses a bunch of features like `let`-chains and `if let` match arm bindings. Best if you just review the second two diffs.\n\nFixes #102333", "tree": {"sha": "e761d65b8024a42d1b3e8830389fc9e4ad7b79e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e761d65b8024a42d1b3e8830389fc9e4ad7b79e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be9ec54437c396acf64ed9be75270752ab5abad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjNZLnCRBK7hj4Ov3rIwAARGIIAAsRq6dx/W/OpOYHhktFBC54\nIziMKHVt7zRMtxe45ZyI/kdZ5YbRuApHcsV051s4nsiwRgGC9IfeZ+8l73UYAai3\nSGVSxd5rPvovMtsmcGzC/cIF4i2T+TaJhpfM+0wN0rvIBR07Q6dQ+D4FhREyPCvE\n6n9GVxzJf4ieurcJ3R3kQmkuHN4Hq1EkBoGD+wvtlimJjzlUPlFtIcO+W9bHU2VJ\nlMh3s07nrY/adonZZaTyj6IWlRD3/WuettKwctH0XcWwo7B5cr9twCUMiI2HH1EU\nueIyDgPhCXpNj6Ij39dycI283nByRM/CeE2bpWSs+AysOCgYLxv6UG+UHu3SU6o=\n=91me\n-----END PGP SIGNATURE-----\n", "payload": "tree e761d65b8024a42d1b3e8830389fc9e4ad7b79e3\nparent 8a497b7181cad4ae66dbd6cc31042b69b6bd0df7\nparent 92561f43f185b54c81167ddc89fbe2dcd94b4efb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1664455399 +0530\ncommitter GitHub <noreply@github.com> 1664455399 +0530\n\nRollup merge of #102336 - compiler-errors:issue-102333, r=jackh726\n\nFix associated type bindings with anon const in GAT position\n\nThe first commit formats `type_of.rs`, which is really hard to maintain since it uses a bunch of features like `let`-chains and `if let` match arm bindings. Best if you just review the second two diffs.\n\nFixes #102333\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be9ec54437c396acf64ed9be75270752ab5abad", "html_url": "https://github.com/rust-lang/rust/commit/1be9ec54437c396acf64ed9be75270752ab5abad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be9ec54437c396acf64ed9be75270752ab5abad/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a497b7181cad4ae66dbd6cc31042b69b6bd0df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a497b7181cad4ae66dbd6cc31042b69b6bd0df7", "html_url": "https://github.com/rust-lang/rust/commit/8a497b7181cad4ae66dbd6cc31042b69b6bd0df7"}, {"sha": "92561f43f185b54c81167ddc89fbe2dcd94b4efb", "url": "https://api.github.com/repos/rust-lang/rust/commits/92561f43f185b54c81167ddc89fbe2dcd94b4efb", "html_url": "https://github.com/rust-lang/rust/commit/92561f43f185b54c81167ddc89fbe2dcd94b4efb"}], "stats": {"total": 132, "additions": 102, "deletions": 30}, "files": [{"sha": "f8a62c849107632b68bd7e60a3d0106fcc2e5c71", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 87, "deletions": 30, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1be9ec54437c396acf64ed9be75270752ab5abad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be9ec54437c396acf64ed9be75270752ab5abad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=1be9ec54437c396acf64ed9be75270752ab5abad", "patch": "@@ -333,7 +333,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     find_opaque_ty_constraints_for_tait(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner), in_trait, .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy {\n+                    origin:\n+                        hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner),\n+                    in_trait,\n+                    ..\n+                }) => {\n                     if in_trait {\n                         span_bug!(item.span, \"impl-trait in trait has no default\")\n                     } else {\n@@ -378,7 +383,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::Field(field) => icx.to_ty(field.ty),\n \n-        Node::Expr(&Expr { kind: ExprKind::Closure{..}, .. }) => tcx.typeck(def_id).node_type(hir_id),\n+        Node::Expr(&Expr { kind: ExprKind::Closure { .. }, .. }) => {\n+            tcx.typeck(def_id).node_type(hir_id)\n+        }\n \n         Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n             // We defer to `type_of` of the corresponding parameter\n@@ -410,40 +417,91 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n                     if asm.operands.iter().any(|(op, _op_sp)| match op {\n                         hir::InlineAsmOperand::Const { anon_const }\n-                        | hir::InlineAsmOperand::SymFn { anon_const } => anon_const.hir_id == hir_id,\n+                        | hir::InlineAsmOperand::SymFn { anon_const } => {\n+                            anon_const.hir_id == hir_id\n+                        }\n                         _ => false,\n                     }) =>\n                 {\n                     tcx.typeck(def_id).node_type(hir_id)\n                 }\n \n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => tcx\n-                    .adt_def(tcx.hir().get_parent_item(hir_id))\n-                    .repr()\n-                    .discr_type()\n-                    .to_ty(tcx),\n+                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                    tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n+                }\n \n-                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n-                    if let Node::TraitRef(trait_ref) = tcx.hir().get(\n-                        tcx.hir().get_parent_node(binding_id)\n-                    ) =>\n+                Node::TypeBinding(\n+                    binding @ &TypeBinding {\n+                        hir_id: binding_id,\n+                        kind: TypeBindingKind::Equality { term: Term::Const(ref e) },\n+                        ..\n+                    },\n+                ) if let Node::TraitRef(trait_ref) =\n+                    tcx.hir().get(tcx.hir().get_parent_node(binding_id))\n+                    && e.hir_id == hir_id =>\n                 {\n-                  let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                    return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n-                  };\n-                  let assoc_items = tcx.associated_items(trait_def_id);\n-                  let assoc_item = assoc_items.find_by_name_and_kind(\n-                    tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n-                  );\n-                  if let Some(assoc_item) = assoc_item {\n-                    tcx.type_of(assoc_item.def_id)\n-                  } else {\n-                      // FIXME(associated_const_equality): add a useful error message here.\n-                      tcx.ty_error_with_message(\n-                        DUMMY_SP,\n-                        \"Could not find associated const on trait\",\n-                    )\n-                  }\n+                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                        return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                    };\n+                    let assoc_items = tcx.associated_items(trait_def_id);\n+                    let assoc_item = assoc_items.find_by_name_and_kind(\n+                        tcx,\n+                        binding.ident,\n+                        ty::AssocKind::Const,\n+                        def_id.to_def_id(),\n+                    );\n+                    if let Some(assoc_item) = assoc_item {\n+                        tcx.type_of(assoc_item.def_id)\n+                    } else {\n+                        // FIXME(associated_const_equality): add a useful error message here.\n+                        tcx.ty_error_with_message(\n+                            DUMMY_SP,\n+                            \"Could not find associated const on trait\",\n+                        )\n+                    }\n+                }\n+\n+                Node::TypeBinding(\n+                    binding @ &TypeBinding { hir_id: binding_id, gen_args, ref kind, .. },\n+                ) if let Node::TraitRef(trait_ref) =\n+                    tcx.hir().get(tcx.hir().get_parent_node(binding_id))\n+                    && let Some((idx, _)) =\n+                        gen_args.args.iter().enumerate().find(|(_, arg)| {\n+                            if let GenericArg::Const(ct) = arg {\n+                                ct.value.hir_id == hir_id\n+                            } else {\n+                                false\n+                            }\n+                        }) =>\n+                {\n+                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                        return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                    };\n+                    let assoc_items = tcx.associated_items(trait_def_id);\n+                    let assoc_item = assoc_items.find_by_name_and_kind(\n+                        tcx,\n+                        binding.ident,\n+                        match kind {\n+                            // I think `<A: T>` type bindings requires that `A` is a type\n+                            TypeBindingKind::Constraint { .. }\n+                            | TypeBindingKind::Equality { term: Term::Ty(..) } => {\n+                                ty::AssocKind::Type\n+                            }\n+                            TypeBindingKind::Equality { term: Term::Const(..) } => {\n+                                ty::AssocKind::Const\n+                            }\n+                        },\n+                        def_id.to_def_id(),\n+                    );\n+                    if let Some(assoc_item) = assoc_item {\n+                        tcx.type_of(tcx.generics_of(assoc_item.def_id).params[idx].def_id)\n+                    } else {\n+                        // FIXME(associated_const_equality): add a useful error message here.\n+                        tcx.ty_error_with_message(\n+                            DUMMY_SP,\n+                            \"Could not find associated const on trait\",\n+                        )\n+                    }\n                 }\n \n                 Node::GenericParam(&GenericParam {\n@@ -452,8 +510,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     ..\n                 }) if ct.hir_id == hir_id => tcx.type_of(tcx.hir().local_def_id(param_hir_id)),\n \n-                x =>\n-                  tcx.ty_error_with_message(\n+                x => tcx.ty_error_with_message(\n                     DUMMY_SP,\n                     &format!(\"unexpected const parent in type_of(): {x:?}\"),\n                 ),"}, {"sha": "6c72563322f55f3fca0639758033bad7ac663dcf", "filename": "src/test/ui/generic-associated-types/issue-102333.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1be9ec54437c396acf64ed9be75270752ab5abad/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be9ec54437c396acf64ed9be75270752ab5abad/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102333.rs?ref=1be9ec54437c396acf64ed9be75270752ab5abad", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+trait A {\n+    type T: B<U<1i32> = ()>;\n+}\n+\n+trait B {\n+    type U<const C: i32>;\n+}\n+\n+fn f<T: A>() {\n+    let _: <<T as A>::T as B>::U<1i32> = ();\n+}\n+\n+fn main() {}"}]}