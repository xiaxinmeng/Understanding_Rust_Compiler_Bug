{"sha": "a5560a6a90f08a84728802bb5fa5632a17a78672", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTYwYTZhOTBmMDhhODQ3Mjg4MDJiYjVmYTU2MzJhMTdhNzg2NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-18T14:48:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-18T14:48:53Z"}, "message": "Auto merge of #85437 - GuillaumeGomez:rollup-3jcirty, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #84587 (rustdoc: Make \"rust code block is empty\" and \"could not parse code block\" warnings a lint (`INVALID_RUST_CODEBLOCKS`))\n - #85280 (Toggle-wrap items differently than top-doc.)\n - #85338 (Implement more Iterator methods on core::iter::Repeat)\n - #85339 (Report an error if a lang item has the wrong number of generic arguments)\n - #85369 (Suggest borrowing if a trait implementation is found for &/&mut <type>)\n - #85393 (Suppress spurious errors inside `async fn`)\n - #85415 (Clean up remnants of BorrowOfPackedField)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "28ab40600d50d390d67e8aab29b871fe65bf65ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28ab40600d50d390d67e8aab29b871fe65bf65ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5560a6a90f08a84728802bb5fa5632a17a78672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5560a6a90f08a84728802bb5fa5632a17a78672", "html_url": "https://github.com/rust-lang/rust/commit/a5560a6a90f08a84728802bb5fa5632a17a78672", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5560a6a90f08a84728802bb5fa5632a17a78672/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b9d1e102123ca913cf5306079400f753515768", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b9d1e102123ca913cf5306079400f753515768", "html_url": "https://github.com/rust-lang/rust/commit/70b9d1e102123ca913cf5306079400f753515768"}, {"sha": "f4a0d97def604dd50610deee0f95100de325f678", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a0d97def604dd50610deee0f95100de325f678", "html_url": "https://github.com/rust-lang/rust/commit/f4a0d97def604dd50610deee0f95100de325f678"}], "stats": {"total": 933, "additions": 800, "deletions": 133}, "files": [{"sha": "0edb79fdbc8e86d105cb1f9bd0e26ca8740198f3", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -32,7 +32,6 @@ pub enum UnsafetyViolationDetails {\n     UseOfInlineAssembly,\n     InitializingTypeWith,\n     CastOfPointerToInt,\n-    BorrowOfPackedField,\n     UseOfMutableStatic,\n     UseOfExternStatic,\n     DerefOfRawPointer,\n@@ -64,11 +63,6 @@ impl UnsafetyViolationDetails {\n             CastOfPointerToInt => {\n                 (\"cast of pointer to int\", \"casting pointers to integers in constants\")\n             }\n-            BorrowOfPackedField => (\n-                \"borrow of packed field\",\n-                \"fields of packed structs might be misaligned: dereferencing a misaligned pointer \\\n-                 or even just creating a misaligned reference is undefined behavior\",\n-            ),\n             UseOfMutableStatic => (\n                 \"use of mutable static\",\n                 \"mutable statics can be mutated by multiple threads: aliasing violations or data \\"}, {"sha": "f4d78ac04cb029832ac6bf40d8f19033c6e825a4", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -1241,7 +1241,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// it. However, it works pretty well in practice. In particular,\n     /// this is needed to deal with projection outlives bounds like\n     ///\n-    /// ```ignore (internal compiler representation so lifetime syntax is invalid)\n+    /// ```text\n     /// <T as Foo<'0>>::Item: '1\n     /// ```\n     ///"}, {"sha": "32799cbf4c7dd5ca605d5756829be63b1b9794be", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -64,38 +64,30 @@ impl<'tcx> UnsafetyVisitor<'tcx> {\n             SafetyContext::UnsafeFn if unsafe_op_in_unsafe_fn_allowed => {}\n             SafetyContext::UnsafeFn => {\n                 // unsafe_op_in_unsafe_fn is disallowed\n-                if kind == BorrowOfPackedField {\n-                    // FIXME handle borrows of packed fields\n-                } else {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0133,\n-                        \"{} is unsafe and requires unsafe block\",\n-                        description,\n-                    )\n-                    .span_label(span, description)\n-                    .note(note)\n-                    .emit();\n-                }\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0133,\n+                    \"{} is unsafe and requires unsafe block\",\n+                    description,\n+                )\n+                .span_label(span, description)\n+                .note(note)\n+                .emit();\n             }\n             SafetyContext::Safe => {\n-                if kind == BorrowOfPackedField {\n-                    // FIXME handle borrows of packed fields\n-                } else {\n-                    let fn_sugg = if unsafe_op_in_unsafe_fn_allowed { \" function or\" } else { \"\" };\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0133,\n-                        \"{} is unsafe and requires unsafe{} block\",\n-                        description,\n-                        fn_sugg,\n-                    )\n-                    .span_label(span, description)\n-                    .note(note)\n-                    .emit();\n-                }\n+                let fn_sugg = if unsafe_op_in_unsafe_fn_allowed { \" function or\" } else { \"\" };\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0133,\n+                    \"{} is unsafe and requires unsafe{} block\",\n+                    description,\n+                    fn_sugg,\n+                )\n+                .span_label(span, description)\n+                .note(note)\n+                .emit();\n             }\n         }\n     }\n@@ -203,8 +195,6 @@ enum UnsafeOpKind {\n     #[allow(dead_code)] // FIXME\n     CastOfPointerToInt,\n     #[allow(dead_code)] // FIXME\n-    BorrowOfPackedField,\n-    #[allow(dead_code)] // FIXME\n     UseOfMutableStatic,\n     #[allow(dead_code)] // FIXME\n     UseOfExternStatic,\n@@ -244,11 +234,6 @@ impl UnsafeOpKind {\n             CastOfPointerToInt => {\n                 (\"cast of pointer to int\", \"casting pointers to integers in constants\")\n             }\n-            BorrowOfPackedField => (\n-                \"borrow of packed field\",\n-                \"fields of packed structs might be misaligned: dereferencing a misaligned pointer \\\n-                 or even just creating a misaligned reference is undefined behavior\",\n-            ),\n             UseOfMutableStatic => (\n                 \"use of mutable static\",\n                 \"mutable statics can be mutated by multiple threads: aliasing violations or data \\"}, {"sha": "118fcca4508eacf9af643fde1bd61d0c355b693e", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 124, "deletions": 3, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -13,12 +13,13 @@ use crate::weak_lang_items;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::ty::TyCtxt;\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::{extract, ITEM_REFS};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n+use rustc_span::Span;\n \n use rustc_middle::ty::query::Providers;\n \n@@ -61,8 +62,7 @@ impl LanguageItemCollector<'tcx> {\n             match ITEM_REFS.get(&value).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(hir_id);\n-                    self.collect_item(item_index, def_id.to_def_id());\n+                    self.collect_item_extended(item_index, hir_id, span);\n                 }\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {\n@@ -180,6 +180,127 @@ impl LanguageItemCollector<'tcx> {\n             self.items.groups[group as usize].push(item_def_id);\n         }\n     }\n+\n+    // Like collect_item() above, but also checks whether the lang item is declared\n+    // with the right number of generic arguments if it is a trait.\n+    fn collect_item_extended(&mut self, item_index: usize, hir_id: HirId, span: Span) {\n+        let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+        let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n+        let name = lang_item.name();\n+\n+        self.collect_item(item_index, item_def_id);\n+\n+        // Now check whether the lang_item has the expected number of generic\n+        // arguments if it is a trait. Generally speaking, binary and indexing\n+        // operations have one (for the RHS/index), unary operations have none,\n+        // and the rest also have none except for the closure traits (one for\n+        // the argument list), generators (one for the resume argument),\n+        // ordering/equality relations (one for the RHS), and various conversion\n+        // traits.\n+\n+        let expected_num = match lang_item {\n+            // Binary operations\n+            LangItem::Add\n+            | LangItem::Sub\n+            | LangItem::Mul\n+            | LangItem::Div\n+            | LangItem::Rem\n+            | LangItem::BitXor\n+            | LangItem::BitAnd\n+            | LangItem::BitOr\n+            | LangItem::Shl\n+            | LangItem::Shr\n+            | LangItem::AddAssign\n+            | LangItem::SubAssign\n+            | LangItem::MulAssign\n+            | LangItem::DivAssign\n+            | LangItem::RemAssign\n+            | LangItem::BitXorAssign\n+            | LangItem::BitAndAssign\n+            | LangItem::BitOrAssign\n+            | LangItem::ShlAssign\n+            | LangItem::ShrAssign\n+            | LangItem::Index\n+            | LangItem::IndexMut\n+\n+            // Miscellaneous\n+            | LangItem::Unsize\n+            | LangItem::CoerceUnsized\n+            | LangItem::DispatchFromDyn\n+            | LangItem::Fn\n+            | LangItem::FnMut\n+            | LangItem::FnOnce\n+            | LangItem::Generator\n+            | LangItem::PartialEq\n+            | LangItem::PartialOrd\n+                => Some(1),\n+\n+            // Unary operations\n+            LangItem::Neg\n+            | LangItem::Not\n+\n+            // Miscellaneous\n+            | LangItem::Deref\n+            | LangItem::DerefMut\n+            | LangItem::Sized\n+            | LangItem::StructuralPeq\n+            | LangItem::StructuralTeq\n+            | LangItem::Copy\n+            | LangItem::Clone\n+            | LangItem::Sync\n+            | LangItem::DiscriminantKind\n+            | LangItem::PointeeTrait\n+            | LangItem::Freeze\n+            | LangItem::Drop\n+            | LangItem::Receiver\n+            | LangItem::Future\n+            | LangItem::Unpin\n+            | LangItem::Termination\n+            | LangItem::Try\n+            | LangItem::Send\n+            | LangItem::UnwindSafe\n+            | LangItem::RefUnwindSafe\n+                => Some(0),\n+\n+            // Not a trait\n+            _ => None,\n+        };\n+\n+        if let Some(expected_num) = expected_num {\n+            let (actual_num, generics_span) = match self.tcx.hir().get(hir_id) {\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..),\n+                    ..\n+                }) => (generics.params.len(), generics.span),\n+                _ => bug!(\"op/index/deref lang item target is not a trait: {:?}\", lang_item),\n+            };\n+\n+            if expected_num != actual_num {\n+                // We are issuing E0718 \"incorrect target\" here, because while the\n+                // item kind of the target is correct, the target is still wrong\n+                // because of the wrong number of generic arguments.\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0718,\n+                    \"`{}` language item must be applied to a trait with {} generic argument{}\",\n+                    name,\n+                    expected_num,\n+                    pluralize!(expected_num)\n+                )\n+                .span_label(\n+                    generics_span,\n+                    format!(\n+                        \"this trait has {} generic argument{}, not {}\",\n+                        actual_num,\n+                        pluralize!(actual_num),\n+                        expected_num\n+                    ),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n }\n \n /// Traverses and collects all the lang items in all crates."}, {"sha": "7e67bc118ec1e2821fd0c509bea0cfba37d48349", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -46,6 +46,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// type Foo = impl Baz;\n     /// fn bar() -> Foo {\n     /// //          ^^^ This is the span we are looking for!\n+    /// }\n     /// ```\n     ///\n     /// In cases where the fn returns `(impl Trait, impl Trait)` or"}, {"sha": "8bbd2da5375130f432ce85e73d8e0f6d8f09adf9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -686,17 +686,36 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         }\n \n+        // Blacklist traits for which it would be nonsensical to suggest borrowing.\n+        // For instance, immutable references are always Copy, so suggesting to\n+        // borrow would always succeed, but it's probably not what the user wanted.\n+        let blacklist: Vec<_> =\n+            [LangItem::Copy, LangItem::Clone, LangItem::Unpin, LangItem::Sized, LangItem::Send]\n+                .iter()\n+                .filter_map(|lang_item| self.tcx.lang_items().require(*lang_item).ok())\n+                .collect();\n+\n         let span = obligation.cause.span;\n         let param_env = obligation.param_env;\n         let trait_ref = trait_ref.skip_binder();\n \n-        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n-            // Try to apply the original trait binding obligation by borrowing.\n-            let self_ty = trait_ref.self_ty();\n-            let found = self_ty.to_string();\n-            let new_self_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, self_ty);\n-            let substs = self.tcx.mk_substs_trait(new_self_ty, &[]);\n-            let new_trait_ref = ty::TraitRef::new(obligation.parent_trait_ref.def_id(), substs);\n+        let found_ty = trait_ref.self_ty();\n+        let found_ty_str = found_ty.to_string();\n+        let imm_borrowed_found_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, found_ty);\n+        let imm_substs = self.tcx.mk_substs_trait(imm_borrowed_found_ty, &[]);\n+        let mut_borrowed_found_ty = self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, found_ty);\n+        let mut_substs = self.tcx.mk_substs_trait(mut_borrowed_found_ty, &[]);\n+\n+        // Try to apply the original trait binding obligation by borrowing.\n+        let mut try_borrowing = |new_trait_ref: ty::TraitRef<'tcx>,\n+                                 expected_trait_ref: ty::TraitRef<'tcx>,\n+                                 mtbl: bool,\n+                                 blacklist: &[DefId]|\n+         -> bool {\n+            if blacklist.contains(&expected_trait_ref.def_id) {\n+                return false;\n+            }\n+\n             let new_obligation = Obligation::new(\n                 ObligationCause::dummy(),\n                 param_env,\n@@ -713,8 +732,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                     let msg = format!(\n                         \"the trait bound `{}: {}` is not satisfied\",\n-                        found,\n-                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                        found_ty_str,\n+                        expected_trait_ref.print_only_trait_path(),\n                     );\n                     if has_custom_message {\n                         err.note(&msg);\n@@ -730,7 +749,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         &format!(\n                             \"expected an implementor of trait `{}`\",\n-                            obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                            expected_trait_ref.print_only_trait_path(),\n                         ),\n                     );\n \n@@ -745,16 +764,52 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                         err.span_suggestion(\n                             span,\n-                            \"consider borrowing here\",\n-                            format!(\"&{}\", snippet),\n+                            &format!(\n+                                \"consider{} borrowing here\",\n+                                if mtbl { \" mutably\" } else { \"\" }\n+                            ),\n+                            format!(\"&{}{}\", if mtbl { \"mut \" } else { \"\" }, snippet),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n                     return true;\n                 }\n             }\n+            return false;\n+        };\n+\n+        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n+            let expected_trait_ref = obligation.parent_trait_ref.skip_binder();\n+            let new_imm_trait_ref =\n+                ty::TraitRef::new(obligation.parent_trait_ref.def_id(), imm_substs);\n+            let new_mut_trait_ref =\n+                ty::TraitRef::new(obligation.parent_trait_ref.def_id(), mut_substs);\n+            if try_borrowing(new_imm_trait_ref, expected_trait_ref, false, &[]) {\n+                return true;\n+            } else {\n+                return try_borrowing(new_mut_trait_ref, expected_trait_ref, true, &[]);\n+            }\n+        } else if let ObligationCauseCode::BindingObligation(_, _)\n+        | ObligationCauseCode::ItemObligation(_) = &obligation.cause.code\n+        {\n+            if try_borrowing(\n+                ty::TraitRef::new(trait_ref.def_id, imm_substs),\n+                trait_ref,\n+                false,\n+                &blacklist[..],\n+            ) {\n+                return true;\n+            } else {\n+                return try_borrowing(\n+                    ty::TraitRef::new(trait_ref.def_id, mut_substs),\n+                    trait_ref,\n+                    true,\n+                    &blacklist[..],\n+                );\n+            }\n+        } else {\n+            false\n         }\n-        false\n     }\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,"}, {"sha": "5f26e701c0ab7803e35d38802557486ad478edd9", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -89,19 +89,31 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n-                let note = format!(\n-                    \"the type is part of the {} because of this {}\",\n-                    self.kind, yield_data.source\n-                );\n-\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 let span = self\n                     .prev_unresolved_span\n                     .unwrap_or_else(|| unresolved_type_span.unwrap_or(source_span));\n-                self.fcx\n-                    .need_type_info_err_in_generator(self.kind, span, unresolved_type)\n-                    .span_note(yield_data.span, &*note)\n-                    .emit();\n+\n+                // If we encounter an int/float variable, then inference fallback didn't\n+                // finish due to some other error. Don't emit spurious additional errors.\n+                if let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) =\n+                    unresolved_type.kind()\n+                {\n+                    self.fcx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_type));\n+                } else {\n+                    let note = format!(\n+                        \"the type is part of the {} because of this {}\",\n+                        self.kind, yield_data.source\n+                    );\n+\n+                    self.fcx\n+                        .need_type_info_err_in_generator(self.kind, span, unresolved_type)\n+                        .span_note(yield_data.span, &*note)\n+                        .emit();\n+                }\n             } else {\n                 // Insert the type into the ordered set.\n                 let scope_span = scope.map(|s| s.span(self.fcx.tcx, self.region_scope_tree));"}, {"sha": "427102afee103535dcf882c84e7ac2180fefa083", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -303,8 +303,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\n-            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?})\",\n-            self_ty, m_name, trait_def_id\n+            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?}, opt_input_types={:?})\",\n+            self_ty, m_name, trait_def_id, opt_input_types\n         );\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`"}, {"sha": "ad7853b7cd0f10282626d5a4d087ca37f6ccd822", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -1187,3 +1187,14 @@ fn fatally_break_rust(sess: &Session) {\n fn potentially_plural_count(count: usize, word: &str) -> String {\n     format!(\"{} {}{}\", count, word, pluralize!(count))\n }\n+\n+fn has_expected_num_generic_args<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_did: Option<DefId>,\n+    expected: usize,\n+) -> bool {\n+    trait_did.map_or(true, |trait_did| {\n+        let generics = tcx.generics_of(trait_did);\n+        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n+    })\n+}"}, {"sha": "963436d05d8ef30a52bac21eb8c15855f9635c4f", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -1,7 +1,7 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::method::MethodCallee;\n-use super::FnCtxt;\n+use super::{has_expected_num_generic_args, FnCtxt};\n use rustc_ast as ast;\n use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -795,6 +795,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             lhs_ty, op, opname, trait_did\n         );\n \n+        // Catches cases like #83893, where a lang item is declared with the\n+        // wrong number of generic arguments. Should have yielded an error\n+        // elsewhere by now, but we have to catch it here so that we do not\n+        // index `other_tys` out of bounds (if the lang item has too many\n+        // generic arguments, `other_tys` is too short).\n+        if !has_expected_num_generic_args(\n+            self.tcx,\n+            trait_did,\n+            match op {\n+                // Binary ops have a generic right-hand side, unary ops don't\n+                Op::Binary(..) => 1,\n+                Op::Unary(..) => 0,\n+            },\n+        ) {\n+            return Err(());\n+        }\n+\n         let method = trait_did.and_then(|trait_did| {\n             let opname = Ident::with_dummy_span(opname);\n             self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))"}, {"sha": "a63aec07ad1c086a2ef4a7a41f6387782dd195e3", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -1,5 +1,5 @@\n use crate::check::method::MethodCallee;\n-use crate::check::{FnCtxt, PlaceOp};\n+use crate::check::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n@@ -153,6 +153,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n             PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n         };\n+\n+        // If the lang item was declared incorrectly, stop here so that we don't\n+        // run into an ICE (#83893). The error is reported where the lang item is\n+        // declared.\n+        if !has_expected_num_generic_args(\n+            self.tcx,\n+            imm_tr,\n+            match op {\n+                PlaceOp::Deref => 0,\n+                PlaceOp::Index => 1,\n+            },\n+        ) {\n+            return None;\n+        }\n+\n         imm_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n                 span,\n@@ -177,6 +192,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n             PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n         };\n+\n+        // If the lang item was declared incorrectly, stop here so that we don't\n+        // run into an ICE (#83893). The error is reported where the lang item is\n+        // declared.\n+        if !has_expected_num_generic_args(\n+            self.tcx,\n+            mut_tr,\n+            match op {\n+                PlaceOp::Deref => 0,\n+                PlaceOp::Index => 1,\n+            },\n+        ) {\n+            return None;\n+        }\n+\n         mut_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n                 span,"}, {"sha": "71e222c560a0526a8654599b0c738d5a1c3a433c", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// InferBorrowKind results in a structure like this:\n     ///\n-    /// ```\n+    /// ```text\n     /// {\n     ///       Place(base: hir_id_s, projections: [], ....) -> {\n     ///                                                            capture_kind_expr: hir_id_L5,\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     ///\n     /// After the min capture analysis, we get:\n-    /// ```\n+    /// ```text\n     /// {\n     ///       hir_id_s -> [\n     ///            Place(base: hir_id_s, projections: [], ....) -> {"}, {"sha": "a9478041c69c47f9783eebb8ebf8498d0714eea2", "filename": "library/core/src/iter/sources/repeat.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -72,10 +72,32 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn next(&mut self) -> Option<A> {\n         Some(self.element.clone())\n     }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (usize::MAX, None)\n     }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        // Advancing an infinite iterator of a single element is a no-op.\n+        let _ = n;\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<A> {\n+        let _ = n;\n+        Some(self.element.clone())\n+    }\n+\n+    fn last(self) -> Option<A> {\n+        loop {}\n+    }\n+\n+    fn count(self) -> usize {\n+        loop {}\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -84,6 +106,19 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> {\n         Some(self.element.clone())\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        // Advancing an infinite iterator of a single element is a no-op.\n+        let _ = n;\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<A> {\n+        let _ = n;\n+        Some(self.element.clone())\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "16b091eb255b0257bc2090414f418f0dd7b081ba", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -294,6 +294,50 @@ warning: unclosed HTML tag `h1`\n warning: 2 warnings emitted\n ```\n \n+## invalid_rust_codeblocks\n+\n+This lint **warns by default**. It detects Rust code blocks in documentation\n+examples that are invalid (e.g. empty, not parsable as Rust). For example:\n+\n+```rust\n+/// Empty code blocks (with and without the `rust` marker):\n+///\n+/// ```rust\n+/// ```\n+///\n+/// Invalid syntax in code blocks:\n+///\n+/// ```rust\n+/// '<\n+/// ```\n+pub fn foo() {}\n+```\n+\n+Which will give:\n+\n+```text\n+warning: Rust code block is empty\n+ --> lint.rs:3:5\n+  |\n+3 |   /// ```rust\n+  |  _____^\n+4 | | /// ```\n+  | |_______^\n+  |\n+  = note: `#[warn(rustdoc::invalid_rust_codeblocks)]` on by default\n+\n+warning: could not parse code block as Rust code\n+  --> lint.rs:8:5\n+   |\n+8  |   /// ```rust\n+   |  _____^\n+9  | | /// '<\n+10 | | /// ```\n+   | |_______^\n+   |\n+   = note: error from rustc: unterminated character literal\n+```\n+\n ## bare_urls\n \n This lint is **warn-by-default**. It detects URLs which are not links."}, {"sha": "a288b43722ad4c3236989018be46adc04cf7c1ea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -509,7 +509,11 @@ fn document(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, parent: Option\n         info!(\"Documenting {}\", name);\n     }\n     document_item_info(w, cx, item, parent);\n-    document_full_collapsible(w, item, cx);\n+    if parent.is_none() {\n+        document_full_collapsible(w, item, cx);\n+    } else {\n+        document_full(w, item, cx);\n+    }\n }\n \n /// Render md_text as markdown."}, {"sha": "bac9c21f0f39b20eb3ab183ecd013f4a796d2779", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -578,12 +578,13 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         info!(\"Documenting {} on {:?}\", name, t.name);\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        write!(w, \"<details class=\\\"rustdoc-toggle\\\" open><summary>\");\n         write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n         w.write_str(\"</code>\");\n         render_stability_since(w, m, t, cx.tcx());\n         write_srclink(cx, m, w);\n-        w.write_str(\"</h3>\");\n+        w.write_str(\"</h3></summary>\");\n         document(w, cx, m, Some(t));\n     }\n "}, {"sha": "376c83b1a6ea8836e492b202c7bada77e79d4d46", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -157,13 +157,26 @@ declare_rustdoc_lint! {\n     \"detects URLs that are not hyperlinks\"\n }\n \n+declare_rustdoc_lint! {\n+   /// The `invalid_rust_codeblocks` lint detects Rust code blocks in\n+   /// documentation examples that are invalid (e.g. empty, not parsable as\n+   /// Rust code). This is a `rustdoc` only lint, see the documentation in the\n+   /// [rustdoc book].\n+   ///\n+   /// [rustdoc book]: ../../../rustdoc/lints.html#invalid_rust_codeblocks\n+   INVALID_RUST_CODEBLOCKS,\n+   Warn,\n+   \"codeblock could not be parsed as valid Rust or is empty\"\n+}\n+\n crate static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     vec![\n         BROKEN_INTRA_DOC_LINKS,\n         PRIVATE_INTRA_DOC_LINKS,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS,\n         INVALID_CODEBLOCK_ATTRIBUTES,\n+        INVALID_RUST_CODEBLOCKS,\n         INVALID_HTML_TAGS,\n         BARE_URLS,\n         MISSING_CRATE_LEVEL_DOCS,"}, {"sha": "7ccfdf29041d2e00d29c44074cf120e99074aeae", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 69, "deletions": 45, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::Emitter, Applicability, Diagnostic, Handler};\n+use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n@@ -47,63 +48,86 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n         .unwrap_or(false);\n         let buffer = buffer.borrow();\n \n-        if buffer.has_errors || is_empty {\n-            let mut diag = if let Some(sp) = super::source_span_for_markdown_range(\n-                self.cx.tcx,\n-                &dox,\n-                &code_block.range,\n-                &item.attrs,\n-            ) {\n-                let (warning_message, suggest_using_text) = if buffer.has_errors {\n-                    (\"could not parse code block as Rust code\", true)\n-                } else {\n-                    (\"Rust code block is empty\", false)\n-                };\n-\n-                let mut diag = self.cx.sess().struct_span_warn(sp, warning_message);\n-\n-                if code_block.syntax.is_none() && code_block.is_fenced {\n-                    let sp = sp.from_inner(InnerSpan::new(0, 3));\n-                    diag.span_suggestion(\n-                        sp,\n-                        \"mark blocks that do not contain Rust code as text\",\n-                        String::from(\"```text\"),\n-                        Applicability::MachineApplicable,\n+        if !buffer.has_errors && !is_empty {\n+            // No errors in a non-empty program.\n+            return;\n+        }\n+\n+        let local_id = match item.def_id.as_real().and_then(|x| x.as_local()) {\n+            Some(id) => id,\n+            // We don't need to check the syntax for other crates so returning\n+            // without doing anything should not be a problem.\n+            None => return,\n+        };\n+\n+        let hir_id = self.cx.tcx.hir().local_def_id_to_hir_id(local_id);\n+        let empty_block = code_block.syntax.is_none() && code_block.is_fenced;\n+        let is_ignore = code_block.is_ignore;\n+\n+        // The span and whether it is precise or not.\n+        let (sp, precise_span) = match super::source_span_for_markdown_range(\n+            self.cx.tcx,\n+            &dox,\n+            &code_block.range,\n+            &item.attrs,\n+        ) {\n+            Some(sp) => (sp, true),\n+            None => (item.attr_span(self.cx.tcx), false),\n+        };\n+\n+        // lambda that will use the lint to start a new diagnostic and add\n+        // a suggestion to it when needed.\n+        let diag_builder = |lint: LintDiagnosticBuilder<'_>| {\n+            let explanation = if is_ignore {\n+                \"`ignore` code blocks require valid Rust code for syntax highlighting; \\\n+                    mark blocks that do not contain Rust code as text\"\n+            } else {\n+                \"mark blocks that do not contain Rust code as text\"\n+            };\n+            let msg = if buffer.has_errors {\n+                \"could not parse code block as Rust code\"\n+            } else {\n+                \"Rust code block is empty\"\n+            };\n+            let mut diag = lint.build(msg);\n+\n+            if precise_span {\n+                if is_ignore {\n+                    // giving an accurate suggestion is hard because `ignore` might not have come first in the list.\n+                    // just give a `help` instead.\n+                    diag.span_help(\n+                        sp.from_inner(InnerSpan::new(0, 3)),\n+                        &format!(\"{}: ```text\", explanation),\n                     );\n-                } else if suggest_using_text && code_block.is_ignore {\n-                    let sp = sp.from_inner(InnerSpan::new(0, 3));\n+                } else if empty_block {\n                     diag.span_suggestion(\n-                        sp,\n-                        \"`ignore` code blocks require valid Rust code for syntax highlighting. \\\n-                         Mark blocks that do not contain Rust code as text\",\n-                        String::from(\"```text,\"),\n+                        sp.from_inner(InnerSpan::new(0, 3)),\n+                        explanation,\n+                        String::from(\"```text\"),\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-\n-                diag\n-            } else {\n-                // We couldn't calculate the span of the markdown block that had the error, so our\n-                // diagnostics are going to be a bit lacking.\n-                let mut diag = self.cx.sess().struct_span_warn(\n-                    item.attr_span(self.cx.tcx),\n-                    \"doc comment contains an invalid Rust code block\",\n-                );\n-\n-                if code_block.syntax.is_none() && code_block.is_fenced {\n-                    diag.help(\"mark blocks that do not contain Rust code as text: ```text\");\n-                }\n-\n-                diag\n-            };\n+            } else if empty_block || is_ignore {\n+                diag.help(&format!(\"{}: ```text\", explanation));\n+            }\n \n             // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n             for message in buffer.messages.iter() {\n                 diag.note(&message);\n             }\n \n             diag.emit();\n-        }\n+        };\n+\n+        // Finally build and emit the completed diagnostic.\n+        // All points of divergence have been handled earlier so this can be\n+        // done the same way whether the span is precise or not.\n+        self.cx.tcx.struct_span_lint_hir(\n+            crate::lint::INVALID_RUST_CODEBLOCKS,\n+            hir_id,\n+            sp,\n+            diag_builder,\n+        );\n     }\n }\n "}, {"sha": "86f6a2868fb56af1107918665b267b9c99bb40c4", "filename": "src/test/rustdoc-ui/ignore-block-help.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Fignore-block-help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Fignore-block-help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fignore-block-help.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -3,5 +3,8 @@\n /// ```ignore (to-prevent-tidy-error)\n /// let heart = '\u2764\ufe0f';\n /// ```\n-//~^^^ WARN\n+//~^^^ WARNING could not parse code block\n+//~| NOTE on by default\n+//~| NOTE character literal may only contain one codepoint\n+//~| HELP `ignore` code blocks require valid Rust code\n pub struct X;"}, {"sha": "9c02ff11d19c4bd898a05c34cc0833a99750cce8", "filename": "src/test/rustdoc-ui/ignore-block-help.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Fignore-block-help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Fignore-block-help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fignore-block-help.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -7,11 +7,13 @@ LL | | /// let heart = '\u2764\ufe0f';\n LL | | /// ```\n    | |_______^\n    |\n-   = note: error from rustc: character literal may only contain one codepoint\n-help: `ignore` code blocks require valid Rust code for syntax highlighting. Mark blocks that do not contain Rust code as text\n+   = note: `#[warn(rustdoc::invalid_rust_codeblocks)]` on by default\n+help: `ignore` code blocks require valid Rust code for syntax highlighting; mark blocks that do not contain Rust code as text: ```text\n+  --> $DIR/ignore-block-help.rs:3:5\n    |\n-LL | /// ```text,ignore (to-prevent-tidy-error)\n-   |     ^^^^^^^^\n+LL | /// ```ignore (to-prevent-tidy-error)\n+   |     ^^^\n+   = note: error from rustc: character literal may only contain one codepoint\n \n warning: 1 warning emitted\n "}, {"sha": "b503d1093fda8e9e353ba78af406fa3a0f510057", "filename": "src/test/rustdoc-ui/invalid-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -71,7 +71,7 @@ pub fn blargh() {}\n /// \\_\n #[doc = \"```\"]\n pub fn crazy_attrs() {}\n-//~^^^^ WARNING doc comment contains an invalid Rust code block\n+//~^^^^ WARNING could not parse code block\n \n /// ```rust\n /// ```"}, {"sha": "82eac9bd68b21b966b6276911f56f2ab07350667", "filename": "src/test/rustdoc-ui/invalid-syntax.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -7,6 +7,7 @@ LL | | /// \\__________pkt->size___________/          \\_result->size_/ \\__pkt->si\n LL | | /// ```\n    | |_______^\n    |\n+   = note: `#[warn(rustdoc::invalid_rust_codeblocks)]` on by default\n    = note: error from rustc: unknown start of token: \\\n    = note: error from rustc: unknown start of token: \\\n    = note: error from rustc: unknown start of token: \\\n@@ -90,7 +91,7 @@ LL | | /// ```\n    |\n    = note: error from rustc: unknown start of token: \\\n \n-warning: doc comment contains an invalid Rust code block\n+warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:70:1\n    |\n LL | / #[doc = \"```\"]"}, {"sha": "a160809cbf9573705c4f8aea507ecb5080fbb727", "filename": "src/test/rustdoc/toggle-trait-fn.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,7 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/trait.Foo.html\n+// @has - '//details[@class=\"rustdoc-toggle\"]//code' 'bar'\n+pub trait Foo {\n+    fn bar() -> ();\n+}"}, {"sha": "c5b9e34edf703d6d695858a14b9004462e11fe75", "filename": "src/test/ui/async-await/issue-73741-type-err.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fasync-await%2Fissue-73741-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fasync-await%2Fissue-73741-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-73741-type-err.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,14 @@\n+// edition:2018\n+//\n+// Regression test for issue #73741\n+// Ensures that we don't emit spurious errors when\n+// a type error ocurrs in an `async fn`\n+\n+async fn weird() {\n+    1 = 2; //~ ERROR invalid left-hand side\n+\n+    let mut loop_count = 0;\n+    async {}.await\n+}\n+\n+fn main() {}"}, {"sha": "0b5343a98cfb44316cd13ffbb19f7f8b5844938f", "filename": "src/test/ui/async-await/issue-73741-type-err.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fasync-await%2Fissue-73741-type-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fasync-await%2Fissue-73741-type-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-73741-type-err.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,11 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-73741-type-err.rs:8:7\n+   |\n+LL |     1 = 2;\n+   |     - ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0070`."}, {"sha": "0c329542928c559adf4f00c268a2b989269476de", "filename": "src/test/ui/lang-items/lang-item-missing-generator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "previous_filename": "src/test/ui/lang-item-missing-generator.rs"}, {"sha": "fa13bf0b12719050bb268f8014248e718bc62c1d", "filename": "src/test/ui/lang-items/lang-item-missing-generator.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "previous_filename": "src/test/ui/lang-item-missing-generator.stderr"}, {"sha": "4e26343242e0105d46a5b5c4e2304b8699efeb4d", "filename": "src/test/ui/lang-items/lang-item-missing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "previous_filename": "src/test/ui/lang-item-missing.rs"}, {"sha": "f7516c7d377dab1ff50429237150044408aa9e26", "filename": "src/test/ui/lang-items/lang-item-missing.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "previous_filename": "src/test/ui/lang-item-missing.stderr"}, {"sha": "9f4f2464a1e65db1f9d119abc7b30def5aaf17ff", "filename": "src/test/ui/lang-items/wrong-number-generic-args-add.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,20 @@\n+// Checks whether declaring a lang item with the wrong number\n+// of generic arguments crashes the compiler (issue #83893).\n+\n+#![feature(lang_items,no_core)]\n+#![no_core]\n+#![crate_type=\"lib\"]\n+\n+#[lang = \"sized\"]\n+trait MySized {}\n+\n+#[lang = \"add\"]\n+trait MyAdd<'a, T> {}\n+//~^^ ERROR: `add` language item must be applied to a trait with 1 generic argument [E0718]\n+\n+fn ice() {\n+    let r = 5;\n+    let a = 6;\n+    r + a\n+    //~^ ERROR: cannot add `{integer}` to `{integer}` [E0369]\n+}"}, {"sha": "6f89441fd285d978b460319a62592b4893a7af5f", "filename": "src/test/ui/lang-items/wrong-number-generic-args-add.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,20 @@\n+error[E0718]: `add` language item must be applied to a trait with 1 generic argument\n+  --> $DIR/wrong-number-generic-args-add.rs:11:1\n+   |\n+LL | #[lang = \"add\"]\n+   | ^^^^^^^^^^^^^^^\n+LL | trait MyAdd<'a, T> {}\n+   |            ------- this trait has 2 generic arguments, not 1\n+\n+error[E0369]: cannot add `{integer}` to `{integer}`\n+  --> $DIR/wrong-number-generic-args-add.rs:18:7\n+   |\n+LL |     r + a\n+   |     - ^ - {integer}\n+   |     |\n+   |     {integer}\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0369, E0718.\n+For more information about an error, try `rustc --explain E0369`."}, {"sha": "1d90e63dc5470749fccfd178df32cdc640449f74", "filename": "src/test/ui/lang-items/wrong-number-generic-args-index.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,19 @@\n+// Checks whether declaring a lang item with the wrong number\n+// of generic arguments crashes the compiler (issue #83893).\n+\n+#![feature(lang_items,no_core)]\n+#![no_core]\n+#![crate_type=\"lib\"]\n+\n+#[lang = \"sized\"]\n+trait MySized {}\n+\n+#[lang = \"index\"]\n+trait MyIndex<'a, T> {}\n+//~^^ ERROR: `index` language item must be applied to a trait with 1 generic argument [E0718]\n+\n+fn ice() {\n+    let arr = [0; 5];\n+    let _ = arr[2];\n+    //~^ ERROR: cannot index into a value of type `[{integer}; 5]` [E0608]\n+}"}, {"sha": "bc3f19ff276239284b9cbbe75d353fc12c264185", "filename": "src/test/ui/lang-items/wrong-number-generic-args-index.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,18 @@\n+error[E0718]: `index` language item must be applied to a trait with 1 generic argument\n+  --> $DIR/wrong-number-generic-args-index.rs:11:1\n+   |\n+LL | #[lang = \"index\"]\n+   | ^^^^^^^^^^^^^^^^^\n+LL | trait MyIndex<'a, T> {}\n+   |              ------- this trait has 2 generic arguments, not 1\n+\n+error[E0608]: cannot index into a value of type `[{integer}; 5]`\n+  --> $DIR/wrong-number-generic-args-index.rs:17:13\n+   |\n+LL |     let _ = arr[2];\n+   |             ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0608, E0718.\n+For more information about an error, try `rustc --explain E0608`."}, {"sha": "bd060c92cd4699f3c8872bd3d7350a62d74180f6", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -21,10 +21,10 @@ LL | fn foo<X: Trait>(_: X) {}\n    |           ----- required by this bound in `foo`\n ...\n LL |   foo(s);\n-   |       ^ the trait `Trait` is not implemented for `S`\n-   |\n-   = help: the following implementations were found:\n-             <&'a mut S as Trait>\n+   |       ^\n+   |       |\n+   |       expected an implementor of trait `Trait`\n+   |       help: consider mutably borrowing here: `&mut s`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "050cf8c64b361eaa2438e11c34b003abeae65667", "filename": "src/test/ui/suggestions/issue-84973-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,13 @@\n+// A slight variation of issue-84973.rs. Here, a mutable borrow is\n+// required (and the obligation kind is different).\n+\n+trait Tr {}\n+impl Tr for &mut i32 {}\n+\n+fn foo<T: Tr>(i: T) {}\n+\n+fn main() {\n+    let a: i32 = 32;\n+    foo(a);\n+    //~^ ERROR: the trait bound `i32: Tr` is not satisfied [E0277]\n+}"}, {"sha": "b6ed437b5eefd7f71493222d1f65d8b9b5fe7fd8", "filename": "src/test/ui/suggestions/issue-84973-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `i32: Tr` is not satisfied\n+  --> $DIR/issue-84973-2.rs:11:9\n+   |\n+LL | fn foo<T: Tr>(i: T) {}\n+   |           -- required by this bound in `foo`\n+...\n+LL |     foo(a);\n+   |         ^\n+   |         |\n+   |         expected an implementor of trait `Tr`\n+   |         help: consider mutably borrowing here: `&mut a`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "db954530b1bebe34acb5cb34ac2de3a2146e5880", "filename": "src/test/ui/suggestions/issue-84973-blacklist.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,29 @@\n+// Checks that certain traits for which we don't want to suggest borrowing\n+// are blacklisted and don't cause the suggestion to be issued.\n+\n+#![feature(generators)]\n+\n+fn f_copy<T: Copy>(t: T) {}\n+fn f_clone<T: Clone>(t: T) {}\n+fn f_unpin<T: Unpin>(t: T) {}\n+fn f_sized<T: Sized>(t: T) {}\n+fn f_send<T: Send>(t: T) {}\n+\n+struct S;\n+\n+fn main() {\n+    f_copy(\"\".to_string()); //~ ERROR: the trait bound `String: Copy` is not satisfied [E0277]\n+    f_clone(S); //~ ERROR: the trait bound `S: Clone` is not satisfied [E0277]\n+    f_unpin(static || { yield; });\n+    //~^ ERROR: cannot be unpinned [E0277]\n+\n+    let cl = || ();\n+    let ref_cl: &dyn Fn() -> () = &cl;\n+    f_sized(*ref_cl);\n+    //~^ ERROR: the size for values of type `dyn Fn()` cannot be known at compilation time [E0277]\n+    //~| ERROR: the size for values of type `dyn Fn()` cannot be known at compilation time [E0277]\n+\n+    use std::rc::Rc;\n+    let rc = Rc::new(0);\n+    f_send(rc); //~ ERROR: `Rc<{integer}>` cannot be sent between threads safely [E0277]\n+}"}, {"sha": "f1e6ef883ae904e964a384de5cac221d467d30d0", "filename": "src/test/ui/suggestions/issue-84973-blacklist.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,64 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/issue-84973-blacklist.rs:15:12\n+   |\n+LL | fn f_copy<T: Copy>(t: T) {}\n+   |              ---- required by this bound in `f_copy`\n+...\n+LL |     f_copy(\"\".to_string());\n+   |            ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+\n+error[E0277]: the trait bound `S: Clone` is not satisfied\n+  --> $DIR/issue-84973-blacklist.rs:16:13\n+   |\n+LL | fn f_clone<T: Clone>(t: T) {}\n+   |               ----- required by this bound in `f_clone`\n+...\n+LL |     f_clone(S);\n+   |             ^ the trait `Clone` is not implemented for `S`\n+\n+error[E0277]: `[static generator@$DIR/issue-84973-blacklist.rs:17:13: 17:33]` cannot be unpinned\n+  --> $DIR/issue-84973-blacklist.rs:17:5\n+   |\n+LL | fn f_unpin<T: Unpin>(t: T) {}\n+   |               ----- required by this bound in `f_unpin`\n+...\n+LL |     f_unpin(static || { yield; });\n+   |     ^^^^^^^ the trait `Unpin` is not implemented for `[static generator@$DIR/issue-84973-blacklist.rs:17:13: 17:33]`\n+   |\n+   = note: consider using `Box::pin`\n+\n+error[E0277]: the size for values of type `dyn Fn()` cannot be known at compilation time\n+  --> $DIR/issue-84973-blacklist.rs:22:13\n+   |\n+LL | fn f_sized<T: Sized>(t: T) {}\n+   |            - required by this bound in `f_sized`\n+...\n+LL |     f_sized(*ref_cl);\n+   |             ^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `dyn Fn()`\n+\n+error[E0277]: `Rc<{integer}>` cannot be sent between threads safely\n+  --> $DIR/issue-84973-blacklist.rs:28:12\n+   |\n+LL | fn f_send<T: Send>(t: T) {}\n+   |              ---- required by this bound in `f_send`\n+...\n+LL |     f_send(rc);\n+   |            ^^ `Rc<{integer}>` cannot be sent between threads safely\n+   |\n+   = help: the trait `Send` is not implemented for `Rc<{integer}>`\n+\n+error[E0277]: the size for values of type `dyn Fn()` cannot be known at compilation time\n+  --> $DIR/issue-84973-blacklist.rs:22:5\n+   |\n+LL |     f_sized(*ref_cl);\n+   |     ^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `dyn Fn()`\n+   = note: all function arguments must have a statically known size\n+   = help: unsized fn params are gated as an unstable feature\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f339251e57dabd49ab830695553153409f4719a8", "filename": "src/test/ui/suggestions/issue-84973-negative.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,12 @@\n+// Checks that we only suggest borrowing if &T actually implements the trait.\n+\n+trait Tr {}\n+impl Tr for &f32 {}\n+fn bar<T: Tr>(t: T) {}\n+\n+fn main() {\n+    let a = 0i32;\n+    let b = 0.0f32;\n+    bar(a); //~ ERROR: the trait bound `i32: Tr` is not satisfied [E0277]\n+    bar(b); //~ ERROR: the trait bound `f32: Tr` is not satisfied [E0277]\n+}"}, {"sha": "94513eca0bf0994077ee5530cb8650f308e2f264", "filename": "src/test/ui/suggestions/issue-84973-negative.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `i32: Tr` is not satisfied\n+  --> $DIR/issue-84973-negative.rs:10:9\n+   |\n+LL | fn bar<T: Tr>(t: T) {}\n+   |           -- required by this bound in `bar`\n+...\n+LL |     bar(a);\n+   |         ^ the trait `Tr` is not implemented for `i32`\n+\n+error[E0277]: the trait bound `f32: Tr` is not satisfied\n+  --> $DIR/issue-84973-negative.rs:11:9\n+   |\n+LL | fn bar<T: Tr>(t: T) {}\n+   |           -- required by this bound in `bar`\n+...\n+LL |     bar(b);\n+   |         ^\n+   |         |\n+   |         expected an implementor of trait `Tr`\n+   |         help: consider borrowing here: `&b`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "42468478ed9a24214ccbad6f3986a054b14dae79", "filename": "src/test/ui/suggestions/issue-84973.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.rs?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,33 @@\n+// Checks whether borrowing is suggested when a trait bound is not satisfied\n+// for found type `T`, but is for `&/&mut T`.\n+\n+fn main() {\n+    let f = Fancy{};\n+    let o = Other::new(f);\n+    //~^ ERROR: the trait bound `Fancy: SomeTrait` is not satisfied [E0277]\n+}\n+\n+struct Fancy {}\n+\n+impl <'a> SomeTrait for &'a Fancy {\n+}\n+\n+trait SomeTrait {}\n+\n+struct Other<'a, G> {\n+    a: &'a str,\n+    g: G,\n+}\n+\n+// Broadly copied from https://docs.rs/petgraph/0.5.1/src/petgraph/dot.rs.html#70\n+impl<'a, G> Other<'a, G>\n+where\n+    G: SomeTrait,\n+{\n+    pub fn new(g: G) -> Self {\n+        Other {\n+            a: \"hi\",\n+            g: g,\n+        }\n+    }\n+}"}, {"sha": "49fa94da8592304a44ae8fbc25a62c1220b94067", "filename": "src/test/ui/suggestions/issue-84973.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5560a6a90f08a84728802bb5fa5632a17a78672/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.stderr?ref=a5560a6a90f08a84728802bb5fa5632a17a78672", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Fancy: SomeTrait` is not satisfied\n+  --> $DIR/issue-84973.rs:6:24\n+   |\n+LL |     let o = Other::new(f);\n+   |                        ^\n+   |                        |\n+   |                        expected an implementor of trait `SomeTrait`\n+   |                        help: consider borrowing here: `&f`\n+...\n+LL |     pub fn new(g: G) -> Self {\n+   |     ------------------------ required by `Other::<'a, G>::new`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}