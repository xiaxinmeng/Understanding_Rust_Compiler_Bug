{"sha": "f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "node_id": "C_kwDOAAsO6NoAKGY5ZGZiNmUzMmZkYjI2NDJiNWM0YjM2NmYzYmQ1ZjBiYmMyNWY0MTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-27T13:03:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-27T13:03:58Z"}, "message": "Rollup merge of #103544 - Nilstrieb:no-recovery-pls, r=compiler-errors\n\nAdd flag to forbid recovery in the parser\n\nTo start the effort of fixing #103534, this adds a new flag to the parser, which forbids the parser from doing recovery, which it shouldn't do in macros.\n\nThis doesn't add any new checks for recoveries yet and is just here to bikeshed the names for the functions here before doing more.\n\nr? `@compiler-errors`", "tree": {"sha": "2a572748ffc640ba59c5752041b97d090e25e8f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a572748ffc640ba59c5752041b97d090e25e8f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjWoG+CRBK7hj4Ov3rIwAAcZ0IAFPkwo05QRqmG8EFRa0yCnWj\n4WXolzapUo9NAfsr8duBxoiOTuebgKu/30BztNJdN0msIGJ2j6JvoetKeu2zEnwI\nM1XTMOVXvXAqAxzT1IkUmp4/BKWPIc0cckjEBkhkHp7JLdvxCyVbP2yhjAh6f71f\nfaupBAeCkAwcuoFPpU0+o8biCVHLp+BbGIoRTSmgPCBarsXMVzECojWeYzUBdPMO\n+pvf08I6OAHXaxQAhoLvrToobNX3m7dRAa5DzekfUuXbAgZ0/Y82rSsoA8vAr7iy\nEzsRyX16CEbpqxas0CdFiBRAjwJzbS5BKWQqp9wkYpD0SCR6ywt/ECW5qU/i+0w=\n=EO1w\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a572748ffc640ba59c5752041b97d090e25e8f5\nparent 4a01cab4b7ae190800e577bf40c97c9bcb29e901\nparent da407ed38f6bcb79683379d59d18e615d2b8dfaa\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1666875838 +0200\ncommitter GitHub <noreply@github.com> 1666875838 +0200\n\nRollup merge of #103544 - Nilstrieb:no-recovery-pls, r=compiler-errors\n\nAdd flag to forbid recovery in the parser\n\nTo start the effort of fixing #103534, this adds a new flag to the parser, which forbids the parser from doing recovery, which it shouldn't do in macros.\n\nThis doesn't add any new checks for recoveries yet and is just here to bikeshed the names for the functions here before doing more.\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "html_url": "https://github.com/rust-lang/rust/commit/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a01cab4b7ae190800e577bf40c97c9bcb29e901", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a01cab4b7ae190800e577bf40c97c9bcb29e901", "html_url": "https://github.com/rust-lang/rust/commit/4a01cab4b7ae190800e577bf40c97c9bcb29e901"}, {"sha": "da407ed38f6bcb79683379d59d18e615d2b8dfaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/da407ed38f6bcb79683379d59d18e615d2b8dfaa", "html_url": "https://github.com/rust-lang/rust/commit/da407ed38f6bcb79683379d59d18e615d2b8dfaa"}], "stats": {"total": 33, "additions": 31, "deletions": 2}, "files": [{"sha": "f6fe38174f7c5566f380e7a2c587c8e3b98aa272", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "patch": "@@ -250,6 +250,7 @@ fn expand_macro<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n+    // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone());\n \n     // Try each arm's matchers."}, {"sha": "a781748efc52af24aff8ed22f151cd16e7628a7e", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "patch": "@@ -2112,6 +2112,8 @@ impl<'a> Parser<'a> {\n             // HACK: This is needed so we can detect whether we're inside a macro,\n             // where regular assumptions about what tokens can follow other tokens\n             // don't necessarily apply.\n+            && self.may_recover()\n+            // FIXME(Nilstrieb): Remove this check once `may_recover` actually stops recovery\n             && self.subparser_name.is_none()\n         {\n             // It is likely that the closure body is a block but where the"}, {"sha": "5fe29062b85b90b7d1c88755283e812ed10dcff8", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=f9dfb6e32fdb2642b5c4b366f3bd5f0bbc25f411", "patch": "@@ -115,6 +115,12 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     };\n }\n \n+#[derive(Clone, Copy)]\n+pub enum Recovery {\n+    Allowed,\n+    Forbidden,\n+}\n+\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n@@ -152,12 +158,15 @@ pub struct Parser<'a> {\n     /// This allows us to recover when the user forget to add braces around\n     /// multiple statements in the closure body.\n     pub current_closure: Option<ClosureSpans>,\n+    /// Whether the parser is allowed to do recovery.\n+    /// This is disabled when parsing macro arguments, see #103534\n+    pub recovery: Recovery,\n }\n \n-// This type is used a lot, e.g. it's cloned when matching many declarative macro rules. Make sure\n+// This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 328);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 336);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -483,6 +492,7 @@ impl<'a> Parser<'a> {\n                 inner_attr_ranges: Default::default(),\n             },\n             current_closure: None,\n+            recovery: Recovery::Allowed,\n         };\n \n         // Make parser point to the first token.\n@@ -491,6 +501,22 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n+    pub fn forbid_recovery(mut self) -> Self {\n+        self.recovery = Recovery::Forbidden;\n+        self\n+    }\n+\n+    /// Whether the parser is allowed to recover from broken code.\n+    ///\n+    /// If this returns false, recovering broken code into valid code (especially if this recovery does lookahead)\n+    /// is not allowed. All recovery done by the parser must be gated behind this check.\n+    ///\n+    /// Technically, this only needs to restrict eager recovery by doing lookahead at more tokens.\n+    /// But making the distinction is very subtle, and simply forbidding all recovery is a lot simpler to uphold.\n+    fn may_recover(&self) -> bool {\n+        matches!(self.recovery, Recovery::Allowed)\n+    }\n+\n     pub fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),"}]}