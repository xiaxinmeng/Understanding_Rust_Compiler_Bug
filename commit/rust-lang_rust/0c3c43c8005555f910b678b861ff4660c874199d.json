{"sha": "0c3c43c8005555f910b678b861ff4660c874199d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjM2M0M2M4MDA1NTU1ZjkxMGI2NzhiODYxZmY0NjYwYzg3NDE5OWQ=", "commit": {"author": {"name": "Matt Ickstadt", "email": "mattico8@gmail.com", "date": "2017-08-22T20:24:25Z"}, "committer": {"name": "Matt Ickstadt", "email": "mattico8@gmail.com", "date": "2017-08-26T20:07:32Z"}, "message": "Remove Splice struct return value from String::splice", "tree": {"sha": "9142b6fce1d7b8641890c905ed61ea7f0515f4db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9142b6fce1d7b8641890c905ed61ea7f0515f4db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c3c43c8005555f910b678b861ff4660c874199d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3c43c8005555f910b678b861ff4660c874199d", "html_url": "https://github.com/rust-lang/rust/commit/0c3c43c8005555f910b678b861ff4660c874199d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c3c43c8005555f910b678b861ff4660c874199d/comments", "author": {"login": "mattico", "id": 853158, "node_id": "MDQ6VXNlcjg1MzE1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/853158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattico", "html_url": "https://github.com/mattico", "followers_url": "https://api.github.com/users/mattico/followers", "following_url": "https://api.github.com/users/mattico/following{/other_user}", "gists_url": "https://api.github.com/users/mattico/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattico/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattico/subscriptions", "organizations_url": "https://api.github.com/users/mattico/orgs", "repos_url": "https://api.github.com/users/mattico/repos", "events_url": "https://api.github.com/users/mattico/events{/privacy}", "received_events_url": "https://api.github.com/users/mattico/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mattico", "id": 853158, "node_id": "MDQ6VXNlcjg1MzE1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/853158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattico", "html_url": "https://github.com/mattico", "followers_url": "https://api.github.com/users/mattico/followers", "following_url": "https://api.github.com/users/mattico/following{/other_user}", "gists_url": "https://api.github.com/users/mattico/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattico/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattico/subscriptions", "organizations_url": "https://api.github.com/users/mattico/orgs", "repos_url": "https://api.github.com/users/mattico/repos", "events_url": "https://api.github.com/users/mattico/events{/privacy}", "received_events_url": "https://api.github.com/users/mattico/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a24e0f25d7a0ac793b37eb4db353d5f9f2befc97", "url": "https://api.github.com/repos/rust-lang/rust/commits/a24e0f25d7a0ac793b37eb4db353d5f9f2befc97", "html_url": "https://github.com/rust-lang/rust/commit/a24e0f25d7a0ac793b37eb4db353d5f9f2befc97"}], "stats": {"total": 134, "additions": 25, "deletions": 109}, "files": [{"sha": "dae4475257a02988aafad92413e0eeb97f02c21d", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c3c43c8005555f910b678b861ff4660c874199d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c3c43c8005555f910b678b861ff4660c874199d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=0c3c43c8005555f910b678b861ff4660c874199d", "patch": "@@ -18,7 +18,6 @@ let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n \n // Replace the range up until the \u03b2 from the string\n-let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n-assert_eq!(t, \"\u03b1 is alpha, \");\n+s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n ```\n\\ No newline at end of file"}, {"sha": "bd85653132bb19d84b005b565491db143093740a", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 19, "deletions": 90, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0c3c43c8005555f910b678b861ff4660c874199d/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3c43c8005555f910b678b861ff4660c874199d/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=0c3c43c8005555f910b678b861ff4660c874199d", "patch": "@@ -1391,19 +1391,19 @@ impl String {\n     }\n \n     /// Creates a splicing iterator that removes the specified range in the string,\n-    /// replaces with the given string, and yields the removed chars.\n-    /// The given string doesn\u2019t need to be the same length as the range.\n+    /// and replaces it with the given string.\n+    /// The given string doesn't need to be the same length as the range.\n     ///\n-    /// Note: The element range is removed when the [`Splice`] is dropped,\n-    /// even if the iterator is not consumed until the end.\n+    /// Note: Unlike [`Vec::splice`], the replacement happens eagerly, and this\n+    /// method does not return the removed chars.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n-    /// [`Splice`]: ../../std/string/struct.Splice.html\n+    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n     ///\n     /// # Examples\n     ///\n@@ -1415,45 +1415,32 @@ impl String {\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n     ///\n     /// // Replace the range up until the \u03b2 from the string\n-    /// let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n-    /// assert_eq!(t, \"\u03b1 is alpha, \");\n+    /// s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n     #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-    pub fn splice<'a, 'b, R>(&'a mut self, range: R, replace_with: &'b str) -> Splice<'a, 'b>\n+    pub fn splice<R>(&mut self, range: R, replace_with: &str)\n         where R: RangeArgument<usize>\n     {\n         // Memory safety\n         //\n         // The String version of Splice does not have the memory safety issues\n         // of the vector version. The data is just plain bytes.\n-        // Because the range removal happens in Drop, if the Splice iterator is leaked,\n-        // the removal will not happen.\n-        let len = self.len();\n-        let start = match range.start() {\n-             Included(&n) => n,\n-             Excluded(&n) => n + 1,\n-             Unbounded => 0,\n+\n+        match range.start() {\n+             Included(&n) => assert!(self.is_char_boundary(n)),\n+             Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n+             Unbounded => {},\n         };\n-        let end = match range.end() {\n-             Included(&n) => n + 1,\n-             Excluded(&n) => n,\n-             Unbounded => len,\n+        match range.end() {\n+             Included(&n) => assert!(self.is_char_boundary(n + 1)),\n+             Excluded(&n) => assert!(self.is_char_boundary(n)),\n+             Unbounded => {},\n         };\n \n-        // Take out two simultaneous borrows. The &mut String won't be accessed\n-        // until iteration is over, in Drop.\n-        let self_ptr = self as *mut _;\n-        // slicing does the appropriate bounds checks\n-        let chars_iter = self[start..end].chars();\n-\n-        Splice {\n-            start,\n-            end,\n-            iter: chars_iter,\n-            string: self_ptr,\n-            replace_with,\n-        }\n+        unsafe {\n+            self.as_mut_vec()\n+        }.splice(range, replace_with.bytes());\n     }\n \n     /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n@@ -2240,61 +2227,3 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for Drain<'a> {}\n-\n-/// A splicing iterator for `String`.\n-///\n-/// This struct is created by the [`splice()`] method on [`String`]. See its\n-/// documentation for more.\n-///\n-/// [`splice()`]: struct.String.html#method.splice\n-/// [`String`]: struct.String.html\n-#[derive(Debug)]\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-pub struct Splice<'a, 'b> {\n-    /// Will be used as &'a mut String in the destructor\n-    string: *mut String,\n-    /// Start of part to remove\n-    start: usize,\n-    /// End of part to remove\n-    end: usize,\n-    /// Current remaining range to remove\n-    iter: Chars<'a>,\n-    replace_with: &'b str,\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-unsafe impl<'a, 'b> Sync for Splice<'a, 'b> {}\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-unsafe impl<'a, 'b> Send for Splice<'a, 'b> {}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> Drop for Splice<'a, 'b> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let vec = (*self.string).as_mut_vec();\n-            vec.splice(self.start..self.end, self.replace_with.bytes());\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> Iterator for Splice<'a, 'b> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        self.iter.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> DoubleEndedIterator for Splice<'a, 'b> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        self.iter.next_back()\n-    }\n-}"}, {"sha": "6aba18ddf49ffe072f63a3641fa91140070d3f47", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c3c43c8005555f910b678b861ff4660c874199d/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3c43c8005555f910b678b861ff4660c874199d/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=0c3c43c8005555f910b678b861ff4660c874199d", "patch": "@@ -442,9 +442,8 @@ fn test_drain() {\n #[test]\n fn test_splice() {\n     let mut s = \"Hello, world!\".to_owned();\n-    let t: String = s.splice(7..12, \"\u4e16\u754c\").collect();\n+    s.splice(7..12, \"\u4e16\u754c\");\n     assert_eq!(s, \"Hello, \u4e16\u754c!\");\n-    assert_eq!(t, \"world\");\n }\n \n #[test]\n@@ -457,12 +456,10 @@ fn test_splice_char_boundary() {\n #[test]\n fn test_splice_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    let t: String = v.splice(2...3, \"789\").collect();\n+    v.splice(2...3, \"789\");\n     assert_eq!(v, \"127895\");\n-    assert_eq!(t, \"34\");\n-    let t2: String = v.splice(1...2, \"A\").collect();\n+    v.splice(1...2, \"A\");\n     assert_eq!(v, \"1A895\");\n-    assert_eq!(t2, \"27\");\n }\n \n #[test]\n@@ -482,24 +479,15 @@ fn test_splice_inclusive_out_of_bounds() {\n #[test]\n fn test_splice_empty() {\n     let mut s = String::from(\"12345\");\n-    let t: String = s.splice(1..2, \"\").collect();\n+    s.splice(1..2, \"\");\n     assert_eq!(s, \"1345\");\n-    assert_eq!(t, \"2\");\n }\n \n #[test]\n fn test_splice_unbounded() {\n     let mut s = String::from(\"12345\");\n-    let t: String = s.splice(.., \"\").collect();\n+    s.splice(.., \"\");\n     assert_eq!(s, \"\");\n-    assert_eq!(t, \"12345\");\n-}\n-\n-#[test]\n-fn test_splice_forget() {\n-    let mut s = String::from(\"12345\");\n-    ::std::mem::forget(s.splice(2..4, \"789\"));\n-    assert_eq!(s, \"12345\");\n }\n \n #[test]"}]}