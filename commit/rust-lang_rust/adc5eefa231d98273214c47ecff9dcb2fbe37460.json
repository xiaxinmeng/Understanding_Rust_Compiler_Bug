{"sha": "adc5eefa231d98273214c47ecff9dcb2fbe37460", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYzVlZWZhMjMxZDk4MjczMjE0YzQ3ZWNmZjlkY2IyZmJlMzc0NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-30T08:11:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-30T08:11:55Z"}, "message": "auto merge of #11168 : sfackler/rust/de-at-extctxt, r=alexcrichton\n\n* Pass `&ExtCtxt` instead of `@ExtCtxt`.\r\n* Stop passing duplicate parameters around in `expand`.\r\n* Make `ast_fold` methods take `&mut self`.\r\n\r\nAfter these, it should be possible to remove the `@mut` boxes from `ExtCtxt` altogether, though #11167 is doing some of that so I'm holding off on that for now. This will probably conflict with that PR, so I'm guessing that one will have to be rebased on top of the other.\r\n\r\nr? @pcwalton", "tree": {"sha": "6015759a519bdb8adbfd3b3949a69b2887817853", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6015759a519bdb8adbfd3b3949a69b2887817853"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adc5eefa231d98273214c47ecff9dcb2fbe37460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adc5eefa231d98273214c47ecff9dcb2fbe37460", "html_url": "https://github.com/rust-lang/rust/commit/adc5eefa231d98273214c47ecff9dcb2fbe37460", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adc5eefa231d98273214c47ecff9dcb2fbe37460/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cbb44aff9a9840c133ea454db7d302c247d5f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbb44aff9a9840c133ea454db7d302c247d5f0f", "html_url": "https://github.com/rust-lang/rust/commit/0cbb44aff9a9840c133ea454db7d302c247d5f0f"}, {"sha": "dc830345e840875dff41ae1a0497cbff18909712", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc830345e840875dff41ae1a0497cbff18909712", "html_url": "https://github.com/rust-lang/rust/commit/dc830345e840875dff41ae1a0497cbff18909712"}], "stats": {"total": 842, "additions": 399, "deletions": 443}, "files": [{"sha": "74e8e0de1d8d07a47bc16b61acc9609cd184cc0c", "filename": "src/librustc/front/assign_node_ids.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -18,14 +18,14 @@ struct NodeIdAssigner {\n }\n \n impl ast_fold for NodeIdAssigner {\n-    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n         assert_eq!(old_id, ast::DUMMY_NODE_ID);\n         self.sess.next_node_id()\n     }\n }\n \n pub fn assign_node_ids(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    let fold = NodeIdAssigner {\n+    let mut fold = NodeIdAssigner {\n         sess: sess,\n     };\n     fold.fold_crate(crate)"}, {"sha": "58e7963ca9097c6a4ac9c8673040569109e6ab92", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -24,25 +24,25 @@ pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n }\n \n impl<'a> fold::ast_fold for Context<'a> {\n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         fold_mod(self, module)\n     }\n-    fn fold_block(&self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+    fn fold_block(&mut self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         fold_block(self, block)\n     }\n-    fn fold_foreign_mod(&self, foreign_module: &ast::foreign_mod)\n+    fn fold_foreign_mod(&mut self, foreign_module: &ast::foreign_mod)\n                         -> ast::foreign_mod {\n         fold_foreign_mod(self, foreign_module)\n     }\n-    fn fold_item_underscore(&self, item: &ast::item_) -> ast::item_ {\n+    fn fold_item_underscore(&mut self, item: &ast::item_) -> ast::item_ {\n         fold_item_underscore(self, item)\n     }\n }\n \n pub fn strip_items(crate: ast::Crate,\n                    in_cfg: |attrs: &[ast::Attribute]| -> bool)\n                    -> ast::Crate {\n-    let ctxt = Context {\n+    let mut ctxt = Context {\n         in_cfg: in_cfg,\n     };\n     ctxt.fold_crate(crate)\n@@ -57,7 +57,7 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n     }\n }\n \n-fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n+fn fold_mod(cx: &mut Context, m: &ast::_mod) -> ast::_mod {\n     let filtered_items = m.items.iter()\n             .filter(|&a| item_in_cfg(cx, *a))\n             .flat_map(|&x| cx.fold_item(x).move_iter())\n@@ -80,7 +80,7 @@ fn filter_foreign_item(cx: &Context, item: @ast::foreign_item)\n     }\n }\n \n-fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n+fn fold_foreign_mod(cx: &mut Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n     let filtered_items = nm.items\n                            .iter()\n                            .filter_map(|a| filter_foreign_item(cx, *a))\n@@ -95,7 +95,7 @@ fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n     }\n }\n \n-fn fold_item_underscore(cx: &Context, item: &ast::item_) -> ast::item_ {\n+fn fold_item_underscore(cx: &mut Context, item: &ast::item_) -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, ref b, c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n@@ -129,7 +129,7 @@ fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n     }\n }\n \n-fn fold_block(cx: &Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     let resulting_stmts = b.stmts.iter()\n             .filter(|&a| retain_stmt(cx, *a))\n             .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())"}, {"sha": "13bf867e06be11dfd99df31faf34aa9499e26c60", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -56,7 +56,7 @@ struct StandardLibraryInjector {\n }\n \n impl fold::ast_fold for StandardLibraryInjector {\n-    fn fold_crate(&self, crate: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, crate: ast::Crate) -> ast::Crate {\n         let version = STD_VERSION.to_managed();\n         let vers_item = attr::mk_name_value_item_str(@\"vers\", version);\n         let mut vis = ~[ast::view_item {\n@@ -108,7 +108,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n         if !no_prelude(item.attrs) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n@@ -119,7 +119,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         let prelude_path = ast::Path {\n             span: dummy_sp(),\n             global: false,\n@@ -158,7 +158,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n }\n \n fn inject_libstd_ref(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    let fold = StandardLibraryInjector {\n+    let mut fold = StandardLibraryInjector {\n         sess: sess,\n     };\n     fold.fold_crate(crate)"}, {"sha": "6193e5e8fa1f68330856064265b97a267fd734f6", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -40,7 +40,7 @@ struct Test {\n struct TestCtxt {\n     sess: session::Session,\n     path: RefCell<~[ast::Ident]>,\n-    ext_cx: @ExtCtxt,\n+    ext_cx: ExtCtxt,\n     testfns: RefCell<~[Test]>,\n     is_extra: bool,\n     config: ast::CrateConfig,\n@@ -63,30 +63,30 @@ pub fn modify_for_testing(sess: session::Session,\n }\n \n struct TestHarnessGenerator {\n-    cx: @TestCtxt,\n+    cx: TestCtxt,\n }\n \n impl fold::ast_fold for TestHarnessGenerator {\n-    fn fold_crate(&self, c: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n         let folded = fold::noop_fold_crate(c, self);\n \n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n         ast::Crate {\n-            module: add_test_module(self.cx, &folded.module),\n+            module: add_test_module(&self.cx, &folded.module),\n             .. folded\n         }\n     }\n \n-    fn fold_item(&self, i: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, i: @ast::item) -> SmallVector<@ast::item> {\n         {\n             let mut path = self.cx.path.borrow_mut();\n             path.get().push(i.ident);\n         }\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.get()));\n \n-        if is_test_fn(self.cx, i) || is_bench_fn(i) {\n+        if is_test_fn(&self.cx, i) || is_bench_fn(i) {\n             match i.node {\n                 ast::item_fn(_, purity, _, _, _)\n                     if purity == ast::unsafe_fn => {\n@@ -101,7 +101,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                         span: i.span,\n                         path: self.cx.path.get(),\n                         bench: is_bench_fn(i),\n-                        ignore: is_ignored(self.cx, i),\n+                        ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)\n                     };\n                     {\n@@ -122,11 +122,11 @@ impl fold::ast_fold for TestHarnessGenerator {\n         res\n     }\n \n-    fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, m: &ast::_mod) -> ast::_mod {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(cx: @TestCtxt, item: @ast::item) -> @ast::item {\n+        fn nomain(cx: &TestCtxt, item: @ast::item) -> @ast::item {\n             if !cx.sess.building_library.get() {\n                 @ast::item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n@@ -145,7 +145,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n         let mod_nomain = ast::_mod {\n             view_items: m.view_items.clone(),\n-            items: m.items.iter().map(|i| nomain(self.cx, *i)).collect(),\n+            items: m.items.iter().map(|i| nomain(&self.cx, *i)).collect(),\n         };\n \n         fold::noop_fold_mod(&mod_nomain, self)\n@@ -154,7 +154,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n                          -> ast::Crate {\n-    let cx: @TestCtxt = @TestCtxt {\n+    let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: RefCell::new(~[]),\n@@ -163,8 +163,7 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n         config: crate.config.clone(),\n     };\n \n-    let ext_cx = cx.ext_cx;\n-    ext_cx.bt_push(ExpnInfo {\n+    cx.ext_cx.bt_push(ExpnInfo {\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n             name: @\"test\",\n@@ -173,11 +172,11 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n         }\n     });\n \n-    let fold = TestHarnessGenerator {\n+    let mut fold = TestHarnessGenerator {\n         cx: cx\n     };\n     let res = fold.fold_crate(crate);\n-    ext_cx.bt_pop();\n+    fold.cx.ext_cx.bt_pop();\n     return res;\n }\n \n@@ -190,7 +189,7 @@ fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: @TestCtxt, i: @ast::item) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs, \"test\");\n \n     fn has_test_signature(i: @ast::item) -> bool {\n@@ -243,7 +242,7 @@ fn is_bench_fn(i: @ast::item) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: @TestCtxt, i: @ast::item) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: @ast::item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n@@ -313,7 +312,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n-    let mainfn = (quote_item!(cx.ext_cx,\n+    let mainfn = (quote_item!(&cx.ext_cx,\n         pub fn main() {\n             #[main];\n             extra::test::test_main_static(::std::os::args(), TESTS);\n@@ -377,7 +376,7 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n-    (quote_item!(cx.ext_cx,\n+    (quote_item!(&cx.ext_cx,\n         pub static TESTS : &'static [self::extra::test::TestDescAndFn] =\n             $test_descs\n         ;\n@@ -438,24 +437,24 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     };\n \n     let t_expr = if test.bench {\n-        quote_expr!(cx.ext_cx, self::extra::test::StaticBenchFn($fn_expr) )\n+        quote_expr!(&cx.ext_cx, self::extra::test::StaticBenchFn($fn_expr) )\n     } else {\n-        quote_expr!(cx.ext_cx, self::extra::test::StaticTestFn($fn_expr) )\n+        quote_expr!(&cx.ext_cx, self::extra::test::StaticTestFn($fn_expr) )\n     };\n \n     let ignore_expr = if test.ignore {\n-        quote_expr!(cx.ext_cx, true )\n+        quote_expr!(&cx.ext_cx, true )\n     } else {\n-        quote_expr!(cx.ext_cx, false )\n+        quote_expr!(&cx.ext_cx, false )\n     };\n \n     let fail_expr = if test.should_fail {\n-        quote_expr!(cx.ext_cx, true )\n+        quote_expr!(&cx.ext_cx, true )\n     } else {\n-        quote_expr!(cx.ext_cx, false )\n+        quote_expr!(&cx.ext_cx, false )\n     };\n \n-    let e = quote_expr!(cx.ext_cx,\n+    let e = quote_expr!(&cx.ext_cx,\n         self::extra::test::TestDescAndFn {\n             desc: self::extra::test::TestDesc {\n                 name: self::extra::test::StaticTestName($name_expr),"}, {"sha": "90825289ac39f4f57581929904ecbf95157ff649", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -301,7 +301,7 @@ struct NestedItemsDropper {\n }\n \n impl fold::ast_fold for NestedItemsDropper {\n-    fn fold_block(&self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+    fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n                 ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n@@ -340,7 +340,7 @@ impl fold::ast_fold for NestedItemsDropper {\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n-    let fld = NestedItemsDropper {\n+    let mut fld = NestedItemsDropper {\n         contents: (),\n     };\n \n@@ -365,17 +365,17 @@ struct AstRenumberer {\n }\n \n impl fold::ast_fold for AstRenumberer {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n         self.xcx.tr_id(id)\n     }\n-    fn new_span(&self, span: Span) -> Span {\n+    fn new_span(&mut self, span: Span) -> Span {\n         self.xcx.tr_span(span)\n     }\n }\n \n fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = AstRenumberer {\n+    let mut fld = AstRenumberer {\n         xcx: xcx,\n     };\n     match ii {"}, {"sha": "17b46b883b37fdf0525a038a4e115d2b9857a25f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -75,12 +75,12 @@ struct ListenerFn {\n \n struct ReadyCtx {\n     sess: session::Session,\n-    ext_cx: @ExtCtxt,\n+    ext_cx: ExtCtxt,\n     path: ~[ast::Ident],\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n+fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &mut CrateSetup)\n             -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n@@ -101,7 +101,7 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n     }, fold)\n }\n \n-fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &CrateSetup)\n+fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &mut CrateSetup)\n              -> SmallVector<@ast::item> {\n     ctx.path.push(item.ident);\n \n@@ -145,10 +145,10 @@ struct CrateSetup {\n }\n \n impl fold::ast_fold for CrateSetup {\n-    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n         fold_item(self.ctx, item, self)\n     }\n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         fold_mod(self.ctx, module, self)\n     }\n }\n@@ -162,7 +162,7 @@ pub fn ready_crate(sess: session::Session,\n         path: ~[],\n         fns: ~[]\n     };\n-    let fold = CrateSetup {\n+    let mut fold = CrateSetup {\n         ctx: ctx,\n     };\n     fold.fold_crate(crate)"}, {"sha": "cd7953aac20674727a9b6e8d0c55dc198bee49bb", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -37,7 +37,7 @@ fn next_state(s: State) -> Option<State> {\n     }\n }\n \n-pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "ccbc533fbcc72ead619e10bca7c3ae4b8fc74d4d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 42, "deletions": 52, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -35,11 +35,8 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-pub type ItemDecorator = extern \"Rust\" fn(@ExtCtxt,\n-                                          Span,\n-                                          @ast::MetaItem,\n-                                          ~[@ast::item])\n-                                          -> ~[@ast::item];\n+pub type ItemDecorator =\n+    fn(&ExtCtxt, Span, @ast::MetaItem, ~[@ast::item]) -> ~[@ast::item];\n \n pub struct SyntaxExpanderTT {\n     expander: SyntaxExpanderTTExpander,\n@@ -48,26 +45,24 @@ pub struct SyntaxExpanderTT {\n \n pub trait SyntaxExpanderTTTrait {\n     fn expand(&self,\n-              ecx: @ExtCtxt,\n+              ecx: &mut ExtCtxt,\n               span: Span,\n               token_tree: &[ast::token_tree],\n               context: ast::SyntaxContext)\n               -> MacResult;\n }\n \n pub type SyntaxExpanderTTFunNoCtxt =\n-    extern \"Rust\" fn(ecx: @ExtCtxt,\n-                     span: codemap::Span,\n-                     token_tree: &[ast::token_tree])\n-                     -> MacResult;\n+    fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::token_tree])\n+       -> MacResult;\n \n enum SyntaxExpanderTTExpander {\n     SyntaxExpanderTTExpanderWithoutContext(SyntaxExpanderTTFunNoCtxt),\n }\n \n impl SyntaxExpanderTTTrait for SyntaxExpanderTT {\n     fn expand(&self,\n-              ecx: @ExtCtxt,\n+              ecx: &mut ExtCtxt,\n               span: Span,\n               token_tree: &[ast::token_tree],\n               _: ast::SyntaxContext)\n@@ -92,7 +87,7 @@ pub struct SyntaxExpanderTTItem {\n \n pub trait SyntaxExpanderTTItemTrait {\n     fn expand(&self,\n-              cx: @ExtCtxt,\n+              cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n               token_tree: ~[ast::token_tree],\n@@ -102,7 +97,7 @@ pub trait SyntaxExpanderTTItemTrait {\n \n impl SyntaxExpanderTTItemTrait for SyntaxExpanderTTItem {\n     fn expand(&self,\n-              cx: @ExtCtxt,\n+              cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n               token_tree: ~[ast::token_tree],\n@@ -119,16 +114,12 @@ impl SyntaxExpanderTTItemTrait for SyntaxExpanderTTItem {\n     }\n }\n \n-pub type SyntaxExpanderTTItemFun = extern \"Rust\" fn(@ExtCtxt,\n-                                                    Span,\n-                                                    ast::Ident,\n-                                                    ~[ast::token_tree],\n-                                                    ast::SyntaxContext)\n-                                                    -> MacResult;\n+pub type SyntaxExpanderTTItemFun =\n+    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::token_tree], ast::SyntaxContext)\n+       -> MacResult;\n \n pub type SyntaxExpanderTTItemFunNoCtxt =\n-    extern \"Rust\" fn(@ExtCtxt, Span, ast::Ident, ~[ast::token_tree])\n-                     -> MacResult;\n+    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::token_tree]) -> MacResult;\n \n pub trait AnyMacro {\n     fn make_expr(&self) -> @ast::Expr;\n@@ -306,39 +297,38 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt {\n     parse_sess: @mut parse::ParseSess,\n     cfg: ast::CrateConfig,\n-    backtrace: @mut Option<@ExpnInfo>,\n+    backtrace: Option<@ExpnInfo>,\n \n     // These two @mut's should really not be here,\n     // but the self types for CtxtRepr are all wrong\n     // and there are bugs in the code for object\n     // types that make this hard to get right at the\n     // moment. - nmatsakis\n-    mod_path: @mut ~[ast::Ident],\n-    trace_mac: @mut bool\n+    mod_path: ~[ast::Ident],\n+    trace_mac: bool\n }\n \n impl ExtCtxt {\n     pub fn new(parse_sess: @mut parse::ParseSess, cfg: ast::CrateConfig)\n-               -> @ExtCtxt {\n-        @ExtCtxt {\n+               -> ExtCtxt {\n+        ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: @mut None,\n-            mod_path: @mut ~[],\n-            trace_mac: @mut false\n+            backtrace: None,\n+            mod_path: ~[],\n+            trace_mac: false\n         }\n     }\n \n-    pub fn expand_expr(@self, mut e: @ast::Expr) -> @ast::Expr {\n+    pub fn expand_expr(&mut self, mut e: @ast::Expr) -> @ast::Expr {\n         loop {\n             match e.node {\n                 ast::ExprMac(..) => {\n-                    let extsbox = @mut syntax_expander_table();\n-                    let expander = expand::MacroExpander {\n-                        extsbox: extsbox,\n+                    let mut expander = expand::MacroExpander {\n+                        extsbox: @mut syntax_expander_table(),\n                         cx: self,\n                     };\n-                    e = expand::expand_expr(extsbox, self, e, &expander);\n+                    e = expand::expand_expr(e, &mut expander);\n                 }\n                 _ => return e\n             }\n@@ -349,32 +339,32 @@ impl ExtCtxt {\n     pub fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        match *self.backtrace {\n+        match self.backtrace {\n             Some(@ExpnInfo {call_site: cs, ..}) => cs,\n             None => self.bug(\"missing top span\")\n         }\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n-    pub fn mod_push(&self, i: ast::Ident) { self.mod_path.push(i); }\n-    pub fn mod_pop(&self) { self.mod_path.pop(); }\n-    pub fn mod_path(&self) -> ~[ast::Ident] { (*self.mod_path).clone() }\n-    pub fn bt_push(&self, ei: codemap::ExpnInfo) {\n+    pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n+    pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n+    pub fn mod_pop(&mut self) { self.mod_path.pop(); }\n+    pub fn mod_path(&self) -> ~[ast::Ident] { self.mod_path.clone() }\n+    pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n-                *self.backtrace =\n+                self.backtrace =\n                     Some(@ExpnInfo {\n                         call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: *self.backtrace},\n+                                         expn_info: self.backtrace},\n                         callee: *callee});\n             }\n         }\n     }\n-    pub fn bt_pop(&self) {\n-        match *self.backtrace {\n+    pub fn bt_pop(&mut self) {\n+        match self.backtrace {\n             Some(@ExpnInfo {\n                 call_site: Span {expn_info: prev, ..}, ..}) => {\n-                *self.backtrace = prev\n+                self.backtrace = prev\n             }\n             _ => self.bug(\"tried to pop without a push\")\n         }\n@@ -404,10 +394,10 @@ impl ExtCtxt {\n         self.parse_sess.span_diagnostic.handler().bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n-        *self.trace_mac\n+        self.trace_mac\n     }\n-    pub fn set_trace_macros(&self, x: bool) {\n-        *self.trace_mac = x\n+    pub fn set_trace_macros(&mut self, x: bool) {\n+        self.trace_mac = x\n     }\n     pub fn str_of(&self, id: ast::Ident) -> @str {\n         ident_to_str(&id)\n@@ -417,7 +407,7 @@ impl ExtCtxt {\n     }\n }\n \n-pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::Expr, err_msg: &str) -> (@str, ast::StrStyle) {\n+pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr, err_msg: &str) -> (@str, ast::StrStyle) {\n     match expr.node {\n       ast::ExprLit(l) => match l.node {\n         ast::lit_str(s, style) => (s, style),\n@@ -427,14 +417,14 @@ pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::Expr, err_msg: &str) -> (@str, ast:\n     }\n }\n \n-pub fn check_zero_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n+pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, format!(\"{} takes no arguments\", name));\n     }\n }\n \n-pub fn get_single_str_from_tts(cx: @ExtCtxt,\n+pub fn get_single_str_from_tts(cx: &ExtCtxt,\n                                sp: Span,\n                                tts: &[ast::token_tree],\n                                name: &str)\n@@ -450,7 +440,7 @@ pub fn get_single_str_from_tts(cx: @ExtCtxt,\n     }\n }\n \n-pub fn get_exprs_from_tts(cx: @ExtCtxt,\n+pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n                           tts: &[ast::token_tree]) -> ~[@ast::Expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),"}, {"sha": "e5f20950412ac8045d4de4c96bd97082d01294b8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use ast_util;\n use codemap::{Span, respan, dummy_sp};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n-use fold;\n+use fold::ast_fold;\n use opt_vec;\n use opt_vec::OptVec;\n \n@@ -236,7 +236,7 @@ pub trait AstBuilder {\n                      vis: ast::visibility, path: ~[ast::Ident]) -> ast::view_item;\n }\n \n-impl AstBuilder for @ExtCtxt {\n+impl AstBuilder for ExtCtxt {\n     fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n         self.path_all(span, false, strs, opt_vec::Empty, ~[])\n     }\n@@ -686,12 +686,12 @@ impl AstBuilder for @ExtCtxt {\n     }\n     fn lambda0(&self, _span: Span, blk: P<ast::Block>) -> @ast::Expr {\n         let blk_e = self.expr(blk.span, ast::ExprBlock(blk));\n-        quote_expr!(*self, || $blk_e )\n+        quote_expr!(self, || $blk_e )\n     }\n \n     fn lambda1(&self, _span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr {\n         let blk_e = self.expr(blk.span, ast::ExprBlock(blk));\n-        quote_expr!(*self, |$ident| $blk_e )\n+        quote_expr!(self, |$ident| $blk_e )\n     }\n \n     fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], expr: @ast::Expr) -> @ast::Expr {\n@@ -903,12 +903,12 @@ impl AstBuilder for @ExtCtxt {\n     }\n }\n \n-struct Duplicator {\n-    cx: @ExtCtxt,\n+struct Duplicator<'a> {\n+    cx: &'a ExtCtxt,\n }\n \n-impl fold::ast_fold for Duplicator {\n-    fn new_id(&self, _: NodeId) -> NodeId {\n+impl<'a> ast_fold for Duplicator<'a> {\n+    fn new_id(&mut self, _: NodeId) -> NodeId {\n         ast::DUMMY_NODE_ID\n     }\n }\n@@ -920,14 +920,14 @@ pub trait Duplicate {\n     // These functions just duplicate AST nodes.\n     //\n \n-    fn duplicate(&self, cx: @ExtCtxt) -> Self;\n+    fn duplicate(&self, cx: &ExtCtxt) -> Self;\n }\n \n impl Duplicate for @ast::Expr {\n-    fn duplicate(&self, cx: @ExtCtxt) -> @ast::Expr {\n-        let folder = @Duplicator {\n+    fn duplicate(&self, cx: &ExtCtxt) -> @ast::Expr {\n+        let mut folder = Duplicator {\n             cx: cx,\n-        } as @fold::ast_fold;\n+        };\n         folder.fold_expr(*self)\n     }\n }"}, {"sha": "1878f6f3c3cbc93e7878b5e8db560e7b677f3b9a", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -18,7 +18,7 @@ use ext::build::AstBuilder;\n \n use std::char;\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n     let mut bytes = ~[];"}, {"sha": "d9fbc33153a609c5114f3e9c649c3263c3f6985a", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -25,7 +25,7 @@ use parse;\n use parse::token;\n use parse::attr::parser_attr;\n \n-pub fn expand_cfg(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_owned());\n \n     let mut cfgs = ~[];"}, {"sha": "d8be7dedef2f2851302a457e98482ed076c93f9b", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use codemap;\n use ext::base;\n use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(cx: @base::ExtCtxt,\n+pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let es = base::get_exprs_from_tts(cx, sp, tts);"}, {"sha": "0cb3e781c26ef91dd805b281b089c237672373fb", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -16,7 +16,7 @@ use opt_vec;\n use parse::token;\n use parse::token::{str_to_ident};\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for (i, e) in tts.iter().enumerate() {"}, {"sha": "c3c57082684b65f9755ead8c7944cde743acc659", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -14,7 +14,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_clone(cx: @ExtCtxt,\n+pub fn expand_deriving_clone(cx: &ExtCtxt,\n                              span: Span,\n                              mitem: @MetaItem,\n                              in_items: ~[@item])\n@@ -42,7 +42,7 @@ pub fn expand_deriving_clone(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n+pub fn expand_deriving_deep_clone(cx: &ExtCtxt,\n                                   span: Span,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@item])\n@@ -74,7 +74,7 @@ pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: @ExtCtxt, span: Span,\n+    cx: &ExtCtxt, span: Span,\n     substr: &Substructure) -> @Expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;"}, {"sha": "f7b249fc8d8bb50da211e3644b13d532ddd6e6b5", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -14,17 +14,17 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_eq(cx: @ExtCtxt,\n+pub fn expand_deriving_eq(cx: &ExtCtxt,\n                           span: Span,\n                           mitem: @MetaItem,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_eq(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_ne(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "c1e4e1e2b641d8b6028bf1fe1801622c693a38c8", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_ord(cx: @ExtCtxt,\n+pub fn expand_deriving_ord(cx: &ExtCtxt,\n                            span: Span,\n                            mitem: @MetaItem,\n                            in_items: ~[@item]) -> ~[@item] {\n@@ -51,7 +51,7 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_op(less: bool, equal: bool, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,"}, {"sha": "0b4d2659fd1fe6f6ab6095fc507db041e9254a60", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -14,11 +14,11 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n+pub fn expand_deriving_totaleq(cx: &ExtCtxt,\n                                span: Span,\n                                mitem: @MetaItem,\n                                in_items: ~[@item]) -> ~[@item] {\n-    fn cs_equals(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_equals(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)\n     }"}, {"sha": "3c58bfa01a96fa4a39d5f8fd271fb7ac73f9b295", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -16,7 +16,7 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use std::cmp::{Ordering, Equal, Less, Greater};\n \n-pub fn expand_deriving_totalord(cx: @ExtCtxt,\n+pub fn expand_deriving_totalord(cx: &ExtCtxt,\n                                 span: Span,\n                                 mitem: @MetaItem,\n                                 in_items: ~[@item]) -> ~[@item] {\n@@ -44,7 +44,7 @@ pub fn expand_deriving_totalord(cx: @ExtCtxt,\n }\n \n \n-pub fn ordering_const(cx: @ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n+pub fn ordering_const(cx: &ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n     let cnst = match cnst {\n         Less => \"Less\",\n         Equal => \"Equal\",\n@@ -56,7 +56,7 @@ pub fn ordering_const(cx: @ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n                      cx.ident_of(cnst)])\n }\n \n-pub fn cs_cmp(cx: @ExtCtxt, span: Span,\n+pub fn cs_cmp(cx: &ExtCtxt, span: Span,\n               substr: &Substructure) -> @Expr {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = ordering_const(cx, span, Equal);"}, {"sha": "de995af9ae3a5c56faa4f1e6bb0ea9f71891a169", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -19,7 +19,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_decodable(cx: @ExtCtxt,\n+pub fn expand_deriving_decodable(cx: &ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n@@ -51,7 +51,7 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn decodable_substructure(cx: @ExtCtxt, span: Span,\n+fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                           substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n     let recurse = ~[cx.ident_of(\"extra\"),\n@@ -132,7 +132,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_ident` is the name of this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n-fn decode_static_fields(cx: @ExtCtxt,\n+fn decode_static_fields(cx: &ExtCtxt,\n                         outer_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,"}, {"sha": "ba2df120796c3ad54c99a0eb993c8eace919250e", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -14,7 +14,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_default(cx: @ExtCtxt,\n+pub fn expand_deriving_default(cx: &ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])\n@@ -41,7 +41,7 @@ pub fn expand_deriving_default(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn default_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn default_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let default_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),"}, {"sha": "a6cba59aea518bb63b91b224ace9e90e60e8f7e2", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -81,7 +81,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_encodable(cx: @ExtCtxt,\n+pub fn expand_deriving_encodable(cx: &ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n@@ -113,7 +113,7 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn encodable_substructure(cx: @ExtCtxt, span: Span,\n+fn encodable_substructure(cx: &ExtCtxt, span: Span,\n                           substr: &Substructure) -> @Expr {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings"}, {"sha": "2eb0fe30b4b0764f237f7a36bd1c67a3d9564715", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -190,7 +190,7 @@ mod ty;\n \n pub struct TraitDef<'a> {\n     /// The extension context\n-    cx: @ExtCtxt,\n+    cx: &'a ExtCtxt,\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n@@ -300,15 +300,15 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    'a |@ExtCtxt, Span, &Substructure| -> @Expr;\n+    'a |&ExtCtxt, Span, &Substructure| -> @Expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'a> =\n-    'a |@ExtCtxt,\n+    'a |&ExtCtxt,\n            Span,\n            &[(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])],\n            &[@Expr]|\n@@ -1076,10 +1076,10 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: |@ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n+               f: |&ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n                base: @Expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ExtCtxt,\n+               cx: &ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n                -> @Expr {\n@@ -1115,9 +1115,9 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |@ExtCtxt, Span, ~[@Expr]| -> @Expr,\n+pub fn cs_same_method(f: |&ExtCtxt, Span, ~[@Expr]| -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ExtCtxt,\n+                      cx: &ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n                       -> @Expr {\n@@ -1149,10 +1149,10 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |@ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n+                           f: |&ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n                            base: @Expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ExtCtxt,\n+                           cx: &ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n                            -> @Expr {\n@@ -1179,7 +1179,7 @@ on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n-                cx: @ExtCtxt, trait_span: Span,\n+                cx: &ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> @Expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n@@ -1197,7 +1197,7 @@ pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n /// cs_binop with binop == or\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n-             cx: @ExtCtxt, span: Span,\n+             cx: &ExtCtxt, span: Span,\n              substructure: &Substructure) -> @Expr {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n@@ -1207,7 +1207,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n-              cx: @ExtCtxt, span: Span,\n+              cx: &ExtCtxt, span: Span,\n               substructure: &Substructure) -> @Expr {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,"}, {"sha": "8b2ad95e45c5b3f11504c8df890e441be31f5f23", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n \n-pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n+pub fn expand_deriving_iter_bytes(cx: &ExtCtxt,\n                                   span: Span,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@item]) -> ~[@item] {\n@@ -45,7 +45,7 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn iter_bytes_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let (lsb0, f)= match substr.nonself_args {\n         [l, f] => (l, f),\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")"}, {"sha": "1e8b79c8f350b117560648005a84bb2d5f3947f0", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -46,20 +46,20 @@ pub mod totalord;\n \n pub mod generic;\n \n-pub type ExpandDerivingStructDefFn<'a> = 'a |@ExtCtxt,\n+pub type ExpandDerivingStructDefFn<'a> = 'a |&ExtCtxt,\n                                                    Span,\n                                                    x: &struct_def,\n                                                    Ident,\n                                                    y: &Generics|\n                                                    -> @item;\n-pub type ExpandDerivingEnumDefFn<'a> = 'a |@ExtCtxt,\n+pub type ExpandDerivingEnumDefFn<'a> = 'a |&ExtCtxt,\n                                                  Span,\n                                                  x: &enum_def,\n                                                  Ident,\n                                                  y: &Generics|\n                                                  -> @item;\n \n-pub fn expand_meta_deriving(cx: @ExtCtxt,\n+pub fn expand_meta_deriving(cx: &ExtCtxt,\n                             _span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])"}, {"sha": "ba2d85f357a7d6627300d94fcb07b5ca1924a648", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n+pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n                                       span: Span,\n                                       mitem: @MetaItem,\n                                       in_items: ~[@item]) -> ~[@item] {\n@@ -64,7 +64,7 @@ pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn cs_from(name: &str, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let n = match substr.nonself_args {\n         [n] => n,\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")"}, {"sha": "1491797c8083f438251087b529b0767813f88bb7", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -16,7 +16,7 @@ use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use opt_vec;\n \n-pub fn expand_deriving_rand(cx: @ExtCtxt,\n+pub fn expand_deriving_rand(cx: &ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])\n@@ -50,7 +50,7 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn rand_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -130,7 +130,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: @ExtCtxt,\n+    fn rand_thing(cx: &ExtCtxt,\n                   span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,"}, {"sha": "25700f93a33cd5d8cbe6acf5020028fd69837f7a", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_to_str(cx: @ExtCtxt,\n+pub fn expand_deriving_to_str(cx: &ExtCtxt,\n                               span: Span,\n                               mitem: @MetaItem,\n                               in_items: ~[@item])\n@@ -47,7 +47,7 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n // doesn't invoke the to_str() method on each field. Hence we mirror\n // the logic of the repr_to_str() method, but with tweaks to call to_str()\n // on sub-fields.\n-fn to_str_substructure(cx: @ExtCtxt, span: Span,\n+fn to_str_substructure(cx: &ExtCtxt, span: Span,\n                        substr: &Substructure) -> @Expr {\n     let to_str = cx.ident_of(\"to_str\");\n "}, {"sha": "10e07520a84903757319589331a26d7948dcb961", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -58,15 +58,15 @@ impl<'a> Path<'a> {\n     }\n \n     pub fn to_ty(&self,\n-                 cx: @ExtCtxt,\n+                 cx: &ExtCtxt,\n                  span: Span,\n                  self_ty: Ident,\n                  self_generics: &Generics)\n                  -> P<ast::Ty> {\n         cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n-                   cx: @ExtCtxt,\n+                   cx: &ExtCtxt,\n                    span: Span,\n                    self_ty: Ident,\n                    self_generics: &Generics)\n@@ -110,14 +110,14 @@ pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n+fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n         Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n \n-fn mk_lifetimes(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Lifetime> {\n+fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Lifetime> {\n     match *lt {\n         Some(ref s) => opt_vec::with(cx.lifetime(span, cx.ident_of(*s))),\n         None => opt_vec::Empty\n@@ -126,7 +126,7 @@ fn mk_lifetimes(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Life\n \n impl<'a> Ty<'a> {\n     pub fn to_ty(&self,\n-                 cx: @ExtCtxt,\n+                 cx: &ExtCtxt,\n                  span: Span,\n                  self_ty: Ident,\n                  self_generics: &Generics)\n@@ -164,7 +164,7 @@ impl<'a> Ty<'a> {\n     }\n \n     pub fn to_path(&self,\n-                   cx: @ExtCtxt,\n+                   cx: &ExtCtxt,\n                    span: Span,\n                    self_ty: Ident,\n                    self_generics: &Generics)\n@@ -189,7 +189,7 @@ impl<'a> Ty<'a> {\n }\n \n \n-fn mk_ty_param(cx: @ExtCtxt, span: Span, name: &str, bounds: &[Path],\n+fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, bounds: &[Path],\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n         bounds.map(|b| {\n@@ -219,7 +219,7 @@ impl<'a> LifetimeBounds<'a> {\n         }\n     }\n     pub fn to_generics(&self,\n-                       cx: @ExtCtxt,\n+                       cx: &ExtCtxt,\n                        span: Span,\n                        self_ty: Ident,\n                        self_generics: &Generics)\n@@ -239,7 +239,7 @@ impl<'a> LifetimeBounds<'a> {\n }\n \n \n-pub fn get_explicit_self(cx: @ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n+pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     -> (@Expr, ast::explicit_self) {\n     let self_path = cx.expr_self(span);\n     match *self_ptr {"}, {"sha": "c406dbf0d0117886a48e785b8b88844c7238ab31", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -14,7 +14,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_zero(cx: @ExtCtxt,\n+pub fn expand_deriving_zero(cx: &ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])\n@@ -57,7 +57,7 @@ pub fn expand_deriving_zero(cx: @ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn zero_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let zero_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "cebd7aac4e3ea7c16755a095a3c88239cca34345", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -22,7 +22,7 @@ use ext::build::AstBuilder;\n \n use std::os;\n \n-pub fn expand_option_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let var = get_single_str_from_tts(cx, sp, tts, \"option_env!\");\n \n@@ -33,7 +33,7 @@ pub fn expand_option_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     MRExpr(e)\n }\n \n-pub fn expand_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n "}, {"sha": "eb07353cda3d174c20a21fcad42c397c4ae6db35", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 123, "deletions": 157, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -31,11 +31,7 @@ use util::small_vector::SmallVector;\n \n use std::vec;\n \n-pub fn expand_expr(extsbox: @mut SyntaxEnv,\n-                   cx: @ExtCtxt,\n-                   e: @ast::Expr,\n-                   fld: &MacroExpander)\n-                   -> @ast::Expr {\n+pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -49,22 +45,22 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 // Token-tree macros:\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n                     if (pth.segments.len() > 1u) {\n-                        cx.span_fatal(\n+                        fld.cx.span_fatal(\n                             pth.span,\n                             format!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n                     let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n-                    match (*extsbox).find(&extname.name) {\n+                    match (*fld.extsbox).find(&extname.name) {\n                         None => {\n-                            cx.span_fatal(\n+                            fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"macro undefined: '{}'\", extnamestr))\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n-                            cx.bt_push(ExpnInfo {\n+                            fld.cx.bt_push(ExpnInfo {\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n@@ -81,17 +77,17 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // be the root of the call stack. That's the most\n                             // relevant span and it's the actual invocation of\n                             // the macro.\n-                            let mac_span = original_span(cx);\n+                            let mac_span = original_span(fld.cx);\n \n                             let expanded =\n-                                match expandfun.expand(cx,\n+                                match expandfun.expand(fld.cx,\n                                                        mac_span.call_site,\n                                                        marked_before,\n                                                        marked_ctxt) {\n                                     MRExpr(e) => e,\n                                     MRAny(any_macro) => any_macro.make_expr(),\n                                     _ => {\n-                                        cx.span_fatal(\n+                                        fld.cx.span_fatal(\n                                             pth.span,\n                                             format!(\n                                                 \"non-expr macro in expr pos: {}\",\n@@ -109,7 +105,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // node here?\n                             let fully_expanded =\n                                 fld.fold_expr(marked_after).node.clone();\n-                            cx.bt_pop();\n+                            fld.cx.bt_pop();\n \n                             @ast::Expr {\n                                 id: ast::DUMMY_NODE_ID,\n@@ -118,7 +114,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             }\n                         }\n                         _ => {\n-                            cx.span_fatal(\n+                            fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"'{}' is not a tt-style macro\", extnamestr)\n                             )\n@@ -152,46 +148,47 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             // }\n \n             let local_ident = token::gensym_ident(\"i\");\n-            let next_ident = cx.ident_of(\"next\");\n-            let none_ident = cx.ident_of(\"None\");\n+            let next_ident = fld.cx.ident_of(\"next\");\n+            let none_ident = fld.cx.ident_of(\"None\");\n \n-            let local_path = cx.path_ident(span, local_ident);\n-            let some_path = cx.path_ident(span, cx.ident_of(\"Some\"));\n+            let local_path = fld.cx.path_ident(span, local_ident);\n+            let some_path = fld.cx.path_ident(span, fld.cx.ident_of(\"Some\"));\n \n             // `let i = &mut <src_expr>`\n-            let iter_decl_stmt = cx.stmt_let(span, false, local_ident,\n-                                             cx.expr_mut_addr_of(span, src_expr));\n+            let iter_decl_stmt = fld.cx.stmt_let(span, false, local_ident,\n+                                                 fld.cx.expr_mut_addr_of(span, src_expr));\n \n             // `None => break ['<ident>];`\n             let none_arm = {\n                 // FIXME #6993: this map goes away:\n-                let break_expr = cx.expr(span, ast::ExprBreak(opt_ident.map(|x| x.name)));\n-                let none_pat = cx.pat_ident(span, none_ident);\n-                cx.arm(span, ~[none_pat], break_expr)\n+                let break_expr = fld.cx.expr(span, ast::ExprBreak(opt_ident.map(|x| x.name)));\n+                let none_pat = fld.cx.pat_ident(span, none_ident);\n+                fld.cx.arm(span, ~[none_pat], break_expr)\n             };\n \n             // `Some(<src_pat>) => <src_loop_block>`\n             let some_arm =\n-                cx.arm(span,\n-                       ~[cx.pat_enum(span, some_path, ~[src_pat])],\n-                       cx.expr_block(src_loop_block));\n+                fld.cx.arm(span,\n+                           ~[fld.cx.pat_enum(span, some_path, ~[src_pat])],\n+                           fld.cx.expr_block(src_loop_block));\n \n             // `match i.next() { ... }`\n             let match_expr = {\n                 let next_call_expr =\n-                    cx.expr_method_call(span, cx.expr_path(local_path), next_ident, ~[]);\n+                    fld.cx.expr_method_call(span, fld.cx.expr_path(local_path), next_ident, ~[]);\n \n-                cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n+                fld.cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n             };\n \n             // ['ident:] loop { ... }\n-            let loop_expr = cx.expr(span,\n-                                    ast::ExprLoop(cx.block_expr(match_expr), opt_ident));\n+            let loop_expr = fld.cx.expr(span,\n+                                        ast::ExprLoop(fld.cx.block_expr(match_expr),\n+                                                      opt_ident));\n \n             // `{ let ... ;  loop { ... } }`\n-            let block = cx.block(span,\n-                                 ~[iter_decl_stmt],\n-                                 Some(loop_expr));\n+            let block = fld.cx.block(span,\n+                                     ~[iter_decl_stmt],\n+                                     Some(loop_expr));\n \n             @ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n@@ -213,11 +210,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n-                        cx: @ExtCtxt,\n-                        module_: &ast::_mod,\n-                        fld: &MacroExpander)\n-                        -> ast::_mod {\n+pub fn expand_mod_items(module_: &ast::_mod, fld: &mut MacroExpander) -> ast::_mod {\n     // Fold the contents first:\n     let module_ = noop_fold_mod(module_, fld);\n \n@@ -228,18 +221,18 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         item.attrs.rev_iter().fold(~[*item], |items, attr| {\n             let mname = attr.name();\n \n-            match (*extsbox).find(&intern(mname)) {\n+            match (*fld.extsbox).find(&intern(mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n-                  cx.bt_push(ExpnInfo {\n+                  fld.cx.bt_push(ExpnInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n                           name: mname,\n                           format: MacroAttribute,\n                           span: None\n                       }\n                   });\n-                  let r = dec_fn(cx, attr.span, attr.node.value, items);\n-                  cx.bt_pop();\n+                  let r = dec_fn(fld.cx, attr.span, attr.node.value, items);\n+                  fld.cx.bt_pop();\n                   r\n               },\n               _ => items,\n@@ -270,20 +263,17 @@ macro_rules! with_exts_frame (\n static special_block_name : &'static str = \" block\";\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(extsbox: @mut SyntaxEnv,\n-                   cx: @ExtCtxt,\n-                   it: @ast::item,\n-                   fld: &MacroExpander)\n+pub fn expand_item(it: @ast::item, fld: &mut MacroExpander)\n                    -> SmallVector<@ast::item> {\n     match it.node {\n-        ast::item_mac(..) => expand_item_mac(extsbox, cx, it, fld),\n+        ast::item_mac(..) => expand_item_mac(it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n-            cx.mod_push(it.ident);\n+            fld.cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(it.attrs);\n-            let result = with_exts_frame!(extsbox,\n+            let result = with_exts_frame!(fld.extsbox,\n                                           macro_escape,\n                                           noop_fold_item(it, fld));\n-            cx.mod_pop();\n+            fld.cx.mod_pop();\n             result\n         },\n         _ => noop_fold_item(it, fld)\n@@ -297,10 +287,7 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n-                       cx: @ExtCtxt,\n-                       it: @ast::item,\n-                       fld: &MacroExpander)\n+pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n                        -> SmallVector<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned {\n@@ -309,24 +296,24 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         }) => {\n             (pth, (*tts).clone(), ctxt)\n         }\n-        _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n+        _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let fm = fresh_mark();\n-    let expanded = match (*extsbox).find(&extname.name) {\n-        None => cx.span_fatal(pth.span,\n-                              format!(\"macro undefined: '{}!'\", extnamestr)),\n+    let expanded = match (*fld.extsbox).find(&extname.name) {\n+        None => fld.cx.span_fatal(pth.span,\n+                                  format!(\"macro undefined: '{}!'\", extnamestr)),\n \n         Some(@SE(NormalTT(expander, span))) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n-                cx.span_fatal(pth.span,\n-                              format!(\"macro {}! expects no ident argument, \\\n-                                    given '{}'\", extnamestr,\n-                                   ident_to_str(&it.ident)));\n+                fld.cx.span_fatal(pth.span,\n+                                  format!(\"macro {}! expects no ident argument, \\\n+                                           given '{}'\", extnamestr,\n+                                           ident_to_str(&it.ident)));\n             }\n-            cx.bt_push(ExpnInfo {\n+            fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n@@ -337,15 +324,15 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_before = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander.expand(cx, it.span, marked_before, marked_ctxt)\n+            expander.expand(fld.cx, it.span, marked_before, marked_ctxt)\n         }\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n-                cx.span_fatal(pth.span,\n-                              format!(\"macro {}! expects an ident argument\",\n-                                   extnamestr));\n+                fld.cx.span_fatal(pth.span,\n+                                  format!(\"macro {}! expects an ident argument\",\n+                                          extnamestr));\n             }\n-            cx.bt_push(ExpnInfo {\n+            fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n@@ -356,10 +343,11 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander.expand(cx, it.span, it.ident, marked_tts, marked_ctxt)\n+            expander.expand(fld.cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n-        _ => cx.span_fatal(\n-            it.span, format!(\"{}! is not legal in item position\", extnamestr))\n+        _ => fld.cx.span_fatal(it.span,\n+                               format!(\"{}! is not legal in item position\",\n+                                       extnamestr))\n     };\n \n     let items = match expanded {\n@@ -369,7 +357,8 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 .collect()\n         }\n         MRExpr(_) => {\n-            cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\", extnamestr))\n+            fld.cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\",\n+                                                extnamestr))\n         }\n         MRAny(any_macro) => {\n             any_macro.make_items().move_iter()\n@@ -380,11 +369,11 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n-            insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n+            insert_macro(*fld.extsbox,intern(mdef.name), @SE((*mdef).ext));\n             SmallVector::zero()\n         }\n     };\n-    cx.bt_pop();\n+    fld.cx.bt_pop();\n     return items;\n }\n \n@@ -406,11 +395,7 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n }\n \n // expand a stmt\n-pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n-                   cx: @ExtCtxt,\n-                   s: &Stmt,\n-                   fld: &MacroExpander)\n-                   -> SmallVector<@Stmt> {\n+pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi, ctxt) = match s.node {\n@@ -421,21 +406,21 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 }\n             }\n         }\n-        _ => return expand_non_macro_stmt(*extsbox, s, fld)\n+        _ => return expand_non_macro_stmt(s, fld)\n     };\n     if (pth.segments.len() > 1u) {\n-        cx.span_fatal(pth.span,\n-                      \"expected macro name without module separators\");\n+        fld.cx.span_fatal(pth.span,\n+                          \"expected macro name without module separators\");\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let fully_expanded: SmallVector<@Stmt> = match (*extsbox).find(&extname.name) {\n+    let fully_expanded: SmallVector<@Stmt> = match (*fld.extsbox).find(&extname.name) {\n         None => {\n-            cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n+            fld.cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n \n         Some(@SE(NormalTT(expandfun, exp_span))) => {\n-            cx.bt_push(ExpnInfo {\n+            fld.cx.bt_push(ExpnInfo {\n                 call_site: s.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n@@ -450,9 +435,9 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n             // See the comment in expand_expr for why we want the original span,\n             // not the current mac.span.\n-            let mac_span = original_span(cx);\n+            let mac_span = original_span(fld.cx);\n \n-            let expanded = match expandfun.expand(cx,\n+            let expanded = match expandfun.expand(fld.cx,\n                                                   mac_span.call_site,\n                                                   marked_tts,\n                                                   marked_ctxt) {\n@@ -463,7 +448,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                     }\n                 }\n                 MRAny(any_macro) => any_macro.make_stmt(),\n-                _ => cx.span_fatal(\n+                _ => fld.cx.span_fatal(\n                     pth.span,\n                     format!(\"non-stmt macro in stmt pos: {}\", extnamestr))\n             };\n@@ -472,18 +457,19 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             // Keep going, outside-in.\n             let fully_expanded = fld.fold_stmt(marked_after);\n             if fully_expanded.is_empty() {\n-                cx.span_fatal(pth.span,\n+                fld.cx.span_fatal(pth.span,\n                               \"macro didn't expand to a statement\");\n             }\n-            cx.bt_pop();\n+            fld.cx.bt_pop();\n             fully_expanded.move_iter()\n                     .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n                     .collect()\n         }\n \n         _ => {\n-            cx.span_fatal(pth.span,\n-                          format!(\"'{}' is not a tt-style macro\", extnamestr))\n+            fld.cx.span_fatal(pth.span,\n+                              format!(\"'{}' is not a tt-style macro\",\n+                                      extnamestr))\n         }\n     };\n \n@@ -502,7 +488,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n+fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                          -> SmallVector<@Stmt> {\n     // is it a let?\n     match s.node {\n@@ -511,7 +497,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             span: stmt_span\n         },\n         node_id) => {\n-            let block_info = get_block_info(exts);\n+            let block_info = get_block_info(*fld.extsbox);\n             let pending_renames = block_info.pending_renames;\n \n             // take it apart:\n@@ -536,7 +522,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n                 let new_name = fresh_name(ident);\n                 new_pending_renames.push((*ident,new_name));\n             }\n-            let rename_fld = renames_to_fold(new_pending_renames);\n+            let mut rename_fld = renames_to_fold(new_pending_renames);\n             // rewrite the pattern using the new names (the old ones\n             // have already been applied):\n             let rewritten_pat = rename_fld.fold_pat(expanded_pat);\n@@ -624,22 +610,17 @@ pub fn new_name_finder(idents: ~[ast::Ident]) -> NewNameFinderContext {\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    _: @ExtCtxt,\n-                    blk: &Block,\n-                    fld: &MacroExpander)\n-                    -> P<Block> {\n+pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n-    with_exts_frame!(extsbox,false,\n-                     expand_block_elts(*extsbox, blk, fld))\n+    with_exts_frame!(fld.extsbox,false,\n+                     expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n-                         -> P<Block> {\n-    let block_info = get_block_info(exts);\n+pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n+    let block_info = get_block_info(*fld.extsbox);\n     let pending_renames = block_info.pending_renames;\n-    let rename_fld = renames_to_fold(pending_renames);\n+    let mut rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let new_stmts = b.stmts.iter()\n             .map(|x| rename_fld.fold_stmt(*x)\n@@ -671,7 +652,7 @@ struct IdentRenamer {\n }\n \n impl ast_fold for IdentRenamer {\n-    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+    fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n             new_rename(from, to, ctxt)\n         });\n@@ -684,13 +665,13 @@ impl ast_fold for IdentRenamer {\n \n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n-pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n-    @IdentRenamer {\n+pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> IdentRenamer {\n+    IdentRenamer {\n         renames: renames,\n-    } as @ast_fold\n+    }\n }\n \n-pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n+pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n     Span {\n         lo: sp.lo,\n@@ -917,7 +898,7 @@ struct Injector {\n }\n \n impl ast_fold for Injector {\n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         // Just inject the standard macros at the start of the first module\n         // in the crate: that is, at the start of the crate file itself.\n         let items = vec::append(~[ self.sm ], module.items);\n@@ -943,54 +924,39 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n         None => fail!(\"expected core macros to parse correctly\")\n     };\n \n-    let injector = @Injector {\n+    let mut injector = Injector {\n         sm: sm,\n-    } as @ast_fold;\n+    };\n     injector.fold_crate(c)\n }\n \n-pub struct MacroExpander {\n+pub struct MacroExpander<'a> {\n     extsbox: @mut SyntaxEnv,\n-    cx: @ExtCtxt,\n+    cx: &'a mut ExtCtxt,\n }\n \n-impl ast_fold for MacroExpander {\n-    fn fold_expr(&self, expr: @ast::Expr) -> @ast::Expr {\n-        expand_expr(self.extsbox,\n-                    self.cx,\n-                    expr,\n-                    self)\n+impl<'a> ast_fold for MacroExpander<'a> {\n+    fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n+        expand_expr(expr, self)\n     }\n \n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n-        expand_mod_items(self.extsbox,\n-                         self.cx,\n-                         module,\n-                         self)\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n+        expand_mod_items(module, self)\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n-        expand_item(self.extsbox,\n-                    self.cx,\n-                    item,\n-                    self)\n+    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n+        expand_item(item, self)\n     }\n \n-    fn fold_stmt(&self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n-        expand_stmt(self.extsbox,\n-                    self.cx,\n-                    stmt,\n-                    self)\n+    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n+        expand_stmt(stmt, self)\n     }\n \n-    fn fold_block(&self, block: P<Block>) -> P<Block> {\n-        expand_block(self.extsbox,\n-                     self.cx,\n-                     block,\n-                     self)\n+    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n+        expand_block(block, self)\n     }\n \n-    fn new_span(&self, span: Span) -> Span {\n+    fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n }\n@@ -1004,11 +970,11 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // exts table through the fold, but that would require updating\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = syntax_expander_table();\n-    let cx = ExtCtxt::new(parse_sess, cfg.clone());\n-    let expander = @MacroExpander {\n+    let mut cx = ExtCtxt::new(parse_sess, cfg.clone());\n+    let mut expander = MacroExpander {\n         extsbox: @mut extsbox,\n-        cx: cx,\n-    } as @ast_fold;\n+        cx: &mut cx,\n+    };\n \n     let ret = expander.fold_crate(c);\n     parse_sess.span_diagnostic.handler().abort_if_errors();\n@@ -1081,7 +1047,7 @@ pub struct ContextWrapper {\n }\n \n impl ast_fold for ContextWrapper {\n-    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+    fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let ast::Ident {\n             name,\n             ctxt\n@@ -1091,7 +1057,7 @@ impl ast_fold for ContextWrapper {\n             ctxt: self.context_function.f(ctxt),\n         }\n     }\n-    fn fold_mac(&self, m: &ast::mac) -> ast::mac {\n+    fn fold_mac(&mut self, m: &ast::mac) -> ast::mac {\n         let macro = match m.node {\n             mac_invoc_tt(ref path, ref tts, ctxt) => {\n                 mac_invoc_tt(self.fold_path(path),\n@@ -1108,24 +1074,24 @@ impl ast_fold for ContextWrapper {\n \n // given a function from ctxts to ctxts, produce\n // an ast_fold that applies that function to all ctxts:\n-pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @ContextWrapper {\n-    @ContextWrapper {\n+pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> ContextWrapper {\n+    ContextWrapper {\n         context_function: cf as @CtxtFn,\n     }\n }\n \n // just a convenience:\n-pub fn new_mark_folder(m: Mrk) -> @ContextWrapper {\n+pub fn new_mark_folder(m: Mrk) -> ContextWrapper {\n     fun_to_ctxt_folder(@Marker{mark:m})\n }\n \n-pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> @ContextWrapper {\n+pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> ContextWrapper {\n     fun_to_ctxt_folder(@Renamer{from:from,to:to})\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n-    fold_tts(tts,new_mark_folder(m))\n+    fold_tts(tts, &mut new_mark_folder(m))\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n@@ -1159,7 +1125,7 @@ pub fn mtwt_cancel_outer_mark(tts: &[ast::token_tree], ctxt: ast::SyntaxContext)\n     mark_tts(tts,outer_mark)\n }\n \n-fn original_span(cx: @ExtCtxt) -> @codemap::ExpnInfo {\n+fn original_span(cx: &ExtCtxt) -> @codemap::ExpnInfo {\n     let mut relevant_info = cx.backtrace();\n     let mut einfo = relevant_info.unwrap();\n     loop {\n@@ -1330,7 +1296,7 @@ mod test {\n         let ident_str = @\"x\";\n         let tts = string_to_tts(ident_str);\n         let fm = fresh_mark();\n-        let marked_once = fold::fold_tts(tts,new_mark_folder(fm));\n+        let marked_once = fold::fold_tts(tts,&mut new_mark_folder(fm));\n         assert_eq!(marked_once.len(),1);\n         let marked_once_ctxt =\n             match marked_once[0] {\n@@ -1352,7 +1318,7 @@ mod test {\n         let item_ast = string_to_crate(@\"fn f() -> int { a }\");\n         let a_name = intern(\"a\");\n         let a2_name = gensym(\"a2\");\n-        let renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n+        let mut renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n         let renamed_ast = renamer.fold_crate(item_ast.clone());\n         let mut path_finder = new_path_finder(~[]);"}, {"sha": "34a8236905b0aa3c8150856773f612c93b8b49a5", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use codemap::Span;\n use ext::base;\n use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(ecx: @base::ExtCtxt, sp: Span,\n+pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt, sp: Span,\n                          _tts: &[ast::token_tree]) -> base::MacResult {\n     ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n     ecx.parse_sess.span_diagnostic.span_note(sp,"}, {"sha": "3bfab7da9b46d50d949b3a9ffbd45ab2976d48a9", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -28,8 +28,8 @@ enum ArgumentType {\n     String,\n }\n \n-struct Context {\n-    ecx: @ExtCtxt,\n+struct Context<'a> {\n+    ecx: &'a mut ExtCtxt,\n     fmtsp: Span,\n \n     // Parsed argument expressions and the types that we've found so far for\n@@ -50,7 +50,7 @@ struct Context {\n     next_arg: uint,\n }\n \n-impl Context {\n+impl<'a> Context<'a> {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other format! expressions.\n     fn parse_args(&mut self, sp: Span,\n@@ -722,7 +722,7 @@ impl Context {\n     }\n }\n \n-pub fn expand_args(ecx: @ExtCtxt, sp: Span,\n+pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n                    tts: &[ast::token_tree]) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n@@ -739,19 +739,20 @@ pub fn expand_args(ecx: @ExtCtxt, sp: Span,\n     };\n     let (extra, efmt) = match cx.parse_args(sp, tts) {\n         (extra, Some(e)) => (extra, e),\n-        (_, None) => { return MRExpr(ecx.expr_uint(sp, 2)); }\n+        (_, None) => { return MRExpr(cx.ecx.expr_uint(sp, 2)); }\n     };\n     cx.fmtsp = efmt.span;\n     // Be sure to recursively expand macros just in case the format string uses\n     // a macro to build the format expression.\n-    let (fmt, _) = expr_to_str(ecx, ecx.expand_expr(efmt),\n+    let expr = cx.ecx.expand_expr(efmt);\n+    let (fmt, _) = expr_to_str(cx.ecx, expr,\n                                \"format argument must be a string literal.\");\n \n     let mut err = false;\n     parse::parse_error::cond.trap(|m| {\n         if !err {\n             err = true;\n-            ecx.span_err(efmt.span, m);\n+            cx.ecx.span_err(efmt.span, m);\n         }\n     }).inside(|| {\n         for piece in parse::Parser::new(fmt) {\n@@ -767,12 +768,12 @@ pub fn expand_args(ecx: @ExtCtxt, sp: Span,\n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.is_none() {\n-            ecx.span_err(cx.args[i].span, \"argument never used\");\n+            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n         }\n     }\n     for (name, e) in cx.names.iter() {\n         if !cx.name_types.contains_key(name) {\n-            ecx.span_err(e.span, \"named argument never used\");\n+            cx.ecx.span_err(e.span, \"named argument never used\");\n         }\n     }\n "}, {"sha": "22b04501cfbec2b5fe444d6a63f1e0f2b856091e", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -15,7 +15,7 @@ use ext::base;\n use print;\n use parse::token::{get_ident_interner};\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt,\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt,\n                          sp: codemap::Span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {"}, {"sha": "330d33d6fc6c4436d4c84f218fda9e7e997faab4", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -40,11 +40,11 @@ pub mod rt {\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n     pub trait ToTokens {\n-        fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree];\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[token_tree];\n     }\n \n     impl ToTokens for ~[token_tree] {\n-        fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree] {\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[token_tree] {\n             (*self).clone()\n         }\n     }\n@@ -56,7 +56,7 @@ pub mod rt {\n         pub fn to_source() -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n-        pub fn to_tokens(cx: @ExtCtxt) -> ~[token_tree] {\n+        pub fn to_tokens(cx: &ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }\n     }\n@@ -199,7 +199,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens(\n         ($t:ty) => (\n             impl ToTokens for $t {\n-                fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> ~[token_tree] {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -209,7 +209,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens_self(\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n-                fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> ~[token_tree] {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -289,22 +289,22 @@ pub mod rt {\n \n }\n \n-pub fn expand_quote_tokens(cx: @ExtCtxt,\n+pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n     base::MRExpr(expanded)\n }\n \n-pub fn expand_quote_expr(cx: @ExtCtxt,\n+pub fn expand_quote_expr(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n     base::MRExpr(expanded)\n }\n \n-pub fn expand_quote_item(cx: @ExtCtxt,\n+pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n@@ -313,7 +313,7 @@ pub fn expand_quote_item(cx: @ExtCtxt,\n     base::MRExpr(expanded)\n }\n \n-pub fn expand_quote_pat(cx: @ExtCtxt,\n+pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n@@ -322,7 +322,7 @@ pub fn expand_quote_pat(cx: @ExtCtxt,\n     base::MRExpr(expanded)\n }\n \n-pub fn expand_quote_ty(cx: @ExtCtxt,\n+pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n@@ -331,7 +331,7 @@ pub fn expand_quote_ty(cx: @ExtCtxt,\n     base::MRExpr(expanded)\n }\n \n-pub fn expand_quote_stmt(cx: @ExtCtxt,\n+pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n@@ -349,15 +349,15 @@ fn id_ext(str: &str) -> ast::Ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n+fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n     let e_str = cx.expr_str(sp, cx.str_of(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n                         ~[e_str])\n }\n \n-fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::Expr {\n+fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::binop) -> @ast::Expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -373,7 +373,7 @@ fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::Expr {\n     cx.expr_ident(sp, id_ext(name))\n }\n \n-fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n+fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -528,7 +528,7 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n }\n \n \n-fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::token_tree)\n     -> ~[@ast::Stmt] {\n \n     match *tt {\n@@ -570,7 +570,7 @@ fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n     }\n }\n \n-fn mk_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> ~[@ast::Stmt] {\n     let mut ss = ~[];\n     for tt in tts.iter() {\n@@ -579,7 +579,7 @@ fn mk_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: @ExtCtxt,\n+fn expand_tts(cx: &ExtCtxt,\n               sp: Span,\n               tts: &[ast::token_tree]) -> (@ast::Expr, @ast::Expr) {\n \n@@ -652,7 +652,7 @@ fn expand_tts(cx: @ExtCtxt,\n     (cx_expr, block)\n }\n \n-fn expand_wrapper(cx: @ExtCtxt,\n+fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: @ast::Expr,\n                   expr: @ast::Expr) -> @ast::Expr {\n@@ -667,7 +667,7 @@ fn expand_wrapper(cx: @ExtCtxt,\n     cx.expr_block(cx.block_all(sp, uses, ~[stmt_let_ext_cx], Some(expr)))\n }\n \n-fn expand_parse_call(cx: @ExtCtxt,\n+fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n                      arg_exprs: ~[@ast::Expr],"}, {"sha": "ccf4bf2acd6f312e84190a7f36db379657467083", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -28,7 +28,7 @@ use std::str;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -39,7 +39,7 @@ pub fn expand_line(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -51,7 +51,7 @@ pub fn expand_col(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -61,13 +61,13 @@ pub fn expand_file(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, get_ident_interner());\n     base::MRExpr(cx.expr_str(sp, s.to_managed()))\n }\n \n-pub fn expand_mod(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(cx.expr_str(sp,\n@@ -77,7 +77,7 @@ pub fn expand_mod(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     // The file will be added to the code map by the parser\n@@ -88,7 +88,7 @@ pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n@@ -120,7 +120,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     }\n }\n \n-pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n         -> base::MacResult\n {\n     use std::at_vec;\n@@ -167,7 +167,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: @ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n+fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n         let mut cu = Path::new(cx.codemap().span_to_filename(sp));"}, {"sha": "d9b1c2bddbca82df9a90b75ecf0e8cd86d38ab3a", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -16,7 +16,7 @@ use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n use parse::token::keywords;\n \n-pub fn expand_trace_macros(cx: @ExtCtxt,\n+pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[ast::token_tree])\n                         -> base::MacResult {"}, {"sha": "ae9bbdadf2cbd9ed4dc9ce3cd23f6c5874156eb2", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -83,7 +83,7 @@ struct MacroRulesSyntaxExpanderTTFun {\n \n impl SyntaxExpanderTTTrait for MacroRulesSyntaxExpanderTTFun {\n     fn expand(&self,\n-              cx: @ExtCtxt,\n+              cx: &mut ExtCtxt,\n               sp: Span,\n               arg: &[ast::token_tree],\n               _: ast::SyntaxContext)\n@@ -93,7 +93,7 @@ impl SyntaxExpanderTTTrait for MacroRulesSyntaxExpanderTTFun {\n }\n \n // Given `lhses` and `rhses`, this is the new macro we create\n-fn generic_extension(cx: @ExtCtxt,\n+fn generic_extension(cx: &ExtCtxt,\n                      sp: Span,\n                      name: Ident,\n                      arg: &[ast::token_tree],\n@@ -168,7 +168,7 @@ fn generic_extension(cx: @ExtCtxt,\n // this procedure performs the expansion of the\n // macro_rules! macro. It parses the RHS and adds\n // an extension to the current context.\n-pub fn add_new_extension(cx: @ExtCtxt,\n+pub fn add_new_extension(cx: &mut ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n                          arg: ~[ast::token_tree],"}, {"sha": "9edde7c9c87addba41ee6d837d45a60c3589063c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -17,15 +17,15 @@ use util::small_vector::SmallVector;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n-    fn fold_crate(&self, c: Crate) -> Crate {\n+    fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n+    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n         meta_items.map(|x| fold_meta_item_(*x, self))\n     }\n \n-    fn fold_view_paths(&self, view_paths: &[@view_path]) -> ~[@view_path] {\n+    fn fold_view_paths(&mut self, view_paths: &[@view_path]) -> ~[@view_path] {\n         view_paths.map(|view_path| {\n             let inner_view_path = match view_path.node {\n                 view_path_simple(ref ident, ref path, node_id) => {\n@@ -62,7 +62,7 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_view_item(&self, vi: &view_item) -> view_item {\n+    fn fold_view_item(&mut self, vi: &view_item) -> view_item {\n         let inner_view_item = match vi.node {\n             view_item_extern_mod(ref ident,\n                                  string,\n@@ -85,7 +85,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_foreign_item(&self, ni: @foreign_item) -> @foreign_item {\n+    fn fold_foreign_item(&mut self, ni: @foreign_item) -> @foreign_item {\n         let fold_attribute = |x| fold_attribute_(x, self);\n \n         @ast::foreign_item {\n@@ -114,11 +114,11 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item(&self, i: @item) -> SmallVector<@item> {\n+    fn fold_item(&mut self, i: @item) -> SmallVector<@item> {\n         noop_fold_item(i, self)\n     }\n \n-    fn fold_struct_field(&self, sf: &struct_field) -> struct_field {\n+    fn fold_struct_field(&mut self, sf: &struct_field) -> struct_field {\n         let fold_attribute = |x| fold_attribute_(x, self);\n \n         Spanned {\n@@ -132,15 +132,15 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item_underscore(&self, i: &item_) -> item_ {\n+    fn fold_item_underscore(&mut self, i: &item_) -> item_ {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_type_method(&self, m: &TypeMethod) -> TypeMethod {\n+    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&self, m: @method) -> @method {\n+    fn fold_method(&mut self, m: @method) -> @method {\n         @ast::method {\n             ident: self.fold_ident(m.ident),\n             attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n@@ -156,23 +156,23 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_block(&self, b: P<Block>) -> P<Block> {\n+    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&self, s: &Stmt) -> SmallVector<@Stmt> {\n+    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<@Stmt> {\n         noop_fold_stmt(s, self)\n     }\n \n-    fn fold_arm(&self, a: &Arm) -> Arm {\n+    fn fold_arm(&mut self, a: &Arm) -> Arm {\n         Arm {\n             pats: a.pats.map(|x| self.fold_pat(*x)),\n             guard: a.guard.map(|x| self.fold_expr(x)),\n             body: self.fold_block(a.body),\n         }\n     }\n \n-    fn fold_pat(&self, p: @Pat) -> @Pat {\n+    fn fold_pat(&mut self, p: @Pat) -> @Pat {\n         let node = match p.node {\n             PatWild => PatWild,\n             PatWildMulti => PatWildMulti,\n@@ -217,7 +217,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_decl(&self, d: @Decl) -> SmallVector<@Decl> {\n+    fn fold_decl(&mut self, d: @Decl) -> SmallVector<@Decl> {\n         let node = match d.node {\n             DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n             DeclItem(it) => {\n@@ -233,11 +233,11 @@ pub trait ast_fold {\n         }).collect()\n     }\n \n-    fn fold_expr(&self, e: @Expr) -> @Expr {\n+    fn fold_expr(&mut self, e: @Expr) -> @Expr {\n         noop_fold_expr(e, self)\n     }\n \n-    fn fold_ty(&self, t: P<Ty>) -> P<Ty> {\n+    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         let node = match t.node {\n             ty_nil | ty_bot | ty_infer => t.node.clone(),\n             ty_box(ref mt) => ty_box(fold_mt(mt, self)),\n@@ -284,11 +284,11 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_mod(&self, m: &_mod) -> _mod {\n+    fn fold_mod(&mut self, m: &_mod) -> _mod {\n         noop_fold_mod(m, self)\n     }\n \n-    fn fold_foreign_mod(&self, nm: &foreign_mod) -> foreign_mod {\n+    fn fold_foreign_mod(&mut self, nm: &foreign_mod) -> foreign_mod {\n         ast::foreign_mod {\n             abis: nm.abis,\n             view_items: nm.view_items\n@@ -302,7 +302,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_variant(&self, v: &variant) -> P<variant> {\n+    fn fold_variant(&mut self, v: &variant) -> P<variant> {\n         let kind;\n         match v.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n@@ -339,11 +339,11 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_ident(&self, i: Ident) -> Ident {\n+    fn fold_ident(&mut self, i: Ident) -> Ident {\n         i\n     }\n \n-    fn fold_path(&self, p: &Path) -> Path {\n+    fn fold_path(&mut self, p: &Path) -> Path {\n         ast::Path {\n             span: self.new_span(p.span),\n             global: p.global,\n@@ -355,7 +355,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_local(&self, l: @Local) -> @Local {\n+    fn fold_local(&mut self, l: @Local) -> @Local {\n         @Local {\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n@@ -365,7 +365,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_mac(&self, macro: &mac) -> mac {\n+    fn fold_mac(&mut self, macro: &mac) -> mac {\n         Spanned {\n             node: match macro.node {\n                 mac_invoc_tt(ref p, ref tts, ctxt) => {\n@@ -382,22 +382,22 @@ pub trait ast_fold {\n         es.map(|x| f(*x))\n     }\n \n-    fn new_id(&self, i: NodeId) -> NodeId {\n+    fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n \n-    fn new_span(&self, sp: Span) -> Span {\n+    fn new_span(&mut self, sp: Span) -> Span {\n         sp\n     }\n \n-    fn fold_explicit_self(&self, es: &explicit_self) -> explicit_self {\n+    fn fold_explicit_self(&mut self, es: &explicit_self) -> explicit_self {\n         Spanned {\n             span: self.new_span(es.span),\n             node: self.fold_explicit_self_(&es.node)\n         }\n     }\n \n-    fn fold_explicit_self_(&self, es: &explicit_self_) -> explicit_self_ {\n+    fn fold_explicit_self_(&mut self, es: &explicit_self_) -> explicit_self_ {\n         match *es {\n             sty_static | sty_value(_) | sty_uniq(_) | sty_box(_) => {\n                 *es\n@@ -412,7 +412,7 @@ pub trait ast_fold {\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &T) -> @MetaItem {\n+fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n     @Spanned {\n         node:\n             match mi.node {\n@@ -430,7 +430,7 @@ fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &T) -> @MetaItem {\n }\n \n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n+fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n     Spanned {\n         span: fld.new_span(at.span),\n         node: ast::Attribute_ {\n@@ -442,7 +442,7 @@ fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n }\n \n //used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n+fn fold_arg_<T:ast_fold>(a: &arg, fld: &mut T) -> arg {\n     ast::arg {\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n@@ -452,7 +452,7 @@ fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n \n // build a new vector of tts by appling the ast_fold's fold_ident to\n // all of the identifiers in the token trees.\n-pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n+pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &mut T) -> ~[token_tree] {\n     tts.map(|tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n@@ -470,7 +470,7 @@ pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n+fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n@@ -479,7 +479,7 @@ fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n     }\n }\n \n-pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n+pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &mut T)\n                                 -> P<fn_decl> {\n     P(fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n@@ -489,66 +489,66 @@ pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n     })\n }\n \n-fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &T)\n+fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &mut T)\n                                    -> TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &T) -> TyParam {\n+pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &mut T) -> TyParam {\n     TyParam {\n         ident: tp.ident,\n         id: fld.new_id(tp.id),\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n     }\n }\n \n-pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &T)\n+pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &mut T)\n                                   -> OptVec<TyParam> {\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n-pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &T) -> Lifetime {\n+pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         span: fld.new_span(l.span),\n         ident: l.ident\n     }\n }\n \n-pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &T)\n+pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &mut T)\n                                   -> OptVec<Lifetime> {\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n-pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &T)\n+pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &mut T)\n                                      -> Option<Lifetime> {\n     o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n }\n \n-pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &T) -> Generics {\n+pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &mut T) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &T)\n+fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &mut T)\n                                -> @ast::struct_def {\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(f, fld)),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n     }\n }\n \n-fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &T) -> trait_ref {\n+fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &mut T) -> trait_ref {\n     ast::trait_ref {\n         path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &T) -> struct_field {\n+fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &mut T) -> struct_field {\n     Spanned {\n         node: ast::struct_field_ {\n             kind: f.node.kind,\n@@ -560,22 +560,22 @@ fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &T) -> struct_field {\n     }\n }\n \n-fn fold_field_<T:ast_fold>(field: Field, folder: &T) -> Field {\n+fn fold_field_<T:ast_fold>(field: Field, folder: &mut T) -> Field {\n     ast::Field {\n         ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n         expr: folder.fold_expr(field.expr),\n         span: folder.new_span(field.span),\n     }\n }\n \n-fn fold_mt<T:ast_fold>(mt: &mt, folder: &T) -> mt {\n+fn fold_mt<T:ast_fold>(mt: &mt, folder: &mut T) -> mt {\n     mt {\n         ty: folder.fold_ty(mt.ty),\n         mutbl: mt.mutbl,\n     }\n }\n \n-fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n+fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n                                -> Option<OptVec<TyParamBound>> {\n     b.as_ref().map(|bounds| {\n         bounds.map(|bound| {\n@@ -584,15 +584,15 @@ fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n     })\n }\n \n-fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n+fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &mut T)\n                                  -> variant_arg {\n     ast::variant_arg {\n         ty: folder.fold_ty(va.ty),\n         id: folder.new_id(va.id)\n     }\n }\n \n-pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &T) -> P<Block> {\n+pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n@@ -605,7 +605,7 @@ pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &T) -> P<Block> {\n     })\n }\n \n-pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n+pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &mut T) -> item_ {\n     match *i {\n         item_static(t, m, e) => {\n             item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n@@ -662,7 +662,7 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n     }\n }\n \n-pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n+pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &mut T)\n                                          -> TypeMethod {\n     TypeMethod {\n         ident: fld.fold_ident(m.ident),\n@@ -676,7 +676,7 @@ pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n     }\n }\n \n-pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n+pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &mut T) -> _mod {\n     ast::_mod {\n         view_items: m.view_items\n                      .iter()\n@@ -685,7 +685,7 @@ pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n     }\n }\n \n-pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n+pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &mut T) -> Crate {\n     let fold_meta_item = |x| fold_meta_item_(x, folder);\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n@@ -697,7 +697,7 @@ pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n     }\n }\n \n-pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n+pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &mut T)\n                                   -> SmallVector<@ast::item> {\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n@@ -711,23 +711,23 @@ pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n     })\n }\n \n-pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n+pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &mut T) -> @ast::Expr {\n     let fold_field = |x| fold_field_(x, folder);\n \n     let node = match e.node {\n         ExprVstore(e, v) => {\n             ExprVstore(folder.fold_expr(e), v)\n         }\n         ExprVec(ref exprs, mutt) => {\n-            ExprVec(folder.map_exprs(|x| folder.fold_expr(x), *exprs), mutt)\n+            ExprVec(exprs.map(|&x| folder.fold_expr(x)), mutt)\n         }\n         ExprRepeat(expr, count, mutt) => {\n             ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count), mutt)\n         }\n         ExprTup(ref elts) => ExprTup(elts.map(|x| folder.fold_expr(*x))),\n         ExprCall(f, ref args, blk) => {\n             ExprCall(folder.fold_expr(f),\n-                     folder.map_exprs(|x| folder.fold_expr(x), *args),\n+                     args.map(|&x| folder.fold_expr(x)),\n                      blk)\n         }\n         ExprMethodCall(callee_id, f, i, ref tps, ref args, blk) => {\n@@ -736,7 +736,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n                 folder.fold_expr(f),\n                 folder.fold_ident(i),\n                 tps.map(|&x| folder.fold_ty(x)),\n-                folder.map_exprs(|x| folder.fold_expr(x), *args),\n+                args.map(|&x| folder.fold_expr(x)),\n                 blk\n             )\n         }\n@@ -837,7 +837,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n     }\n }\n \n-pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> SmallVector<@Stmt> {\n+pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n     let nodes = match s.node {\n         StmtDecl(d, nid) => {\n             folder.fold_decl(d).move_iter()\n@@ -876,7 +876,7 @@ mod test {\n     struct ToZzIdentFolder;\n \n     impl ast_fold for ToZzIdentFolder {\n-        fn fold_ident(&self, _: ast::Ident) -> ast::Ident {\n+        fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n     }\n@@ -898,23 +898,23 @@ mod test {\n \n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n-        let zz_fold = ToZzIdentFolder;\n+        let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n-        let zz_fold = ToZzIdentFolder;\n+        let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }"}, {"sha": "dc95faa19864766dc30bc1dea4d2b92c21fac9b3", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc5eefa231d98273214c47ecff9dcb2fbe37460/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=adc5eefa231d98273214c47ecff9dcb2fbe37460", "patch": "@@ -16,7 +16,7 @@ extern mod syntax;\n \n use syntax::ext::base::ExtCtxt;\n \n-fn syntax_extension(cx: @ExtCtxt) {\n+fn syntax_extension(cx: &ExtCtxt) {\n     let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, 1 + 2);\n     let p_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, (x, 1 .. 4, *));\n "}]}