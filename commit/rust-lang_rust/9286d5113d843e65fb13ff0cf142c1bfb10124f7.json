{"sha": "9286d5113d843e65fb13ff0cf142c1bfb10124f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyODZkNTExM2Q4NDNlNjVmYjEzZmYwY2YxNDJjMWJmYjEwMTI0Zjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-01T18:13:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Migrate uv signal handling away from ~fn()", "tree": {"sha": "68c53cf968e7ab66788f0d32f861f5ebffa15d93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68c53cf968e7ab66788f0d32f861f5ebffa15d93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9286d5113d843e65fb13ff0cf142c1bfb10124f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9286d5113d843e65fb13ff0cf142c1bfb10124f7", "html_url": "https://github.com/rust-lang/rust/commit/9286d5113d843e65fb13ff0cf142c1bfb10124f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9286d5113d843e65fb13ff0cf142c1bfb10124f7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceab326e82dfba2f3cd513926c023dea1af4b1c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceab326e82dfba2f3cd513926c023dea1af4b1c2", "html_url": "https://github.com/rust-lang/rust/commit/ceab326e82dfba2f3cd513926c023dea1af4b1c2"}], "stats": {"total": 143, "additions": 56, "deletions": 87}, "files": [{"sha": "487c007658083f3bb7988cca01f011c8b5233f47", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=9286d5113d843e65fb13ff0cf142c1bfb10124f7", "patch": "@@ -191,7 +191,6 @@ pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n-pub type SignalCallback = ~fn(SignalWatcher, Signum);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n@@ -206,7 +205,6 @@ struct WatcherData {\n     async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n     udp_send_cb: Option<UdpSendCallback>,\n-    signal_cb: Option<SignalCallback>,\n }\n \n pub trait WatcherInterop {"}, {"sha": "fd35f9e494e873b4db4a2dafe196ba50b16e60bb", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=9286d5113d843e65fb13ff0cf142c1bfb10124f7", "patch": "@@ -103,7 +103,6 @@ impl Process {\n extern fn on_exit(handle: *uvll::uv_process_t,\n                   exit_status: libc::c_int,\n                   term_signal: libc::c_int) {\n-    let handle = handle as *uvll::uv_handle_t;\n     let p: &mut Process = unsafe { UvHandle::from_uv_handle(&handle) };\n \n     assert!(p.exit_status.is_none());"}, {"sha": "c195f48022735a3189bc8f225febb1c1367b87c4", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 51, "deletions": 44, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=9286d5113d843e65fb13ff0cf142c1bfb10124f7", "patch": "@@ -8,65 +8,72 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n use std::libc::c_int;\n use std::rt::io::signal::Signum;\n+use std::rt::sched::{SchedHandle, Scheduler};\n+use std::comm::{SharedChan, SendDeferred};\n+use std::rt::local::Local;\n+use std::rt::rtio::RtioSignal;\n \n-use super::{Loop, NativeHandle, SignalCallback, UvError, Watcher};\n+use super::{Loop, UvError, UvHandle};\n use uvll;\n+use uvio::HomingIO;\n \n-pub struct SignalWatcher(*uvll::uv_signal_t);\n+pub struct SignalWatcher {\n+    handle: *uvll::uv_signal_t,\n+    home: SchedHandle,\n \n-impl Watcher for SignalWatcher { }\n+    channel: SharedChan<Signum>,\n+    signal: Signum,\n+}\n \n impl SignalWatcher {\n-    pub fn new(loop_: &mut Loop) -> SignalWatcher {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_SIGNAL);\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::uv_signal_init(loop_.native_handle(), handle));\n-            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n-    }\n+    pub fn new(loop_: &mut Loop, signum: Signum,\n+               channel: SharedChan<Signum>) -> Result<~SignalWatcher, UvError> {\n+        let handle = UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL);\n+        assert_eq!(unsafe {\n+            uvll::signal_init(loop_.native_handle(), handle)\n+        }, 0);\n \n-    pub fn start(&mut self, signum: Signum, callback: SignalCallback)\n-            -> Result<(), UvError>\n-    {\n-        return unsafe {\n-            match uvll::uv_signal_start(self.native_handle(), signal_cb,\n-                                        signum as c_int) {\n-                0 => {\n-                    let data = self.get_watcher_data();\n-                    data.signal_cb = Some(callback);\n-                    Ok(())\n-                }\n-                n => Err(UvError(n)),\n+        match unsafe { uvll::signal_start(handle, signal_cb, signum as c_int) } {\n+            0 => {\n+                let s = ~SignalWatcher {\n+                    handle: handle,\n+                    home: get_handle_to_current_scheduler!(),\n+                    channel: channel,\n+                    signal: signum,\n+                };\n+                Ok(s.install())\n+            }\n+            n => {\n+                unsafe { uvll::free_handle(handle) }\n+                Err(UvError(n))\n             }\n-        };\n-\n-        extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n-            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n-            let data = watcher.get_watcher_data();\n-            let cb = data.signal_cb.get_ref();\n-            (*cb)(watcher, unsafe { cast::transmute(signum as int) });\n         }\n-    }\n \n-    pub fn stop(&mut self) {\n-        unsafe {\n-            uvll::uv_signal_stop(self.native_handle());\n-        }\n     }\n }\n \n-impl NativeHandle<*uvll::uv_signal_t> for SignalWatcher {\n-    fn from_native_handle(handle: *uvll::uv_signal_t) -> SignalWatcher {\n-        SignalWatcher(handle)\n-    }\n+extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n+    let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n+    assert_eq!(signum as int, s.signal as int);\n+    s.channel.send_deferred(s.signal);\n+}\n+\n+impl HomingIO for SignalWatcher {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n \n-    fn native_handle(&self) -> *uvll::uv_signal_t {\n-        match self { &SignalWatcher(ptr) => ptr }\n+impl UvHandle<uvll::uv_signal_t> for SignalWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_signal_t { self.handle }\n+}\n+\n+impl RtioSignal for SignalWatcher {}\n+\n+impl Drop for SignalWatcher {\n+    fn drop(&mut self) {\n+        do self.home_for_io |self_| {\n+            self_.close_async_();\n+        }\n     }\n }"}, {"sha": "956699c5c2e89060628eacb815b8e7b1f82ab098", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=9286d5113d843e65fb13ff0cf142c1bfb10124f7", "patch": "@@ -102,8 +102,7 @@ impl RtioTimer for TimerWatcher {\n }\n \n extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n-    let handle = handle as *uvll::uv_handle_t;\n-    let timer : &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n+    let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n     match timer.action.take_unwrap() {\n         WakeTask(task) => {"}, {"sha": "dc8793c285b800b14f4fe389eda368ae902f5787", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9286d5113d843e65fb13ff0cf142c1bfb10124f7/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=9286d5113d843e65fb13ff0cf142c1bfb10124f7", "patch": "@@ -13,8 +13,8 @@ use std::cast::transmute;\n use std::cast;\n use std::cell::Cell;\n use std::clone::Clone;\n-use std::comm::{SendDeferred, SharedChan, GenericChan};\n-use std::libc::{c_int, c_uint, c_void, pid_t};\n+use std::comm::{SharedChan, GenericChan};\n+use std::libc::{c_int, c_uint, c_void};\n use std::ptr;\n use std::str;\n use std::rt::io;\n@@ -841,11 +841,8 @@ impl IoFactory for UvIoFactory {\n \n     fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n         -> Result<~RtioSignal, IoError> {\n-        let watcher = SignalWatcher::new(self.uv_loop());\n-        let home = get_handle_to_current_scheduler!();\n-        let mut signal = ~UvSignal::new(watcher, home);\n-        match signal.watcher.start(signum, |_, _| channel.send_deferred(signum)) {\n-            Ok(()) => Ok(signal as ~RtioSignal),\n+        match SignalWatcher::new(self.uv_loop(), signum, channel) {\n+            Ok(s) => Ok(s as ~RtioSignal),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n@@ -1591,37 +1588,6 @@ impl RtioUnixAcceptor for UvUnixAcceptor {\n     }\n }\n \n-pub struct UvSignal {\n-    watcher: signal::SignalWatcher,\n-    home: SchedHandle,\n-}\n-\n-impl HomingIO for UvSignal {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvSignal {\n-    fn new(w: signal::SignalWatcher, home: SchedHandle) -> UvSignal {\n-        UvSignal { watcher: w, home: home }\n-    }\n-}\n-\n-impl RtioSignal for UvSignal {}\n-\n-impl Drop for UvSignal {\n-    fn drop(&mut self) {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        uvdebug!(\"closing UvSignal\");\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.watcher.close {\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-    }\n-}\n-\n // this function is full of lies\n unsafe fn local_io() -> &'static mut IoFactory {\n     do Local::borrow |sched: &mut Scheduler| {"}]}