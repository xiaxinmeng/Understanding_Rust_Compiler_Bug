{"sha": "15431b36bb760a8793740907e8d13e7ed8272e89", "node_id": "C_kwDOAAsO6NoAKDE1NDMxYjM2YmI3NjBhODc5Mzc0MDkwN2U4ZDEzZTdlZDgyNzJlODk", "commit": {"author": {"name": "Elliot Bobrow", "email": "77182873+ebobrow@users.noreply.github.com", "date": "2022-10-03T04:27:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-03T04:27:57Z"}, "message": "Merge branch 'master' into mul-add-negative", "tree": {"sha": "382426869adb9da41d7f91fc992a1181293312fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382426869adb9da41d7f91fc992a1181293312fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15431b36bb760a8793740907e8d13e7ed8272e89", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjOmTNCRBK7hj4Ov3rIwAAT/MIAKCk11cQFJpBNrdClfi4SB3T\nTTzfv5dmZ4ihfOY3b5v3vqA2R9zURaZVf4B+LdLw6EAgrXVYNh747cD+E7ZL2CSo\nlRKGDomLQB5kowc+oAmUWGgS5Qy5a6OwBvCbrxBGEr7Bc0sKs7VwbC8iKXn+oTNn\nLWcxFIgM2Jx2cKBflv0E9j2CFERvLMoChaabkRKu6eerQFIMYHDZh1nbqcG5lCiE\nQIu705cBvkzJohBN3i1guSXEt8+fkQneCpympV+UsEki2BFEOYKiZf27wY0QcAze\nt72PHYWGEjO/+XEIGsPuKDtYyiZWjnZc/OP5Gdj901qurGkMV2xZuWcwULa2x/A=\n=w1Rh\n-----END PGP SIGNATURE-----\n", "payload": "tree 382426869adb9da41d7f91fc992a1181293312fa\nparent 7747032b774de25cb9e1cf672a9244f17eb234cb\nparent 2be6c4ae5b075028a6c61ba75daaf22fb7921c85\nauthor Elliot Bobrow <77182873+ebobrow@users.noreply.github.com> 1664771277 -0700\ncommitter GitHub <noreply@github.com> 1664771277 -0700\n\nMerge branch 'master' into mul-add-negative"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15431b36bb760a8793740907e8d13e7ed8272e89", "html_url": "https://github.com/rust-lang/rust/commit/15431b36bb760a8793740907e8d13e7ed8272e89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15431b36bb760a8793740907e8d13e7ed8272e89/comments", "author": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7747032b774de25cb9e1cf672a9244f17eb234cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7747032b774de25cb9e1cf672a9244f17eb234cb", "html_url": "https://github.com/rust-lang/rust/commit/7747032b774de25cb9e1cf672a9244f17eb234cb"}, {"sha": "2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "html_url": "https://github.com/rust-lang/rust/commit/2be6c4ae5b075028a6c61ba75daaf22fb7921c85"}], "stats": {"total": 3252, "additions": 1875, "deletions": 1377}, "files": [{"sha": "0eb443167ecf3ffcb4f26d8f1f42007cffe55b43", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -45,9 +45,8 @@ fn generate_lint_files(\n     renamed_lints: &[RenamedLint],\n ) {\n     let internal_lints = Lint::internal_lints(lints);\n-    let usable_lints = Lint::usable_lints(lints);\n-    let mut sorted_usable_lints = usable_lints.clone();\n-    sorted_usable_lints.sort_by_key(|lint| lint.name.clone());\n+    let mut usable_lints = Lint::usable_lints(lints);\n+    usable_lints.sort_by_key(|lint| lint.name.clone());\n \n     replace_region_in_file(\n         update_mode,"}, {"sha": "9717aa9e981fbf41f30c4864f3ee19cd8ff6747d", "filename": "clippy_lints/src/asm_syntax.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fasm_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fasm_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fasm_syntax.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -64,6 +64,7 @@ declare_clippy_lint! {\n     ///\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n@@ -72,6 +73,7 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n@@ -103,6 +105,7 @@ declare_clippy_lint! {\n     ///\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n@@ -111,6 +114,7 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n+    /// # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     /// # unsafe { let ptr = \"\".as_ptr();\n     /// # use std::arch::asm;\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);"}, {"sha": "24a3588ecf16f735215a4045cd8ca26d30c57dc1", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use crate::utils::conf::DisallowedType;\n \n@@ -276,9 +276,9 @@ fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedTy\n }\n \n fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+    cx.tcx.is_diagnostic_item(sym::MutexGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockReadGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockWriteGuard, def_id)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)"}, {"sha": "569bf27c3e716e13e3802e7e4cd6fe8bab627135", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,10 +3,11 @@ use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{BlockCheckMode, Closure, Expr, ExprKind};\n+use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,39 +45,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BlocksInIfConditions => [BLOCKS_IN_IF_CONDITIONS]);\n \n-struct ExVisitor<'a, 'tcx> {\n-    found_block: Option<&'tcx Expr<'tcx>>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Closure(&Closure { body, .. }) = expr.kind {\n-            // do not lint if the closure is called using an iterator (see #1141)\n-            if_chain! {\n-                if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n-                let caller = self.cx.typeck_results().expr_ty(self_arg);\n-                if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n-                if implements_trait(self.cx, caller, iter_id, &[]);\n-                then {\n-                    return;\n-                }\n-            }\n-\n-            let body = self.cx.tcx.hir().body(body);\n-            let ex = &body.value;\n-            if let ExprKind::Block(block, _) = ex.kind {\n-                if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n-                    self.found_block = Some(ex);\n-                    return;\n-                }\n-            }\n-        }\n-        walk_expr(self, expr);\n-    }\n-}\n-\n const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n                                     instead, move the block or closure higher and bind it with a `let`\";\n@@ -144,11 +112,31 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None, cx };\n-                walk_expr(&mut visitor, cond);\n-                if let Some(block) = visitor.found_block {\n-                    span_lint(cx, BLOCKS_IN_IF_CONDITIONS, block.span, COMPLEX_BLOCK_MESSAGE);\n-                }\n+                let _: Option<!> = for_each_expr(cond, |e| {\n+                    if let ExprKind::Closure(closure) = e.kind {\n+                        // do not lint if the closure is called using an iterator (see #1141)\n+                        if_chain! {\n+                            if let Some(parent) = get_parent_expr(cx, e);\n+                            if let ExprKind::MethodCall(_, self_arg, _, _) = &parent.kind;\n+                            let caller = cx.typeck_results().expr_ty(self_arg);\n+                            if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                            if implements_trait(cx, caller, iter_id, &[]);\n+                            then {\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+\n+                        let body = cx.tcx.hir().body(closure.body);\n+                        let ex = &body.value;\n+                        if let ExprKind::Block(block, _) = ex.kind {\n+                            if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n+                                span_lint(cx, BLOCKS_IN_IF_CONDITIONS, ex.span, COMPLEX_BLOCK_MESSAGE);\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+                    }\n+                    ControlFlow::Continue(Descend::Yes)\n+                });\n             }\n         }\n     }"}, {"sha": "001d74c2605453e02988103b8f785aab7ce7fc64", "filename": "clippy_lints/src/bool_to_int_with_if.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_to_int_with_if.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::{Block, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use clippy_utils::{diagnostics::span_lint_and_then, is_else_clause, sugg::Sugg};\n+use clippy_utils::{diagnostics::span_lint_and_then, is_else_clause, is_integer_literal, sugg::Sugg};\n use rustc_errors::Applicability;\n \n declare_clippy_lint! {\n@@ -56,13 +56,9 @@ fn check_if_else<'tcx>(ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx\n         && let Some(then_lit) = int_literal(then)\n         && let Some(else_lit) = int_literal(else_)\n     {\n-        let inverted = if\n-            check_int_literal_equals_val(then_lit, 1)\n-            && check_int_literal_equals_val(else_lit, 0) {\n+        let inverted = if is_integer_literal(then_lit, 1) && is_integer_literal(else_lit, 0) {\n             false\n-        } else if\n-            check_int_literal_equals_val(then_lit, 0)\n-            && check_int_literal_equals_val(else_lit, 1) {\n+        } else if is_integer_literal(then_lit, 0) && is_integer_literal(else_lit, 1) {\n             true\n         } else {\n             // Expression isn't boolean, exit\n@@ -123,14 +119,3 @@ fn int_literal<'tcx>(expr: &'tcx rustc_hir::Expr<'tcx>) -> Option<&'tcx rustc_hi\n         None\n     }\n }\n-\n-fn check_int_literal_equals_val<'tcx>(expr: &'tcx rustc_hir::Expr<'tcx>, expected_value: u128) -> bool {\n-    if let ExprKind::Lit(lit) = &expr.kind\n-        && let LitKind::Int(val, _) = lit.node\n-        && val == expected_value\n-    {\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "21ed7f4844cc593948bbb21bc6a69c1c37ca126c", "filename": "clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::get_parent_expr;\n use clippy_utils::numeric_literal::NumericLiteral;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n@@ -30,8 +31,10 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n+    let cast_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+\n     if let Some(lit) = get_numeric_literal(cast_expr) {\n-        let literal_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+        let literal_str = &cast_str;\n \n         if_chain! {\n             if let LitKind::Int(n, _) = lit.node;\n@@ -49,58 +52,79 @@ pub(super) fn check<'tcx>(\n \n         match lit.node {\n             LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n-                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                lint_unnecessary_cast(cx, expr, literal_str, cast_from, cast_to);\n+                return false;\n             },\n             LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n-                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                lint_unnecessary_cast(cx, expr, literal_str, cast_from, cast_to);\n+                return false;\n+            },\n+            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {\n+                return false;\n             },\n-            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n             LitKind::Int(_, LitIntType::Signed(_) | LitIntType::Unsigned(_))\n             | LitKind::Float(_, LitFloatType::Suffixed(_))\n                 if cast_from.kind() == cast_to.kind() =>\n             {\n                 if let Some(src) = snippet_opt(cx, cast_expr.span) {\n                     if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node) {\n                         lint_unnecessary_cast(cx, expr, num_lit.integer, cast_from, cast_to);\n+                        return true;\n                     }\n                 }\n             },\n-            _ => {\n-                if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNNECESSARY_CAST,\n-                        expr.span,\n-                        &format!(\"casting to the same type is unnecessary (`{cast_from}` -> `{cast_to}`)\"),\n-                        \"try\",\n-                        literal_str,\n-                        Applicability::MachineApplicable,\n-                    );\n-                    return true;\n-                }\n-            },\n+            _ => {},\n         }\n     }\n \n+    if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n+        span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_CAST,\n+            expr.span,\n+            &format!(\"casting to the same type is unnecessary (`{cast_from}` -> `{cast_to}`)\"),\n+            \"try\",\n+            cast_str,\n+            Applicability::MachineApplicable,\n+        );\n+        return true;\n+    }\n+\n     false\n }\n \n-fn lint_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn lint_unnecessary_cast(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    raw_literal_str: &str,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+) {\n     let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n-    let replaced_literal;\n-    let matchless = if literal_str.contains(['(', ')']) {\n-        replaced_literal = literal_str.replace(['(', ')'], \"\");\n-        &replaced_literal\n-    } else {\n-        literal_str\n+    // first we remove all matches so `-(1)` become `-1`, and remove trailing dots, so `1.` become `1`\n+    let literal_str = raw_literal_str\n+        .replace(['(', ')'], \"\")\n+        .trim_end_matches('.')\n+        .to_string();\n+    // we know need to check if the parent is a method call, to add parenthesis accordingly (eg:\n+    // (-1).foo() instead of -1.foo())\n+    let sugg = if let Some(parent_expr) = get_parent_expr(cx, expr)\n+        && let ExprKind::MethodCall(..) = parent_expr.kind\n+        && literal_str.starts_with('-')\n+        {\n+            format!(\"({literal_str}_{cast_to})\")\n+\n+        } else {\n+            format!(\"{literal_str}_{cast_to}\")\n     };\n+\n     span_lint_and_sugg(\n         cx,\n         UNNECESSARY_CAST,\n         expr.span,\n         &format!(\"casting {literal_kind_name} literal to `{cast_to}` is unnecessary\"),\n         \"try\",\n-        format!(\"{}_{cast_to}\", matchless.trim_end_matches('.')),\n+        sugg,\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "78e9921f036f3369bd3f5768bb96227c01430fcd", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,9 +2,8 @@\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{in_constant, meets_msrv, msrvs, SpanlessEq};\n+use clippy_utils::{in_constant, is_integer_literal, meets_msrv, msrvs, SpanlessEq};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -223,16 +222,7 @@ fn check_lower_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n \n /// Check for `expr >= 0`\n fn check_lower_bound_zero<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n-    if_chain! {\n-        if let ExprKind::Lit(ref lit) = &check.kind;\n-        if let LitKind::Int(0, _) = &lit.node;\n-\n-        then {\n-            Some(Conversion::new_any(candidate))\n-        } else {\n-            None\n-        }\n-    }\n+    is_integer_literal(check, 0).then(|| Conversion::new_any(candidate))\n }\n \n /// Check for `expr >= (to_type::MIN as from_type)`"}, {"sha": "77af3b53d63338ad735d7a46f351975af3343927", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,10 +3,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::LimitStack;\n+use core::ops::ControlFlow;\n use rustc_ast::ast::Attribute;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId};\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, ExprKind, FnDecl, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -61,11 +63,27 @@ impl CognitiveComplexity {\n             return;\n         }\n \n-        let expr = &body.value;\n+        let expr = body.value;\n+\n+        let mut cc = 1u64;\n+        let mut returns = 0u64;\n+        let _: Option<!> = for_each_expr(expr, |e| {\n+            match e.kind {\n+                ExprKind::If(_, _, _) => {\n+                    cc += 1;\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    if arms.len() > 1 {\n+                        cc += 1;\n+                    }\n+                    cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n+                },\n+                ExprKind::Ret(_) => returns += 1,\n+                _ => {},\n+            }\n+            ControlFlow::Continue(())\n+        });\n \n-        let mut helper = CcHelper { cc: 1, returns: 0 };\n-        helper.visit_expr(expr);\n-        let CcHelper { cc, returns } = helper;\n         let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::Result) {\n             returns\n@@ -74,13 +92,12 @@ impl CognitiveComplexity {\n             (returns / 2)\n         };\n \n-        let mut rust_cc = cc;\n         // prevent degenerate cases where unreachable code contains `return` statements\n-        if rust_cc >= ret_adjust {\n-            rust_cc -= ret_adjust;\n+        if cc >= ret_adjust {\n+            cc -= ret_adjust;\n         }\n \n-        if rust_cc > self.limit.limit() {\n+        if cc > self.limit.limit() {\n             let fn_span = match kind {\n                 FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n@@ -107,7 +124,7 @@ impl CognitiveComplexity {\n                 COGNITIVE_COMPLEXITY,\n                 fn_span,\n                 &format!(\n-                    \"the function has a cognitive complexity of ({rust_cc}/{})\",\n+                    \"the function has a cognitive complexity of ({cc}/{})\",\n                     self.limit.limit()\n                 ),\n                 None,\n@@ -140,27 +157,3 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n }\n-\n-struct CcHelper {\n-    cc: u64,\n-    returns: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for CcHelper {\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        walk_expr(self, e);\n-        match e.kind {\n-            ExprKind::If(_, _, _) => {\n-                self.cc += 1;\n-            },\n-            ExprKind::Match(_, arms, _) => {\n-                if arms.len() > 1 {\n-                    self.cc += 1;\n-                }\n-                self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n-            },\n-            ExprKind::Ret(_) => self.returns += 1,\n-            _ => {},\n-        }\n-    }\n-}"}, {"sha": "cf8b7acd66d22ab4d9e627e95d0a4117573d4df0", "filename": "clippy_lints/src/from_str_radix_10.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_str_radix_10.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_integer_literal;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n@@ -60,8 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for FromStrRadix10 {\n             if pathseg.ident.name.as_str() == \"from_str_radix\";\n \n             // check if the second argument is a primitive `10`\n-            if let ExprKind::Lit(lit) = &radix.kind;\n-            if let rustc_ast::ast::LitKind::Int(10, _) = lit.node;\n+            if is_integer_literal(radix, 10);\n \n             then {\n                 let expr = if let ExprKind::AddrOf(_, _, expr) = &src.kind {"}, {"sha": "d263804f32cf48538be82cad8e979d6543d490f8", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 33, "deletions": 44, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::{DefIdSet, LocalDefId};\n-use rustc_hir::{self as hir, def::Res, intravisit, QPath};\n+use rustc_hir::{self as hir, def::Res, QPath};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n     lint::in_external_macro,\n@@ -13,8 +13,11 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n+use core::ops::ControlFlow;\n+\n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n@@ -200,79 +203,65 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n     }\n }\n \n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    for_each_expr(body.value, |e| {\n         use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n \n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n+        match e.kind {\n             Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n             MethodCall(_, receiver, args, _) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in std::iter::once(receiver).chain(args.iter()) {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n-            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n-                self.mutates_static |= is_mutated_static(target);\n+            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target)\n+                if is_mutated_static(target) =>\n+            {\n+                ControlFlow::Break(())\n             },\n-            _ => {},\n+            _ => ControlFlow::Continue(()),\n         }\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, body.value);\n-    v.mutates_static\n+    })\n+    .is_some()\n }"}, {"sha": "b7595d101e0fa9f04893f52eb75c8f44f4c98e96", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -5,8 +5,11 @@ use rustc_span::def_id::LocalDefId;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::visitors::for_each_expr_with_closures;\n use clippy_utils::{iter_input_pats, path_to_local};\n \n+use core::ops::ControlFlow;\n+\n use super::NOT_UNSAFE_PTR_ARG_DEREF;\n \n pub(super) fn check_fn<'tcx>(\n@@ -39,21 +42,34 @@ fn check_raw_ptr<'tcx>(\n     body: &'tcx hir::Body<'tcx>,\n     def_id: LocalDefId,\n ) {\n-    let expr = &body.value;\n     if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .filter_map(|arg| raw_ptr_arg(cx, arg))\n             .collect::<HirIdSet>();\n \n         if !raw_ptrs.is_empty() {\n-            let typeck_results = cx.tcx.typeck_body(body.id());\n-            let mut v = DerefVisitor {\n-                cx,\n-                ptrs: raw_ptrs,\n-                typeck_results,\n-            };\n-\n-            intravisit::walk_expr(&mut v, expr);\n+            let typeck = cx.tcx.typeck_body(body.id());\n+            let _: Option<!> = for_each_expr_with_closures(cx, body.value, |e| {\n+                match e.kind {\n+                    hir::ExprKind::Call(f, args) if type_is_unsafe_function(cx, typeck.expr_ty(f)) => {\n+                        for arg in args {\n+                            check_arg(cx, &raw_ptrs, arg);\n+                        }\n+                    },\n+                    hir::ExprKind::MethodCall(_, recv, args, _) => {\n+                        let def_id = typeck.type_dependent_def_id(e.hir_id).unwrap();\n+                        if cx.tcx.fn_sig(def_id).skip_binder().unsafety == hir::Unsafety::Unsafe {\n+                            check_arg(cx, &raw_ptrs, recv);\n+                            for arg in args {\n+                                check_arg(cx, &raw_ptrs, arg);\n+                            }\n+                        }\n+                    },\n+                    hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => check_arg(cx, &raw_ptrs, ptr),\n+                    _ => (),\n+                }\n+                ControlFlow::Continue(())\n+            });\n         }\n     }\n }\n@@ -70,54 +86,13 @@ fn raw_ptr_arg(cx: &LateContext<'_>, arg: &hir::Param<'_>) -> Option<hir::HirId>\n     }\n }\n \n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: HirIdSet,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    self.check_arg(receiver);\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n+fn check_arg(cx: &LateContext<'_>, raw_ptrs: &HirIdSet, arg: &hir::Expr<'_>) {\n+    if path_to_local(arg).map_or(false, |id| raw_ptrs.contains(&id)) {\n+        span_lint(\n+            cx,\n+            NOT_UNSAFE_PTR_ARG_DEREF,\n+            arg.span,\n+            \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n+        );\n     }\n }"}, {"sha": "0d6718c168a5c9da12865ee7633dc5078ad7e33a", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::eager_or_lazy::switch_to_eager_eval;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n+use clippy_utils::{\n+    contains_return, higher, is_else_clause, is_res_lang_ctor, meets_msrv, msrvs, path_res, peel_blocks,\n+};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -76,10 +78,8 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             && let ExprKind::Block(then_block, _) = then.kind\n             && let Some(then_expr) = then_block.expr\n             && let ExprKind::Call(then_call, [then_arg]) = then_expr.kind\n-            && let ExprKind::Path(ref then_call_qpath) = then_call.kind\n-            && is_lang_ctor(cx, then_call_qpath, OptionSome)\n-            && let ExprKind::Path(ref qpath) = peel_blocks(els).kind\n-            && is_lang_ctor(cx, qpath, OptionNone)\n+            && is_res_lang_ctor(cx, path_res(cx, then_call), OptionSome)\n+            && is_res_lang_ctor(cx, path_res(cx, peel_blocks(els)), OptionNone)\n             && !stmts_contains_early_return(then_block.stmts)\n         {\n             let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");"}, {"sha": "946d04eff6f9850f6c81dce875bca890f0b9d76f", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,10 +2,11 @@ use clippy_utils::{\n     diagnostics::span_lint_hir_and_then,\n     get_async_fn_body, is_async_fn,\n     source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n-    visitors::expr_visitor_no_bodies,\n+    visitors::for_each_expr,\n };\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -152,7 +153,7 @@ fn lint_implicit_returns(\n \n         ExprKind::Loop(block, ..) => {\n             let mut add_return = false;\n-            expr_visitor_no_bodies(|e| {\n+            let _: Option<!> = for_each_expr(block, |e| {\n                 if let ExprKind::Break(dest, sub_expr) = e.kind {\n                     if dest.target_id.ok() == Some(expr.hir_id) {\n                         if call_site_span.is_none() && e.span.ctxt() == ctxt {\n@@ -167,9 +168,8 @@ fn lint_implicit_returns(\n                         }\n                     }\n                 }\n-                true\n-            })\n-            .visit_block(block);\n+                ControlFlow::Continue(())\n+            });\n             if add_return {\n                 #[expect(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {"}, {"sha": "48edbf6ae576cc66cfe717a11a9eb5de8ec5f57a", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n+use clippy_utils::{higher, is_integer_literal, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -131,17 +131,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n     match peel_blocks_with_stmt(expr).kind {\n         ExprKind::AssignOp(ref op1, target, value) => {\n-            if_chain! {\n-                if BinOpKind::Sub == op1.node;\n-                // Check if literal being subtracted is one\n-                if let ExprKind::Lit(ref lit1) = value.kind;\n-                if let LitKind::Int(1, _) = lit1.node;\n-                then {\n-                    Some(target)\n-                } else {\n-                    None\n-                }\n-            }\n+            // Check if literal being subtracted is one\n+            (BinOpKind::Sub == op1.node && is_integer_literal(value, 1)).then_some(target)\n         },\n         ExprKind::Assign(target, value, _) => {\n             if_chain! {\n@@ -150,8 +141,7 @@ fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Exp\n \n                 if SpanlessEq::new(cx).eq_expr(left1, target);\n \n-                if let ExprKind::Lit(ref lit1) = right1.kind;\n-                if let LitKind::Int(1, _) = lit1.node;\n+                if is_integer_literal(right1, 1);\n                 then {\n                     Some(target)\n                 } else {"}, {"sha": "d1d2db27c6fc0acd6efa477769d5840722056f1b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::higher;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Closure, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -168,9 +168,16 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => path_def_id(cx, path)\n-            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n-            .into(),\n+        ExprKind::Call(path, _) => {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n+                cx.qpath_res(qpath, path.hir_id)\n+                    .opt_def_id()\n+                    .map_or(false, |id| cx.tcx.is_diagnostic_item(sym::iter_repeat, id))\n+                    .into()\n+            } else {\n+                Finite\n+            }\n+        },\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }"}, {"sha": "676136df572bd0dd7cff51bc4cc1d74945a3dd2c", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, paths, return_ty, trait_ref_of_method};\n+use clippy_utils::{return_ty, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc_hir::{GenericParamKind, ImplItem, ImplItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -118,7 +118,10 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n }\n \n fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n-    let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n+    let display_trait_id = cx\n+        .tcx\n+        .get_diagnostic_item(sym::Display)\n+        .expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n     let self_type = cx.tcx.fn_sig(item.def_id).input(0);"}, {"sha": "71dfdab369b97e93228a82f1de68ea331b89639d", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -13,10 +13,10 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::INVALID_PATHS),\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n     LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n ])"}, {"sha": "307ec40f40b3b155ca7e5b17d9108a440e99d065", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -24,8 +24,6 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n-    #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n@@ -34,6 +32,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,"}, {"sha": "3b78e492baa480fd12f0bb6b15575f8d5962f842", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -535,7 +535,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n         store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n         store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }"}, {"sha": "4bb9936e9cde7a235f674ba7483f531b8f3dc1de", "filename": "clippy_lints/src/loops/manual_find.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FIND;\n use clippy_utils::{\n-    diagnostics::span_lint_and_then, higher, is_lang_ctor, path_res, peel_blocks_with_stmt,\n+    diagnostics::span_lint_and_then, higher, is_res_lang_ctor, path_res, peel_blocks_with_stmt,\n     source::snippet_with_applicability, ty::implements_trait,\n };\n use if_chain::if_chain;\n@@ -30,8 +30,8 @@ pub(super) fn check<'tcx>(\n         if let [stmt] = block.stmts;\n         if let StmtKind::Semi(semi) = stmt.kind;\n         if let ExprKind::Ret(Some(ret_value)) = semi.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ctor), .. }, [inner_ret]) = ret_value.kind;\n-        if is_lang_ctor(cx, ctor, LangItem::OptionSome);\n+        if let ExprKind::Call(ctor, [inner_ret]) = ret_value.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, ctor), LangItem::OptionSome);\n         if path_res(cx, inner_ret) == Res::Local(binding_id);\n         if let Some((last_stmt, last_ret)) = last_stmt_and_ret(cx, expr);\n         then {\n@@ -143,8 +143,7 @@ fn last_stmt_and_ret<'tcx>(\n         if let Some((_, Node::Block(block))) = parent_iter.next();\n         if let Some((last_stmt, last_ret)) = extract(block);\n         if last_stmt.hir_id == node_hir;\n-        if let ExprKind::Path(path) = &last_ret.kind;\n-        if is_lang_ctor(cx, path, LangItem::OptionNone);\n+        if is_res_lang_ctor(cx, path_res(cx, last_ret), LangItem::OptionNone);\n         if let Some((_, Node::Expr(_block))) = parent_iter.next();\n         // This includes the function header\n         if let Some((_, func)) = parent_iter.next();"}, {"sha": "8c27c09404b1b28e77fb13a62b97bea0a5a6fd7b", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,13 +3,13 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n+use clippy_utils::{path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_span::source_map::Span;\n \n /// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n@@ -30,8 +30,10 @@ pub(super) fn check<'tcx>(\n         if path_to_local_id(let_expr, pat_hir_id);\n         // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n         if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, let_pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let some_ctor = cx.tcx.lang_items().option_some_variant() == Some(variant_id);\n+        let ok_ctor = cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if some_ctor || ok_ctor;\n         // Ensure expr in `if let` is not used afterwards\n         if !is_local_used(cx, if_then, pat_hir_id);"}, {"sha": "153f97e4e66c88ffe334d220c0d8425cf6589796", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,13 +3,12 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n-    get_enclosing_loop_or_multi_call_closure, is_refutable, is_trait_method, match_def_path, paths,\n-    visitors::is_res_used,\n+    get_enclosing_loop_or_multi_call_closure, is_refutable, is_res_lang_ctor, is_trait_method, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, LangItem, Local, Mutability, PatKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::ty::adjustment::Adjust;\n@@ -19,9 +18,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr_struct, iter_expr, some_pat, loop_expr) = if_chain! {\n         if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n-        if let Res::Def(_, pat_did) = pat_path.res;\n-        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        if let PatKind::TupleStruct(ref pat_path, some_pat, _) = let_pat.kind;\n+        if is_res_lang_ctor(cx, cx.qpath_res(pat_path, let_pat.hir_id), LangItem::OptionSome);\n         // check for call to `Iterator::next`\n         if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;"}, {"sha": "825ec84b4a81241be619e8d8b5c4e64689b09ed5", "filename": "clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_assert.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,8 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use crate::rustc_lint::LintContext;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{peel_blocks_with_stmt, sugg};\n+use clippy_utils::{peel_blocks_with_stmt, span_extract_comment, sugg};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -50,20 +51,36 @@ impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n                 let cond = cond.peel_drop_temps();\n+                let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n+                if !comments.is_empty() {\n+                    comments += \"\\n\";\n+                }\n                 let (cond, not) = match cond.kind {\n                     ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n                     _ => (cond, \"!\"),\n                 };\n                 let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n                 let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n-                span_lint_and_sugg(\n+                // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n+                span_lint_and_then(\n                     cx,\n                     MANUAL_ASSERT,\n                     expr.span,\n                     \"only a `panic!` in `if`-then statement\",\n-                    \"try\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n+                    |diag| {\n+                        // comments can be noisy, do not show them to the user\n+                        diag.tool_only_span_suggestion(\n+                                    expr.span.shrink_to_lo(),\n+                                    \"add comments back\",\n+                                    comments,\n+                                    applicability);\n+                        diag.span_suggestion(\n+                                    expr.span,\n+                                    \"try instead\",\n+                                    sugg,\n+                                    applicability);\n+                                     }\n+\n                 );\n             }\n         }"}, {"sha": "ece4df95505ceb2de65d5bb5ba0e03f7cdc4d7cc", "filename": "clippy_lints/src/manual_clamp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_clamp.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -324,7 +324,7 @@ fn is_call_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>)\n         outer_arg: &'tcx Expr<'tcx>,\n         span: Span,\n     ) -> Option<ClampSuggestion<'tcx>> {\n-        if let ExprKind::Call(inner_fn, &[ref first, ref second]) = &inner_call.kind\n+        if let ExprKind::Call(inner_fn, [first, second]) = &inner_call.kind\n             && let Some(inner_seg) = segment(cx, inner_fn)\n             && let Some(outer_seg) = segment(cx, outer_fn)\n         {\n@@ -377,9 +377,7 @@ fn is_call_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>)\n /// # ;\n /// ```\n fn is_match_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n-    if let ExprKind::Match(value, &[ref first_arm, ref second_arm, ref last_arm], rustc_hir::MatchSource::Normal) =\n-        &expr.kind\n-    {\n+    if let ExprKind::Match(value, [first_arm, second_arm, last_arm], rustc_hir::MatchSource::Normal) = &expr.kind {\n         // Find possible min/max branches\n         let minmax_values = |a: &'tcx Arm<'tcx>| {\n             if let PatKind::Binding(_, var_hir_id, _, None) = &a.pat.kind"}, {"sha": "3181bc86d179362e0ed6d075837ef569c7094478", "filename": "clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -92,7 +92,7 @@ fn check_into_iter(\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n         && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n-        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && cx.tcx.lang_items().require(hir::LangItem::IntoIterIntoIter).ok() == Some(into_iter_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n         && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n         suggest(cx, parent_expr, left_expr, target_expr);"}, {"sha": "32da37a862d8ca02f30001805b013a8fc2f89a0d", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -131,12 +131,12 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n         },\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr.as_ref()) {\n-                (&[], Some(inner_expr)) => {\n+                ([], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `{ X }` to `X`\n                     reduce_unit_expression(cx, inner_expr)\n                 },\n-                (&[ref inner_stmt], None) => {\n+                ([inner_stmt], None) => {\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.kind {"}, {"sha": "fd14d868df348e7e856c08e8b59bf2f4c9ee58d8", "filename": "clippy_lints/src/matches/collapsible_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{\n+    is_res_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n@@ -110,7 +112,7 @@ fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     }\n     match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         _ => false,\n     }\n }"}, {"sha": "76f5e1c941c7a270e37f0647455c8db60550588c", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,8 +3,8 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id, peel_blocks,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -251,9 +251,11 @@ fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: Syn\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n             PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n@@ -272,16 +274,14 @@ fn get_some_expr<'tcx>(\n ) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(ref qpath),\n-                ..\n-            },\n-            [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n-            expr: arg,\n-            needs_unsafe_block,\n-        }),\n+        ExprKind::Call(callee, [arg])\n+            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+        {\n+            Some(SomeExpr {\n+                expr: arg,\n+                needs_unsafe_block,\n+            })\n+        },\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n@@ -302,5 +302,5 @@ fn get_some_expr<'tcx>(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n }"}, {"sha": "587c926dc01c3f02d790653c72dcbc3d8eded3e8", "filename": "clippy_lints/src/matches/manual_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,12 +3,14 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, sugg};\n+use clippy_utils::{is_res_lang_ctor, path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::LangItem::{OptionNone, ResultErr};\n use rustc_hir::{Arm, Expr, PatKind};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::sym;\n \n use super::MANUAL_UNWRAP_OR;\n@@ -59,15 +61,19 @@ fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'\n         if arms.iter().all(|arm| arm.guard.is_none());\n         if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n             match arm.pat.kind {\n-                PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n                 PatKind::TupleStruct(ref qpath, [pat], _) =>\n-                    matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n+                    matches!(pat.kind, PatKind::Wild)\n+                        && is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr),\n                 _ => false,\n             }\n         });\n         let unwrap_arm = &arms[1 - idx];\n         if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, unwrap_arm.pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        if cx.tcx.lang_items().option_some_variant() == Some(variant_id)\n+            || cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n         if path_to_local_id(unwrap_arm.body, binding_hir_id);\n         if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();"}, {"sha": "2818f030b7a6388fc85b4ca52fe99da681b75aca", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_lang_ctor, peel_blocks};\n+use clippy_utils::{is_res_lang_ctor, path_res, peel_blocks};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, LangItem, Mutability, PatKind, QPath};\n use rustc_lint::LateContext;\n@@ -59,18 +59,20 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+    matches!(\n+        arm.pat.kind,\n+        PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionNone)\n+    )\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<Mutability> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionSome);\n         if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., ident, _) = first_pat.kind;\n         if let ExprKind::Call(e, [arg]) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, path_res(cx, e), LangItem::OptionSome);\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = arg.kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "c4f6852aedc3d541785111161099fba809ff86b4", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{\n-    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor, over,\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_res_lang_ctor, over, path_res,\n     peel_blocks_with_stmt,\n };\n use rustc_errors::Applicability;\n@@ -112,10 +112,7 @@ fn check_if_let_inner(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool\n             let ret = strip_return(else_expr);\n             let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n             if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n-                if let ExprKind::Path(ref qpath) = ret.kind {\n-                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n-                }\n-                return false;\n+                return is_res_lang_ctor(cx, path_res(cx, ret), OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n             }\n             return eq_expr_value(cx, if_let.let_expr, ret);\n         }"}, {"sha": "81bebff34c82c78644adfbf5ba37d34f46f7ba54", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -4,10 +4,11 @@ use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n-use clippy_utils::{higher, is_lang_ctor, is_trait_method};\n+use clippy_utils::{higher, is_trait_method};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::LangItem::{self, OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n@@ -87,15 +88,21 @@ fn find_sugg_for_if_let<'tcx>(\n             }\n         },\n         PatKind::Path(ref path) => {\n-            let method = if is_lang_ctor(cx, path, OptionNone) {\n-                \"is_none()\"\n-            } else if is_lang_ctor(cx, path, PollPending) {\n-                \"is_pending()\"\n+            if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(path, check_pat.hir_id)\n+                && let Some(variant_id) = cx.tcx.opt_parent(ctor_id)\n+            {\n+                let method = if cx.tcx.lang_items().option_none_variant() == Some(variant_id) {\n+                    \"is_none()\"\n+                } else if cx.tcx.lang_items().poll_pending_variant() == Some(variant_id) {\n+                    \"is_pending()\"\n+                } else {\n+                    return;\n+                };\n+                // `None` and `Pending` don't have an inner type.\n+                (method, cx.tcx.types.unit)\n             } else {\n                 return;\n-            };\n-            // `None` and `Pending` don't have an inner type.\n-            (method, cx.tcx.types.unit)\n+            }\n         },\n         _ => return,\n     };"}, {"sha": "c6cba81d8718972e89d436f83a3b4ef2facd37e2", "filename": "clippy_lints/src/matches/try_err.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n+use clippy_utils::{get_parent_expr, is_res_lang_ctor, match_def_path, path_res, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::ResultErr;\n@@ -27,8 +27,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutine\n         if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n         if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n         if let ExprKind::Call(err_fun, [err_arg, ..]) = try_arg.kind;\n-        if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-        if is_lang_ctor(cx, err_fun_path, ResultErr);\n+        if is_res_lang_ctor(cx, path_res(cx, err_fun), ResultErr);\n         if let Some(return_ty) = find_return_type(cx, &expr.kind);\n         then {\n             let prefix;"}, {"sha": "0c4d9f100f7a966f7c3bade76f7e3843b3518f70", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{is_default_equivalent, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{is_default_equivalent, is_res_lang_ctor, meets_msrv, msrvs, path_res};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n@@ -102,40 +102,38 @@ impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if let ExprKind::Path(ref replacement_qpath) = src.kind {\n-        // Check that second argument is `Option::None`\n-        if is_lang_ctor(cx, replacement_qpath, OptionNone) {\n-            // Since this is a late pass (already type-checked),\n-            // and we already know that the second argument is an\n-            // `Option`, we do not need to check the first\n-            // argument's type. All that's left is to get\n-            // replacee's path.\n-            let replaced_path = match dest.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n-                    if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n-                        replaced_path\n-                    } else {\n-                        return;\n-                    }\n-                },\n-                ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n-                _ => return,\n-            };\n+    // Check that second argument is `Option::None`\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        // Since this is a late pass (already type-checked),\n+        // and we already know that the second argument is an\n+        // `Option`, we do not need to check the first\n+        // argument's type. All that's left is to get\n+        // replacee's path.\n+        let replaced_path = match dest.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n+                if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n+                    replaced_path\n+                } else {\n+                    return;\n+                }\n+            },\n+            ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n+            _ => return,\n+        };\n \n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MEM_REPLACE_OPTION_WITH_NONE,\n-                expr_span,\n-                \"replacing an `Option` with `None`\",\n-                \"consider `Option::take()` instead\",\n-                format!(\n-                    \"{}.take()\",\n-                    snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            MEM_REPLACE_OPTION_WITH_NONE,\n+            expr_span,\n+            \"replacing an `Option` with `None`\",\n+            \"consider `Option::take()` instead\",\n+            format!(\n+                \"{}.take()\",\n+                snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n     }\n }\n \n@@ -203,10 +201,8 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n         return;\n     }\n     // disable lint for Option since it is covered in another lint\n-    if let ExprKind::Path(q) = &src.kind {\n-        if is_lang_ctor(cx, q, OptionNone) {\n-            return;\n-        }\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        return;\n     }\n     if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n         span_lint_and_then("}, {"sha": "3fef53739fbde876c7114f2967c7ffc7231b730b", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,17 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{get_parent_expr, paths};\n+use clippy_utils::get_parent_expr;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n use super::FILETYPE_IS_FILE;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(recv);\n \n-    if !match_type(cx, ty, &paths::FILE_TYPE) {\n+    if !is_type_diagnostic_item(cx, ty, sym::FileType) {\n         return;\n     }\n "}, {"sha": "3bdc154df04958a67dd050f306ac1f22d01897bd", "filename": "clippy_lints/src/methods/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::SpanlessEq;\n-use rustc_ast::LitKind;\n+use clippy_utils::{is_integer_literal, SpanlessEq};\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -26,8 +25,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n         && lhs_path.ident.name == sym::len\n \n         // RHS of subtraction is 1\n-        && let ExprKind::Lit(rhs_lit) = &rhs.kind\n-        && let LitKind::Int(1, ..) = rhs_lit.node\n+        && is_integer_literal(rhs, 1)\n \n         // check that recv == lhs_recv `recv.get(lhs_recv.len() - 1)`\n         && SpanlessEq::new(cx).eq_expr(recv, lhs_recv)"}, {"sha": "ede3b8bb74e97c7353dcef5154a167057bceb612", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -65,7 +65,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     }\n \n     if let ty::Adt(adt, substs) = ty.kind() {\n-        match_def_path(cx, adt.did(), &paths::COW) && substs.type_at(1).is_str()\n+        cx.tcx.is_diagnostic_item(sym::Cow, adt.did()) && substs.type_at(1).is_str()\n     } else {\n         false\n     }"}, {"sha": "4f73b3ec42247e56bacf4f6d9df9a1506095c6e7", "filename": "clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{get_expr_use_or_unification_node, is_lang_ctor, is_no_std_crate};\n+use clippy_utils::{get_expr_use_or_unification_node, is_no_std_crate, is_res_lang_ctor, path_res};\n \n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -26,26 +26,11 @@ impl IterType {\n }\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n-    let item = match &recv.kind {\n-        ExprKind::Array(v) if v.len() <= 1 => v.first(),\n-        ExprKind::Path(p) => {\n-            if is_lang_ctor(cx, p, OptionNone) {\n-                None\n-            } else {\n-                return;\n-            }\n-        },\n-        ExprKind::Call(f, some_args) if some_args.len() == 1 => {\n-            if let ExprKind::Path(p) = &f.kind {\n-                if is_lang_ctor(cx, p, OptionSome) {\n-                    Some(&some_args[0])\n-                } else {\n-                    return;\n-                }\n-            } else {\n-                return;\n-            }\n-        },\n+    let item = match recv.kind {\n+        ExprKind::Array([]) => None,\n+        ExprKind::Array([e]) => Some(e),\n+        ExprKind::Path(ref p) if is_res_lang_ctor(cx, cx.qpath_res(p, recv.hir_id), OptionNone) => None,\n+        ExprKind::Call(f, [arg]) if is_res_lang_ctor(cx, path_res(cx, f), OptionSome) => Some(arg),\n         _ => return,\n     };\n     let iter_type = match method_name {"}, {"sha": "5b758f1e6547c676ea7dca16710969e9df4834ec", "filename": "clippy_lints/src/methods/manual_ok_or.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n-use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n+use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -22,8 +22,8 @@ pub(super) fn check<'tcx>(\n         if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n         if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Option);\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, [err_arg]) = or_expr.kind;\n-        if is_lang_ctor(cx, err_path, ResultErr);\n+        if let ExprKind::Call(err_path, [err_arg]) = or_expr.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, err_path), ResultErr);\n         if is_ok_wrapping(cx, map_expr);\n         if let Some(recv_snippet) = snippet_opt(cx, recv.span);\n         if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n@@ -46,17 +46,19 @@ pub(super) fn check<'tcx>(\n }\n \n fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if is_lang_ctor(cx, qpath, ResultOk) {\n-            return true;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n-        let body = cx.tcx.hir().body(body);\n-        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n-        if is_lang_ctor(cx, ok_path, ResultOk);\n-        then { path_to_local_id(ok_arg, param_id) } else { false }\n+    match map_expr.kind {\n+        ExprKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, map_expr.hir_id), ResultOk) => true,\n+        ExprKind::Closure(closure) => {\n+            let body = cx.tcx.hir().body(closure.body);\n+            if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind\n+                && let ExprKind::Call(callee, [ok_arg]) = body.value.kind\n+                && is_res_lang_ctor(cx, path_res(cx, callee), ResultOk)\n+            {\n+                path_to_local_id(ok_arg, param_id)\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n     }\n }"}, {"sha": "8b6b8f1bf16cbbfcf6952c4dac6fd684448d85e3", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_path_diagnostic_item;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n-use clippy_utils::{is_expr_path_def_path, paths};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n@@ -38,7 +38,7 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n             || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (is_type_diagnostic_item(cx, ty, sym::Cow) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {\n@@ -57,7 +57,7 @@ pub(super) fn check(\n ) {\n     if_chain! {\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n-        if is_expr_path_def_path(cx, repeat_fn, &paths::ITER_REPEAT);\n+        if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::String);\n         if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);"}, {"sha": "3a23ecc50dc1d4dc76b90fd721220eed395b40dc", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_def_id};\n+use clippy_utils::{is_res_lang_ctor, path_def_id, path_res};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -51,22 +51,12 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionNone)\n-    } else {\n-        return;\n-    };\n-\n-    if !default_arg_is_none {\n+    if !is_res_lang_ctor(cx, path_res(cx, def_arg), OptionNone) {\n         // nothing to lint!\n         return;\n     }\n \n-    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionSome)\n-    } else {\n-        false\n-    };\n+    let f_arg_is_some = is_res_lang_ctor(cx, path_res(cx, map_arg), OptionSome);\n \n     if is_option {\n         let self_snippet = snippet(cx, recv.span, \"..\");"}, {"sha": "55ba6e262df7e1d44b2f3555eddec6f4b26f9d26", "filename": "clippy_lints/src/methods/or_then_unwrap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{diagnostics::span_lint_and_sugg, is_lang_ctor};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res};\n use rustc_errors::Applicability;\n use rustc_hir::{lang_items::LangItem, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -58,8 +58,7 @@ pub(super) fn check<'tcx>(\n \n fn get_content_if_ctor_matches(cx: &LateContext<'_>, expr: &Expr<'_>, item: LangItem) -> Option<Span> {\n     if let ExprKind::Call(some_expr, [arg]) = expr.kind\n-        && let ExprKind::Path(qpath) = &some_expr.kind\n-        && is_lang_ctor(cx, qpath, item)\n+        && is_res_lang_ctor(cx, path_res(cx, some_expr), item)\n     {\n         Some(arg.span)\n     } else {"}, {"sha": "ae3594bd36c3ab1ecfb3a1e6022666aa900b7001", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,11 +2,11 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::usage::local_used_after_expr;\n-use clippy_utils::visitors::expr_visitor;\n+use clippy_utils::visitors::{for_each_expr_with_closures, Descend};\n use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, path_to_local_id, paths};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n     BindingAnnotation, Expr, ExprKind, HirId, LangItem, Local, MatchSource, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n@@ -211,7 +211,7 @@ fn indirect_usage<'tcx>(\n     binding: HirId,\n     ctxt: SyntaxContext,\n ) -> Option<IndirectUsage<'tcx>> {\n-    if let StmtKind::Local(Local {\n+    if let StmtKind::Local(&Local {\n         pat: Pat {\n             kind: PatKind::Binding(BindingAnnotation::NONE, _, ident, None),\n             ..\n@@ -222,14 +222,12 @@ fn indirect_usage<'tcx>(\n     }) = stmt.kind\n     {\n         let mut path_to_binding = None;\n-        expr_visitor(cx, |expr| {\n-            if path_to_local_id(expr, binding) {\n-                path_to_binding = Some(expr);\n+        let _: Option<!> = for_each_expr_with_closures(cx, init_expr, |e| {\n+            if path_to_local_id(e, binding) {\n+                path_to_binding = Some(e);\n             }\n-\n-            path_to_binding.is_none()\n-        })\n-        .visit_expr(init_expr);\n+            ControlFlow::Continue(Descend::from(path_to_binding.is_none()))\n+        });\n \n         let mut parents = cx.tcx.hir().parent_iter(path_to_binding?.hir_id);\n         let iter_usage = parse_iter_usage(cx, ctxt, &mut parents)?;\n@@ -250,7 +248,7 @@ fn indirect_usage<'tcx>(\n             ..\n         } = iter_usage\n         {\n-            if parent_id == *local_hir_id {\n+            if parent_id == local_hir_id {\n                 return Some(IndirectUsage {\n                     name: ident.name,\n                     span: stmt.span,"}, {"sha": "1cef6226ad4ff40925445616a8bd93c986cef96e", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,9 +2,10 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use clippy_utils::{is_res_lang_ctor, is_trait_method, path_res, path_to_local_id};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -13,7 +14,7 @@ use rustc_span::sym;\n use super::UNNECESSARY_FILTER_MAP;\n use super::UNNECESSARY_FIND_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, name: &str) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>, arg: &'tcx hir::Expr<'tcx>, name: &str) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n@@ -26,10 +27,16 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, body.value);\n \n-        let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n-        return_visitor.visit_expr(body.value);\n-        found_mapping |= return_visitor.found_mapping;\n-        found_filtering |= return_visitor.found_filtering;\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            if let hir::ExprKind::Ret(Some(e)) = &e.kind {\n+                let (found_mapping_res, found_filtering_res) = check_expression(cx, arg_id, e);\n+                found_mapping |= found_mapping_res;\n+                found_filtering |= found_filtering_res;\n+                ControlFlow::Continue(Descend::No)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n+        });\n \n         let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n@@ -61,15 +68,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n // returns (found_mapping, found_filtering)\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n-    match &expr.kind {\n+    match expr.kind {\n         hir::ExprKind::Call(func, args) => {\n-            if let hir::ExprKind::Path(ref path) = func.kind {\n-                if is_lang_ctor(cx, path, OptionSome) {\n-                    if path_to_local_id(&args[0], arg_id) {\n-                        return (false, false);\n-                    }\n-                    return (true, false);\n+            if is_res_lang_ctor(cx, path_res(cx, func), OptionSome) {\n+                if path_to_local_id(&args[0], arg_id) {\n+                    return (false, false);\n                 }\n+                return (true, false);\n             }\n             (true, true)\n         },\n@@ -80,7 +85,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n-            for arm in *arms {\n+            for arm in arms {\n                 let (m, f) = check_expression(cx, arg_id, arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n@@ -93,39 +98,9 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)\n         },\n-        hir::ExprKind::Path(path) if is_lang_ctor(cx, path, OptionNone) => (false, true),\n+        hir::ExprKind::Path(ref path) if is_res_lang_ctor(cx, cx.qpath_res(path, expr.hir_id), OptionNone) => {\n+            (false, true)\n+        },\n         _ => (true, true),\n     }\n }\n-\n-struct ReturnVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    arg_id: hir::HirId,\n-    // Found a non-None return that isn't Some(input)\n-    found_mapping: bool,\n-    // Found a return that isn't Some\n-    found_filtering: bool,\n-}\n-\n-impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n-        ReturnVisitor {\n-            cx,\n-            arg_id,\n-            found_mapping: false,\n-            found_filtering: false,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if let hir::ExprKind::Ret(Some(expr)) = &expr.kind {\n-            let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n-            self.found_mapping |= found_mapping;\n-            self.found_filtering |= found_filtering;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-}"}, {"sha": "c1139d84e2f47eb1138e475a859b320db610dff2", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,19 +1,20 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::walk_ptrs_ty_depth;\n-use clippy_utils::{get_parent_expr, match_trait_method, paths};\n+use clippy_utils::{get_parent_expr, is_trait_method};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::USELESS_ASREF;\n \n /// Checks for the `USELESS_ASREF` lint.\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, recvr: &hir::Expr<'_>) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n-    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+    if is_trait_method(cx, expr, sym::AsRef) || is_trait_method(cx, expr, sym::AsMut) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let rcv_ty = cx.typeck_results().expr_ty(recvr);\n         let res_ty = cx.typeck_results().expr_ty(expr);"}, {"sha": "4f967755bfa1975d5781547dd1eaa89569dd1bec", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_trait_method, paths};\n+use clippy_utils::is_trait_method;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -83,7 +83,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n             }\n         },\n         ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n-            if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD) {\n+            if cx.typeck_results().expr_ty(receiver).is_floating_point() || is_trait_method(cx, expr, sym::Ord) {\n                 if path.ident.name == sym!(max) {\n                     fetch_const(cx, Some(receiver), args, MinMax::Max)\n                 } else if path.ident.name == sym!(min) {"}, {"sha": "516dee20f8b15f17266ca589927a2631361f7072", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_opt};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n@@ -15,7 +14,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n \n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_expr, in_constant, iter_input_pats, last_path_segment, SpanlessEq};\n+use clippy_utils::{get_parent_expr, in_constant, is_integer_literal, iter_input_pats, last_path_segment, SpanlessEq};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -314,8 +313,7 @@ fn non_macro_local(cx: &LateContext<'_>, res: def::Res) -> bool {\n fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n-        if let ExprKind::Lit(ref lit) = e.kind;\n-        if let LitKind::Int(0, _) = lit.node;\n+        if is_integer_literal(e, 0);\n         if !in_constant(cx, e.hir_id);\n         then {\n             let (msg, sugg_fn) = match mut_ty.mutbl {"}, {"sha": "10c3ff026b6d66100b3bee5a9b27d7c25799c184", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,43 +1,31 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_with_applicability;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BindingAnnotation, Mutability, Node, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for bindings that destructure a reference and borrow the inner\n+    /// Checks for bindings that needlessly destructure a reference and borrow the inner\n     /// value with `&ref`.\n     ///\n     /// ### Why is this bad?\n     /// This pattern has no effect in almost all cases.\n     ///\n-    /// ### Known problems\n-    /// In some cases, `&ref` is needed to avoid a lifetime mismatch error.\n-    /// Example:\n-    /// ```rust\n-    /// fn foo(a: &Option<String>, b: &Option<String>) {\n-    ///     match (a, b) {\n-    ///         (None, &ref c) | (&ref c, None) => (),\n-    ///         (&Some(ref c), _) => (),\n-    ///     };\n-    /// }\n-    /// ```\n-    ///\n     /// ### Example\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n-    /// # #[allow(unused)]\n     /// v.iter_mut().filter(|&ref a| a.is_empty());\n+    ///\n+    /// if let &[ref first, ref second] = v.as_slice() {}\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n-    /// # #[allow(unused)]\n     /// v.iter_mut().filter(|a| a.is_empty());\n+    ///\n+    /// if let [first, second] = v.as_slice() {}\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_BORROWED_REFERENCE,\n@@ -54,34 +42,83 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n             return;\n         }\n \n-        if_chain! {\n-            // Only lint immutable refs, because `&mut ref T` may be useful.\n-            if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n+        // Do not lint patterns that are part of an OR `|` pattern, the binding mode must match in all arms\n+        for (_, node) in cx.tcx.hir().parent_iter(pat.hir_id) {\n+            let Node::Pat(pat) = node else { break };\n+\n+            if matches!(pat.kind, PatKind::Or(_)) {\n+                return;\n+            }\n+        }\n+\n+        // Only lint immutable refs, because `&mut ref T` may be useful.\n+        let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind else { return };\n \n+        match sub_pat.kind {\n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            if let PatKind::Binding(BindingAnnotation::REF, .., spanned_name, _) = sub_pat.kind;\n-            let parent_id = cx.tcx.hir().get_parent_node(pat.hir_id);\n-            if let Some(parent_node) = cx.tcx.hir().find(parent_id);\n-            then {\n-                // do not recurse within patterns, as they may have other references\n-                // XXXManishearth we can relax this constraint if we only check patterns\n-                // with a single ref pattern inside them\n-                if let Node::Pat(_) = parent_node {\n-                    return;\n+            PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_BORROWED_REFERENCE,\n+                    pat.span,\n+                    \"this pattern takes a reference on something that is being dereferenced\",\n+                    |diag| {\n+                        // `&ref ident`\n+                        //  ^^^^^\n+                        let span = pat.span.until(ident.span);\n+                        diag.span_suggestion_verbose(\n+                            span,\n+                            \"try removing the `&ref` part\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n+            },\n+            // Slices where each element is `ref`: `&[ref a, ref b, ..., ref z]`\n+            PatKind::Slice(\n+                before,\n+                None\n+                | Some(Pat {\n+                    kind: PatKind::Wild, ..\n+                }),\n+                after,\n+            ) => {\n+                let mut suggestions = Vec::new();\n+\n+                for element_pat in itertools::chain(before, after) {\n+                    if let PatKind::Binding(BindingAnnotation::REF, _, ident, None) = element_pat.kind {\n+                        // `&[..., ref ident, ...]`\n+                        //         ^^^^\n+                        let span = element_pat.span.until(ident.span);\n+                        suggestions.push((span, String::new()));\n+                    } else {\n+                        return;\n+                    }\n                 }\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, pat.span,\n-                                   \"this pattern takes a reference on something that is being de-referenced\",\n-                                   |diag| {\n-                                       let hint = snippet_with_applicability(cx, spanned_name.span, \"..\", &mut applicability).into_owned();\n-                                       diag.span_suggestion(\n-                                           pat.span,\n-                                           \"try removing the `&ref` part and just keep\",\n-                                           hint,\n-                                           applicability,\n-                                       );\n-                                   });\n-            }\n+\n+                if !suggestions.is_empty() {\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_BORROWED_REFERENCE,\n+                        pat.span,\n+                        \"dereferencing a slice pattern where every element takes a reference\",\n+                        |diag| {\n+                            // `&[...]`\n+                            //  ^\n+                            let span = pat.span.until(sub_pat.span);\n+                            suggestions.push((span, String::new()));\n+\n+                            diag.multipart_suggestion(\n+                                \"try removing the `&` and `ref` parts\",\n+                                suggestions,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "9d26e5900866c85ef55e1b0bad608ca8272177a3", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,9 +2,9 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::needs_ordered_drop;\n-use clippy_utils::visitors::{expr_visitor, expr_visitor_no_bodies, is_local_used};\n+use clippy_utils::visitors::{for_each_expr, for_each_expr_with_closures, is_local_used};\n+use core::ops::ControlFlow;\n use rustc_errors::{Applicability, MultiSpan};\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n     BindingAnnotation, Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt,\n     StmtKind,\n@@ -64,31 +64,25 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessLateInit => [NEEDLESS_LATE_INIT]);\n \n fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> bool {\n-    let mut seen = false;\n-    expr_visitor(cx, |expr| {\n-        if let ExprKind::Assign(..) = expr.kind {\n-            seen = true;\n+    for_each_expr_with_closures(cx, stmt, |e| {\n+        if matches!(e.kind, ExprKind::Assign(..)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-\n-        !seen\n     })\n-    .visit_stmt(stmt);\n-\n-    seen\n+    .is_some()\n }\n \n fn contains_let(cond: &Expr<'_>) -> bool {\n-    let mut seen = false;\n-    expr_visitor_no_bodies(|expr| {\n-        if let ExprKind::Let(_) = expr.kind {\n-            seen = true;\n+    for_each_expr(cond, |e| {\n+        if matches!(e.kind, ExprKind::Let(_)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-\n-        !seen\n     })\n-    .visit_expr(cond);\n-\n-    seen\n+    .is_some()\n }\n \n fn stmt_needs_ordered_drop(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {"}, {"sha": "97c8cfbd3eb7a195cda0aa3b4a1caa7ffdfcde40", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n+use clippy_utils::path_res;\n use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{AsyncGeneratorKind, Block, Body, Expr, ExprKind, GeneratorKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -112,11 +113,12 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n \n fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Call(path, [arg]) = &expr.kind;\n-        if let ExprKind::Path(ref qpath) = &path.kind;\n-        let sugg_remove = if is_lang_ctor(cx, qpath, OptionSome) {\n+        if let ExprKind::Call(path, [arg]) = expr.kind;\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path_res(cx, path);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let sugg_remove = if cx.tcx.lang_items().option_some_variant() == Some(variant_id) {\n             \"Some()\"\n-        } else if is_lang_ctor(cx, qpath, ResultOk) {\n+        } else if cx.tcx.lang_items().result_ok_variant() == Some(variant_id) {\n             \"Ok()\"\n         } else {\n             return;"}, {"sha": "1a765b14892f6fccba6e1f6b4a2c0ca52435e6f2", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n+use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -49,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                 if_chain! {\n                     if (path.ident.name == sym!(mode)\n                         && (match_type(cx, obj_ty, &paths::OPEN_OPTIONS)\n-                            || match_type(cx, obj_ty, &paths::DIR_BUILDER)))\n+                            || is_type_diagnostic_item(cx, obj_ty, sym::DirBuilder)))\n                         || (path.ident.name == sym!(set_mode) && match_type(cx, obj_ty, &paths::PERMISSIONS));\n                     if let ExprKind::Lit(_) = param.kind;\n "}, {"sha": "1f22fbd53872423c13e98a6acf0a418e4e3804fe", "filename": "clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -44,25 +44,19 @@ impl ArithmeticSideEffects {\n     /// Assuming that `expr` is a literal integer, checks operators (+=, -=, *, /) in a\n     /// non-constant environment that won't overflow.\n     fn has_valid_op(op: &Spanned<hir::BinOpKind>, expr: &hir::Expr<'_>) -> bool {\n-        if let hir::BinOpKind::Add | hir::BinOpKind::Sub = op.node\n-            && let hir::ExprKind::Lit(ref lit) = expr.kind\n-            && let ast::LitKind::Int(0, _) = lit.node\n+        if let hir::ExprKind::Lit(ref lit) = expr.kind &&\n+            let ast::LitKind::Int(value, _) = lit.node\n         {\n-            return true;\n-        }\n-        if let hir::BinOpKind::Div | hir::BinOpKind::Rem = op.node\n-            && let hir::ExprKind::Lit(ref lit) = expr.kind\n-            && !matches!(lit.node, ast::LitKind::Int(0, _))\n-        {\n-            return true;\n-        }\n-        if let hir::BinOpKind::Mul = op.node\n-            && let hir::ExprKind::Lit(ref lit) = expr.kind\n-            && let ast::LitKind::Int(0 | 1, _) = lit.node\n-        {\n-            return true;\n+            match (&op.node, value) {\n+                (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0) |\n+                (hir::BinOpKind::Mul, 0 | 1) => true,\n+                (hir::BinOpKind::Div | hir::BinOpKind::Rem, 0) => false,\n+                (hir::BinOpKind::Div | hir::BinOpKind::Rem, _) => true,\n+                _ => false,\n+            }\n+        } else {\n+            false\n         }\n-        false\n     }\n \n     /// Checks if the given `expr` has any of the inner `allowed` elements."}, {"sha": "26bca7c306a84e99d7e81f8370ed53696b62c11b", "filename": "clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,11 +2,12 @@ use clippy_utils::binop_traits;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_lint::LateContext;\n use rustc_middle::mir::FakeReadCause;\n@@ -65,15 +66,19 @@ pub(super) fn check<'tcx>(\n             }\n         };\n \n-        let mut visitor = ExprVisitor {\n-            assignee,\n-            counter: 0,\n-            cx,\n-        };\n-\n-        walk_expr(&mut visitor, e);\n+        let mut found = false;\n+        let found_multiple = for_each_expr(e, |e| {\n+            if eq_expr_value(cx, assignee, e) {\n+                if found {\n+                    return ControlFlow::Break(());\n+                }\n+                found = true;\n+            }\n+            ControlFlow::Continue(())\n+        })\n+        .is_some();\n \n-        if visitor.counter == 1 {\n+        if found && !found_multiple {\n             // a = a op b\n             if eq_expr_value(cx, assignee, l) {\n                 lint(assignee, r);\n@@ -98,22 +103,6 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}\n-\n fn imm_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet {\n     struct S(hir::HirIdSet);\n     impl Delegate<'_> for S {"}, {"sha": "0830a106f55685014b50e19476296bddf8397519", "filename": "clippy_lints/src/operators/numeric_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::constant_simple;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_integer_literal;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n@@ -50,11 +51,9 @@ impl Context {\n                 hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n                     hir::ExprKind::Lit(_lit) => (),\n                     hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n-                        if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                            if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n-                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                self.expr_id = Some(expr.hir_id);\n-                            }\n+                        if is_integer_literal(expr, 1) {\n+                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                            self.expr_id = Some(expr.hir_id);\n                         }\n                     },\n                     _ => {"}, {"sha": "4eb42da1fed02a1bdabb2dab559c36498e31b310", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_res_lang_ctor, peel_blocks,\n     peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n@@ -174,7 +174,8 @@ fn try_get_option_occurrence<'tcx>(\n \n fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n     if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk) {\n+        let res = cx.qpath_res(qpath, pat.hir_id);\n+        if is_res_lang_ctor(cx, res, OptionSome) || is_res_lang_ctor(cx, res, ResultOk) {\n             return Some(inner_pat);\n         }\n     }\n@@ -226,9 +227,10 @@ fn try_convert_match<'tcx>(\n \n fn is_none_or_err_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     match arm.pat.kind {\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         PatKind::TupleStruct(ref qpath, [first_pat], _) => {\n-            is_lang_ctor(cx, qpath, ResultErr) && matches!(first_pat.kind, PatKind::Wild)\n+            is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr)\n+                && matches!(first_pat.kind, PatKind::Wild)\n         },\n         PatKind::Wild => true,\n         _ => false,"}, {"sha": "efec12489a9bad42708568988843610ddfb172b9", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::return_ty;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::expr_visitor_no_bodies;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -58,18 +59,20 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n     let mut panics = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return true };\n+    let _: Option<!> = for_each_expr(body.value, |e| {\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else {\n+            return ControlFlow::Continue(Descend::Yes);\n+        };\n         if matches!(\n             cx.tcx.item_name(macro_call.def_id).as_str(),\n             \"unimplemented\" | \"unreachable\" | \"panic\" | \"todo\" | \"assert\" | \"assert_eq\" | \"assert_ne\"\n         ) {\n             panics.push(macro_call.span);\n-            return false;\n+            ControlFlow::Continue(Descend::No)\n+        } else {\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-        true\n-    })\n-    .visit_expr(body.value);\n+    });\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "6810a2431758910ab3a62bf5ac25286882ac5e97", "filename": "clippy_lints/src/partialeq_to_none.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::{\n-    diagnostics::span_lint_and_sugg, is_lang_ctor, peel_hir_expr_refs, peel_ref_operators, sugg,\n+    diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res, peel_hir_expr_refs, peel_ref_operators, sugg,\n     ty::is_type_diagnostic_item,\n };\n use rustc_errors::Applicability;\n@@ -54,8 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialeqToNone {\n         // If the expression is a literal `Option::None`\n         let is_none_ctor = |expr: &Expr<'_>| {\n             !expr.span.from_expansion()\n-                && matches!(&peel_hir_expr_refs(expr).0.kind,\n-            ExprKind::Path(p) if is_lang_ctor(cx, p, LangItem::OptionNone))\n+                && is_res_lang_ctor(cx, path_res(cx, peel_hir_expr_refs(expr).0), LangItem::OptionNone)\n         };\n \n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "328371fd602f0c517c9c48a6ff2a6585535e90ba", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,11 +3,12 @@ use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_lang_ctor, path_to_local, path_to_local_id,\n+    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_res_lang_ctor, path_to_local, path_to_local_id,\n     peel_blocks, peel_blocks_with_stmt,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,7 +59,7 @@ enum IfBlockType<'hir> {\n     /// Contains: let_pat_qpath (Xxx), let_pat_type, let_pat_sym (a), let_expr (b), if_then (c),\n     /// if_else (d)\n     IfLet(\n-        &'hir QPath<'hir>,\n+        Res,\n         Ty<'hir>,\n         Symbol,\n         &'hir Expr<'hir>,\n@@ -126,7 +127,14 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if ddpos.as_opt_usize().is_none();\n         if let PatKind::Binding(BindingAnnotation(by_ref, _), bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n-        let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n+        let if_block = IfBlockType::IfLet(\n+            cx.qpath_res(path1, let_pat.hir_id),\n+            caller_ty,\n+            ident.name,\n+            let_expr,\n+            if_then,\n+            if_else\n+        );\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n             || is_early_return(sym::Result, cx, &if_block);\n         if if_else.map(|e| eq_expr_value(cx, let_expr, peel_blocks(e))).filter(|e| *e).is_none();\n@@ -165,21 +173,21 @@ fn is_early_return(smbl: Symbol, cx: &LateContext<'_>, if_block: &IfBlockType<'_\n                     _ => false,\n                 }\n         },\n-        IfBlockType::IfLet(qpath, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n+        IfBlockType::IfLet(res, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n             is_type_diagnostic_item(cx, let_expr_ty, smbl)\n                 && match smbl {\n                     sym::Option => {\n                         // We only need to check `if let Some(x) = option` not `if let None = option`,\n                         // because the later one will be suggested as `if option.is_none()` thus causing conflict.\n-                        is_lang_ctor(cx, qpath, OptionSome)\n+                        is_res_lang_ctor(cx, res, OptionSome)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, None)\n                     },\n                     sym::Result => {\n-                        (is_lang_ctor(cx, qpath, ResultOk)\n+                        (is_res_lang_ctor(cx, res, ResultOk)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, Some(let_pat_sym)))\n-                            || is_lang_ctor(cx, qpath, ResultErr)\n+                            || is_res_lang_ctor(cx, res, ResultErr)\n                                 && expr_return_none_or_err(smbl, cx, if_then, let_expr, Some(let_pat_sym))\n                     },\n                     _ => false,\n@@ -198,7 +206,7 @@ fn expr_return_none_or_err(\n     match peel_blocks_with_stmt(expr).kind {\n         ExprKind::Ret(Some(ret_expr)) => expr_return_none_or_err(smbl, cx, ret_expr, cond_expr, err_sym),\n         ExprKind::Path(ref qpath) => match smbl {\n-            sym::Option => is_lang_ctor(cx, qpath, OptionNone),\n+            sym::Option => is_res_lang_ctor(cx, cx.qpath_res(qpath, expr.hir_id), OptionNone),\n             sym::Result => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         },"}, {"sha": "fa107858863a44c79f5087903acd52d2913b8b09", "filename": "clippy_lints/src/read_zero_byte_vec.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::{\n     diagnostics::{span_lint, span_lint_and_sugg},\n     higher::{get_vec_init_kind, VecInitKind},\n     source::snippet,\n-    visitors::expr_visitor_no_bodies,\n+    visitors::for_each_expr,\n };\n-use hir::{intravisit::Visitor, ExprKind, Local, PatKind, PathSegment, QPath, StmtKind};\n+use core::ops::ControlFlow;\n+use hir::{Expr, ExprKind, Local, PatKind, PathSegment, QPath, StmtKind};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,38 +59,31 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                 && let PatKind::Binding(_, _, ident, _) = pat.kind\n                 && let Some(vec_init_kind) = get_vec_init_kind(cx, init)\n             {\n-                // finds use of `_.read(&mut v)`\n-                let mut read_found = false;\n-                let mut visitor = expr_visitor_no_bodies(|expr| {\n-                    if let ExprKind::MethodCall(path, _self, [arg], _) = expr.kind\n+                let visitor = |expr: &Expr<'_>| {\n+                    if let ExprKind::MethodCall(path, _, [arg], _) = expr.kind\n                         && let PathSegment { ident: read_or_read_exact, .. } = *path\n                         && matches!(read_or_read_exact.as_str(), \"read\" | \"read_exact\")\n                         && let ExprKind::AddrOf(_, hir::Mutability::Mut, inner) = arg.kind\n                         && let ExprKind::Path(QPath::Resolved(None, inner_path)) = inner.kind\n                         && let [inner_seg] = inner_path.segments\n                         && ident.name == inner_seg.ident.name\n                     {\n-                        read_found = true;\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(())\n                     }\n-                    !read_found\n-                });\n+                };\n \n-                let next_stmt_span;\n-                if idx == block.stmts.len() - 1 {\n+                let (read_found, next_stmt_span) =\n+                if let Some(next_stmt) = block.stmts.get(idx + 1) {\n+                    // case { .. stmt; stmt; .. }\n+                    (for_each_expr(next_stmt, visitor).is_some(), next_stmt.span)\n+                } else if let Some(e) = block.expr {\n                     // case { .. stmt; expr }\n-                    if let Some(e) = block.expr {\n-                        visitor.visit_expr(e);\n-                        next_stmt_span = e.span;\n-                    } else {\n-                        return;\n-                    }\n+                    (for_each_expr(e, visitor).is_some(), e.span)\n                 } else {\n-                    // case { .. stmt; stmt; .. }\n-                    let next_stmt = &block.stmts[idx + 1];\n-                    visitor.visit_stmt(next_stmt);\n-                    next_stmt_span = next_stmt.span;\n-                }\n-                drop(visitor);\n+                    return\n+                };\n \n                 if read_found && !next_stmt_span.from_expansion() {\n                     let applicability = Applicability::MaybeIncorrect;"}, {"sha": "2b2a41d160117a5f781cf7d389df8ad550e353d4", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::diagnostics::{span_lint_and_then, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_opt, snippet_with_context};\n+use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{fn_def_id, path_to_local_id};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -270,33 +272,20 @@ fn emit_return_lint(\n }\n \n fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows || expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n+    for_each_expr(expr, |e| {\n+        if let Some(def_id) = fn_def_id(cx, e)\n+            && cx\n                 .tcx\n                 .fn_sig(def_id)\n-                .output()\n                 .skip_binder()\n+                .output()\n                 .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+        {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(Descend::from(!expr.span.from_expansion()))\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+    })\n+    .is_some()\n }"}, {"sha": "760399231513f8a4b15668e35fb606f1745f313e", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_enclosing_block, is_expr_path_def_path, path_to_local, path_to_local_id, paths, SpanlessEq};\n+use clippy_utils::{\n+    get_enclosing_block, is_integer_literal, is_path_diagnostic_item, path_to_local, path_to_local_id, SpanlessEq,\n+};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_stmt, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath, Stmt, StmtKind};\n@@ -219,8 +220,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n             && path_to_local_id(self_arg, self.vec_alloc.local_id)\n             && path.ident.name == sym!(resize)\n             // Check that is filled with 0\n-            && let ExprKind::Lit(ref lit) = fill_arg.kind\n-            && let LitKind::Int(0, _) = lit.node {\n+            && is_integer_literal(fill_arg, 0) {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n@@ -254,10 +254,8 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn is_repeat_zero(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n             if let ExprKind::Call(fn_expr, [repeat_arg]) = expr.kind;\n-            if is_expr_path_def_path(self.cx, fn_expr, &paths::ITER_REPEAT);\n-            if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n-            if let LitKind::Int(0, _) = lit.node;\n-\n+            if is_path_diagnostic_item(self.cx, fn_expr, sym::iter_repeat);\n+            if is_integer_literal(repeat_arg, 0);\n             then {\n                 true\n             } else {"}, {"sha": "b57b484bdc897ed87aa85ae99daa1147153818c5", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{binop_traits, trait_ref_of_method, BINOP_TRAITS, OP_ASSIGN_TRAITS};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -92,25 +93,17 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n }\n \n fn count_binops(expr: &hir::Expr<'_>) -> u32 {\n-    let mut visitor = BinaryExprVisitor::default();\n-    visitor.visit_expr(expr);\n-    visitor.nb_binops\n-}\n-\n-#[derive(Default)]\n-struct BinaryExprVisitor {\n-    nb_binops: u32,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n+    let mut count = 0u32;\n+    let _: Option<!> = for_each_expr(expr, |e| {\n+        if matches!(\n+            e.kind,\n             hir::ExprKind::Binary(..)\n-            | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n-            | hir::ExprKind::AssignOp(..) => self.nb_binops += 1,\n-            _ => {},\n+                | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n+                | hir::ExprKind::AssignOp(..)\n+        ) {\n+            count += 1;\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+        ControlFlow::Continue(())\n+    });\n+    count\n }"}, {"sha": "19ce5ae72c24e8f7b21dd162fc9dcd29e8d81bd0", "filename": "clippy_lints/src/transmute/transmuting_null.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,8 +1,6 @@\n use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_path_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n+use clippy_utils::{is_integer_literal, is_path_diagnostic_item};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n@@ -19,37 +17,28 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n \n     // Catching transmute over constants that resolve to `null`.\n     let mut const_eval_context = constant_context(cx, cx.typeck_results());\n-    if_chain! {\n-        if let ExprKind::Path(ref _qpath) = arg.kind;\n-        if let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg);\n-        if x == 0;\n-        then {\n-            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n-            return true;\n-        }\n+    if let ExprKind::Path(ref _qpath) = arg.kind &&\n+        let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg) &&\n+        x == 0\n+    {\n+        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+        return true;\n     }\n \n     // Catching:\n     // `std::mem::transmute(0 as *const i32)`\n-    if_chain! {\n-        if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n-        if let ExprKind::Lit(ref lit) = inner_expr.kind;\n-        if let LitKind::Int(0, _) = lit.node;\n-        then {\n-            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n-            return true;\n-        }\n+    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind && is_integer_literal(inner_expr, 0) {\n+        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+        return true;\n     }\n \n     // Catching:\n     // `std::mem::transmute(std::ptr::null::<i32>())`\n-    if_chain! {\n-        if let ExprKind::Call(func1, []) = arg.kind;\n-        if is_path_diagnostic_item(cx, func1, sym::ptr_null);\n-        then {\n-            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n-            return true;\n-        }\n+    if let ExprKind::Call(func1, []) = arg.kind &&\n+        is_path_diagnostic_item(cx, func1, sym::ptr_null)\n+    {\n+        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+        return true;\n     }\n \n     // FIXME:"}, {"sha": "1ab0162a88134165770c19ba80cc0fe3da0433f7", "filename": "clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::ty::{is_type_diagnostic_item, is_uninit_value_valid_for_ty};\n-use clippy_utils::{is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n-use rustc_ast::ast::LitKind;\n+use clippy_utils::{is_integer_literal, is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -216,7 +215,7 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n             let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n             if is_type_diagnostic_item(cx, self_type, sym::Vec)\n                 && path.ident.name.as_str() == \"set_len\"\n-                && !is_literal_zero(arg)\n+                && !is_integer_literal(arg, 0)\n             {\n                 Some((self_expr, expr.span))\n             } else {\n@@ -226,13 +225,3 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n         _ => None,\n     }\n }\n-\n-fn is_literal_zero(arg: &Expr<'_>) -> bool {\n-    if let ExprKind::Lit(lit) = &arg.kind\n-        && let LitKind::Int(0, _) = lit.node\n-    {\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "016aacbf9da37c10de4e684b428429f4db34efa9", "filename": "clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n                         );\n                 } else {\n                     if_chain! {\n-                        if match_def_path(cx, fun_def_id, &paths::FROM_FROM);\n+                        if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(fun_def_id);\n                         if let [.., last_arg] = args;\n                         if let ExprKind::Lit(spanned) = &last_arg.kind;\n                         if let LitKind::Str(symbol, _) = spanned.node;"}, {"sha": "7211e6864f3a93b92692bb9ec524f34067814122", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, is_res_lang_ctor, path_res, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -120,9 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 if !ret_expr.span.from_expansion();\n                 // Check if a function call.\n                 if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n-                // Check if OPTION_SOME or RESULT_OK, depending on return type.\n-                if let ExprKind::Path(qpath) = &func.kind;\n-                if is_lang_ctor(cx, qpath, lang_item);\n+                if is_res_lang_ctor(cx, path_res(cx, func), lang_item);\n                 // Make sure the function argument does not contain a return expression.\n                 if !contains_return(arg);\n                 then {"}, {"sha": "8bcdff66331d162c44d06971af7f9774f09698a3", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::{is_try, match_trait_method, paths};\n+use clippy_utils::{is_trait_method, is_try, match_trait_method, paths};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -116,13 +117,13 @@ fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Exp\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_READ)\n+            is_trait_method(cx, call, sym::IoRead)\n         };\n         let write_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_WRITE)\n+            is_trait_method(cx, call, sym::IoWrite)\n         };\n \n         match (read_trait, write_trait, symbol, is_await) {"}, {"sha": "a69719b127b2fb04cc970d12356e83d1258dc687", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{method_chain_args, return_ty};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{Expr, ImplItemKind};\n+use rustc_hir::ImplItemKind;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n@@ -73,59 +73,45 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n     }\n }\n \n-struct FindExpectUnwrap<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        // check for `expect`\n-        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n+        let body = cx.tcx.hir().body(body_id);\n+        let typeck = cx.tcx.typeck(impl_item.def_id.def_id);\n+        let mut result = Vec::new();\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            // check for `expect`\n+            if let Some(arglists) = method_chain_args(e, &[\"expect\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // check for `unwrap`\n-        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(e, &[\"unwrap\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n-    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n-        let body = cx.tcx.hir().body(body_id);\n-        let mut fpu = FindExpectUnwrap {\n-            lcx: cx,\n-            typeck_results: cx.tcx.typeck(impl_item.def_id.def_id),\n-            result: Vec::new(),\n-        };\n-        fpu.visit_expr(body.value);\n+            ControlFlow::Continue(())\n+        });\n \n         // if we've found one, lint\n-        if !fpu.result.is_empty() {\n+        if !result.is_empty() {\n             span_lint_and_then(\n                 cx,\n                 UNWRAP_IN_RESULT,\n                 impl_span,\n                 \"used unwrap or expect in a function that returns result or option\",\n                 move |diag| {\n                     diag.help(\"unwrap and expect should not be used in a function that returns result or option\");\n-                    diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    diag.span_note(result, \"potential non-recoverable error(s)\");\n                 },\n             );\n         }"}, {"sha": "a82643a59f97bb11bc1c17c5ba62157073a5c753", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -154,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         }\n \n                         if_chain! {\n-                            if match_def_path(cx, def_id, &paths::FROM_FROM);\n+                            if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(def_id);\n                             if same_type_and_consts(a, b);\n \n                             then {"}, {"sha": "6309a04c73d5de9d3230b78e772007716853c9f2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 208, "deletions": 69, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,11 +2,11 @@ use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path,\n-    method_calls, paths, peel_blocks_with_stmt, SpanlessEq,\n+    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n+    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -20,21 +20,24 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind, Ty,\n+    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n     TyKind, UnOp,\n };\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::ConstValue;\n-use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, FloatTy};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{\n+    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n+};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{sym, BytePos, Span};\n \n use std::borrow::{Borrow, Cow};\n+use std::str;\n \n #[cfg(feature = \"internal\")]\n pub mod metadata_collector;\n@@ -226,11 +229,11 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to `utils::match_type()` on a type diagnostic item\n-    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n     ///\n     /// ### Why is this bad?\n-    /// `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n     ///\n     /// ### Example\n     /// ```rust,ignore\n@@ -241,9 +244,9 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n     /// ```\n-    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    pub UNNECESSARY_DEF_PATH,\n     internal,\n-    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n }\n \n declare_clippy_lint! {\n@@ -537,7 +540,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     }\n }\n \n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n+fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n@@ -888,89 +891,225 @@ fn suggest_note(\n     );\n }\n \n-declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n \n-impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+#[allow(clippy::too_many_lines)]\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, MATCH_TYPE_ON_DIAGNOSTIC_ITEM, expr.hir_id) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n             return;\n         }\n \n         if_chain! {\n-            // Check if this is a call to utils::match_type()\n-            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n-            if is_expr_path_def_path(cx, fn_path, &[\"clippy_utils\", \"ty\", \"match_type\"]);\n+            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n             // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, ty_path);\n-            let segments: Vec<&str> = segments.iter().map(Symbol::as_str).collect();\n-            if let Some(ty_did) = def_path_res(cx, &segments[..]).opt_def_id();\n-            // Check if the matched type is a diagnostic item\n-            if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = def_path_res(cx, &segments[..]).opt_def_id();\n             then {\n-                // TODO: check paths constants from external crates.\n-                let cx_snippet = snippet(cx, context.span, \"_\");\n-                let ty_snippet = snippet(cx, ty.span, \"_\");\n+                // def_path_res will match field names before anything else, but for this we want to match\n+                // inherent functions first.\n+                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n+                    let method_name = *segments.last().unwrap();\n+                    cx.tcx.def_key(def_id).parent\n+                        .and_then(|parent_idx|\n+                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n+                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n+                                    .find_by_name_and_kind(\n+                                        cx.tcx,\n+                                        Ident::from_str(method_name),\n+                                        AssocKind::Fn,\n+                                        *impl_id,\n+                                    )\n+                                )\n+                        )\n+                        .map_or(def_id, |item| item.def_id)\n+                } else {\n+                    def_id\n+                };\n \n-                span_lint_and_sugg(\n+                // Check if the target item is a diagnostic item or LangItem.\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"]).def_id();\n+                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) =>\n+                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (2, Item::LangItem(item)) =>\n+                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(\n                     cx,\n-                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    UNNECESSARY_DEF_PATH,\n                     expr.span,\n-                    \"usage of `clippy_utils::ty::match_type()` on a type diagnostic item\",\n-                    \"try\",\n-                    format!(\"clippy_utils::ty::is_type_diagnostic_item({cx_snippet}, {ty_snippet}, sym::{item_name})\"),\n-                    Applicability::MaybeIncorrect,\n+                    msg,\n+                    |diag| {\n+                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n+                        if with_note {\n+                            diag.help(\n+                                \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\"\n+                            );\n+                        }\n+                    },\n                 );\n             }\n         }\n     }\n }\n \n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<Symbol>> {\n-    use rustc_hir::ItemKind;\n-\n-    match &expr.kind {\n-        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n-        ExprKind::Path(qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n             Res::Local(hir_id) => {\n                 let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n-                    if let Some(init) = local.init {\n-                        return path_to_matched_type(cx, init);\n-                    }\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n                 }\n             },\n-            Res::Def(DefKind::Const | DefKind::Static(..), def_id) => {\n-                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n-                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n-                        let body = cx.tcx.hir().body(body_id);\n-                        return path_to_matched_type(cx, body.value);\n-                    }\n-                }\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n             },\n-            _ => {},\n+            _ => None,\n         },\n-        ExprKind::Array(exprs) => {\n-            let segments: Vec<Symbol> = exprs\n-                .iter()\n-                .filter_map(|expr| {\n-                    if let ExprKind::Lit(lit) = &expr.kind {\n-                        if let LitKind::Str(sym, _) = lit.node {\n-                            return Some(sym);\n-                        }\n+        ExprKind::Array(exprs) => exprs\n+            .iter()\n+            .map(|expr| {\n+                if let ExprKind::Lit(lit) = &expr.kind {\n+                    if let LitKind::Str(sym, _) = lit.node {\n+                        return Some((*sym.as_str()).to_owned());\n                     }\n+                }\n \n-                    None\n-                })\n-                .collect();\n-\n-            if segments.len() == exprs.len() {\n-                return Some(segments);\n-            }\n-        },\n-        _ => {},\n+                None\n+            })\n+            .collect(),\n+        _ => None,\n     }\n+}\n \n-    None\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n+\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n }\n \n // This is not a complete resolver for paths. It works on all the paths currently used in the paths"}, {"sha": "3caa6380e0989eaa2ac39d5576f4241d1c5cdc74", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 97, "deletions": 18, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -3,6 +3,7 @@\n #![feature(control_flow_enum)]\n #![feature(let_chains)]\n #![feature(lint_reasons)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]\n@@ -65,6 +66,7 @@ pub use self::hir_utils::{\n     both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n };\n \n+use core::ops::ControlFlow;\n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n use std::sync::OnceLock;\n@@ -113,7 +115,7 @@ use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n use crate::ty::{can_partially_move_ty, expr_sig, is_copy, is_recursively_primitive_type, ty_is_fn_once_param};\n-use crate::visitors::expr_visitor_no_bodies;\n+use crate::visitors::for_each_expr;\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -238,19 +240,69 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     }\n }\n \n-/// Checks if a `QPath` resolves to a constructor of a `LangItem`.\n+/// Checks if a `Res` refers to a constructor of a `LangItem`\n /// For example, use this to check whether a function call or a pattern is `Some(..)`.\n-pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem) -> bool {\n+pub fn is_res_lang_ctor(cx: &LateContext<'_>, res: Res, lang_item: LangItem) -> bool {\n+    if let Res::Def(DefKind::Ctor(..), id) = res\n+        && let Ok(lang_id) = cx.tcx.lang_items().require(lang_item)\n+        && let Some(id) = cx.tcx.opt_parent(id)\n+    {\n+        id == lang_id\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn is_res_diagnostic_ctor(cx: &LateContext<'_>, res: Res, diag_item: Symbol) -> bool {\n+    if let Res::Def(DefKind::Ctor(..), id) = res\n+        && let Some(id) = cx.tcx.opt_parent(id)\n+    {\n+        cx.tcx.is_diagnostic_item(diag_item, id)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Checks if a `QPath` resolves to a constructor of a diagnostic item.\n+pub fn is_diagnostic_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, diagnostic_item: Symbol) -> bool {\n     if let QPath::Resolved(_, path) = qpath {\n         if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n-            if let Ok(item_id) = cx.tcx.lang_items().require(lang_item) {\n-                return cx.tcx.parent(ctor_id) == item_id;\n-            }\n+            return cx.tcx.is_diagnostic_item(diagnostic_item, cx.tcx.parent(ctor_id));\n         }\n     }\n     false\n }\n \n+/// Checks if the `DefId` matches the given diagnostic item or it's constructor.\n+pub fn is_diagnostic_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: Symbol) -> bool {\n+    let did = match cx.tcx.def_kind(did) {\n+        DefKind::Ctor(..) => cx.tcx.parent(did),\n+        // Constructors for types in external crates seem to have `DefKind::Variant`\n+        DefKind::Variant => match cx.tcx.opt_parent(did) {\n+            Some(did) if matches!(cx.tcx.def_kind(did), DefKind::Variant) => did,\n+            _ => did,\n+        },\n+        _ => did,\n+    };\n+\n+    cx.tcx.is_diagnostic_item(item, did)\n+}\n+\n+/// Checks if the `DefId` matches the given `LangItem` or it's constructor.\n+pub fn is_lang_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: LangItem) -> bool {\n+    let did = match cx.tcx.def_kind(did) {\n+        DefKind::Ctor(..) => cx.tcx.parent(did),\n+        // Constructors for types in external crates seem to have `DefKind::Variant`\n+        DefKind::Variant => match cx.tcx.opt_parent(did) {\n+            Some(did) if matches!(cx.tcx.def_kind(did), DefKind::Variant) => did,\n+            _ => did,\n+        },\n+        _ => did,\n+    };\n+\n+    cx.tcx.lang_items().require(item).map_or(false, |id| id == did)\n+}\n+\n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     matches!(\n         expr.kind,\n@@ -486,6 +538,13 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n                 .copied()\n                 .find(|assoc_def_id| tcx.item_name(*assoc_def_id).as_str() == name)\n                 .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id)),\n+            DefKind::Struct | DefKind::Union => tcx\n+                .adt_def(def_id)\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .find(|f| f.name.as_str() == name)\n+                .map(|f| Res::Def(DefKind::Field, f.did)),\n             _ => None,\n         }\n     }\n@@ -738,7 +797,7 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n             }\n         },\n         ExprKind::Call(repl_func, _) => is_default_equivalent_call(cx, repl_func),\n-        ExprKind::Path(qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        ExprKind::Path(qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, e.hir_id), OptionNone),\n         ExprKind::AddrOf(rustc_hir::BorrowKind::Ref, _, expr) => matches!(expr.kind, ExprKind::Array([])),\n         _ => false,\n     }\n@@ -1136,17 +1195,14 @@ pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n \n /// Returns `true` if `expr` contains a return expression\n pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    let mut found = false;\n-    expr_visitor_no_bodies(|expr| {\n-        if !found {\n-            if let hir::ExprKind::Ret(..) = &expr.kind {\n-                found = true;\n-            }\n+    for_each_expr(expr, |e| {\n+        if matches!(e.kind, hir::ExprKind::Ret(..)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-        !found\n     })\n-    .visit_expr(expr);\n-    found\n+    .is_some()\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n@@ -1553,7 +1609,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, pat, ddpos) = arm.pat.kind;\n             if ddpos.as_opt_usize().is_none();\n-            if is_lang_ctor(cx, path, ResultOk);\n+            if is_res_lang_ctor(cx, cx.qpath_res(path, arm.pat.hir_id), ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n             then {\n@@ -1565,7 +1621,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n \n     fn is_err(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            is_lang_ctor(cx, path, ResultErr)\n+            is_res_lang_ctor(cx, cx.qpath_res(path, arm.pat.hir_id), ResultErr)\n         } else {\n             false\n         }\n@@ -2295,6 +2351,29 @@ pub fn span_contains_comment(sm: &SourceMap, span: Span) -> bool {\n     });\n }\n \n+/// Return all the comments a given span contains\n+/// Comments are returned wrapped with their relevant delimiters\n+pub fn span_extract_comment(sm: &SourceMap, span: Span) -> String {\n+    let snippet = sm.span_to_snippet(span).unwrap_or_default();\n+    let mut comments_buf: Vec<String> = Vec::new();\n+    let mut index: usize = 0;\n+\n+    for token in tokenize(&snippet) {\n+        let token_range = index..(index + token.len as usize);\n+        index += token.len as usize;\n+        match token.kind {\n+            TokenKind::BlockComment { .. } | TokenKind::LineComment { .. } => {\n+                if let Some(comment) = snippet.get(token_range) {\n+                    comments_buf.push(comment.to_string());\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    comments_buf.join(\"\\n\")\n+}\n+\n macro_rules! op_utils {\n     ($($name:ident $assign:ident)*) => {\n         /// Binary operation traits like `LangItem::Add`"}, {"sha": "dda21b903901f44707c87ebcae77a2e405a5a81a", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -2,7 +2,7 @@\n \n use crate::is_path_diagnostic_item;\n use crate::source::snippet_opt;\n-use crate::visitors::expr_visitor_no_bodies;\n+use crate::visitors::{for_each_expr, Descend};\n \n use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n@@ -270,20 +270,19 @@ fn find_assert_args_inner<'a, const N: usize>(\n     };\n     let mut args = ArrayVec::new();\n     let mut panic_expn = None;\n-    expr_visitor_no_bodies(|e| {\n+    let _: Option<!> = for_each_expr(expr, |e| {\n         if args.is_full() {\n             if panic_expn.is_none() && e.span.ctxt() != expr.span.ctxt() {\n                 panic_expn = PanicExpn::parse(cx, e);\n             }\n-            panic_expn.is_none()\n+            ControlFlow::Continue(Descend::from(panic_expn.is_none()))\n         } else if is_assert_arg(cx, e, expn) {\n             args.push(e);\n-            false\n+            ControlFlow::Continue(Descend::No)\n         } else {\n-            true\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-    })\n-    .visit_expr(expr);\n+    });\n     let args = args.into_inner().ok()?;\n     // if no `panic!(..)` is found, use `PanicExpn::Empty`\n     // to indicate that the default assertion message is used\n@@ -297,22 +296,19 @@ fn find_assert_within_debug_assert<'a>(\n     expn: ExpnId,\n     assert_name: Symbol,\n ) -> Option<(&'a Expr<'a>, ExpnId)> {\n-    let mut found = None;\n-    expr_visitor_no_bodies(|e| {\n-        if found.is_some() || !e.span.from_expansion() {\n-            return false;\n+    for_each_expr(expr, |e| {\n+        if !e.span.from_expansion() {\n+            return ControlFlow::Continue(Descend::No);\n         }\n         let e_expn = e.span.ctxt().outer_expn();\n         if e_expn == expn {\n-            return true;\n-        }\n-        if e_expn.expn_data().macro_def_id.map(|id| cx.tcx.item_name(id)) == Some(assert_name) {\n-            found = Some((e, e_expn));\n+            ControlFlow::Continue(Descend::Yes)\n+        } else if e_expn.expn_data().macro_def_id.map(|id| cx.tcx.item_name(id)) == Some(assert_name) {\n+            ControlFlow::Break((e, e_expn))\n+        } else {\n+            ControlFlow::Continue(Descend::No)\n         }\n-        false\n     })\n-    .visit_expr(expr);\n-    found\n }\n \n fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) -> bool {\n@@ -396,16 +392,14 @@ impl FormatString {\n         });\n \n         let mut parts = Vec::new();\n-        expr_visitor_no_bodies(|expr| {\n-            if let ExprKind::Lit(lit) = &expr.kind {\n-                if let LitKind::Str(symbol, _) = lit.node {\n-                    parts.push(symbol);\n-                }\n+        let _: Option<!> = for_each_expr(pieces, |expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind\n+                && let LitKind::Str(symbol, _) = lit.node\n+            {\n+                parts.push(symbol);\n             }\n-\n-            true\n-        })\n-        .visit_expr(pieces);\n+            ControlFlow::Continue(())\n+        });\n \n         Some(Self {\n             span,\n@@ -431,7 +425,7 @@ impl<'tcx> FormatArgsValues<'tcx> {\n     fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n         let mut pos_to_value_index = Vec::new();\n         let mut value_args = Vec::new();\n-        expr_visitor_no_bodies(|expr| {\n+        let _: Option<!> = for_each_expr(args, |expr| {\n             if expr.span.ctxt() == args.span.ctxt() {\n                 // ArgumentV1::new_<format_trait>(<val>)\n                 // ArgumentV1::from_usize(<val>)\n@@ -453,16 +447,13 @@ impl<'tcx> FormatArgsValues<'tcx> {\n \n                     pos_to_value_index.push(val_idx);\n                 }\n-\n-                true\n+                ControlFlow::Continue(Descend::Yes)\n             } else {\n                 // assume that any expr with a differing span is a value\n                 value_args.push(expr);\n-\n-                false\n+                ControlFlow::Continue(Descend::No)\n             }\n-        })\n-        .visit_expr(args);\n+        });\n \n         Self {\n             value_args,\n@@ -866,22 +857,20 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n     }\n \n     pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n-        let mut format_args = None;\n-        expr_visitor_no_bodies(|e| {\n-            if format_args.is_some() {\n-                return false;\n-            }\n+        for_each_expr(expr, |e| {\n             let e_ctxt = e.span.ctxt();\n             if e_ctxt == expr.span.ctxt() {\n-                return true;\n-            }\n-            if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n-                format_args = FormatArgsExpn::parse(cx, e);\n+                ControlFlow::Continue(Descend::Yes)\n+            } else if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n+                if let Some(args) = FormatArgsExpn::parse(cx, e) {\n+                    ControlFlow::Break(args)\n+                } else {\n+                    ControlFlow::Continue(Descend::No)\n+                }\n+            } else {\n+                ControlFlow::Continue(Descend::No)\n             }\n-            false\n         })\n-        .visit_expr(expr);\n-        format_args\n     }\n \n     /// Source callsite span of all inputs"}, {"sha": "13938645fc3e500047b8dc5c0f384d823f0d8737", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -34,7 +34,6 @@ pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"defa\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n@@ -64,8 +63,6 @@ pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n-pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n-pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];"}, {"sha": "88837d8a143eddf15d7472ae89321195667ddb3e", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,7 +1,7 @@\n use crate::source::snippet;\n-use crate::visitors::expr_visitor_no_bodies;\n+use crate::visitors::{for_each_expr, Descend};\n use crate::{path_to_local_id, strip_pat_refs};\n-use rustc_hir::intravisit::Visitor;\n+use core::ops::ControlFlow;\n use rustc_hir::{Body, BodyId, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::Span;\n@@ -30,28 +30,23 @@ fn extract_clone_suggestions<'tcx>(\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n-    let mut abort = false;\n     let mut spans = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        if abort {\n-            return false;\n-        }\n-        if let ExprKind::MethodCall(seg, recv, [], _) = expr.kind {\n-            if path_to_local_id(recv, id) {\n-                if seg.ident.name.as_str() == \"capacity\" {\n-                    abort = true;\n-                    return false;\n-                }\n-                for &(fn_name, suffix) in replace {\n-                    if seg.ident.name.as_str() == fn_name {\n-                        spans.push((expr.span, snippet(cx, recv.span, \"_\") + suffix));\n-                        return false;\n-                    }\n+    for_each_expr(body, |e| {\n+        if let ExprKind::MethodCall(seg, recv, [], _) = e.kind\n+            && path_to_local_id(recv, id)\n+        {\n+            if seg.ident.as_str() == \"capacity\" {\n+                return ControlFlow::Break(());\n+            }\n+            for &(fn_name, suffix) in replace {\n+                if seg.ident.as_str() == fn_name {\n+                    spans.push((e.span, snippet(cx, recv.span, \"_\") + suffix));\n+                    return ControlFlow::Continue(Descend::No);\n                 }\n             }\n         }\n-        !abort\n+        ControlFlow::Continue(Descend::Yes)\n     })\n-    .visit_body(body);\n-    if abort { None } else { Some(spans) }\n+    .is_none()\n+    .then_some(spans)\n }"}, {"sha": "b5ec3fef3e0b4b8f52867371e7088a0d7ef7ad8b", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n use crate as utils;\n-use crate::visitors::{expr_visitor, expr_visitor_no_bodies};\n+use crate::visitors::{for_each_expr, for_each_expr_with_closures, Descend};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirIdSet;\n@@ -148,28 +149,17 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n }\n \n pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n-    let mut seen_return_break_continue = false;\n-    expr_visitor_no_bodies(|ex| {\n-        if seen_return_break_continue {\n-            return false;\n-        }\n-        match &ex.kind {\n-            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n-                seen_return_break_continue = true;\n-            },\n+    for_each_expr(expression, |e| {\n+        match e.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => ControlFlow::Break(()),\n             // Something special could be done here to handle while or for loop\n             // desugaring, as this will detect a break if there's a while loop\n             // or a for loop inside the expression.\n-            _ => {\n-                if ex.span.from_expansion() {\n-                    seen_return_break_continue = true;\n-                }\n-            },\n+            _ if e.span.from_expansion() => ControlFlow::Break(()),\n+            _ => ControlFlow::Continue(()),\n         }\n-        !seen_return_break_continue\n     })\n-    .visit_expr(expression);\n-    seen_return_break_continue\n+    .is_some()\n }\n \n pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr<'_>) -> bool {\n@@ -200,23 +190,16 @@ pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr\n         return true;\n     }\n \n-    let mut used_after_expr = false;\n     let mut past_expr = false;\n-    expr_visitor(cx, |expr| {\n-        if used_after_expr {\n-            return false;\n-        }\n-\n-        if expr.hir_id == after.hir_id {\n+    for_each_expr_with_closures(cx, block, |e| {\n+        if e.hir_id == after.hir_id {\n             past_expr = true;\n-            return false;\n-        }\n-\n-        if past_expr && utils::path_to_local_id(expr, local_id) {\n-            used_after_expr = true;\n+            ControlFlow::Continue(Descend::No)\n+        } else if past_expr && utils::path_to_local_id(e, local_id) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-        !used_after_expr\n     })\n-    .visit_block(block);\n-    used_after_expr\n+    .is_some()\n }"}, {"sha": "d4294f18fd5019c0eed128e9321f8caca80b0109", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 75, "deletions": 89, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -5,14 +5,13 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, Pat, QPath, Stmt, UnOp,\n-    UnsafeSource, Unsafety,\n+    AnonConst, Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, Pat, QPath,\n+    Stmt, UnOp, UnsafeSource, Unsafety,\n };\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{self, Ty, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults};\n use rustc_span::Span;\n \n mod internal {\n@@ -48,6 +47,26 @@ impl Continue for Descend {\n     }\n }\n \n+/// A type which can be visited.\n+pub trait Visitable<'tcx> {\n+    /// Calls the corresponding `visit_*` function on the visitor.\n+    fn visit<V: Visitor<'tcx>>(self, visitor: &mut V);\n+}\n+macro_rules! visitable_ref {\n+    ($t:ident, $f:ident) => {\n+        impl<'tcx> Visitable<'tcx> for &'tcx $t<'tcx> {\n+            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+                visitor.$f(self);\n+            }\n+        }\n+    };\n+}\n+visitable_ref!(Arm, visit_arm);\n+visitable_ref!(Block, visit_block);\n+visitable_ref!(Body, visit_body);\n+visitable_ref!(Expr, visit_expr);\n+visitable_ref!(Stmt, visit_stmt);\n+\n /// Calls the given function once for each expression contained. This does not enter any bodies or\n /// nested items.\n pub fn for_each_expr<'tcx, B, C: Continue>(\n@@ -82,57 +101,63 @@ pub fn for_each_expr<'tcx, B, C: Continue>(\n     v.res\n }\n \n-/// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n-/// bodies (i.e. closures) are visited.\n-/// If the callback returns `true`, the expr just provided to the callback is walked.\n-#[must_use]\n-pub fn expr_visitor<'tcx>(cx: &LateContext<'tcx>, f: impl FnMut(&'tcx Expr<'tcx>) -> bool) -> impl Visitor<'tcx> {\n-    struct V<'tcx, F> {\n-        hir: Map<'tcx>,\n+/// Calls the given function once for each expression contained. This will enter bodies, but not\n+/// nested items.\n+pub fn for_each_expr_with_closures<'tcx, B, C: Continue>(\n+    cx: &LateContext<'tcx>,\n+    node: impl Visitable<'tcx>,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B, C>,\n+) -> Option<B> {\n+    struct V<'tcx, B, F> {\n+        tcx: TyCtxt<'tcx>,\n         f: F,\n+        res: Option<B>,\n     }\n-    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>) -> bool> Visitor<'tcx> for V<'tcx, F> {\n+    impl<'tcx, B, C: Continue, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B, C>> Visitor<'tcx> for V<'tcx, B, F> {\n         type NestedFilter = nested_filter::OnlyBodies;\n         fn nested_visit_map(&mut self) -> Self::Map {\n-            self.hir\n+            self.tcx.hir()\n         }\n \n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            if (self.f)(expr) {\n-                walk_expr(self, expr);\n+        fn visit_expr(&mut self, e: &'tcx Expr<'tcx>) {\n+            if self.res.is_some() {\n+                return;\n             }\n-        }\n-    }\n-    V { hir: cx.tcx.hir(), f }\n-}\n-\n-/// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n-/// bodies (i.e. closures) are not visited.\n-/// If the callback returns `true`, the expr just provided to the callback is walked.\n-#[must_use]\n-pub fn expr_visitor_no_bodies<'tcx>(f: impl FnMut(&'tcx Expr<'tcx>) -> bool) -> impl Visitor<'tcx> {\n-    struct V<F>(F);\n-    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>) -> bool> Visitor<'tcx> for V<F> {\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            if (self.0)(e) {\n-                walk_expr(self, e);\n+            match (self.f)(e) {\n+                ControlFlow::Continue(c) if c.descend() => walk_expr(self, e),\n+                ControlFlow::Break(b) => self.res = Some(b),\n+                ControlFlow::Continue(_) => (),\n             }\n         }\n+\n+        // Only walk closures\n+        fn visit_anon_const(&mut self, _: &'tcx AnonConst) {}\n+        // Avoid unnecessary `walk_*` calls.\n+        fn visit_ty(&mut self, _: &'tcx hir::Ty<'tcx>) {}\n+        fn visit_pat(&mut self, _: &'tcx Pat<'tcx>) {}\n+        fn visit_qpath(&mut self, _: &'tcx QPath<'tcx>, _: HirId, _: Span) {}\n+        // Avoid monomorphising all `visit_*` functions.\n+        fn visit_nested_item(&mut self, _: ItemId) {}\n     }\n-    V(f)\n+    let mut v = V {\n+        tcx: cx.tcx,\n+        f,\n+        res: None,\n+    };\n+    node.visit(&mut v);\n+    v.res\n }\n \n /// returns `true` if expr contains match expr desugared from try\n fn contains_try(expr: &hir::Expr<'_>) -> bool {\n-    let mut found = false;\n-    expr_visitor_no_bodies(|e| {\n-        if !found {\n-            found = matches!(e.kind, hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar));\n+    for_each_expr(expr, |e| {\n+        if matches!(e.kind, hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-        !found\n     })\n-    .visit_expr(expr);\n-    found\n+    .is_some()\n }\n \n pub fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n@@ -228,68 +253,29 @@ where\n     }\n }\n \n-/// A type which can be visited.\n-pub trait Visitable<'tcx> {\n-    /// Calls the corresponding `visit_*` function on the visitor.\n-    fn visit<V: Visitor<'tcx>>(self, visitor: &mut V);\n-}\n-macro_rules! visitable_ref {\n-    ($t:ident, $f:ident) => {\n-        impl<'tcx> Visitable<'tcx> for &'tcx $t<'tcx> {\n-            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n-                visitor.$f(self);\n-            }\n-        }\n-    };\n-}\n-visitable_ref!(Arm, visit_arm);\n-visitable_ref!(Block, visit_block);\n-visitable_ref!(Body, visit_body);\n-visitable_ref!(Expr, visit_expr);\n-visitable_ref!(Stmt, visit_stmt);\n-\n-// impl<'tcx, I: IntoIterator> Visitable<'tcx> for I\n-// where\n-//     I::Item: Visitable<'tcx>,\n-// {\n-//     fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n-//         for x in self {\n-//             x.visit(visitor);\n-//         }\n-//     }\n-// }\n-\n /// Checks if the given resolved path is used in the given body.\n pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n-    let mut found = false;\n-    expr_visitor(cx, |e| {\n-        if found {\n-            return false;\n-        }\n-\n+    for_each_expr_with_closures(cx, cx.tcx.hir().body(body).value, |e| {\n         if let ExprKind::Path(p) = &e.kind {\n             if cx.qpath_res(p, e.hir_id) == res {\n-                found = true;\n+                return ControlFlow::Break(());\n             }\n         }\n-        !found\n+        ControlFlow::Continue(())\n     })\n-    .visit_expr(cx.tcx.hir().body(body).value);\n-    found\n+    .is_some()\n }\n \n /// Checks if the given local is used.\n pub fn is_local_used<'tcx>(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n-    let mut is_used = false;\n-    let mut visitor = expr_visitor(cx, |expr| {\n-        if !is_used {\n-            is_used = path_to_local_id(expr, id);\n+    for_each_expr_with_closures(cx, visitable, |e| {\n+        if path_to_local_id(e, id) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-        !is_used\n-    });\n-    visitable.visit(&mut visitor);\n-    drop(visitor);\n-    is_used\n+    })\n+    .is_some()\n }\n \n /// Checks if the given expression is a constant."}, {"sha": "152459ba1c9d78b2a50a0b9b714b61584accdd75", "filename": "src/docs/needless_borrowed_reference.txt", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/src%2Fdocs%2Fneedless_borrowed_reference.txt", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/src%2Fdocs%2Fneedless_borrowed_reference.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fneedless_borrowed_reference.txt?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,30 +1,22 @@\n ### What it does\n-Checks for bindings that destructure a reference and borrow the inner\n+Checks for bindings that needlessly destructure a reference and borrow the inner\n value with `&ref`.\n \n ### Why is this bad?\n This pattern has no effect in almost all cases.\n \n-### Known problems\n-In some cases, `&ref` is needed to avoid a lifetime mismatch error.\n-Example:\n-```\n-fn foo(a: &Option<String>, b: &Option<String>) {\n-    match (a, b) {\n-        (None, &ref c) | (&ref c, None) => (),\n-        (&Some(ref c), _) => (),\n-    };\n-}\n-```\n-\n ### Example\n ```\n let mut v = Vec::<String>::new();\n v.iter_mut().filter(|&ref a| a.is_empty());\n+\n+if let &[ref first, ref second] = v.as_slice() {}\n ```\n \n Use instead:\n ```\n let mut v = Vec::<String>::new();\n v.iter_mut().filter(|a| a.is_empty());\n+\n+if let [first, second] = v.as_slice() {}\n ```\n\\ No newline at end of file"}, {"sha": "52fcaec4df32e2e92d3ffbaf5d756d1e5640f112", "filename": "tests/ui-internal/auxiliary/paths.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -0,0 +1,2 @@\n+pub static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];"}, {"sha": "4b41ff15e80f904c907cb5ce02732c5eb34da2a1", "filename": "tests/ui-internal/match_type_on_diag_item.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs?ref=7747032b774de25cb9e1cf672a9244f17eb234cb", "patch": "@@ -1,39 +0,0 @@\n-#![deny(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n-#![feature(rustc_private)]\n-\n-extern crate clippy_utils;\n-extern crate rustc_hir;\n-extern crate rustc_lint;\n-extern crate rustc_middle;\n-\n-#[macro_use]\n-extern crate rustc_session;\n-use clippy_utils::{paths, ty::match_type};\n-use rustc_hir::Expr;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::Ty;\n-\n-declare_lint! {\n-    pub TEST_LINT,\n-    Warn,\n-    \"\"\n-}\n-\n-declare_lint_pass!(Pass => [TEST_LINT]);\n-\n-static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-\n-impl<'tcx> LateLintPass<'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n-        let ty = cx.typeck_results().expr_ty(expr);\n-\n-        let _ = match_type(cx, ty, &OPTION);\n-        let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-\n-        let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n-        let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "e3cb6b6c22eada7f40fb0edeb61261104385a7a0", "filename": "tests/ui-internal/match_type_on_diag_item.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr?ref=7747032b774de25cb9e1cf672a9244f17eb234cb", "patch": "@@ -1,27 +0,0 @@\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:31:17\n-   |\n-LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Option)`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/match_type_on_diag_item.rs:1:9\n-   |\n-LL | #![deny(clippy::internal)]\n-   |         ^^^^^^^^^^^^^^^^\n-   = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n-\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:32:17\n-   |\n-LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Result)`\n-\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:35:17\n-   |\n-LL |         let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Rc)`\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "4c050332f2cc938ce497ecb9c55b3738b0d186c1", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+// aux-build:paths.rs\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy_utils;\n+extern crate paths;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_span;\n+\n+#[allow(unused)]\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+#[allow(unused)]\n+use clippy_utils::{\n+    is_expr_path_def_path, is_path_diagnostic_item, is_res_diagnostic_ctor, is_res_lang_ctor, is_trait_method,\n+    match_def_path, match_trait_method, path_res,\n+};\n+\n+#[allow(unused)]\n+use rustc_hir::LangItem;\n+#[allow(unused)]\n+use rustc_span::sym;\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+#[allow(unused)]\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+#[allow(unused)]\n+const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n+\n+fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+\n+    #[allow(unused)]\n+    let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Rc);\n+\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+\n+    let _ = is_type_lang_item(cx, ty, LangItem::OwnedBox);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit);\n+\n+    let _ = cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did);\n+    let _ = cx.tcx.is_diagnostic_item(sym::Option, did);\n+    let _ = cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did);\n+\n+    let _ = is_trait_method(cx, expr, sym::AsRef);\n+\n+    let _ = is_path_diagnostic_item(cx, expr, sym::Option);\n+    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id));\n+    let _ = is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome);\n+}\n+\n+fn main() {}"}, {"sha": "6506f1f164ac6b47d82f66485284af19042292b9", "filename": "tests/ui-internal/unnecessary_def_path.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+// aux-build:paths.rs\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy_utils;\n+extern crate paths;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_span;\n+\n+#[allow(unused)]\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+#[allow(unused)]\n+use clippy_utils::{\n+    is_expr_path_def_path, is_path_diagnostic_item, is_res_diagnostic_ctor, is_res_lang_ctor, is_trait_method,\n+    match_def_path, match_trait_method, path_res,\n+};\n+\n+#[allow(unused)]\n+use rustc_hir::LangItem;\n+#[allow(unused)]\n+use rustc_span::sym;\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+#[allow(unused)]\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+#[allow(unused)]\n+const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n+\n+fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n+    let _ = match_type(cx, ty, &OPTION);\n+    let _ = match_type(cx, ty, RESULT);\n+    let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+\n+    #[allow(unused)]\n+    let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+    let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+\n+    let _ = match_type(cx, ty, &paths::OPTION);\n+    let _ = match_type(cx, ty, paths::RESULT);\n+\n+    let _ = match_type(cx, ty, &[\"alloc\", \"boxed\", \"Box\"]);\n+    let _ = match_type(cx, ty, &[\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"]);\n+\n+    let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n+    let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\"]);\n+    let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+\n+    let _ = match_trait_method(cx, expr, &[\"core\", \"convert\", \"AsRef\"]);\n+\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\"]);\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+}\n+\n+fn main() {}"}, {"sha": "a99a8f71fa6a73aac3b1713ec2f7cb2ea1dcb9cb", "filename": "tests/ui-internal/unnecessary_def_path.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Funnecessary_def_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui-internal%2Funnecessary_def_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -0,0 +1,101 @@\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:37:13\n+   |\n+LL |     let _ = match_type(cx, ty, &OPTION);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Option)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unnecessary_def_path.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::unnecessary_def_path)]` implied by `#[deny(clippy::internal)]`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:38:13\n+   |\n+LL |     let _ = match_type(cx, ty, RESULT);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:39:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:43:13\n+   |\n+LL |     let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Rc)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:45:13\n+   |\n+LL |     let _ = match_type(cx, ty, &paths::OPTION);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Option)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:46:13\n+   |\n+LL |     let _ = match_type(cx, ty, paths::RESULT);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:48:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"alloc\", \"boxed\", \"Box\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_lang_item(cx, ty, LangItem::OwnedBox)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:49:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:51:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:52:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.is_diagnostic_item(sym::Option, did)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:53:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did)`\n+   |\n+   = help: if this `DefId` came from a constructor expression or pattern then the parent `DefId` should be used instead\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:55:13\n+   |\n+LL |     let _ = match_trait_method(cx, expr, &[\"core\", \"convert\", \"AsRef\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_trait_method(cx, expr, sym::AsRef)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:57:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_path_diagnostic_item(cx, expr, sym::Option)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:58:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id))`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:59:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome)`\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "b9e3d89c2b29df97ac35c61a6d85f66238cfa9e3", "filename": "tests/ui/floating_point_exp.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_exp.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_exp.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_exp.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::imprecise_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let x = 2f32;"}, {"sha": "ef008dd9be0554c0263346fab06c8bdc180569da", "filename": "tests/ui/floating_point_exp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_exp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_exp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_exp.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::imprecise_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let x = 2f32;"}, {"sha": "b92fae56e421c778af67b887baf0263861e14202", "filename": "tests/ui/floating_point_exp.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_exp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_exp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_exp.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,31 +1,31 @@\n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:6:13\n+  --> $DIR/floating_point_exp.rs:7:13\n    |\n LL |     let _ = x.exp() - 1.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n    |\n    = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n \n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:7:13\n+  --> $DIR/floating_point_exp.rs:8:13\n    |\n LL |     let _ = x.exp() - 1.0 + 2.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n \n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:8:13\n+  --> $DIR/floating_point_exp.rs:9:13\n    |\n LL |     let _ = (x as f32).exp() - 1.0 + 2.0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).exp_m1()`\n \n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:14:13\n+  --> $DIR/floating_point_exp.rs:15:13\n    |\n LL |     let _ = x.exp() - 1.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n \n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:15:13\n+  --> $DIR/floating_point_exp.rs:16:13\n    |\n LL |     let _ = x.exp() - 1.0 + 2.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`"}, {"sha": "ee540646160074b87a8b5dd11128e525f9e0424c", "filename": "tests/ui/floating_point_log.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_log.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_log.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code, clippy::double_parens)]\n+#![allow(dead_code, clippy::double_parens, clippy::unnecessary_cast)]\n #![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n \n const TWO: f32 = 2.0;"}, {"sha": "0590670a50bc799fc6ec2e1bea696630dbc6d627", "filename": "tests/ui/floating_point_log.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code, clippy::double_parens)]\n+#![allow(dead_code, clippy::double_parens, clippy::unnecessary_cast)]\n #![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n \n const TWO: f32 = 2.0;"}, {"sha": "7347bf72cbea6bc2346f5cdb07bc20ba02265191", "filename": "tests/ui/floating_point_logbase.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_logbase.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_logbase.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_logbase.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::suboptimal_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let x = 3f32;"}, {"sha": "ba5b8d406928396e90caa41f79f944bc794057b8", "filename": "tests/ui/floating_point_logbase.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_logbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_logbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_logbase.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::suboptimal_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let x = 3f32;"}, {"sha": "9d736b5e1a2748ef7e46769220391cdcf99c423a", "filename": "tests/ui/floating_point_logbase.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_logbase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_logbase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_logbase.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,31 +1,31 @@\n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:7:13\n+  --> $DIR/floating_point_logbase.rs:8:13\n    |\n LL |     let _ = x.ln() / y.ln();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n    |\n    = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n \n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:8:13\n+  --> $DIR/floating_point_logbase.rs:9:13\n    |\n LL |     let _ = (x as f32).ln() / y.ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).log(y)`\n \n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:9:13\n+  --> $DIR/floating_point_logbase.rs:10:13\n    |\n LL |     let _ = x.log2() / y.log2();\n    |             ^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n \n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:10:13\n+  --> $DIR/floating_point_logbase.rs:11:13\n    |\n LL |     let _ = x.log10() / y.log10();\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n \n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:11:13\n+  --> $DIR/floating_point_logbase.rs:12:13\n    |\n LL |     let _ = x.log(5f32) / y.log(5f32);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`"}, {"sha": "f7f93de29577d0086a0845af15d93f8a95768caa", "filename": "tests/ui/floating_point_powf.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powf.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powf.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powf.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let x = 3f32;"}, {"sha": "499fc0e15e47832d8a360037beeef00cce7b147c", "filename": "tests/ui/floating_point_powf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powf.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let x = 3f32;"}, {"sha": "7c9d50db2f78e1e314fe0274d1622de48a2ab807", "filename": "tests/ui/floating_point_powf.stderr", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powf.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,189 +1,189 @@\n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:6:13\n+  --> $DIR/floating_point_powf.rs:7:13\n    |\n LL |     let _ = 2f32.powf(x);\n    |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n    |\n    = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:7:13\n+  --> $DIR/floating_point_powf.rs:8:13\n    |\n LL |     let _ = 2f32.powf(3.1);\n    |             ^^^^^^^^^^^^^^ help: consider using: `3.1f32.exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:8:13\n+  --> $DIR/floating_point_powf.rs:9:13\n    |\n LL |     let _ = 2f32.powf(-3.1);\n    |             ^^^^^^^^^^^^^^^ help: consider using: `(-3.1f32).exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:9:13\n+  --> $DIR/floating_point_powf.rs:10:13\n    |\n LL |     let _ = std::f32::consts::E.powf(x);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:10:13\n+  --> $DIR/floating_point_powf.rs:11:13\n    |\n LL |     let _ = std::f32::consts::E.powf(3.1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `3.1f32.exp()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:11:13\n+  --> $DIR/floating_point_powf.rs:12:13\n    |\n LL |     let _ = std::f32::consts::E.powf(-3.1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-3.1f32).exp()`\n \n error: square-root of a number can be computed more efficiently and accurately\n-  --> $DIR/floating_point_powf.rs:12:13\n+  --> $DIR/floating_point_powf.rs:13:13\n    |\n LL |     let _ = x.powf(1.0 / 2.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n \n error: cube-root of a number can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:13:13\n+  --> $DIR/floating_point_powf.rs:14:13\n    |\n LL |     let _ = x.powf(1.0 / 3.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n    |\n    = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n \n error: cube-root of a number can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:14:13\n+  --> $DIR/floating_point_powf.rs:15:13\n    |\n LL |     let _ = (x as f32).powf(1.0 / 3.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).cbrt()`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:15:13\n+  --> $DIR/floating_point_powf.rs:16:13\n    |\n LL |     let _ = x.powf(3.0);\n    |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:16:13\n+  --> $DIR/floating_point_powf.rs:17:13\n    |\n LL |     let _ = x.powf(-2.0);\n    |             ^^^^^^^^^^^^ help: consider using: `x.powi(-2)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:17:13\n+  --> $DIR/floating_point_powf.rs:18:13\n    |\n LL |     let _ = x.powf(16_777_215.0);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(16_777_215)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:18:13\n+  --> $DIR/floating_point_powf.rs:19:13\n    |\n LL |     let _ = x.powf(-16_777_215.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(-16_777_215)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:19:13\n+  --> $DIR/floating_point_powf.rs:20:13\n    |\n LL |     let _ = (x as f32).powf(-16_777_215.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).powi(-16_777_215)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:20:13\n+  --> $DIR/floating_point_powf.rs:21:13\n    |\n LL |     let _ = (x as f32).powf(3.0);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).powi(3)`\n \n error: cube-root of a number can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:21:13\n+  --> $DIR/floating_point_powf.rs:22:13\n    |\n LL |     let _ = (1.5_f32 + 1.0).powf(1.0 / 3.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(1.5_f32 + 1.0).cbrt()`\n \n error: cube-root of a number can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:22:13\n+  --> $DIR/floating_point_powf.rs:23:13\n    |\n LL |     let _ = 1.5_f64.powf(1.0 / 3.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1.5_f64.cbrt()`\n \n error: square-root of a number can be computed more efficiently and accurately\n-  --> $DIR/floating_point_powf.rs:23:13\n+  --> $DIR/floating_point_powf.rs:24:13\n    |\n LL |     let _ = 1.5_f64.powf(1.0 / 2.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1.5_f64.sqrt()`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:24:13\n+  --> $DIR/floating_point_powf.rs:25:13\n    |\n LL |     let _ = 1.5_f64.powf(3.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `1.5_f64.powi(3)`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:33:13\n+  --> $DIR/floating_point_powf.rs:34:13\n    |\n LL |     let _ = 2f64.powf(x);\n    |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:34:13\n+  --> $DIR/floating_point_powf.rs:35:13\n    |\n LL |     let _ = 2f64.powf(3.1);\n    |             ^^^^^^^^^^^^^^ help: consider using: `3.1f64.exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:35:13\n+  --> $DIR/floating_point_powf.rs:36:13\n    |\n LL |     let _ = 2f64.powf(-3.1);\n    |             ^^^^^^^^^^^^^^^ help: consider using: `(-3.1f64).exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:36:13\n+  --> $DIR/floating_point_powf.rs:37:13\n    |\n LL |     let _ = std::f64::consts::E.powf(x);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:37:13\n+  --> $DIR/floating_point_powf.rs:38:13\n    |\n LL |     let _ = std::f64::consts::E.powf(3.1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `3.1f64.exp()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:38:13\n+  --> $DIR/floating_point_powf.rs:39:13\n    |\n LL |     let _ = std::f64::consts::E.powf(-3.1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-3.1f64).exp()`\n \n error: square-root of a number can be computed more efficiently and accurately\n-  --> $DIR/floating_point_powf.rs:39:13\n+  --> $DIR/floating_point_powf.rs:40:13\n    |\n LL |     let _ = x.powf(1.0 / 2.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n \n error: cube-root of a number can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:40:13\n+  --> $DIR/floating_point_powf.rs:41:13\n    |\n LL |     let _ = x.powf(1.0 / 3.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:41:13\n+  --> $DIR/floating_point_powf.rs:42:13\n    |\n LL |     let _ = x.powf(3.0);\n    |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:42:13\n+  --> $DIR/floating_point_powf.rs:43:13\n    |\n LL |     let _ = x.powf(-2.0);\n    |             ^^^^^^^^^^^^ help: consider using: `x.powi(-2)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:43:13\n+  --> $DIR/floating_point_powf.rs:44:13\n    |\n LL |     let _ = x.powf(-2_147_483_648.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(-2_147_483_648)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:44:13\n+  --> $DIR/floating_point_powf.rs:45:13\n    |\n LL |     let _ = x.powf(2_147_483_647.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2_147_483_647)`"}, {"sha": "884d05fed71ba2f650100a8e1db301ac3c5731e7", "filename": "tests/ui/floating_point_powi.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powi.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powi.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powi.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::suboptimal_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let one = 1;"}, {"sha": "e6a1c895371b6fe68622774068b4a693798350b8", "filename": "tests/ui/floating_point_powi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powi.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::suboptimal_flops)]\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let one = 1;"}, {"sha": "5df0de1fef22e59f22fdf21d73e5c6e2ed7bed69", "filename": "tests/ui/floating_point_powi.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Ffloating_point_powi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powi.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,43 +1,43 @@\n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:9:13\n+  --> $DIR/floating_point_powi.rs:10:13\n    |\n LL |     let _ = x.powi(2) + y;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n    |\n    = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:10:13\n+  --> $DIR/floating_point_powi.rs:11:13\n    |\n LL |     let _ = x.powi(2) - y;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, -y)`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:11:13\n+  --> $DIR/floating_point_powi.rs:12:13\n    |\n LL |     let _ = x + y.powi(2);\n    |             ^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:12:13\n+  --> $DIR/floating_point_powi.rs:13:13\n    |\n LL |     let _ = x - y.powi(2);\n    |             ^^^^^^^^^^^^^ help: consider using: `y.mul_add(-y, x)`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:13:13\n+  --> $DIR/floating_point_powi.rs:14:13\n    |\n LL |     let _ = x + (y as f32).powi(2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(y as f32).mul_add(y as f32, x)`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:14:13\n+  --> $DIR/floating_point_powi.rs:15:13\n    |\n LL |     let _ = (x.powi(2) + y).sqrt();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:15:13\n+  --> $DIR/floating_point_powi.rs:16:13\n    |\n LL |     let _ = (x + y.powi(2)).sqrt();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`"}, {"sha": "84f6855f3387bc232c9cc8c10b1e6d6eff57e067", "filename": "tests/ui/manual_assert.edition2018.fixed", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -4,7 +4,7 @@\n // run-rustfix\n \n #![warn(clippy::manual_assert)]\n-#![allow(clippy::nonminimal_bool)]\n+#![allow(dead_code, unused_doc_comments, clippy::nonminimal_bool)]\n \n macro_rules! one {\n     () => {\n@@ -50,3 +50,14 @@ fn main() {\n     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n     assert!(!a.is_empty(), \"with expansion {}\", one!());\n }\n+\n+fn issue7730(a: u8) {\n+    // Suggestion should preserve comment\n+    // comment\n+/* this is a\n+        multiline\n+        comment */\n+/// Doc comment\n+// comment after `panic!`\n+assert!(!(a > 2), \"panic with comment\");\n+}"}, {"sha": "dbd21be2da9e181b9f153927e312a27b8232c230", "filename": "tests/ui/manual_assert.edition2018.stderr", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -4,65 +4,121 @@ error: only a `panic!` in `if`-then statement\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qaqaq{:?}\", a);\n LL | |     }\n-   | |_____^ help: try: `assert!(a.is_empty(), \"qaqaq{:?}\", a);`\n+   | |_____^\n    |\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n+help: try instead\n+   |\n+LL |     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:33:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qwqwq\");\n LL | |     }\n-   | |_____^ help: try: `assert!(a.is_empty(), \"qwqwq\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(a.is_empty(), \"qwqwq\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:50:5\n    |\n LL | /     if b.is_empty() {\n LL | |         panic!(\"panic1\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!b.is_empty(), \"panic1\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!b.is_empty(), \"panic1\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:53:5\n    |\n LL | /     if b.is_empty() && a.is_empty() {\n LL | |         panic!(\"panic2\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:56:5\n    |\n LL | /     if a.is_empty() && !b.is_empty() {\n LL | |         panic!(\"panic3\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:59:5\n    |\n LL | /     if b.is_empty() || a.is_empty() {\n LL | |         panic!(\"panic4\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:62:5\n    |\n LL | /     if a.is_empty() || !b.is_empty() {\n LL | |         panic!(\"panic5\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:65:5\n    |\n LL | /     if a.is_empty() {\n LL | |         panic!(\"with expansion {}\", one!())\n LL | |     }\n-   | |_____^ help: try: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!a.is_empty(), \"with expansion {}\", one!());\n+   |\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:72:5\n+   |\n+LL | /     if a > 2 {\n+LL | |         // comment\n+LL | |         /* this is a\n+LL | |         multiline\n+...  |\n+LL | |         panic!(\"panic with comment\") // comment after `panic!`\n+LL | |     }\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a > 2), \"panic with comment\");\n+   |\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "84f6855f3387bc232c9cc8c10b1e6d6eff57e067", "filename": "tests/ui/manual_assert.edition2021.fixed", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2021.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2021.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2021.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -4,7 +4,7 @@\n // run-rustfix\n \n #![warn(clippy::manual_assert)]\n-#![allow(clippy::nonminimal_bool)]\n+#![allow(dead_code, unused_doc_comments, clippy::nonminimal_bool)]\n \n macro_rules! one {\n     () => {\n@@ -50,3 +50,14 @@ fn main() {\n     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n     assert!(!a.is_empty(), \"with expansion {}\", one!());\n }\n+\n+fn issue7730(a: u8) {\n+    // Suggestion should preserve comment\n+    // comment\n+/* this is a\n+        multiline\n+        comment */\n+/// Doc comment\n+// comment after `panic!`\n+assert!(!(a > 2), \"panic with comment\");\n+}"}, {"sha": "dbd21be2da9e181b9f153927e312a27b8232c230", "filename": "tests/ui/manual_assert.edition2021.stderr", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.edition2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2021.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -4,65 +4,121 @@ error: only a `panic!` in `if`-then statement\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qaqaq{:?}\", a);\n LL | |     }\n-   | |_____^ help: try: `assert!(a.is_empty(), \"qaqaq{:?}\", a);`\n+   | |_____^\n    |\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n+help: try instead\n+   |\n+LL |     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:33:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qwqwq\");\n LL | |     }\n-   | |_____^ help: try: `assert!(a.is_empty(), \"qwqwq\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(a.is_empty(), \"qwqwq\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:50:5\n    |\n LL | /     if b.is_empty() {\n LL | |         panic!(\"panic1\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!b.is_empty(), \"panic1\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!b.is_empty(), \"panic1\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:53:5\n    |\n LL | /     if b.is_empty() && a.is_empty() {\n LL | |         panic!(\"panic2\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:56:5\n    |\n LL | /     if a.is_empty() && !b.is_empty() {\n LL | |         panic!(\"panic3\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:59:5\n    |\n LL | /     if b.is_empty() || a.is_empty() {\n LL | |         panic!(\"panic4\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:62:5\n    |\n LL | /     if a.is_empty() || !b.is_empty() {\n LL | |         panic!(\"panic5\");\n LL | |     }\n-   | |_____^ help: try: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n+   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:65:5\n    |\n LL | /     if a.is_empty() {\n LL | |         panic!(\"with expansion {}\", one!())\n LL | |     }\n-   | |_____^ help: try: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!a.is_empty(), \"with expansion {}\", one!());\n+   |\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:72:5\n+   |\n+LL | /     if a > 2 {\n+LL | |         // comment\n+LL | |         /* this is a\n+LL | |         multiline\n+...  |\n+LL | |         panic!(\"panic with comment\") // comment after `panic!`\n+LL | |     }\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a > 2), \"panic with comment\");\n+   |\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "a2393674fe6129dae1a74fe21562dceb014dafd3", "filename": "tests/ui/manual_assert.fixed", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui%2Fmanual_assert.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui%2Fmanual_assert.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.fixed?ref=7747032b774de25cb9e1cf672a9244f17eb234cb", "patch": "@@ -1,45 +0,0 @@\n-// revisions: edition2018 edition2021\n-// [edition2018] edition:2018\n-// [edition2021] edition:2021\n-// run-rustfix\n-\n-#![warn(clippy::manual_assert)]\n-#![allow(clippy::nonminimal_bool)]\n-\n-fn main() {\n-    let a = vec![1, 2, 3];\n-    let c = Some(2);\n-    if !a.is_empty()\n-        && a.len() == 3\n-        && c.is_some()\n-        && !a.is_empty()\n-        && a.len() == 3\n-        && !a.is_empty()\n-        && a.len() == 3\n-        && !a.is_empty()\n-        && a.len() == 3\n-    {\n-        panic!(\"qaqaq{:?}\", a);\n-    }\n-    assert!(a.is_empty(), \"qaqaq{:?}\", a);\n-    assert!(a.is_empty(), \"qwqwq\");\n-    if a.len() == 3 {\n-        println!(\"qwq\");\n-        println!(\"qwq\");\n-        println!(\"qwq\");\n-    }\n-    if let Some(b) = c {\n-        panic!(\"orz {}\", b);\n-    }\n-    if a.len() == 3 {\n-        panic!(\"qaqaq\");\n-    } else {\n-        println!(\"qwq\");\n-    }\n-    let b = vec![1, 2, 3];\n-    assert!(!b.is_empty(), \"panic1\");\n-    assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n-    assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n-    assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n-    assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n-}"}, {"sha": "14abf94965af03529a42eec35237d66c759af7fc", "filename": "tests/ui/manual_assert.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -4,7 +4,7 @@\n // run-rustfix\n \n #![warn(clippy::manual_assert)]\n-#![allow(clippy::nonminimal_bool)]\n+#![allow(dead_code, unused_doc_comments, clippy::nonminimal_bool)]\n \n macro_rules! one {\n     () => {\n@@ -66,3 +66,15 @@ fn main() {\n         panic!(\"with expansion {}\", one!())\n     }\n }\n+\n+fn issue7730(a: u8) {\n+    // Suggestion should preserve comment\n+    if a > 2 {\n+        // comment\n+        /* this is a\n+        multiline\n+        comment */\n+        /// Doc comment\n+        panic!(\"panic with comment\") // comment after `panic!`\n+    }\n+}"}, {"sha": "e7f8cd878ca789076f28a8aff64eb95cdd336d4c", "filename": "tests/ui/manual_bits.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_bits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_bits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_bits.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -6,7 +6,8 @@\n     clippy::useless_conversion,\n     path_statements,\n     unused_must_use,\n-    clippy::unnecessary_operation\n+    clippy::unnecessary_operation,\n+    clippy::unnecessary_cast\n )]\n \n use std::mem::{size_of, size_of_val};"}, {"sha": "7b1d15495287a6327058245c5121e7a348d9b1b4", "filename": "tests/ui/manual_bits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_bits.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -6,7 +6,8 @@\n     clippy::useless_conversion,\n     path_statements,\n     unused_must_use,\n-    clippy::unnecessary_operation\n+    clippy::unnecessary_operation,\n+    clippy::unnecessary_cast\n )]\n \n use std::mem::{size_of, size_of_val};"}, {"sha": "652fafbc41d8107e717bc51ddc75adaf2478b10e", "filename": "tests/ui/manual_bits.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_bits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fmanual_bits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_bits.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,175 +1,175 @@\n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:15:5\n+  --> $DIR/manual_bits.rs:16:5\n    |\n LL |     size_of::<i8>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS as usize`\n    |\n    = note: `-D clippy::manual-bits` implied by `-D warnings`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:16:5\n+  --> $DIR/manual_bits.rs:17:5\n    |\n LL |     size_of::<i16>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:17:5\n+  --> $DIR/manual_bits.rs:18:5\n    |\n LL |     size_of::<i32>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:18:5\n+  --> $DIR/manual_bits.rs:19:5\n    |\n LL |     size_of::<i64>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:19:5\n+  --> $DIR/manual_bits.rs:20:5\n    |\n LL |     size_of::<i128>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:20:5\n+  --> $DIR/manual_bits.rs:21:5\n    |\n LL |     size_of::<isize>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:22:5\n+  --> $DIR/manual_bits.rs:23:5\n    |\n LL |     size_of::<u8>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:23:5\n+  --> $DIR/manual_bits.rs:24:5\n    |\n LL |     size_of::<u16>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:24:5\n+  --> $DIR/manual_bits.rs:25:5\n    |\n LL |     size_of::<u32>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:25:5\n+  --> $DIR/manual_bits.rs:26:5\n    |\n LL |     size_of::<u64>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:26:5\n+  --> $DIR/manual_bits.rs:27:5\n    |\n LL |     size_of::<u128>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:27:5\n+  --> $DIR/manual_bits.rs:28:5\n    |\n LL |     size_of::<usize>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:29:5\n+  --> $DIR/manual_bits.rs:30:5\n    |\n LL |     8 * size_of::<i8>();\n    |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:30:5\n+  --> $DIR/manual_bits.rs:31:5\n    |\n LL |     8 * size_of::<i16>();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:31:5\n+  --> $DIR/manual_bits.rs:32:5\n    |\n LL |     8 * size_of::<i32>();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:32:5\n+  --> $DIR/manual_bits.rs:33:5\n    |\n LL |     8 * size_of::<i64>();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:33:5\n+  --> $DIR/manual_bits.rs:34:5\n    |\n LL |     8 * size_of::<i128>();\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:34:5\n+  --> $DIR/manual_bits.rs:35:5\n    |\n LL |     8 * size_of::<isize>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:36:5\n+  --> $DIR/manual_bits.rs:37:5\n    |\n LL |     8 * size_of::<u8>();\n    |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:37:5\n+  --> $DIR/manual_bits.rs:38:5\n    |\n LL |     8 * size_of::<u16>();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:38:5\n+  --> $DIR/manual_bits.rs:39:5\n    |\n LL |     8 * size_of::<u32>();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:39:5\n+  --> $DIR/manual_bits.rs:40:5\n    |\n LL |     8 * size_of::<u64>();\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:40:5\n+  --> $DIR/manual_bits.rs:41:5\n    |\n LL |     8 * size_of::<u128>();\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:41:5\n+  --> $DIR/manual_bits.rs:42:5\n    |\n LL |     8 * size_of::<usize>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:51:5\n+  --> $DIR/manual_bits.rs:52:5\n    |\n LL |     size_of::<Word>() * 8;\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `Word::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:55:18\n+  --> $DIR/manual_bits.rs:56:18\n    |\n LL |     let _: u32 = (size_of::<u128>() * 8) as u32;\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:56:18\n+  --> $DIR/manual_bits.rs:57:18\n    |\n LL |     let _: u32 = (size_of::<u128>() * 8).try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:57:13\n+  --> $DIR/manual_bits.rs:58:13\n    |\n LL |     let _ = (size_of::<u128>() * 8).pow(5);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(u128::BITS as usize)`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:58:14\n+  --> $DIR/manual_bits.rs:59:14\n    |\n LL |     let _ = &(size_of::<u128>() * 8);\n    |              ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(u128::BITS as usize)`"}, {"sha": "bcb4eb2dd48a65615d4241b5f8f48f1370abd12c", "filename": "tests/ui/needless_borrowed_ref.fixed", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fneedless_borrowed_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fneedless_borrowed_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,17 +1,38 @@\n // run-rustfix\n \n-#[warn(clippy::needless_borrowed_reference)]\n-#[allow(unused_variables)]\n-fn main() {\n+#![warn(clippy::needless_borrowed_reference)]\n+#![allow(unused, clippy::needless_borrow)]\n+\n+fn main() {}\n+\n+fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n     let mut v = Vec::<String>::new();\n     let _ = v.iter_mut().filter(|a| a.is_empty());\n-    //                            ^ should be linted\n \n     let var = 3;\n     let thingy = Some(&var);\n-    if let Some(&ref v) = thingy {\n-        //          ^ should be linted\n-    }\n+    if let Some(v) = thingy {}\n+\n+    if let &[a, ref b] = slice_of_refs {}\n+\n+    let [a, ..] = &array;\n+    let [a, b, ..] = &array;\n+\n+    if let [a, b] = slice {}\n+    if let [a, b] = &vec[..] {}\n+\n+    if let [a, b, ..] = slice {}\n+    if let [a, .., b] = slice {}\n+    if let [.., a, b] = slice {}\n+}\n+\n+fn should_not_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+    if let [ref a] = slice {}\n+    if let &[ref a, b] = slice {}\n+    if let &[ref a, .., b] = slice {}\n+\n+    // must not be removed as variables must be bound consistently across | patterns\n+    if let (&[ref a], _) | ([], ref a) = (slice_of_refs, &1u8) {}\n \n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n@@ -28,17 +49,15 @@ fn main() {\n     }\n }\n \n-#[allow(dead_code)]\n enum Animal {\n     Cat(u64),\n     Dog(u64),\n }\n \n-#[allow(unused_variables)]\n-#[allow(dead_code)]\n fn foo(a: &Animal, b: &Animal) {\n     match (a, b) {\n-        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (), // lifetime mismatch error if there is no '&ref'\n+        // lifetime mismatch error if there is no '&ref' before `feature(nll)` stabilization in 1.63\n+        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (),\n         //                  ^    and   ^ should **not** be linted\n         (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n     }"}, {"sha": "f6de1a6d83d1bbdf965c19a28823899956608e44", "filename": "tests/ui/needless_borrowed_ref.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,17 +1,38 @@\n // run-rustfix\n \n-#[warn(clippy::needless_borrowed_reference)]\n-#[allow(unused_variables)]\n-fn main() {\n+#![warn(clippy::needless_borrowed_reference)]\n+#![allow(unused, clippy::needless_borrow)]\n+\n+fn main() {}\n+\n+fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n     let mut v = Vec::<String>::new();\n     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-    //                            ^ should be linted\n \n     let var = 3;\n     let thingy = Some(&var);\n-    if let Some(&ref v) = thingy {\n-        //          ^ should be linted\n-    }\n+    if let Some(&ref v) = thingy {}\n+\n+    if let &[&ref a, ref b] = slice_of_refs {}\n+\n+    let &[ref a, ..] = &array;\n+    let &[ref a, ref b, ..] = &array;\n+\n+    if let &[ref a, ref b] = slice {}\n+    if let &[ref a, ref b] = &vec[..] {}\n+\n+    if let &[ref a, ref b, ..] = slice {}\n+    if let &[ref a, .., ref b] = slice {}\n+    if let &[.., ref a, ref b] = slice {}\n+}\n+\n+fn should_not_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+    if let [ref a] = slice {}\n+    if let &[ref a, b] = slice {}\n+    if let &[ref a, .., b] = slice {}\n+\n+    // must not be removed as variables must be bound consistently across | patterns\n+    if let (&[ref a], _) | ([], ref a) = (slice_of_refs, &1u8) {}\n \n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n@@ -28,17 +49,15 @@ fn main() {\n     }\n }\n \n-#[allow(dead_code)]\n enum Animal {\n     Cat(u64),\n     Dog(u64),\n }\n \n-#[allow(unused_variables)]\n-#[allow(dead_code)]\n fn foo(a: &Animal, b: &Animal) {\n     match (a, b) {\n-        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (), // lifetime mismatch error if there is no '&ref'\n+        // lifetime mismatch error if there is no '&ref' before `feature(nll)` stabilization in 1.63\n+        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (),\n         //                  ^    and   ^ should **not** be linted\n         (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n     }"}, {"sha": "7453542e673f3bbf5f07f0003b408d4c9c77310f", "filename": "tests/ui/needless_borrowed_ref.stderr", "status": "modified", "additions": 117, "deletions": 4, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fneedless_borrowed_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fneedless_borrowed_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,10 +1,123 @@\n-error: this pattern takes a reference on something that is being de-referenced\n-  --> $DIR/needless_borrowed_ref.rs:7:34\n+error: this pattern takes a reference on something that is being dereferenced\n+  --> $DIR/needless_borrowed_ref.rs:10:34\n    |\n LL |     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-   |                                  ^^^^^^ help: try removing the `&ref` part and just keep: `a`\n+   |                                  ^^^^^^\n    |\n    = note: `-D clippy::needless-borrowed-reference` implied by `-D warnings`\n+help: try removing the `&ref` part\n+   |\n+LL -     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n+LL +     let _ = v.iter_mut().filter(|a| a.is_empty());\n+   |\n+\n+error: this pattern takes a reference on something that is being dereferenced\n+  --> $DIR/needless_borrowed_ref.rs:14:17\n+   |\n+LL |     if let Some(&ref v) = thingy {}\n+   |                 ^^^^^^\n+   |\n+help: try removing the `&ref` part\n+   |\n+LL -     if let Some(&ref v) = thingy {}\n+LL +     if let Some(v) = thingy {}\n+   |\n+\n+error: this pattern takes a reference on something that is being dereferenced\n+  --> $DIR/needless_borrowed_ref.rs:16:14\n+   |\n+LL |     if let &[&ref a, ref b] = slice_of_refs {}\n+   |              ^^^^^^\n+   |\n+help: try removing the `&ref` part\n+   |\n+LL -     if let &[&ref a, ref b] = slice_of_refs {}\n+LL +     if let &[a, ref b] = slice_of_refs {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:18:9\n+   |\n+LL |     let &[ref a, ..] = &array;\n+   |         ^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     let &[ref a, ..] = &array;\n+LL +     let [a, ..] = &array;\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:19:9\n+   |\n+LL |     let &[ref a, ref b, ..] = &array;\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     let &[ref a, ref b, ..] = &array;\n+LL +     let [a, b, ..] = &array;\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:21:12\n+   |\n+LL |     if let &[ref a, ref b] = slice {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, ref b] = slice {}\n+LL +     if let [a, b] = slice {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:22:12\n+   |\n+LL |     if let &[ref a, ref b] = &vec[..] {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, ref b] = &vec[..] {}\n+LL +     if let [a, b] = &vec[..] {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:24:12\n+   |\n+LL |     if let &[ref a, ref b, ..] = slice {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, ref b, ..] = slice {}\n+LL +     if let [a, b, ..] = slice {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:25:12\n+   |\n+LL |     if let &[ref a, .., ref b] = slice {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, .., ref b] = slice {}\n+LL +     if let [a, .., b] = slice {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:26:12\n+   |\n+LL |     if let &[.., ref a, ref b] = slice {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[.., ref a, ref b] = slice {}\n+LL +     if let [.., a, b] = slice {}\n+   |\n \n-error: aborting due to previous error\n+error: aborting due to 10 previous errors\n "}, {"sha": "29691e81666f7797bc99428b961545f9249331d7", "filename": "tests/ui/option_take_on_temporary.fixed", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui%2Foption_take_on_temporary.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7747032b774de25cb9e1cf672a9244f17eb234cb/tests%2Fui%2Foption_take_on_temporary.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_take_on_temporary.fixed?ref=7747032b774de25cb9e1cf672a9244f17eb234cb", "patch": "@@ -1,15 +0,0 @@\n-// run-rustfix\n-\n-fn main() {\n-    println!(\"Testing non erroneous option_take_on_temporary\");\n-    let mut option = Some(1);\n-    let _ = Box::new(move || option.take().unwrap());\n-\n-    println!(\"Testing non erroneous option_take_on_temporary\");\n-    let x = Some(3);\n-    x.as_ref();\n-\n-    println!(\"Testing erroneous option_take_on_temporary\");\n-    let x = Some(3);\n-    x.as_ref();\n-}"}, {"sha": "c57e2990fb9519871024e969ab5d8fecdb08b2fd", "filename": "tests/ui/ptr_offset_with_cast.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fptr_offset_with_cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fptr_offset_with_cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_offset_with_cast.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let vec = vec![b'a', b'b', b'c'];"}, {"sha": "3de7997acddda2901c2e245715e65f555a18abff", "filename": "tests/ui/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_offset_with_cast.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![allow(clippy::unnecessary_cast)]\n \n fn main() {\n     let vec = vec![b'a', b'b', b'c'];"}, {"sha": "3ba40593d6444148f63ee18bfd709af4e485d89e", "filename": "tests/ui/ptr_offset_with_cast.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fptr_offset_with_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Fptr_offset_with_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_offset_with_cast.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -1,13 +1,13 @@\n error: use of `offset` with a `usize` casted to an `isize`\n-  --> $DIR/ptr_offset_with_cast.rs:12:17\n+  --> $DIR/ptr_offset_with_cast.rs:13:17\n    |\n LL |         let _ = ptr.offset(offset_usize as isize);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.add(offset_usize)`\n    |\n    = note: `-D clippy::ptr-offset-with-cast` implied by `-D warnings`\n \n error: use of `wrapping_offset` with a `usize` casted to an `isize`\n-  --> $DIR/ptr_offset_with_cast.rs:16:17\n+  --> $DIR/ptr_offset_with_cast.rs:17:17\n    |\n LL |         let _ = ptr.wrapping_offset(offset_usize as isize);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.wrapping_add(offset_usize)`"}, {"sha": "94dc96427263cf36102800d5e04b25c608830eee", "filename": "tests/ui/unnecessary_cast.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Funnecessary_cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Funnecessary_cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast.fixed?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -97,4 +97,18 @@ mod fixable {\n \n         let _ = -(1 + 1) as i64;\n     }\n+\n+    fn issue_9563() {\n+        let _: f64 = (-8.0_f64).exp();\n+        #[allow(clippy::precedence)]\n+        let _: f64 = -8.0_f64.exp(); // should suggest `-8.0_f64.exp()` here not to change code behavior\n+    }\n+\n+    fn issue_9562_non_literal() {\n+        fn foo() -> f32 {\n+            0.\n+        }\n+\n+        let _num = foo();\n+    }\n }"}, {"sha": "e5150256f69ac49e5dbd465c616484352e5b5297", "filename": "tests/ui/unnecessary_cast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast.rs?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -97,4 +97,18 @@ mod fixable {\n \n         let _ = -(1 + 1) as i64;\n     }\n+\n+    fn issue_9563() {\n+        let _: f64 = (-8.0 as f64).exp();\n+        #[allow(clippy::precedence)]\n+        let _: f64 = -(8.0 as f64).exp(); // should suggest `-8.0_f64.exp()` here not to change code behavior\n+    }\n+\n+    fn issue_9562_non_literal() {\n+        fn foo() -> f32 {\n+            0.\n+        }\n+\n+        let _num = foo() as f32;\n+    }\n }"}, {"sha": "e5c3dd5e53f876e2489d702319694058069fd6d4", "filename": "tests/ui/unnecessary_cast.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Funnecessary_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15431b36bb760a8793740907e8d13e7ed8272e89/tests%2Fui%2Funnecessary_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast.stderr?ref=15431b36bb760a8793740907e8d13e7ed8272e89", "patch": "@@ -162,5 +162,23 @@ error: casting integer literal to `i64` is unnecessary\n LL |         let _: i64 = -(1) as i64;\n    |                      ^^^^^^^^^^^ help: try: `-1_i64`\n \n-error: aborting due to 27 previous errors\n+error: casting float literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:102:22\n+   |\n+LL |         let _: f64 = (-8.0 as f64).exp();\n+   |                      ^^^^^^^^^^^^^ help: try: `(-8.0_f64)`\n+\n+error: casting float literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:104:23\n+   |\n+LL |         let _: f64 = -(8.0 as f64).exp(); // should suggest `-8.0_f64.exp()` here not to change code behavior\n+   |                       ^^^^^^^^^^^^ help: try: `8.0_f64`\n+\n+error: casting to the same type is unnecessary (`f32` -> `f32`)\n+  --> $DIR/unnecessary_cast.rs:112:20\n+   |\n+LL |         let _num = foo() as f32;\n+   |                    ^^^^^^^^^^^^ help: try: `foo()`\n+\n+error: aborting due to 30 previous errors\n "}]}