{"sha": "745fd9903c804a6810cd3a1e050116f2c3575ac0", "node_id": "C_kwDOAAsO6NoAKDc0NWZkOTkwM2M4MDRhNjgxMGNkM2ExZTA1MDExNmYyYzM1NzVhYzA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-02T12:20:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-02T12:20:45Z"}, "message": "Merge #10428\n\n10428: minor: regen r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9dfe92a44334a5631e5ef0f15658df4e321fda18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dfe92a44334a5631e5ef0f15658df4e321fda18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/745fd9903c804a6810cd3a1e050116f2c3575ac0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhWE6dCRBK7hj4Ov3rIwAA5bIIACBL55dTOhfhrSn6eQYqUXIi\nc7GDtW3LrQLndz6siKOtzuXXg2yhb/90WvYytHbNcbwHaPwSZoMKdud7m2jej0Rn\nGl87Ix1AGgpAwO0PEp9yNzHEbHbnEeF4dnNjPMRDsm6QW+LwCJtxIsT7tcN0OJzc\nJMUAlVKiR1AzOHnruQyeYVd+EFRSfEIk0zSbEj9KCoSg6rlHWKrMQLI/3JRVbfc0\nhqdM9u9K2JApfVeYxuMhNqk90laML69QIzu8pyA1MO3RHvjWbkGumb0F54ETkRKn\nHh6ihp0fUcDlOj7IBQZ5MnWdy8Qc9hdzshf/NB31GhoMZ2RiSfWljObRcIHFieE=\n=q0oj\n-----END PGP SIGNATURE-----\n", "payload": "tree 9dfe92a44334a5631e5ef0f15658df4e321fda18\nparent a6e6f9c58b951459a73497618fc523d96de24fba\nparent f04f8ddb0dc5ea9b2f38e6dc0ccac6a0ad0d48db\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633177245 +0000\ncommitter GitHub <noreply@github.com> 1633177245 +0000\n\nMerge #10428\n\n10428: minor: regen r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/745fd9903c804a6810cd3a1e050116f2c3575ac0", "html_url": "https://github.com/rust-lang/rust/commit/745fd9903c804a6810cd3a1e050116f2c3575ac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/745fd9903c804a6810cd3a1e050116f2c3575ac0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6e6f9c58b951459a73497618fc523d96de24fba", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e6f9c58b951459a73497618fc523d96de24fba", "html_url": "https://github.com/rust-lang/rust/commit/a6e6f9c58b951459a73497618fc523d96de24fba"}, {"sha": "f04f8ddb0dc5ea9b2f38e6dc0ccac6a0ad0d48db", "url": "https://api.github.com/repos/rust-lang/rust/commits/f04f8ddb0dc5ea9b2f38e6dc0ccac6a0ad0d48db", "html_url": "https://github.com/rust-lang/rust/commit/f04f8ddb0dc5ea9b2f38e6dc0ccac6a0ad0d48db"}], "stats": {"total": 152, "additions": 151, "deletions": 1}, "files": [{"sha": "1810033e844ffe92b18cfc6c44cd90f6db17d28a", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/745fd9903c804a6810cd3a1e050116f2c3575ac0/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745fd9903c804a6810cd3a1e050116f2c3575ac0/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=745fd9903c804a6810cd3a1e050116f2c3575ac0", "patch": "@@ -5,6 +5,7 @@ use crate::{\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n     pub(crate) syntax: SyntaxNode,\n@@ -13,6 +14,7 @@ impl Name {\n     pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n     pub(crate) syntax: SyntaxNode,\n@@ -23,6 +25,7 @@ impl NameRef {\n     pub fn super_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![super]) }\n     pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Lifetime {\n     pub(crate) syntax: SyntaxNode,\n@@ -32,6 +35,7 @@ impl Lifetime {\n         support::token(&self.syntax, T![lifetime_ident])\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub(crate) syntax: SyntaxNode,\n@@ -41,6 +45,7 @@ impl Path {\n     pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n     pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathSegment {\n     pub(crate) syntax: SyntaxNode,\n@@ -56,6 +61,7 @@ impl PathSegment {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -66,6 +72,7 @@ impl GenericArgList {\n     pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -78,6 +85,7 @@ impl ParamList {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n     pub fn pipe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![|]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n     pub(crate) syntax: SyntaxNode,\n@@ -86,20 +94,23 @@ impl RetType {\n     pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathType {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeArg {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AssocTypeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -111,20 +122,23 @@ impl AssocTypeArg {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl LifetimeArg {\n     pub fn lifetime(&self) -> Option<Lifetime> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ConstArg {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -134,13 +148,15 @@ impl GenericParamList {\n     pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeBoundList {\n     pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n     pub(crate) syntax: SyntaxNode,\n@@ -152,6 +168,7 @@ impl MacroCall {\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n     pub(crate) syntax: SyntaxNode,\n@@ -163,6 +180,7 @@ impl Attr {\n     pub fn meta(&self) -> Option<Meta> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n     pub(crate) syntax: SyntaxNode,\n@@ -175,12 +193,14 @@ impl TokenTree {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroItems {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasModuleItem for MacroItems {}\n impl MacroItems {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroStmts {\n     pub(crate) syntax: SyntaxNode,\n@@ -189,6 +209,7 @@ impl MacroStmts {\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n     pub(crate) syntax: SyntaxNode,\n@@ -198,6 +219,7 @@ impl ast::HasModuleItem for SourceFile {}\n impl SourceFile {\n     pub fn shebang_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![shebang]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Const {\n     pub(crate) syntax: SyntaxNode,\n@@ -215,6 +237,7 @@ impl Const {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Enum {\n     pub(crate) syntax: SyntaxNode,\n@@ -227,6 +250,7 @@ impl Enum {\n     pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n     pub fn variant_list(&self) -> Option<VariantList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n     pub(crate) syntax: SyntaxNode,\n@@ -236,6 +260,7 @@ impl ExternBlock {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n     pub fn extern_item_list(&self) -> Option<ExternItemList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrate {\n     pub(crate) syntax: SyntaxNode,\n@@ -249,6 +274,7 @@ impl ExternCrate {\n     pub fn rename(&self) -> Option<Rename> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Fn {\n     pub(crate) syntax: SyntaxNode,\n@@ -269,6 +295,7 @@ impl Fn {\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Impl {\n     pub(crate) syntax: SyntaxNode,\n@@ -285,6 +312,7 @@ impl Impl {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroRules {\n     pub(crate) syntax: SyntaxNode,\n@@ -299,6 +327,7 @@ impl MacroRules {\n     pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -311,6 +340,7 @@ impl MacroDef {\n     pub fn args(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) syntax: SyntaxNode,\n@@ -323,6 +353,7 @@ impl Module {\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Static {\n     pub(crate) syntax: SyntaxNode,\n@@ -339,6 +370,7 @@ impl Static {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Struct {\n     pub(crate) syntax: SyntaxNode,\n@@ -352,6 +384,7 @@ impl Struct {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn field_list(&self) -> Option<FieldList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Trait {\n     pub(crate) syntax: SyntaxNode,\n@@ -367,6 +400,7 @@ impl Trait {\n     pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAlias {\n     pub(crate) syntax: SyntaxNode,\n@@ -383,6 +417,7 @@ impl TypeAlias {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Union {\n     pub(crate) syntax: SyntaxNode,\n@@ -395,6 +430,7 @@ impl Union {\n     pub fn union_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![union]) }\n     pub fn record_field_list(&self) -> Option<RecordFieldList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Use {\n     pub(crate) syntax: SyntaxNode,\n@@ -406,6 +442,7 @@ impl Use {\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n     pub(crate) syntax: SyntaxNode,\n@@ -417,6 +454,7 @@ impl Visibility {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -427,6 +465,7 @@ impl ItemList {\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Rename {\n     pub(crate) syntax: SyntaxNode,\n@@ -436,6 +475,7 @@ impl Rename {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTree {\n     pub(crate) syntax: SyntaxNode,\n@@ -447,6 +487,7 @@ impl UseTree {\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn rename(&self) -> Option<Rename> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n     pub(crate) syntax: SyntaxNode,\n@@ -456,13 +497,15 @@ impl UseTreeList {\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Abi {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Abi {\n     pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -471,6 +514,7 @@ impl WhereClause {\n     pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -484,6 +528,7 @@ impl BlockExpr {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn stmt_list(&self) -> Option<StmtList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -497,6 +542,7 @@ impl SelfParam {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n     pub(crate) syntax: SyntaxNode,\n@@ -508,6 +554,7 @@ impl Param {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -517,6 +564,7 @@ impl RecordFieldList {\n     pub fn fields(&self) -> AstChildren<RecordField> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -526,6 +574,7 @@ impl TupleFieldList {\n     pub fn fields(&self) -> AstChildren<TupleField> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n     pub(crate) syntax: SyntaxNode,\n@@ -537,6 +586,7 @@ impl RecordField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleField {\n     pub(crate) syntax: SyntaxNode,\n@@ -546,6 +596,7 @@ impl ast::HasVisibility for TupleField {}\n impl TupleField {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct VariantList {\n     pub(crate) syntax: SyntaxNode,\n@@ -555,6 +606,7 @@ impl VariantList {\n     pub fn variants(&self) -> AstChildren<Variant> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Variant {\n     pub(crate) syntax: SyntaxNode,\n@@ -567,6 +619,7 @@ impl Variant {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AssocItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -577,6 +630,7 @@ impl AssocItemList {\n     pub fn assoc_items(&self) -> AstChildren<AssocItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -587,6 +641,7 @@ impl ExternItemList {\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -600,6 +655,7 @@ impl ConstParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -609,6 +665,7 @@ impl ast::HasTypeBounds for LifetimeParam {}\n impl LifetimeParam {\n     pub fn lifetime(&self) -> Option<Lifetime> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -620,6 +677,7 @@ impl TypeParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_type(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n     pub(crate) syntax: SyntaxNode,\n@@ -631,6 +689,7 @@ impl WherePred {\n     pub fn lifetime(&self) -> Option<Lifetime> { support::child(&self.syntax) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Meta {\n     pub(crate) syntax: SyntaxNode,\n@@ -641,6 +700,7 @@ impl Meta {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -649,6 +709,7 @@ impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -663,6 +724,7 @@ impl LetStmt {\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -675,6 +737,7 @@ impl ArrayExpr {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AwaitExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -685,12 +748,14 @@ impl AwaitExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasAttrs for BinExpr {}\n impl BinExpr {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -700,6 +765,7 @@ impl BoxExpr {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -710,6 +776,7 @@ impl BreakExpr {\n     pub fn lifetime(&self) -> Option<Lifetime> { support::child(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -719,6 +786,7 @@ impl ast::HasArgList for CallExpr {}\n impl CallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CastExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -729,6 +797,7 @@ impl CastExpr {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ClosureExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -742,6 +811,7 @@ impl ClosureExpr {\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ContinueExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -753,6 +823,7 @@ impl ContinueExpr {\n     }\n     pub fn lifetime(&self) -> Option<Lifetime> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -763,6 +834,7 @@ impl FieldExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -775,6 +847,7 @@ impl ForExpr {\n     pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IfExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -785,6 +858,7 @@ impl IfExpr {\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n     pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IndexExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -794,12 +868,14 @@ impl IndexExpr {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Literal {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasAttrs for Literal {}\n impl Literal {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LoopExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -809,6 +885,7 @@ impl ast::HasLoopBody for LoopExpr {}\n impl LoopExpr {\n     pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -819,6 +896,7 @@ impl MatchExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MethodCallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -831,6 +909,7 @@ impl MethodCallExpr {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn generic_arg_list(&self) -> Option<GenericArgList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -841,6 +920,7 @@ impl ParenExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -849,6 +929,7 @@ impl ast::HasAttrs for PathExpr {}\n impl PathExpr {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PrefixExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -857,12 +938,14 @@ impl ast::HasAttrs for PrefixExpr {}\n impl PrefixExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangeExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasAttrs for RangeExpr {}\n impl RangeExpr {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -873,6 +956,7 @@ impl RecordExpr {\n         support::child(&self.syntax)\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -885,6 +969,7 @@ impl RefExpr {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReturnExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -894,6 +979,7 @@ impl ReturnExpr {\n     pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -903,6 +989,7 @@ impl TryExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -913,6 +1000,7 @@ impl TupleExpr {\n     pub fn fields(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhileExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -923,6 +1011,7 @@ impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct YieldExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -932,6 +1021,7 @@ impl YieldExpr {\n     pub fn yield_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![yield]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StmtList {\n     pub(crate) syntax: SyntaxNode,\n@@ -943,6 +1033,7 @@ impl StmtList {\n     pub fn tail_expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Label {\n     pub(crate) syntax: SyntaxNode,\n@@ -951,6 +1042,7 @@ impl Label {\n     pub fn lifetime(&self) -> Option<Lifetime> { support::child(&self.syntax) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordExprFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -963,6 +1055,7 @@ impl RecordExprFieldList {\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordExprField {\n     pub(crate) syntax: SyntaxNode,\n@@ -973,6 +1066,7 @@ impl RecordExprField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -982,6 +1076,7 @@ impl ArgList {\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n@@ -992,6 +1087,7 @@ impl Condition {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1002,6 +1098,7 @@ impl MatchArmList {\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n     pub(crate) syntax: SyntaxNode,\n@@ -1014,6 +1111,7 @@ impl MatchArm {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchGuard {\n     pub(crate) syntax: SyntaxNode,\n@@ -1025,6 +1123,7 @@ impl MatchGuard {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1036,6 +1135,7 @@ impl ArrayType {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1044,6 +1144,7 @@ impl DynTraitType {\n     pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n     pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPtrType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1057,6 +1158,7 @@ impl FnPtrType {\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1066,6 +1168,7 @@ impl ForType {\n     pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1074,27 +1177,31 @@ impl ImplTraitType {\n     pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n     pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct InferType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl InferType {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl MacroType {\n     pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl NeverType {\n     pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1104,6 +1211,7 @@ impl ParenType {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PtrType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1114,6 +1222,7 @@ impl PtrType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1124,6 +1233,7 @@ impl RefType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1133,6 +1243,7 @@ impl SliceType {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n     pub(crate) syntax: SyntaxNode,\n@@ -1142,6 +1253,7 @@ impl TupleType {\n     pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n     pub(crate) syntax: SyntaxNode,\n@@ -1151,6 +1263,7 @@ impl TypeBound {\n     pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IdentPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1163,6 +1276,7 @@ impl IdentPat {\n     pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1171,34 +1285,39 @@ impl BoxPat {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RestPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl RestPat {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl LiteralPat {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl MacroPat {\n     pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct OrPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl OrPat {\n     pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1208,25 +1327,29 @@ impl ParenPat {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WildcardPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl WildcardPat {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl RangePat {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1237,6 +1360,7 @@ impl RecordPat {\n         support::child(&self.syntax)\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1246,6 +1370,7 @@ impl RefPat {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SlicePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1255,6 +1380,7 @@ impl SlicePat {\n     pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1264,6 +1390,7 @@ impl TuplePat {\n     pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleStructPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1274,6 +1401,7 @@ impl TupleStructPat {\n     pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstBlockPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1282,6 +1410,7 @@ impl ConstBlockPat {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPatFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1292,6 +1421,7 @@ impl RecordPatFieldList {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPatField {\n     pub(crate) syntax: SyntaxNode,\n@@ -1302,13 +1432,15 @@ impl RecordPatField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericArg {\n     TypeArg(TypeArg),\n     AssocTypeArg(AssocTypeArg),\n     LifetimeArg(LifetimeArg),\n     ConstArg(ConstArg),\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Type {\n     ArrayType(ArrayType),\n@@ -1326,6 +1458,7 @@ pub enum Type {\n     SliceType(SliceType),\n     TupleType(TupleType),\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Expr {\n     ArrayExpr(ArrayExpr),\n@@ -1360,6 +1493,7 @@ pub enum Expr {\n     WhileExpr(WhileExpr),\n     YieldExpr(YieldExpr),\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Item {\n     Const(Const),\n@@ -1380,12 +1514,14 @@ pub enum Item {\n     Use(Use),\n }\n impl ast::HasAttrs for Item {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Stmt {\n     ExprStmt(ExprStmt),\n     Item(Item),\n     LetStmt(LetStmt),\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n     IdentPat(IdentPat),\n@@ -1405,11 +1541,13 @@ pub enum Pat {\n     TupleStructPat(TupleStructPat),\n     ConstBlockPat(ConstBlockPat),\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum FieldList {\n     RecordFieldList(RecordFieldList),\n     TupleFieldList(TupleFieldList),\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Adt {\n     Enum(Enum),\n@@ -1420,6 +1558,7 @@ impl ast::HasAttrs for Adt {}\n impl ast::HasGenericParams for Adt {}\n impl ast::HasName for Adt {}\n impl ast::HasVisibility for Adt {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n     Const(Const),\n@@ -1428,6 +1567,7 @@ pub enum AssocItem {\n     TypeAlias(TypeAlias),\n }\n impl ast::HasAttrs for AssocItem {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ExternItem {\n     Fn(Fn),\n@@ -1436,48 +1576,57 @@ pub enum ExternItem {\n     TypeAlias(TypeAlias),\n }\n impl ast::HasAttrs for ExternItem {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n     ConstParam(ConstParam),\n     LifetimeParam(LifetimeParam),\n     TypeParam(TypeParam),\n }\n impl ast::HasAttrs for GenericParam {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasArgList {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasArgList for AnyHasArgList {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasAttrs {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasAttrs for AnyHasAttrs {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasGenericParams {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasGenericParams for AnyHasGenericParams {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasLoopBody {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasLoopBody for AnyHasLoopBody {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasModuleItem {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasModuleItem for AnyHasModuleItem {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasName {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasName for AnyHasName {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasTypeBounds {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::HasTypeBounds for AnyHasTypeBounds {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AnyHasVisibility {\n     pub(crate) syntax: SyntaxNode,"}, {"sha": "c9f3c2cb8e113e8c3e39c7a236d89e8be14324d0", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/745fd9903c804a6810cd3a1e050116f2c3575ac0/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/745fd9903c804a6810cd3a1e050116f2c3575ac0/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=745fd9903c804a6810cd3a1e050116f2c3575ac0", "patch": "@@ -318,7 +318,8 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n         }\n     }\n \n-    sourcegen::add_preamble(\"sourcegen_ast\", sourcegen::reformat(res))\n+    let res = sourcegen::add_preamble(\"sourcegen_ast\", sourcegen::reformat(res));\n+    res.replace(\"#[derive\", \"\\n#[derive\")\n }\n \n fn write_doc_comment(contents: &[String], dest: &mut String) {"}]}