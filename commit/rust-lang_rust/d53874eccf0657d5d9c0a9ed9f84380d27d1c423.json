{"sha": "d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1Mzg3NGVjY2YwNjU3ZDVkOWMwYTllZDlmODQzODBkMjdkMWM0MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-02T01:22:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-02T01:22:20Z"}, "message": "auto merge of #17381 : tbu-/rust/pr_mapinplace2, r=aturon\n\nAdditionally, support zero-sized types.\r\n\r\nNow there isn't a safe interface of `PartialVec` anymore, it's just a bare data structure with destructor that assumes you handled everything correctly before.", "tree": {"sha": "082971a76ae87a4f45be9f63dfe1777520d6aacb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/082971a76ae87a4f45be9f63dfe1777520d6aacb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "html_url": "https://github.com/rust-lang/rust/commit/d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d53874eccf0657d5d9c0a9ed9f84380d27d1c423/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a70a0374e24c146e714b0beb4437e571a488be4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a70a0374e24c146e714b0beb4437e571a488be4f", "html_url": "https://github.com/rust-lang/rust/commit/a70a0374e24c146e714b0beb4437e571a488be4f"}, {"sha": "454d91d3d23d9c2d6d8b9a404aa43e234b76bf74", "url": "https://api.github.com/repos/rust-lang/rust/commits/454d91d3d23d9c2d6d8b9a404aa43e234b76bf74", "html_url": "https://github.com/rust-lang/rust/commit/454d91d3d23d9c2d6d8b9a404aa43e234b76bf74"}], "stats": {"total": 430, "additions": 222, "deletions": 208}, "files": [{"sha": "280fbdeffa23dfc2644904162a856dc33e318b56", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 222, "deletions": 208, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/d53874eccf0657d5d9c0a9ed9f84380d27d1c423/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53874eccf0657d5d9c0a9ed9f84380d27d1c423/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "patch": "@@ -18,6 +18,7 @@ use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n+use core::kinds::marker::InvariantType;\n use core::mem;\n use core::num;\n use core::ops;\n@@ -1818,56 +1819,15 @@ pub mod raw {\n     }\n }\n \n-/// An owned, partially type-converted vector.\n+/// An owned, partially type-converted vector of elements with non-zero size.\n ///\n-/// This struct takes two type parameters `T` and `U` which must be of the\n-/// same, non-zero size having the same minimal alignment.\n+/// `T` and `U` must have the same, non-zero size. They must also have the same\n+/// alignment.\n ///\n-/// No allocations are performed by usage, only a deallocation happens in the\n-/// destructor which should only run when unwinding.\n-///\n-/// It can be used to convert a vector of `T`s into a vector of `U`s, by\n-/// converting the individual elements one-by-one.\n-///\n-/// You may call the `push` method as often as you get a `Some(t)` from `pop`.\n-/// After pushing the same number of `U`s as you got `T`s, you can `unwrap` the\n-/// vector.\n-///\n-/// # Example\n-///\n-/// ```ignore\n-/// let pv = PartialVec::from_vec(vec![0u32, 1]);\n-/// assert_eq!(pv.pop(), Some(0));\n-/// assert_eq!(pv.pop(), Some(1));\n-/// assert_eq!(pv.pop(), None);\n-/// pv.push(2u32);\n-/// pv.push(3);\n-/// assert_eq!(pv.into_vec().as_slice(), &[2, 3]);\n-/// ```\n-//\n-// Upheld invariants:\n-//\n-// (a) `vec` isn't modified except when the `PartialVec` goes out of scope, the\n-//     only thing it is used for is keeping the memory which the `PartialVec`\n-//     uses for the inplace conversion.\n-//\n-// (b) `start_u` points to the start of the vector.\n-//\n-// (c) `end_u` points to one element beyond the vector.\n-//\n-// (d) `start_u` <= `end_u` <= `start_t` <= `end_t`.\n-//\n-// (e) From `start_u` (incl.) to `end_u` (excl.) there are sequential instances\n-//     of type `U`.\n-//\n-// (f) From `start_t` (incl.) to `end_t` (excl.) there are sequential instances\n-//     of type `T`.\n-//\n-// (g) The size of `T` and `U` is equal and non-zero.\n-//\n-// (h) The `min_align_of` of `T` and `U` is equal.\n-\n-struct PartialVec<T,U> {\n+/// When the destructor of this struct runs, all `U`s from `start_u` (incl.) to\n+/// `end_u` (excl.) and all `T`s from `start_t` (incl.) to `end_t` (excl.) are\n+/// destructed. Additionally the underlying storage of `vec` will be freed.\n+struct PartialVecNonZeroSized<T,U> {\n     vec: Vec<T>,\n \n     start_u: *mut U,\n@@ -1876,166 +1836,34 @@ struct PartialVec<T,U> {\n     end_t: *mut T,\n }\n \n-impl<T,U> PartialVec<T,U> {\n-    /// Creates a `PartialVec` from a `Vec`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `T` and `U` have differing sizes, are zero-sized or have\n-    /// differing minimal alignments.\n-    fn from_vec(mut vec: Vec<T>) -> PartialVec<T,U> {\n-        // FIXME: Assert statically that the types `T` and `U` have the same\n-        // size.\n-        //\n-        // These asserts make sure (g) and (h) are satisfied.\n-        assert!(mem::size_of::<T>() != 0);\n-        assert!(mem::size_of::<U>() != 0);\n-        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n-        assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n-\n-        let start = vec.as_mut_ptr();\n-\n-        // This `as int` cast is safe, because the size of the elements of the\n-        // vector is not 0, and:\n-        //\n-        // 1) If the size of the elements in the vector is 1, the `int` may\n-        //    overflow, but it has the correct bit pattern so that the\n-        //    `.offset()` function will work.\n-        //\n-        //    Example:\n-        //        Address space 0x0-0xF.\n-        //        `u8` array at: 0x1.\n-        //        Size of `u8` array: 0x8.\n-        //        Calculated `offset`: -0x8.\n-        //        After `array.offset(offset)`: 0x9.\n-        //        (0x1 + 0x8 = 0x1 - 0x8)\n-        //\n-        // 2) If the size of the elements in the vector is >1, the `uint` ->\n-        //    `int` conversion can't overflow.\n-        let offset = vec.len() as int;\n-\n-        let start_u = start as *mut U;\n-        let end_u = start as *mut U;\n-        let start_t = start;\n-\n-        // This points inside the vector, as the vector has length `offset`.\n-        let end_t = unsafe { start_t.offset(offset) };\n-\n-        // (b) is satisfied, `start_u` points to the start of `vec`.\n-        //\n-        // (c) is also satisfied, `end_t` points to the end of `vec`.\n-        //\n-        // `start_u == end_u == start_t <= end_t`, so also `start_u <= end_u <=\n-        // start_t <= end_t`, thus (b).\n-        //\n-        // As `start_u == end_u`, it is represented correctly that there are no\n-        // instances of `U` in `vec`, thus (e) is satisfied.\n-        //\n-        // At start, there are only elements of type `T` in `vec`, so (f) is\n-        // satisfied, as `start_t` points to the start of `vec` and `end_t` to\n-        // the end of it.\n-\n-        PartialVec {\n-            // (a) is satisfied, `vec` isn't modified in the function.\n-            vec: vec,\n-            start_u: start_u,\n-            end_u: end_u,\n-            start_t: start_t,\n-            end_t: end_t,\n-        }\n-    }\n-\n-    /// Pops a `T` from the `PartialVec`.\n-    ///\n-    /// Removes the next `T` from the vector and returns it as `Some(T)`, or\n-    /// `None` if there are none left.\n-    fn pop(&mut self) -> Option<T> {\n-        // The `if` ensures that there are more `T`s in `vec`.\n-        if self.start_t < self.end_t {\n-            let result;\n-            unsafe {\n-                // (f) is satisfied before, so in this if branch there actually\n-                // is a `T` at `start_t`.  After shifting the pointer by one,\n-                // (f) is again satisfied.\n-                result = ptr::read(self.start_t as *const T);\n-                self.start_t = self.start_t.offset(1);\n-            }\n-            Some(result)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Pushes a new `U` to the `PartialVec`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if not enough `T`s were popped to have enough space for the new\n-    /// `U`.\n-    fn push(&mut self, value: U) {\n-        // The assert assures that still `end_u <= start_t` (d) after\n-        // the function.\n-        assert!(self.end_u as *const () < self.start_t as *const (),\n-            \"writing more elements to PartialVec than reading from it\")\n-        unsafe {\n-            // (e) is satisfied before, and after writing one `U`\n-            // to `end_u` and shifting it by one, it's again\n-            // satisfied.\n-            ptr::write(self.end_u, value);\n-            self.end_u = self.end_u.offset(1);\n-        }\n-    }\n-\n-    /// Unwraps the new `Vec` of `U`s after having pushed enough `U`s and\n-    /// popped all `T`s.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if not all `T`s were popped, also fails if not the same amount of\n-    /// `U`s was pushed before calling `unwrap`.\n-    fn into_vec(mut self) -> Vec<U> {\n-        // If `self.end_u == self.end_t`, we know from (e) that there are no\n-        // more `T`s in `vec`, we also know that the whole length of `vec` is\n-        // now used by `U`s, thus we can just interpret `vec` as a vector of\n-        // `U` safely.\n-\n-        assert!(self.end_u as *const () == self.end_t as *const (),\n-            \"trying to unwrap a PartialVec before completing the writes to it\");\n-\n-        // Extract `vec` and prevent the destructor of `PartialVec` from\n-        // running. Note that none of the function calls can fail, thus no\n-        // resources can be leaked (as the `vec` member of `PartialVec` is the\n-        // only one which holds allocations -- and it is returned from this\n-        // function.\n-        unsafe {\n-            let vec_len = self.vec.len();\n-            let vec_cap = self.vec.capacity();\n-            let vec_ptr = self.vec.as_mut_ptr() as *mut U;\n-            mem::forget(self);\n-            Vec::from_raw_parts(vec_len, vec_cap, vec_ptr)\n-        }\n-    }\n+/// An owned, partially type-converted vector of zero-sized elements.\n+///\n+/// When the destructor of this struct runs, all `num_t` `T`s and `num_u` `U`s\n+/// are destructed.\n+struct PartialVecZeroSized<T,U> {\n+    num_t: uint,\n+    num_u: uint,\n+    marker_t: InvariantType<T>,\n+    marker_u: InvariantType<U>,\n }\n \n #[unsafe_destructor]\n-impl<T,U> Drop for PartialVec<T,U> {\n+impl<T,U> Drop for PartialVecNonZeroSized<T,U> {\n     fn drop(&mut self) {\n         unsafe {\n-            // As per (a) `vec` hasn't been modified until now. As it has a\n-            // length currently, this would run destructors of `T`s which might\n-            // not be there. So at first, set `vec`s length to `0`. This must\n-            // be done at first to remain memory-safe as the destructors of `U`\n-            // or `T` might cause unwinding where `vec`s destructor would be\n-            // executed.\n+            // `vec` hasn't been modified until now. As it has a length\n+            // currently, this would run destructors of `T`s which might not be\n+            // there. So at first, set `vec`s length to `0`. This must be done\n+            // at first to remain memory-safe as the destructors of `U` or `T`\n+            // might cause unwinding where `vec`s destructor would be executed.\n             self.vec.set_len(0);\n \n-            // As per (e) and (f) we have instances of `U`s and `T`s in `vec`.\n-            // Destruct them.\n-            while self.start_u < self.end_u {\n+            // We have instances of `U`s and `T`s in `vec`. Destruct them.\n+            while self.start_u != self.end_u {\n                 let _ = ptr::read(self.start_u as *const U); // Run a `U` destructor.\n                 self.start_u = self.start_u.offset(1);\n             }\n-            while self.start_t < self.end_t {\n+            while self.start_t != self.end_t {\n                 let _ = ptr::read(self.start_t as *const T); // Run a `T` destructor.\n                 self.start_t = self.start_t.offset(1);\n             }\n@@ -2045,14 +1873,31 @@ impl<T,U> Drop for PartialVec<T,U> {\n     }\n }\n \n+#[unsafe_destructor]\n+impl<T,U> Drop for PartialVecZeroSized<T,U> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Destruct the instances of `T` and `U` this struct owns.\n+            while self.num_t != 0 {\n+                let _: T = mem::uninitialized(); // Run a `T` destructor.\n+                self.num_t -= 1;\n+            }\n+            while self.num_u != 0 {\n+                let _: U = mem::uninitialized(); // Run a `U` destructor.\n+                self.num_u -= 1;\n+            }\n+        }\n+    }\n+}\n+\n impl<T> Vec<T> {\n     /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n-    /// non-zero size and the same minimal alignment.\n+    /// size and in case they are not zero-sized the same minimal alignment.\n     ///\n     /// # Failure\n     ///\n-    /// Fails if `T` and `U` have differing sizes, are zero-sized or have\n-    /// differing minimal alignments.\n+    /// Fails if `T` and `U` have differing sizes or are not zero-sized and\n+    /// have differing minimal alignments.\n     ///\n     /// # Example\n     ///\n@@ -2068,13 +1913,174 @@ impl<T> Vec<T> {\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n     pub fn map_in_place<U>(self, f: |T| -> U) -> Vec<U> {\n-        let mut pv = PartialVec::from_vec(self);\n-        loop {\n-            let maybe_t = pv.pop();\n-            match maybe_t {\n-                Some(t) => pv.push(f(t)),\n-                None => return pv.into_vec(),\n+        // FIXME: Assert statically that the types `T` and `U` have the same\n+        // size.\n+        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n+\n+        let mut vec = self;\n+\n+        if mem::size_of::<T>() != 0 {\n+            // FIXME: Assert statically that the types `T` and `U` have the\n+            // same minimal alignment in case they are not zero-sized.\n+\n+            // These asserts are necessary because the `min_align_of` of the\n+            // types are passed to the allocator by `Vec`.\n+            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+\n+            // This `as int` cast is safe, because the size of the elements of the\n+            // vector is not 0, and:\n+            //\n+            // 1) If the size of the elements in the vector is 1, the `int` may\n+            //    overflow, but it has the correct bit pattern so that the\n+            //    `.offset()` function will work.\n+            //\n+            //    Example:\n+            //        Address space 0x0-0xF.\n+            //        `u8` array at: 0x1.\n+            //        Size of `u8` array: 0x8.\n+            //        Calculated `offset`: -0x8.\n+            //        After `array.offset(offset)`: 0x9.\n+            //        (0x1 + 0x8 = 0x1 - 0x8)\n+            //\n+            // 2) If the size of the elements in the vector is >1, the `uint` ->\n+            //    `int` conversion can't overflow.\n+            let offset = vec.len() as int;\n+            let start = vec.as_mut_ptr();\n+\n+            let mut pv = PartialVecNonZeroSized {\n+                vec: vec,\n+\n+                start_t: start,\n+                // This points inside the vector, as the vector has length\n+                // `offset`.\n+                end_t: unsafe { start.offset(offset) },\n+                start_u: start as *mut U,\n+                end_u: start as *mut U,\n+            };\n+            //  start_t\n+            //  start_u\n+            //  |\n+            // +-+-+-+-+-+-+\n+            // |T|T|T|...|T|\n+            // +-+-+-+-+-+-+\n+            //  |           |\n+            //  end_u       end_t\n+\n+            while pv.end_u as *mut T != pv.end_t {\n+                unsafe {\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|T|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+\n+                    let t = ptr::read(pv.start_t as *const T);\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We must not fail here, one cell is marked as `T`\n+                    // although it is not `T`.\n+\n+                    pv.start_t = pv.start_t.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We may fail again.\n+\n+                    // The function given by the user might fail.\n+                    let u = f(t);\n+\n+                    ptr::write(pv.end_u, u);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We should not fail here, because that would leak the `U`\n+                    // pointed to by `end_u`.\n+\n+                    pv.end_u = pv.end_u.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //            |       |\n+                    //            end_u   end_t\n+                    // We may fail again.\n+                }\n+            }\n+\n+            //  start_u     start_t\n+            //  |           |\n+            // +-+-+-+-+-+-+\n+            // |U|...|U|U|U|\n+            // +-+-+-+-+-+-+\n+            //              |\n+            //              end_t\n+            //              end_u\n+            // Extract `vec` and prevent the destructor of\n+            // `PartialVecNonZeroSized` from running. Note that none of the\n+            // function calls can fail, thus no resources can be leaked (as the\n+            // `vec` member of `PartialVec` is the only one which holds\n+            // allocations -- and it is returned from this function. None of\n+            // this can fail.\n+            unsafe {\n+                let vec_len = pv.vec.len();\n+                let vec_cap = pv.vec.capacity();\n+                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n+                mem::forget(pv);\n+                Vec::from_raw_parts(vec_len, vec_cap, vec_ptr)\n+            }\n+        } else {\n+            // Put the `Vec` into the `PartialVecZeroSized` structure and\n+            // prevent the destructor of the `Vec` from running. Since the\n+            // `Vec` contained zero-sized objects, it did not allocate, so we\n+            // are not leaking memory here.\n+            let mut pv = PartialVecZeroSized::<T,U> {\n+                num_t: vec.len(),\n+                num_u: 0,\n+                marker_t: InvariantType,\n+                marker_u: InvariantType,\n             };\n+            unsafe { mem::forget(vec); }\n+\n+            while pv.num_t != 0 {\n+                unsafe {\n+                    // Create a `T` out of thin air and decrement `num_t`. This\n+                    // must not fail between these steps, as otherwise a\n+                    // destructor of `T` which doesn't exist runs.\n+                    let t = mem::uninitialized();\n+                    pv.num_t -= 1;\n+\n+                    // The function given by the user might fail.\n+                    let u = f(t);\n+\n+                    // Forget the `U` and increment `num_u`. This increment\n+                    // cannot overflow the `uint` as we only do this for a\n+                    // number of times that fits into a `uint` (and start with\n+                    // `0`). Again, we should not fail between these steps.\n+                    mem::forget(u);\n+                    pv.num_u += 1;\n+                }\n+            }\n+            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n+            // destructor of the latter will not run. None of this can fail.\n+            let mut result = Vec::new();\n+            unsafe { result.set_len(pv.num_u); }\n+            result\n         }\n     }\n }\n@@ -2448,7 +2454,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_map_inp_lace_incompatible_types_fail() {\n+    fn test_map_in_place_incompatible_types_fail() {\n         let v = vec![0u, 1, 2];\n         v.map_in_place(|_| ());\n     }\n@@ -2459,6 +2465,14 @@ mod tests {\n         assert_eq!(v.map_in_place(|i: uint| i as int - 1).as_slice(), [-1i, 0, 1].as_slice());\n     }\n \n+    #[test]\n+    fn test_map_in_place_zero_sized() {\n+        let v = vec![(), ()];\n+        #[deriving(PartialEq, Show)]\n+        struct ZeroSized;\n+        assert_eq!(v.map_in_place(|_| ZeroSized).as_slice(), [ZeroSized, ZeroSized].as_slice());\n+    }\n+\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {"}]}