{"sha": "9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNWE1MzBiODRjNzVlMzRjMTgzZWVhNTBjZTlhNWQ3ZmNmNjU4MWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-20T11:06:48Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-24T17:54:16Z"}, "message": "rustc_metadata: Minimize use of `Lrc` in crate store\n\nCrate metadatas are still stored as `Lrc<CrateMetadata>` in `CStore` because crate store has to be cloneable due to `Resolver::clone_outputs`.", "tree": {"sha": "59f69eb8cbf17cfa30004f4717234e7fc3b222ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f69eb8cbf17cfa30004f4717234e7fc3b222ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "html_url": "https://github.com/rust-lang/rust/commit/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5fee33e7aa71d7cfc5abd8848a81924cafd2b15", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5fee33e7aa71d7cfc5abd8848a81924cafd2b15", "html_url": "https://github.com/rust-lang/rust/commit/c5fee33e7aa71d7cfc5abd8848a81924cafd2b15"}], "stats": {"total": 88, "additions": 41, "deletions": 47}, "files": [{"sha": "d5558db2397e797cd14f4297ebc0bc1a07fa2eb1", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n-use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n+use rustc_data_structures::sync::{self, MetadataRef};\n use rustc_macros::HashStable;\n \n pub use self::NativeLibraryKind::*;\n@@ -203,13 +203,13 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any>;\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable>;\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;"}, {"sha": "f99298281fecc5e5b7e203d5827ca148e955a4e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "patch": "@@ -1213,34 +1213,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let dep_graph = hir.dep_graph.clone();\n         let cstore = resolutions.cstore;\n-        let max_cnum = cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let crates = cstore.crates_untracked();\n+        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let upstream_def_path_tables: Vec<(CrateNum, Lrc<_>)> = cstore\n-                .crates_untracked()\n+            let def_path_tables = crates\n                 .iter()\n                 .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                .collect();\n-\n-            let def_path_tables = || {\n-                upstream_def_path_tables\n-                    .iter()\n-                    .map(|&(cnum, ref rc)| (cnum, &**rc))\n-                    .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())))\n-            };\n+                .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())));\n \n             // Precompute the capacity of the hashmap so we don't have to\n             // re-allocate when populating it.\n-            let capacity = def_path_tables().map(|(_, t)| t.size()).sum::<usize>();\n+            let capacity = def_path_tables.clone().map(|(_, t)| t.size()).sum::<usize>();\n \n             let mut map: FxHashMap<_, _> = FxHashMap::with_capacity_and_hasher(\n                 capacity,\n                 ::std::default::Default::default()\n             );\n \n-            for (cnum, def_path_table) in def_path_tables() {\n+            for (cnum, def_path_table) in def_path_tables {\n                 def_path_table.add_def_path_hashes_to(cnum, &mut map);\n             }\n \n@@ -1417,8 +1410,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n-        self.cstore.crate_data_as_rc_any(cnum)\n+    pub fn crate_data_as_any(self, cnum: CrateNum) -> &'tcx dyn Any {\n+        self.cstore.crate_data_as_any(cnum)\n     }\n \n     #[inline(always)]"}, {"sha": "f0a68058de8ca89e414d553f6669d509c1134bb5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "patch": "@@ -3,7 +3,7 @@\n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n+use rustc_data_structures::sync::{RwLock, Lock, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n@@ -186,7 +186,7 @@ impl<'a> CrateLoader<'a> {\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n@@ -240,9 +240,9 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let cmeta = cstore::CrateMetadata {\n+        self.cstore.set_crate_data(cnum, cstore::CrateMetadata {\n             extern_crate: Lock::new(None),\n-            def_path_table: Lrc::new(def_path_table),\n+            def_path_table,\n             trait_impls,\n             root: crate_root,\n             blob: metadata,\n@@ -256,11 +256,9 @@ impl<'a> CrateLoader<'a> {\n             private_dep,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-        };\n+        });\n \n-        let cmeta = Lrc::new(cmeta);\n-        self.cstore.set_crate_data(cnum, cmeta.clone());\n-        (cnum, cmeta)\n+        cnum\n     }\n \n     fn load_proc_macro<'b>(\n@@ -324,7 +322,7 @@ impl<'a> CrateLoader<'a> {\n         span: Span,\n         dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n \n@@ -334,7 +332,7 @@ impl<'a> CrateLoader<'a> {\n         span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n+    ) -> Result<CrateNum, LoadError<'b>> {\n         info!(\"resolving crate `{}`\", name);\n         let (root, hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) =>\n@@ -380,7 +378,7 @@ impl<'a> CrateLoader<'a> {\n                 data.dep_kind.with_lock(|data_dep_kind| {\n                     *data_dep_kind = cmp::max(*data_dep_kind, dep_kind);\n                 });\n-                Ok((cnum, data))\n+                Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n                 Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n@@ -484,7 +482,7 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n         })).collect()\n     }\n \n@@ -581,7 +579,8 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -685,7 +684,8 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n+                let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None);\n+                let data = self.cstore.get_crate_data(cnum);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -705,7 +705,8 @@ impl<'a> CrateLoader<'a> {\n             info!(\"loading profiler\");\n \n             let name = Symbol::intern(\"profiler_builtins\");\n-            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n+            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -886,7 +887,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -907,7 +908,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -925,7 +926,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "6b06cf575edcf5557aeddaf70335f4f4e7e809de", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "patch": "@@ -54,7 +54,7 @@ crate struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    crate def_path_table: Lrc<DefPathTable>,\n+    crate def_path_table: DefPathTable,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n@@ -123,18 +123,18 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n-        self.metas[cnum].clone()\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n+        self.metas[cnum].as_ref()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    crate fn set_crate_data(&mut self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n+    crate fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n         assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n-        self.metas[cnum] = Some(data);\n+        self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n     crate fn iter_crate_data<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n+        where I: FnMut(CrateNum, &CrateMetadata)\n     {\n         for (k, v) in self.metas.iter_enumerated() {\n             if let &Some(ref v) = v {"}, {"sha": "d942a19194a1443d69a35a34a52daf3502f0c152", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5a530b84c75e34c183eea50ce9a5d7fcf6581b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9f5a530b84c75e34c183eea50ce9a5d7fcf6581b", "patch": "@@ -53,7 +53,7 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $tcx.crate_data_as_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n@@ -478,8 +478,8 @@ impl cstore::CStore {\n }\n \n impl CrateStore for cstore::CStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any> {\n-        self.get_crate_data(krate)\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any {\n+        self.get_crate_data(cnum)\n     }\n \n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n@@ -520,8 +520,8 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable> {\n-        self.get_crate_data(cnum).def_path_table.clone()\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n+        &self.get_crate_data(cnum).def_path_table\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum>"}]}