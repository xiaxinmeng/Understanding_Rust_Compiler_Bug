{"sha": "666ff8fd00b41b86547ed053605a46892cff78fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NmZmOGZkMDBiNDFiODY1NDdlZDA1MzYwNWE0Njg5MmNmZjc4ZmU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-02T08:32:54Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:41:28Z"}, "message": "reduce repetition in stmt parsing", "tree": {"sha": "a43d1aefd5f4ca6cd360ad78f24a870b40ce7273", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a43d1aefd5f4ca6cd360ad78f24a870b40ce7273"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/666ff8fd00b41b86547ed053605a46892cff78fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/666ff8fd00b41b86547ed053605a46892cff78fe", "html_url": "https://github.com/rust-lang/rust/commit/666ff8fd00b41b86547ed053605a46892cff78fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/666ff8fd00b41b86547ed053605a46892cff78fe/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a46509a4c2dc430ebebf940a26232fdaeeba81", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a46509a4c2dc430ebebf940a26232fdaeeba81", "html_url": "https://github.com/rust-lang/rust/commit/01a46509a4c2dc430ebebf940a26232fdaeeba81"}], "stats": {"total": 93, "additions": 37, "deletions": 56}, "files": [{"sha": "0863e037f22b182b02bcdd38cf636c3aa8d546a9", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/666ff8fd00b41b86547ed053605a46892cff78fe/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666ff8fd00b41b86547ed053605a46892cff78fe/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=666ff8fd00b41b86547ed053605a46892cff78fe", "patch": "@@ -44,33 +44,27 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n \n         Ok(Some(if self.eat_keyword(kw::Let) {\n-            Stmt {\n-                id: DUMMY_NODE_ID,\n-                kind: StmtKind::Local(self.parse_local(attrs.into())?),\n-                span: lo.to(self.prev_span),\n-            }\n+            let stmt = self.parse_local(attrs.into())?;\n+            self.mk_stmt(lo.to(self.prev_span), StmtKind::Local(stmt))\n         } else if let Some(macro_def) = self.eat_macro_def(\n             &attrs,\n             &respan(lo, VisibilityKind::Inherited),\n             lo,\n         )? {\n-            Stmt {\n-                id: DUMMY_NODE_ID,\n-                kind: StmtKind::Item(macro_def),\n-                span: lo.to(self.prev_span),\n-            }\n+            self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))\n         // Starts like a simple path, being careful to avoid contextual keywords\n         // such as a union items, item with `crate` visibility or auto trait items.\n         // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n         // like a path (1 token), but it fact not a path.\n         // `union::b::c` - path, `union U { ... }` - not a path.\n         // `crate::b::c` - path, `crate struct S;` - not a path.\n-        } else if self.token.is_path_start() &&\n-                  !self.token.is_qpath_start() &&\n-                  !self.is_union_item() &&\n-                  !self.is_crate_vis() &&\n-                  !self.is_auto_trait_item() &&\n-                  !self.is_async_fn() {\n+        } else if self.token.is_path_start()\n+            && !self.token.is_qpath_start()\n+            && !self.is_union_item()\n+            && !self.is_crate_vis()\n+            && !self.is_auto_trait_item()\n+            && !self.is_async_fn()\n+        {\n             let path = self.parse_path(PathStyle::Expr)?;\n \n             if !self.eat(&token::Not) {\n@@ -85,12 +79,7 @@ impl<'a> Parser<'a> {\n                     let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n                     this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n                 })?;\n-\n-                return Ok(Some(Stmt {\n-                    id: DUMMY_NODE_ID,\n-                    kind: StmtKind::Expr(expr),\n-                    span: lo.to(self.prev_span),\n-                }));\n+                return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr))));\n             }\n \n             let args = self.parse_mac_args()?;\n@@ -108,15 +97,19 @@ impl<'a> Parser<'a> {\n                 args,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            let kind = if delim == token::Brace ||\n-                          self.token == token::Semi || self.token == token::Eof {\n+\n+            let kind = if delim == token::Brace\n+                || self.token == token::Semi\n+                || self.token == token::Eof\n+            {\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n             }\n             // We used to incorrectly stop parsing macro-expanded statements here.\n             // If the next token will be an error anyway but could have parsed with the\n             // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-            else if macro_legacy_warnings && self.token.can_begin_expr() &&\n-                match self.token.kind {\n+            else if macro_legacy_warnings\n+                && self.token.can_begin_expr()\n+                && match self.token.kind {\n                     // These can continue an expression, so we can't stop parsing and warn.\n                     token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n                     token::BinOp(token::Minus) | token::BinOp(token::Star) |\n@@ -135,11 +128,7 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n                 StmtKind::Expr(e)\n             };\n-            Stmt {\n-                id: DUMMY_NODE_ID,\n-                span: lo.to(hi),\n-                kind,\n-            }\n+            self.mk_stmt(lo.to(hi), kind)\n         } else {\n             // FIXME: Bad copy of attrs\n             let old_directory_ownership =\n@@ -148,11 +137,7 @@ impl<'a> Parser<'a> {\n             self.directory.ownership = old_directory_ownership;\n \n             match item {\n-                Some(i) => Stmt {\n-                    id: DUMMY_NODE_ID,\n-                    span: lo.to(i.span),\n-                    kind: StmtKind::Item(i),\n-                },\n+                Some(i) => self.mk_stmt(lo.to(i.span), StmtKind::Item(i)),\n                 None => {\n                     let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n                         if !attrs.is_empty() {\n@@ -178,14 +163,12 @@ impl<'a> Parser<'a> {\n                         // We are encoding a string of semicolons as an\n                         // an empty tuple that spans the excess semicolons\n                         // to preserve this info until the lint stage\n-                        return Ok(Some(Stmt {\n-                            id: DUMMY_NODE_ID,\n-                            span: lo.to(last_semi),\n-                            kind: StmtKind::Semi(self.mk_expr(lo.to(last_semi),\n-                                ExprKind::Tup(Vec::new()),\n-                                ThinVec::new()\n-                            )),\n-                        }));\n+                        let kind = StmtKind::Semi(self.mk_expr(\n+                            lo.to(last_semi),\n+                            ExprKind::Tup(Vec::new()),\n+                            ThinVec::new()\n+                        ));\n+                        return Ok(Some(self.mk_stmt(lo.to(last_semi), kind)));\n                     }\n \n                     if self.token == token::CloseDelim(token::Brace) {\n@@ -194,13 +177,8 @@ impl<'a> Parser<'a> {\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(\n-                        Restrictions::STMT_EXPR, Some(attrs.into()))?;\n-                    Stmt {\n-                        id: DUMMY_NODE_ID,\n-                        span: lo.to(e.span),\n-                        kind: StmtKind::Expr(e),\n-                    }\n+                    let e = self.parse_expr_res( Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+                    self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n                 }\n             }\n         }))\n@@ -402,11 +380,10 @@ impl<'a> Parser<'a> {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n-                    Some(Stmt {\n-                        id: DUMMY_NODE_ID,\n-                        kind: StmtKind::Expr(self.mk_expr_err(self.token.span)),\n-                        span: self.token.span,\n-                    })\n+                    Some(self.mk_stmt(\n+                        self.token.span,\n+                        StmtKind::Expr(self.mk_expr_err(self.token.span)),\n+                    ))\n                 }\n                 Ok(stmt) => stmt,\n             };\n@@ -478,4 +455,8 @@ impl<'a> Parser<'a> {\n             \"this was erroneously allowed and will become a hard error in a future release\"\n         }).emit();\n     }\n+\n+    fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n+        Stmt { id: DUMMY_NODE_ID, kind, span }\n+    }\n }"}]}