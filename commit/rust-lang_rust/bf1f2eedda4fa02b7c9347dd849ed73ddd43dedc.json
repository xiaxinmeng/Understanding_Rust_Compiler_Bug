{"sha": "bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMWYyZWVkZGE0ZmEwMmI3YzkzNDdkZDg0OWVkNzNkZGQ0M2RlZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T00:56:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T00:56:00Z"}, "message": "Auto merge of #70865 - Dylan-DPC:rollup-jje2cuv, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70612 (Add io::Write::write_all_vectored)\n - #70690 (Clean up E0501 explanation)\n - #70821 (expose suggestions::InferCtxtExt for clippy)\n - #70839 (clean up E0506 explanation)\n - #70859 (Move sanitize-inline-always test to sanitize directory)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7d44f5c39ecc54b9da9bfc5a3f87c6b6a84eeb36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d44f5c39ecc54b9da9bfc5a3f87c6b6a84eeb36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "html_url": "https://github.com/rust-lang/rust/commit/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257", "html_url": "https://github.com/rust-lang/rust/commit/6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257"}, {"sha": "b9fe46d45b77870c82467c15a6df59899d2e22d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9fe46d45b77870c82467c15a6df59899d2e22d8", "html_url": "https://github.com/rust-lang/rust/commit/b9fe46d45b77870c82467c15a6df59899d2e22d8"}], "stats": {"total": 257, "additions": 210, "deletions": 47}, "files": [{"sha": "ffdbc443905ae44aa3f191add7c5b3335ae5adc0", "filename": "src/librustc_error_codes/error_codes/E0501.md", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md?ref=bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "patch": "@@ -1,12 +1,4 @@\n-This error indicates that a mutable variable is being used while it is still\n-captured by a closure. Because the closure has borrowed the variable, it is not\n-available for use until the closure goes out of scope.\n-\n-Note that a capture will either move or borrow a variable, but in this\n-situation, the closure is borrowing the variable. Take a look at the chapter\n-on [Capturing][capturing] in Rust By Example for more information.\n-\n-[capturing]: https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html\n+A mutable variable is used but it is already captured by a closure.\n \n Erroneous code example:\n \n@@ -29,6 +21,16 @@ fn foo(a: &mut i32) {\n }\n ```\n \n+This error indicates that a mutable variable is used while it is still captured\n+by a closure. Because the closure has borrowed the variable, it is not available\n+until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at the chapter\n+on [Capturing][capturing] in Rust By Example for more information.\n+\n+[capturing]: https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html\n+\n To fix this error, you can finish using the closure before using the captured\n variable:\n "}, {"sha": "c312a0460e3a13358982aef51ed28abeec9aa2fa", "filename": "src/librustc_error_codes/error_codes/E0506.md", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md?ref=bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "patch": "@@ -1,4 +1,4 @@\n-This error occurs when an attempt is made to assign to a borrowed value.\n+An attempt was made to assign to a borrowed value.\n \n Erroneous code example:\n \n@@ -7,14 +7,12 @@ struct FancyNum {\n     num: u8,\n }\n \n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-    // error: cannot assign to `fancy_num` because it is borrowed\n+let mut fancy_num = FancyNum { num: 5 };\n+let fancy_ref = &fancy_num;\n+fancy_num = FancyNum { num: 6 };\n+// error: cannot assign to `fancy_num` because it is borrowed\n \n-    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n-}\n+println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n ```\n \n Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n@@ -27,13 +25,11 @@ struct FancyNum {\n     num: u8,\n }\n \n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let moved_num = fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n+let mut fancy_num = FancyNum { num: 5 };\n+let moved_num = fancy_num;\n+fancy_num = FancyNum { num: 6 };\n \n-    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n-}\n+println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n ```\n \n If the value has to be borrowed, try limiting the lifetime of the borrow using\n@@ -44,18 +40,16 @@ struct FancyNum {\n     num: u8,\n }\n \n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"Ref: {}\", fancy_ref.num);\n-    }\n+let mut fancy_num = FancyNum { num: 5 };\n \n-    // Works because `fancy_ref` is no longer in scope\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n+{\n+    let fancy_ref = &fancy_num;\n+    println!(\"Ref: {}\", fancy_ref.num);\n }\n+\n+// Works because `fancy_ref` is no longer in scope\n+fancy_num = FancyNum { num: 6 };\n+println!(\"Num: {}\", fancy_num.num);\n ```\n \n Or by moving the reference into a function:\n@@ -65,17 +59,15 @@ struct FancyNum {\n     num: u8,\n }\n \n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    print_fancy_ref(&fancy_num);\n-\n-    // Works because function borrow has ended\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-\n fn print_fancy_ref(fancy_ref: &FancyNum){\n     println!(\"Ref: {}\", fancy_ref.num);\n }\n+\n+let mut fancy_num = FancyNum { num: 5 };\n+\n+print_fancy_ref(&fancy_num);\n+\n+// Works because function borrow has ended\n+fancy_num = FancyNum { num: 6 };\n+println!(\"Num: {}\", fancy_num.num);\n ```"}, {"sha": "a8fc56d8509a01d9b40b130ba77db403d70a18e5", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "patch": "@@ -22,7 +22,8 @@ use std::fmt;\n use super::InferCtxtPrivExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n-crate trait InferCtxtExt<'tcx> {\n+// This trait is public to expose the diagnostics methods to clippy.\n+pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "5ab88260d6ac1888fd3d9657da14094d60d2342a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 169, "deletions": 1, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "patch": "@@ -261,6 +261,7 @@\n \n use crate::cmp;\n use crate::fmt;\n+use crate::mem;\n use crate::memchr;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr;\n@@ -1376,6 +1377,70 @@ pub trait Write {\n         Ok(())\n     }\n \n+    /// Attempts to write multiple buffers into this writer.\n+    ///\n+    /// This method will continuously call [`write_vectored`] until there is no\n+    /// more data to be written or an error of non-[`ErrorKind::Interrupted`]\n+    /// kind is returned. This method will not return until all buffers have\n+    /// been successfully written or such an error occurs. The first error that\n+    /// is not of [`ErrorKind::Interrupted`] kind generated from this method\n+    /// will be returned.\n+    ///\n+    /// If the buffer contains no data, this will never call [`write_vectored`].\n+    ///\n+    /// [`write_vectored`]: #method.write_vectored\n+    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    ///\n+    /// # Notes\n+    ///\n+    ///\n+    /// Unlike `io::Write::write_vectored`, this takes a *mutable* reference to\n+    /// a slice of `IoSlice`s, not an immutable one. That's because we need to\n+    /// modify the slice to keep track of the bytes already written.\n+    ///\n+    /// Once this function returns, the contents of `bufs` are unspecified, as\n+    /// this depends on how many calls to `write_vectored` were necessary. It is\n+    /// best to understand this function as taking ownership of `bufs` and to\n+    /// not use `bufs` afterwards. The underlying buffers, to which the\n+    /// `IoSlice`s point (but not the `IoSlice`s themselves), are unchanged and\n+    /// can be reused.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(write_all_vectored)]\n+    /// # fn main() -> std::io::Result<()> {\n+    ///\n+    /// use std::io::{Write, IoSlice};\n+    ///\n+    /// let mut writer = Vec::new();\n+    /// let bufs = &mut [\n+    ///     IoSlice::new(&[1]),\n+    ///     IoSlice::new(&[2, 3]),\n+    ///     IoSlice::new(&[4, 5, 6]),\n+    /// ];\n+    ///\n+    /// writer.write_all_vectored(bufs)?;\n+    /// // Note: the contents of `bufs` is now undefined, see the Notes section.\n+    ///\n+    /// assert_eq!(writer, &[1, 2, 3, 4, 5, 6]);\n+    /// # Ok(()) }\n+    /// ```\n+    #[unstable(feature = \"write_all_vectored\", issue = \"70436\")]\n+    fn write_all_vectored(&mut self, mut bufs: &mut [IoSlice<'_>]) -> Result<()> {\n+        while !bufs.is_empty() {\n+            match self.write_vectored(bufs) {\n+                Ok(0) => {\n+                    return Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"));\n+                }\n+                Ok(n) => bufs = IoSlice::advance(mem::take(&mut bufs), n),\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///\n@@ -2423,7 +2488,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n #[cfg(test)]\n mod tests {\n     use super::{repeat, Cursor, SeekFrom};\n-    use crate::cmp;\n+    use crate::cmp::{self, min};\n     use crate::io::prelude::*;\n     use crate::io::{self, IoSlice, IoSliceMut};\n     use crate::ops::Deref;\n@@ -2812,4 +2877,107 @@ mod tests {\n         bufs = IoSlice::advance(bufs, 9);\n         assert!(bufs.is_empty());\n     }\n+\n+    /// Create a new writer that reads from at most `n_bufs` and reads\n+    /// `per_call` bytes (in total) per call to write.\n+    fn test_writer(n_bufs: usize, per_call: usize) -> TestWriter {\n+        TestWriter { n_bufs, per_call, written: Vec::new() }\n+    }\n+\n+    struct TestWriter {\n+        n_bufs: usize,\n+        per_call: usize,\n+        written: Vec<u8>,\n+    }\n+\n+    impl Write for TestWriter {\n+        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+            self.write_vectored(&[IoSlice::new(buf)])\n+        }\n+\n+        fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+            let mut left = self.per_call;\n+            let mut written = 0;\n+            for buf in bufs.iter().take(self.n_bufs) {\n+                let n = min(left, buf.len());\n+                self.written.extend_from_slice(&buf[0..n]);\n+                left -= n;\n+                written += n;\n+            }\n+            Ok(written)\n+        }\n+\n+        fn flush(&mut self) -> io::Result<()> {\n+            Ok(())\n+        }\n+    }\n+\n+    #[test]\n+    fn test_writer_read_from_one_buf() {\n+        let mut writer = test_writer(1, 2);\n+\n+        assert_eq!(writer.write(&[]).unwrap(), 0);\n+        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+\n+        // Read at most 2 bytes.\n+        assert_eq!(writer.write(&[1, 1, 1]).unwrap(), 2);\n+        let bufs = &[IoSlice::new(&[2, 2, 2])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 2);\n+\n+        // Only read from first buf.\n+        let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4, 4])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 1);\n+\n+        assert_eq!(writer.written, &[1, 1, 2, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_writer_read_from_multiple_bufs() {\n+        let mut writer = test_writer(3, 3);\n+\n+        // Read at most 3 bytes from two buffers.\n+        let bufs = &[IoSlice::new(&[1]), IoSlice::new(&[2, 2, 2])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n+\n+        // Read at most 3 bytes from three buffers.\n+        let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4]), IoSlice::new(&[5, 5])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n+\n+        assert_eq!(writer.written, &[1, 2, 2, 3, 4, 5]);\n+    }\n+\n+    #[test]\n+    fn test_write_all_vectored() {\n+        #[rustfmt::skip] // Becomes unreadable otherwise.\n+        let tests: Vec<(_, &'static [u8])> = vec![\n+            (vec![], &[]),\n+            (vec![IoSlice::new(&[1])], &[1]),\n+            (vec![IoSlice::new(&[1, 2])], &[1, 2]),\n+            (vec![IoSlice::new(&[1, 2, 3])], &[1, 2, 3]),\n+            (vec![IoSlice::new(&[1, 2, 3, 4])], &[1, 2, 3, 4]),\n+            (vec![IoSlice::new(&[1, 2, 3, 4, 5])], &[1, 2, 3, 4, 5]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2])], &[1, 2]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2])], &[1, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2])], &[1, 1, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 1, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 2, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 1, 2, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2]), IoSlice::new(&[3])], &[1, 2, 3]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3])], &[1, 1, 2, 2, 3, 3]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 2, 2, 3, 3, 3]),\n+            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 1, 1, 2, 2, 2, 3, 3, 3]),\n+        ];\n+\n+        let writer_configs = &[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)];\n+\n+        for (n_bufs, per_call) in writer_configs.iter().copied() {\n+            for (mut input, wanted) in tests.clone().into_iter() {\n+                let mut writer = test_writer(n_bufs, per_call);\n+                assert!(writer.write_all_vectored(&mut *input).is_ok());\n+                assert_eq!(&*writer.written, &*wanted);\n+            }\n+        }\n+    }\n }"}, {"sha": "52dc5578180396198a400f9ae4d1307a58185a1d", "filename": "src/test/ui/sanitize/inline-always.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Ftest%2Fui%2Fsanitize%2Finline-always.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Ftest%2Fui%2Fsanitize%2Finline-always.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Finline-always.rs?ref=bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "previous_filename": "src/test/ui/sanitize-inline-always.rs"}, {"sha": "84c05af4cf83ae7cad78bf72c265089168650902", "filename": "src/test/ui/sanitize/inline-always.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Ftest%2Fui%2Fsanitize%2Finline-always.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc/src%2Ftest%2Fui%2Fsanitize%2Finline-always.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Finline-always.stderr?ref=bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "patch": "@@ -1,12 +1,12 @@\n warning: `no_sanitize` will have no effect after inlining\n-  --> $DIR/sanitize-inline-always.rs:7:1\n+  --> $DIR/inline-always.rs:7:1\n    |\n LL | #[no_sanitize(address)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(inline_no_sanitize)]` on by default\n note: inlining requested here\n-  --> $DIR/sanitize-inline-always.rs:5:1\n+  --> $DIR/inline-always.rs:5:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/sanitize-inline-always.stderr"}]}