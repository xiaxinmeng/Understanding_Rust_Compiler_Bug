{"sha": "8424c24837fffdb83796c5da52094b296445f08f", "node_id": "C_kwDOAAsO6NoAKDg0MjRjMjQ4MzdmZmZkYjgzNzk2YzVkYTUyMDk0YjI5NjQ0NWYwOGY", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-14T00:51:05Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-14T02:30:18Z"}, "message": "Add `Vec` storage optimization to `Arc` and add tests", "tree": {"sha": "5c651b55db76fe21455b9d2ffe8633020a8f637f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c651b55db76fe21455b9d2ffe8633020a8f637f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8424c24837fffdb83796c5da52094b296445f08f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8424c24837fffdb83796c5da52094b296445f08f", "html_url": "https://github.com/rust-lang/rust/commit/8424c24837fffdb83796c5da52094b296445f08f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8424c24837fffdb83796c5da52094b296445f08f/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c813c4d11898d275ee20c841252a3afde203c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c813c4d11898d275ee20c841252a3afde203c58", "html_url": "https://github.com/rust-lang/rust/commit/1c813c4d11898d275ee20c841252a3afde203c58"}], "stats": {"total": 115, "additions": 96, "deletions": 19}, "files": [{"sha": "37e07eb5998b332ffdeb54f4fe675557800e289d", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8424c24837fffdb83796c5da52094b296445f08f/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8424c24837fffdb83796c5da52094b296445f08f/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=8424c24837fffdb83796c5da52094b296445f08f", "patch": "@@ -333,6 +333,15 @@ struct ArcInner<T: ?Sized> {\n     data: T,\n }\n \n+/// Calculate layout for `ArcInner<T>` using the inner value's layout\n+fn arcinner_layout_for_value_layout(layout: Layout) -> Layout {\n+    // Calculate layout using the given value layout.\n+    // Previously, layout was calculated on the expression\n+    // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n+    // reference (see #54908).\n+    Layout::new::<ArcInner<()>>().extend(layout).unwrap().0.pad_to_align()\n+}\n+\n unsafe impl<T: ?Sized + Sync + Send> Send for ArcInner<T> {}\n unsafe impl<T: ?Sized + Sync + Send> Sync for ArcInner<T> {}\n \n@@ -1154,11 +1163,7 @@ impl<T: ?Sized> Arc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = arcinner_layout_for_value_layout(value_layout);\n         unsafe {\n             Arc::try_allocate_for_layout(value_layout, allocate, mem_to_arcinner)\n                 .unwrap_or_else(|_| handle_alloc_error(layout))\n@@ -1176,11 +1181,7 @@ impl<T: ?Sized> Arc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> Result<*mut ArcInner<T>, AllocError> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = arcinner_layout_for_value_layout(value_layout);\n \n         let ptr = allocate(layout)?;\n \n@@ -1246,7 +1247,7 @@ impl<T> Arc<[T]> {\n         }\n     }\n \n-    /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n+    /// Copy elements from slice into newly allocated `Arc<[T]>`\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     #[cfg(not(no_global_oom_handling))]\n@@ -1260,6 +1261,49 @@ impl<T> Arc<[T]> {\n         }\n     }\n \n+    /// Create an `Arc<[T]>` by reusing the underlying memory\n+    /// of a `Vec<T>`. This will return the vector if the existing allocation\n+    /// is not large enough.\n+    #[cfg(not(no_global_oom_handling))]\n+    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Arc<[T]>, Vec<T>> {\n+        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n+        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n+        let layout_arcinner = arcinner_layout_for_value_layout(layout_elements);\n+        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n+        if layout_arcinner.size() > layout_allocation.size()\n+            || layout_arcinner.align() > layout_allocation.align()\n+        {\n+            // Can't fit - calling `grow` would involve `realloc`\n+            // (which copies the elements), followed by copying again.\n+            return Err(v);\n+        }\n+        if layout_arcinner.size() < layout_allocation.size()\n+            || layout_arcinner.align() < layout_allocation.align()\n+        {\n+            // We need to shrink the allocation so that it fits\n+            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n+            // SAFETY:\n+            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n+            // - `layout_arcinner` is smaller\n+            // If this fails, the ownership has not been transferred\n+            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_arcinner) }\n+            {\n+                ptr = p.cast();\n+            } else {\n+                return Err(v);\n+            }\n+        }\n+        // Make sure the vec's memory isn't deallocated now\n+        let v = mem::ManuallyDrop::new(v);\n+        let ptr: *mut ArcInner<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n+        unsafe {\n+            ptr::copy(ptr.cast::<T>(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n+            ptr::write(&mut (*ptr).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*ptr).weak, atomic::AtomicUsize::new(1));\n+            Ok(Self::from_ptr(ptr))\n+        }\n+    }\n+\n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -2571,14 +2615,17 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     /// assert_eq!(&[1, 2, 3], &shared[..]);\n     /// ```\n     #[inline]\n-    fn from(mut v: Vec<T>) -> Arc<[T]> {\n-        unsafe {\n-            let arc = Arc::copy_from_slice(&v);\n-\n-            // Allow the Vec to free its memory, but not destroy its contents\n-            v.set_len(0);\n-\n-            arc\n+    fn from(v: Vec<T>) -> Arc<[T]> {\n+        match Arc::try_from_vec_in_place(v) {\n+            Ok(rc) => rc,\n+            Err(mut v) => {\n+                unsafe {\n+                    let rc = Arc::copy_from_slice(&v);\n+                    // Allow the Vec to free its memory, but not destroy its contents\n+                    v.set_len(0);\n+                    rc\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "eb379e4d6a10f9edfba773e77377f3cd4169a289", "filename": "library/alloc/tests/arc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8424c24837fffdb83796c5da52094b296445f08f/library%2Falloc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8424c24837fffdb83796c5da52094b296445f08f/library%2Falloc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Farc.rs?ref=8424c24837fffdb83796c5da52094b296445f08f", "patch": "@@ -210,3 +210,18 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::sync::Weak`\n }\n+\n+#[test]\n+fn arc_from_vec_opt() {\n+    let mut v = Vec::with_capacity(64);\n+    v.push(0usize);\n+    let addr = v.as_ptr().cast::<u8>();\n+    let arc: Arc<[_]> = v.into();\n+    unsafe {\n+        assert_eq!(\n+            arc.as_ptr().cast::<u8>().offset_from(addr),\n+            (std::mem::size_of::<usize>() * 2) as isize,\n+            \"Vector allocation not reused\"\n+        );\n+    }\n+}"}, {"sha": "1d5f3c52006487bb9517b4fafec882965868c117", "filename": "library/alloc/tests/rc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8424c24837fffdb83796c5da52094b296445f08f/library%2Falloc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8424c24837fffdb83796c5da52094b296445f08f/library%2Falloc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Frc.rs?ref=8424c24837fffdb83796c5da52094b296445f08f", "patch": "@@ -206,3 +206,18 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::rc::Weak`\n }\n+\n+#[test]\n+fn rc_from_vec_opt() {\n+    let mut v = Vec::with_capacity(64);\n+    v.push(0usize);\n+    let addr = v.as_ptr().cast::<u8>();\n+    let rc: Rc<[_]> = v.into();\n+    unsafe {\n+        assert_eq!(\n+            rc.as_ptr().cast::<u8>().offset_from(addr),\n+            (std::mem::size_of::<usize>() * 2) as isize,\n+            \"Vector allocation not reused\"\n+        );\n+    }\n+}"}]}