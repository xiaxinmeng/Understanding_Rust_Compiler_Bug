{"sha": "ef1d1120953fb7a20f22fb70800cf9b76ce54077", "node_id": "C_kwDOAAsO6NoAKGVmMWQxMTIwOTUzZmI3YTIwZjIyZmI3MDgwMGNmOWI3NmNlNTQwNzc", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-29T17:09:03Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-06T16:11:05Z"}, "message": "pass ItemId to check_item_type instead of Item\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "0f1bc359975fdb3e594029c22ce7b398ecbafb06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f1bc359975fdb3e594029c22ce7b398ecbafb06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef1d1120953fb7a20f22fb70800cf9b76ce54077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1d1120953fb7a20f22fb70800cf9b76ce54077", "html_url": "https://github.com/rust-lang/rust/commit/ef1d1120953fb7a20f22fb70800cf9b76ce54077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef1d1120953fb7a20f22fb70800cf9b76ce54077/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b07c4af81ed606adc7090f3b80cbb1d5cc51947", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b07c4af81ed606adc7090f3b80cbb1d5cc51947", "html_url": "https://github.com/rust-lang/rust/commit/1b07c4af81ed606adc7090f3b80cbb1d5cc51947"}], "stats": {"total": 80, "additions": 50, "deletions": 30}, "files": [{"sha": "b2348511e6bcbbe579ebcec6248a839a6d88fff6", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ef1d1120953fb7a20f22fb70800cf9b76ce54077/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1d1120953fb7a20f22fb70800cf9b76ce54077/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=ef1d1120953fb7a20f22fb70800cf9b76ce54077", "patch": "@@ -27,6 +27,7 @@ use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};\n \n+use rustc_hir::def::DefKind;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -711,28 +712,35 @@ fn check_opaque_meets_bounds<'tcx>(\n     });\n }\n \n-pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n+pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n-        it.def_id,\n-        tcx.def_path_str(it.def_id.to_def_id())\n+        id.def_id,\n+        tcx.def_path_str(id.def_id.to_def_id())\n     );\n     let _indenter = indenter();\n-    match it.kind {\n-        // Consts can play a role in type-checking, so they are included here.\n-        hir::ItemKind::Static(..) => {\n-            tcx.ensure().typeck(it.def_id);\n-            maybe_check_static_with_link_section(tcx, it.def_id, it.span);\n-            check_static_inhabited(tcx, it.def_id, it.span);\n+    match tcx.hir().def_kind(id.def_id) {\n+        DefKind::Static(..) => {\n+            tcx.ensure().typeck(id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.def_id, tcx.def_span(id.def_id));\n+            check_static_inhabited(tcx, id.def_id, tcx.def_span(id.def_id));\n         }\n-        hir::ItemKind::Const(..) => {\n-            tcx.ensure().typeck(it.def_id);\n+        DefKind::Const => {\n+            tcx.ensure().typeck(id.def_id);\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n-            check_enum(tcx, it.span, &enum_definition.variants, it.def_id);\n+        DefKind::Enum => {\n+            let item = tcx.hir().item(id);\n+            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n+                return;\n+            };\n+            check_enum(tcx, item.span, &enum_definition.variants, item.def_id);\n         }\n-        hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-        hir::ItemKind::Impl(ref impl_) => {\n+        DefKind::Fn => {} // entirely within check_item_body\n+        DefKind::Impl => {\n+            let it = tcx.hir().item(id);\n+            let hir::ItemKind::Impl(ref impl_) = it.kind else {\n+                return;\n+            };\n             debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n                 check_impl_items_against_trait(\n@@ -745,7 +753,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 check_on_unimplemented(tcx, it);\n             }\n         }\n-        hir::ItemKind::Trait(_, _, _, _, ref items) => {\n+        DefKind::Trait => {\n+            let it = tcx.hir().item(id);\n+            let hir::ItemKind::Trait(_, _, _, _, ref items) = it.kind else {\n+                return;\n+            };\n             check_on_unimplemented(tcx, it);\n \n             for item in items.iter() {\n@@ -771,28 +783,36 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             }\n         }\n-        hir::ItemKind::Struct(..) => {\n-            check_struct(tcx, it.def_id, it.span);\n+        DefKind::Struct => {\n+            check_struct(tcx, id.def_id, tcx.def_span(id.def_id));\n         }\n-        hir::ItemKind::Union(..) => {\n-            check_union(tcx, it.def_id, it.span);\n+        DefKind::Union => {\n+            check_union(tcx, id.def_id, tcx.def_span(id.def_id));\n         }\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n+        DefKind::OpaqueTy => {\n+            let item = tcx.hir().item(id);\n+            let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n+                return;\n+            };\n             // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n             // `async-std` (and `pub async fn` in general).\n             // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n             // See https://github.com/rust-lang/rust/issues/75100\n             if !tcx.sess.opts.actually_rustdoc {\n-                let substs = InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n-                check_opaque(tcx, it.def_id, substs, it.span, &origin);\n+                let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n+                check_opaque(tcx, item.def_id, substs, item.span, &origin);\n             }\n         }\n-        hir::ItemKind::TyAlias(..) => {\n-            let pty_ty = tcx.type_of(it.def_id);\n-            let generics = tcx.generics_of(it.def_id);\n+        DefKind::TyAlias => {\n+            let pty_ty = tcx.type_of(id.def_id);\n+            let generics = tcx.generics_of(id.def_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n-        hir::ItemKind::ForeignMod { abi, items } => {\n+        DefKind::ForeignMod => {\n+            let it = tcx.hir().item(id);\n+            let hir::ItemKind::ForeignMod { abi, items } = it.kind else {\n+                return;\n+            };\n             check_abi(tcx, it.hir_id(), it.span, abi);\n \n             if abi == Abi::RustIntrinsic {\n@@ -851,7 +871,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             }\n         }\n-        _ => { /* nothing to do */ }\n+        _ => {}\n     }\n }\n \n@@ -1453,8 +1473,8 @@ pub(super) fn check_type_params_are_used<'tcx>(\n pub(super) fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n-        let item = tcx.hir().item(id);\n-        check_item_type(tcx, item)\n+        // let item = tcx.hir().item(id);\n+        check_item_type(tcx, id);\n     }\n }\n "}]}