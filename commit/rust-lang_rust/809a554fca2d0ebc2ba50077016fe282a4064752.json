{"sha": "809a554fca2d0ebc2ba50077016fe282a4064752", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwOWE1NTRmY2EyZDBlYmMyYmE1MDA3NzAxNmZlMjgyYTQwNjQ3NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-23T00:37:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-23T00:37:35Z"}, "message": "Auto merge of #23593 - Manishearth:rollup, r=Manishearth\n\n(yay, no Saturday)", "tree": {"sha": "eb7494e5b785d5abb724393c4ade43ed572f9c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb7494e5b785d5abb724393c4ade43ed572f9c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/809a554fca2d0ebc2ba50077016fe282a4064752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/809a554fca2d0ebc2ba50077016fe282a4064752", "html_url": "https://github.com/rust-lang/rust/commit/809a554fca2d0ebc2ba50077016fe282a4064752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/809a554fca2d0ebc2ba50077016fe282a4064752/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aad7dd4fad8d7e2e2f877a511a637258949597", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aad7dd4fad8d7e2e2f877a511a637258949597", "html_url": "https://github.com/rust-lang/rust/commit/b0aad7dd4fad8d7e2e2f877a511a637258949597"}, {"sha": "b4e9106a8a476c2b77e2c4cd8717a9bc1b95de52", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e9106a8a476c2b77e2c4cd8717a9bc1b95de52", "html_url": "https://github.com/rust-lang/rust/commit/b4e9106a8a476c2b77e2c4cd8717a9bc1b95de52"}], "stats": {"total": 552, "additions": 347, "deletions": 205}, "files": [{"sha": "b15829db431dfef89f5d7b6a4fb6217c98874b3b", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -242,7 +242,7 @@ full debug info with variable and type information.\n \\fBopt\\-level\\fR=\\fIVAL\\fR\n Optimize with possible levels 0\\[en]3\n \n-.SH ENVIRONMENT VARIABLES\n+.SH ENVIRONMENT\n \n Some of these affect the output of the compiler, while others affect programs\n which link to the standard library."}, {"sha": "415ec4e4fbf0a4bc661caa3ee26558908310b851", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -1982,7 +1982,7 @@ the namespace hierarchy as it normally would.\n ## Attributes\n \n ```{.ebnf .gram}\n-attribute : \"#!\" ? '[' meta_item ']' ;\n+attribute : '#' '!' ? '[' meta_item ']' ;\n meta_item : ident [ '=' literal\n                   | '(' meta_seq ')' ] ? ;\n meta_seq : meta_item [ ',' meta_seq ] ? ;\n@@ -3158,7 +3158,7 @@ ten_times(|j| println!(\"hello, {}\", j));\n ### While loops\n \n ```{.ebnf .gram}\n-while_expr : \"while\" no_struct_literal_expr '{' block '}' ;\n+while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n ```\n \n A `while` loop begins by evaluating the boolean loop conditional expression.\n@@ -3223,7 +3223,7 @@ A `continue` expression is only permitted in the body of a loop.\n ### For expressions\n \n ```{.ebnf .gram}\n-for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n+for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n ```\n \n A `for` expression is a syntactic construct for looping over elements provided"}, {"sha": "76f8b6c97381818dc3a79b4e7aa87696d58a8377", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -1,6 +1,6 @@\n # Summary\n \n-* [I: The Basics](basic.md)\n+* [The Basics](basic.md)\n     * [Installing Rust](installing-rust.md)\n     * [Hello, world!](hello-world.md)\n     * [Hello, Cargo!](hello-cargo.md)\n@@ -14,7 +14,7 @@\n     * [Strings](strings.md)\n     * [Arrays, Vectors, and Slices](arrays-vectors-and-slices.md)\n     * [Standard Input](standard-input.md)\n-* [II: Intermediate Rust](intermediate.md)\n+* [Intermediate Rust](intermediate.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [Testing](testing.md)\n     * [Pointers](pointers.md)\n@@ -31,7 +31,7 @@\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [Documentation](documentation.md)\n-* [III: Advanced Topics](advanced.md)\n+* [Advanced Topics](advanced.md)\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)\n     * [Advanced Macros](advanced-macros.md)"}, {"sha": "a9e1ce8d7ce50db9a5c0b3c3a5c75b561c0ba754", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -24,7 +24,7 @@ use core::default::Default;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator, IntoIterator};\n-use core::ops::{Index, IndexMut};\n+use core::ops::{Index};\n use core::{iter, fmt, mem, usize};\n use Bound::{self, Included, Excluded, Unbounded};\n \n@@ -925,15 +925,6 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n-{\n-    fn index_mut(&mut self, key: &Q) -> &mut V {\n-        self.get_mut(key).expect(\"no entry found for key\")\n-    }\n-}\n-\n /// Genericises over how to get the correct type of iterator from the correct type\n /// of Node ownership.\n trait Traverse<N> {"}, {"sha": "31812e19aee86d4c90bff5c5ad55a6aee9784cff", "filename": "src/librustc/README.md", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -0,0 +1,128 @@\n+An informal guide to reading and working on the rustc compiler.\n+==================================================================\n+\n+If you wish to expand on this document, or have a more experienced\n+Rust contributor add anything else to it, please get in touch:\n+\n+* http://internals.rust-lang.org/\n+* https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n+\n+or file a bug:\n+\n+https://github.com/rust-lang/rust/issues\n+\n+Your concerns are probably the same as someone else's.\n+\n+The crates of rustc\n+===================\n+\n+Rustc consists of a number of crates, including `libsyntax`,\n+`librustc`, `librustc_back`, `librustc_trans`, and `librustc_driver`\n+(the names and divisions are not set in stone and may change;\n+in general, a finer-grained division of crates is preferable):\n+\n+- `libsyntax` contains those things concerned purely with syntax \u2013\n+  that is, the AST, parser, pretty-printer, lexer, macro expander, and\n+  utilities for traversing ASTs \u2013 are in a separate crate called\n+  \"syntax\", whose files are in `./../libsyntax`, where `.` is the\n+  current directory (that is, the parent directory of front/, middle/,\n+  back/, and so on).\n+\n+- `librustc` (the current directory) contains the high-level analysis\n+  passes, such as the type checker, borrow checker, and so forth.\n+  It is the heart of the compiler.\n+\n+- `librustc_back` contains some very low-level details that are\n+  specific to different LLVM targets and so forth.\n+\n+- `librustc_trans` contains the code to convert from Rust IR into LLVM\n+  IR, and then from LLVM IR into machine code, as well as the main\n+  driver that orchestrates all the other passes and various other bits\n+  of miscellany. In general it contains code that runs towards the\n+  end of the compilation process.\n+\n+- `librustc_driver` invokes the compiler from `libsyntax`, then the\n+  analysis phases from `librustc`, and finally the lowering and\n+  codegen passes from `librustc_trans`.\n+\n+Roughly speaking the \"order\" of the three crates is as follows:\n+\n+    libsyntax -> librustc -> librustc_trans\n+    |                                     |\n+    +-----------------+-------------------+\n+                      |\n+              librustc_driver\n+\n+\n+Modules in the rustc crate\n+==========================\n+\n+The rustc crate itself consists of the following submodules\n+(mostly, but not entirely, in their own directories):\n+\n+- session: options and data that pertain to the compilation session as\n+  a whole\n+- middle: middle-end: name resolution, typechecking, LLVM code\n+  generation\n+- metadata: encoder and decoder for data required by separate\n+  compilation\n+- plugin: infrastructure for compiler plugins\n+- lint: infrastructure for compiler warnings\n+- util: ubiquitous types and helper functions\n+- lib: bindings to LLVM\n+\n+The entry-point for the compiler is main() in the librustc_trans\n+crate.\n+\n+The 3 central data structures:\n+------------------------------\n+\n+1. `./../libsyntax/ast.rs` defines the AST. The AST is treated as\n+   immutable after parsing, but it depends on mutable context data\n+   structures (mainly hash maps) to give it meaning.\n+\n+   - Many \u2013 though not all \u2013 nodes within this data structure are\n+     wrapped in the type `spanned<T>`, meaning that the front-end has\n+     marked the input coordinates of that node. The member `node` is\n+     the data itself, the member `span` is the input location (file,\n+     line, column; both low and high).\n+\n+   - Many other nodes within this data structure carry a\n+     `def_id`. These nodes represent the 'target' of some name\n+     reference elsewhere in the tree. When the AST is resolved, by\n+     `middle/resolve.rs`, all names wind up acquiring a def that they\n+     point to. So anything that can be pointed-to by a name winds\n+     up with a `def_id`.\n+\n+2. `middle/ty.rs` defines the datatype `sty`. This is the type that\n+   represents types after they have been resolved and normalized by\n+   the middle-end. The typeck phase converts every ast type to a\n+   `ty::sty`, and the latter is used to drive later phases of\n+   compilation. Most variants in the `ast::ty` tag have a\n+   corresponding variant in the `ty::sty` tag.\n+\n+3. `./../librustc_llvm/lib.rs` defines the exported types\n+   `ValueRef`, `TypeRef`, `BasicBlockRef`, and several others.\n+   Each of these is an opaque pointer to an LLVM type,\n+   manipulated through the `lib::llvm` interface.\n+\n+\n+Control and information flow within the compiler:\n+-------------------------------------------------\n+\n+- main() in lib.rs assumes control on startup. Options are\n+  parsed, platform is detected, etc.\n+\n+- `./../libsyntax/parse/parser.rs` parses the input files and produces\n+  an AST that represents the input crate.\n+\n+- Multiple middle-end passes (`middle/resolve.rs`, `middle/typeck.rs`)\n+  analyze the semantics of the resulting AST. Each pass generates new\n+  information about the AST and stores it in various environment data\n+  structures. The driver passes environments to each compiler pass\n+  that needs to refer to them.\n+\n+- Finally, the `trans` module in `librustc_trans` translates the Rust\n+  AST to LLVM bitcode in a type-directed way. When it's finished\n+  synthesizing LLVM values, rustc asks LLVM to write them out in some\n+  form (`.bc`, `.o`) and possibly run the system linker."}, {"sha": "9b364768208ebfabbb333cdf84d36b7b697af1fb", "filename": "src/librustc/README.txt", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b0aad7dd4fad8d7e2e2f877a511a637258949597/src%2Flibrustc%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b0aad7dd4fad8d7e2e2f877a511a637258949597/src%2Flibrustc%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.txt?ref=b0aad7dd4fad8d7e2e2f877a511a637258949597", "patch": "@@ -1,124 +0,0 @@\n-An informal guide to reading and working on the rustc compiler.\n-==================================================================\n-\n-If you wish to expand on this document, or have a more experienced\n-Rust contributor add anything else to it, please get in touch:\n-\n-* http://internals.rust-lang.org/\n-* https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n-\n-or file a bug:\n-\n-https://github.com/rust-lang/rust/issues\n-\n-Your concerns are probably the same as someone else's.\n-\n-The crates of rustc\n-===================\n-\n-Rustc consists of four crates altogether: `libsyntax`, `librustc`,\n-`librustc_back`, and `librustc_trans` (the names and divisions are not\n-set in stone and may change; in general, a finer-grained division of\n-crates is preferable):\n-\n-- `libsyntax` contains those things concerned purely with syntax --\n-  that is, the AST, parser, pretty-printer, lexer, macro expander, and\n-  utilities for traversing ASTs -- are in a separate crate called\n-  \"syntax\", whose files are in ./../libsyntax, where . is the current\n-  directory (that is, the parent directory of front/, middle/, back/,\n-  and so on).\n-\n-- `librustc` (the current directory) contains the high-level analysis\n-  passes, such as the type checker, borrow checker, and so forth.\n-  It is the heart of the compiler.\n-\n-- `librustc_back` contains some very low-level details that are\n-  specific to different LLVM targets and so forth.\n-\n-- `librustc_trans` contains the code to convert from Rust IR into LLVM\n-  IR, and then from LLVM IR into machine code, as well as the main\n-  driver that orchestrates all the other passes and various other bits\n-  of miscellany. In general it contains code that runs towards the\n-  end of the compilation process.\n-\n-Roughly speaking the \"order\" of the three crates is as follows:\n-\n-    libsyntax -> librustc -> librustc_trans\n-    |                                     |\n-    +-----------------+-------------------+\n-                      |\n-             librustc_trans/driver\n-\n-Here the role of `librustc_trans/driver` is to invoke the compiler\n-from libsyntax, then the analysis phases from librustc, and finally\n-the lowering and codegen passes from librustc_trans.\n-\n-Modules in the rustc crate\n-==========================\n-\n-The rustc crate itself consists of the following subdirectories\n-(mostly, but not entirely, in their own directories):\n-\n-session  - options and data that pertain to the compilation session as a whole\n-middle   - middle-end: name resolution, typechecking, LLVM code\n-                  generation\n-metadata - encoder and decoder for data required by\n-                    separate compilation\n-util     - ubiquitous types and helper functions\n-lib      - bindings to LLVM\n-\n-The entry-point for the compiler is main() in the librustc_trans\n-crate.\n-\n-The 3 central data structures:\n-------------------------------\n-\n-#1: ./../libsyntax/ast.rs defines the AST. The AST is treated as immutable\n-    after parsing, but it depends on mutable context data structures\n-    (mainly hash maps) to give it meaning.\n-\n-      - Many -- though not all -- nodes within this data structure are\n-        wrapped in the type `spanned<T>`, meaning that the front-end has\n-        marked the input coordinates of that node. The member .node is\n-        the data itself, the member .span is the input location (file,\n-        line, column; both low and high).\n-\n-      - Many other nodes within this data structure carry a\n-        def_id. These nodes represent the 'target' of some name\n-        reference elsewhere in the tree. When the AST is resolved, by\n-        middle/resolve.rs, all names wind up acquiring a def that they\n-        point to. So anything that can be pointed-to by a name winds\n-        up with a def_id.\n-\n-#2: middle/ty.rs defines the datatype sty.  This is the type that\n-    represents types after they have been resolved and normalized by\n-    the middle-end. The typeck phase converts every ast type to a\n-    ty::sty, and the latter is used to drive later phases of\n-    compilation.  Most variants in the ast::ty tag have a\n-    corresponding variant in the ty::sty tag.\n-\n-#3: lib/llvm.rs (in librustc_trans) defines the exported types\n-    ValueRef, TypeRef, BasicBlockRef, and several others. Each of\n-    these is an opaque pointer to an LLVM type, manipulated through\n-    the lib::llvm interface.\n-\n-\n-Control and information flow within the compiler:\n--------------------------------------------------\n-\n-- main() in lib.rs assumes control on startup. Options are\n-  parsed, platform is detected, etc.\n-\n-- ./../libsyntax/parse/parser.rs parses the input files and produces an AST\n-  that represents the input crate.\n-\n-- Multiple middle-end passes (middle/resolve.rs, middle/typeck.rs)\n-  analyze the semantics of the resulting AST. Each pass generates new\n-  information about the AST and stores it in various environment data\n-  structures. The driver passes environments to each compiler pass\n-  that needs to refer to them.\n-\n-- Finally, the `trans` module in `librustc_trans` translates the Rust\n-  AST to LLVM bitcode in a type-directed way. When it's finished\n-  synthesizing LLVM values, rustc asks LLVM to write them out in some\n-  form (.bc, .o) and possibly run the system linker."}, {"sha": "566af2590e6c07cd0ec1a256856951ee36478222", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -900,7 +900,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return;\n         }\n         if self.glob_map.contains_key(&import_id) {\n-            self.glob_map[import_id].insert(name);\n+            self.glob_map.get_mut(&import_id).unwrap().insert(name);\n             return;\n         }\n "}, {"sha": "46451019760dd478aa179449473532a32d15fe63", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -603,7 +603,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = &mut (*import_resolutions)[target];\n+        let import_resolution = import_resolutions.get_mut(&target).unwrap();\n \n         {\n             let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {"}, {"sha": "1f416d5404d2778d0fdea4768371232068e2bae8", "filename": "src/librustc_trans/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_trans%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_trans%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.txt?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -1 +1 @@\n-See the README.txt in ../librustc.\n+See the README.md in ../librustc."}, {"sha": "ebd92faaf0f5328dda42d28c11fca41a6b1199ef", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -983,56 +983,72 @@ pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n /// gives us better information about what we are loading.\n pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n-    if type_is_zero_size(cx.ccx(), t) {\n-        C_undef(type_of::type_of(cx.ccx(), t))\n-    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n-        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n-        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n-        // and we have to convert it\n-        Load(cx, BitCast(cx, ptr, type_of::arg_type_of(cx.ccx(), t).ptr_to()))\n-    } else {\n-        unsafe {\n-            let global = llvm::LLVMIsAGlobalVariable(ptr);\n-            if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-                let val = llvm::LLVMGetInitializer(global);\n-                if !val.is_null() {\n-                    // This could go into its own function, for DRY.\n-                    // (something like \"pre-store packing/post-load unpacking\")\n-                    if ty::type_is_bool(t) {\n-                        return Trunc(cx, val, Type::i1(cx.ccx()));\n-                    } else {\n-                        return val;\n-                    }\n-                }\n+    if cx.unreachable.get() || type_is_zero_size(cx.ccx(), t) {\n+        return C_undef(type_of::type_of(cx.ccx(), t));\n+    }\n+\n+    let ptr = to_arg_ty_ptr(cx, ptr, t);\n+\n+    if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+        return Load(cx, ptr);\n+    }\n+\n+    unsafe {\n+        let global = llvm::LLVMIsAGlobalVariable(ptr);\n+        if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+            let val = llvm::LLVMGetInitializer(global);\n+            if !val.is_null() {\n+                return from_arg_ty(cx, val, t);\n             }\n         }\n-        if ty::type_is_bool(t) {\n-            Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n-        } else if ty::type_is_char(t) {\n-            // a char is a Unicode codepoint, and so takes values from 0\n-            // to 0x10FFFF inclusive only.\n-            LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-        } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n-                  && !common::type_is_fat_ptr(cx.tcx(), t) {\n-            LoadNonNull(cx, ptr)\n-        } else {\n-            Load(cx, ptr)\n-        }\n     }\n+\n+    let val =  if ty::type_is_bool(t) {\n+        LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n+    } else if ty::type_is_char(t) {\n+        // a char is a Unicode codepoint, and so takes values from 0\n+        // to 0x10FFFF inclusive only.\n+        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n+    } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n+        && !common::type_is_fat_ptr(cx.tcx(), t) {\n+            LoadNonNull(cx, ptr)\n+    } else {\n+        Load(cx, ptr)\n+    };\n+\n+    from_arg_ty(cx, val, t)\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n-    if ty::type_is_bool(t) {\n-        Store(cx, ZExt(cx, v, Type::i8(cx.ccx())), dst);\n-    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+    Store(cx, to_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n+}\n+\n+pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+    if ty::type_is_bool(ty) {\n+        ZExt(bcx, val, Type::i8(bcx.ccx()))\n+    } else {\n+        val\n+    }\n+}\n+\n+pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+    if ty::type_is_bool(ty) {\n+        Trunc(bcx, val, Type::i1(bcx.ccx()))\n+    } else {\n+        val\n+    }\n+}\n+\n+pub fn to_arg_ty_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef, ty: Ty<'tcx>) -> ValueRef {\n+    if type_is_immediate(bcx.ccx(), ty) && type_of::type_of(bcx.ccx(), ty).is_aggregate() {\n         // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n         // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n         // and we have to convert it\n-        Store(cx, v, BitCast(cx, dst, type_of::arg_type_of(cx.ccx(), t).ptr_to()));\n+        BitCast(bcx, ptr, type_of::arg_type_of(bcx.ccx(), ty).ptr_to())\n     } else {\n-        Store(cx, v, dst);\n+        ptr\n     }\n }\n "}, {"sha": "d158cfa7b88765b77f12dba0808328ebd9ef630b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -446,10 +446,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n-            VolatileLoad(bcx, llargs[0])\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+            from_arg_ty(bcx, VolatileLoad(bcx, ptr), tp_ty)\n         },\n         (_, \"volatile_store\") => {\n-            VolatileStore(bcx, llargs[1], llargs[0]);\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+            let val = to_arg_ty(bcx, llargs[1], tp_ty);\n+            VolatileStore(bcx, val, ptr);\n             C_nil(ccx)\n         },\n \n@@ -709,8 +714,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             llvm::SequentiallyConsistent\n                     };\n \n-                    let res = AtomicCmpXchg(bcx, llargs[0], llargs[1],\n-                                            llargs[2], order,\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let cmp = to_arg_ty(bcx, llargs[1], tp_ty);\n+                    let src = to_arg_ty(bcx, llargs[2], tp_ty);\n+                    let res = AtomicCmpXchg(bcx, ptr, cmp, src, order,\n                                             strongest_failure_ordering);\n                     if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n                         ExtractValue(bcx, res, 0)\n@@ -720,10 +728,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"load\" => {\n-                    AtomicLoad(bcx, llargs[0], order)\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    from_arg_ty(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n                 \"store\" => {\n-                    AtomicStore(bcx, llargs[1], llargs[0], order);\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let val = to_arg_ty(bcx, llargs[1], tp_ty);\n+                    AtomicStore(bcx, val, ptr, order);\n                     C_nil(ccx)\n                 }\n \n@@ -749,7 +762,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let val = to_arg_ty(bcx, llargs[1], tp_ty);\n+                    AtomicRMW(bcx, atom_op, ptr, val, order)\n                 }\n             }\n "}, {"sha": "ce4bb4465517b21ef55189e1fc99f2312fae03ee", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -380,7 +380,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                 // borrow_kind of the upvar to make sure it\n                 // is inferred to mutable if necessary\n                 let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                let ub = &mut upvar_capture_map[upvar_id];\n+                let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n                 self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow"}, {"sha": "9139e182ce479594ba38b0ccc132a33f2f9b98a5", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -23,7 +23,7 @@ use hash::{Hash, SipHasher};\n use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n-use ops::{Deref, FnMut, Index, IndexMut};\n+use ops::{Deref, FnMut, Index};\n use option::Option::{self, Some, None};\n use rand::{self, Rng};\n use result::Result::{self, Ok, Err};\n@@ -1258,18 +1258,6 @@ impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash + Borrow<Q>,\n-          Q: Eq + Hash,\n-          S: HashState,\n-{\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n-        self.get_mut(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n /// HashMap iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {"}, {"sha": "130fd1d7dc83b36841ee5ca4afbf89ec575188f5", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -40,7 +40,7 @@ use fmt;\n /// among threads to ensure that a possibly invalid invariant is not witnessed.\n ///\n /// A poisoned mutex, however, does not prevent all access to the underlying\n-/// data. The `PoisonError` type has an `into_guard` method which will return\n+/// data. The `PoisonError` type has an `into_inner` method which will return\n /// the guard that would have otherwise been returned on a successful lock. This\n /// allows access to the data, despite the lock being poisoned.\n ///\n@@ -105,7 +105,7 @@ use fmt;\n /// // pattern matched on to return the underlying guard on both branches.\n /// let mut guard = match lock.lock() {\n ///     Ok(guard) => guard,\n-///     Err(poisoned) => poisoned.into_guard(),\n+///     Err(poisoned) => poisoned.into_inner(),\n /// };\n ///\n /// *guard += 1;"}, {"sha": "a88445bafc049e8920b440627911a4b221b9ed5f", "filename": "src/test/compile-fail-fulldeps/gated-macro-reexports.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that macro reexports item are gated by `macro_reexport` feature gate.\n+\n+// aux-build:macro_reexport_1.rs\n+// ignore-stage1\n+\n+#![crate_type = \"dylib\"]\n+\n+#[macro_reexport(reexported)]\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_1;\n+//~^ ERROR macros reexports are experimental and possibly buggy\n+//~| HELP add #![feature(macro_reexport)] to the crate attributes to enable"}, {"sha": "abaa256d52e7fa3e7e3cbccb8a714a64352efcfe", "filename": "src/test/compile-fail/gated-box-patterns.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail%2Fgated-box-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail%2Fgated-box-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-box-patterns.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that patterns including the box syntax are gated by `box_patterns` feature gate.\n+\n+fn main() {\n+    let x = Box::new(1);\n+\n+    match x {\n+        box 1 => (),\n+        //~^ box pattern syntax is experimental\n+        //~| add #![feature(box_patterns)] to the crate attributes to enable\n+        _     => ()\n+    };\n+}"}, {"sha": "3e08c1f7a71305ee1d64d977e4986023d5a5fdd3", "filename": "src/test/compile-fail/gated-box-syntax.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail%2Fgated-box-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail%2Fgated-box-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-box-syntax.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the use of the box syntax is gated by `box_syntax` feature gate.\n+\n+fn main() {\n+    let x = box 3;\n+    //~^ ERROR box expression syntax is experimental; you can call `Box::new` instead.\n+    //~| HELP add #![feature(box_syntax)] to the crate attributes to enable\n+}"}, {"sha": "c0a251e77a3160c0f617d216cc9d702a7daf8c21", "filename": "src/test/compile-fail/gated-simd-ffi.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail%2Fgated-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Fcompile-fail%2Fgated-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-simd-ffi.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the use of smid types in the ffi is gated by `smid_ffi` feature gate.\n+\n+#![feature(simd)]\n+\n+#[repr(C)]\n+#[derive(Copy)]\n+#[simd]\n+pub struct f32x4(f32, f32, f32, f32);\n+\n+#[allow(dead_code)]\n+extern {\n+    fn foo(x: f32x4);\n+    //~^ ERROR use of SIMD type `f32x4` in FFI is highly experimental and may result in invalid code\n+    //~| HELP add #![feature(simd_ffi)] to the crate attributes to enable\n+}\n+\n+fn main() {}"}, {"sha": "97357c1dba4674da12abf8aea1c12dc8721adb05", "filename": "src/test/run-pass/issue-23550.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809a554fca2d0ebc2ba50077016fe282a4064752/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23550.rs?ref=809a554fca2d0ebc2ba50077016fe282a4064752", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+#![allow(warnings)]\n+\n+use std::intrinsics;\n+\n+#[derive(Copy)]\n+struct Wrap(i64);\n+\n+// These volatile and atomic intrinsics used to cause an ICE\n+\n+unsafe fn test_bool(p: &mut bool, v: bool) {\n+    intrinsics::volatile_load(p);\n+    intrinsics::volatile_store(p, v);\n+    intrinsics::atomic_load(p);\n+    intrinsics::atomic_cxchg(p, v, v);\n+    intrinsics::atomic_store(p, v);\n+    intrinsics::atomic_xchg(p, v);\n+}\n+\n+unsafe fn test_immediate_fca(p: &mut Wrap, v: Wrap) {\n+    intrinsics::volatile_load(p);\n+    intrinsics::volatile_store(p, v);\n+    intrinsics::atomic_load(p);\n+    intrinsics::atomic_cxchg(p, v, v);\n+    intrinsics::atomic_store(p, v);\n+    intrinsics::atomic_xchg(p, v);\n+}\n+\n+fn main() {}"}]}