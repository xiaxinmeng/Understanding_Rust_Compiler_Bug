{"sha": "f89041bbe3da48d98c1512b39c819ed42cff4e78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OTA0MWJiZTNkYTQ4ZDk4YzE1MTJiMzljODE5ZWQ0MmNmZjRlNzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-06T21:28:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-18T14:11:35Z"}, "message": "identify inputs of `MetaData(X)` nodes\n\nGenerate a second hash file that contains the metadata for an X node.", "tree": {"sha": "15d04ce7c922dd7be2d038d10a5a21e36e0cdb40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15d04ce7c922dd7be2d038d10a5a21e36e0cdb40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89041bbe3da48d98c1512b39c819ed42cff4e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89041bbe3da48d98c1512b39c819ed42cff4e78", "html_url": "https://github.com/rust-lang/rust/commit/f89041bbe3da48d98c1512b39c819ed42cff4e78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89041bbe3da48d98c1512b39c819ed42cff4e78/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc02a54d12f8b03506ae8eda50a05784cf04b63f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc02a54d12f8b03506ae8eda50a05784cf04b63f", "html_url": "https://github.com/rust-lang/rust/commit/bc02a54d12f8b03506ae8eda50a05784cf04b63f"}], "stats": {"total": 304, "additions": 221, "deletions": 83}, "files": [{"sha": "d06f51073df06f359567595d036b48d93ce1b1c4", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -64,7 +64,7 @@ impl CFG {\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n-        self.graph.depth_traverse(self.entry)\n+        self.graph.depth_traverse(self.entry, graph::OUTGOING)\n                   .any(|idx| self.graph.node_data(idx).id() == id)\n     }\n }"}, {"sha": "93248edb197c625e9f4fec25559171ff4245ece5", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc_data_structures::fnv::FnvHashMap;\n-use rustc_data_structures::graph::{Graph, NodeIndex};\n+use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n use std::fmt::Debug;\n use std::hash::Hash;\n \n@@ -63,20 +63,29 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n                   .collect()\n     }\n \n-    /// All nodes reachable from `node`. In other words, things that\n-    /// will have to be recomputed if `node` changes.\n-    pub fn transitive_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    fn reachable_nodes(&self, node: DepNode<D>, direction: Direction) -> Vec<DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n-            self.graph.depth_traverse(index)\n+            self.graph.depth_traverse(index, direction)\n                       .map(|s| self.graph.node_data(s).clone())\n                       .collect()\n         } else {\n             vec![]\n         }\n     }\n \n+    /// All nodes reachable from `node`. In other words, things that\n+    /// will have to be recomputed if `node` changes.\n+    pub fn transitive_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+        self.reachable_nodes(node, OUTGOING)\n+    }\n+\n+    /// All nodes that can reach `node`.\n+    pub fn transitive_predecessors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+        self.reachable_nodes(node, INCOMING)\n+    }\n+\n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn immediate_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index)\n                       .map(|s| self.graph.node_data(s).clone())"}, {"sha": "5312d03052552817810dac087fd68b88602309c3", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -20,7 +20,7 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n-use rustc_data_structures::graph::{self, Direction, NodeIndex};\n+use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n@@ -872,7 +872,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let seeds: Vec<_> = givens.iter().cloned().collect();\n         for (fr, vid) in seeds {\n             let seed_index = NodeIndex(vid.index as usize);\n-            for succ_index in graph.depth_traverse(seed_index) {\n+            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n                 let succ_index = succ_index.0 as u32;\n                 if succ_index < self.num_vars() {\n                     let succ_vid = RegionVid { index: succ_index };"}, {"sha": "731471b0600f3cfe635e813d997d6d5f3223bb52", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -292,11 +292,15 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         }\n     }\n \n-    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E> {\n+    pub fn depth_traverse<'a>(&'a self,\n+                              start: NodeIndex,\n+                              direction: Direction)\n+                              -> DepthFirstTraversal<'a, N, E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n             visited: BitVector::new(self.nodes.len()),\n+            direction: direction,\n         }\n     }\n }\n@@ -371,6 +375,7 @@ pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n     visited: BitVector,\n+    direction: Direction,\n }\n \n impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n@@ -382,9 +387,10 @@ impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n                 continue;\n             }\n \n-            for (_, edge) in self.graph.outgoing_edges(idx) {\n-                if !self.visited.contains(edge.target().node_id()) {\n-                    self.stack.push(edge.target());\n+            for (_, edge) in self.graph.adjacent_edges(idx, self.direction) {\n+                let target = edge.source_or_target(self.direction);\n+                if !self.visited.contains(target.node_id()) {\n+                    self.stack.push(target);\n                 }\n             }\n "}, {"sha": "e426e4d5b44af40d4a429e4f6ddf92397ce515ca", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -195,7 +195,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         for &(_, source_def_id, source_dep_node) in sources {\n-            let dependents = query.transitive_dependents(source_dep_node);\n+            let dependents = query.transitive_successors(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n                 if !dependents.contains(&target_dep_node) {\n                     tcx.sess.span_err("}, {"sha": "5c68552b7185b0a7ef911e864d2f18e16077f75c", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -14,18 +14,50 @@ use rustc::dep_graph::DepNode;\n \n use super::directory::DefPathIndex;\n \n+/// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n     pub nodes: Vec<DepNode<DefPathIndex>>,\n     pub edges: Vec<SerializedEdge>,\n+\n+    /// These are hashes of two things:\n+    /// - the HIR nodes in this crate\n+    /// - the metadata nodes from dependent crates we use\n+    ///\n+    /// In each case, we store a hash summarizing the contents of\n+    /// those items as they were at the time we did this compilation.\n+    /// In the case of HIR nodes, this hash is derived by walking the\n+    /// HIR itself. In the case of metadata nodes, the hash is loaded\n+    /// from saved state.\n+    ///\n+    /// When we do the next compile, we will load these back up and\n+    /// compare them against the hashes we see at that time, which\n+    /// will tell us what has changed, either in this crate or in some\n+    /// crate that we depend on.\n+    pub hashes: Vec<SerializedHash>,\n+}\n+\n+/// Data for use when downstream crates get recompiled.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedMetadataHashes {\n+    /// For each def-id defined in this crate that appears in the\n+    /// metadata, we hash all the inputs that were used when producing\n+    /// the metadata. We save this after compilation is done.  Then,\n+    /// when some downstream crate is being recompiled, it can compare\n+    /// the hashes we saved against the hashes that it saw from\n+    /// before; this will tell it which of the items in this crate\n+    /// changed, which in turn implies what items in the downstream\n+    /// crate need to be recompiled.\n     pub hashes: Vec<SerializedHash>,\n }\n \n pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {\n-    pub index: DefPathIndex,\n+    /// node being hashed; either a Hir or MetaData variant, in\n+    /// practice\n+    pub node: DepNode<DefPathIndex>,\n \n     /// the hash itself, computed by `calculate_item_hash`\n     pub hash: u64,"}, {"sha": "35ef0917517c53aeb3c5b3a635fce098d109ccc1", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -10,7 +10,6 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use calculate_svh::SvhCalculate;\n use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n@@ -131,20 +130,20 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 hashed_items: &[SerializedHash],\n+                                 hashes: &[SerializedHash],\n                                  retraced: &RetracedDefIdDirectory)\n                                  -> DirtyNodes {\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n-    for hashed_item in hashed_items {\n-        match retraced.def_id(hashed_item.index) {\n-            Some(def_id) => {\n+    for hash in hashes {\n+        match hash.node.map_def(|&i| retraced.def_id(i)) {\n+            Some(dep_node) => {\n                 // FIXME(#32753) -- should we use a distinct hash here\n-                let current_hash = tcx.calculate_item_hash(def_id);\n+                let current_hash = dep_node.hash(tcx).unwrap();\n                 debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n-                       def_id, current_hash, hashed_item.hash);\n-                if current_hash != hashed_item.hash {\n-                    dirty_nodes.insert(DepNode::Hir(def_id));\n+                       dep_node, current_hash, hash.hash);\n+                if current_hash != hash.hash {\n+                    dirty_nodes.insert(dep_node);\n                 }\n             }\n             None => {"}, {"sha": "40191cf758dff6a73efad3c4ad328345568732d5", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 116, "deletions": 56, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use calculate_svh::SvhCalculate;\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n+use std::hash::{Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n+use std::path::PathBuf;\n \n use super::data::*;\n use super::directory::*;\n@@ -23,83 +24,78 @@ use super::util::*;\n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n-    if let Some(dep_graph) = dep_graph_path(tcx) {\n-        // FIXME(#32754) lock file?\n-\n-        // delete the old dep-graph, if any\n-        if dep_graph.exists() {\n-            match fs::remove_file(&dep_graph) {\n-                Ok(()) => { }\n-                Err(err) => {\n-                    tcx.sess.err(\n-                        &format!(\"unable to delete old dep-graph at `{}`: {}\",\n-                                 dep_graph.display(), err));\n-                    return;\n-                }\n-            }\n-        }\n+    save_in(tcx, dep_graph_path(tcx), encode_dep_graph);\n+    save_in(tcx, metadata_hash_path(tcx), encode_metadata_hashes);\n+}\n \n-        // generate the data in a memory buffer\n-        let mut wr = Cursor::new(Vec::new());\n-        match encode_dep_graph(tcx, &mut Encoder::new(&mut wr)) {\n+fn save_in<'a,'tcx,F>(tcx: TyCtxt<'a, 'tcx, 'tcx>, opt_path_buf: Option<PathBuf>, encode: F)\n+    where F: FnOnce(TyCtxt<'a, 'tcx, 'tcx>, &mut Encoder) -> io::Result<()>\n+{\n+    let path_buf = match opt_path_buf {\n+        Some(p) => p,\n+        None => return\n+    };\n+\n+    // FIXME(#32754) lock file?\n+\n+    // delete the old dep-graph, if any\n+    if path_buf.exists() {\n+        match fs::remove_file(&path_buf) {\n             Ok(()) => { }\n             Err(err) => {\n                 tcx.sess.err(\n-                    &format!(\"could not encode dep-graph to `{}`: {}\",\n-                             dep_graph.display(), err));\n+                    &format!(\"unable to delete old dep-graph at `{}`: {}\",\n+                             path_buf.display(), err));\n                 return;\n             }\n         }\n+    }\n \n-        // write the data out\n-        let data = wr.into_inner();\n-        match\n-            File::create(&dep_graph)\n-            .and_then(|mut file| file.write_all(&data))\n-        {\n-            Ok(_) => { }\n-            Err(err) => {\n-                tcx.sess.err(\n-                    &format!(\"failed to write dep-graph to `{}`: {}\",\n-                             dep_graph.display(), err));\n-                return;\n-            }\n+    // generate the data in a memory buffer\n+    let mut wr = Cursor::new(Vec::new());\n+    match encode(tcx, &mut Encoder::new(&mut wr)) {\n+        Ok(()) => { }\n+        Err(err) => {\n+            tcx.sess.err(\n+                &format!(\"could not encode dep-graph to `{}`: {}\",\n+                         path_buf.display(), err));\n+            return;\n+        }\n+    }\n+\n+    // write the data out\n+    let data = wr.into_inner();\n+    match\n+        File::create(&path_buf)\n+        .and_then(|mut file| file.write_all(&data))\n+    {\n+        Ok(_) => { }\n+        Err(err) => {\n+            tcx.sess.err(\n+                &format!(\"failed to write dep-graph to `{}`: {}\",\n+                         path_buf.display(), err));\n+            return;\n         }\n     }\n }\n \n pub fn encode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   encoder: &mut Encoder)\n                                   -> io::Result<()> {\n-    // Here we take advantage of how RBML allows us to skip around\n-    // and encode the depgraph as a two-part structure:\n-    //\n-    // ```\n-    // <dep-graph>[SerializedDepGraph]</dep-graph> // tag 0\n-    // <directory>[DefIdDirectory]</directory>     // tag 1\n-    // ```\n-    //\n-    // Then later we can load the directory by skipping to find tag 1.\n-\n     let query = tcx.dep_graph.query();\n \n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n \n-    // Create hashes for things we can persist.\n+    // Create hashes for inputs.\n     let hashes =\n         query.nodes()\n              .into_iter()\n-             .filter_map(|dep_node| match dep_node {\n-                 DepNode::Hir(def_id) => {\n-                     assert!(def_id.is_local());\n-                     builder.add(def_id)\n-                            .map(|index| {\n-                                // FIXME(#32753) -- should we use a distinct hash here\n-                                let hash = tcx.calculate_item_hash(def_id);\n-                                SerializedHash { index: index, hash: hash }\n-                            })\n-                 }\n-                 _ => None\n+             .filter_map(|dep_node| {\n+                 dep_node.hash(tcx)\n+                         .map(|hash| {\n+                             let node = builder.map(dep_node).unwrap();\n+                             SerializedHash { node: node, hash: hash }\n+                         })\n              })\n              .collect();\n \n@@ -133,3 +129,67 @@ pub fn encode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n+pub fn encode_metadata_hashes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        encoder: &mut Encoder)\n+                                        -> io::Result<()>\n+{\n+    let query = tcx.dep_graph.query();\n+\n+    let mut builder = DefIdDirectoryBuilder::new(tcx);\n+\n+    let serialized_hashes = {\n+        // Identify the `MetaData(X)` nodes where `X` is local. These are\n+        // the metadata items we export. Downstream crates will want to\n+        // see a hash that tells them whether we might have changed the\n+        // metadata for a given item since they last compiled.\n+        let meta_data_def_ids =\n+            query.nodes()\n+                 .into_iter()\n+                 .filter_map(|dep_node| match dep_node {\n+                     DepNode::MetaData(def_id) if def_id.is_local() => Some(def_id),\n+                     _ => None,\n+                 });\n+\n+        // To create the hash for each item `X`, we don't hash the raw\n+        // bytes of the metadata (though in principle we could). Instead,\n+        // we walk the predecessors of `MetaData(X)` from the\n+        // dep-graph. This corresponds to all the inputs that were read to\n+        // construct the metadata. To create the hash for the metadata, we\n+        // hash (the hash of) all of those inputs.\n+        let hashes =\n+            meta_data_def_ids\n+            .map(|def_id| {\n+                let mut state = SipHasher::new();\n+                for node in query.transitive_predecessors(DepNode::MetaData(def_id)) {\n+                    if let Some(hash) = node.hash(tcx) {\n+                        state.write_u64(hash.to_le());\n+                    }\n+                }\n+                (def_id, state.finish())\n+            });\n+\n+        // Now create the `SerializedHash` data structures that others\n+        // will load later.\n+        let hashes =\n+            hashes\n+            .map(|(def_id, hash)| {\n+                let index = builder.add(def_id).unwrap();\n+                SerializedHash {\n+                    node: DepNode::MetaData(index),\n+                    hash: hash\n+                }\n+            });\n+\n+        // Collect these up into a vector.\n+        SerializedMetadataHashes {\n+            hashes: hashes.collect()\n+        }\n+    };\n+\n+    // Encode everything.\n+    let directory = builder.into_directory();\n+    try!(directory.encode(encoder));\n+    try!(serialized_hashes.encode(encoder));\n+\n+    Ok(())\n+}"}, {"sha": "8a345583123705ac673d1d13e89458146ad931ec", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use calculate_svh::SvhCalculate;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n \n@@ -16,6 +19,14 @@ use std::io;\n use std::path::{PathBuf, Path};\n \n pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n+    path(tcx, \"local\")\n+}\n+\n+pub fn metadata_hash_path(tcx: TyCtxt) -> Option<PathBuf> {\n+    path(tcx, \"metadata\")\n+}\n+\n+fn path(tcx: TyCtxt, suffix: &str) -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n     tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n@@ -31,9 +42,10 @@ pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n \n         let crate_name = tcx.crate_name(LOCAL_CRATE);\n         let crate_disambiguator = tcx.crate_disambiguator(LOCAL_CRATE);\n-        let file_name = format!(\"dep-graph-{}-{}.bin\",\n+        let file_name = format!(\"{}-{}.{}.bin\",\n                                 crate_name,\n-                                crate_disambiguator);\n+                                crate_disambiguator,\n+                                suffix);\n         Some(incr_dir.join(file_name))\n     })\n }\n@@ -58,3 +70,22 @@ fn create_dir_racy(path: &Path) -> io::Result<()> {\n         Err(e) => Err(e),\n     }\n }\n+\n+pub trait DepNodeHash {\n+    /// Hash this dep-node, if it is of the kind that we know how to\n+    /// hash.\n+    fn hash<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<u64>;\n+}\n+\n+impl DepNodeHash for DepNode<DefId> {\n+    fn hash<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<u64> {\n+        match *self {\n+            DepNode::Hir(def_id) => {\n+                // FIXME(#32753) -- should we use a distinct hash here\n+                assert!(def_id.is_local());\n+                Some(tcx.calculate_item_hash(def_id))\n+            }\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "481154ba29f8c52889b6605756c06542eed046f1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89041bbe3da48d98c1512b39c819ed42cff4e78/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f89041bbe3da48d98c1512b39c819ed42cff4e78", "patch": "@@ -47,6 +47,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n+use rustc_data_structures::graph::OUTGOING;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use _match;\n@@ -1368,7 +1369,7 @@ fn build_cfg<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // return slot alloca. This can cause errors related to clean-up due to\n // the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n-    for index in cfg.graph.depth_traverse(cfg.entry) {\n+    for index in cfg.graph.depth_traverse(cfg.entry, OUTGOING) {\n         let n = cfg.graph.node_data(index);\n         match tcx.map.find(n.id()) {\n             Some(hir_map::NodeExpr(ex)) => {"}]}