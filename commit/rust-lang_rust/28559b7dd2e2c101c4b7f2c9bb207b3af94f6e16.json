{"sha": "28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NTU5YjdkZDJlMmMxMDFjNGI3ZjJjOWJiMjA3YjNhZjk0ZjZlMTY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-10T21:57:07Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-10T21:57:07Z"}, "message": "Merge #489\n\n489: support std r=matklad a=matklad\n\ncloses #465 \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7bee8dee5216b7eb459edaa0aad54f04dcef3f97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bee8dee5216b7eb459edaa0aad54f04dcef3f97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "html_url": "https://github.com/rust-lang/rust/commit/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b6bc55f542c88b1b0789435219f9dbf38c110f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6bc55f542c88b1b0789435219f9dbf38c110f47", "html_url": "https://github.com/rust-lang/rust/commit/b6bc55f542c88b1b0789435219f9dbf38c110f47"}, {"sha": "6b7699d187d51e8a26ba1a18a217a77dd236458f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b7699d187d51e8a26ba1a18a217a77dd236458f", "html_url": "https://github.com/rust-lang/rust/commit/6b7699d187d51e8a26ba1a18a217a77dd236458f"}], "stats": {"total": 652, "additions": 448, "deletions": 204}, "files": [{"sha": "12e4da4a30fc7ab673f073d0bfab239bfd3507a7", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -9,6 +9,7 @@ build: &rust_build\n     rust: 1.31.1\n     script:\n         - rustup component add rustfmt\n+        - rustup component add rust-src\n         - cargo gen-tests --verify\n         - cargo gen-syntax --verify\n         - cargo test --no-run  # let's measure compile time separately"}, {"sha": "d7d5d5265c575dce3f9f7ec2cacf435d4b97d920", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -35,12 +35,21 @@ impl fmt::Display for RawId {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct Arena<ID: ArenaId, T> {\n     data: Vec<T>,\n     _ty: PhantomData<ID>,\n }\n \n+impl<ID: ArenaId, T: fmt::Debug> fmt::Debug for Arena<ID, T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_struct(\"Arena\")\n+            .field(\"len\", &self.len())\n+            .field(\"data\", &self.data)\n+            .finish()\n+    }\n+}\n+\n #[macro_export]\n macro_rules! impl_arena_id {\n     ($name:ident) => {"}, {"sha": "0dda9548a9696cdb4cb5ece18e18dcfd48faaeda", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -347,11 +347,11 @@ pub fn handle_runnables(\n                 .read()\n                 .file2path(ra_vfs::VfsFile(file_id.0.into()));\n             let res = world.workspaces.iter().find_map(|ws| {\n-                let tgt = ws.target_by_root(&path)?;\n+                let tgt = ws.cargo.target_by_root(&path)?;\n                 let res = CargoTargetSpec {\n-                    package: tgt.package(ws).name(ws).to_string(),\n-                    target: tgt.name(ws).to_string(),\n-                    target_kind: tgt.kind(ws),\n+                    package: tgt.package(&ws.cargo).name(&ws.cargo).to_string(),\n+                    target: tgt.name(&ws.cargo).to_string(),\n+                    target_kind: tgt.kind(&ws.cargo),\n                 };\n                 Some(res)\n             });"}, {"sha": "fd5875a0abca21004c71fcd4bbe2e5c065cd0e44", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 30, "deletions": 177, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -1,163 +1,46 @@\n+mod cargo_workspace;\n+mod sysroot;\n+\n use std::path::{Path, PathBuf};\n \n-use cargo_metadata::{metadata_run, CargoOpt};\n-use ra_syntax::SmolStr;\n-use ra_arena::{Arena, RawId, impl_arena_id};\n-use rustc_hash::FxHashMap;\n-use failure::{format_err, bail};\n+use failure::bail;\n use thread_worker::{WorkerHandle, Worker};\n \n use crate::Result;\n \n-/// `CargoWorksapce` represents the logical structure of, well, a Cargo\n-/// workspace. It pretty closely mirrors `cargo metadata` output.\n-///\n-/// Note that internally, rust analyzer uses a differnet structure:\n-/// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n-/// while this knows about `Pacakges` & `Targets`: purely cargo-related\n-/// concepts.\n-#[derive(Debug, Clone)]\n-pub struct CargoWorkspace {\n-    packages: Arena<Package, PackageData>,\n-    targets: Arena<Target, TargetData>,\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Package(RawId);\n-impl_arena_id!(Package);\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Target(RawId);\n-impl_arena_id!(Target);\n-\n-#[derive(Debug, Clone)]\n-struct PackageData {\n-    name: SmolStr,\n-    manifest: PathBuf,\n-    targets: Vec<Target>,\n-    is_member: bool,\n-    dependencies: Vec<PackageDependency>,\n-}\n+pub use crate::project_model::{\n+    cargo_workspace::{CargoWorkspace, Package, Target, TargetKind},\n+    sysroot::Sysroot,\n+};\n \n #[derive(Debug, Clone)]\n-pub struct PackageDependency {\n-    pub pkg: Package,\n-    pub name: SmolStr,\n+pub struct ProjectWorkspace {\n+    pub(crate) cargo: CargoWorkspace,\n+    pub(crate) sysroot: Sysroot,\n }\n \n-#[derive(Debug, Clone)]\n-struct TargetData {\n-    pkg: Package,\n-    name: SmolStr,\n-    root: PathBuf,\n-    kind: TargetKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum TargetKind {\n-    Bin,\n-    Lib,\n-    Example,\n-    Test,\n-    Bench,\n-    Other,\n-}\n-\n-impl Package {\n-    pub fn name(self, ws: &CargoWorkspace) -> &str {\n-        ws.packages[self].name.as_str()\n-    }\n-    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n-        ws.packages[self].manifest.parent().unwrap()\n-    }\n-    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n-        ws.packages[self].targets.iter().cloned()\n-    }\n-    #[allow(unused)]\n-    pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n-        ws.packages[self].is_member\n-    }\n-    pub fn dependencies<'a>(\n-        self,\n-        ws: &'a CargoWorkspace,\n-    ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n-        ws.packages[self].dependencies.iter()\n-    }\n-}\n-\n-impl Target {\n-    pub fn package(self, ws: &CargoWorkspace) -> Package {\n-        ws.targets[self].pkg\n-    }\n-    pub fn name(self, ws: &CargoWorkspace) -> &str {\n-        ws.targets[self].name.as_str()\n-    }\n-    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n-        ws.targets[self].root.as_path()\n-    }\n-    pub fn kind(self, ws: &CargoWorkspace) -> TargetKind {\n-        ws.targets[self].kind\n+impl ProjectWorkspace {\n+    pub fn discover(path: &Path) -> Result<ProjectWorkspace> {\n+        let cargo_toml = find_cargo_toml(path)?;\n+        let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml)?;\n+        let sysroot = Sysroot::discover(&cargo_toml)?;\n+        let res = ProjectWorkspace { cargo, sysroot };\n+        Ok(res)\n     }\n }\n \n-impl CargoWorkspace {\n-    pub fn from_cargo_metadata(path: &Path) -> Result<CargoWorkspace> {\n-        let cargo_toml = find_cargo_toml(path)?;\n-        let meta = metadata_run(\n-            Some(cargo_toml.as_path()),\n-            true,\n-            Some(CargoOpt::AllFeatures),\n-        )\n-        .map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n-        let mut pkg_by_id = FxHashMap::default();\n-        let mut packages = Arena::default();\n-        let mut targets = Arena::default();\n-\n-        let ws_members = &meta.workspace_members;\n-\n-        for meta_pkg in meta.packages {\n-            let is_member = ws_members.contains(&meta_pkg.id);\n-            let pkg = packages.alloc(PackageData {\n-                name: meta_pkg.name.into(),\n-                manifest: meta_pkg.manifest_path.clone(),\n-                targets: Vec::new(),\n-                is_member,\n-                dependencies: Vec::new(),\n-            });\n-            let pkg_data = &mut packages[pkg];\n-            pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n-            for meta_tgt in meta_pkg.targets {\n-                let tgt = targets.alloc(TargetData {\n-                    pkg,\n-                    name: meta_tgt.name.into(),\n-                    root: meta_tgt.src_path.clone(),\n-                    kind: TargetKind::new(meta_tgt.kind.as_slice()),\n-                });\n-                pkg_data.targets.push(tgt);\n-            }\n-        }\n-        let resolve = meta.resolve.expect(\"metadata executed with deps\");\n-        for node in resolve.nodes {\n-            let source = pkg_by_id[&node.id];\n-            for dep_node in node.deps {\n-                let dep = PackageDependency {\n-                    name: dep_node.name.into(),\n-                    pkg: pkg_by_id[&dep_node.pkg],\n-                };\n-                packages[source].dependencies.push(dep);\n-            }\n-        }\n-\n-        Ok(CargoWorkspace { packages, targets })\n-    }\n-    pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + 'a {\n-        self.packages.iter().map(|(id, _pkg)| id)\n-    }\n-    pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n-        self.packages()\n-            .filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root))\n-            .next()\n-    }\n+pub fn workspace_loader() -> (Worker<PathBuf, Result<ProjectWorkspace>>, WorkerHandle) {\n+    thread_worker::spawn::<PathBuf, Result<ProjectWorkspace>, _>(\n+        \"workspace loader\",\n+        1,\n+        |input_receiver, output_sender| {\n+            input_receiver\n+                .into_iter()\n+                .map(|path| ProjectWorkspace::discover(path.as_path()))\n+                .try_for_each(|it| output_sender.send(it))\n+                .unwrap()\n+        },\n+    )\n }\n \n fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n@@ -174,33 +57,3 @@ fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n     }\n     bail!(\"can't find Cargo.toml at {}\", path.display())\n }\n-\n-impl TargetKind {\n-    fn new(kinds: &[String]) -> TargetKind {\n-        for kind in kinds {\n-            return match kind.as_str() {\n-                \"bin\" => TargetKind::Bin,\n-                \"test\" => TargetKind::Test,\n-                \"bench\" => TargetKind::Bench,\n-                \"example\" => TargetKind::Example,\n-                _ if kind.contains(\"lib\") => TargetKind::Lib,\n-                _ => continue,\n-            };\n-        }\n-        TargetKind::Other\n-    }\n-}\n-\n-pub fn workspace_loader() -> (Worker<PathBuf, Result<CargoWorkspace>>, WorkerHandle) {\n-    thread_worker::spawn::<PathBuf, Result<CargoWorkspace>, _>(\n-        \"workspace loader\",\n-        1,\n-        |input_receiver, output_sender| {\n-            input_receiver\n-                .into_iter()\n-                .map(|path| CargoWorkspace::from_cargo_metadata(path.as_path()))\n-                .try_for_each(|it| output_sender.send(it))\n-                .unwrap()\n-        },\n-    )\n-}"}, {"sha": "8f75188607de1154e4664e947f1cd98468b08fc2", "filename": "crates/ra_lsp_server/src/project_model/cargo_workspace.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -0,0 +1,171 @@\n+use std::path::{Path, PathBuf};\n+\n+use cargo_metadata::{metadata_run, CargoOpt};\n+use ra_syntax::SmolStr;\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use rustc_hash::FxHashMap;\n+use failure::format_err;\n+\n+use crate::Result;\n+\n+/// `CargoWorksapce` represents the logical structure of, well, a Cargo\n+/// workspace. It pretty closely mirrors `cargo metadata` output.\n+///\n+/// Note that internally, rust analyzer uses a differnet structure:\n+/// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n+/// while this knows about `Pacakges` & `Targets`: purely cargo-related\n+/// concepts.\n+#[derive(Debug, Clone)]\n+pub struct CargoWorkspace {\n+    packages: Arena<Package, PackageData>,\n+    targets: Arena<Target, TargetData>,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Package(RawId);\n+impl_arena_id!(Package);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Target(RawId);\n+impl_arena_id!(Target);\n+\n+#[derive(Debug, Clone)]\n+struct PackageData {\n+    name: SmolStr,\n+    manifest: PathBuf,\n+    targets: Vec<Target>,\n+    is_member: bool,\n+    dependencies: Vec<PackageDependency>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct PackageDependency {\n+    pub pkg: Package,\n+    pub name: SmolStr,\n+}\n+\n+#[derive(Debug, Clone)]\n+struct TargetData {\n+    pkg: Package,\n+    name: SmolStr,\n+    root: PathBuf,\n+    kind: TargetKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum TargetKind {\n+    Bin,\n+    Lib,\n+    Example,\n+    Test,\n+    Bench,\n+    Other,\n+}\n+\n+impl TargetKind {\n+    fn new(kinds: &[String]) -> TargetKind {\n+        for kind in kinds {\n+            return match kind.as_str() {\n+                \"bin\" => TargetKind::Bin,\n+                \"test\" => TargetKind::Test,\n+                \"bench\" => TargetKind::Bench,\n+                \"example\" => TargetKind::Example,\n+                _ if kind.contains(\"lib\") => TargetKind::Lib,\n+                _ => continue,\n+            };\n+        }\n+        TargetKind::Other\n+    }\n+}\n+\n+impl Package {\n+    pub fn name(self, ws: &CargoWorkspace) -> &str {\n+        ws.packages[self].name.as_str()\n+    }\n+    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n+        ws.packages[self].manifest.parent().unwrap()\n+    }\n+    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n+        ws.packages[self].targets.iter().cloned()\n+    }\n+    #[allow(unused)]\n+    pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n+        ws.packages[self].is_member\n+    }\n+    pub fn dependencies<'a>(\n+        self,\n+        ws: &'a CargoWorkspace,\n+    ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n+        ws.packages[self].dependencies.iter()\n+    }\n+}\n+\n+impl Target {\n+    pub fn package(self, ws: &CargoWorkspace) -> Package {\n+        ws.targets[self].pkg\n+    }\n+    pub fn name(self, ws: &CargoWorkspace) -> &str {\n+        ws.targets[self].name.as_str()\n+    }\n+    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n+        ws.targets[self].root.as_path()\n+    }\n+    pub fn kind(self, ws: &CargoWorkspace) -> TargetKind {\n+        ws.targets[self].kind\n+    }\n+}\n+\n+impl CargoWorkspace {\n+    pub fn from_cargo_metadata(cargo_toml: &Path) -> Result<CargoWorkspace> {\n+        let meta = metadata_run(Some(cargo_toml), true, Some(CargoOpt::AllFeatures))\n+            .map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n+        let mut pkg_by_id = FxHashMap::default();\n+        let mut packages = Arena::default();\n+        let mut targets = Arena::default();\n+\n+        let ws_members = &meta.workspace_members;\n+\n+        for meta_pkg in meta.packages {\n+            let is_member = ws_members.contains(&meta_pkg.id);\n+            let pkg = packages.alloc(PackageData {\n+                name: meta_pkg.name.into(),\n+                manifest: meta_pkg.manifest_path.clone(),\n+                targets: Vec::new(),\n+                is_member,\n+                dependencies: Vec::new(),\n+            });\n+            let pkg_data = &mut packages[pkg];\n+            pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n+            for meta_tgt in meta_pkg.targets {\n+                let tgt = targets.alloc(TargetData {\n+                    pkg,\n+                    name: meta_tgt.name.into(),\n+                    root: meta_tgt.src_path.clone(),\n+                    kind: TargetKind::new(meta_tgt.kind.as_slice()),\n+                });\n+                pkg_data.targets.push(tgt);\n+            }\n+        }\n+        let resolve = meta.resolve.expect(\"metadata executed with deps\");\n+        for node in resolve.nodes {\n+            let source = pkg_by_id[&node.id];\n+            for dep_node in node.deps {\n+                let dep = PackageDependency {\n+                    name: dep_node.name.into(),\n+                    pkg: pkg_by_id[&dep_node.pkg],\n+                };\n+                packages[source].dependencies.push(dep);\n+            }\n+        }\n+\n+        Ok(CargoWorkspace { packages, targets })\n+    }\n+    pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + 'a {\n+        self.packages.iter().map(|(id, _pkg)| id)\n+    }\n+    pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n+        self.packages()\n+            .filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root))\n+            .next()\n+    }\n+}"}, {"sha": "1dbab57f82ac71b563ba20f42008bea7874a97b7", "filename": "crates/ra_lsp_server/src/project_model/sysroot.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -0,0 +1,132 @@\n+use std::{\n+    path::{Path, PathBuf},\n+    process::Command,\n+};\n+\n+use ra_syntax::SmolStr;\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+\n+use crate::Result;\n+\n+#[derive(Debug, Clone)]\n+pub struct Sysroot {\n+    crates: Arena<SysrootCrate, SysrootCrateData>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SysrootCrate(RawId);\n+impl_arena_id!(SysrootCrate);\n+\n+#[derive(Debug, Clone)]\n+struct SysrootCrateData {\n+    name: SmolStr,\n+    root: PathBuf,\n+    deps: Vec<SysrootCrate>,\n+}\n+\n+impl Sysroot {\n+    pub(crate) fn std(&self) -> Option<SysrootCrate> {\n+        self.by_name(\"std\")\n+    }\n+\n+    pub(crate) fn crates<'a>(&'a self) -> impl Iterator<Item = SysrootCrate> + 'a {\n+        self.crates.iter().map(|(id, _data)| id)\n+    }\n+\n+    pub(super) fn discover(cargo_toml: &Path) -> Result<Sysroot> {\n+        let rustc_output = Command::new(\"rustc\")\n+            .current_dir(cargo_toml.parent().unwrap())\n+            .args(&[\"--print\", \"sysroot\"])\n+            .output()?;\n+        if !rustc_output.status.success() {\n+            failure::bail!(\"failed to locate sysroot\")\n+        }\n+        let stdout = String::from_utf8(rustc_output.stdout)?;\n+        let sysroot_path = Path::new(stdout.trim());\n+        let src = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n+\n+        let mut sysroot = Sysroot {\n+            crates: Arena::default(),\n+        };\n+        for name in SYSROOT_CRATES.trim().lines() {\n+            let root = src.join(format!(\"lib{}\", name)).join(\"lib.rs\");\n+            if root.exists() {\n+                sysroot.crates.alloc(SysrootCrateData {\n+                    name: name.into(),\n+                    root,\n+                    deps: Vec::new(),\n+                });\n+            }\n+        }\n+        if let Some(std) = sysroot.std() {\n+            for dep in STD_DEPS.trim().lines() {\n+                if let Some(dep) = sysroot.by_name(dep) {\n+                    sysroot.crates[std].deps.push(dep)\n+                }\n+            }\n+        }\n+        Ok(sysroot)\n+    }\n+\n+    fn by_name(&self, name: &str) -> Option<SysrootCrate> {\n+        self.crates\n+            .iter()\n+            .find(|(_id, data)| data.name == name)\n+            .map(|(id, _data)| id)\n+    }\n+}\n+\n+impl SysrootCrate {\n+    pub(crate) fn name(self, sysroot: &Sysroot) -> &SmolStr {\n+        &sysroot.crates[self].name\n+    }\n+    pub(crate) fn root(self, sysroot: &Sysroot) -> &Path {\n+        sysroot.crates[self].root.as_path()\n+    }\n+    pub(crate) fn root_dir(self, sysroot: &Sysroot) -> &Path {\n+        self.root(sysroot).parent().unwrap()\n+    }\n+    pub(crate) fn deps<'a>(self, sysroot: &'a Sysroot) -> impl Iterator<Item = SysrootCrate> + 'a {\n+        sysroot.crates[self].deps.iter().map(|&it| it)\n+    }\n+}\n+\n+const SYSROOT_CRATES: &str = \"\n+std\n+core\n+alloc\n+collections\n+libc\n+panic_unwind\n+proc_macro\n+rustc_unicode\n+std_unicode\n+test\n+alloc_jemalloc\n+alloc_system\n+compiler_builtins\n+getopts\n+panic_unwind\n+panic_abort\n+rand\n+term\n+unwind\n+build_helper\n+rustc_asan\n+rustc_lsan\n+rustc_msan\n+rustc_tsan\n+syntax\";\n+\n+const STD_DEPS: &str = \"\n+alloc_jemalloc\n+alloc_system\n+panic_abort\n+rand\n+compiler_builtins\n+unwind\n+rustc_asan\n+rustc_lsan\n+rustc_msan\n+rustc_tsan\n+build_helper\";"}, {"sha": "4f3c231d319c48b1db65eacfdab811e05a197f2a", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -15,36 +15,41 @@ use parking_lot::RwLock;\n use failure::format_err;\n \n use crate::{\n-    project_model::{CargoWorkspace, TargetKind},\n+    project_model::{ProjectWorkspace, TargetKind},\n     Result,\n };\n \n #[derive(Debug)]\n pub struct ServerWorldState {\n     pub roots_to_scan: usize,\n     pub root: PathBuf,\n-    pub workspaces: Arc<Vec<CargoWorkspace>>,\n+    pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n     pub vfs: Arc<RwLock<Vfs>>,\n }\n \n pub struct ServerWorld {\n-    pub workspaces: Arc<Vec<CargoWorkspace>>,\n+    pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n }\n \n impl ServerWorldState {\n-    pub fn new(root: PathBuf, workspaces: Vec<CargoWorkspace>) -> ServerWorldState {\n+    pub fn new(root: PathBuf, workspaces: Vec<ProjectWorkspace>) -> ServerWorldState {\n         let mut change = AnalysisChange::new();\n \n         let mut roots = Vec::new();\n         roots.push(root.clone());\n         for ws in workspaces.iter() {\n-            for pkg in ws.packages() {\n-                roots.push(pkg.root(&ws).to_path_buf());\n+            for pkg in ws.cargo.packages() {\n+                roots.push(pkg.root(&ws.cargo).to_path_buf());\n+            }\n+            for krate in ws.sysroot.crates() {\n+                roots.push(krate.root_dir(&ws.sysroot).to_path_buf())\n             }\n         }\n+        roots.sort();\n+        roots.dedup();\n         let roots_to_scan = roots.len();\n         let (mut vfs, roots) = Vfs::new(roots);\n         for r in roots {\n@@ -53,16 +58,43 @@ impl ServerWorldState {\n         }\n \n         let mut crate_graph = CrateGraph::default();\n-        let mut pkg_to_lib_crate = FxHashMap::default();\n-        let mut pkg_crates = FxHashMap::default();\n         for ws in workspaces.iter() {\n-            for pkg in ws.packages() {\n-                for tgt in pkg.targets(ws) {\n-                    let root = tgt.root(ws);\n+            // First, load std\n+            let mut sysroot_crates = FxHashMap::default();\n+            for krate in ws.sysroot.crates() {\n+                if let Some(file_id) = vfs.load(krate.root(&ws.sysroot)) {\n+                    let file_id = FileId(file_id.0.into());\n+                    sysroot_crates.insert(krate, crate_graph.add_crate_root(file_id));\n+                }\n+            }\n+            for from in ws.sysroot.crates() {\n+                for to in from.deps(&ws.sysroot) {\n+                    let name = to.name(&ws.sysroot);\n+                    if let (Some(&from), Some(&to)) =\n+                        (sysroot_crates.get(&from), sysroot_crates.get(&to))\n+                    {\n+                        crate_graph.add_dep(from, name.clone(), to);\n+                    }\n+                }\n+            }\n+\n+            let libstd = ws\n+                .sysroot\n+                .std()\n+                .and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n+\n+            let mut pkg_to_lib_crate = FxHashMap::default();\n+            let mut pkg_crates = FxHashMap::default();\n+            // Next, create crates for each package, target pair\n+            for pkg in ws.cargo.packages() {\n+                let mut lib_tgt = None;\n+                for tgt in pkg.targets(&ws.cargo) {\n+                    let root = tgt.root(&ws.cargo);\n                     if let Some(file_id) = vfs.load(root) {\n                         let file_id = FileId(file_id.0.into());\n                         let crate_id = crate_graph.add_crate_root(file_id);\n-                        if tgt.kind(ws) == TargetKind::Lib {\n+                        if tgt.kind(&ws.cargo) == TargetKind::Lib {\n+                            lib_tgt = Some(crate_id);\n                             pkg_to_lib_crate.insert(pkg, crate_id);\n                         }\n                         pkg_crates\n@@ -71,9 +103,24 @@ impl ServerWorldState {\n                             .push(crate_id);\n                     }\n                 }\n+\n+                // Set deps to the std and to the lib target of the current package\n+                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    if let Some(to) = lib_tgt {\n+                        if to != from {\n+                            crate_graph.add_dep(from, pkg.name(&ws.cargo).into(), to);\n+                        }\n+                    }\n+                    if let Some(std) = libstd {\n+                        crate_graph.add_dep(from, \"std\".into(), std);\n+                    }\n+                }\n             }\n-            for pkg in ws.packages() {\n-                for dep in pkg.dependencies(ws) {\n+\n+            // Now add a dep ednge from all targets of upstream to the lib\n+            // target of downstream.\n+            for pkg in ws.cargo.packages() {\n+                for dep in pkg.dependencies(&ws.cargo) {\n                     if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n                         for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n                             crate_graph.add_dep(from, dep.name.clone(), to);"}, {"sha": "02d62a259160a22ef08c6d8f66e2fc1e44997ffc", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -1,17 +1,48 @@\n mod support;\n \n+use std::{\n+    collections::HashMap,\n+    time::Instant,\n+};\n+\n use languageserver_types::{\n     CodeActionContext, DocumentFormattingParams, FormattingOptions, Position, Range,\n };\n use ra_lsp_server::req::{\n-    CodeActionParams, CodeActionRequest, Formatting, Runnables, RunnablesParams,\n+    CodeActionParams, CodeActionRequest, Formatting, Runnables, RunnablesParams, CompletionParams, Completion,\n };\n use serde_json::json;\n \n use crate::support::project;\n \n const LOG: &'static str = \"\";\n \n+#[test]\n+fn completes_items_from_standard_library() {\n+    let project_start = Instant::now();\n+    let server = project(\n+        r#\"\n+//- Cargo.toml\n+[package]\n+name = \"foo\"\n+version = \"0.0.0\"\n+\n+//- src/lib.rs\n+use std::collections::Spam;\n+\"#,\n+    );\n+    server.wait_for_feedback(\"workspace loaded\");\n+    eprintln!(\"loading took    {:?}\", project_start.elapsed());\n+    let completion_start = Instant::now();\n+    let res = server.send_request::<Completion>(CompletionParams {\n+        text_document: server.doc_id(\"src/lib.rs\"),\n+        context: None,\n+        position: Position::new(0, 23),\n+    });\n+    assert!(format!(\"{}\", res).contains(\"HashMap\"));\n+    eprintln!(\"completion took {:?}\", completion_start.elapsed());\n+}\n+\n #[test]\n fn test_runnables_no_project() {\n     let server = project(\n@@ -122,7 +153,6 @@ fn test_eggs() {}\n     );\n }\n \n-use std::collections::HashMap;\n #[test]\n fn test_format_document() {\n     let server = project("}, {"sha": "46107b6b6008da81f2695ab4688059a7feb2f0f5", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=28559b7dd2e2c101c4b7f2c9bb207b3af94f6e16", "patch": "@@ -93,9 +93,7 @@ impl Server {\n         R: Request,\n         R::Params: Serialize,\n     {\n-        let id = self.req_id.get();\n-        self.req_id.set(id + 1);\n-        let actual = self.send_request::<R>(id, params);\n+        let actual = self.send_request::<R>(params);\n         match find_mismatch(&expected_resp, &actual) {\n             Some((expected_part, actual_part)) => panic!(\n                 \"JSON mismatch\\nExpected:\\n{}\\nWas:\\n{}\\nExpected part:\\n{}\\nActual part:\\n{}\\n\",\n@@ -108,11 +106,14 @@ impl Server {\n         }\n     }\n \n-    fn send_request<R>(&self, id: u64, params: R::Params) -> Value\n+    pub fn send_request<R>(&self, params: R::Params) -> Value\n     where\n         R: Request,\n         R::Params: Serialize,\n     {\n+        let id = self.req_id.get();\n+        self.req_id.set(id + 1);\n+\n         let r = RawRequest::new::<R>(id, &params);\n         self.send_request_(r)\n     }\n@@ -178,7 +179,7 @@ impl Server {\n \n impl Drop for Server {\n     fn drop(&mut self) {\n-        self.send_request::<Shutdown>(666, ());\n+        self.send_request::<Shutdown>(());\n         let receiver = self.worker.take().unwrap().shutdown();\n         while let Some(msg) = recv_timeout(&receiver) {\n             drop(msg);\n@@ -188,7 +189,7 @@ impl Drop for Server {\n }\n \n fn recv_timeout(receiver: &Receiver<RawMessage>) -> Option<RawMessage> {\n-    let timeout = Duration::from_secs(5);\n+    let timeout = Duration::from_secs(50);\n     select! {\n         recv(receiver) -> msg => msg.ok(),\n         recv(after(timeout)) -> _ => panic!(\"timed out\"),"}]}