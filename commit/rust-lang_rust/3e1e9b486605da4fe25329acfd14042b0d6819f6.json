{"sha": "3e1e9b486605da4fe25329acfd14042b0d6819f6", "node_id": "C_kwDOAAsO6NoAKDNlMWU5YjQ4NjYwNWRhNGZlMjUzMjlhY2ZkMTQwNDJiMGQ2ODE5ZjY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-05T03:46:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-05T03:46:37Z"}, "message": "Rollup merge of #94446 - rusticstuff:remove_dir_all-illumos-fix, r=cuviper\n\nUNIX `remove_dir_all()`: Try recursing first on the slow path\n\nThis only affects the _slow_ code path - if there is no `dirent.d_type` or if it is `DT_UNKNOWN`.\n\nPOSIX specifies that calling `unlink()` or `unlinkat(..., 0)` on a directory is allowed to succeed:\n> The _path_ argument shall not name a directory unless the process has appropriate privileges and the implementation supports using _unlink()_ on directories.\n\nThis however can cause dangling inodes requiring an fsck e.g. on Illumos UFS, so we have to avoid that in the common case. We now just try to recurse into it first and unlink() if we can't open it as a directory.\n\nThe other two commits integrate the Macos x86-64 implementation reducing redundancy. Split into two commits for better reviewing.\n\nFixes #94335.", "tree": {"sha": "bb10ce468b57c53e8122d54a7276aa5cad321bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb10ce468b57c53e8122d54a7276aa5cad321bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e1e9b486605da4fe25329acfd14042b0d6819f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIt0dCRBK7hj4Ov3rIwAArVEIALMa9mZC+g7YQcXjiOLFpTbz\nAz+j+KW+JOf/JEWmwIUHVFlXvJX8A6Cs45/DGMxXgt9ZS3ewKrpn1L9XG9am6yfn\nQI08Kf2t3CZwxvKZDdLyy6ACbZ9L5dBLAGT9Hhg6+Zvqh6dFLtyFXDG3BsLc/U/k\nG4hwcSL/BoQXqrNf6ZJjVaA8M4A+VRpPP5dCqyHbu2owuNGcJV/LjfqKtzvOGALX\nMZrdeYmjARRyuY9FrscI0IUzXt452LA5I5VdJoSkDNakDuGR7HM7yAv86LPr7qls\nQbPJi7Zip5E8Oh2v9ZLLacup15h4EDR1s2ZZJvQk6oOO2j26OrQZOd6ZL/AUG3Q=\n=2Zh7\n-----END PGP SIGNATURE-----\n", "payload": "tree bb10ce468b57c53e8122d54a7276aa5cad321bfc\nparent 69f11fff33f68701d222639a1a5ae991605ec3ab\nparent 735f60c34fc0b13d3aeb3873dcadff03dc141b07\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1646451997 +0100\ncommitter GitHub <noreply@github.com> 1646451997 +0100\n\nRollup merge of #94446 - rusticstuff:remove_dir_all-illumos-fix, r=cuviper\n\nUNIX `remove_dir_all()`: Try recursing first on the slow path\n\nThis only affects the _slow_ code path - if there is no `dirent.d_type` or if it is `DT_UNKNOWN`.\n\nPOSIX specifies that calling `unlink()` or `unlinkat(..., 0)` on a directory is allowed to succeed:\n> The _path_ argument shall not name a directory unless the process has appropriate privileges and the implementation supports using _unlink()_ on directories.\n\nThis however can cause dangling inodes requiring an fsck e.g. on Illumos UFS, so we have to avoid that in the common case. We now just try to recurse into it first and unlink() if we can't open it as a directory.\n\nThe other two commits integrate the Macos x86-64 implementation reducing redundancy. Split into two commits for better reviewing.\n\nFixes #94335.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1e9b486605da4fe25329acfd14042b0d6819f6", "html_url": "https://github.com/rust-lang/rust/commit/3e1e9b486605da4fe25329acfd14042b0d6819f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e1e9b486605da4fe25329acfd14042b0d6819f6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69f11fff33f68701d222639a1a5ae991605ec3ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/69f11fff33f68701d222639a1a5ae991605ec3ab", "html_url": "https://github.com/rust-lang/rust/commit/69f11fff33f68701d222639a1a5ae991605ec3ab"}, {"sha": "735f60c34fc0b13d3aeb3873dcadff03dc141b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/735f60c34fc0b13d3aeb3873dcadff03dc141b07", "html_url": "https://github.com/rust-lang/rust/commit/735f60c34fc0b13d3aeb3873dcadff03dc141b07"}], "stats": {"total": 205, "additions": 74, "deletions": 131}, "files": [{"sha": "0851f512fd01b6644b1e3e98e960c9003a4a8948", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 74, "deletions": 131, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/3e1e9b486605da4fe25329acfd14042b0d6819f6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1e9b486605da4fe25329acfd14042b0d6819f6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=3e1e9b486605da4fe25329acfd14042b0d6819f6", "patch": "@@ -1482,140 +1482,60 @@ mod remove_dir_impl {\n     pub use crate::sys_common::fs::remove_dir_all;\n }\n \n-// Dynamically choose implementation Macos x86-64: modern for 10.10+, fallback for older versions\n-#[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+// Modern implementation using openat(), unlinkat() and fdopendir()\n+#[cfg(not(any(target_os = \"redox\", target_os = \"espidf\")))]\n mod remove_dir_impl {\n-    use super::{cstr, lstat, Dir, InnerReadDir, ReadDir};\n+    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n     use crate::ffi::CStr;\n     use crate::io;\n     use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n     use crate::os::unix::prelude::{OwnedFd, RawFd};\n     use crate::path::{Path, PathBuf};\n     use crate::sync::Arc;\n-    use crate::sys::weak::weak;\n     use crate::sys::{cvt, cvt_r};\n-    use libc::{c_char, c_int, DIR};\n-\n-    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n-        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n-        let fd = cvt_r(|| unsafe {\n-            openat.get().unwrap()(\n-                parent_fd.unwrap_or(libc::AT_FDCWD),\n-                p.as_ptr(),\n-                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n-            )\n-        })?;\n-        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n-    }\n \n-    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n-        weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n-        let ptr = unsafe { fdopendir.get().unwrap()(dir_fd.as_raw_fd()) };\n-        if ptr.is_null() {\n-            return Err(io::Error::last_os_error());\n-        }\n-        let dirp = Dir(ptr);\n-        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n-        let new_parent_fd = dir_fd.into_raw_fd();\n-        // a valid root is not needed because we do not call any functions involving the full path\n-        // of the DirEntrys.\n-        let dummy_root = PathBuf::new();\n-        Ok((\n-            ReadDir {\n-                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n-                end_of_stream: false,\n-            },\n-            new_parent_fd,\n-        ))\n-    }\n-\n-    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n-        weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+    #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\"),))]\n+    use libc::{fdopendir, openat, unlinkat};\n+    #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+    use macos_weak::{fdopendir, openat, unlinkat};\n \n-        let pcstr = cstr(p)?;\n+    #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+    mod macos_weak {\n+        use crate::sys::weak::weak;\n+        use libc::{c_char, c_int, DIR};\n \n-        // entry is expected to be a directory, open as such\n-        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+        fn get_openat_fn() -> Option<unsafe extern \"C\" fn(c_int, *const c_char, c_int) -> c_int> {\n+            weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+            openat.get()\n+        }\n \n-        // open the directory passing ownership of the fd\n-        let (dir, fd) = fdreaddir(fd)?;\n-        for child in dir {\n-            let child = child?;\n-            match child.entry.d_type {\n-                libc::DT_DIR => {\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                }\n-                libc::DT_UNKNOWN => {\n-                    match cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })\n-                    {\n-                        // type unknown - try to unlink\n-                        Err(err) if err.raw_os_error() == Some(libc::EPERM) => {\n-                            // if the file is a directory unlink fails with EPERM\n-                            remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                        }\n-                        result => {\n-                            result?;\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // not a directory -> unlink\n-                    cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })?;\n-                }\n-            }\n+        pub fn has_openat() -> bool {\n+            get_openat_fn().is_some()\n         }\n \n-        // unlink the directory after removing its contents\n-        cvt(unsafe {\n-            unlinkat.get().unwrap()(\n-                parent_fd.unwrap_or(libc::AT_FDCWD),\n-                pcstr.as_ptr(),\n-                libc::AT_REMOVEDIR,\n-            )\n-        })?;\n-        Ok(())\n-    }\n+        pub unsafe fn openat(dirfd: c_int, pathname: *const c_char, flags: c_int) -> c_int {\n+            get_openat_fn().map(|openat| openat(dirfd, pathname, flags)).unwrap_or_else(|| {\n+                crate::sys::unix::os::set_errno(libc::ENOSYS);\n+                -1\n+            })\n+        }\n \n-    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n-        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n-        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n-        // into symlinks.\n-        let attr = lstat(p)?;\n-        if attr.file_type().is_symlink() {\n-            crate::fs::remove_file(p)\n-        } else {\n-            remove_dir_all_recursive(None, p)\n+        pub unsafe fn fdopendir(fd: c_int) -> *mut DIR {\n+            weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n+            fdopendir.get().map(|fdopendir| fdopendir(fd)).unwrap_or_else(|| {\n+                crate::sys::unix::os::set_errno(libc::ENOSYS);\n+                crate::ptr::null_mut()\n+            })\n         }\n-    }\n \n-    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n-        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n-        if openat.get().is_some() {\n-            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n-            remove_dir_all_modern(p)\n-        } else {\n-            // fall back to classic implementation\n-            crate::sys_common::fs::remove_dir_all(p)\n+        pub unsafe fn unlinkat(dirfd: c_int, pathname: *const c_char, flags: c_int) -> c_int {\n+            weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+            unlinkat.get().map(|unlinkat| unlinkat(dirfd, pathname, flags)).unwrap_or_else(|| {\n+                crate::sys::unix::os::set_errno(libc::ENOSYS);\n+                -1\n+            })\n         }\n     }\n-}\n-\n-// Modern implementation using openat(), unlinkat() and fdopendir()\n-#[cfg(not(any(\n-    all(target_os = \"macos\", target_arch = \"x86_64\"),\n-    target_os = \"redox\",\n-    target_os = \"espidf\"\n-)))]\n-mod remove_dir_impl {\n-    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n-    use crate::ffi::CStr;\n-    use crate::io;\n-    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n-    use crate::os::unix::prelude::{OwnedFd, RawFd};\n-    use crate::path::{Path, PathBuf};\n-    use crate::sync::Arc;\n-    use crate::sys::{cvt, cvt_r};\n-    use libc::{fdopendir, openat, unlinkat};\n \n     pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n         let fd = cvt_r(|| unsafe {\n@@ -1683,8 +1603,21 @@ mod remove_dir_impl {\n     fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n         let pcstr = cstr(p)?;\n \n-        // entry is expected to be a directory, open as such\n-        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+        // try opening as directory\n+        let fd = match openat_nofollow_dironly(parent_fd, &pcstr) {\n+            Err(err) if err.raw_os_error() == Some(libc::ENOTDIR) => {\n+                // not a directory - don't traverse further\n+                return match parent_fd {\n+                    // unlink...\n+                    Some(parent_fd) => {\n+                        cvt(unsafe { unlinkat(parent_fd, pcstr.as_ptr(), 0) }).map(drop)\n+                    }\n+                    // ...unless this was supposed to be the deletion root directory\n+                    None => Err(err),\n+                };\n+            }\n+            result => result?,\n+        };\n \n         // open the directory passing ownership of the fd\n         let (dir, fd) = fdreaddir(fd)?;\n@@ -1697,19 +1630,13 @@ mod remove_dir_impl {\n                 Some(false) => {\n                     cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n                 }\n-                None => match cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) }) {\n-                    // type unknown - try to unlink\n-                    Err(err)\n-                        if err.raw_os_error() == Some(libc::EISDIR)\n-                            || err.raw_os_error() == Some(libc::EPERM) =>\n-                    {\n-                        // if the file is a directory unlink fails with EISDIR on Linux and EPERM everyhwere else\n-                        remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                    }\n-                    result => {\n-                        result?;\n-                    }\n-                },\n+                None => {\n+                    // POSIX specifies that calling unlink()/unlinkat(..., 0) on a directory can succeed\n+                    // if the process has the appropriate privileges. This however can causing orphaned\n+                    // directories requiring an fsck e.g. on Solaris and Illumos. So we try recursing\n+                    // into it first instead of trying to unlink() it.\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n             }\n         }\n \n@@ -1720,7 +1647,7 @@ mod remove_dir_impl {\n         Ok(())\n     }\n \n-    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n         // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n         // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n         // into symlinks.\n@@ -1731,4 +1658,20 @@ mod remove_dir_impl {\n             remove_dir_all_recursive(None, p)\n         }\n     }\n+\n+    #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        remove_dir_all_modern(p)\n+    }\n+\n+    #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        if macos_weak::has_openat() {\n+            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n+            remove_dir_all_modern(p)\n+        } else {\n+            // fall back to classic implementation\n+            crate::sys_common::fs::remove_dir_all(p)\n+        }\n+    }\n }"}]}