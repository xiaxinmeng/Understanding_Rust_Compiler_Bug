{"sha": "481068a707679257e2a738b40987246e0420e787", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MTA2OGE3MDc2NzkyNTdlMmE3MzhiNDA5ODcyNDZlMDQyMGU3ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-05T18:27:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-05T18:27:52Z"}, "message": "Auto merge of #62419 - Centril:rollup-82umycq, r=Centril\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #61545 (Implement another internal lints)\n - #62110 (Improve -Ztime-passes)\n - #62133 (Feature gate `rustc` attributes harder)\n - #62158 (Add MemoryExtra in InterpretCx constructor params)\n - #62168 (The (almost) culmination of HirIdification)\n - #62193 (Create async version of the dynamic-drop test)\n - #62369 (Remove `compile-pass` from compiletest)\n - #62380 (rustc_target: avoid negative register counts in the SysV x86_64 ABI.)\n - #62381 (Fix a typo in Write::write_vectored docs)\n - #62390 (Update README.md)\n - #62396 (remove Scalar::is_null_ptr)\n - #62406 (Lint on invalid values passed to x.py --warnings)\n - #62414 (Remove last use of mem::uninitialized in SGX)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c269c3e16e3a69f5d1df500cd18e03c270ce7e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c269c3e16e3a69f5d1df500cd18e03c270ce7e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/481068a707679257e2a738b40987246e0420e787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/481068a707679257e2a738b40987246e0420e787", "html_url": "https://github.com/rust-lang/rust/commit/481068a707679257e2a738b40987246e0420e787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/481068a707679257e2a738b40987246e0420e787/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "853f30052d019a8ebe197a5adff3a29d6716a955", "url": "https://api.github.com/repos/rust-lang/rust/commits/853f30052d019a8ebe197a5adff3a29d6716a955", "html_url": "https://github.com/rust-lang/rust/commit/853f30052d019a8ebe197a5adff3a29d6716a955"}, {"sha": "e89bd8c3089eb8e3b85e989352f7cfb73733c76b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e89bd8c3089eb8e3b85e989352f7cfb73733c76b", "html_url": "https://github.com/rust-lang/rust/commit/e89bd8c3089eb8e3b85e989352f7cfb73733c76b"}], "stats": {"total": 1997, "additions": 1310, "deletions": 687}, "files": [{"sha": "caebdfde8cde1656c0073454da53d7eb1208a587", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -18,7 +18,7 @@ Read [\"Installation\"] from [The Book].\n \n _Note: If you wish to contribute to the compiler, you should read\n [this chapter](https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html)\n-of the rustc-guide instead._\n+of the rustc-guide instead of this section._\n \n ### Building on *nix\n 1. Make sure you have installed the dependencies:"}, {"sha": "242074fec7795efea3d986df5a8d49831b9f31c4", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -306,7 +306,20 @@ fn main() {\n     }\n \n     // This is required for internal lints.\n-    cmd.arg(\"-Zunstable-options\");\n+    if let Some(crate_name) = args.windows(2).find(|a| &*a[0] == \"--crate-name\") {\n+        let crate_name = crate_name[1].to_string_lossy();\n+        if crate_name != \"rustc_version\"\n+            && (crate_name.starts_with(\"rustc\")\n+                || crate_name.starts_with(\"syntax\")\n+                || crate_name == \"arena\"\n+                || crate_name == \"fmt_macros\")\n+        {\n+            cmd.arg(\"-Zunstable-options\");\n+            if stage != \"0\" {\n+                cmd.arg(\"-Wrustc::internal\");\n+            }\n+        }\n+    }\n \n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates"}, {"sha": "20d7548df5c654cef9fea62fb96a70b727e4d5fd", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -405,7 +405,7 @@ impl Config {\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n-        if let Some(value) = flags.warnings {\n+        if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }\n \n@@ -571,7 +571,7 @@ impl Config {\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n-            set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n+            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);"}, {"sha": "0e171e92b3125f0622d011b0e7471761ad7254b4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -33,8 +33,11 @@ pub struct Flags {\n     pub rustc_error_format: Option<String>,\n     pub dry_run: bool,\n \n-    // true => deny\n-    pub warnings: Option<bool>,\n+    // This overrides the deny-warnings configuation option,\n+    // which passes -Dwarnings to the compiler invocations.\n+    //\n+    // true => deny, false => allow\n+    pub deny_warnings: Option<bool>,\n }\n \n pub enum Subcommand {\n@@ -468,7 +471,7 @@ Arguments:\n                 .into_iter()\n                 .map(|p| p.into())\n                 .collect::<Vec<_>>(),\n-            warnings: matches.opt_str(\"warnings\").map(|v| v == \"deny\"),\n+            deny_warnings: parse_deny_warnings(&matches),\n         }\n     }\n }\n@@ -549,3 +552,18 @@ fn split(s: &[String]) -> Vec<String> {\n         .map(|s| s.to_string())\n         .collect()\n }\n+\n+fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n+    match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n+        Some(\"deny\") => Some(true),\n+        Some(\"allow\") => Some(false),\n+        Some(value) => {\n+            eprintln!(\n+                r#\"invalid value for --warnings: {:?}, expected \"allow\" or \"deny\"\"#,\n+                value,\n+                );\n+            process::exit(1);\n+        },\n+        None => None,\n+    }\n+}"}, {"sha": "b5a2b9353c661000378415ecfeb757eb7df42d66", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1 +1 @@\n-Subproject commit abf512fc9cc969dcbea69aa15b44586bbeb13c2d\n+Subproject commit b5a2b9353c661000378415ecfeb757eb7df42d66"}, {"sha": "a4c6e5b85f9a4313ef43cb61d93d9a3e69196ef2", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -12,7 +12,6 @@\n        test(no_crate_inject, attr(deny(warnings))))]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(core_intrinsics)]"}, {"sha": "6ab64a11237003c6567da0149f93332417caaadb", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -74,6 +74,7 @@\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n+#![feature(custom_inner_attributes)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n #![feature(extern_types)]"}, {"sha": "39f130b82ed83177cc1a2332ec50f0c12f1634a4", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -9,7 +9,6 @@\n        test(attr(deny(warnings))))]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(nll)]"}, {"sha": "ee22d0b755a097565df5b53cc4db22c2e5da4922", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -55,7 +55,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// ```\n     /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.id);\n+    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.hir_id);\n     ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n     ///         compute_type_of_item(ccx, item)"}, {"sha": "316ca6424731ce40deda23438bfc2743f58b271a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -95,7 +95,7 @@ impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n         } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(sym::target_feature)) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")"}, {"sha": "9e7898e10b0112f7c4a584710037e6a56fb2108c", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -371,7 +371,6 @@ impl Definitions {\n         None\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n         if def_id.krate == LOCAL_CRATE {"}, {"sha": "889659382d060ac5c02b33845389eeae6c4d2412", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -10,7 +10,8 @@ pub fn check_crate(hir_map: &hir::map::Map<'_>) {\n     let errors = Lock::new(Vec::new());\n \n     par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n-        hir_map.visit_item_likes_in_module(hir_map.local_def_id(*module_id), &mut OuterVisitor {\n+        let local_def_id = hir_map.local_def_id_from_node_id(*module_id);\n+        hir_map.visit_item_likes_in_module(local_def_id, &mut OuterVisitor {\n             hir_map,\n             errors: &errors,\n         });\n@@ -79,7 +80,7 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n                                                        hir_id: HirId,\n                                                        walk: F) {\n         assert!(self.owner_def_index.is_none());\n-        let owner_def_index = self.hir_map.local_def_id_from_hir_id(hir_id).index;\n+        let owner_def_index = self.hir_map.local_def_id(hir_id).index;\n         self.owner_def_index = Some(owner_def_index);\n         walk(self);\n "}, {"sha": "79b343ecfe29a4c1dd68dae3841f4cfea0092661", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -219,7 +219,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n-        self.opt_local_def_id_from_hir_id(id).map(|def_id| {\n+        self.opt_local_def_id(id).map(|def_id| {\n             self.def_path(def_id)\n         })\n     }\n@@ -230,32 +230,30 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id(&self, node: NodeId) -> DefId {\n-        self.opt_local_def_id(node).unwrap_or_else(|| {\n+    pub fn local_def_id_from_node_id(&self, node: NodeId) -> DefId {\n+        self.opt_local_def_id_from_node_id(node).unwrap_or_else(|| {\n             let hir_id = self.node_to_hir_id(node);\n-            bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n+            bug!(\"local_def_id_from_node_id: no entry for `{}`, which has a map of `{:?}`\",\n                  node, self.find_entry(hir_id))\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n-    pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n-        self.opt_local_def_id_from_hir_id(hir_id).unwrap_or_else(|| {\n-            bug!(\"local_def_id_from_hir_id: no entry for `{:?}`, which has a map of `{:?}`\",\n+    pub fn local_def_id(&self, hir_id: HirId) -> DefId {\n+        self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n+            bug!(\"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n                  hir_id, self.find_entry(hir_id))\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n-    pub fn opt_local_def_id_from_hir_id(&self, hir_id: HirId) -> Option<DefId> {\n+    pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<DefId> {\n         let node_id = self.hir_to_node_id(hir_id);\n         self.definitions.opt_local_def_id(node_id)\n     }\n \n     #[inline]\n-    pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n+    pub fn opt_local_def_id_from_node_id(&self, node: NodeId) -> Option<DefId> {\n         self.definitions.opt_local_def_id(node)\n     }\n \n@@ -264,7 +262,6 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         self.definitions.as_local_hir_id(def_id)\n@@ -429,7 +426,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n-        self.local_def_id_from_hir_id(self.body_owner(id))\n+        self.local_def_id(self.body_owner(id))\n     }\n \n     /// Given a `HirId`, returns the `BodyId` associated with it,\n@@ -765,7 +762,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: HirId) -> DefId {\n-        self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n+        self.local_def_id(self.get_module_parent_node(id))\n     }\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n@@ -841,7 +838,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_did(&self, id: HirId) -> DefId {\n-        self.local_def_id_from_hir_id(self.get_parent_item(id))\n+        self.local_def_id(self.get_parent_item(id))\n     }\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n@@ -1247,7 +1244,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         // the user-friendly path, otherwise fall back to stringifying DefPath.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n-                let def_id = map.local_def_id_from_hir_id(id);\n+                let def_id = map.local_def_id(id);\n                 tcx.def_path_str(def_id)\n             } else if let Some(path) = map.def_path_from_hir_id(id) {\n                 path.data.into_iter().map(|elem| {"}, {"sha": "cc532cb064ebe3139953ae91eb6b643bfe5b8b2c", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -83,7 +83,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprKind::Closure(..) = expr.node {\n-            let closure_def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+            let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n                 // Every capture of a closure expression is a local in scope,\n                 // that is moved/copied/borrowed into the closure value, and"}, {"sha": "34f3b8a2c720586ceeddba74cb867633be1b8cfd", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -139,12 +139,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n-                        debug!(\n-                            \"EarlyBound self.infcx.tcx.hir().local_def_id(id)={:?} \\\n-                             def_id={:?}\",\n-                            id,\n-                            def_id\n-                        );\n+                        debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n@@ -162,8 +157,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                             \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                             debruijn_index\n                         );\n-                        debug!(\"self.infcx.tcx.hir().local_def_id(id)={:?}\", id);\n-                        debug!(\"def_id={:?}\", def_id);\n+                        debug!(\"LateBound id={:?} def_id={:?}\", id, def_id);\n                         if debruijn_index == self.current_index && id == def_id {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n@@ -231,12 +225,7 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n             }\n \n             (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n-                debug!(\n-                    \"EarlyBound self.infcx.tcx.hir().local_def_id(id)={:?} \\\n-                     def_id={:?}\",\n-                    id,\n-                    def_id\n-                );\n+                debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now"}, {"sha": "c127e667ce9e95f73b4da61bb19b658de2569273", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -951,8 +951,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id\n-                                == tcx.hir().local_def_id_from_hir_id(opaque_parent_hir_id)\n+                            parent_def_id == tcx.hir()\n+                                                .local_def_id(opaque_parent_hir_id)\n                         };\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {"}, {"sha": "b20f7120bbfa2e9ea7ca7189b52c47017019da96", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -29,7 +29,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(arbitrary_self_types)]"}, {"sha": "2930f7690dd8ed8c4dc39ef1499c295ec8c96f5a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -926,7 +926,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n     {\n         let old_param_env = self.context.param_env;\n         self.context.param_env = self.context.tcx.param_env(\n-            self.context.tcx.hir().local_def_id_from_hir_id(id)\n+            self.context.tcx.hir().local_def_id(id)\n         );\n         f(self);\n         self.context.param_env = old_param_env;\n@@ -1341,6 +1341,7 @@ struct LateLintPassObjects<'a> {\n     lints: &'a mut [LateLintPassObject],\n }\n \n+#[cfg_attr(not(bootstrap), allow(rustc::lint_pass_impl_without_macro))]\n impl LintPass for LateLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n@@ -1500,7 +1501,7 @@ pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         time(tcx.sess, \"module lints\", || {\n             // Run per-module lints\n             par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+                tcx.ensure().lint_mod(tcx.hir().local_def_id_from_node_id(module));\n             });\n         });\n     });\n@@ -1510,6 +1511,7 @@ struct EarlyLintPassObjects<'a> {\n     lints: &'a mut [EarlyLintPassObject],\n }\n \n+#[cfg_attr(not(bootstrap), allow(rustc::lint_pass_impl_without_macro))]\n impl LintPass for EarlyLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()"}, {"sha": "34899736949675cd2142cd4967fa30bc37ccacaa", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,11 +7,12 @@ use crate::lint::{\n };\n use errors::Applicability;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast::Ident;\n+use syntax::ast::{Ident, Item, ItemKind};\n use syntax::symbol::{sym, Symbol};\n+use syntax_pos::ExpnInfo;\n \n-declare_lint! {\n-    pub DEFAULT_HASH_TYPES,\n+declare_tool_lint! {\n+    pub rustc::DEFAULT_HASH_TYPES,\n     Allow,\n     \"forbid HashMap and HashSet and suggest the FxHash* variants\"\n }\n@@ -22,7 +23,7 @@ pub struct DefaultHashTypes {\n \n impl DefaultHashTypes {\n     // we are allowed to use `HashMap` and `HashSet` as identifiers for implementing the lint itself\n-    #[allow(internal)]\n+    #[cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n     pub fn new() -> Self {\n         let mut map = FxHashMap::default();\n         map.insert(sym::HashMap, sym::FxHashMap);\n@@ -36,40 +37,34 @@ impl_lint_pass!(DefaultHashTypes => [DEFAULT_HASH_TYPES]);\n impl EarlyLintPass for DefaultHashTypes {\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         if let Some(replace) = self.map.get(&ident.name) {\n-            let msg = format!(\n-                \"Prefer {} over {}, it has better performance\",\n-                replace, ident\n-            );\n+            let msg = format!(\"Prefer {} over {}, it has better performance\", replace, ident);\n             let mut db = cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, &msg);\n             db.span_suggestion(\n                 ident.span,\n                 \"use\",\n                 replace.to_string(),\n                 Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n             );\n-            db.note(&format!(\n-                \"a `use rustc_data_structures::fx::{}` may be necessary\",\n-                replace\n-            ))\n-            .emit();\n+            db.note(&format!(\"a `use rustc_data_structures::fx::{}` may be necessary\", replace))\n+                .emit();\n         }\n     }\n }\n \n-declare_lint! {\n-    pub USAGE_OF_TY_TYKIND,\n+declare_tool_lint! {\n+    pub rustc::USAGE_OF_TY_TYKIND,\n     Allow,\n     \"usage of `ty::TyKind` outside of the `ty::sty` module\"\n }\n \n-declare_lint! {\n-    pub TY_PASS_BY_REFERENCE,\n+declare_tool_lint! {\n+    pub rustc::TY_PASS_BY_REFERENCE,\n     Allow,\n     \"passing `Ty` or `TyCtxt` by reference\"\n }\n \n-declare_lint! {\n-    pub USAGE_OF_QUALIFIED_TY,\n+declare_tool_lint! {\n+    pub rustc::USAGE_OF_QUALIFIED_TY,\n     Allow,\n     \"using `ty::{Ty,TyCtxt}` instead of importing it\"\n }\n@@ -137,13 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n             }\n-            TyKind::Rptr(\n-                _,\n-                MutTy {\n-                    ty: inner_ty,\n-                    mutbl: Mutability::MutImmutable,\n-                },\n-            ) => {\n+            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::MutImmutable }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;\n@@ -225,3 +214,44 @@ fn gen_args(segment: &PathSegment) -> String {\n \n     String::new()\n }\n+\n+declare_tool_lint! {\n+    pub rustc::LINT_PASS_IMPL_WITHOUT_MACRO,\n+    Allow,\n+    \"`impl LintPass` without the `declare_lint_pass!` or `impl_lint_pass!` macros\"\n+}\n+\n+declare_lint_pass!(LintPassImpl => [LINT_PASS_IMPL_WITHOUT_MACRO]);\n+\n+impl EarlyLintPass for LintPassImpl {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n+            if let Some(last) = lint_pass.path.segments.last() {\n+                if last.ident.name == sym::LintPass {\n+                    match &lint_pass.path.span.ctxt().outer_expn_info() {\n+                        Some(info) if is_lint_pass_expansion(info) => {}\n+                        _ => {\n+                            cx.struct_span_lint(\n+                                LINT_PASS_IMPL_WITHOUT_MACRO,\n+                                lint_pass.path.span,\n+                                \"implementing `LintPass` by hand\",\n+                            )\n+                            .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                            .emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_lint_pass_expansion(expn_info: &ExpnInfo) -> bool {\n+    if expn_info.format.name() == sym::impl_lint_pass {\n+        true\n+    } else if let Some(info) = expn_info.call_site.ctxt().outer_expn_info() {\n+        info.format.name() == sym::declare_lint_pass\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "4c27318c3e19bd62be99587cbc05855b07c86d07", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n@@ -325,7 +325,7 @@ fn has_allow_dead_code_or_lang_attr(\n         return true;\n     }\n \n-    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n@@ -494,7 +494,7 @@ impl DeadVisitor<'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n+        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.hir_id));\n         !field.is_positional()\n             && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()\n@@ -525,7 +525,7 @@ impl DeadVisitor<'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = self.tcx.hir().local_def_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {"}, {"sha": "cba4d0f1598c4436335da9dcd0c54c1251f0764b", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -32,7 +32,7 @@ struct EntryContext<'a, 'tcx> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n-        let def_id = self.map.local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.map.local_def_id(item.hir_id);\n         let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n@@ -142,11 +142,11 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n \n fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Start))\n+        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n-        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else {\n         // No main function\n         let mut err = struct_err!(tcx.sess, E0601,"}, {"sha": "77094604edacf63cb7e51c728ff6f6325cdfbe92", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -930,7 +930,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_expr.hir_id);\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);\n         if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n             for (&var_id, upvar) in upvars.iter() {\n                 let upvar_id = ty::UpvarId {"}, {"sha": "7c15f2ef94d1b4e259d106583e83392482239f5c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -118,7 +118,7 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n             match self.item_refs.get(&*value.as_str()).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                     self.collect_item(item_index, def_id);\n                 },\n                 // Known lang item with attribute on incorrect target."}, {"sha": "c4d60b676b2798131acbbe63fa4b58f1f52ab885", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -363,7 +363,7 @@ fn visit_fn<'tcx>(\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n-    let def_id = ir.tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = ir.tcx.hir().local_def_id(id);\n     let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n \n     // Don't run unused pass for #[derive()]\n@@ -494,7 +494,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        let closure_def_id = ir.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+        let closure_def_id = ir.tcx.hir().local_def_id(expr.hir_id);\n         if let Some(upvars) = ir.tcx.upvars(closure_def_id) {\n             let parent_upvars = ir.tcx.upvars(ir.body_owner);\n             call_caps.extend(upvars.iter().filter_map(|(&var_id, upvar)| {"}, {"sha": "b9a95219d3146be6525e8e0866d1cf8acf69ffa6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -35,7 +35,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n     match item.node {\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+            let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -48,7 +48,7 @@ fn method_might_be_inlined(\n     impl_src: DefId,\n ) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n+    let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.hir_id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal = codegen_attrs.flags.contains(\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n                                                  self.tcx.codegen_fn_attrs(def_id)) {\n@@ -345,7 +345,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if codegen_attrs.contains_extern_indicator() ||\n             codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {"}, {"sha": "26ac1275bb992045a920ab3346a9df27c4ddb81b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -675,7 +675,7 @@ impl<'tcx> ScopeTree {\n                     &format!(\"free_scope: {:?} not recognized by the \\\n                               region scope tree for {:?} / {:?}\",\n                              param_owner,\n-                             self.root_parent.map(|id| tcx.hir().local_def_id_from_hir_id(id)),\n+                             self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n                              self.root_body.map(|hir_id| DefId::local(hir_id.owner))));\n             }\n "}, {"sha": "0839a2b435ae81920db2748bcd2a7f8ccd921be1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -83,15 +83,15 @@ impl Region {\n     fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n-        let def_id = hir_map.local_def_id_from_hir_id(param.hir_id);\n+        let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n         (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n-        let def_id = hir_map.local_def_id_from_hir_id(param.hir_id);\n+        let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n@@ -1326,7 +1326,7 @@ fn object_lifetime_defaults_for_item(\n \n                 add_bounds(&mut set, &param.bounds);\n \n-                let param_def_id = tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+                let param_def_id = tcx.hir().local_def_id(param.hir_id);\n                 for predicate in &generics.where_clause.predicates {\n                     // Look for `type: ...` where clauses.\n                     let data = match *predicate {\n@@ -1370,7 +1370,7 @@ fn object_lifetime_defaults_for_item(\n                                 .enumerate()\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                                    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+                                    let def_id = tcx.hir().local_def_id(id);\n                                     Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                                 })\n                         }\n@@ -1835,7 +1835,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n-                        let scope = self.tcx.hir().local_def_id_from_hir_id(fn_id);\n+                        let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}"}, {"sha": "7757336cf9c366a02c77c78241a4315a26169a77", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -361,7 +361,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(\n+        let impl_def_id = self.tcx.hir().local_def_id(\n             self.tcx.hir().get_parent_item(ii.hir_id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n@@ -598,7 +598,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                let parent_def_id = self.hir().local_def_id_from_hir_id(\n+                let parent_def_id = self.hir().local_def_id(\n                     self.hir().get_parent_item(id));\n                 let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n@@ -766,7 +766,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n@@ -796,7 +796,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n "}, {"sha": "867565d5e0922bec9359ea8d1369dfcb7ca35abb", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -275,17 +275,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_null_ptr(self, cx: &impl HasDataLayout) -> bool {\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n-                data == 0\n-            },\n-            Scalar::Ptr(_) => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n         Scalar::Raw { data: b as u128, size: 1 }"}, {"sha": "a061e6f48f4c0bc554751c55d0ed77778d5febd6", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> MonoItem<'tcx> {\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             MonoItem::GlobalAsm(hir_id) => {\n-                let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+                let def_id = tcx.hir().local_def_id(hir_id);\n                 SymbolName {\n                     name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n                 }"}, {"sha": "26e7cc9004d4ee4d5032a1af0999a42ac51c316a", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -27,6 +27,7 @@ pub trait EncodableWithShorthand: Clone + Eq + Hash {\n     fn variant(&self) -> &Self::Variant;\n }\n \n+#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n@@ -159,6 +160,7 @@ where\n     Ok(decoder.map_encoded_cnum_to_current(cnum))\n }\n \n+#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n #[inline]\n pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n where"}, {"sha": "16fc46b66d9f45df66e7517f45a37d5dcbceac4d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -130,6 +130,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n \n     /// Intern a type\n+    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n     #[inline(never)]\n     fn intern_ty(&self,\n         st: TyKind<'tcx>\n@@ -1251,15 +1252,15 @@ impl<'tcx> TyCtxt<'tcx> {\n             maybe_unused_trait_imports:\n                 resolutions.maybe_unused_trait_imports\n                     .into_iter()\n-                    .map(|id| hir.local_def_id(id))\n+                    .map(|id| hir.local_def_id_from_node_id(id))\n                     .collect(),\n             maybe_unused_extern_crates:\n                 resolutions.maybe_unused_extern_crates\n                     .into_iter()\n-                    .map(|(id, sp)| (hir.local_def_id(id), sp))\n+                    .map(|(id, sp)| (hir.local_def_id_from_node_id(id), sp))\n                     .collect(),\n             glob_map: resolutions.glob_map.into_iter().map(|(id, names)| {\n-                (hir.local_def_id(id), names)\n+                (hir.local_def_id_from_node_id(id), names)\n             }).collect(),\n             extern_prelude: resolutions.extern_prelude,\n             hir_map: hir,\n@@ -2107,6 +2108,7 @@ impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n+#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n         &self.0.sty\n@@ -2321,6 +2323,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(converted_sig)\n     }\n \n+    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n     #[inline]\n     pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         self.interners.intern_ty(st)"}, {"sha": "411b18e043a203a36dd5e3a575e3c9564b86c235", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -18,6 +18,7 @@ impl FlagComputation {\n         }\n     }\n \n+    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n     pub fn for_sty(st: &ty::TyKind<'_>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_sty(st);\n@@ -61,6 +62,7 @@ impl FlagComputation {\n         } // otherwise, this binder captures nothing\n     }\n \n+    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n     fn add_sty(&mut self, st: &ty::TyKind<'_>) {\n         match st {\n             &ty::Bool |"}, {"sha": "4453624fa4502334a58a9d8e118ed70dd3fa6f28", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> DefIdForest {\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n-        let crate_id = tcx.hir().local_def_id_from_hir_id(CRATE_HIR_ID);\n+        let crate_id = tcx.hir().local_def_id(CRATE_HIR_ID);\n         DefIdForest::from_id(crate_id)\n     }\n "}, {"sha": "6701c20b0a3660e43e659bb125938244e0c1de9a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,7 +1,5 @@\n // ignore-tidy-filelength\n \n-#![allow(usage_of_ty_tykind)]\n-\n pub use self::Variance::*;\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n@@ -484,6 +482,7 @@ bitflags! {\n     }\n }\n \n+#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n pub struct TyS<'tcx> {\n     pub sty: TyKind<'tcx>,\n     pub flags: TypeFlags,\n@@ -541,29 +540,29 @@ impl<'tcx> Hash for TyS<'tcx> {\n impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n-            TyKind::Bool |\n-            TyKind::Char |\n-            TyKind::Int(_) |\n-            TyKind::Uint(_) |\n-            TyKind::Float(_) |\n-            TyKind::Infer(InferTy::IntVar(_)) |\n-            TyKind::Infer(InferTy::FloatVar(_)) |\n-            TyKind::Infer(InferTy::FreshIntTy(_)) |\n-            TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n-            TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n+            Bool |\n+            Char |\n+            Int(_) |\n+            Uint(_) |\n+            Float(_) |\n+            Infer(InferTy::IntVar(_)) |\n+            Infer(InferTy::FloatVar(_)) |\n+            Infer(InferTy::FreshIntTy(_)) |\n+            Infer(InferTy::FreshFloatTy(_)) => true,\n+            Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n     }\n \n     pub fn is_suggestable(&self) -> bool {\n         match self.sty {\n-            TyKind::Opaque(..) |\n-            TyKind::FnDef(..) |\n-            TyKind::FnPtr(..) |\n-            TyKind::Dynamic(..) |\n-            TyKind::Closure(..) |\n-            TyKind::Infer(..) |\n-            TyKind::Projection(..) => false,\n+            Opaque(..) |\n+            FnDef(..) |\n+            FnPtr(..) |\n+            Dynamic(..) |\n+            Closure(..) |\n+            Infer(..) |\n+            Projection(..) => false,\n             _ => true,\n         }\n     }\n@@ -2816,7 +2815,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                            parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssocItem {\n-        let def_id = self.hir().local_def_id_from_hir_id(trait_item_ref.id.hir_id);\n+        let def_id = self.hir().local_def_id(trait_item_ref.id.hir_id);\n         let (kind, has_self) = match trait_item_ref.kind {\n             hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n             hir::AssocItemKind::Method { has_self } => {\n@@ -2842,7 +2841,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                           parent_def_id: DefId,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssocItem {\n-        let def_id = self.hir().local_def_id_from_hir_id(impl_item_ref.id.hir_id);\n+        let def_id = self.hir().local_def_id(impl_item_ref.id.hir_id);\n         let (kind, has_self) = match impl_item_ref.kind {\n             hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n             hir::AssocItemKind::Method { has_self } => {\n@@ -3114,7 +3113,7 @@ impl Iterator for AssocItemsIterator<'_> {\n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n-    let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n@@ -3178,14 +3177,14 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n             tcx.arena.alloc_from_iter(\n                 trait_item_refs.iter()\n                                .map(|trait_item_ref| trait_item_ref.id)\n-                               .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n+                               .map(|id| tcx.hir().local_def_id(id.hir_id))\n             )\n         }\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             tcx.arena.alloc_from_iter(\n                 impl_item_refs.iter()\n                               .map(|impl_item_ref| impl_item_ref.id)\n-                              .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n+                              .map(|id| tcx.hir().local_def_id(id.hir_id))\n             )\n         }\n         hir::ItemKind::TraitAlias(..) => &[],"}, {"sha": "5d17080a9b2bce0c30de8ca16264a3668c105f3e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,7 @@\n //! This module contains `TyKind` and its major components.\n \n+#![cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;"}, {"sha": "2bb9c258f8b67b14fb2af647de32ebd61513d30d", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -186,7 +186,7 @@ pub(super) fn trait_impls_of_provider(\n         }\n \n         for &hir_id in tcx.hir().trait_impls(trait_id) {\n-            add_impl(tcx.hir().local_def_id_from_hir_id(hir_id));\n+            add_impl(tcx.hir().local_def_id(hir_id));\n         }\n     }\n "}, {"sha": "8e7936dae0976ca7563923d9531c427d6d193521", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -170,7 +170,7 @@ pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) ->\n         }\n     }\n \n-    print_time_passes_entry_internal(what, dur);\n+    print_time_passes_entry(true, what, dur);\n \n     TIME_DEPTH.with(|slot| slot.set(old));\n \n@@ -182,18 +182,6 @@ pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n         return\n     }\n \n-    let old = TIME_DEPTH.with(|slot| {\n-        let r = slot.get();\n-        slot.set(r + 1);\n-        r\n-    });\n-\n-    print_time_passes_entry_internal(what, dur);\n-\n-    TIME_DEPTH.with(|slot| slot.set(old));\n-}\n-\n-fn print_time_passes_entry_internal(what: &str, dur: Duration) {\n     let indentation = TIME_DEPTH.with(|slot| slot.get());\n \n     let mem_string = match get_resident() {"}, {"sha": "8d380c47bc4a371360b12198f7901b82dd9cd860", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -2,7 +2,6 @@\n #![feature(rustc_private)]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n pub mod expand;"}, {"sha": "34db080ef66332e6607d53d774bdb5008a549e55", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -198,7 +198,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     cfg: &cfg::CFG,\n ) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n     let owner_id = tcx.hir().body_owner(body_id);\n-    let owner_def_id = tcx.hir().local_def_id_from_hir_id(owner_id);\n+    let owner_def_id = tcx.hir().local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir().body(body_id);"}, {"sha": "b857c625ec2e76c8b0d4cca48928f53b07453985", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -2,7 +2,6 @@\n \n #![allow(non_camel_case_types)]\n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(in_band_lifetimes)]"}, {"sha": "dbcb20315520bb24fbc1e72d402c5e96fbde963b", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -23,7 +23,6 @@\n #![feature(trusted_len)]\n #![feature(mem_take)]\n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n use back::write::{create_target_machine, create_informational_target_machine};"}, {"sha": "c5553fa93cf67c2c5ce650c486533ceb04b6782c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -84,7 +84,7 @@ fn reachable_non_generics_provider(\n             // let it through if it's included statically.\n             match tcx.hir().get(hir_id) {\n                 Node::ForeignItem(..) => {\n-                    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+                    let def_id = tcx.hir().local_def_id(hir_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n                     } else {\n@@ -104,7 +104,7 @@ fn reachable_non_generics_provider(\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {\n-                    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+                    let def_id = tcx.hir().local_def_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened"}, {"sha": "7bb2cc7c08977c0a03dd05a1f7e6225cf591437c", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1554,7 +1554,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             let total_llvm_time = Instant::now().duration_since(llvm_start_time);\n             // This is the top-level timing for all of LLVM, set the time-depth\n             // to zero.\n-            set_time_depth(0);\n+            set_time_depth(1);\n             print_time_passes_entry(cgcx.time_passes,\n                                     \"LLVM passes\",\n                                     total_llvm_time);"}, {"sha": "a554bf7761c93cbfeeac7732c1b54447e231f037", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -25,7 +25,7 @@ use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n-use rustc::util::common::{time, print_time_passes_entry};\n+use rustc::util::common::{time, print_time_passes_entry, set_time_depth, time_depth};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n@@ -639,9 +639,12 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n+    let time_depth = time_depth();\n+    set_time_depth(time_depth + 1);\n     print_time_passes_entry(tcx.sess.time_passes(),\n                             \"codegen to LLVM IR\",\n                             total_codegen_time);\n+    set_time_depth(time_depth);\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n "}, {"sha": "d0f4b0a870b5ab0a6cfca6202be00ff41c183380", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -14,7 +14,6 @@\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "f38b672afd939ac61c57719185e5c0003ecdf162", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -17,7 +17,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use]"}, {"sha": "f562744dbe753a3a53bba338551b608c9ef47b85", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -33,7 +33,7 @@ impl SymbolNamesTest<'tcx> {\n     fn process_attrs(&mut self,\n                      hir_id: hir::HirId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+        let def_id = tcx.hir().local_def_id(hir_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names"}, {"sha": "38dfb675237b5d256c378b1da81fe1f5cf3a44db", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -27,6 +27,7 @@\n #![cfg_attr(test, feature(test))]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n \n #[macro_use]\n extern crate log;"}, {"sha": "e615f8a4846920915940dbbdd53e9863ffecba4c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -17,7 +17,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n pub extern crate getopts;\n@@ -38,7 +37,8 @@ use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::util::common::{time, ErrorReported, install_panic_hook};\n+use rustc::util::common::{ErrorReported, install_panic_hook, print_time_passes_entry};\n+use rustc::util::common::{set_time_depth, time};\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -54,11 +54,12 @@ use std::default::Default;\n use std::env;\n use std::ffi::OsString;\n use std::io::{self, Read, Write};\n+use std::mem;\n use std::panic::{self, catch_unwind};\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use std::mem;\n+use std::time::Instant;\n \n use syntax::ast;\n use syntax::source_map::FileLoader;\n@@ -72,7 +73,7 @@ pub mod pretty;\n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n \n-/// Exit status code used for compilation failures and  invalid flags.\n+/// Exit status code used for compilation failures and invalid flags.\n pub const EXIT_FAILURE: i32 = 1;\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n@@ -118,6 +119,18 @@ pub struct DefaultCallbacks;\n \n impl Callbacks for DefaultCallbacks {}\n \n+#[derive(Default)]\n+pub struct TimePassesCallbacks {\n+    time_passes: bool,\n+}\n+\n+impl Callbacks for TimePassesCallbacks {\n+    fn config(&mut self, config: &mut interface::Config) {\n+        self.time_passes =\n+            config.opts.debugging_opts.time_passes || config.opts.debugging_opts.time;\n+    }\n+}\n+\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n@@ -1169,18 +1182,24 @@ pub fn init_rustc_env_logger() {\n }\n \n pub fn main() {\n+    let start = Instant::now();\n     init_rustc_env_logger();\n+    let mut callbacks = TimePassesCallbacks::default();\n     let result = report_ices_to_stderr_if_any(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n                 early_error(ErrorOutputType::default(),\n                             &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg))\n             }))\n             .collect::<Vec<_>>();\n-        run_compiler(&args, &mut DefaultCallbacks, None, None)\n+        run_compiler(&args, &mut callbacks, None, None)\n     }).and_then(|result| result);\n-    process::exit(match result {\n+    let exit_code = match result {\n         Ok(_) => EXIT_SUCCESS,\n         Err(_) => EXIT_FAILURE,\n-    });\n+    };\n+    // The extra `\\t` is necessary to align this label with the others.\n+    set_time_depth(0);\n+    print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n+    process::exit(exit_code);\n }"}, {"sha": "f314af43f99a431bcaf25987c8b9f7ce48bcda35", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -465,7 +465,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id_from_hir_id(id)))\n+        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id)))\n     }\n }\n \n@@ -877,7 +877,7 @@ fn print_with_analysis(\n     let mut print = || match ppm {\n         PpmMir | PpmMirCFG => {\n             if let Some(nodeid) = nodeid {\n-                let def_id = tcx.hir().local_def_id(nodeid);\n+                let def_id = tcx.hir().local_def_id_from_node_id(nodeid);\n                 match ppm {\n                     PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n                     PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),"}, {"sha": "3269b85d0dd13243c39a69b3e314e26e89fe9d5f", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -10,7 +10,6 @@\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[allow(unused_extern_crates)]"}, {"sha": "ba893f5f9369161374f9609c7b6ba1da677103bb", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -111,7 +111,7 @@ impl IfThisChanged<'tcx> {\n     }\n \n     fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n+        let def_id = self.tcx.hir().local_def_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id);\n         for attr in attrs {\n             if attr.check_name(ATTR_IF_THIS_CHANGED) {"}, {"sha": "569aa78c9d4b3f0df6d0da39cd4a4791692f9de1", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -9,7 +9,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use] extern crate rustc;"}, {"sha": "c23bb6b47f49080b925903cce1425e87c6891f92", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -500,7 +500,7 @@ impl DirtyCleanVisitor<'tcx> {\n     }\n \n     fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n+        let def_id = self.tcx.hir().local_def_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,"}, {"sha": "4bc50c24e817c216889e7ce06b4d63625f312b87", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,7 +7,6 @@\n #![cfg_attr(unix, feature(libc))]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![allow(unused_imports)]"}, {"sha": "9a5eb2b93d574f0330f196c8e81cce978cdf669c", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -899,9 +899,10 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n             });\n         }, {\n             par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                tcx.ensure().check_mod_loops(tcx.hir().local_def_id(module));\n-                tcx.ensure().check_mod_attrs(tcx.hir().local_def_id(module));\n-                tcx.ensure().check_mod_unstable_api_usage(tcx.hir().local_def_id(module));\n+                tcx.ensure().check_mod_loops(tcx.hir().local_def_id_from_node_id(module));\n+                tcx.ensure().check_mod_attrs(tcx.hir().local_def_id_from_node_id(module));\n+                tcx.ensure().check_mod_unstable_api_usage(\n+                    tcx.hir().local_def_id_from_node_id(module));\n             });\n         });\n     });\n@@ -924,9 +925,9 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     // \"not all control paths return a value\" is reported here.\n                     //\n                     // maybe move the check to a MIR pass?\n-                    tcx.ensure().check_mod_liveness(tcx.hir().local_def_id(module));\n+                    tcx.ensure().check_mod_liveness(tcx.hir().local_def_id_from_node_id(module));\n \n-                    tcx.ensure().check_mod_intrinsics(tcx.hir().local_def_id(module));\n+                    tcx.ensure().check_mod_intrinsics(tcx.hir().local_def_id_from_node_id(module));\n                 });\n             });\n         });\n@@ -986,7 +987,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         }, {\n             time(sess, \"privacy checking modules\", || {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n+                    tcx.ensure().check_mod_privacy(tcx.hir().local_def_id_from_node_id(module));\n                 });\n             });\n         });"}, {"sha": "56180bcad06d33d4a11073f00864e020f198cb13", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -16,7 +16,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     let mut finder = Finder { decls: None };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n-    finder.decls.map(|id| tcx.hir().local_def_id_from_hir_id(id))\n+    finder.decls.map(|id| tcx.hir().local_def_id(id))\n }\n \n struct Finder {"}, {"sha": "267b09bae35e427604ce0ae16f2d1ca737685ff9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) => {\n-                let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+                let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n                 self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n             }\n             _ => ()\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    let def_id = cx.tcx.hir().local_def_id_from_hir_id(struct_field.hir_id);\n+                    let def_id = cx.tcx.hir().local_def_id(struct_field.hir_id);\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.type_of(def_id));\n                 }\n@@ -500,21 +500,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n         let prfn = match cx.tcx.extern_mod_stmt_cnum(def_id) {\n             Some(cnum) => cx.tcx.plugin_registrar_fn(cnum),\n             None => {\n@@ -973,7 +973,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n         if let hir::ItemKind::Union(ref vdata, _) = item.node {\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(\n-                    ctx.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n+                    ctx.tcx.hir().local_def_id(field.hir_id));\n                 if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,\n@@ -1216,7 +1216,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n         use rustc::ty::Predicate::*;\n \n         if cx.tcx.features().trivial_bounds {\n-            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in &predicates.predicates {\n                 let predicate_kind_name = match predicate {\n@@ -1541,7 +1541,7 @@ impl ExplicitOutlivesRequirements {\n         ty_generics: &'tcx ty::Generics,\n     ) -> Vec<ty::Region<'tcx>> {\n         let index = ty_generics.param_def_id_to_index[\n-            &tcx.hir().local_def_id_from_hir_id(param.hir_id)];\n+            &tcx.hir().local_def_id(param.hir_id)];\n \n         match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n@@ -1659,7 +1659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n         use rustc::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n-        let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n             | hir::ItemKind::Enum(_, ref hir_generics)\n             | hir::ItemKind::Union(_, ref hir_generics) = item.node"}, {"sha": "fb02782e6d3200fca67125d7dc978ca5bd3aa765", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -20,7 +20,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use]\n@@ -487,15 +486,17 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n \n pub fn register_internals(store: &mut lint::LintStore, sess: Option<&Session>) {\n     store.register_early_pass(sess, false, false, box DefaultHashTypes::new());\n+    store.register_early_pass(sess, false, false, box LintPassImpl);\n     store.register_late_pass(sess, false, false, false, box TyTyKind);\n     store.register_group(\n         sess,\n         false,\n-        \"internal\",\n+        \"rustc::internal\",\n         None,\n         vec![\n             LintId::of(DEFAULT_HASH_TYPES),\n             LintId::of(USAGE_OF_TY_TYKIND),\n+            LintId::of(LINT_PASS_IMPL_WITHOUT_MACRO),\n             LintId::of(TY_PASS_BY_REFERENCE),\n             LintId::of(USAGE_OF_QUALIFIED_TY),\n         ],"}, {"sha": "84f068ab50a22c5f792420c65b5a7195aca2861c", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -20,7 +20,7 @@ pub enum MethodLateContext {\n }\n \n pub fn method_context(cx: &LateContext<'_, '_>, id: hir::HirId) -> MethodLateContext {\n-    let def_id = cx.tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = cx.tcx.hir().local_def_id(id);\n     let item = cx.tcx.associated_item(def_id);\n     match item.container {\n         ty::TraitContainer(..) => MethodLateContext::TraitAutoImpl,"}, {"sha": "fdfc6f68590a4b308abf99a4a2bbdb1257f2a5b5", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -888,7 +888,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl) {\n-        let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n         let inputs = if sig.c_variadic {\n@@ -912,7 +912,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n-        let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = self.cx.tcx.hir().local_def_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n         self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n@@ -941,7 +941,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n-            let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n             let layout = match cx.layout_of(ty) {"}, {"sha": "53bbecd0e6a1d242ac127d544253f06b1d1c1ddc", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,6 @@\n #![feature(proc_macro_hygiene)]\n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n \n #![recursion_limit=\"128\"]\n "}, {"sha": "c7f57be642618c1ef9be5c2ec908bc4803a1c398", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -667,7 +667,7 @@ impl EncodeContext<'tcx> {\n         (id, md, attrs, vis): (hir::HirId, &hir::Mod, &[ast::Attribute], &hir::Visibility),\n     ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n@@ -683,7 +683,7 @@ impl EncodeContext<'tcx> {\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id_from_hir_id(item_id.id).index\n+                tcx.hir().local_def_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -1105,7 +1105,7 @@ impl EncodeContext<'tcx> {\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n                 let ctor = struct_def.ctor_hir_id()\n-                    .map(|ctor_hir_id| tcx.hir().local_def_id_from_hir_id(ctor_hir_id).index);\n+                    .map(|ctor_hir_id| tcx.hir().local_def_id(ctor_hir_id).index);\n \n                 let repr_options = get_repr_options(tcx, def_id);\n \n@@ -1194,7 +1194,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy_seq(fm.items\n                         .iter()\n-                        .map(|foreign_item| tcx.hir().local_def_id_from_hir_id(\n+                        .map(|foreign_item| tcx.hir().local_def_id(\n                             foreign_item.hir_id).index))\n                 }\n                 hir::ItemKind::Enum(..) => {\n@@ -1313,7 +1313,7 @@ impl EncodeContext<'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n         use syntax::print::pprust;\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: pprust::tts_to_string(&macro_def.body.trees().collect::<Vec<_>>()),\n@@ -1656,7 +1656,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.node {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => {} // ignore these\n@@ -1666,7 +1666,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(ni.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n         self.record(def_id,\n                           EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n@@ -1678,7 +1678,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         intravisit::walk_variant(self, v, g, id);\n \n         if let Some(ref discr) = v.node.disr_expr {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(discr.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(discr.hir_id);\n             self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n         }\n     }\n@@ -1691,7 +1691,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         self.encode_info_for_ty(ty);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n     }\n }\n@@ -1710,7 +1710,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n         for param in &generics.params {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => continue,\n                 GenericParamKind::Type { ref default, .. } => {\n@@ -1730,7 +1730,7 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n             hir::TyKind::Array(_, ref length) => {\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(length.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(length.hir_id);\n                 self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n             }\n             _ => {}\n@@ -1740,7 +1740,7 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprKind::Closure(..) => {\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n                 self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n             }\n             _ => {}\n@@ -1752,7 +1752,7 @@ impl EncodeContext<'tcx> {\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.node {\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n@@ -1788,7 +1788,7 @@ impl EncodeContext<'tcx> {\n \n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                    let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(ctor_hir_id);\n+                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n                     self.record(ctor_def_id,\n                                 EncodeContext::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n@@ -1823,7 +1823,7 @@ struct ImplVisitor<'tcx> {\n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Impl(..) = item.node {\n-            let impl_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls\n                     .entry(trait_ref.def_id)"}, {"sha": "b2e40282d93323a04654b04ec5ed1bb249ca382b", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -25,11 +25,11 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         };\n \n         let foreign_items = fm.items.iter()\n-            .map(|it| self.tcx.hir().local_def_id_from_hir_id(it.hir_id))\n+            .map(|it| self.tcx.hir().local_def_id(it.hir_id))\n             .collect();\n         self.modules.push(ForeignModule {\n             foreign_items,\n-            def_id: self.tcx.hir().local_def_id_from_hir_id(it.hir_id),\n+            def_id: self.tcx.hir().local_def_id(it.hir_id),\n         });\n     }\n "}, {"sha": "826349362db2500556cbfee242377c088aaecf3d", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -15,7 +15,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n extern crate libc;"}, {"sha": "5da5384f8aaa792a8ada31b192c73e815aeebe48", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -56,7 +56,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 name: None,\n                 kind: cstore::NativeUnknown,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir().local_def_id_from_hir_id(it.hir_id)),\n+                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id)),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "40388722bcac933aeb2006b0b5dbc9c333e0bc50", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -20,7 +20,7 @@ use rustc::mir::{\n     ConstraintCategory, Local, Location,\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common::{self, ErrorReported};\n+use rustc::util::common::ErrorReported;\n use rustc_data_structures::binary_search_util;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -468,22 +468,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n-    ) -> Option<ClosureRegionRequirements<'tcx>> {\n-        common::time_ext(\n-            infcx.tcx.sess.time_extended(),\n-            Some(infcx.tcx.sess),\n-            &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n-            || self.solve_inner(infcx, body, upvars, mir_def_id, errors_buffer),\n-        )\n-    }\n-\n-    fn solve_inner(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n-        errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'tcx>> {\n         self.propagate_constraints(body);\n "}, {"sha": "3e090aed5227006bcd8cdc7bdabd73a71f282834", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -768,7 +768,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n                 local_id: *late_bound,\n             };\n             let name = tcx.hir().name(hir_id).as_interned_str();\n-            let region_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+            let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,\n                 bound_region: ty::BoundRegion::BrNamed(region_def_id, name),"}, {"sha": "8948d1c4b3663db2e3740850577df43c2e0d9664", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -69,7 +69,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n             let fn_sig = cx.tables().liberated_fn_sigs()[id].clone();\n-            let fn_def_id = tcx.hir().local_def_id_from_hir_id(id);\n+            let fn_def_id = tcx.hir().local_def_id(id);\n \n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n@@ -534,7 +534,7 @@ where\n     let span = tcx_hir.span(fn_id);\n \n     let hir_tables = hir.tables();\n-    let fn_def_id = tcx_hir.local_def_id_from_hir_id(fn_id);\n+    let fn_def_id = tcx_hir.local_def_id(fn_id);\n \n     // Gather the upvars of a closure, if any.\n     let mut upvar_mutbls = vec![];"}, {"sha": "e95ef0caaafaff626f1802cc7f7444336b172e43", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -47,7 +47,7 @@ pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n+    InterpCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), Default::default())\n }\n \n pub(crate) fn eval_promoted<'mir, 'tcx>(\n@@ -632,7 +632,12 @@ pub fn const_eval_raw_provider<'tcx>(\n     }\n \n     let span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = InterpCx::new(tcx.at(span), key.param_env, CompileTimeInterpreter::new());\n+    let mut ecx = InterpCx::new(\n+        tcx.at(span),\n+        key.param_env,\n+        CompileTimeInterpreter::new(),\n+        Default::default()\n+    );\n \n     let res = ecx.load_mir(cid.instance.def);\n     res.map(|body| {"}, {"sha": "618c047e77359122d214aebf0e331d595105d377", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -331,7 +331,7 @@ An if-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding instead. For instance:\n \n-```compile_pass\n+```\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -360,7 +360,7 @@ A while-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding inside a `loop` instead. For instance:\n \n-```compile_pass,no_run\n+```no_run\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n "}, {"sha": "e7663ddaa9879e1726c6fb5329b70c680b0dd7d0", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -542,7 +542,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let def_id = cx.tcx.hir().local_def_id_from_hir_id(count.hir_id);\n+            let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n             let substs = InternalSubsts::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let instance = ty::Instance::resolve(\n                 cx.tcx.global_tcx(),\n@@ -910,9 +910,9 @@ fn convert_path_expr<'a, 'tcx>(\n         Res::Def(DefKind::ConstParam, def_id) => {\n             let hir_id = cx.tcx.hir().as_local_hir_id(def_id).unwrap();\n             let item_id = cx.tcx.hir().get_parent_node(hir_id);\n-            let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(item_id);\n+            let item_def_id = cx.tcx.hir().local_def_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);\n-            let local_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n+            let local_def_id = cx.tcx.hir().local_def_id(hir_id);\n             let index = generics.param_def_id_to_index[&local_def_id];\n             let name = cx.tcx.hir().name(hir_id).as_interned_str();\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n@@ -1191,7 +1191,7 @@ fn capture_upvar<'tcx>(\n ) -> ExprRef<'tcx> {\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id_from_hir_id(closure_expr.hir_id).to_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id).to_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);"}, {"sha": "3d9349df5bedb3d490b4307394018180cc05be91", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -54,7 +54,7 @@ pub struct Cx<'a, 'tcx> {\n impl<'a, 'tcx> Cx<'a, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'tcx>, src_id: hir::HirId) -> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n-        let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n+        let src_def_id = tcx.hir().local_def_id(src_id);\n         let tables = tcx.typeck_tables_of(src_def_id);\n         let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n "}, {"sha": "fd5290ee0400c52f467171a4f97241d8a8fa3594", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -196,12 +196,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n+    pub fn new(\n+        tcx: TyCtxtAt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        machine: M,\n+        memory_extra: M::MemoryExtra,\n+    ) -> Self {\n         InterpCx {\n             machine,\n             tcx,\n             param_env,\n-            memory: Memory::new(tcx),\n+            memory: Memory::new(tcx, memory_extra),\n             stack: Vec::new(),\n             vtables: FxHashMap::default(),\n         }"}, {"sha": "ff560360f0ad1f186bc97eefec465a2b1d89e178", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -73,7 +73,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in memory. A reference to this is available when `AllocExtra`\n     /// gets initialized, so you can e.g., have an `Rc` here if there is global state you\n     /// need access to in the `AllocExtra` hooks.\n-    type MemoryExtra: Default;\n+    type MemoryExtra;\n \n     /// Extra data stored in every allocation.\n     type AllocExtra: AllocationExtra<Self::PointerTag> + 'static;"}, {"sha": "f5d912595337bcad06be6ba0e8c5bd06023f5c83", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -106,11 +106,11 @@ where\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n-            extra: M::MemoryExtra::default(),\n+            extra,\n             tcx,\n         }\n     }"}, {"sha": "4a80534503a5d017bb00b435f0b8b82f2035114e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -29,7 +29,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use] extern crate log;"}, {"sha": "da8fdb5082a8c21d15f43c9e9368248983a67caa", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -989,7 +989,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n-                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.tcx, def_id));\n \n@@ -1001,11 +1001,11 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::GlobalAsm(..) => {\n                 debug!(\"RootCollector: ItemKind::GlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n-                                        self.tcx.hir().local_def_id_from_hir_id(item.hir_id)));\n+                                        self.tcx.hir().local_def_id(item.hir_id)));\n                 self.output.push(MonoItem::GlobalAsm(item.hir_id));\n             }\n             hir::ItemKind::Static(..) => {\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 debug!(\"RootCollector: ItemKind::Static({})\",\n                        def_id_to_string(self.tcx, def_id));\n                 self.output.push(MonoItem::Static(def_id));\n@@ -1015,7 +1015,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n                 let instance = Instance::mono(self.tcx, def_id);\n                 let cid = GlobalId {\n@@ -1029,7 +1029,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 self.push_if_root(def_id);\n             }\n         }\n@@ -1043,7 +1043,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n-                let def_id = self.tcx.hir().local_def_id_from_hir_id(ii.hir_id);\n+                let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n                 self.push_if_root(def_id);\n             }\n             _ => { /* Nothing to do here */ }\n@@ -1136,7 +1136,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 }\n             }\n \n-            let impl_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let impl_def_id = tcx.hir().local_def_id(item.hir_id);\n \n             debug!(\"create_mono_items_for_default_impls(item={})\",\n                    def_id_to_string(tcx, impl_def_id));"}, {"sha": "e63426281bf21fea294ffd71ecac399254a366a5", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -55,7 +55,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             MonoItem::GlobalAsm(hir_id) => {\n-                let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+                let def_id = tcx.hir().local_def_id(hir_id);\n                 ty::SymbolName {\n                     name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n                 }"}, {"sha": "ad9db4e0aa8d84f59507cd2a11d805e0805d1350", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -314,7 +314,7 @@ fn mono_item_visibility(\n             };\n         }\n         MonoItem::GlobalAsm(hir_id) => {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(*hir_id);\n+            let def_id = tcx.hir().local_def_id(*hir_id);\n             return if tcx.is_reachable_non_generic(def_id) {\n                 *can_be_internalized = false;\n                 default_visibility(tcx, def_id, false)\n@@ -698,7 +698,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id_from_hir_id(hir_id)),\n+        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id)),\n     }\n }\n "}, {"sha": "15e2dc3261d98ecbb9223ac7ea301a7a97264524", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -78,7 +78,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n                               _: hir::HirId,\n                               _: Span) {\n             if let hir::VariantData::Tuple(_, hir_id) = *v {\n-                self.set.insert(self.tcx.hir().local_def_id_from_hir_id(hir_id));\n+                self.set.insert(self.tcx.hir().local_def_id(hir_id));\n             }\n             intravisit::walk_struct_def(self, v)\n         }"}, {"sha": "95cb8de70675d12c604572560870fe51fb006c9f", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -29,7 +29,7 @@ struct VarianceTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n         if let ItemKind::Ty(..) = item.node {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {"}, {"sha": "0a96ad3e3445e7bc59becea63d2779586bd39e3f", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -14,7 +14,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use]"}, {"sha": "daa64478bca8303ee20112c574db6b2ed4925aa2", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n         let item_id = self.tcx.hir().body_owner(body_id);\n-        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         let outer_in_fn = self.in_fn;\n         let outer_tables = self.tables;\n@@ -451,7 +451,7 @@ fn check_expr_kind<'a, 'tcx>(\n             let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            let closure_def_id = v.tcx.hir().local_def_id_from_hir_id(e.hir_id);\n+            let closure_def_id = v.tcx.hir().local_def_id(e.hir_id);\n             if !v.tcx.upvars(closure_def_id).map_or(true, |v| v.is_empty()) {\n                 NotPromotable\n             } else {"}, {"sha": "f1bf1111cf700d0ea3b43725721b4e0f3abe9a92", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -44,7 +44,7 @@ fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n         0 => None,\n         1 => {\n             let (hir_id, _) = finder.registrars.pop().unwrap();\n-            Some(tcx.hir().local_def_id_from_hir_id(hir_id))\n+            Some(tcx.hir().local_def_id(hir_id))\n         },\n         _ => {\n             let diagnostic = tcx.sess.diagnostic();"}, {"sha": "052f1526f0cc8bc077a931d915266c03988deef5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,7 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(in_band_lifetimes)]\n@@ -250,13 +249,13 @@ fn def_id_visibility<'tcx>(\n                     let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n                     match tcx.hir().get(parent_hir_id) {\n                         Node::Variant(..) => {\n-                            let parent_did = tcx.hir().local_def_id_from_hir_id(parent_hir_id);\n+                            let parent_did = tcx.hir().local_def_id(parent_hir_id);\n                             let (mut ctor_vis, mut span, mut descr) = def_id_visibility(\n                                 tcx, parent_did,\n                             );\n \n                             let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id));\n-                            let ctor_did = tcx.hir().local_def_id_from_hir_id(\n+                            let ctor_did = tcx.hir().local_def_id(\n                                 vdata.ctor_hir_id().unwrap());\n                             let variant = adt_def.variant_with_ctor_id(ctor_did);\n \n@@ -333,7 +332,7 @@ fn item_tables<'a, 'tcx>(\n     hir_id: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n ) -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+    let def_id = tcx.hir().local_def_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n@@ -394,7 +393,7 @@ trait VisibilityLike: Sized {\n         access_levels: &AccessLevels,\n     ) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n-        let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+        let def_id = tcx.hir().local_def_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -475,7 +474,7 @@ impl EmbargoVisitor<'tcx> {\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id),\n             ev: self,\n         }\n     }\n@@ -506,7 +505,7 @@ impl EmbargoVisitor<'tcx> {\n                 if let hir::ItemKind::Mod(m) = &item.node {\n                     for item_id in m.item_ids.as_ref() {\n                         let item = self.tcx.hir().expect_item(item_id.id);\n-                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id.id);\n+                        let def_id = self.tcx.hir().local_def_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n                             self.update(item.hir_id, Some(AccessLevel::Exported));\n@@ -726,7 +725,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n+            let def_id = self.tcx.hir().local_def_id(id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n@@ -751,7 +750,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n         let module_did = ty::DefIdTree::parent(\n             self.tcx,\n-            self.tcx.hir().local_def_id_from_hir_id(md.hir_id)\n+            self.tcx.hir().local_def_id(md.hir_id)\n         ).unwrap();\n         let mut module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n@@ -772,7 +771,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             for id in &module.item_ids {\n                 self.update(id.id, level);\n             }\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(module_id);\n+            let def_id = self.tcx.hir().local_def_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n                     if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.res.def_id()) {\n@@ -1163,7 +1162,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = mem::replace(&mut self.current_item,\n-            self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+            self.tcx.hir().local_def_id(item.hir_id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -1689,7 +1688,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n             item_id,\n-            item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id),\n             span: self.tcx.hir().span(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,"}, {"sha": "13b9855dbd71a77b18d24c38291ec68fda3ef1a2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -11,7 +11,6 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n pub use rustc::hir::def::{Namespace, PerNS};"}, {"sha": "dd0beee2104e8cf07a28af3d18d4a527b7824692", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -19,9 +19,8 @@ use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{\n-    feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n-};\n+use syntax::feature_gate::{feature_err, emit_feature_err, is_builtin_attr_name};\n+use syntax::feature_gate::{AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -298,12 +297,25 @@ impl<'a> Resolver<'a> {\n         let res = self.resolve_macro_to_res_inner(path, kind, parent_scope, trace, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n+        let features = self.session.features_untracked();\n         if res != Err(Determinacy::Undetermined) {\n             // Do not report duplicated errors on every undetermined resolution.\n             for segment in &path.segments {\n                 if let Some(args) = &segment.args {\n                     self.session.span_err(args.span(), \"generic arguments in macro path\");\n                 }\n+                if kind == MacroKind::Attr && !features.rustc_attrs &&\n+                   segment.ident.as_str().starts_with(\"rustc\") {\n+                    let msg = \"attributes starting with `rustc` are \\\n+                               reserved for use by the `rustc` compiler\";\n+                    emit_feature_err(\n+                        &self.session.parse_sess,\n+                        sym::rustc_attrs,\n+                        segment.ident.span,\n+                        GateIssue::Language,\n+                        msg,\n+                    );\n+                }\n             }\n         }\n \n@@ -320,24 +332,15 @@ impl<'a> Resolver<'a> {\n             }\n             Res::NonMacroAttr(attr_kind) => {\n                 if kind == MacroKind::Attr {\n-                    let features = self.session.features_untracked();\n                     if attr_kind == NonMacroAttrKind::Custom {\n                         assert!(path.segments.len() == 1);\n-                        let name = path.segments[0].ident.as_str();\n-                        if name.starts_with(\"rustc_\") {\n-                            if !features.rustc_attrs {\n-                                let msg = \"unless otherwise specified, attributes with the prefix \\\n-                                           `rustc_` are reserved for internal compiler diagnostics\";\n-                                self.report_unknown_attribute(path.span, &name, msg,\n-                                                              sym::rustc_attrs);\n-                            }\n-                        } else if !features.custom_attribute {\n+                        if !features.custom_attribute {\n                             let msg = format!(\"The attribute `{}` is currently unknown to the \\\n                                                compiler and may have meaning added to it in the \\\n                                                future\", path);\n                             self.report_unknown_attribute(\n                                 path.span,\n-                                &name,\n+                                &path.segments[0].ident.as_str(),\n                                 &msg,\n                                 sym::custom_attribute,\n                             );"}, {"sha": "dfdf560d419060a39ef922a31d3a5ba0cc192a93", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -123,7 +123,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     where\n         F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>),\n     {\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n         if self.tcx.has_typeck_tables(item_def_id) {\n             let tables = self.tcx.typeck_tables_of(item_def_id);\n             let old_tables = self.save_ctxt.tables;\n@@ -436,7 +436,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         attrs: &'l [Attribute],\n     ) {\n         let qualname = format!(\"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(id)));\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id)));\n \n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n@@ -481,7 +481,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n \n         let kind = match item.node {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -683,7 +683,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.process_generic_params(generics, \"\", item.id);\n         for impl_item in impl_items {\n             let map = &self.tcx.hir();\n-            self.process_impl_item(impl_item, map.local_def_id(item.id));\n+            self.process_impl_item(impl_item, map.local_def_id_from_node_id(item.id));\n         }\n     }\n \n@@ -696,7 +696,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(&generics.params));\n@@ -764,7 +764,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.process_generic_params(generics, &qualname, item.id);\n         for method in methods {\n             let map = &self.tcx.hir();\n-            self.process_trait_item(method, map.local_def_id(item.id))\n+            self.process_trait_item(method, map.local_def_id_from_node_id(item.id))\n         }\n     }\n \n@@ -1109,7 +1109,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(trait_item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(trait_item.id)));\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n@@ -1217,7 +1217,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let access = access_from!(self.save_ctxt, root_item, hir_id);\n \n         // The parent `DefId` of a given use tree is always the enclosing item.\n-        let parent = self.save_ctxt.tcx.hir().opt_local_def_id(id)\n+        let parent = self.save_ctxt.tcx.hir().opt_local_def_id_from_node_id(id)\n             .and_then(|id| self.save_ctxt.tcx.parent(id))\n             .map(id_from_def_id);\n \n@@ -1261,7 +1261,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 };\n \n                 // Make a comma-separated list of names of imported modules.\n-                let def_id = self.tcx.hir().local_def_id(id);\n+                let def_id = self.tcx.hir().local_def_id_from_node_id(id);\n                 let names = self.tcx.names_imported_by_glob_use(def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n@@ -1318,7 +1318,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, '\n         assert_eq!(id, ast::CRATE_NODE_ID);\n \n         let qualname = format!(\"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(id)));\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id)));\n \n         let cm = self.tcx.sess.source_map();\n         let filename = cm.span_to_filename(span);\n@@ -1367,7 +1367,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, '\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.hir().opt_local_def_id(item.id)\n+                    let parent = self.save_ctxt.tcx.hir().opt_local_def_id_from_node_id(item.id)\n                         .and_then(|id| self.save_ctxt.tcx.parent(id))\n                         .map(id_from_def_id);\n                     self.dumper.import(\n@@ -1408,7 +1408,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, '\n             }\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n@@ -1439,7 +1439,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, '\n             }\n             Existential(ref _bounds, ref ty_params) => {\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 // FIXME do something with _bounds\n                 let value = String::new();\n                 if !self.span.filter_generated(item.ident.span) {"}, {"sha": "effd69dc61ddc6660d1ac2fe30c685a3f50f402f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,7 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n #![allow(unused_attributes)]\n \n@@ -135,7 +134,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n \n     pub fn get_extern_item_data(&self, item: &ast::ForeignItem) -> Option<Data> {\n         let qualname = format!(\"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n@@ -186,7 +185,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n@@ -205,7 +204,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Static(ref typ, ..) => {\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n \n                 filter!(self.span_utils, item.ident.span);\n \n@@ -229,7 +228,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Const(ref typ, _) => {\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n@@ -252,7 +251,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Mod(ref m) => {\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n \n                 let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n@@ -280,7 +279,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             ast::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n@@ -365,10 +364,10 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\",\n-                self.tcx.def_path_str(self.tcx.hir().local_def_id(scope)),\n+                self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(scope)),\n                 ident);\n             filter!(self.span_utils, ident.span);\n-            let def_id = self.tcx.hir().local_def_id(field.id);\n+            let def_id = self.tcx.hir().local_def_id_from_node_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n \n \n@@ -400,7 +399,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n-            match self.tcx.impl_of_method(self.tcx.hir().local_def_id(id)) {\n+            match self.tcx.impl_of_method(self.tcx.hir().local_def_id_from_node_id(id)) {\n                 Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                     Some(Node::Item(item)) => match item.node {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n@@ -451,7 +450,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         );\n                     }\n                 },\n-                None => match self.tcx.trait_of_item(self.tcx.hir().local_def_id(id)) {\n+                None => match self.tcx.trait_of_item(self.tcx.hir().local_def_id_from_node_id(id)) {\n                     Some(def_id) => {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n@@ -1193,7 +1192,7 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n }\n \n fn id_from_node_id(id: NodeId, scx: &SaveContext<'_, '_>) -> rls_data::Id {\n-    let def_id = scx.tcx.hir().opt_local_def_id(id);\n+    let def_id = scx.tcx.hir().opt_local_def_id_from_node_id(id);\n     def_id.map(|id| id_from_def_id(id)).unwrap_or_else(|| {\n         // Create a *fake* `DefId` out of a `NodeId` by subtracting the `NodeId`\n         // out of the maximum u32 value. This will work unless you have *billions*"}, {"sha": "cdec65e5d40dfd0abc0dcfb62c03f0eb72f849fe", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -167,29 +167,44 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     target\n }\n \n+const MAX_INT_REGS: usize = 6; // RDI, RSI, RDX, RCX, R8, R9\n+const MAX_SSE_REGS: usize = 8; // XMM0-7\n+\n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n-    let mut sse_regs = 8; // XMM0-7\n+    let mut int_regs = MAX_INT_REGS;\n+    let mut sse_regs = MAX_SSE_REGS;\n \n     let mut x86_64_ty = |arg: &mut ArgType<'a, Ty>, is_arg: bool| {\n         let mut cls_or_mem = classify_arg(cx, arg);\n \n-        let mut needed_int = 0;\n-        let mut needed_sse = 0;\n         if is_arg {\n             if let Ok(cls) = cls_or_mem {\n+                let mut needed_int = 0;\n+                let mut needed_sse = 0;\n                 for &c in &cls {\n                     match c {\n                         Some(Class::Int) => needed_int += 1,\n                         Some(Class::Sse) => needed_sse += 1,\n                         _ => {}\n                     }\n                 }\n-                if arg.layout.is_aggregate() && (int_regs < needed_int || sse_regs < needed_sse) {\n-                    cls_or_mem = Err(Memory);\n+                match (int_regs.checked_sub(needed_int), sse_regs.checked_sub(needed_sse)) {\n+                    (Some(left_int), Some(left_sse)) => {\n+                        int_regs = left_int;\n+                        sse_regs = left_sse;\n+                    }\n+                    _ => {\n+                        // Not enough registers for this argument, so it will be\n+                        // passed on the stack, but we only mark aggregates\n+                        // explicitly as indirect `byval` arguments, as LLVM will\n+                        // automatically put immediates on the stack itself.\n+                        if arg.layout.is_aggregate() {\n+                            cls_or_mem = Err(Memory);\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -201,14 +216,14 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n                 } else {\n                     // `sret` parameter thus one less integer register available\n                     arg.make_indirect();\n+                    // NOTE(eddyb) return is handled first, so no registers\n+                    // should've been used yet.\n+                    assert_eq!(int_regs, MAX_INT_REGS);\n                     int_regs -= 1;\n                 }\n             }\n             Ok(ref cls) => {\n                 // split into sized chunks passed individually\n-                int_regs -= needed_int;\n-                sse_regs -= needed_sse;\n-\n                 if arg.layout.is_aggregate() {\n                     let size = arg.layout.size;\n                     arg.cast_to(cast_target(cls, size))"}, {"sha": "b65813fd8e38d6adb73bb68c38340918fd352c31", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -16,7 +16,6 @@\n #![feature(step_trait)]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use] extern crate log;"}, {"sha": "12b19a2648d7f6d8577d66efbdd6f80fce80c992", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -2,7 +2,6 @@\n //! the guts are broken up into modules; see the comments in those modules.\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(crate_visibility_modifier)]"}, {"sha": "c81b1dc8974b0bf16e1b75f2646cd47f9a19cbc9", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -628,7 +628,7 @@ struct ClauseDumper<'tcx> {\n \n impl ClauseDumper<'tcx> {\n     fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n+        let def_id = self.tcx.hir().local_def_id(hir_id);\n         for attr in attrs {\n             let mut clauses = None;\n "}, {"sha": "7154b7958b932ddbe6d9797c9202b5af1a77422a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1999,7 +1999,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n-                let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 tcx.mk_ty_param(index, tcx.hir().name(hir_id).as_interned_str())\n@@ -2091,7 +2091,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n-                let did = tcx.hir().local_def_id_from_hir_id(item_id.id);\n+                let did = tcx.hir().local_def_id(item_id.id);\n                 self.impl_trait_ty_to_ty(did, lifetimes)\n             }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n@@ -2173,7 +2173,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         debug!(\"ast_const_to_const(id={:?}, ast_const={:?})\", ast_const.hir_id, ast_const);\n \n         let tcx = self.tcx();\n-        let def_id = tcx.hir().local_def_id_from_hir_id(ast_const.hir_id);\n+        let def_id = tcx.hir().local_def_id(ast_const.hir_id);\n \n         let mut const_ = ty::Const {\n             val: ConstValue::Unevaluated(\n@@ -2189,9 +2189,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // parent item and construct a `ParamConst`.\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n             let item_id = tcx.hir().get_parent_node(hir_id);\n-            let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n+            let item_def_id = tcx.hir().local_def_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id_from_hir_id(hir_id)];\n+            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n             let name = tcx.hir().name(hir_id).as_interned_str();\n             const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n         }"}, {"sha": "d2f2f89cf0b1c7dce33459727c574eb1da9f2259", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             opt_kind, expected_sig\n         );\n \n-        let expr_def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+        let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n \n         let ClosureSignatures {\n             bound_sig,"}, {"sha": "603726dfe238c9e967a945cae9df82e5002f86bd", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -901,7 +901,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n+        let count_def_id = tcx.hir().local_def_id(count.hir_id);\n         let count = if self.const_param_def_id(count).is_some() {\n             Ok(self.to_const(count, tcx.type_of(count_def_id)))\n         } else {"}, {"sha": "531ecd11dcb20ed26d8fbbf8ccc0778ca13d0f0e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -22,7 +22,7 @@ fn equate_intrinsic_type<'tcx>(\n     inputs: Vec<Ty<'tcx>>,\n     output: Ty<'tcx>,\n ) {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+    let def_id = tcx.hir().local_def_id(it.hir_id);\n \n     match it.node {\n         hir::ForeignItemKind::Fn(..) => {}"}, {"sha": "a7e4f8e5c6289948bb556d212d5ded5492d3a60b", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )?;\n \n         for import_id in &pick.import_ids {\n-            let import_def_id = self.tcx.hir().local_def_id_from_hir_id(*import_id);\n+            let import_def_id = self.tcx.hir().local_def_id(*import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                 .unwrap().insert(import_def_id);\n@@ -434,7 +434,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        self_ty, expr_id, ProbeScope::TraitsInScope)?;\n         debug!(\"resolve_ufcs: pick={:?}\", pick);\n         for import_id in pick.import_ids {\n-            let import_def_id = tcx.hir().local_def_id_from_hir_id(import_id);\n+            let import_def_id = tcx.hir().local_def_id(import_id);\n             debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                 .unwrap().insert(import_def_id);"}, {"sha": "8dcfa184d7dad5aff8adc53a04756ee7e26bb8b6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -797,7 +797,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n             match i.node {\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => {\n-                    let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n+                    let def_id = self.map.local_def_id(i.hir_id);\n                     self.traits.push(def_id);\n                 }\n                 _ => ()"}, {"sha": "efe9079e19e4bb3268c3251a8bd0833cb4bf2c8d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1085,7 +1085,7 @@ fn check_fn<'a, 'tcx>(\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id_from_hir_id(fn_id));\n+    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n     let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id, }.visit_body(body);\n \n@@ -1183,7 +1183,7 @@ fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir().local_def_id_from_hir_id(fn_id) {\n+        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n             if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n                 // at this point we don't care if there are duplicate handlers or if the handler has\n                 // the wrong signature as this value we'll be used when writing metadata and that\n@@ -1241,7 +1241,7 @@ fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir().local_def_id_from_hir_id(fn_id) {\n+        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n@@ -1292,7 +1292,7 @@ fn check_fn<'a, 'tcx>(\n }\n \n fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -1306,7 +1306,7 @@ fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n }\n \n fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -1334,26 +1334,26 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n-        tcx.def_path_str(tcx.hir().local_def_id_from_hir_id(it.hir_id))\n+        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id))\n     );\n     let _indenter = indenter();\n     match it.node {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n             tcx.typeck_tables_of(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.typeck_tables_of(tcx.hir().local_def_id_from_hir_id(it.hir_id));\n+            tcx.typeck_tables_of(tcx.hir().local_def_id(it.hir_id));\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n             check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n-            let impl_def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n@@ -1367,7 +1367,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n             }\n         }\n         hir::ItemKind::Trait(..) => {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n             check_on_unimplemented(tcx, def_id, it);\n         }\n         hir::ItemKind::Struct(..) => {\n@@ -1377,13 +1377,13 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n             check_union(tcx, it.hir_id, it.span);\n         }\n         hir::ItemKind::Existential(..) => {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n             check_opaque(tcx, def_id, substs, it.span);\n         }\n         hir::ItemKind::Ty(..) => {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n             let pty_ty = tcx.type_of(def_id);\n             let generics = tcx.generics_of(def_id);\n             check_bounds_are_used(tcx, &generics, pty_ty);\n@@ -1401,7 +1401,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n                 }\n             } else {\n                 for item in &m.items {\n-                    let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(item.hir_id));\n+                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n                     if generics.params.len() - generics.own_counts().lifetimes != 0 {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n@@ -1468,7 +1468,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n }\n \n fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item) {\n-    let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n@@ -1551,7 +1551,7 @@ fn check_impl_items_against_trait<'tcx>(\n     // and compatible with trait signature\n     for impl_item in impl_items() {\n         let ty_impl_item = tcx.associated_item(\n-            tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n+            tcx.hir().local_def_id(impl_item.hir_id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n                        tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n@@ -1909,7 +1909,7 @@ fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n \n #[allow(trivial_numeric_casts)]\n pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n@@ -1937,7 +1937,7 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n \n     for v in vs {\n         if let Some(ref e) = v.node.disr_expr {\n-            tcx.typeck_tables_of(tcx.hir().local_def_id_from_hir_id(e.hir_id));\n+            tcx.typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n         }\n     }\n \n@@ -2006,7 +2006,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let item_id = tcx.hir().ty_param_owner(hir_id);\n-        let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n+        let item_def_id = tcx.hir().local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n         let index = generics.param_def_id_to_index[&def_id];\n         tcx.arena.alloc(ty::GenericPredicates {\n@@ -2453,7 +2453,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         value: &T,\n         value_span: Span,\n     ) -> T {\n-        let parent_def_id = self.tcx.hir().local_def_id_from_hir_id(parent_id);\n+        let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n                parent_def_id,\n                value);"}, {"sha": "c66d746d6e0293e78898a181fae714df9bcdd1e9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// types from which we should derive implied bounds, if any.\n     pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n-        let subject = self.tcx.hir().local_def_id_from_hir_id(item_id);\n+        let subject = self.tcx.hir().local_def_id(item_id);\n         let mut rcx = RegionCtxt::new(\n             self,\n             RepeatingScope(item_id),"}, {"sha": "155cabb27a92f0f1a94b873ffa1edae6aad90f5a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_id = tcx.hir().local_def_id_from_hir_id(closure_id);\n+        let closure_def_id = tcx.hir().local_def_id(closure_id);\n \n         tcx.upvars(closure_def_id).iter().flat_map(|upvars| {\n             upvars"}, {"sha": "a41f4ec91a426e49e73237929cd9c6adada2443c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -95,7 +95,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n         hir::ItemKind::Impl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n-            let is_auto = tcx.impl_trait_ref(tcx.hir().local_def_id_from_hir_id(item.hir_id))\n+            let is_auto = tcx.impl_trait_ref(tcx.hir().local_def_id(item.hir_id))\n                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n                 tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n@@ -188,7 +188,7 @@ fn check_associated_item(\n \n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n-        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id_from_hir_id(item_id));\n+        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n             ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n@@ -232,7 +232,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) -> CheckWfFcxBuilder<'tcx\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n         id,\n@@ -252,7 +252,7 @@ fn check_type_defn<'tcx, F>(\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n-        let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n         let packed = fcx.tcx.adt_def(def_id).repr.packed();\n \n         for variant in &variants {\n@@ -320,7 +320,7 @@ fn check_type_defn<'tcx, F>(\n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item) {\n     debug!(\"check_trait: {:?}\", item.hir_id);\n \n-    let trait_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+    let trait_def_id = tcx.hir().local_def_id(item.hir_id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n     if trait_def.is_marker {\n@@ -342,7 +342,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item) {\n \n fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n         let sig = fcx.normalize_associated_types_in(item.span, &sig);\n         let mut implied_bounds = vec![];\n@@ -361,7 +361,7 @@ fn check_item_type(\n     debug!(\"check_item_type: {:?}\", item_id);\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir().local_def_id_from_hir_id(item_id));\n+        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;\n@@ -394,7 +394,7 @@ fn check_impl<'tcx>(\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let item_def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let item_def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n \n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n@@ -943,7 +943,7 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item,\n     hir_generics: &hir::Generics,\n ) {\n-    let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     let ty = tcx.type_of(item_def_id);\n     if tcx.has_error_field(ty) {\n         return;\n@@ -1026,7 +1026,7 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_>, def_id: DefId) {\n fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n     let empty_env = ty::ParamEnv::empty();\n \n-    let def_id = fcx.tcx.hir().local_def_id_from_hir_id(id);\n+    let def_id = fcx.tcx.hir().local_def_id(id);\n     let predicates = fcx.tcx.predicates_of(def_id).predicates\n         .iter()\n         .map(|(p, _)| *p)\n@@ -1069,19 +1069,19 @@ impl CheckTypeWellFormedVisitor<'tcx> {\n impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n     fn visit_item(&self, i: &'tcx hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(i.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(i.hir_id);\n         self.tcx.ensure().check_item_well_formed(def_id);\n     }\n \n     fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n     }\n \n     fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(impl_item.hir_id);\n         self.tcx.ensure().check_impl_item_well_formed(def_id);\n     }\n }\n@@ -1101,7 +1101,7 @@ struct AdtField<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn non_enum_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n         let fields = struct_def.fields().iter().map(|field| {\n-            let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n+            let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id(field.hir_id));\n             let field_ty = self.normalize_associated_types_in(field.span,\n                                                               &field_ty);\n             let field_ty = self.resolve_vars_if_possible(&field_ty);"}, {"sha": "a2632b20c2ecbca944f6bebedabb3f95d76c759f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -34,7 +34,7 @@ use syntax_pos::Span;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'tcx hir::Body) -> &'tcx ty::TypeckTables<'tcx> {\n         let item_id = self.tcx.hir().body_owner(body.id());\n-        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is uSymbolfor unit tests."}, {"sha": "ffc66ec16de139ed68602ea89f1d63bc7fd6fd9e", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -52,7 +52,7 @@ struct CheckVisitor<'tcx> {\n \n impl CheckVisitor<'tcx> {\n     fn check_import(&self, id: hir::HirId, span: Span) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = self.tcx.hir().local_def_id(id);\n         if !self.tcx.maybe_unused_trait_import(def_id) {\n             return;\n         }\n@@ -219,7 +219,7 @@ struct ExternCrateToLint {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n-            let extern_crate_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {\n                     def_id: extern_crate_def_id,"}, {"sha": "a95b9a03dcf77d90b449f4fbabb9553084c918cc", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> Checker<'tcx> {\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n             for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n-                let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(impl_id);\n+                let impl_def_id = self.tcx.hir().local_def_id(impl_id);\n                 f(self.tcx, impl_def_id);\n             }\n         }"}, {"sha": "fb79a85ea25bf9ffb5c4afd88f5760d3a870ba58", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -54,7 +54,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             _ => return\n         };\n \n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n@@ -257,7 +257,7 @@ impl InherentCollect<'tcx> {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n             vec.push(impl_def_id);\n         } else {"}, {"sha": "04b59a63e1d8ae788b7628c0639180f816dbff10", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -89,7 +89,7 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::Union(..) => {\n-                let type_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let type_def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }\n             _ => {}"}, {"sha": "1d0e433f07b3a90acc768c97df76f0f03fe4f3be", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -19,7 +19,7 @@ mod orphan;\n mod unsafety;\n \n fn check_impl(tcx: TyCtxt<'_>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+    let impl_def_id = tcx.hir().local_def_id(hir_id);\n \n     // If there are no traits, then this implementation must have a\n     // base type.\n@@ -151,8 +151,8 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n /// Overlap: no two impls for the same trait are implemented for the\n /// same type. Likewise, no two inherent impls for a given type\n /// constructor provide a method with the same name.\n-fn check_impl_overlap(tcx: TyCtxt<'_>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n+    let impl_def_id = tcx.hir().local_def_id(hir_id);\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     let trait_def_id = trait_ref.def_id;\n "}, {"sha": "299e18337bd309aa1d110353429f097d1b3f4b0e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -22,7 +22,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n             debug!(\"coherence2::orphan check: trait impl {}\","}, {"sha": "07fbfddd96e434e248fd323b3f56d5df41069cb7", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -21,7 +21,7 @@ impl UnsafetyChecker<'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity)\n     {\n-        let local_did = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let local_did = self.tcx.hir().local_def_id(item.hir_id);\n         if let Some(trait_ref) = self.tcx.impl_trait_ref(local_did) {\n             let trait_def = self.tcx.trait_def(trait_ref.def_id);\n             let unsafe_attr = impl_generics.and_then(|generics| {"}, {"sha": "09de228dd578034e87f409562b300a359aa07bb1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -124,12 +124,12 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n                 hir::GenericParamKind::Type {\n                     default: Some(_), ..\n                 } => {\n-                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+                    let def_id = self.tcx.hir().local_def_id(param.hir_id);\n                     self.tcx.type_of(def_id);\n                 }\n                 hir::GenericParamKind::Type { .. } => {}\n                 hir::GenericParamKind::Const { .. } => {\n-                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+                    let def_id = self.tcx.hir().local_def_id(param.hir_id);\n                     self.tcx.type_of(def_id);\n                 }\n             }\n@@ -139,7 +139,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprKind::Closure(..) = expr.node {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n         }\n@@ -265,7 +265,7 @@ fn type_param_predicates(\n \n     let param_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n-    let param_owner_def_id = tcx.hir().local_def_id_from_hir_id(param_owner);\n+    let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.param_def_id_to_index[&def_id];\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id).as_interned_str());\n@@ -385,7 +385,7 @@ fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n-                def_id == tcx.hir().local_def_id_from_hir_id(param_id)\n+                def_id == tcx.hir().local_def_id(param_id)\n             }\n             _ => false,\n         }\n@@ -397,7 +397,7 @@ fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n-    let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n+    let def_id = tcx.hir().local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n@@ -406,7 +406,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n-                let def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = tcx.hir().local_def_id(item.hir_id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n@@ -444,7 +444,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.predicates_of(def_id);\n \n             for f in struct_def.fields() {\n-                let def_id = tcx.hir().local_def_id_from_hir_id(f.hir_id);\n+                let def_id = tcx.hir().local_def_id(f.hir_id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n@@ -478,7 +478,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n \n fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n     let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n-    let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n+    let def_id = tcx.hir().local_def_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n \n     match trait_item.node {\n@@ -498,7 +498,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n }\n \n fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(impl_item_id);\n+    let def_id = tcx.hir().local_def_id(impl_item_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n@@ -508,7 +508,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n }\n \n fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n+    let def_id = tcx.hir().local_def_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n@@ -525,7 +525,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n             if let Some(ref e) = variant.node.disr_expr {\n-                let expr_did = tcx.hir().local_def_id_from_hir_id(e.hir_id);\n+                let expr_did = tcx.hir().local_def_id(e.hir_id);\n                 def.eval_explicit_discr(tcx, expr_did)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n@@ -548,7 +548,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n         );\n \n         for f in variant.node.data.fields() {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(f.hir_id);\n+            let def_id = tcx.hir().local_def_id(f.hir_id);\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n@@ -578,7 +578,7 @@ fn convert_variant(\n         .fields()\n         .iter()\n         .map(|f| {\n-            let fid = tcx.hir().local_def_id_from_hir_id(f.hir_id);\n+            let fid = tcx.hir().local_def_id(f.hir_id);\n             let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n             if let Some(prev_span) = dup_span {\n                 struct_span_err!(\n@@ -635,13 +635,13 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n             let variants = def.variants\n                 .iter()\n                 .map(|v| {\n-                    let variant_did = Some(tcx.hir().local_def_id_from_hir_id(v.node.id));\n+                    let variant_did = Some(tcx.hir().local_def_id(v.node.id));\n                     let ctor_did = v.node.data.ctor_hir_id()\n-                        .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+                        .map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n                     let discr = if let Some(ref e) = v.node.disr_expr {\n                         distance_from_explicit = 0;\n-                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n+                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id))\n                     } else {\n                         ty::VariantDiscr::Relative(distance_from_explicit)\n                     };\n@@ -657,7 +657,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n         ItemKind::Struct(ref def, _) => {\n             let variant_did = None;\n             let ctor_did = def.ctor_hir_id()\n-                .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+                .map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n             let variants = std::iter::once(convert_variant(\n                 tcx, variant_did, ctor_did, item.ident, ty::VariantDiscr::Relative(0), def,\n@@ -669,7 +669,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n         ItemKind::Union(ref def, _) => {\n             let variant_did = None;\n             let ctor_did = def.ctor_hir_id()\n-                .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+                .map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n             let variants = std::iter::once(convert_variant(\n                 tcx, variant_did, ctor_did, item.ident, ty::VariantDiscr::Relative(0), def,\n@@ -889,7 +889,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_) |\n         Node::Ctor(..) | Node::Field(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n-            Some(tcx.hir().local_def_id_from_hir_id(parent_id))\n+            Some(tcx.hir().local_def_id(parent_id))\n         }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n@@ -937,7 +937,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: kw::SelfUpper.as_interned_str(),\n-                        def_id: tcx.hir().local_def_id_from_hir_id(param_id),\n+                        def_id: tcx.hir().local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n@@ -983,7 +983,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             .map(|(i, param)| ty::GenericParamDef {\n                 name: param.name.ident().as_interned_str(),\n                 index: own_start + i as u32,\n-                def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+                def_id: tcx.hir().local_def_id(param.hir_id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Lifetime,\n             }),\n@@ -1050,7 +1050,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                 let param_def = ty::GenericParamDef {\n                     index: type_start + i as u32,\n                     name: param.name.ident().as_interned_str(),\n-                    def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+                    def_id: tcx.hir().local_def_id(param.hir_id),\n                     pure_wrt_drop: param.pure_wrt_drop,\n                     kind,\n                 };\n@@ -1623,23 +1623,23 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n-            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -1720,7 +1720,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id));\n             let inputs = data.fields()\n                 .iter()\n-                .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n+                .map(|f| tcx.type_of(tcx.hir().local_def_id(f.hir_id)));\n             ty::Binder::bind(tcx.mk_fn_sig(\n                 inputs,\n                 ty,\n@@ -2036,7 +2036,7 @@ fn explicit_predicates_of(\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+            def_id: tcx.hir().local_def_id(param.hir_id),\n             index,\n             name: param.name.ident().as_interned_str(),\n         }));\n@@ -2154,7 +2154,7 @@ fn explicit_predicates_of(\n             };\n \n             let assoc_ty =\n-                tcx.mk_projection(tcx.hir().local_def_id_from_hir_id(trait_item.hir_id),\n+                tcx.mk_projection(tcx.hir().local_def_id(trait_item.hir_id),\n                     self_trait_ref.substs);\n \n             let bounds = AstConv::compute_bounds("}, {"sha": "029a8f9c41f68f4de6b79f1c8781c83bba5d0dc4", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -54,7 +54,7 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n+        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id_from_node_id(module));\n     }\n }\n \n@@ -79,7 +79,7 @@ struct ImplWfCheck<'tcx> {\n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n-            let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx,\n                                                 impl_def_id,\n                                                 impl_item_refs);\n@@ -109,7 +109,7 @@ fn enforce_impl_params_are_constrained(\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref| tcx.hir().local_def_id_from_hir_id(item_ref.id.hir_id))\n+        .map(|item_ref| tcx.hir().local_def_id(item_ref.id.hir_id))\n         .filter(|&def_id| {\n             let item = tcx.associated_item(def_id);\n             item.kind == ty::AssocKind::Type && item.defaultness.has_value()"}, {"sha": "934fc684eaeda1a24d74d3e90d2b2ad594787d05", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -74,7 +74,6 @@ This API is completely unstable and subject to change.\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #[macro_use] extern crate log;\n@@ -310,7 +309,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         time(tcx.sess, \"type collecting\", || {\n             for &module in tcx.hir().krate().modules.keys() {\n-                tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n+                tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id_from_node_id(module));\n             }\n         });\n     })?;\n@@ -345,7 +344,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n \n     time(tcx.sess, \"item-types checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n-            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id_from_node_id(module));\n         }\n     });\n \n@@ -370,7 +369,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n-    let env_def_id = tcx.hir().local_def_id_from_hir_id(env_node_id);\n+    let env_def_id = tcx.hir().local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n \n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n@@ -384,7 +383,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n-    let env_def_id = tcx.hir().local_def_id_from_hir_id(env_hir_id);\n+    let env_def_id = tcx.hir().local_def_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut bounds = Bounds::default();\n     let (principal, _) = AstConv::instantiate_poly_trait_ref_inner("}, {"sha": "6b288347ad00683875b77773b81034fc701451a5", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -52,7 +52,7 @@ pub struct InferVisitor<'cx, 'tcx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let item_did = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let item_did = self.tcx.hir().local_def_id(item.hir_id);\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n "}, {"sha": "3ae646b3ac7ceb12976969bceaed44c37633ed58", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -15,7 +15,7 @@ struct OutlivesTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found."}, {"sha": "b75a0912657fac462901603a181f2b5807e1fccd", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn visit_node_helper(&mut self, id: hir::HirId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         self.build_constraints_for_item(def_id);\n     }\n "}, {"sha": "51fb5465d1e5922a842c9f0448a454d87cde0b8f", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let solutions = &self.solutions;\n         self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n-            let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+            let def_id = tcx.hir().local_def_id(id);\n             let generics = tcx.generics_of(def_id);\n             let count = generics.count();\n "}, {"sha": "7af7c79bb3c0d7f300f0403ab4b28b980a39fc2c", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -103,7 +103,7 @@ fn lang_items(tcx: TyCtxt<'_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self, id: hir::HirId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         let count = tcx.generics_of(def_id).count();\n \n         if count == 0 {"}, {"sha": "9f6266b316f3a69dc43b8b3581286b206f72e090", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -13,7 +13,7 @@ struct VarianceTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found."}, {"sha": "350bcc9dbc649f4daed64d2193783aedd82eb016", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -281,14 +281,14 @@ impl Clean<ExternalCrate> for CrateNum {\n                     hir::ItemKind::Mod(_) => {\n                         as_primitive(Res::Def(\n                             DefKind::Mod,\n-                            cx.tcx.hir().local_def_id_from_hir_id(id.id),\n+                            cx.tcx.hir().local_def_id(id.id),\n                         ))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_primitive(path.res).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n-                            (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -325,13 +325,13 @@ impl Clean<ExternalCrate> for CrateNum {\n                     hir::ItemKind::Mod(_) => {\n                         as_keyword(Res::Def(\n                             DefKind::Mod,\n-                            cx.tcx.hir().local_def_id_from_hir_id(id.id),\n+                            cx.tcx.hir().local_def_id(id.id),\n                         ))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_keyword(path.res).map(|(_, prim, attrs)| {\n-                            (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -654,7 +654,7 @@ impl Clean<Item> for doctree::Module<'_> {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_node_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items,\n@@ -1588,15 +1588,15 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n             }\n             hir::GenericParamKind::Type { ref default, synthetic } => {\n                 (self.name.ident().name.clean(cx), GenericParamDefKind::Type {\n-                    did: cx.tcx.hir().local_def_id_from_hir_id(self.hir_id),\n+                    did: cx.tcx.hir().local_def_id(self.hir_id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n                     synthetic: synthetic,\n                 })\n             }\n             hir::GenericParamKind::Const { ref ty } => {\n                 (self.name.ident().name.clean(cx), GenericParamDefKind::Const {\n-                    did: cx.tcx.hir().local_def_id_from_hir_id(self.hir_id),\n+                    did: cx.tcx.hir().local_def_id(self.hir_id),\n                     ty: ty.clean(cx),\n                 })\n             }\n@@ -1926,7 +1926,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             (self.generics.clean(cx), (self.decl, self.body).clean(cx))\n         });\n \n-        let did = cx.tcx.hir().local_def_id_from_hir_id(self.id);\n+        let did = cx.tcx.hir().local_def_id(self.id);\n         let constness = if cx.tcx.is_min_const_fn(did) {\n             hir::Constness::Const\n         } else {\n@@ -2136,7 +2136,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2166,7 +2166,7 @@ impl Clean<Item> for doctree::TraitAlias<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2229,7 +2229,7 @@ impl Clean<Item> for hir::TraitItem {\n                 AssocTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n-        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2262,7 +2262,7 @@ impl Clean<Item> for hir::ImplItem {\n                 generics: Generics::default(),\n             }, true),\n         };\n-        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n@@ -2757,7 +2757,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n             TyKind::Array(ref ty, ref length) => {\n-                let def_id = cx.tcx.hir().local_def_id_from_hir_id(length.hir_id);\n+                let def_id = cx.tcx.hir().local_def_id(length.hir_id);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n                 let cid = GlobalId {\n@@ -2829,15 +2829,15 @@ impl Clean<Type> for hir::Ty {\n                                     if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n-                                                cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+                                                cx.tcx.hir().local_def_id(param.hir_id);\n                                             lt_substs.insert(lt_def_id, lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def_id =\n-                                        cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+                                        cx.tcx.hir().local_def_id(param.hir_id);\n                                     let mut j = 0;\n                                     let type_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2861,7 +2861,7 @@ impl Clean<Type> for hir::Ty {\n                                 }\n                                 hir::GenericParamKind::Const { .. } => {\n                                     let const_param_def_id =\n-                                        cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n+                                        cx.tcx.hir().local_def_id(param.hir_id);\n                                     let mut j = 0;\n                                     let const_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2982,10 +2982,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::FnPtr(_) => {\n                 let ty = cx.tcx.lift(self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n+                let local_def_id = cx.tcx.hir().local_def_id_from_node_id(ast::CRATE_NODE_ID);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n                     generic_params: Vec::new(),\n-                    decl: (cx.tcx.hir().local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n+                    decl: (local_def_id, sig).clean(cx),\n                     abi: sig.abi(),\n                 })\n             }\n@@ -3158,7 +3159,7 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n \n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n \n         Item {\n             name: Some(self.ident.name).clean(cx),\n@@ -3239,7 +3240,7 @@ impl Clean<Item> for doctree::Struct<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3259,7 +3260,7 @@ impl Clean<Item> for doctree::Union<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3306,7 +3307,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3333,7 +3334,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -3634,7 +3635,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3658,7 +3659,7 @@ impl Clean<Item> for doctree::Existential<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3709,7 +3710,7 @@ impl Clean<Item> for doctree::Static<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3734,7 +3735,7 @@ impl Clean<Item> for doctree::Constant<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3821,7 +3822,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3991,7 +3992,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n+            def_id: cx.tcx.hir().local_def_id_from_node_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n@@ -4052,7 +4053,7 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -4268,7 +4269,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             inner: ProcMacroItem(ProcMacro {\n                 kind: self.kind,\n                 helpers: self.helpers.clean(cx),"}, {"sha": "c391baabee06beea47fa93edee55fc929da285f4", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -363,7 +363,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             // to the map from defid -> hirid\n             let access_levels = AccessLevels {\n                 map: access_levels.map.iter()\n-                                    .map(|(&k, &v)| (tcx.hir().local_def_id_from_hir_id(k), v))\n+                                    .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n                                     .collect()\n             };\n "}, {"sha": "58777130b7f29339b530468d6da409c92e8bf073", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,4 @@\n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\","}, {"sha": "a2a6b1efe820c21ec3f0fd5a8ee7575ab46ea947", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -118,7 +118,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     // doesn't work with it anyway, so pull them from the HIR map instead\n     for &trait_did in cx.all_traits.iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n-            let impl_did = cx.tcx.hir().local_def_id_from_hir_id(impl_node);\n+            let impl_did = cx.tcx.hir().local_def_id(impl_node);\n             inline::build_impl(cx, impl_did, &mut new_items);\n         }\n     }"}, {"sha": "fa5faaf3ff56828264c2f6bd0c2b62be1ad0906f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -66,12 +66,12 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: hir::HirId) -> Option<attr::Stability> {\n-        self.cx.tcx.hir().opt_local_def_id_from_hir_id(id)\n+        self.cx.tcx.hir().opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n     }\n \n     fn deprecation(&self, id: hir::HirId) -> Option<attr::Deprecation> {\n-        self.cx.tcx.hir().opt_local_def_id_from_hir_id(id)\n+        self.cx.tcx.hir().opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n@@ -375,7 +375,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let ident = renamed.unwrap_or(item.ident);\n \n         if item.vis.node.is_pub() {\n-            let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+            let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n             self.store_path(def_id);\n         }\n \n@@ -389,7 +389,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+                let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n                                 .unwrap_or(LOCAL_CRATE),\n@@ -618,7 +618,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         Macro {\n \n-            def_id: self.cx.tcx.hir().local_def_id_from_hir_id(def.hir_id),\n+            def_id: self.cx.tcx.hir().local_def_id(def.hir_id),\n             attrs: &def.attrs,\n             name: renamed.unwrap_or(def.name),\n             whence: def.span,"}, {"sha": "a8d4d1181aa4fcb31b5f0f5beca28930454575e5", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1144,7 +1144,7 @@ pub trait Write {\n \n     /// Like `write`, except that it writes from a slice of buffers.\n     ///\n-    /// Data is copied to from each buffer in order, with the final buffer\n+    /// Data is copied from each buffer in order, with the final buffer\n     /// read from possibly being only partially consumed. This method must\n     /// behave as a call to `write` with the buffers concatenated would.\n     ///"}, {"sha": "601957acd5c63efbb5bf985a03cab8a666695a0b", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -3,8 +3,6 @@\n //! This module contains the facade (aka platform-specific) implementations of\n //! OS level functionality for Fortanix SGX.\n \n-#![allow(deprecated)]\n-\n use crate::io::ErrorKind;\n use crate::os::raw::c_char;\n use crate::sync::atomic::{AtomicBool, Ordering};\n@@ -142,7 +140,7 @@ pub unsafe extern \"C\" fn __rust_abort() {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     fn rdrand64() -> u64 {\n         unsafe {\n-            let mut ret: u64 = crate::mem::uninitialized();\n+            let mut ret: u64 = 0;\n             for _ in 0..10 {\n                 if crate::arch::x86_64::_rdrand64_step(&mut ret) == 1 {\n                     return ret;"}, {"sha": "a0c298010b6b693726ae10f688b73e66aa4b9e50", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -60,7 +60,7 @@ pub fn is_known(attr: &Attribute) -> bool {\n }\n \n pub fn is_known_lint_tool(m_item: Ident) -> bool {\n-    [\"clippy\"].contains(&m_item.as_str().as_ref())\n+    [sym::clippy, sym::rustc].contains(&m_item.name)\n }\n \n impl NestedMetaItem {"}, {"sha": "6fbd2ab7c43f2f7438071fe69543cee2852da455", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1504,9 +1504,7 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n \n     fn enable_custom_inner_attributes(&self) -> bool {\n-        self.features.map_or(false, |features| {\n-            features.custom_inner_attributes || features.custom_attribute || features.rustc_attrs\n-        })\n+        self.features.map_or(false, |features| features.custom_inner_attributes)\n     }\n }\n "}, {"sha": "e1e39faaad4adfb626b57153acaa5a511ca11ef8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1296,6 +1296,18 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                                     attribute is just used for rustc unit \\\n                                                     tests and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n+    (sym::rustc_dump_env_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"the `#[rustc_dump_env_program_clauses]` \\\n+                                                    attribute is just used for rustc unit \\\n+                                                    tests and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_object_lifetime_default, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"the `#[rustc_object_lifetime_default]` \\\n+                                                    attribute is just used for rustc unit \\\n+                                                    tests and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n     (sym::rustc_test_marker, Normal, template!(Word), Gated(Stability::Unstable,\n                                     sym::rustc_attrs,\n                                     \"the `#[rustc_test_marker]` attribute \\\n@@ -1357,6 +1369,26 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),\n \n+    (sym::rustc_allocator_nounwind, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_doc_only_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_promotable, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_allow_const_fn_ptr, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n     (sym::rustc_dummy, Normal, template!(Word /* doesn't matter*/), Gated(Stability::Unstable,\n                                          sym::rustc_attrs,\n                                          \"used by the test suite\",\n@@ -1643,6 +1675,14 @@ impl<'a> Context<'a> {\n             }\n             debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n             return;\n+        } else {\n+            for segment in &attr.path.segments {\n+                if segment.ident.as_str().starts_with(\"rustc\") {\n+                    let msg = \"attributes starting with `rustc` are \\\n+                               reserved for use by the `rustc` compiler\";\n+                    gate_feature!(self, rustc_attrs, segment.ident.span, msg);\n+                }\n+            }\n         }\n         for &(n, ty) in self.plugin_attributes {\n             if attr.path == n {\n@@ -1653,19 +1693,13 @@ impl<'a> Context<'a> {\n                 return;\n             }\n         }\n-        if !attr::is_known(attr) {\n-            if attr.name_or_empty().as_str().starts_with(\"rustc_\") {\n-                let msg = \"unless otherwise specified, attributes with the prefix `rustc_` \\\n-                           are reserved for internal compiler diagnostics\";\n-                gate_feature!(self, rustc_attrs, attr.span, msg);\n-            } else if !is_macro {\n-                // Only run the custom attribute lint during regular feature gate\n-                // checking. Macro gating runs before the plugin attributes are\n-                // registered, so we skip this in that case.\n-                let msg = format!(\"The attribute `{}` is currently unknown to the compiler and \\\n-                                   may have meaning added to it in the future\", attr.path);\n-                gate_feature!(self, custom_attribute, attr.span, &msg);\n-            }\n+        if !is_macro && !attr::is_known(attr) {\n+            // Only run the custom attribute lint during regular feature gate\n+            // checking. Macro gating runs before the plugin attributes are\n+            // registered, so we skip this in that case.\n+            let msg = format!(\"The attribute `{}` is currently unknown to the compiler and \\\n+                                may have meaning added to it in the future\", attr.path);\n+            gate_feature!(self, custom_attribute, attr.span, &msg);\n         }\n     }\n }"}, {"sha": "a7c5ed158e0287158e3118869365ed8d6c0e360f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -8,7 +8,6 @@\n        test(attr(deny(warnings))))]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(bind_by_move_pattern_guards)]"}, {"sha": "77b69ddd303b49278e03717304ca3fece656bb59", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -3,7 +3,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(in_band_lifetimes)]"}, {"sha": "07b9f60932024db20a488398270f7a42e4afdc03", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,7 +7,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n-#![deny(internal)]\n #![deny(unused_lifetimes)]\n \n #![feature(const_fn)]"}, {"sha": "6a97e5f212732a4d91446a99bb48516c725de4fa", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -175,6 +175,7 @@ symbols! {\n         cfg_target_thread_local,\n         cfg_target_vendor,\n         char,\n+        clippy,\n         clone,\n         Clone,\n         clone_closures,\n@@ -216,6 +217,7 @@ symbols! {\n         custom_inner_attributes,\n         custom_test_frameworks,\n         c_variadic,\n+        declare_lint_pass,\n         decl_macro,\n         Default,\n         default_lib_allocator,\n@@ -326,6 +328,7 @@ symbols! {\n         if_while_or_patterns,\n         ignore,\n         impl_header_lifetime_elision,\n+        impl_lint_pass,\n         impl_trait_in_bindings,\n         import_shadowing,\n         index,\n@@ -367,6 +370,7 @@ symbols! {\n         link_llvm_intrinsics,\n         link_name,\n         link_section,\n+        LintPass,\n         lint_reasons,\n         literal,\n         local_inner_macros,"}, {"sha": "b95b0ca1a89c00b103dd9200537be8bff3441ec3", "filename": "src/test/auxiliary/rust_test_helpers.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -215,6 +215,29 @@ uint64_t get_c_many_params(void *a, void *b, void *c, void *d, struct quad f) {\n     return f.c;\n }\n \n+struct quad_floats {\n+    float a;\n+    float b;\n+    float c;\n+    float d;\n+};\n+\n+float get_c_exhaust_sysv64_ints(\n+    void *a,\n+    void *b,\n+    void *c,\n+    void *d,\n+    void *e,\n+    void *f,\n+    // `f` used the last integer register, so `g` goes on the stack.\n+    // It also used to bring the \"count of available integer registers\" down to\n+    // `-1` which broke the next SSE-only aggregate argument (`h`) - see #62350.\n+    void *g,\n+    struct quad_floats h\n+) {\n+    return h.c;\n+}\n+\n // Calculates the average of `(x + y) / n` where x: i64, y: f64. There must be exactly n pairs\n // passed as variadic arguments. There are two versions of this function: the\n // variadic one, and the one that takes a `va_list`."}, {"sha": "35152e7f4babd4a6a28c8bc261979e07dbddcb59", "filename": "src/test/run-pass-fulldeps/issue-15778-pass.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -2,12 +2,13 @@\n // ignore-stage1\n // compile-flags: -D crate-not-okay\n \n-#![feature(plugin, rustc_attrs)]\n+#![feature(plugin, custom_attribute, custom_inner_attributes, rustc_attrs)]\n+\n #![plugin(lint_for_crate)]\n #![rustc_crate_okay]\n #![rustc_crate_blue]\n #![rustc_crate_red]\n #![rustc_crate_grey]\n #![rustc_crate_green]\n \n-pub fn main() { }\n+fn main() {}"}, {"sha": "fdf0573b5e3ec829db9814d51d57fe647253c73f", "filename": "src/test/run-pass/abi-sysv64-arg-passing.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -20,6 +20,7 @@\n // extern-return-TwoU64s\n // foreign-fn-with-byval\n // issue-28676\n+// issue-62350-sysv-neg-reg-counts\n // struct-return\n \n // ignore-android\n@@ -83,6 +84,9 @@ mod tests {\n     #[derive(Copy, Clone)]\n     pub struct Quad { a: u64, b: u64, c: u64, d: u64 }\n \n+    #[derive(Copy, Clone)]\n+    pub struct QuadFloats { a: f32, b: f32, c: f32, d: f32 }\n+\n     #[repr(C)]\n     #[derive(Copy, Clone)]\n     pub struct Floats { a: f64, b: u8, c: f64 }\n@@ -108,6 +112,16 @@ mod tests {\n         pub fn get_z(x: S) -> u64;\n         pub fn get_c_many_params(_: *const (), _: *const (),\n                                  _: *const (), _: *const (), f: Quad) -> u64;\n+        pub fn get_c_exhaust_sysv64_ints(\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            h: QuadFloats,\n+        ) -> f32;\n         pub fn rust_dbg_abi_1(q: Quad) -> Quad;\n         pub fn rust_dbg_abi_2(f: Floats) -> Floats;\n     }\n@@ -263,6 +277,27 @@ mod tests {\n         test();\n     }\n \n+    fn test_62350() {\n+        use std::ptr;\n+        unsafe {\n+            let null = ptr::null();\n+            let q = QuadFloats {\n+                a: 10.2,\n+                b: 20.3,\n+                c: 30.4,\n+                d: 40.5\n+            };\n+            assert_eq!(\n+                get_c_exhaust_sysv64_ints(null, null, null, null, null, null, null, q),\n+                q.c,\n+            );\n+        }\n+    }\n+\n+    pub fn issue_62350() {\n+        test_62350();\n+    }\n+\n     fn test1() {\n         unsafe {\n             let q = Quad { a: 0xaaaa_aaaa_aaaa_aaaa,\n@@ -321,6 +356,7 @@ fn main() {\n     extern_return_twou64s();\n     foreign_fn_with_byval();\n     issue_28676();\n+    issue_62350();\n     struct_return();\n }\n "}, {"sha": "df819306e4aa2708dfb50b6d3106e951079c96e1", "filename": "src/test/run-pass/abi/issues/issue-62350-sysv-neg-reg-counts.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass%2Fabi%2Fissues%2Fissue-62350-sysv-neg-reg-counts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass%2Fabi%2Fissues%2Fissue-62350-sysv-neg-reg-counts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabi%2Fissues%2Fissue-62350-sysv-neg-reg-counts.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -0,0 +1,46 @@\n+// run-pass\n+#![allow(dead_code)]\n+#![allow(improper_ctypes)]\n+\n+// ignore-wasm32-bare no libc to test ffi with\n+\n+#[derive(Copy, Clone)]\n+pub struct QuadFloats { a: f32, b: f32, c: f32, d: f32 }\n+\n+mod rustrt {\n+    use super::QuadFloats;\n+\n+    #[link(name = \"rust_test_helpers\", kind = \"static\")]\n+    extern {\n+        pub fn get_c_exhaust_sysv64_ints(\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            _: *const (),\n+            h: QuadFloats,\n+        ) -> f32;\n+    }\n+}\n+\n+fn test() {\n+    unsafe {\n+        let null = std::ptr::null();\n+        let q = QuadFloats {\n+            a: 10.2,\n+            b: 20.3,\n+            c: 30.4,\n+            d: 40.5\n+        };\n+        assert_eq!(\n+            rustrt::get_c_exhaust_sysv64_ints(null, null, null, null, null, null, null, q),\n+            q.c,\n+        );\n+    }\n+}\n+\n+pub fn main() {\n+    test();\n+}"}, {"sha": "9ebf0fcb1c1925d7c5a10523a879e1bf98cf8780", "filename": "src/test/run-pass/attr-on-generic-formals.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/853f30052d019a8ebe197a5adff3a29d6716a955/src%2Ftest%2Frun-pass%2Fattr-on-generic-formals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/853f30052d019a8ebe197a5adff3a29d6716a955/src%2Ftest%2Frun-pass%2Fattr-on-generic-formals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-on-generic-formals.rs?ref=853f30052d019a8ebe197a5adff3a29d6716a955", "patch": "@@ -1,52 +0,0 @@\n-#![allow(unused_attributes)]\n-\n-// This test ensures we can attach attributes to the formals in all\n-// places where generic parameter lists occur, assuming appropriate\n-// feature gates are enabled.\n-//\n-// (We are prefixing all tested features with `rustc_`, to ensure that\n-// the attributes themselves won't be rejected by the compiler when\n-// using `rustc_attrs` feature. There is a separate compile-fail/ test\n-// ensuring that the attribute feature-gating works in this context.)\n-\n-#![feature(rustc_attrs)]\n-#![allow(dead_code)]\n-\n-struct StLt<#[rustc_lt_struct] 'a>(&'a u32);\n-struct StTy<#[rustc_ty_struct] I>(I);\n-\n-enum EnLt<#[rustc_lt_enum] 'b> { A(&'b u32), B }\n-enum EnTy<#[rustc_ty_enum] J> { A(J), B }\n-\n-trait TrLt<#[rustc_lt_trait] 'c> { fn foo(&self, _: &'c [u32]) -> &'c u32; }\n-trait TrTy<#[rustc_ty_trait] K> { fn foo(&self, _: K); }\n-\n-type TyLt<#[rustc_lt_type] 'd> = &'d u32;\n-type TyTy<#[rustc_ty_type] L> = (L, );\n-\n-impl<#[rustc_lt_inherent] 'e> StLt<'e> { }\n-impl<#[rustc_ty_inherent] M> StTy<M> { }\n-\n-impl<#[rustc_lt_impl_for] 'f> TrLt<'f> for StLt<'f> {\n-    fn foo(&self, _: &'f [u32]) -> &'f u32 { loop { } }\n-}\n-impl<#[rustc_ty_impl_for] N> TrTy<N> for StTy<N> {\n-    fn foo(&self, _: N) { }\n-}\n-\n-fn f_lt<#[rustc_lt_fn] 'g>(_: &'g [u32]) -> &'g u32 { loop { } }\n-fn f_ty<#[rustc_ty_fn] O>(_: O) { }\n-\n-impl<I> StTy<I> {\n-    fn m_lt<#[rustc_lt_meth] 'h>(_: &'h [u32]) -> &'h u32 { loop { } }\n-    fn m_ty<#[rustc_ty_meth] P>(_: P) { }\n-}\n-\n-fn hof_lt<Q>(_: Q)\n-    where Q: for <#[rustc_lt_hof] 'i> Fn(&'i [u32]) -> &'i u32\n-{\n-}\n-\n-fn main() {\n-\n-}"}, {"sha": "9226145d9354de3ee119bb8d159655b7aa63d725", "filename": "src/test/run-pass/drop/dynamic-drop-async.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Frun-pass%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop%2Fdynamic-drop-async.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -0,0 +1,328 @@\n+// Test that values are not leaked in async functions, even in the cases where:\n+// * Dropping one of the values panics while running the future.\n+// * The future is dropped at one of its suspend points.\n+// * Dropping one of the values panics while dropping the future.\n+\n+// run-pass\n+// edition:2018\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![allow(unused_assignments)]\n+#![allow(unused_variables)]\n+#![feature(slice_patterns)]\n+#![feature(async_await)]\n+\n+use std::{\n+    cell::{Cell, RefCell},\n+    future::Future,\n+    marker::Unpin,\n+    panic,\n+    pin::Pin,\n+    ptr,\n+    rc::Rc,\n+    task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    usize,\n+};\n+\n+struct InjectedFailure;\n+\n+struct Defer<T> {\n+    ready: bool,\n+    value: Option<T>,\n+}\n+\n+impl<T: Unpin> Future for Defer<T> {\n+    type Output = T;\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        if self.ready {\n+            Poll::Ready(self.value.take().unwrap())\n+        } else {\n+            self.ready = true;\n+            Poll::Pending\n+        }\n+    }\n+}\n+\n+/// Allocator tracks the creation and destruction of `Ptr`s.\n+/// The `failing_op`-th operation will panic.\n+struct Allocator {\n+    data: RefCell<Vec<bool>>,\n+    failing_op: usize,\n+    cur_ops: Cell<usize>,\n+}\n+\n+impl panic::UnwindSafe for Allocator {}\n+impl panic::RefUnwindSafe for Allocator {}\n+\n+impl Drop for Allocator {\n+    fn drop(&mut self) {\n+        let data = self.data.borrow();\n+        if data.iter().any(|d| *d) {\n+            panic!(\"missing free: {:?}\", data);\n+        }\n+    }\n+}\n+\n+impl Allocator {\n+    fn new(failing_op: usize) -> Self {\n+        Allocator { failing_op, cur_ops: Cell::new(0), data: RefCell::new(vec![]) }\n+    }\n+    fn alloc(&self) -> impl Future<Output = Ptr<'_>> + '_ {\n+        self.fallible_operation();\n+\n+        let mut data = self.data.borrow_mut();\n+\n+        let addr = data.len();\n+        data.push(true);\n+        Defer { ready: false, value: Some(Ptr(addr, self)) }\n+    }\n+    fn fallible_operation(&self) {\n+        self.cur_ops.set(self.cur_ops.get() + 1);\n+\n+        if self.cur_ops.get() == self.failing_op {\n+            panic!(InjectedFailure);\n+        }\n+    }\n+}\n+\n+// Type that tracks whether it was dropped and can panic when it's created or\n+// destroyed.\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n+    fn drop(&mut self) {\n+        match self.1.data.borrow_mut()[self.0] {\n+            false => panic!(\"double free at index {:?}\", self.0),\n+            ref mut d => *d = false,\n+        }\n+\n+        self.1.fallible_operation();\n+    }\n+}\n+\n+async fn dynamic_init(a: Rc<Allocator>, c: bool) {\n+    let _x;\n+    if c {\n+        _x = Some(a.alloc().await);\n+    }\n+}\n+\n+async fn dynamic_drop(a: Rc<Allocator>, c: bool) {\n+    let x = a.alloc().await;\n+    if c {\n+        Some(x)\n+    } else {\n+        None\n+    };\n+}\n+\n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n+async fn struct_dynamic_drop(a: Rc<Allocator>, c0: bool, c1: bool, c: bool) {\n+    for i in 0..2 {\n+        let x;\n+        let y;\n+        if (c0 && i == 0) || (c1 && i == 1) {\n+            x = (a.alloc().await, a.alloc().await, a.alloc().await);\n+            y = TwoPtrs(a.alloc().await, a.alloc().await);\n+            if c {\n+                drop(x.1);\n+                a.alloc().await;\n+                drop(y.0);\n+                a.alloc().await;\n+            }\n+        }\n+    }\n+}\n+\n+async fn field_assignment(a: Rc<Allocator>, c0: bool) {\n+    let mut x = (TwoPtrs(a.alloc().await, a.alloc().await), a.alloc().await);\n+\n+    x.1 = a.alloc().await;\n+    x.1 = a.alloc().await;\n+\n+    let f = (x.0).0;\n+    a.alloc().await;\n+    if c0 {\n+        (x.0).0 = f;\n+    }\n+    a.alloc().await;\n+}\n+\n+async fn assignment(a: Rc<Allocator>, c0: bool, c1: bool) {\n+    let mut _v = a.alloc().await;\n+    let mut _w = a.alloc().await;\n+    if c0 {\n+        drop(_v);\n+    }\n+    _v = _w;\n+    if c1 {\n+        _w = a.alloc().await;\n+    }\n+}\n+\n+async fn array_simple(a: Rc<Allocator>) {\n+    let _x = [a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+}\n+\n+async fn vec_simple(a: Rc<Allocator>) {\n+    let _x = vec![a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+}\n+\n+async fn mixed_drop_and_nondrop(a: Rc<Allocator>) {\n+    // check that destructor panics handle drop\n+    // and non-drop blocks in the same scope correctly.\n+    //\n+    // Surprisingly enough, this used to not work.\n+    let (x, y, z);\n+    x = a.alloc().await;\n+    y = 5;\n+    z = a.alloc().await;\n+}\n+\n+#[allow(unreachable_code)]\n+async fn vec_unreachable(a: Rc<Allocator>) {\n+    let _x = vec![a.alloc().await, a.alloc().await, a.alloc().await, return];\n+}\n+\n+async fn slice_pattern_one_of(a: Rc<Allocator>, i: usize) {\n+    let array = [a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+    let _x = match i {\n+        0 => {\n+            let [a, ..] = array;\n+            a\n+        }\n+        1 => {\n+            let [_, a, ..] = array;\n+            a\n+        }\n+        2 => {\n+            let [_, _, a, _] = array;\n+            a\n+        }\n+        3 => {\n+            let [_, _, _, a] = array;\n+            a\n+        }\n+        _ => panic!(\"unmatched\"),\n+    };\n+    a.alloc().await;\n+}\n+\n+async fn subslice_pattern_from_end_with_drop(a: Rc<Allocator>, arg: bool, arg2: bool) {\n+    let arr = [a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+    if arg2 {\n+        drop(arr);\n+        return;\n+    }\n+\n+    if arg {\n+        let [.., _x, _] = arr;\n+    } else {\n+        let [_, _y..] = arr;\n+    }\n+    a.alloc().await;\n+}\n+\n+async fn subslice_pattern_reassign(a: Rc<Allocator>) {\n+    let mut ar = [a.alloc().await, a.alloc().await, a.alloc().await];\n+    let [_, _, _x] = ar;\n+    ar = [a.alloc().await, a.alloc().await, a.alloc().await];\n+    let [_, _y..] = ar;\n+    a.alloc().await;\n+}\n+\n+fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n+where\n+    F: Fn(Rc<Allocator>) -> G,\n+    G: Future<Output = ()>,\n+{\n+    for polls in 0.. {\n+        // Run without any panics to find which operations happen after the\n+        // penultimate `poll`.\n+        let first_alloc = Rc::new(Allocator::new(usize::MAX));\n+        let mut fut = Box::pin(f(first_alloc.clone()));\n+        let mut ops_before_last_poll = 0;\n+        let mut completed = false;\n+        for _ in 0..polls {\n+            ops_before_last_poll = first_alloc.cur_ops.get();\n+            if let Poll::Ready(()) = fut.as_mut().poll(cx) {\n+                completed = true;\n+            }\n+        }\n+        drop(fut);\n+\n+        // Start at `ops_before_last_poll` so that we will always be able to\n+        // `poll` the expected number of times.\n+        for failing_op in ops_before_last_poll..first_alloc.cur_ops.get() {\n+            let alloc = Rc::new(Allocator::new(failing_op + 1));\n+            let f = &f;\n+            let cx = &mut *cx;\n+            let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n+                let mut fut = Box::pin(f(alloc));\n+                for _ in 0..polls {\n+                    let _ = fut.as_mut().poll(cx);\n+                }\n+                drop(fut);\n+            }));\n+            match result {\n+                Ok(..) => panic!(\"test executed more ops on first call\"),\n+                Err(e) => {\n+                    if e.downcast_ref::<InjectedFailure>().is_none() {\n+                        panic::resume_unwind(e);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if completed {\n+            break;\n+        }\n+    }\n+}\n+\n+fn clone_waker(data: *const ()) -> RawWaker {\n+    RawWaker::new(data, &RawWakerVTable::new(clone_waker, drop, drop, drop))\n+}\n+\n+fn main() {\n+    let waker = unsafe { Waker::from_raw(clone_waker(ptr::null())) };\n+    let context = &mut Context::from_waker(&waker);\n+\n+    run_test(context, |a| dynamic_init(a, false));\n+    run_test(context, |a| dynamic_init(a, true));\n+    run_test(context, |a| dynamic_drop(a, false));\n+    run_test(context, |a| dynamic_drop(a, true));\n+\n+    run_test(context, |a| assignment(a, false, false));\n+    run_test(context, |a| assignment(a, false, true));\n+    run_test(context, |a| assignment(a, true, false));\n+    run_test(context, |a| assignment(a, true, true));\n+\n+    run_test(context, |a| array_simple(a));\n+    run_test(context, |a| vec_simple(a));\n+    run_test(context, |a| vec_unreachable(a));\n+\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(context, |a| field_assignment(a, false));\n+    run_test(context, |a| field_assignment(a, true));\n+\n+    run_test(context, |a| mixed_drop_and_nondrop(a));\n+\n+    run_test(context, |a| slice_pattern_one_of(a, 0));\n+    run_test(context, |a| slice_pattern_one_of(a, 1));\n+    run_test(context, |a| slice_pattern_one_of(a, 2));\n+    run_test(context, |a| slice_pattern_one_of(a, 3));\n+\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(context, |a| subslice_pattern_reassign(a));\n+}"}, {"sha": "2a57876f464c0b391600265ff4577788514116af", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -8,8 +8,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n-                  LintArray};\n+use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use rustc_plugin::Registry;\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n@@ -19,7 +18,14 @@ declare_tool_lint!(\n     Warn, \"Warn about other stuff\"\n );\n \n-declare_lint_pass!(Pass => [TEST_LINT, TEST_GROUP]);\n+declare_tool_lint!(\n+    /// Some docs\n+    pub rustc::TEST_RUSTC_TOOL_LINT,\n+    Deny,\n+    \"Deny internal stuff\"\n+);\n+\n+declare_lint_pass!(Pass => [TEST_LINT, TEST_GROUP, TEST_RUSTC_TOOL_LINT]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {"}, {"sha": "3786c6de7e78c400a827cf3f4e339e47d232e6c1", "filename": "src/test/ui-fulldeps/internal-lints/default_hash_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,7 +7,7 @@ extern crate rustc_data_structures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::collections::{HashMap, HashSet};\n \n-#[deny(default_hash_types)]\n+#[deny(rustc::default_hash_types)]\n fn main() {\n     let _map: HashMap<String, String> = HashMap::default();\n     //~^ ERROR Prefer FxHashMap over HashMap, it has better performance"}, {"sha": "c1762d31323cf8b2a1a83ac008ab9659083fa964", "filename": "src/test/ui-fulldeps/internal-lints/default_hash_types.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,8 +7,8 @@ LL |     let _map: HashMap<String, String> = HashMap::default();\n note: lint level defined here\n   --> $DIR/default_hash_types.rs:10:8\n    |\n-LL | #[deny(default_hash_types)]\n-   |        ^^^^^^^^^^^^^^^^^^\n+LL | #[deny(rustc::default_hash_types)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: a `use rustc_data_structures::fx::FxHashMap` may be necessary\n \n error: Prefer FxHashMap over HashMap, it has better performance"}, {"sha": "48dd5b122b5acd023f074022a8474b1481b208ab", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -0,0 +1,53 @@\n+// compile-flags: -Z unstable-options\n+\n+#![feature(rustc_private)]\n+#![deny(rustc::lint_pass_impl_without_macro)]\n+\n+extern crate rustc;\n+\n+use rustc::lint::{LintArray, LintPass};\n+use rustc::{declare_lint, declare_lint_pass, impl_lint_pass, lint_array};\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Allow,\n+    \"test\"\n+}\n+\n+struct Foo;\n+\n+impl LintPass for Foo { //~ERROR implementing `LintPass` by hand\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TEST_LINT)\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        \"Foo\"\n+    }\n+}\n+\n+macro_rules! custom_lint_pass_macro {\n+    () => {\n+        struct Custom;\n+\n+        impl LintPass for Custom { //~ERROR implementing `LintPass` by hand\n+            fn get_lints(&self) -> LintArray {\n+                lint_array!(TEST_LINT)\n+            }\n+\n+            fn name(&self) -> &'static str {\n+                \"Custom\"\n+            }\n+        }\n+    };\n+}\n+\n+custom_lint_pass_macro!();\n+\n+struct Bar;\n+\n+impl_lint_pass!(Bar => [TEST_LINT]);\n+\n+declare_lint_pass!(Baz => [TEST_LINT]);\n+\n+fn main() {}"}, {"sha": "b439ae2cd148d5dbe97cbd4de7b3ebddc031db25", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -0,0 +1,26 @@\n+error: implementing `LintPass` by hand\n+  --> $DIR/lint_pass_impl_without_macro.rs:19:6\n+   |\n+LL | impl LintPass for Foo {\n+   |      ^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint_pass_impl_without_macro.rs:4:9\n+   |\n+LL | #![deny(rustc::lint_pass_impl_without_macro)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: try using `declare_lint_pass!` or `impl_lint_pass!` instead\n+\n+error: implementing `LintPass` by hand\n+  --> $DIR/lint_pass_impl_without_macro.rs:33:14\n+   |\n+LL |         impl LintPass for Custom {\n+   |              ^^^^^^^^\n+...\n+LL | custom_lint_pass_macro!();\n+   | -------------------------- in this macro invocation\n+   |\n+   = help: try using `declare_lint_pass!` or `impl_lint_pass!` instead\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7564c0245802ddcde7d526be33212f8a2daa41ee", "filename": "src/test/ui-fulldeps/internal-lints/pass_ty_by_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Z unstable-options\n \n #![feature(rustc_private)]\n-#![deny(ty_pass_by_reference)]\n+#![deny(rustc::ty_pass_by_reference)]\n #![allow(unused)]\n \n extern crate rustc;"}, {"sha": "d2ed6b6a19c31eb722b665c1e9d76b7b33c316bc", "filename": "src/test/ui-fulldeps/internal-lints/pass_ty_by_ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,8 +7,8 @@ LL |     ty_ref: &Ty<'_>,\n note: lint level defined here\n   --> $DIR/pass_ty_by_ref.rs:4:9\n    |\n-LL | #![deny(ty_pass_by_reference)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(rustc::ty_pass_by_reference)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: passing `TyCtxt<'_>` by reference\n   --> $DIR/pass_ty_by_ref.rs:15:18"}, {"sha": "0040230ec7d7c6e4871c9f7f7dff7adcccaf78e8", "filename": "src/test/ui-fulldeps/internal-lints/qualified_ty_ty_ctxt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Z unstable-options\n \n #![feature(rustc_private)]\n-#![deny(usage_of_qualified_ty)]\n+#![deny(rustc::usage_of_qualified_ty)]\n #![allow(unused)]\n \n extern crate rustc;"}, {"sha": "72c23f8cd3cac0fc36ed3e96d1167c582ff33957", "filename": "src/test/ui-fulldeps/internal-lints/qualified_ty_ty_ctxt.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,8 +7,8 @@ LL |     ty_q: ty::Ty<'_>,\n note: lint level defined here\n   --> $DIR/qualified_ty_ty_ctxt.rs:4:9\n    |\n-LL | #![deny(usage_of_qualified_ty)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(rustc::usage_of_qualified_ty)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: usage of qualified `ty::TyCtxt<'_>`\n   --> $DIR/qualified_ty_ty_ctxt.rs:27:16"}, {"sha": "c6bd122f4e5489dd8f8f61733bbeed25977fb545", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -6,7 +6,7 @@ extern crate rustc;\n \n use rustc::ty::{self, Ty, TyKind};\n \n-#[deny(usage_of_ty_tykind)]\n+#[deny(rustc::usage_of_ty_tykind)]\n fn main() {\n     let sty = TyKind::Bool; //~ ERROR usage of `ty::TyKind::<kind>`\n "}, {"sha": "8add4252c4103a36e0b5c46161546eef87bab52c", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -7,8 +7,8 @@ LL |     let sty = TyKind::Bool;\n note: lint level defined here\n   --> $DIR/ty_tykind_usage.rs:9:8\n    |\n-LL | #[deny(usage_of_ty_tykind)]\n-   |        ^^^^^^^^^^^^^^^^^^\n+LL | #[deny(rustc::usage_of_ty_tykind)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:14:9"}, {"sha": "1c192a4d1d882d160e8ea7313f787b24f20369fe", "filename": "src/test/ui/async-await/async-closure-matches-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure-matches-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure-matches-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure-matches-expr.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,4 +1,4 @@\n-// compile-pass\n+// build-pass\n // edition:2018\n \n #![feature(async_await, async_closure)]"}, {"sha": "df9c8d894652b5b280d5df09b5568c270f05a273", "filename": "src/test/ui/attributes/attrs-with-no-formal-in-generics-1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-1.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -6,10 +6,8 @@\n \n struct RefIntPair<'a, 'b>(&'a u32, &'b u32);\n \n-impl<#[rustc_1] 'a, 'b, #[oops]> RefIntPair<'a, 'b> {\n+impl<#[rustc_dummy] 'a, 'b, #[oops]> RefIntPair<'a, 'b> {\n     //~^ ERROR trailing attribute after generic parameter\n }\n \n-fn main() {\n-\n-}\n+fn main() {}"}, {"sha": "5b4f5222a2b1404129d01d03eb521ad4221fdc41", "filename": "src/test/ui/attributes/attrs-with-no-formal-in-generics-1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-1.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,8 +1,8 @@\n error: trailing attribute after generic parameter\n-  --> $DIR/attrs-with-no-formal-in-generics-1.rs:9:25\n+  --> $DIR/attrs-with-no-formal-in-generics-1.rs:9:29\n    |\n-LL | impl<#[rustc_1] 'a, 'b, #[oops]> RefIntPair<'a, 'b> {\n-   |                         ^^^^^^^ attributes must go before parameters\n+LL | impl<#[rustc_dummy] 'a, 'b, #[oops]> RefIntPair<'a, 'b> {\n+   |                             ^^^^^^^ attributes must go before parameters\n \n error: aborting due to previous error\n "}, {"sha": "d1d044035260bf3fdadc7b641a42fc474f29910f", "filename": "src/test/ui/attributes/attrs-with-no-formal-in-generics-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-2.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -6,7 +6,7 @@\n \n struct RefAny<'a, T>(&'a T);\n \n-impl<#[rustc_1] 'a, #[rustc_2] T, #[oops]> RefAny<'a, T> {}\n+impl<#[rustc_dummy] 'a, #[rustc_dummy] T, #[oops]> RefAny<'a, T> {}\n //~^ ERROR trailing attribute after generic parameter\n \n fn main() {}"}, {"sha": "fce3ff7de78e88ec4a18e8fb712d2a7c45ca9fe4", "filename": "src/test/ui/attributes/attrs-with-no-formal-in-generics-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fattrs-with-no-formal-in-generics-2.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,8 +1,8 @@\n error: trailing attribute after generic parameter\n-  --> $DIR/attrs-with-no-formal-in-generics-2.rs:9:35\n+  --> $DIR/attrs-with-no-formal-in-generics-2.rs:9:43\n    |\n-LL | impl<#[rustc_1] 'a, #[rustc_2] T, #[oops]> RefAny<'a, T> {}\n-   |                                   ^^^^^^^ attributes must go before parameters\n+LL | impl<#[rustc_dummy] 'a, #[rustc_dummy] T, #[oops]> RefAny<'a, T> {}\n+   |                                           ^^^^^^^ attributes must go before parameters\n \n error: aborting due to previous error\n "}, {"sha": "0f9d37292958aa703dabcafad748323c8fe95a83", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr_feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -5,7 +5,7 @@ const fn error(_: fn()) {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_allow_const_fn_ptr]\n-//~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved\n+//~^ ERROR internal implementation detail\n const fn compiles(_: fn()) {}\n \n fn main() {}"}, {"sha": "d2ca0c8bc381b5a66e1edda7518cbe726e6fa965", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr_feature_gate.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n-  --> $DIR/allow_const_fn_ptr_feature_gate.rs:7:3\n+error[E0658]: internal implementation detail\n+  --> $DIR/allow_const_fn_ptr_feature_gate.rs:7:1\n    |\n LL | #[rustc_allow_const_fn_ptr]\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable"}, {"sha": "d3a2e486416afd9ae47c570f4f8c31c716b8e510", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,6 +1,23 @@\n // Test that `#[rustc_*]` attributes are gated by `rustc_attrs` feature gate.\n \n-#[rustc_foo]\n-//~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved\n+#![feature(decl_macro)]\n \n+mod rustc { pub macro unknown() {} }\n+mod unknown { pub macro rustc() {} }\n+\n+#[rustc::unknown]\n+//~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+//~| ERROR macro `rustc::unknown` may not be used in attributes\n+fn f() {}\n+\n+#[unknown::rustc]\n+//~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+//~| ERROR macro `unknown::rustc` may not be used in attributes\n+fn g() {}\n+\n+#[rustc_dummy]\n+//~^ ERROR used by the test suite\n+#[rustc_unknown]\n+//~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+//~| ERROR attribute `rustc_unknown` is currently unknown\n fn main() {}"}, {"sha": "cdc7b27a749e5f4c21eb31bc814e9b3c6c7f8155", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,12 +1,60 @@\n-error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n-  --> $DIR/feature-gate-rustc-attrs.rs:3:3\n+error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+  --> $DIR/feature-gate-rustc-attrs.rs:8:3\n    |\n-LL | #[rustc_foo]\n-   |   ^^^^^^^^^\n+LL | #[rustc::unknown]\n+   |   ^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n \n-error: aborting due to previous error\n+error: macro `rustc::unknown` may not be used in attributes\n+  --> $DIR/feature-gate-rustc-attrs.rs:8:1\n+   |\n+LL | #[rustc::unknown]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+  --> $DIR/feature-gate-rustc-attrs.rs:13:12\n+   |\n+LL | #[unknown::rustc]\n+   |            ^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n+\n+error: macro `unknown::rustc` may not be used in attributes\n+  --> $DIR/feature-gate-rustc-attrs.rs:13:1\n+   |\n+LL | #[unknown::rustc]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+  --> $DIR/feature-gate-rustc-attrs.rs:20:3\n+   |\n+LL | #[rustc_unknown]\n+   |   ^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n+\n+error[E0658]: The attribute `rustc_unknown` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/feature-gate-rustc-attrs.rs:20:3\n+   |\n+LL | #[rustc_unknown]\n+   |   ^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error[E0658]: used by the test suite\n+  --> $DIR/feature-gate-rustc-attrs.rs:18:1\n+   |\n+LL | #[rustc_dummy]\n+   | ^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "3c5cc84c6a6ac7d9e0e94c471de875fccfaa5894", "filename": "src/test/ui/generic/generic-param-attrs.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-param-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-param-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-param-attrs.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,44 +1,38 @@\n // This test previously ensured that attributes on formals in generic parameter\n // lists are rejected without a feature gate.\n-//\n-// (We are prefixing all tested features with `rustc_`, to ensure that\n-// the attributes themselves won't be rejected by the compiler when\n-// using `rustc_attrs` feature. There is a separate compile-fail/ test\n-// ensuring that the attribute feature-gating works in this context.)\n \n // build-pass (FIXME(62277): could be check-pass?)\n \n #![feature(rustc_attrs)]\n-#![allow(dead_code)]\n-\n-struct StLt<#[rustc_lt_struct] 'a>(&'a u32);\n-struct StTy<#[rustc_ty_struct] I>(I);\n-enum EnLt<#[rustc_lt_enum] 'b> { A(&'b u32), B }\n-enum EnTy<#[rustc_ty_enum] J> { A(J), B }\n-trait TrLt<#[rustc_lt_trait] 'c> { fn foo(&self, _: &'c [u32]) -> &'c u32; }\n-trait TrTy<#[rustc_ty_trait] K> { fn foo(&self, _: K); }\n-type TyLt<#[rustc_lt_type] 'd> = &'d u32;\n-type TyTy<#[rustc_ty_type] L> = (L, );\n-\n-impl<#[rustc_lt_inherent] 'e> StLt<'e> { }\n-impl<#[rustc_ty_inherent] M> StTy<M> { }\n-impl<#[rustc_lt_impl_for] 'f> TrLt<'f> for StLt<'f> {\n+\n+struct StLt<#[rustc_dummy] 'a>(&'a u32);\n+struct StTy<#[rustc_dummy] I>(I);\n+enum EnLt<#[rustc_dummy] 'b> { A(&'b u32), B }\n+enum EnTy<#[rustc_dummy] J> { A(J), B }\n+trait TrLt<#[rustc_dummy] 'c> { fn foo(&self, _: &'c [u32]) -> &'c u32; }\n+trait TrTy<#[rustc_dummy] K> { fn foo(&self, _: K); }\n+type TyLt<#[rustc_dummy] 'd> = &'d u32;\n+type TyTy<#[rustc_dummy] L> = (L, );\n+\n+impl<#[rustc_dummy] 'e> StLt<'e> { }\n+impl<#[rustc_dummy] M> StTy<M> { }\n+impl<#[rustc_dummy] 'f> TrLt<'f> for StLt<'f> {\n     fn foo(&self, _: &'f [u32]) -> &'f u32 { loop { } }\n }\n-impl<#[rustc_ty_impl_for] N> TrTy<N> for StTy<N> {\n+impl<#[rustc_dummy] N> TrTy<N> for StTy<N> {\n     fn foo(&self, _: N) { }\n }\n \n-fn f_lt<#[rustc_lt_fn] 'g>(_: &'g [u32]) -> &'g u32 { loop { } }\n-fn f_ty<#[rustc_ty_fn] O>(_: O) { }\n+fn f_lt<#[rustc_dummy] 'g>(_: &'g [u32]) -> &'g u32 { loop { } }\n+fn f_ty<#[rustc_dummy] O>(_: O) { }\n \n impl<I> StTy<I> {\n-    fn m_lt<#[rustc_lt_meth] 'h>(_: &'h [u32]) -> &'h u32 { loop { } }\n-    fn m_ty<#[rustc_ty_meth] P>(_: P) { }\n+    fn m_lt<#[rustc_dummy] 'h>(_: &'h [u32]) -> &'h u32 { loop { } }\n+    fn m_ty<#[rustc_dummy] P>(_: P) { }\n }\n \n fn hof_lt<Q>(_: Q)\n-    where Q: for <#[rustc_lt_hof] 'i> Fn(&'i [u32]) -> &'i u32\n+    where Q: for <#[rustc_dummy] 'i> Fn(&'i [u32]) -> &'i u32\n {}\n \n fn main() {}"}, {"sha": "553dea7aa6ed307c964879b9fc454b2e6fc352f7", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-elided.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-elided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-elided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-elided.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,5 @@\n // edition:2018\n-// compile-pass\n+// build-pass (FIXME(62277): could be check-pass?)\n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "43915e05e8824e46ed6e67a8dc321a3f400fdf33", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-existential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-existential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-existential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-existential.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,5 @@\n // edition:2018\n-// compile-pass\n+// build-pass (FIXME(62277): could be check-pass?)\n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "c0930ec5944e07df99f41c0fa276aae3726a652e", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,5 @@\n // edition:2018\n-// compile-pass\n+// build-pass (FIXME(62277): could be check-pass?)\n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "ed36bda7db719f128693d659f726e6d4bc042e01", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-other.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,5 @@\n // edition:2018\n-// compile-pass\n+// build-pass (FIXME(62277): could be check-pass?)\n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "fb50dce1af616ec86387b35749d668b3e526d0eb", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,10 +1,7 @@\n-// compile-flags:-Zborrowck=mir -Zverbose\n-\n // Test that we can deduce when projections like `T::Item` outlive the\n // function body. Test that this does not imply that `T: 'a` holds.\n \n-#![allow(warnings)]\n-#![feature(rustc_attrs)]\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n use std::cell::Cell;\n \n@@ -18,7 +15,6 @@ where\n     f(&value, Cell::new(&n));\n }\n \n-#[rustc_errors]\n fn generic1<T: Iterator>(value: T) {\n     // No error here:\n     twice(value, |value_ref, item| invoke1(item));\n@@ -30,7 +26,6 @@ where\n {\n }\n \n-#[rustc_errors]\n fn generic2<T: Iterator>(value: T) {\n     twice(value, |value_ref, item| invoke2(value_ref, item));\n     //~^ ERROR the parameter type `T` may not live long enough"}, {"sha": "9f0c60c1e1705a34424e546f32cc55a44bdb440f", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,5 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-implied-bounds.rs:35:18\n+  --> $DIR/projection-implied-bounds.rs:30:18\n    |\n LL |     twice(value, |value_ref, item| invoke2(value_ref, item));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a68c3cf12fd7179a1ecd3adab2a247d0c2fb24e4", "filename": "src/test/ui/nll/ty-outlives/ty-param-implied-bounds.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -4,9 +4,6 @@\n // Test that we assume that universal types like `T` outlive the\n // function body.\n \n-#![allow(warnings)]\n-#![feature(rustc_attrs)]\n-\n use std::cell::Cell;\n \n fn twice<F, T>(value: T, mut f: F)\n@@ -17,7 +14,6 @@ where\n     f(Cell::new(&value));\n }\n \n-#[rustc_errors]\n fn generic<T>(value: T) {\n     // No error here:\n     twice(value, |r| invoke(r));"}, {"sha": "f71c8cd0e0c398f7ebc29a3e59c16a6d2469059c", "filename": "src/test/ui/object-lifetime/object-lifetime-default.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,44 +1,44 @@\n-error: 'a,Ambiguous\n-  --> $DIR/object-lifetime-default.rs:24:1\n+error: BaseDefault\n+  --> $DIR/object-lifetime-default.rs:6:1\n    |\n-LL | struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct A<T>(T);\n+   | ^^^^^^^^^^^^^^^\n \n-error: 'a,'b\n-  --> $DIR/object-lifetime-default.rs:21:1\n+error: BaseDefault\n+  --> $DIR/object-lifetime-default.rs:9:1\n    |\n-LL | struct F<'a,'b,T:'a,U:'b>(&'a T, &'b U);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct B<'a,T>(&'a (), T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: 'b\n-  --> $DIR/object-lifetime-default.rs:18:1\n+error: 'a\n+  --> $DIR/object-lifetime-default.rs:12:1\n    |\n-LL | struct E<'a,'b:'a,T:'b>(&'a T, &'b T);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct C<'a,T:'a>(&'a T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Ambiguous\n   --> $DIR/object-lifetime-default.rs:15:1\n    |\n LL | struct D<'a,'b,T:'a+'b>(&'a T, &'b T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: 'a\n-  --> $DIR/object-lifetime-default.rs:12:1\n+error: 'b\n+  --> $DIR/object-lifetime-default.rs:18:1\n    |\n-LL | struct C<'a,T:'a>(&'a T);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct E<'a,'b:'a,T:'b>(&'a T, &'b T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: BaseDefault\n-  --> $DIR/object-lifetime-default.rs:9:1\n+error: 'a,'b\n+  --> $DIR/object-lifetime-default.rs:21:1\n    |\n-LL | struct B<'a,T>(&'a (), T);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct F<'a,'b,T:'a,U:'b>(&'a T, &'b U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: BaseDefault\n-  --> $DIR/object-lifetime-default.rs:6:1\n+error: 'a,Ambiguous\n+  --> $DIR/object-lifetime-default.rs:24:1\n    |\n-LL | struct A<T>(T);\n-   | ^^^^^^^^^^^^^^^\n+LL | struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 7 previous errors\n "}, {"sha": "437ae930934709c94b2e4e54f33cf46bc83a8cb2", "filename": "src/test/ui/proc-macro/expand-to-unstable-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,12 +1,12 @@\n // aux-build:derive-unstable-2.rs\n \n-#![allow(warnings)]\n-\n #[macro_use]\n extern crate derive_unstable_2;\n \n #[derive(Unstable)]\n-//~^ ERROR: reserved for internal compiler\n+//~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+//~| ERROR attribute `rustc_foo` is currently unknown to the compiler\n+\n struct A;\n \n fn main() {"}, {"sha": "803773db88e9636cecdcd07a0d10d59ad37a3c09", "filename": "src/test/ui/proc-macro/expand-to-unstable-2.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,12 +1,21 @@\n-error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n-  --> $DIR/expand-to-unstable-2.rs:8:10\n+error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+  --> $DIR/expand-to-unstable-2.rs:6:10\n    |\n LL | #[derive(Unstable)]\n    |          ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: The attribute `rustc_foo` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/expand-to-unstable-2.rs:6:10\n+   |\n+LL | #[derive(Unstable)]\n+   |          ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "cb535362266c00365163e35fd25ce5aa82f32b64", "filename": "src/test/ui/reserved/reserved-attr-on-macro.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,5 +1,7 @@\n #[rustc_attribute_should_be_reserved]\n-//~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved\n+//~^ ERROR attribute `rustc_attribute_should_be_reserved` is currently unknown\n+//~| ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+\n macro_rules! foo {\n     () => (());\n }"}, {"sha": "0c62c82017e18fb8c91879fccdb2e195a19a863f", "filename": "src/test/ui/reserved/reserved-attr-on-macro.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n+error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n   --> $DIR/reserved-attr-on-macro.rs:1:3\n    |\n LL | #[rustc_attribute_should_be_reserved]\n@@ -7,14 +7,23 @@ LL | #[rustc_attribute_should_be_reserved]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n \n+error[E0658]: The attribute `rustc_attribute_should_be_reserved` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/reserved-attr-on-macro.rs:1:3\n+   |\n+LL | #[rustc_attribute_should_be_reserved]\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n error: cannot determine resolution for the macro `foo`\n-  --> $DIR/reserved-attr-on-macro.rs:8:5\n+  --> $DIR/reserved-attr-on-macro.rs:10:5\n    |\n LL |     foo!();\n    |     ^^^\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "0e10131ce8d1f4d325935d7d5b0d835db04ff8d9", "filename": "src/test/ui/suggestions/attribute-typos.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,13 +1,11 @@\n-#[deprcated]    //~ ERROR E0658\n-fn foo() {}     //~| HELP a built-in attribute with a similar name exists\n-                //~| SUGGESTION deprecated\n-                //~| HELP add #![feature(custom_attribute)] to the crate attributes to enable\n+#[deprcated] //~ ERROR attribute `deprcated` is currently unknown\n+fn foo() {}\n \n-#[tests]        //~ ERROR E0658\n-fn bar() {}     //~| HELP a built-in attribute with a similar name exists\n-                //~| SUGGESTION test\n-                //~| HELP add #![feature(custom_attribute)] to the crate attributes to enable\n+#[tests] //~ ERROR attribute `tests` is currently unknown to the compiler\n+fn bar() {}\n \n-#[rustc_err]    //~ ERROR E0658\n-fn main() {}    //~| HELP add #![feature(rustc_attrs)] to the crate attributes to enable\n-                // don't suggest rustc attributes\n+#[rustc_err]\n+//~^ ERROR attribute `rustc_err` is currently unknown\n+//~| ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+\n+fn main() {}"}, {"sha": "958688b4d390652f111e5a559de34780c51eab8a", "filename": "src/test/ui/suggestions/attribute-typos.stderr", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -1,14 +1,23 @@\n-error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n-  --> $DIR/attribute-typos.rs:11:3\n+error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n+  --> $DIR/attribute-typos.rs:7:3\n    |\n LL | #[rustc_err]\n    |   ^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n \n+error[E0658]: The attribute `rustc_err` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/attribute-typos.rs:7:3\n+   |\n+LL | #[rustc_err]\n+   |   ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n error[E0658]: The attribute `tests` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/attribute-typos.rs:6:3\n+  --> $DIR/attribute-typos.rs:4:3\n    |\n LL | #[tests]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `test`\n@@ -25,6 +34,6 @@ LL | #[deprcated]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "b8008152e2a0525b47d825d285e1b6b4ac7f0602", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481068a707679257e2a738b40987246e0420e787/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=481068a707679257e2a738b40987246e0420e787", "patch": "@@ -591,9 +591,6 @@ impl TestProps {\n         } else if config.parse_name_directive(ln, \"build-pass\") {\n             check_no_run(\"build-pass\");\n             Some(PassMode::Build)\n-        } else if config.parse_name_directive(ln, \"compile-pass\") /* compatibility */ {\n-            check_no_run(\"compile-pass\");\n-            Some(PassMode::Build)\n         } else if config.parse_name_directive(ln, \"run-pass\") {\n             if config.mode != Mode::Ui && config.mode != Mode::RunPass /* compatibility */ {\n                 panic!(\"`run-pass` header is only supported in UI tests\")"}]}