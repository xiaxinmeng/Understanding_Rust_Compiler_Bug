{"sha": "16168dd1143c95c7ad1bebb1f8f0690c3265734d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MTY4ZGQxMTQzYzk1YzdhZDFiZWJiMWY4ZjA2OTBjMzI2NTczNGQ=", "commit": {"author": {"name": "bstrie", "email": "865233+bstrie@users.noreply.github.com", "date": "2021-06-14T19:46:50Z"}, "committer": {"name": "bstrie", "email": "865233+bstrie@users.noreply.github.com", "date": "2021-06-19T16:22:39Z"}, "message": "Clarify that certain intrinsics are not unsafe", "tree": {"sha": "a9d329e2d6a6739af2a80fe5642b5e8f83f21292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d329e2d6a6739af2a80fe5642b5e8f83f21292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16168dd1143c95c7ad1bebb1f8f0690c3265734d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16168dd1143c95c7ad1bebb1f8f0690c3265734d", "html_url": "https://github.com/rust-lang/rust/commit/16168dd1143c95c7ad1bebb1f8f0690c3265734d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16168dd1143c95c7ad1bebb1f8f0690c3265734d/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a216131c3566858b78f45ccc0c36b5578f5c5155", "url": "https://api.github.com/repos/rust-lang/rust/commits/a216131c3566858b78f45ccc0c36b5578f5c5155", "html_url": "https://github.com/rust-lang/rust/commit/a216131c3566858b78f45ccc0c36b5578f5c5155"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "7ba8f46cf6928155c6ae17aaf8e1ae056227ae41", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16168dd1143c95c7ad1bebb1f8f0690c3265734d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16168dd1143c95c7ad1bebb1f8f0690c3265734d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=16168dd1143c95c7ad1bebb1f8f0690c3265734d", "patch": "@@ -56,6 +56,10 @@ fn equate_intrinsic_type<'tcx>(\n /// Returns `true` if the given intrinsic is unsafe to call or not.\n pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n     match intrinsic {\n+        // When adding a new intrinsic to this list,\n+        // it's usually worth updating that intrinsic's documentation\n+        // to note that it's safe to call, since\n+        // safe extern fns are otherwise unprecedented.\n         sym::abort\n         | sym::size_of\n         | sym::min_align_of"}, {"sha": "9a955e970857f01f15fcf30a0dfcf1c073f28157", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/16168dd1143c95c7ad1bebb1f8f0690c3265734d/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16168dd1143c95c7ad1bebb1f8f0690c3265734d/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=16168dd1143c95c7ad1bebb1f8f0690c3265734d", "patch": "@@ -712,6 +712,11 @@ extern \"rust-intrinsic\" {\n \n     /// Aborts the execution of the process.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// A more user-friendly and stable version of this operation is\n     /// [`std::process::abort`](../../std/process/fn.abort.html).\n     pub fn abort() -> !;\n@@ -745,6 +750,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     pub fn likely(b: bool) -> bool;\n@@ -754,6 +764,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     pub fn unlikely(b: bool) -> bool;\n@@ -765,6 +780,11 @@ extern \"rust-intrinsic\" {\n \n     /// The size of a type in bytes.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n     ///\n@@ -774,6 +794,11 @@ extern \"rust-intrinsic\" {\n \n     /// The minimum alignment of a type.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n@@ -796,6 +821,11 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a static string slice containing the name of a type.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n@@ -804,6 +834,11 @@ extern \"rust-intrinsic\" {\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n@@ -829,6 +864,11 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n@@ -837,6 +877,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This exists solely for [`mem::forget_unsized`]; normal `forget` uses\n     /// `ManuallyDrop` instead.\n+    ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n     pub fn forget<T: ?Sized>(_: T);\n \n@@ -1090,6 +1135,11 @@ extern \"rust-intrinsic\" {\n     /// If the actual type neither requires drop glue nor implements\n     /// `Copy`, then the return value of this function is unspecified.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     pub fn needs_drop<T>() -> bool;\n@@ -1310,21 +1360,41 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the minimum of two `f32` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n@@ -1438,6 +1508,11 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of bits set in an integer type `T`\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `count_ones` method. For example,\n     /// [`u32::count_ones`]\n@@ -1446,6 +1521,11 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `leading_zeros` method. For example,\n     /// [`u32::leading_zeros`]\n@@ -1497,6 +1577,11 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `trailing_zeros` method. For example,\n     /// [`u32::trailing_zeros`]\n@@ -1548,6 +1633,11 @@ extern \"rust-intrinsic\" {\n \n     /// Reverses the bytes in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `swap_bytes` method. For example,\n     /// [`u32::swap_bytes`]\n@@ -1556,6 +1646,11 @@ extern \"rust-intrinsic\" {\n \n     /// Reverses the bits in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `reverse_bits` method. For example,\n     /// [`u32::reverse_bits`]\n@@ -1564,6 +1659,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs checked integer addition.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`u32::overflowing_add`]\n@@ -1572,6 +1672,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs checked integer subtraction\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`u32::overflowing_sub`]\n@@ -1580,6 +1685,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs checked integer multiplication\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`u32::overflowing_mul`]\n@@ -1649,6 +1759,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs rotate left.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`u32::rotate_left`]\n@@ -1657,6 +1772,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs rotate right.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`u32::rotate_right`]\n@@ -1665,20 +1785,35 @@ extern \"rust-intrinsic\" {\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`u32::wrapping_mul`]\n@@ -1687,13 +1822,23 @@ extern \"rust-intrinsic\" {\n \n     /// Computes `a + b`, saturating at numeric bounds.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`u32::saturating_sub`]\n@@ -1703,13 +1848,23 @@ extern \"rust-intrinsic\" {\n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n     /// if `T` has no variants, returns `0`. Uninhabited variants will be counted.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     pub fn variant_count<T>() -> usize;\n@@ -1732,10 +1887,20 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n+    ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n \n     /// See documentation of `<*const T>::guaranteed_ne` for details.\n+    ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n "}]}