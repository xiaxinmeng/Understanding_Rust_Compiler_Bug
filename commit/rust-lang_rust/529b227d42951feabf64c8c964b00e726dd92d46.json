{"sha": "529b227d42951feabf64c8c964b00e726dd92d46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyOWIyMjdkNDI5NTFmZWFiZjY0YzhjOTY0YjAwZTcyNmRkOTJkNDY=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-09T15:27:40Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-09T15:27:40Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "d54ea1a30905d4fd8798129103bb13921fb55c94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d54ea1a30905d4fd8798129103bb13921fb55c94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/529b227d42951feabf64c8c964b00e726dd92d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/529b227d42951feabf64c8c964b00e726dd92d46", "html_url": "https://github.com/rust-lang/rust/commit/529b227d42951feabf64c8c964b00e726dd92d46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/529b227d42951feabf64c8c964b00e726dd92d46/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "html_url": "https://github.com/rust-lang/rust/commit/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc"}, {"sha": "9d786ea221b27fbdf7c7f7beea0290db448e0611", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d786ea221b27fbdf7c7f7beea0290db448e0611", "html_url": "https://github.com/rust-lang/rust/commit/9d786ea221b27fbdf7c7f7beea0290db448e0611"}], "stats": {"total": 596, "additions": 406, "deletions": 190}, "files": [{"sha": "37ff1ce7631da55ba7eb50ce918c74dcea7811d9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -1060,6 +1060,7 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_mbe 0.1.0\",\n+ \"ra_parser 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\","}, {"sha": "945f236c22e7ac2a5ed1f472e2c3468564a44628", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -12,7 +12,7 @@ use crate::{\n \n impl Struct {\n     pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n-        db.struct_data(self.id).variant_data.clone()\n+        db.struct_data(self.id.into()).variant_data.clone()\n     }\n }\n "}, {"sha": "e5bfad3ca8142c2decfad15147c0b10cc593981f", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -288,19 +288,19 @@ pub struct Struct {\n \n impl Struct {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.0.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        db.struct_data(self.id).name.clone()\n+        db.struct_data(self.id.into()).name.clone()\n     }\n \n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n-        db.struct_data(self.id)\n+        db.struct_data(self.id.into())\n             .variant_data\n             .fields()\n             .into_iter()\n@@ -310,7 +310,7 @@ impl Struct {\n     }\n \n     pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        db.struct_data(self.id)\n+        db.struct_data(self.id.into())\n             .variant_data\n             .fields()\n             .into_iter()\n@@ -346,11 +346,11 @@ pub struct Union {\n \n impl Union {\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        db.union_data(self.id).name.clone()\n+        db.struct_data(self.id.into()).name.clone()\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.0.module(db) }\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {"}, {"sha": "247ae3e55d17037d8d82bb3b74ad0c68a4f71bd2", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -78,13 +78,13 @@ impl HasSource for StructField {\n impl HasSource for Struct {\n     type Ast = ast::StructDef;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n-        self.id.source(db)\n+        self.id.0.source(db)\n     }\n }\n impl HasSource for Union {\n     type Ast = ast::StructDef;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n-        self.id.source(db)\n+        self.id.0.source(db)\n     }\n }\n impl HasSource for Enum {"}, {"sha": "5a1eade2cc08b58e7d7720d4e36446055a0d9d4d", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -67,10 +67,7 @@ impl ExprScopes {\n         &self.scopes[scope].entries\n     }\n \n-    pub(crate) fn scope_chain<'a>(\n-        &'a self,\n-        scope: Option<ScopeId>,\n-    ) -> impl Iterator<Item = ScopeId> + 'a {\n+    pub(crate) fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }\n "}, {"sha": "c95d2cdd05d4c96f84d0557708b803e29f2499ae", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use hir_def::{StructId, StructOrUnionId, UnionId};\n use hir_expand::name::AsName;\n use ra_syntax::ast::{self, AstNode, NameOwner};\n \n@@ -15,18 +16,19 @@ pub trait FromSource: Sized {\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self>;\n }\n \n+// FIXIME: these two impls are wrong, `ast::StructDef` might produce either a struct or a union\n impl FromSource for Struct {\n     type Ast = ast::StructDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Struct { id })\n+        let id: StructOrUnionId = from_source(db, src)?;\n+        Some(Struct { id: StructId(id) })\n     }\n }\n impl FromSource for Union {\n     type Ast = ast::StructDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Union { id })\n+        let id: StructOrUnionId = from_source(db, src)?;\n+        Some(Union { id: UnionId(id) })\n     }\n }\n impl FromSource for Enum {"}, {"sha": "1fed5025eb80c21f26c5f246124801bda6fd9fc9", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -665,7 +665,7 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n }\n \n fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n-    let struct_data = db.struct_data(def.id);\n+    let struct_data = db.struct_data(def.id.into());\n     let fields = match struct_data.variant_data.fields() {\n         Some(fields) => fields,\n         None => panic!(\"fn_sig_for_struct_constructor called on unit struct\"),\n@@ -681,7 +681,7 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n \n /// Build the type of a tuple struct constructor.\n fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n-    let struct_data = db.struct_data(def.id);\n+    let struct_data = db.struct_data(def.id.into());\n     if struct_data.variant_data.fields().is_none() {\n         return type_for_adt(db, def); // Unit struct\n     }"}, {"sha": "a29c4d41e5fd0ddda57555078421b37fa2a8790f", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     db::DefDatabase2, type_ref::TypeRef, AstItemDef, EnumId, LocalEnumVariantId,\n-    LocalStructFieldId, StructId, UnionId,\n+    LocalStructFieldId, StructOrUnionId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -49,15 +49,11 @@ pub struct StructFieldData {\n }\n \n impl StructData {\n-    pub(crate) fn struct_data_query(db: &impl DefDatabase2, struct_: StructId) -> Arc<StructData> {\n-        let src = struct_.source(db);\n-        let name = src.ast.name().map(|n| n.as_name());\n-        let variant_data = VariantData::new(src.ast.kind());\n-        let variant_data = Arc::new(variant_data);\n-        Arc::new(StructData { name, variant_data })\n-    }\n-    pub(crate) fn union_data_query(db: &impl DefDatabase2, struct_: UnionId) -> Arc<StructData> {\n-        let src = struct_.source(db);\n+    pub(crate) fn struct_data_query(\n+        db: &impl DefDatabase2,\n+        id: StructOrUnionId,\n+    ) -> Arc<StructData> {\n+        let src = id.source(db);\n         let name = src.ast.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(src.ast.kind());\n         let variant_data = Arc::new(variant_data);"}, {"sha": "29cf71a594c5ce070660840a1c439954ee7b06bf", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -11,17 +11,16 @@ use crate::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    EnumId, StructId, UnionId,\n+    EnumId, StructOrUnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_function(&self, loc: crate::ItemLoc<ast::FnDef>) -> crate::FunctionId;\n     #[salsa::interned]\n-    fn intern_struct(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::StructId;\n-    #[salsa::interned]\n-    fn intern_union(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::UnionId;\n+    fn intern_struct_or_union(&self, loc: crate::ItemLoc<ast::StructDef>)\n+        -> crate::StructOrUnionId;\n     #[salsa::interned]\n     fn intern_enum(&self, loc: crate::ItemLoc<ast::EnumDef>) -> crate::EnumId;\n     #[salsa::interned]\n@@ -49,10 +48,7 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     fn crate_def_map(&self, krate: CrateId) -> Arc<CrateDefMap>;\n \n     #[salsa::invoke(StructData::struct_data_query)]\n-    fn struct_data(&self, s: StructId) -> Arc<StructData>;\n-\n-    #[salsa::invoke(StructData::union_data_query)]\n-    fn union_data(&self, s: UnionId) -> Arc<StructData>;\n+    fn struct_data(&self, id: StructOrUnionId) -> Arc<StructData>;\n \n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;"}, {"sha": "239317efe3bd1f159c0c2eed45f89342ef611bc3", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -205,26 +205,30 @@ impl AstItemDef<ast::FnDef> for FunctionId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(salsa::InternId);\n-impl_intern_key!(StructId);\n-impl AstItemDef<ast::StructDef> for StructId {\n+pub struct StructOrUnionId(salsa::InternId);\n+impl_intern_key!(StructOrUnionId);\n+impl AstItemDef<ast::StructDef> for StructOrUnionId {\n     fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n-        db.intern_struct(loc)\n+        db.intern_struct_or_union(loc)\n     }\n     fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n-        db.lookup_intern_struct(self)\n+        db.lookup_intern_struct_or_union(self)\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct UnionId(salsa::InternId);\n-impl_intern_key!(UnionId);\n-impl AstItemDef<ast::StructDef> for UnionId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n-        db.intern_union(loc)\n+pub struct StructId(pub StructOrUnionId);\n+impl From<StructId> for StructOrUnionId {\n+    fn from(id: StructId) -> StructOrUnionId {\n+        id.0\n     }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n-        db.lookup_intern_union(self)\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct UnionId(pub StructOrUnionId);\n+impl From<UnionId> for StructOrUnionId {\n+    fn from(id: UnionId) -> StructOrUnionId {\n+        id.0\n     }\n }\n "}, {"sha": "7e60839614f008e46a35b34da4607ccbd153faaa", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -19,7 +19,8 @@ use crate::{\n     },\n     path::{Path, PathKind},\n     AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,\n-    LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n+    LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, StructOrUnionId, TraitId, TypeAliasId,\n+    UnionId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -664,12 +665,14 @@ where\n                 PerNs::values(FunctionId::from_ast_id(ctx, ast_id).into())\n             }\n             raw::DefKind::Struct(ast_id) => {\n-                let s = StructId::from_ast_id(ctx, ast_id).into();\n+                let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();\n+                let s = StructId(id).into();\n                 PerNs::both(s, s)\n             }\n             raw::DefKind::Union(ast_id) => {\n-                let s = UnionId::from_ast_id(ctx, ast_id).into();\n-                PerNs::both(s, s)\n+                let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();\n+                let u = UnionId(id).into();\n+                PerNs::both(u, u)\n             }\n             raw::DefKind::Enum(ast_id) => PerNs::types(EnumId::from_ast_id(ctx, ast_id).into()),\n             raw::DefKind::Const(ast_id) => PerNs::values(ConstId::from_ast_id(ctx, ast_id).into()),"}, {"sha": "8f29bf7d9f0e33d40fcfea9561a489b9518959cc", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -10,6 +10,7 @@ log = \"0.4.5\"\n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n ra_syntax = { path = \"../ra_syntax\" }\n+ra_parser = { path = \"../ra_parser\" }\n ra_prof = { path = \"../ra_prof\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }"}, {"sha": "b4dafe1d87071303297b06e4afbd5aa901f77f71", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n \n use mbe::MacroRules;\n use ra_db::{salsa, SourceDatabase};\n+use ra_parser::FragmentKind;\n use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n@@ -22,9 +23,12 @@ pub trait AstDatabase: SourceDatabase {\n \n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n-    fn macro_arg(&self, id: MacroCallId) -> Option<Arc<tt::Subtree>>;\n-    fn macro_def(&self, id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n-    fn parse_macro(&self, macro_file: MacroFile) -> Option<Parse<SyntaxNode>>;\n+    fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n+    fn macro_def(&self, id: MacroDefId) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>>;\n+    fn parse_macro(\n+        &self,\n+        macro_file: MacroFile,\n+    ) -> Option<(Parse<SyntaxNode>, Arc<mbe::RevTokenMap>)>;\n     fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n }\n \n@@ -34,26 +38,32 @@ pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdM\n     Arc::new(map)\n }\n \n-pub(crate) fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+pub(crate) fn macro_def(\n+    db: &dyn AstDatabase,\n+    id: MacroDefId,\n+) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>> {\n     let macro_call = id.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+    let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n         log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n         None\n     })?;\n     let rules = MacroRules::parse(&tt).ok().or_else(|| {\n         log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n         None\n     })?;\n-    Some(Arc::new(rules))\n+    Some(Arc::new((rules, tmap)))\n }\n \n-pub(crate) fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<tt::Subtree>> {\n+pub(crate) fn macro_arg(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n     let loc = db.lookup_intern_macro(id);\n     let macro_call = loc.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n-    Some(Arc::new(tt))\n+    let (tt, tmap) = mbe::ast_to_token_tree(&arg)?;\n+    Some(Arc::new((tt, tmap)))\n }\n \n pub(crate) fn macro_expand(\n@@ -64,7 +74,7 @@ pub(crate) fn macro_expand(\n     let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+    let tt = macro_rules.0.expand(&macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {\n@@ -77,16 +87,17 @@ pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Optio\n     match file_id.0 {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n         HirFileIdRepr::MacroFile(macro_file) => {\n-            db.parse_macro(macro_file).map(|it| it.syntax_node())\n+            db.parse_macro(macro_file).map(|(it, _)| it.syntax_node())\n         }\n     }\n }\n \n pub(crate) fn parse_macro(\n     db: &dyn AstDatabase,\n     macro_file: MacroFile,\n-) -> Option<Parse<SyntaxNode>> {\n+) -> Option<(Parse<SyntaxNode>, Arc<mbe::RevTokenMap>)> {\n     let _p = profile(\"parse_macro_query\");\n+\n     let macro_call_id = macro_file.macro_call_id;\n     let tt = db\n         .macro_expand(macro_call_id)\n@@ -97,8 +108,11 @@ pub(crate) fn parse_macro(\n             log::warn!(\"fail on macro_parse: (reason: {})\", err,);\n         })\n         .ok()?;\n-    match macro_file.macro_file_kind {\n-        MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n-        MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n-    }\n+\n+    let fragment_kind = match macro_file.macro_file_kind {\n+        MacroFileKind::Items => FragmentKind::Items,\n+        MacroFileKind::Expr => FragmentKind::Expr,\n+    };\n+    let (parse, rev_token_map) = mbe::token_tree_to_syntax_node(&tt, fragment_kind).ok()?;\n+    Some((parse, Arc::new(rev_token_map)))\n }"}, {"sha": "151d1d7858ed881459f464af6a3eae26339fc6d3", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -12,11 +12,12 @@ pub mod hygiene;\n pub mod diagnostics;\n \n use std::hash::{Hash, Hasher};\n+use std::sync::Arc;\n \n use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode,\n+    SyntaxNode, TextRange, TextUnit,\n };\n \n use crate::ast_id_map::FileAstId;\n@@ -66,6 +67,30 @@ impl HirFileId {\n             }\n         }\n     }\n+\n+    /// Return expansion information if it is a macro-expansion file\n+    pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+\n+                let arg_start = loc.ast_id.to_node(db).token_tree()?.syntax().text_range().start();\n+                let def_start =\n+                    loc.def.ast_id.to_node(db).token_tree()?.syntax().text_range().start();\n+\n+                let macro_def = db.macro_def(loc.def)?;\n+                let shift = macro_def.0.shift();\n+                let exp_map = db.parse_macro(macro_file)?.1;\n+                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+\n+                let arg_start = (loc.ast_id.file_id, arg_start);\n+                let def_start = (loc.def.ast_id.file_id, def_start);\n+\n+                Some(ExpansionInfo { arg_start, def_start, macro_arg, macro_def, exp_map, shift })\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -112,6 +137,38 @@ impl MacroCallId {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+/// ExpansionInfo mainly describes how to map text range between src and expanded macro\n+pub struct ExpansionInfo {\n+    pub(crate) arg_start: (HirFileId, TextUnit),\n+    pub(crate) def_start: (HirFileId, TextUnit),\n+    pub(crate) shift: u32,\n+\n+    pub(crate) macro_def: Arc<(mbe::MacroRules, mbe::TokenMap)>,\n+    pub(crate) macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    pub(crate) exp_map: Arc<mbe::RevTokenMap>,\n+}\n+\n+impl ExpansionInfo {\n+    pub fn find_range(&self, from: TextRange) -> Option<(HirFileId, TextRange)> {\n+        let token_id = look_in_rev_map(&self.exp_map, from)?;\n+\n+        let (token_map, (file_id, start_offset), token_id) = if token_id.0 >= self.shift {\n+            (&self.macro_arg.1, self.arg_start, tt::TokenId(token_id.0 - self.shift).into())\n+        } else {\n+            (&self.macro_def.1, self.def_start, token_id)\n+        };\n+\n+        let range = token_map.relative_range_of(token_id)?;\n+\n+        return Some((file_id, range + start_offset));\n+\n+        fn look_in_rev_map(exp_map: &mbe::RevTokenMap, from: TextRange) -> Option<tt::TokenId> {\n+            exp_map.ranges.iter().find(|&it| it.0.is_subrange(&from)).map(|it| it.1)\n+        }\n+    }\n+}\n+\n /// `AstId` points to an AST node in any file.\n ///\n /// It is stable across reparses, and can be used as salsa key/value."}, {"sha": "1bf81e7d5195103716a3bd44646e0627fa41ef4e", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 88, "deletions": 32, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -29,6 +29,21 @@ pub struct NavigationTarget {\n     docs: Option<String>,\n }\n \n+fn find_range_from_node(\n+    db: &RootDatabase,\n+    src: hir::HirFileId,\n+    node: &SyntaxNode,\n+) -> (FileId, TextRange) {\n+    let text_range = node.text_range();\n+    let (file_id, text_range) = src\n+        .expansion_info(db)\n+        .and_then(|expansion_info| expansion_info.find_range(text_range))\n+        .unwrap_or((src, text_range));\n+\n+    // FIXME: handle recursive macro generated macro\n+    (file_id.original_file(db), text_range)\n+}\n+\n impl NavigationTarget {\n     /// When `focus_range` is specified, returns it. otherwise\n     /// returns `full_range`\n@@ -72,8 +87,12 @@ impl NavigationTarget {\n         self.focus_range\n     }\n \n-    pub(crate) fn from_bind_pat(file_id: FileId, pat: &ast::BindPat) -> NavigationTarget {\n-        NavigationTarget::from_named(file_id, pat, None, None)\n+    pub(crate) fn from_bind_pat(\n+        db: &RootDatabase,\n+        file_id: FileId,\n+        pat: &ast::BindPat,\n+    ) -> NavigationTarget {\n+        NavigationTarget::from_named(db, file_id.into(), pat, None, None)\n     }\n \n     pub(crate) fn from_symbol(db: &RootDatabase, symbol: FileSymbol) -> NavigationTarget {\n@@ -96,7 +115,7 @@ impl NavigationTarget {\n     ) -> NavigationTarget {\n         let parse = db.parse(file_id);\n         let pat = pat.to_node(parse.tree().syntax());\n-        NavigationTarget::from_bind_pat(file_id, &pat)\n+        NavigationTarget::from_bind_pat(db, file_id, &pat)\n     }\n \n     pub(crate) fn from_self_param(\n@@ -119,31 +138,46 @@ impl NavigationTarget {\n \n     pub(crate) fn from_module(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let src = module.definition_source(db);\n-        let file_id = src.file_id.original_file(db);\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         match src.ast {\n             ModuleSource::SourceFile(node) => {\n-                NavigationTarget::from_syntax(file_id, name, None, node.syntax(), None, None)\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n+\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    name,\n+                    None,\n+                    text_range,\n+                    node.syntax(),\n+                    None,\n+                    None,\n+                )\n+            }\n+            ModuleSource::Module(node) => {\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n+\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    name,\n+                    None,\n+                    text_range,\n+                    node.syntax(),\n+                    node.doc_comment_text(),\n+                    node.short_label(),\n+                )\n             }\n-            ModuleSource::Module(node) => NavigationTarget::from_syntax(\n-                file_id,\n-                name,\n-                None,\n-                node.syntax(),\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            ),\n         }\n     }\n \n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n-            let file_id = src.file_id.original_file(db);\n+            let (file_id, text_range) = find_range_from_node(db, src.file_id, src.ast.syntax());\n             return NavigationTarget::from_syntax(\n                 file_id,\n                 name,\n                 None,\n+                text_range,\n                 src.ast.syntax(),\n                 src.ast.doc_comment_text(),\n                 src.ast.short_label(),\n@@ -154,13 +188,25 @@ impl NavigationTarget {\n \n     pub(crate) fn from_field(db: &RootDatabase, field: hir::StructField) -> NavigationTarget {\n         let src = field.source(db);\n-        let file_id = src.file_id.original_file(db);\n         match src.ast {\n-            FieldSource::Named(it) => {\n-                NavigationTarget::from_named(file_id, &it, it.doc_comment_text(), it.short_label())\n-            }\n+            FieldSource::Named(it) => NavigationTarget::from_named(\n+                db,\n+                src.file_id,\n+                &it,\n+                it.doc_comment_text(),\n+                it.short_label(),\n+            ),\n             FieldSource::Pos(it) => {\n-                NavigationTarget::from_syntax(file_id, \"\".into(), None, it.syntax(), None, None)\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, it.syntax());\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    \"\".into(),\n+                    None,\n+                    text_range,\n+                    it.syntax(),\n+                    None,\n+                    None,\n+                )\n             }\n         }\n     }\n@@ -172,7 +218,8 @@ impl NavigationTarget {\n     {\n         let src = def.source(db);\n         NavigationTarget::from_named(\n-            src.file_id.original_file(db),\n+            db,\n+            src.file_id,\n             &src.ast,\n             src.ast.doc_comment_text(),\n             src.ast.short_label(),\n@@ -212,10 +259,13 @@ impl NavigationTarget {\n         impl_block: hir::ImplBlock,\n     ) -> NavigationTarget {\n         let src = impl_block.source(db);\n+        let (file_id, text_range) = find_range_from_node(db, src.file_id, src.ast.syntax());\n+\n         NavigationTarget::from_syntax(\n-            src.file_id.original_file(db),\n+            file_id,\n             \"impl\".into(),\n             None,\n+            text_range,\n             src.ast.syntax(),\n             None,\n             None,\n@@ -236,12 +286,7 @@ impl NavigationTarget {\n     pub(crate) fn from_macro_def(db: &RootDatabase, macro_call: hir::MacroDef) -> NavigationTarget {\n         let src = macro_call.source(db);\n         log::debug!(\"nav target {:#?}\", src.ast.syntax());\n-        NavigationTarget::from_named(\n-            src.file_id.original_file(db),\n-            &src.ast,\n-            src.ast.doc_comment_text(),\n-            None,\n-        )\n+        NavigationTarget::from_named(db, src.file_id, &src.ast, src.ast.doc_comment_text(), None)\n     }\n \n     #[cfg(test)]\n@@ -270,21 +315,33 @@ impl NavigationTarget {\n \n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n     pub(crate) fn from_named(\n-        file_id: FileId,\n+        db: &RootDatabase,\n+        file_id: hir::HirFileId,\n         node: &impl ast::NameOwner,\n         docs: Option<String>,\n         description: Option<String>,\n     ) -> NavigationTarget {\n         //FIXME: use `_` instead of empty string\n         let name = node.name().map(|it| it.text().clone()).unwrap_or_default();\n-        let focus_range = node.name().map(|it| it.syntax().text_range());\n-        NavigationTarget::from_syntax(file_id, name, focus_range, node.syntax(), docs, description)\n+        let focus_range = node.name().map(|it| find_range_from_node(db, file_id, it.syntax()).1);\n+        let (file_id, full_range) = find_range_from_node(db, file_id, node.syntax());\n+\n+        NavigationTarget::from_syntax(\n+            file_id,\n+            name,\n+            focus_range,\n+            full_range,\n+            node.syntax(),\n+            docs,\n+            description,\n+        )\n     }\n \n     fn from_syntax(\n         file_id: FileId,\n         name: SmolStr,\n         focus_range: Option<TextRange>,\n+        full_range: TextRange,\n         node: &SyntaxNode,\n         docs: Option<String>,\n         description: Option<String>,\n@@ -293,9 +350,8 @@ impl NavigationTarget {\n             file_id,\n             name,\n             kind: node.kind(),\n-            full_range: node.text_range(),\n+            full_range,\n             focus_range,\n-            // ptr: Some(LocalSyntaxPtr::new(node)),\n             container_name: None,\n             description,\n             docs,"}, {"sha": "afa59cbe3ac3a6e8f0af17d2239615ad2f3b3901", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 64, "deletions": 13, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -101,99 +101,110 @@ pub(crate) fn name_definition(\n         }\n     }\n \n-    if let Some(nav) = named_target(file_id, &parent) {\n+    if let Some(nav) = named_target(db, file_id, &parent) {\n         return Some(vec![nav]);\n     }\n \n     None\n }\n \n-fn named_target(file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n+fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n     match_ast! {\n         match node {\n             ast::StructDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::EnumDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::EnumVariant(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::FnDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::TypeAliasDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::ConstDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::StaticDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::TraitDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::RecordFieldDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::Module(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::MacroCall(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     None,\n@@ -334,6 +345,46 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_definition_works_for_macro_defined_fn_with_arg() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            macro_rules! define_fn {\n+                ($name:ident) => (fn $name() {})\n+            }\n+\n+            define_fn!(\n+                foo\n+            )\n+\n+            fn bar() {\n+               <|>foo();\n+            }\n+            \",\n+            \"foo FN_DEF FileId(1) [80; 83) [80; 83)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_definition_works_for_macro_defined_fn_no_arg() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            macro_rules! define_fn {\n+                () => (fn foo() {})\n+            }\n+\n+            define_fn!();\n+\n+            fn bar() {\n+               <|>foo();\n+            }\n+            \",\n+            \"foo FN_DEF FileId(1) [39; 42) [39; 42)\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_definition_works_for_methods() {\n         covers!(goto_definition_works_for_methods);"}, {"sha": "1bb27eb8512345760ce173f3ae44c3fba35833ac", "filename": "crates/ra_ide_api/src/status.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -94,10 +94,10 @@ impl FromIterator<TableEntry<FileId, Parse<ast::SourceFile>>> for SyntaxTreeStat\n     }\n }\n \n-impl FromIterator<TableEntry<MacroFile, Option<Parse<SyntaxNode>>>> for SyntaxTreeStats {\n+impl<M> FromIterator<TableEntry<MacroFile, Option<(Parse<SyntaxNode>, M)>>> for SyntaxTreeStats {\n     fn from_iter<T>(iter: T) -> SyntaxTreeStats\n     where\n-        T: IntoIterator<Item = TableEntry<MacroFile, Option<Parse<SyntaxNode>>>>,\n+        T: IntoIterator<Item = TableEntry<MacroFile, Option<(Parse<SyntaxNode>, M)>>>,\n     {\n         let mut res = SyntaxTreeStats::default();\n         for entry in iter {"}, {"sha": "8a31d1c360aa1b25262d4717e039c34ab8d5de08", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -31,8 +31,7 @@ pub enum ExpandError {\n }\n \n pub use crate::syntax_bridge::{\n-    ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_expr, token_tree_to_items,\n-    token_tree_to_macro_stmts, token_tree_to_pat, token_tree_to_ty,\n+    ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_syntax_node, RevTokenMap, TokenMap,\n };\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n@@ -118,6 +117,10 @@ impl MacroRules {\n         shift_subtree(&mut tt, self.shift);\n         mbe_expander::expand(self, &tt)\n     }\n+\n+    pub fn shift(&self) -> u32 {\n+        self.shift\n+    }\n }\n \n impl Rule {"}, {"sha": "3f57ce3b5011f88a52cdeb68f2ac2c2696ef0442", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -1,9 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_parser::{\n-    FragmentKind::{self, *},\n-    ParseError, TreeSink,\n-};\n+use ra_parser::{FragmentKind, ParseError, TreeSink};\n use ra_syntax::{\n     ast, AstNode, AstToken, NodeOrToken, Parse, SmolStr, SyntaxKind, SyntaxKind::*, SyntaxNode,\n     SyntaxTreeBuilder, TextRange, TextUnit, T,\n@@ -14,12 +11,18 @@ use crate::subtree_source::SubtreeTokenSource;\n use crate::ExpandError;\n \n /// Maps `tt::TokenId` to the relative range of the original token.\n-#[derive(Default)]\n+#[derive(Debug, PartialEq, Eq, Default)]\n pub struct TokenMap {\n     /// Maps `tt::TokenId` to the *relative* source range.\n     tokens: Vec<TextRange>,\n }\n \n+/// Maps relative range of the expanded syntax node to `tt::TokenId`\n+#[derive(Debug, PartialEq, Eq, Default)]\n+pub struct RevTokenMap {\n+    pub ranges: Vec<(TextRange, tt::TokenId)>,\n+}\n+\n /// Convert the syntax tree (what user has written) to a `TokenTree` (what macro\n /// will consume).\n pub fn ast_to_token_tree(ast: &ast::TokenTree) -> Option<(tt::Subtree, TokenMap)> {\n@@ -49,10 +52,10 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n // * ImplItems(SmallVec<[ast::ImplItem; 1]>)\n // * ForeignItems(SmallVec<[ast::ForeignItem; 1]>\n \n-fn fragment_to_syntax_node(\n+pub fn token_tree_to_syntax_node(\n     tt: &tt::Subtree,\n     fragment_kind: FragmentKind,\n-) -> Result<Parse<SyntaxNode>, ExpandError> {\n+) -> Result<(Parse<SyntaxNode>, RevTokenMap), ExpandError> {\n     let tmp;\n     let tokens = match tt {\n         tt::Subtree { delimiter: tt::Delimiter::None, token_trees } => token_trees.as_slice(),\n@@ -69,38 +72,8 @@ fn fragment_to_syntax_node(\n         return Err(ExpandError::ConversionError);\n     }\n     //FIXME: would be cool to report errors\n-    let parse = tree_sink.inner.finish();\n-    Ok(parse)\n-}\n-\n-/// Parses the token tree (result of macro expansion) to an expression\n-pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<Parse<ast::Expr>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Expr)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) to a Pattern\n-pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<Parse<ast::Pat>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Pattern)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) to a Type\n-pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<Parse<ast::TypeRef>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Type)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) as a sequence of stmts\n-pub fn token_tree_to_macro_stmts(tt: &tt::Subtree) -> Result<Parse<ast::MacroStmts>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Statements)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) as a sequence of items\n-pub fn token_tree_to_items(tt: &tt::Subtree) -> Result<Parse<ast::MacroItems>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Items)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n+    let (parse, range_map) = tree_sink.finish();\n+    Ok((parse, range_map))\n }\n \n impl TokenMap {\n@@ -116,6 +89,12 @@ impl TokenMap {\n     }\n }\n \n+impl RevTokenMap {\n+    fn add(&mut self, relative_range: TextRange, token_id: tt::TokenId) {\n+        self.ranges.push((relative_range, token_id.clone()))\n+    }\n+}\n+\n /// Returns the textual content of a doc comment block as a quoted string\n /// That is, strips leading `///` (or `/**`, etc)\n /// and strips the ending `*/`\n@@ -262,6 +241,7 @@ struct TtTreeSink<'a> {\n     cursor: Cursor<'a>,\n     text_pos: TextUnit,\n     inner: SyntaxTreeBuilder,\n+    range_map: RevTokenMap,\n \n     // Number of roots\n     // Use for detect ill-form tree which is not single root\n@@ -276,8 +256,13 @@ impl<'a> TtTreeSink<'a> {\n             text_pos: 0.into(),\n             inner: SyntaxTreeBuilder::default(),\n             roots: smallvec::SmallVec::new(),\n+            range_map: RevTokenMap::default(),\n         }\n     }\n+\n+    fn finish(self) -> (Parse<SyntaxNode>, RevTokenMap) {\n+        (self.inner.finish(), self.range_map)\n+    }\n }\n \n fn delim_to_str(d: tt::Delimiter, closing: bool) -> SmolStr {\n@@ -307,6 +292,15 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n \n             match self.cursor.token_tree() {\n                 Some(tt::TokenTree::Leaf(leaf)) => {\n+                    // Mark the range if needed\n+                    if let tt::Leaf::Ident(ident) = leaf {\n+                        if kind == IDENT {\n+                            let range =\n+                                TextRange::offset_len(self.text_pos, TextUnit::of_str(&ident.text));\n+                            self.range_map.add(range, ident.id);\n+                        }\n+                    }\n+\n                     self.cursor = self.cursor.bump();\n                     self.buf += &format!(\"{}\", leaf);\n                 }\n@@ -337,6 +331,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n         {\n             if curr.spacing == tt::Spacing::Alone {\n                 self.inner.token(WHITESPACE, \" \".into());\n+                self.text_pos += TextUnit::of_char(' ');\n             }\n         }\n     }\n@@ -423,6 +418,6 @@ mod tests {\n             \"#,\n         );\n         let expansion = expand(&rules, \"stmts!();\");\n-        assert!(token_tree_to_expr(&expansion).is_err());\n+        assert!(token_tree_to_syntax_node(&expansion, FragmentKind::Expr).is_err());\n     }\n }"}, {"sha": "0109a4d980ec90f9c5ce68700beade2be8865930", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529b227d42951feabf64c8c964b00e726dd92d46/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=529b227d42951feabf64c8c964b00e726dd92d46", "patch": "@@ -1,3 +1,4 @@\n+use ra_parser::FragmentKind;\n use ra_syntax::{ast, AstNode, NodeOrToken, WalkEvent};\n use test_utils::assert_eq_text;\n \n@@ -126,9 +127,9 @@ fn test_expr_order() {\n \"#,\n     );\n     let expanded = expand(&rules, \"foo! { 1 + 1}\");\n-    let tree = token_tree_to_items(&expanded).unwrap().tree();\n+    let tree = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node();\n \n-    let dump = format!(\"{:#?}\", tree.syntax());\n+    let dump = format!(\"{:#?}\", tree);\n     assert_eq_text!(\n         dump.trim(),\n         r#\"MACRO_ITEMS@[0; 15)\n@@ -383,9 +384,9 @@ fn test_expand_to_item_list() {\n             \",\n     );\n     let expansion = expand(&rules, \"structs!(Foo, Bar);\");\n-    let tree = token_tree_to_items(&expansion).unwrap().tree();\n+    let tree = token_tree_to_syntax_node(&expansion, FragmentKind::Items).unwrap().0.syntax_node();\n     assert_eq!(\n-        format!(\"{:#?}\", tree.syntax()).trim(),\n+        format!(\"{:#?}\", tree).trim(),\n         r#\"\n MACRO_ITEMS@[0; 40)\n   STRUCT_DEF@[0; 20)\n@@ -501,10 +502,11 @@ fn test_tt_to_stmts() {\n     );\n \n     let expanded = expand(&rules, \"foo!{}\");\n-    let stmts = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n+    let stmts =\n+        token_tree_to_syntax_node(&expanded, FragmentKind::Statements).unwrap().0.syntax_node();\n \n     assert_eq!(\n-        format!(\"{:#?}\", stmts.syntax()).trim(),\n+        format!(\"{:#?}\", stmts).trim(),\n         r#\"MACRO_STMTS@[0; 15)\n   LET_STMT@[0; 7)\n     LET_KW@[0; 3) \"let\"\n@@ -754,7 +756,10 @@ fn test_all_items() {\n         }\n \"#,\n     );\n-    assert_expansion(MacroKind::Items, &rules, r#\"\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"\n         foo! {\n             extern crate a;\n             mod b;\n@@ -770,7 +775,9 @@ fn test_all_items() {\n             extern {}\n             type T = u8;\n         }\n-\"#, r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#);\n+\"#,\n+        r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#,\n+    );\n }\n \n #[test]\n@@ -946,10 +953,10 @@ fn test_vec() {\n     );\n \n     let expansion = expand(&rules, r#\"vec![1u32,2];\"#);\n-    let tree = token_tree_to_expr(&expansion).unwrap().tree();\n+    let tree = token_tree_to_syntax_node(&expansion, FragmentKind::Expr).unwrap().0.syntax_node();\n \n     assert_eq!(\n-        format!(\"{:#?}\", tree.syntax()).trim(),\n+        format!(\"{:#?}\", tree).trim(),\n         r#\"BLOCK_EXPR@[0; 45)\n   BLOCK@[0; 45)\n     L_CURLY@[0; 1) \"{\"\n@@ -1088,8 +1095,12 @@ macro_rules! generate_pattern_iterators {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n-        \"fn foo () {}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n+        \"fn foo () {}\",\n+    );\n }\n \n #[test]\n@@ -1171,8 +1182,12 @@ fn test_impl_nonzero_fmt() {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n-        \"fn foo () {}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n+        \"fn foo () {}\",\n+    );\n }\n \n #[test]\n@@ -1189,8 +1204,12 @@ fn test_cfg_if_items() {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n-        \"__cfg_if_items ! {(rustdoc ,) ;}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n+        \"__cfg_if_items ! {(rustdoc ,) ;}\",\n+    );\n }\n \n #[test]\n@@ -1233,10 +1252,13 @@ cfg_if !   {\n \"#,\n         \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"\n cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n \"#,\n-        \"\"\n+        \"\",\n     );\n }\n \n@@ -1291,10 +1313,13 @@ macro_rules! RIDL {\n }\"#,\n     );\n \n-    let expanded = expand(&rules, r#\"\n+    let expanded = expand(\n+        &rules,\n+        r#\"\n RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n     fn GetDataSize(&mut self) -> UINT\n-}}\"#);\n+}}\"#,\n+    );\n     assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n }\n \n@@ -1340,7 +1365,8 @@ quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n \n #[test]\n fn test_empty_repeat_vars_in_empty_repeat_vars() {\n-    let rules = create_rules(r#\"\n+    let rules = create_rules(\n+        r#\"\n macro_rules! delegate_impl {\n     ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n      pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n@@ -1385,9 +1411,15 @@ macro_rules! delegate_impl {\n         }\n     }\n }\n-\"#);\n+\"#,\n+    );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#, \"impl <> Data for & \\'a mut G where G : Data {}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#,\n+        \"impl <> Data for & \\'a mut G where G : Data {}\",\n+    );\n }\n \n pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n@@ -1436,22 +1468,30 @@ pub(crate) fn assert_expansion(\n     };\n     let (expanded_tree, expected_tree) = match kind {\n         MacroKind::Items => {\n-            let expanded_tree = token_tree_to_items(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_items(&expected).unwrap().tree();\n+            let expanded_tree =\n+                token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node();\n+            let expected_tree =\n+                token_tree_to_syntax_node(&expected, FragmentKind::Items).unwrap().0.syntax_node();\n \n             (\n-                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n-                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(&expanded_tree).trim().to_string(),\n+                debug_dump_ignore_spaces(&expected_tree).trim().to_string(),\n             )\n         }\n \n         MacroKind::Stmts => {\n-            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().tree();\n+            let expanded_tree = token_tree_to_syntax_node(&expanded, FragmentKind::Statements)\n+                .unwrap()\n+                .0\n+                .syntax_node();\n+            let expected_tree = token_tree_to_syntax_node(&expected, FragmentKind::Statements)\n+                .unwrap()\n+                .0\n+                .syntax_node();\n \n             (\n-                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n-                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(&expanded_tree).trim().to_string(),\n+                debug_dump_ignore_spaces(&expected_tree).trim().to_string(),\n             )\n         }\n     };"}]}