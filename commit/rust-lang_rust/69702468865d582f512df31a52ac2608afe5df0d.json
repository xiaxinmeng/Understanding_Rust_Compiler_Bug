{"sha": "69702468865d582f512df31a52ac2608afe5df0d", "node_id": "C_kwDOAAsO6NoAKDY5NzAyNDY4ODY1ZDU4MmY1MTJkZjMxYTUyYWMyNjA4YWZlNWRmMGQ", "commit": {"author": {"name": "Jacob Pratt", "email": "jacob@jhpratt.dev", "date": "2022-05-21T01:06:44Z"}, "committer": {"name": "Jacob Pratt", "email": "jacob@jhpratt.dev", "date": "2022-05-21T04:32:47Z"}, "message": "Remove `crate` visibility modifier in libs, tests", "tree": {"sha": "12c11456a618b7ca4dffd47967802e7f46cb2ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12c11456a618b7ca4dffd47967802e7f46cb2ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69702468865d582f512df31a52ac2608afe5df0d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQTgxeqBxcDGar1sVhy4DhnkZitapAUCYohrbwAKCRC4DhnkZita\npJZ9AP9ZXtuLVbD3gvGd0B2OW0O+mHy614NGc1PuIUTIoQe3AAEA00xTZ/e96Z6S\n10MC7TA4Qi1nJ/F4u5crEzCiU4EnpAY=\n=gB7j\n-----END PGP SIGNATURE-----", "payload": "tree 12c11456a618b7ca4dffd47967802e7f46cb2ed4\nparent 49c82f31a85f04a709810de4ccfb8ba765c1377b\nauthor Jacob Pratt <jacob@jhpratt.dev> 1653095204 -0400\ncommitter Jacob Pratt <jacob@jhpratt.dev> 1653107567 -0400\n\nRemove `crate` visibility modifier in libs, tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69702468865d582f512df31a52ac2608afe5df0d", "html_url": "https://github.com/rust-lang/rust/commit/69702468865d582f512df31a52ac2608afe5df0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69702468865d582f512df31a52ac2608afe5df0d/comments", "author": {"login": "jhpratt", "id": 3161395, "node_id": "MDQ6VXNlcjMxNjEzOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3161395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhpratt", "html_url": "https://github.com/jhpratt", "followers_url": "https://api.github.com/users/jhpratt/followers", "following_url": "https://api.github.com/users/jhpratt/following{/other_user}", "gists_url": "https://api.github.com/users/jhpratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhpratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhpratt/subscriptions", "organizations_url": "https://api.github.com/users/jhpratt/orgs", "repos_url": "https://api.github.com/users/jhpratt/repos", "events_url": "https://api.github.com/users/jhpratt/events{/privacy}", "received_events_url": "https://api.github.com/users/jhpratt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhpratt", "id": 3161395, "node_id": "MDQ6VXNlcjMxNjEzOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3161395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhpratt", "html_url": "https://github.com/jhpratt", "followers_url": "https://api.github.com/users/jhpratt/followers", "following_url": "https://api.github.com/users/jhpratt/following{/other_user}", "gists_url": "https://api.github.com/users/jhpratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhpratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhpratt/subscriptions", "organizations_url": "https://api.github.com/users/jhpratt/orgs", "repos_url": "https://api.github.com/users/jhpratt/repos", "events_url": "https://api.github.com/users/jhpratt/events{/privacy}", "received_events_url": "https://api.github.com/users/jhpratt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49c82f31a85f04a709810de4ccfb8ba765c1377b", "url": "https://api.github.com/repos/rust-lang/rust/commits/49c82f31a85f04a709810de4ccfb8ba765c1377b", "html_url": "https://github.com/rust-lang/rust/commit/49c82f31a85f04a709810de4ccfb8ba765c1377b"}], "stats": {"total": 2289, "additions": 1037, "deletions": 1252}, "files": [{"sha": "27fb4709982bdbc96f94574fbfda96e5bc88e2c6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -20,12 +20,12 @@ struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>,\n }\n \n-crate struct AutoTraitFinder<'a, 'tcx> {\n-    crate cx: &'a mut core::DocContext<'tcx>,\n+pub(crate) struct AutoTraitFinder<'a, 'tcx> {\n+    pub(crate) cx: &'a mut core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> Self {\n+    pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> Self {\n         AutoTraitFinder { cx }\n     }\n \n@@ -130,7 +130,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         })\n     }\n \n-    crate fn get_auto_trait_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n+    pub(crate) fn get_auto_trait_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n         let tcx = self.cx.tcx;\n         let param_env = tcx.param_env(item_def_id);\n         let ty = tcx.type_of(item_def_id);"}, {"sha": "c591c591331117b45d51db11d695a7f62d207a06", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -8,12 +8,12 @@ use rustc_span::DUMMY_SP;\n \n use super::*;\n \n-crate struct BlanketImplFinder<'a, 'tcx> {\n-    crate cx: &'a mut core::DocContext<'tcx>,\n+pub(crate) struct BlanketImplFinder<'a, 'tcx> {\n+    pub(crate) cx: &'a mut core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n-    crate fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n+    pub(crate) fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(item_def_id);\n         let ty = self.cx.tcx.bound_type_of(item_def_id);\n "}, {"sha": "deac1723b26208d48deb1137074d762a1a5f6822", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -21,7 +21,7 @@ use crate::html::escape::Escape;\n mod tests;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-crate enum Cfg {\n+pub(crate) enum Cfg {\n     /// Accepts all configurations.\n     True,\n     /// Denies all configurations.\n@@ -37,9 +37,9 @@ crate enum Cfg {\n }\n \n #[derive(PartialEq, Debug)]\n-crate struct InvalidCfgError {\n-    crate msg: &'static str,\n-    crate span: Span,\n+pub(crate) struct InvalidCfgError {\n+    pub(crate) msg: &'static str,\n+    pub(crate) span: Span,\n }\n \n impl Cfg {\n@@ -56,7 +56,7 @@ impl Cfg {\n         }\n     }\n \n-    crate fn parse_without(\n+    pub(crate) fn parse_without(\n         cfg: &MetaItem,\n         exclude: &FxHashSet<Cfg>,\n     ) -> Result<Option<Cfg>, InvalidCfgError> {\n@@ -117,15 +117,15 @@ impl Cfg {\n     ///\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n-    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+    pub(crate) fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n         Self::parse_without(cfg, &FxHashSet::default()).map(|ret| ret.unwrap())\n     }\n \n     /// Checks whether the given configuration can be matched in the current session.\n     ///\n     /// Equivalent to `attr::cfg_matches`.\n     // FIXME: Actually make use of `features`.\n-    crate fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+    pub(crate) fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n         match *self {\n             Cfg::False => false,\n             Cfg::True => true,"}, {"sha": "1b6658bb4cab8f4c3775c9779778fdc532addea0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -38,7 +38,7 @@ type Attrs<'hir> = &'hir [ast::Attribute];\n /// and `Some` of a vector of items if it was successfully expanded.\n ///\n /// `parent_module` refers to the parent of the *re-export*, not the original item.\n-crate fn try_inline(\n+pub(crate) fn try_inline(\n     cx: &mut DocContext<'_>,\n     parent_module: DefId,\n     import_def_id: Option<DefId>,\n@@ -134,7 +134,7 @@ crate fn try_inline(\n     Some(ret)\n }\n \n-crate fn try_inline_glob(\n+pub(crate) fn try_inline_glob(\n     cx: &mut DocContext<'_>,\n     res: Res,\n     visited: &mut FxHashSet<DefId>,\n@@ -154,15 +154,15 @@ crate fn try_inline_glob(\n     }\n }\n \n-crate fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n+pub(crate) fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n     cx.tcx.get_attrs_unchecked(did)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType) {\n+pub(crate) fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType) {\n     let crate_name = cx.tcx.crate_name(did.krate);\n \n     let relative =\n@@ -190,7 +190,7 @@ crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType)\n     }\n }\n \n-crate fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Trait {\n+pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Trait {\n     let trait_items = cx\n         .tcx\n         .associated_items(did)\n@@ -274,7 +274,7 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n }\n \n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n-crate fn build_impls(\n+pub(crate) fn build_impls(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n@@ -318,7 +318,7 @@ fn merge_attrs(\n }\n \n /// Inline an `impl`, inherent or of a trait. The `did` must be for an `impl`.\n-crate fn build_impl(\n+pub(crate) fn build_impl(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n@@ -565,7 +565,7 @@ fn build_module(\n     clean::Module { items, span }\n }\n \n-crate fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n+pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n     if let Some(did) = did.as_local() {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n         rustc_hir_pretty::id_to_string(&tcx.hir(), hir_id)\n@@ -670,7 +670,7 @@ fn separate_supertrait_bounds(\n     (g, ty_bounds)\n }\n \n-crate fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n+pub(crate) fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n     if did.is_local() {\n         return;\n     }"}, {"sha": "4f66b4a240c391f9d041a7001100d581bcd57667", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -3,12 +3,12 @@\n \n mod auto_trait;\n mod blanket_impl;\n-crate mod cfg;\n-crate mod inline;\n+pub(crate) mod cfg;\n+pub(crate) mod inline;\n mod render_macro_matchers;\n mod simplify;\n-crate mod types;\n-crate mod utils;\n+pub(crate) mod types;\n+pub(crate) mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -41,10 +41,10 @@ use crate::visit_ast::Module as DocModule;\n \n use utils::*;\n \n-crate use self::types::*;\n-crate use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n+pub(crate) use self::types::*;\n+pub(crate) use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n-crate trait Clean<T> {\n+pub(crate) trait Clean<T> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> T;\n }\n "}, {"sha": "af7813a77409238ef7d4abf6ff1a1dfcab0e19a1", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -21,7 +21,7 @@ use crate::clean::GenericArgs as PP;\n use crate::clean::WherePredicate as WP;\n use crate::core::DocContext;\n \n-crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n+pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components.\n     //\n     // We use `FxIndexMap` so that the insertion order is preserved to prevent messing up to\n@@ -79,7 +79,7 @@ crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n-crate fn merge_bounds(\n+pub(crate) fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,"}, {"sha": "edf7ddb30dbf9779f6894fafb7d439b9635a572b", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 294, "deletions": 290, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -44,22 +44,22 @@ use crate::formats::item_type::ItemType;\n use crate::html::render::Context;\n use crate::passes::collect_intra_doc_links::UrlFragment;\n \n-crate use self::FnRetTy::*;\n-crate use self::ItemKind::*;\n-crate use self::SelfTy::*;\n-crate use self::Type::{\n+pub(crate) use self::FnRetTy::*;\n+pub(crate) use self::ItemKind::*;\n+pub(crate) use self::SelfTy::*;\n+pub(crate) use self::Type::{\n     Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive, QPath,\n     RawPointer, Slice, Tuple,\n };\n-crate use self::Visibility::{Inherited, Public};\n+pub(crate) use self::Visibility::{Inherited, Public};\n \n #[cfg(test)]\n mod tests;\n \n-crate type ItemIdSet = FxHashSet<ItemId>;\n+pub(crate) type ItemIdSet = FxHashSet<ItemId>;\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\n-crate enum ItemId {\n+pub(crate) enum ItemId {\n     /// A \"normal\" item that uses a [`DefId`] for identification.\n     DefId(DefId),\n     /// Identifier that is used for auto traits.\n@@ -72,7 +72,7 @@ crate enum ItemId {\n \n impl ItemId {\n     #[inline]\n-    crate fn is_local(self) -> bool {\n+    pub(crate) fn is_local(self) -> bool {\n         match self {\n             ItemId::Auto { for_: id, .. }\n             | ItemId::Blanket { for_: id, .. }\n@@ -83,21 +83,21 @@ impl ItemId {\n \n     #[inline]\n     #[track_caller]\n-    crate fn expect_def_id(self) -> DefId {\n+    pub(crate) fn expect_def_id(self) -> DefId {\n         self.as_def_id()\n             .unwrap_or_else(|| panic!(\"ItemId::expect_def_id: `{:?}` isn't a DefId\", self))\n     }\n \n     #[inline]\n-    crate fn as_def_id(self) -> Option<DefId> {\n+    pub(crate) fn as_def_id(self) -> Option<DefId> {\n         match self {\n             ItemId::DefId(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    crate fn krate(self) -> CrateNum {\n+    pub(crate) fn krate(self) -> CrateNum {\n         match self {\n             ItemId::Auto { for_: id, .. }\n             | ItemId::Blanket { for_: id, .. }\n@@ -115,57 +115,57 @@ impl From<DefId> for ItemId {\n \n /// The crate currently being documented.\n #[derive(Clone, Debug)]\n-crate struct Crate {\n-    crate module: Item,\n-    crate primitives: ThinVec<(DefId, PrimitiveType)>,\n+pub(crate) struct Crate {\n+    pub(crate) module: Item,\n+    pub(crate) primitives: ThinVec<(DefId, PrimitiveType)>,\n     /// Only here so that they can be filtered through the rustdoc passes.\n-    crate external_traits: Rc<RefCell<FxHashMap<DefId, TraitWithExtraInfo>>>,\n+    pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, TraitWithExtraInfo>>>,\n }\n \n // `Crate` is frequently moved by-value. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Crate, 72);\n \n impl Crate {\n-    crate fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n+    pub(crate) fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n         ExternalCrate::LOCAL.name(tcx)\n     }\n \n-    crate fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n+    pub(crate) fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n         ExternalCrate::LOCAL.src(tcx)\n     }\n }\n \n /// This struct is used to wrap additional information added by rustdoc on a `trait` item.\n #[derive(Clone, Debug)]\n-crate struct TraitWithExtraInfo {\n-    crate trait_: Trait,\n-    crate is_notable: bool,\n+pub(crate) struct TraitWithExtraInfo {\n+    pub(crate) trait_: Trait,\n+    pub(crate) is_notable: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate struct ExternalCrate {\n-    crate crate_num: CrateNum,\n+pub(crate) struct ExternalCrate {\n+    pub(crate) crate_num: CrateNum,\n }\n \n impl ExternalCrate {\n     const LOCAL: Self = Self { crate_num: LOCAL_CRATE };\n \n     #[inline]\n-    crate fn def_id(&self) -> DefId {\n+    pub(crate) fn def_id(&self) -> DefId {\n         self.crate_num.as_def_id()\n     }\n \n-    crate fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n+    pub(crate) fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n         let krate_span = tcx.def_span(self.def_id());\n         tcx.sess.source_map().span_to_filename(krate_span)\n     }\n \n-    crate fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n+    pub(crate) fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n         tcx.crate_name(self.crate_num)\n     }\n \n-    crate fn src_root(&self, tcx: TyCtxt<'_>) -> PathBuf {\n+    pub(crate) fn src_root(&self, tcx: TyCtxt<'_>) -> PathBuf {\n         match self.src(tcx) {\n             FileName::Real(ref p) => match p.local_path_if_available().parent() {\n                 Some(p) => p.to_path_buf(),\n@@ -177,7 +177,7 @@ impl ExternalCrate {\n \n     /// Attempts to find where an external crate is located, given that we're\n     /// rendering in to the specified source destination.\n-    crate fn location(\n+    pub(crate) fn location(\n         &self,\n         extern_url: Option<&str>,\n         extern_url_takes_precedence: bool,\n@@ -221,7 +221,7 @@ impl ExternalCrate {\n             .unwrap_or(Unknown) // Well, at least we tried.\n     }\n \n-    crate fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n+    pub(crate) fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n         let root = self.def_id();\n \n         let as_keyword = |res: Res<!>| {\n@@ -268,7 +268,7 @@ impl ExternalCrate {\n         }\n     }\n \n-    crate fn primitives(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, PrimitiveType)> {\n+    pub(crate) fn primitives(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, PrimitiveType)> {\n         let root = self.def_id();\n \n         // Collect all inner modules which are tagged as implementations of\n@@ -341,7 +341,7 @@ impl ExternalCrate {\n \n /// Indicates where an external crate can be found.\n #[derive(Debug)]\n-crate enum ExternalLocation {\n+pub(crate) enum ExternalLocation {\n     /// Remote URL root of the external crate\n     Remote(String),\n     /// This external crate can be found in the local doc/ folder\n@@ -354,18 +354,18 @@ crate enum ExternalLocation {\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n #[derive(Clone)]\n-crate struct Item {\n+pub(crate) struct Item {\n     /// The name of this item.\n     /// Optional because not every item has a name, e.g. impls.\n-    crate name: Option<Symbol>,\n-    crate attrs: Box<Attributes>,\n-    crate visibility: Visibility,\n+    pub(crate) name: Option<Symbol>,\n+    pub(crate) attrs: Box<Attributes>,\n+    pub(crate) visibility: Visibility,\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n-    crate kind: Box<ItemKind>,\n-    crate item_id: ItemId,\n+    pub(crate) kind: Box<ItemKind>,\n+    pub(crate) item_id: ItemId,\n \n-    crate cfg: Option<Arc<Cfg>>,\n+    pub(crate) cfg: Option<Arc<Cfg>>,\n }\n \n /// NOTE: this does NOT unconditionally print every item, to avoid thousands of lines of logs.\n@@ -393,7 +393,7 @@ impl fmt::Debug for Item {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Item, 56);\n \n-crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n+pub(crate) fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     Span::new(def_id.as_local().map_or_else(\n         || tcx.def_span(def_id),\n         |local| {\n@@ -404,26 +404,26 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n }\n \n impl Item {\n-    crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n+    pub(crate) fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n-    crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n+    pub(crate) fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n-    crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n+    pub(crate) fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n     }\n \n-    crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n+    pub(crate) fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n         self.item_id\n             .as_def_id()\n             .map(|did| tcx.get_attrs_unchecked(did).inner_docs())\n             .unwrap_or(false)\n     }\n \n-    crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n+    pub(crate) fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         let kind = match &*self.kind {\n             ItemKind::StrippedItem(k) => k,\n             _ => &*self.kind,\n@@ -444,19 +444,19 @@ impl Item {\n         }\n     }\n \n-    crate fn attr_span(&self, tcx: TyCtxt<'_>) -> rustc_span::Span {\n+    pub(crate) fn attr_span(&self, tcx: TyCtxt<'_>) -> rustc_span::Span {\n         crate::passes::span_of_attrs(&self.attrs).unwrap_or_else(|| self.span(tcx).inner())\n     }\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<String> {\n+    pub(crate) fn doc_value(&self) -> Option<String> {\n         self.attrs.doc_value()\n     }\n \n     /// Convenience wrapper around [`Self::from_def_id_and_parts`] which converts\n     /// `hir_id` to a [`DefId`]\n-    crate fn from_hir_id_and_parts(\n+    pub(crate) fn from_hir_id_and_parts(\n         hir_id: hir::HirId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n@@ -465,7 +465,7 @@ impl Item {\n         Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n     }\n \n-    crate fn from_def_id_and_parts(\n+    pub(crate) fn from_def_id_and_parts(\n         def_id: DefId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n@@ -483,7 +483,7 @@ impl Item {\n         )\n     }\n \n-    crate fn from_def_id_and_attrs_and_parts(\n+    pub(crate) fn from_def_id_and_attrs_and_parts(\n         def_id: DefId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n@@ -508,11 +508,11 @@ impl Item {\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    crate fn collapsed_doc_value(&self) -> Option<String> {\n+    pub(crate) fn collapsed_doc_value(&self) -> Option<String> {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    crate fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n+    pub(crate) fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n \n         cx.cache()\n@@ -544,7 +544,7 @@ impl Item {\n     /// This is used for generating summary text, which does not include\n     /// the link text, but does need to know which `[]`-bracketed names\n     /// are actually links.\n-    crate fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n+    pub(crate) fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n         cache\n             .intra_doc_links\n             .get(&self.item_id)\n@@ -558,68 +558,68 @@ impl Item {\n             .collect()\n     }\n \n-    crate fn is_crate(&self) -> bool {\n+    pub(crate) fn is_crate(&self) -> bool {\n         self.is_mod() && self.item_id.as_def_id().map_or(false, |did| did.is_crate_root())\n     }\n-    crate fn is_mod(&self) -> bool {\n+    pub(crate) fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n     }\n-    crate fn is_trait(&self) -> bool {\n+    pub(crate) fn is_trait(&self) -> bool {\n         self.type_() == ItemType::Trait\n     }\n-    crate fn is_struct(&self) -> bool {\n+    pub(crate) fn is_struct(&self) -> bool {\n         self.type_() == ItemType::Struct\n     }\n-    crate fn is_enum(&self) -> bool {\n+    pub(crate) fn is_enum(&self) -> bool {\n         self.type_() == ItemType::Enum\n     }\n-    crate fn is_variant(&self) -> bool {\n+    pub(crate) fn is_variant(&self) -> bool {\n         self.type_() == ItemType::Variant\n     }\n-    crate fn is_associated_type(&self) -> bool {\n+    pub(crate) fn is_associated_type(&self) -> bool {\n         matches!(&*self.kind, AssocTypeItem(..) | StrippedItem(box AssocTypeItem(..)))\n     }\n-    crate fn is_ty_associated_type(&self) -> bool {\n+    pub(crate) fn is_ty_associated_type(&self) -> bool {\n         matches!(&*self.kind, TyAssocTypeItem(..) | StrippedItem(box TyAssocTypeItem(..)))\n     }\n-    crate fn is_associated_const(&self) -> bool {\n+    pub(crate) fn is_associated_const(&self) -> bool {\n         matches!(&*self.kind, AssocConstItem(..) | StrippedItem(box AssocConstItem(..)))\n     }\n-    crate fn is_ty_associated_const(&self) -> bool {\n+    pub(crate) fn is_ty_associated_const(&self) -> bool {\n         matches!(&*self.kind, TyAssocConstItem(..) | StrippedItem(box TyAssocConstItem(..)))\n     }\n-    crate fn is_method(&self) -> bool {\n+    pub(crate) fn is_method(&self) -> bool {\n         self.type_() == ItemType::Method\n     }\n-    crate fn is_ty_method(&self) -> bool {\n+    pub(crate) fn is_ty_method(&self) -> bool {\n         self.type_() == ItemType::TyMethod\n     }\n-    crate fn is_typedef(&self) -> bool {\n+    pub(crate) fn is_typedef(&self) -> bool {\n         self.type_() == ItemType::Typedef\n     }\n-    crate fn is_primitive(&self) -> bool {\n+    pub(crate) fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n-    crate fn is_union(&self) -> bool {\n+    pub(crate) fn is_union(&self) -> bool {\n         self.type_() == ItemType::Union\n     }\n-    crate fn is_import(&self) -> bool {\n+    pub(crate) fn is_import(&self) -> bool {\n         self.type_() == ItemType::Import\n     }\n-    crate fn is_extern_crate(&self) -> bool {\n+    pub(crate) fn is_extern_crate(&self) -> bool {\n         self.type_() == ItemType::ExternCrate\n     }\n-    crate fn is_keyword(&self) -> bool {\n+    pub(crate) fn is_keyword(&self) -> bool {\n         self.type_() == ItemType::Keyword\n     }\n-    crate fn is_stripped(&self) -> bool {\n+    pub(crate) fn is_stripped(&self) -> bool {\n         match *self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n-    crate fn has_stripped_fields(&self) -> Option<bool> {\n+    pub(crate) fn has_stripped_fields(&self) -> Option<bool> {\n         match *self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n@@ -628,7 +628,7 @@ impl Item {\n         }\n     }\n \n-    crate fn stability_class(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+    pub(crate) fn stability_class(&self, tcx: TyCtxt<'_>) -> Option<String> {\n         self.stability(tcx).as_ref().and_then(|s| {\n             let mut classes = Vec::with_capacity(2);\n \n@@ -645,30 +645,30 @@ impl Item {\n         })\n     }\n \n-    crate fn stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n+    pub(crate) fn stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n         match self.stability(tcx)?.level {\n             StabilityLevel::Stable { since, .. } => Some(since),\n             StabilityLevel::Unstable { .. } => None,\n         }\n     }\n \n-    crate fn const_stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n+    pub(crate) fn const_stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n         match self.const_stability(tcx)?.level {\n             StabilityLevel::Stable { since, .. } => Some(since),\n             StabilityLevel::Unstable { .. } => None,\n         }\n     }\n \n-    crate fn is_non_exhaustive(&self) -> bool {\n+    pub(crate) fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter().any(|a| a.has_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n-    crate fn type_(&self) -> ItemType {\n+    pub(crate) fn type_(&self) -> ItemType {\n         ItemType::from(self)\n     }\n \n-    crate fn is_default(&self) -> bool {\n+    pub(crate) fn is_default(&self) -> bool {\n         match *self.kind {\n             ItemKind::MethodItem(_, Some(defaultness)) => {\n                 defaultness.has_value() && !defaultness.is_final()\n@@ -678,7 +678,7 @@ impl Item {\n     }\n \n     /// Returns a `FnHeader` if `self` is a function item, otherwise returns `None`.\n-    crate fn fn_header(&self, tcx: TyCtxt<'_>) -> Option<hir::FnHeader> {\n+    pub(crate) fn fn_header(&self, tcx: TyCtxt<'_>) -> Option<hir::FnHeader> {\n         fn build_fn_header(\n             def_id: DefId,\n             tcx: TyCtxt<'_>,\n@@ -721,7 +721,7 @@ impl Item {\n }\n \n #[derive(Clone, Debug)]\n-crate enum ItemKind {\n+pub(crate) enum ItemKind {\n     ExternCrateItem {\n         /// The crate's name, *not* the name it's imported as.\n         src: Option<Symbol>,\n@@ -774,7 +774,7 @@ crate enum ItemKind {\n impl ItemKind {\n     /// Some items contain others such as structs (for their fields) and Enums\n     /// (for their variants). This method returns those contained items.\n-    crate fn inner_items(&self) -> impl Iterator<Item = &Item> {\n+    pub(crate) fn inner_items(&self) -> impl Iterator<Item = &Item> {\n         match self {\n             StructItem(s) => s.fields.iter(),\n             UnionItem(u) => u.fields.iter(),\n@@ -813,12 +813,12 @@ impl ItemKind {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Module {\n-    crate items: Vec<Item>,\n-    crate span: Span,\n+pub(crate) struct Module {\n+    pub(crate) items: Vec<Item>,\n+    pub(crate) span: Span,\n }\n \n-crate trait AttributesExt {\n+pub(crate) trait AttributesExt {\n     type AttributeIterator<'a>: Iterator<Item = ast::NestedMetaItem>\n     where\n         Self: 'a;\n@@ -949,7 +949,7 @@ impl AttributesExt for [ast::Attribute] {\n     }\n }\n \n-crate trait NestedAttributesExt {\n+pub(crate) trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `word`\n     fn has_word(self, word: Symbol) -> bool\n     where\n@@ -978,24 +978,24 @@ impl<I: Iterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-crate struct DocFragment {\n-    crate span: rustc_span::Span,\n+pub(crate) struct DocFragment {\n+    pub(crate) span: rustc_span::Span,\n     /// The module this doc-comment came from.\n     ///\n     /// This allows distinguishing between the original documentation and a pub re-export.\n     /// If it is `None`, the item was not re-exported.\n-    crate parent_module: Option<DefId>,\n-    crate doc: Symbol,\n-    crate kind: DocFragmentKind,\n-    crate indent: usize,\n+    pub(crate) parent_module: Option<DefId>,\n+    pub(crate) doc: Symbol,\n+    pub(crate) kind: DocFragmentKind,\n+    pub(crate) indent: usize,\n }\n \n // `DocFragment` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(DocFragment, 32);\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-crate enum DocFragmentKind {\n+pub(crate) enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc,\n     /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n@@ -1027,7 +1027,7 @@ fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n \n /// Collapse a collection of [`DocFragment`]s into one string,\n /// handling indentation and newlines as needed.\n-crate fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n+pub(crate) fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n     let mut acc = String::new();\n     for frag in doc_strings {\n         add_doc_fragment(&mut acc, frag);\n@@ -1120,44 +1120,44 @@ fn unindent_doc_fragments(docs: &mut Vec<DocFragment>) {\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n #[derive(Clone, Debug, PartialEq, Eq)]\n-crate struct ItemLink {\n+pub(crate) struct ItemLink {\n     /// The original link written in the markdown\n-    crate link: String,\n+    pub(crate) link: String,\n     /// The link text displayed in the HTML.\n     ///\n     /// This may not be the same as `link` if there was a disambiguator\n     /// in an intra-doc link (e.g. \\[`fn@f`\\])\n-    crate link_text: String,\n-    crate did: DefId,\n+    pub(crate) link_text: String,\n+    pub(crate) did: DefId,\n     /// The url fragment to append to the link\n-    crate fragment: Option<UrlFragment>,\n+    pub(crate) fragment: Option<UrlFragment>,\n }\n \n pub struct RenderedLink {\n     /// The text the link was original written as.\n     ///\n     /// This could potentially include disambiguators and backticks.\n-    crate original_text: String,\n+    pub(crate) original_text: String,\n     /// The text to display in the HTML\n-    crate new_text: String,\n+    pub(crate) new_text: String,\n     /// The URL to put in the `href`\n-    crate href: String,\n+    pub(crate) href: String,\n }\n \n /// The attributes on an [`Item`], including attributes like `#[derive(...)]` and `#[inline]`,\n /// as well as doc comments.\n #[derive(Clone, Debug, Default)]\n-crate struct Attributes {\n-    crate doc_strings: Vec<DocFragment>,\n-    crate other_attrs: Vec<ast::Attribute>,\n+pub(crate) struct Attributes {\n+    pub(crate) doc_strings: Vec<DocFragment>,\n+    pub(crate) other_attrs: Vec<ast::Attribute>,\n }\n \n impl Attributes {\n-    crate fn lists(&self, name: Symbol) -> impl Iterator<Item = ast::NestedMetaItem> + '_ {\n+    pub(crate) fn lists(&self, name: Symbol) -> impl Iterator<Item = ast::NestedMetaItem> + '_ {\n         self.other_attrs.lists(name)\n     }\n \n-    crate fn has_doc_flag(&self, flag: Symbol) -> bool {\n+    pub(crate) fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n             if !attr.has_name(sym::doc) {\n                 continue;\n@@ -1173,7 +1173,7 @@ impl Attributes {\n         false\n     }\n \n-    crate fn from_ast(\n+    pub(crate) fn from_ast(\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n@@ -1185,7 +1185,7 @@ impl Attributes {\n         Attributes::from_ast_iter(attrs1.chain(attrs2), false)\n     }\n \n-    crate fn from_ast_iter<'a>(\n+    pub(crate) fn from_ast_iter<'a>(\n         attrs: impl Iterator<Item = (&'a ast::Attribute, Option<DefId>)>,\n         doc_only: bool,\n     ) -> Attributes {\n@@ -1214,7 +1214,7 @@ impl Attributes {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<String> {\n+    pub(crate) fn doc_value(&self) -> Option<String> {\n         let mut iter = self.doc_strings.iter();\n \n         let ori = iter.next()?;\n@@ -1232,7 +1232,7 @@ impl Attributes {\n     ///\n     /// The last newline is not trimmed so the produced strings are reusable between\n     /// early and late doc link resolution regardless of their position.\n-    crate fn prepare_to_doc_link_resolution(&self) -> FxHashMap<Option<DefId>, String> {\n+    pub(crate) fn prepare_to_doc_link_resolution(&self) -> FxHashMap<Option<DefId>, String> {\n         let mut res = FxHashMap::default();\n         for fragment in &self.doc_strings {\n             let out_str = res.entry(fragment.parent_module).or_default();\n@@ -1243,15 +1243,15 @@ impl Attributes {\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    crate fn collapsed_doc_value(&self) -> Option<String> {\n+    pub(crate) fn collapsed_doc_value(&self) -> Option<String> {\n         if self.doc_strings.is_empty() {\n             None\n         } else {\n             Some(collapse_doc_fragments(&self.doc_strings))\n         }\n     }\n \n-    crate fn get_doc_aliases(&self) -> Box<[Symbol]> {\n+    pub(crate) fn get_doc_aliases(&self) -> Box<[Symbol]> {\n         let mut aliases = FxHashSet::default();\n \n         for attr in self.other_attrs.lists(sym::doc).filter(|a| a.has_name(sym::alias)) {\n@@ -1286,13 +1286,13 @@ impl PartialEq for Attributes {\n impl Eq for Attributes {}\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericBound {\n+pub(crate) enum GenericBound {\n     TraitBound(PolyTrait, hir::TraitBoundModifier),\n     Outlives(Lifetime),\n }\n \n impl GenericBound {\n-    crate fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n+    pub(crate) fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, did, false, vec![], empty);\n@@ -1303,7 +1303,7 @@ impl GenericBound {\n         )\n     }\n \n-    crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n+    pub(crate) fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n@@ -1313,14 +1313,14 @@ impl GenericBound {\n         false\n     }\n \n-    crate fn get_poly_trait(&self) -> Option<PolyTrait> {\n+    pub(crate) fn get_poly_trait(&self) -> Option<PolyTrait> {\n         if let GenericBound::TraitBound(ref p, _) = *self {\n             return Some(p.clone());\n         }\n         None\n     }\n \n-    crate fn get_trait_path(&self) -> Option<Path> {\n+    pub(crate) fn get_trait_path(&self) -> Option<Path> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             Some(trait_.clone())\n         } else {\n@@ -1330,27 +1330,27 @@ impl GenericBound {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Lifetime(pub Symbol);\n+pub(crate) struct Lifetime(pub Symbol);\n \n impl Lifetime {\n-    crate fn statik() -> Lifetime {\n+    pub(crate) fn statik() -> Lifetime {\n         Lifetime(kw::StaticLifetime)\n     }\n \n-    crate fn elided() -> Lifetime {\n+    pub(crate) fn elided() -> Lifetime {\n         Lifetime(kw::UnderscoreLifetime)\n     }\n }\n \n #[derive(Clone, Debug)]\n-crate enum WherePredicate {\n+pub(crate) enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<Lifetime> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Term },\n }\n \n impl WherePredicate {\n-    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    pub(crate) fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match *self {\n             WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n             WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n@@ -1360,41 +1360,41 @@ impl WherePredicate {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericParamDefKind {\n+pub(crate) enum GenericParamDefKind {\n     Lifetime { outlives: Vec<Lifetime> },\n     Type { did: DefId, bounds: Vec<GenericBound>, default: Option<Box<Type>>, synthetic: bool },\n     Const { did: DefId, ty: Box<Type>, default: Option<Box<String>> },\n }\n \n impl GenericParamDefKind {\n-    crate fn is_type(&self) -> bool {\n+    pub(crate) fn is_type(&self) -> bool {\n         matches!(self, GenericParamDefKind::Type { .. })\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct GenericParamDef {\n-    crate name: Symbol,\n-    crate kind: GenericParamDefKind,\n+pub(crate) struct GenericParamDef {\n+    pub(crate) name: Symbol,\n+    pub(crate) kind: GenericParamDefKind,\n }\n \n // `GenericParamDef` is used in many places. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(GenericParamDef, 56);\n \n impl GenericParamDef {\n-    crate fn is_synthetic_type_param(&self) -> bool {\n+    pub(crate) fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime { .. } | GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { synthetic, .. } => synthetic,\n         }\n     }\n \n-    crate fn is_type(&self) -> bool {\n+    pub(crate) fn is_type(&self) -> bool {\n         self.kind.is_type()\n     }\n \n-    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    pub(crate) fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match self.kind {\n             GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n             _ => None,\n@@ -1404,26 +1404,26 @@ impl GenericParamDef {\n \n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, Debug, Default)]\n-crate struct Generics {\n-    crate params: Vec<GenericParamDef>,\n-    crate where_predicates: Vec<WherePredicate>,\n+pub(crate) struct Generics {\n+    pub(crate) params: Vec<GenericParamDef>,\n+    pub(crate) where_predicates: Vec<WherePredicate>,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Function {\n-    crate decl: FnDecl,\n-    crate generics: Generics,\n+pub(crate) struct Function {\n+    pub(crate) decl: FnDecl,\n+    pub(crate) generics: Generics,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct FnDecl {\n-    crate inputs: Arguments,\n-    crate output: FnRetTy,\n-    crate c_variadic: bool,\n+pub(crate) struct FnDecl {\n+    pub(crate) inputs: Arguments,\n+    pub(crate) output: FnRetTy,\n+    pub(crate) c_variadic: bool,\n }\n \n impl FnDecl {\n-    crate fn self_type(&self) -> Option<SelfTy> {\n+    pub(crate) fn self_type(&self) -> Option<SelfTy> {\n         self.inputs.values.get(0).and_then(|v| v.to_self())\n     }\n \n@@ -1436,7 +1436,7 @@ impl FnDecl {\n     ///\n     /// This function will panic if the return type does not match the expected sugaring for async\n     /// functions.\n-    crate fn sugared_async_return_type(&self) -> FnRetTy {\n+    pub(crate) fn sugared_async_return_type(&self) -> FnRetTy {\n         match &self.output {\n             FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n                 GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n@@ -1453,28 +1453,28 @@ impl FnDecl {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Arguments {\n-    crate values: Vec<Argument>,\n+pub(crate) struct Arguments {\n+    pub(crate) values: Vec<Argument>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Argument {\n-    crate type_: Type,\n-    crate name: Symbol,\n+pub(crate) struct Argument {\n+    pub(crate) type_: Type,\n+    pub(crate) name: Symbol,\n     /// This field is used to represent \"const\" arguments from the `rustc_legacy_const_generics`\n     /// feature. More information in <https://github.com/rust-lang/rust/issues/83167>.\n-    crate is_const: bool,\n+    pub(crate) is_const: bool,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n-crate enum SelfTy {\n+pub(crate) enum SelfTy {\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n     SelfExplicit(Type),\n }\n \n impl Argument {\n-    crate fn to_self(&self) -> Option<SelfTy> {\n+    pub(crate) fn to_self(&self) -> Option<SelfTy> {\n         if self.name != kw::SelfLower {\n             return None;\n         }\n@@ -1491,13 +1491,13 @@ impl Argument {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum FnRetTy {\n+pub(crate) enum FnRetTy {\n     Return(Type),\n     DefaultReturn,\n }\n \n impl FnRetTy {\n-    crate fn as_return(&self) -> Option<&Type> {\n+    pub(crate) fn as_return(&self) -> Option<&Type> {\n         match self {\n             Return(ret) => Some(ret),\n             DefaultReturn => None,\n@@ -1506,30 +1506,30 @@ impl FnRetTy {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Trait {\n-    crate unsafety: hir::Unsafety,\n-    crate items: Vec<Item>,\n-    crate generics: Generics,\n-    crate bounds: Vec<GenericBound>,\n-    crate is_auto: bool,\n+pub(crate) struct Trait {\n+    pub(crate) unsafety: hir::Unsafety,\n+    pub(crate) items: Vec<Item>,\n+    pub(crate) generics: Generics,\n+    pub(crate) bounds: Vec<GenericBound>,\n+    pub(crate) is_auto: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate struct TraitAlias {\n-    crate generics: Generics,\n-    crate bounds: Vec<GenericBound>,\n+pub(crate) struct TraitAlias {\n+    pub(crate) generics: Generics,\n+    pub(crate) bounds: Vec<GenericBound>,\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct PolyTrait {\n-    crate trait_: Path,\n-    crate generic_params: Vec<GenericParamDef>,\n+pub(crate) struct PolyTrait {\n+    pub(crate) trait_: Path,\n+    pub(crate) generic_params: Vec<GenericParamDef>,\n }\n \n /// Rustdoc's representation of types, mostly based on the [`hir::Ty`].\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum Type {\n+pub(crate) enum Type {\n     /// A named type, which could be a trait.\n     ///\n     /// This is mostly Rustdoc's version of [`hir::Path`].\n@@ -1580,7 +1580,7 @@ rustc_data_structures::static_assert_size!(Type, 80);\n \n impl Type {\n     /// When comparing types for equality, it can help to ignore `&` wrapping.\n-    crate fn without_borrowed_ref(&self) -> &Type {\n+    pub(crate) fn without_borrowed_ref(&self) -> &Type {\n         let mut result = self;\n         while let Type::BorrowedRef { type_, .. } = result {\n             result = &*type_;\n@@ -1591,7 +1591,7 @@ impl Type {\n     /// Check if two types are \"potentially the same\".\n     /// This is different from `Eq`, because it knows that things like\n     /// `Placeholder` are possible matches for everything.\n-    crate fn is_same(&self, other: &Self, cache: &Cache) -> bool {\n+    pub(crate) fn is_same(&self, other: &Self, cache: &Cache) -> bool {\n         match (self, other) {\n             // Recursive cases.\n             (Type::Tuple(a), Type::Tuple(b)) => {\n@@ -1618,7 +1618,7 @@ impl Type {\n         }\n     }\n \n-    crate fn primitive_type(&self) -> Option<PrimitiveType> {\n+    pub(crate) fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n             Primitive(p) | BorrowedRef { type_: box Primitive(p), .. } => Some(p),\n             Slice(..) | BorrowedRef { type_: box Slice(..), .. } => Some(PrimitiveType::Slice),\n@@ -1637,36 +1637,36 @@ impl Type {\n     }\n \n     /// Checks if this is a `T::Name` path for an associated type.\n-    crate fn is_assoc_ty(&self) -> bool {\n+    pub(crate) fn is_assoc_ty(&self) -> bool {\n         match self {\n             Type::Path { path, .. } => path.is_assoc_ty(),\n             _ => false,\n         }\n     }\n \n-    crate fn is_self_type(&self) -> bool {\n+    pub(crate) fn is_self_type(&self) -> bool {\n         match *self {\n             Generic(name) => name == kw::SelfUpper,\n             _ => false,\n         }\n     }\n \n-    crate fn generics(&self) -> Option<Vec<&Type>> {\n+    pub(crate) fn generics(&self) -> Option<Vec<&Type>> {\n         match self {\n             Type::Path { path, .. } => path.generics(),\n             _ => None,\n         }\n     }\n \n-    crate fn is_full_generic(&self) -> bool {\n+    pub(crate) fn is_full_generic(&self) -> bool {\n         matches!(self, Type::Generic(_))\n     }\n \n-    crate fn is_primitive(&self) -> bool {\n+    pub(crate) fn is_primitive(&self) -> bool {\n         self.primitive_type().is_some()\n     }\n \n-    crate fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n+    pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath { self_type, trait_, assoc, .. } = self {\n             Some((&self_type, trait_.def_id(), *assoc.clone()))\n         } else {\n@@ -1701,7 +1701,7 @@ impl Type {\n     /// Use this method to get the [DefId] of a [clean] AST node, including [PrimitiveType]s.\n     ///\n     /// [clean]: crate::clean\n-    crate fn def_id(&self, cache: &Cache) -> Option<DefId> {\n+    pub(crate) fn def_id(&self, cache: &Cache) -> Option<DefId> {\n         self.inner_def_id(Some(cache))\n     }\n }\n@@ -1713,7 +1713,7 @@ impl Type {\n /// N.B. This has to be different from [`hir::PrimTy`] because it also includes types that aren't\n /// paths, like [`Self::Unit`].\n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-crate enum PrimitiveType {\n+pub(crate) enum PrimitiveType {\n     Isize,\n     I8,\n     I16,\n@@ -1743,7 +1743,7 @@ crate enum PrimitiveType {\n \n type SimplifiedTypes = FxHashMap<PrimitiveType, ArrayVec<SimplifiedType, 2>>;\n impl PrimitiveType {\n-    crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+    pub(crate) fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         use ast::{FloatTy, IntTy, UintTy};\n         match prim {\n             hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n@@ -1766,7 +1766,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n+    pub(crate) fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n             sym::isize => Some(PrimitiveType::Isize),\n             sym::i8 => Some(PrimitiveType::I8),\n@@ -1797,7 +1797,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn simplified_types() -> &'static SimplifiedTypes {\n+    pub(crate) fn simplified_types() -> &'static SimplifiedTypes {\n         use ty::fast_reject::SimplifiedTypeGen::*;\n         use ty::{FloatTy, IntTy, UintTy};\n         use PrimitiveType::*;\n@@ -1842,7 +1842,7 @@ impl PrimitiveType {\n         })\n     }\n \n-    crate fn impls<'tcx>(&self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = DefId> + 'tcx {\n+    pub(crate) fn impls<'tcx>(&self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = DefId> + 'tcx {\n         Self::simplified_types()\n             .get(self)\n             .into_iter()\n@@ -1851,15 +1851,15 @@ impl PrimitiveType {\n             .copied()\n     }\n \n-    crate fn all_impls(tcx: TyCtxt<'_>) -> impl Iterator<Item = DefId> + '_ {\n+    pub(crate) fn all_impls(tcx: TyCtxt<'_>) -> impl Iterator<Item = DefId> + '_ {\n         Self::simplified_types()\n             .values()\n             .flatten()\n             .flat_map(move |&simp| tcx.incoherent_impls(simp))\n             .copied()\n     }\n \n-    crate fn as_sym(&self) -> Symbol {\n+    pub(crate) fn as_sym(&self) -> Symbol {\n         use PrimitiveType::*;\n         match self {\n             Isize => sym::isize,\n@@ -1897,7 +1897,7 @@ impl PrimitiveType {\n     /// but otherwise, if multiple crates define the same primitive, there is no guarantee of which will be picked.\n     /// In particular, if a crate depends on both `std` and another crate that also defines `doc(primitive)`, then\n     /// it's entirely random whether `std` or the other crate is picked. (no_std crates are usually fine unless multiple dependencies define a primitive.)\n-    crate fn primitive_locations(tcx: TyCtxt<'_>) -> &FxHashMap<PrimitiveType, DefId> {\n+    pub(crate) fn primitive_locations(tcx: TyCtxt<'_>) -> &FxHashMap<PrimitiveType, DefId> {\n         static PRIMITIVE_LOCATIONS: OnceCell<FxHashMap<PrimitiveType, DefId>> = OnceCell::new();\n         PRIMITIVE_LOCATIONS.get_or_init(|| {\n             let mut primitive_locations = FxHashMap::default();\n@@ -2008,7 +2008,7 @@ impl From<hir::PrimTy> for PrimitiveType {\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum Visibility {\n+pub(crate) enum Visibility {\n     /// `pub`\n     Public,\n     /// Visibility inherited from parent.\n@@ -2020,45 +2020,45 @@ crate enum Visibility {\n }\n \n impl Visibility {\n-    crate fn is_public(&self) -> bool {\n+    pub(crate) fn is_public(&self) -> bool {\n         matches!(self, Visibility::Public)\n     }\n }\n \n #[derive(Clone, Debug)]\n-crate struct Struct {\n-    crate struct_type: CtorKind,\n-    crate generics: Generics,\n-    crate fields: Vec<Item>,\n-    crate fields_stripped: bool,\n+pub(crate) struct Struct {\n+    pub(crate) struct_type: CtorKind,\n+    pub(crate) generics: Generics,\n+    pub(crate) fields: Vec<Item>,\n+    pub(crate) fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Union {\n-    crate generics: Generics,\n-    crate fields: Vec<Item>,\n-    crate fields_stripped: bool,\n+pub(crate) struct Union {\n+    pub(crate) generics: Generics,\n+    pub(crate) fields: Vec<Item>,\n+    pub(crate) fields_stripped: bool,\n }\n \n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n #[derive(Clone, Debug)]\n-crate struct VariantStruct {\n-    crate struct_type: CtorKind,\n-    crate fields: Vec<Item>,\n-    crate fields_stripped: bool,\n+pub(crate) struct VariantStruct {\n+    pub(crate) struct_type: CtorKind,\n+    pub(crate) fields: Vec<Item>,\n+    pub(crate) fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Enum {\n-    crate variants: IndexVec<VariantIdx, Item>,\n-    crate generics: Generics,\n-    crate variants_stripped: bool,\n+pub(crate) struct Enum {\n+    pub(crate) variants: IndexVec<VariantIdx, Item>,\n+    pub(crate) generics: Generics,\n+    pub(crate) variants_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate enum Variant {\n+pub(crate) enum Variant {\n     CLike,\n     Tuple(Vec<Item>),\n     Struct(VariantStruct),\n@@ -2067,63 +2067,63 @@ crate enum Variant {\n /// Small wrapper around [`rustc_span::Span`] that adds helper methods\n /// and enforces calling [`rustc_span::Span::source_callsite()`].\n #[derive(Copy, Clone, Debug)]\n-crate struct Span(rustc_span::Span);\n+pub(crate) struct Span(rustc_span::Span);\n \n impl Span {\n     /// Wraps a [`rustc_span::Span`]. In case this span is the result of a macro expansion, the\n     /// span will be updated to point to the macro invocation instead of the macro definition.\n     ///\n     /// (See rust-lang/rust#39726)\n-    crate fn new(sp: rustc_span::Span) -> Self {\n+    pub(crate) fn new(sp: rustc_span::Span) -> Self {\n         Self(sp.source_callsite())\n     }\n \n-    crate fn inner(&self) -> rustc_span::Span {\n+    pub(crate) fn inner(&self) -> rustc_span::Span {\n         self.0\n     }\n \n-    crate fn dummy() -> Self {\n+    pub(crate) fn dummy() -> Self {\n         Self(rustc_span::DUMMY_SP)\n     }\n \n-    crate fn is_dummy(&self) -> bool {\n+    pub(crate) fn is_dummy(&self) -> bool {\n         self.0.is_dummy()\n     }\n \n-    crate fn filename(&self, sess: &Session) -> FileName {\n+    pub(crate) fn filename(&self, sess: &Session) -> FileName {\n         sess.source_map().span_to_filename(self.0)\n     }\n \n-    crate fn lo(&self, sess: &Session) -> Loc {\n+    pub(crate) fn lo(&self, sess: &Session) -> Loc {\n         sess.source_map().lookup_char_pos(self.0.lo())\n     }\n \n-    crate fn hi(&self, sess: &Session) -> Loc {\n+    pub(crate) fn hi(&self, sess: &Session) -> Loc {\n         sess.source_map().lookup_char_pos(self.0.hi())\n     }\n \n-    crate fn cnum(&self, sess: &Session) -> CrateNum {\n+    pub(crate) fn cnum(&self, sess: &Session) -> CrateNum {\n         // FIXME: is there a time when the lo and hi crate would be different?\n         self.lo(sess).file.cnum\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Path {\n-    crate res: Res,\n-    crate segments: Vec<PathSegment>,\n+pub(crate) struct Path {\n+    pub(crate) res: Res,\n+    pub(crate) segments: Vec<PathSegment>,\n }\n \n impl Path {\n-    crate fn def_id(&self) -> DefId {\n+    pub(crate) fn def_id(&self) -> DefId {\n         self.res.def_id()\n     }\n \n-    crate fn last(&self) -> Symbol {\n+    pub(crate) fn last(&self) -> Symbol {\n         self.segments.last().expect(\"segments were empty\").name\n     }\n \n-    crate fn whole_name(&self) -> String {\n+    pub(crate) fn whole_name(&self) -> String {\n         self.segments\n             .iter()\n             .map(|s| if s.name == kw::PathRoot { String::new() } else { s.name.to_string() })\n@@ -2132,7 +2132,7 @@ impl Path {\n     }\n \n     /// Checks if this is a `T::Name` path for an associated type.\n-    crate fn is_assoc_ty(&self) -> bool {\n+    pub(crate) fn is_assoc_ty(&self) -> bool {\n         match self.res {\n             Res::SelfTy { .. } if self.segments.len() != 1 => true,\n             Res::Def(DefKind::TyParam, _) if self.segments.len() != 1 => true,\n@@ -2141,7 +2141,7 @@ impl Path {\n         }\n     }\n \n-    crate fn generics(&self) -> Option<Vec<&Type>> {\n+    pub(crate) fn generics(&self) -> Option<Vec<&Type>> {\n         self.segments.last().and_then(|seg| {\n             if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n                 Some(\n@@ -2158,7 +2158,7 @@ impl Path {\n         })\n     }\n \n-    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n+    pub(crate) fn bindings(&self) -> Option<&[TypeBinding]> {\n         self.segments.last().and_then(|seg| {\n             if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n                 Some(&**bindings)\n@@ -2170,7 +2170,7 @@ impl Path {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericArg {\n+pub(crate) enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Type),\n     Const(Box<Constant>),\n@@ -2183,7 +2183,7 @@ crate enum GenericArg {\n rustc_data_structures::static_assert_size!(GenericArg, 88);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericArgs {\n+pub(crate) enum GenericArgs {\n     AngleBracketed { args: Vec<GenericArg>, bindings: ThinVec<TypeBinding> },\n     Parenthesized { inputs: Vec<Type>, output: Option<Box<Type>> },\n }\n@@ -2194,9 +2194,9 @@ crate enum GenericArgs {\n rustc_data_structures::static_assert_size!(GenericArgs, 40);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct PathSegment {\n-    crate name: Symbol,\n-    crate args: GenericArgs,\n+pub(crate) struct PathSegment {\n+    pub(crate) name: Symbol,\n+    pub(crate) args: GenericArgs,\n }\n \n // `PathSegment` usually occurs multiple times in every `Path`, so its size can\n@@ -2205,53 +2205,53 @@ crate struct PathSegment {\n rustc_data_structures::static_assert_size!(PathSegment, 48);\n \n #[derive(Clone, Debug)]\n-crate struct Typedef {\n-    crate type_: Type,\n-    crate generics: Generics,\n+pub(crate) struct Typedef {\n+    pub(crate) type_: Type,\n+    pub(crate) generics: Generics,\n     /// `type_` can come from either the HIR or from metadata. If it comes from HIR, it may be a type\n     /// alias instead of the final type. This will always have the final type, regardless of whether\n     /// `type_` came from HIR or from metadata.\n     ///\n     /// If `item_type.is_none()`, `type_` is guaranteed to come from metadata (and therefore hold the\n     /// final type).\n-    crate item_type: Option<Type>,\n+    pub(crate) item_type: Option<Type>,\n }\n \n #[derive(Clone, Debug)]\n-crate struct OpaqueTy {\n-    crate bounds: Vec<GenericBound>,\n-    crate generics: Generics,\n+pub(crate) struct OpaqueTy {\n+    pub(crate) bounds: Vec<GenericBound>,\n+    pub(crate) generics: Generics,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct BareFunctionDecl {\n-    crate unsafety: hir::Unsafety,\n-    crate generic_params: Vec<GenericParamDef>,\n-    crate decl: FnDecl,\n-    crate abi: Abi,\n+pub(crate) struct BareFunctionDecl {\n+    pub(crate) unsafety: hir::Unsafety,\n+    pub(crate) generic_params: Vec<GenericParamDef>,\n+    pub(crate) decl: FnDecl,\n+    pub(crate) abi: Abi,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Static {\n-    crate type_: Type,\n-    crate mutability: Mutability,\n-    crate expr: Option<BodyId>,\n+pub(crate) struct Static {\n+    pub(crate) type_: Type,\n+    pub(crate) mutability: Mutability,\n+    pub(crate) expr: Option<BodyId>,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate struct Constant {\n-    crate type_: Type,\n-    crate kind: ConstantKind,\n+pub(crate) struct Constant {\n+    pub(crate) type_: Type,\n+    pub(crate) kind: ConstantKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate enum Term {\n+pub(crate) enum Term {\n     Type(Type),\n     Constant(Constant),\n }\n \n impl Term {\n-    crate fn ty(&self) -> Option<&Type> {\n+    pub(crate) fn ty(&self) -> Option<&Type> {\n         if let Term::Type(ty) = self { Some(ty) } else { None }\n     }\n }\n@@ -2263,7 +2263,7 @@ impl From<Type> for Term {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate enum ConstantKind {\n+pub(crate) enum ConstantKind {\n     /// This is the wrapper around `ty::Const` for a non-local constant. Because it doesn't have a\n     /// `BodyId`, we need to handle it on its own.\n     ///\n@@ -2281,21 +2281,21 @@ crate enum ConstantKind {\n }\n \n impl Constant {\n-    crate fn expr(&self, tcx: TyCtxt<'_>) -> String {\n+    pub(crate) fn expr(&self, tcx: TyCtxt<'_>) -> String {\n         self.kind.expr(tcx)\n     }\n \n-    crate fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+    pub(crate) fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n         self.kind.value(tcx)\n     }\n \n-    crate fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n+    pub(crate) fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n         self.kind.is_literal(tcx)\n     }\n }\n \n impl ConstantKind {\n-    crate fn expr(&self, tcx: TyCtxt<'_>) -> String {\n+    pub(crate) fn expr(&self, tcx: TyCtxt<'_>) -> String {\n         match *self {\n             ConstantKind::TyConst { ref expr } => expr.clone(),\n             ConstantKind::Extern { def_id } => print_inlined_const(tcx, def_id),\n@@ -2305,7 +2305,7 @@ impl ConstantKind {\n         }\n     }\n \n-    crate fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+    pub(crate) fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n         match *self {\n             ConstantKind::TyConst { .. } | ConstantKind::Anonymous { .. } => None,\n             ConstantKind::Extern { def_id } | ConstantKind::Local { def_id, .. } => {\n@@ -2314,7 +2314,7 @@ impl ConstantKind {\n         }\n     }\n \n-    crate fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n+    pub(crate) fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n         match *self {\n             ConstantKind::TyConst { .. } => false,\n             ConstantKind::Extern { def_id } => def_id.as_local().map_or(false, |def_id| {\n@@ -2328,18 +2328,18 @@ impl ConstantKind {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Impl {\n-    crate unsafety: hir::Unsafety,\n-    crate generics: Generics,\n-    crate trait_: Option<Path>,\n-    crate for_: Type,\n-    crate items: Vec<Item>,\n-    crate polarity: ty::ImplPolarity,\n-    crate kind: ImplKind,\n+pub(crate) struct Impl {\n+    pub(crate) unsafety: hir::Unsafety,\n+    pub(crate) generics: Generics,\n+    pub(crate) trait_: Option<Path>,\n+    pub(crate) for_: Type,\n+    pub(crate) items: Vec<Item>,\n+    pub(crate) polarity: ty::ImplPolarity,\n+    pub(crate) kind: ImplKind,\n }\n \n impl Impl {\n-    crate fn provided_trait_methods(&self, tcx: TyCtxt<'_>) -> FxHashSet<Symbol> {\n+    pub(crate) fn provided_trait_methods(&self, tcx: TyCtxt<'_>) -> FxHashSet<Symbol> {\n         self.trait_\n             .as_ref()\n             .map(|t| t.def_id())\n@@ -2349,22 +2349,22 @@ impl Impl {\n }\n \n #[derive(Clone, Debug)]\n-crate enum ImplKind {\n+pub(crate) enum ImplKind {\n     Normal,\n     Auto,\n     Blanket(Box<Type>),\n }\n \n impl ImplKind {\n-    crate fn is_auto(&self) -> bool {\n+    pub(crate) fn is_auto(&self) -> bool {\n         matches!(self, ImplKind::Auto)\n     }\n \n-    crate fn is_blanket(&self) -> bool {\n+    pub(crate) fn is_blanket(&self) -> bool {\n         matches!(self, ImplKind::Blanket(_))\n     }\n \n-    crate fn as_blanket_ty(&self) -> Option<&Type> {\n+    pub(crate) fn as_blanket_ty(&self) -> Option<&Type> {\n         match self {\n             ImplKind::Blanket(ty) => Some(ty),\n             _ => None,\n@@ -2373,63 +2373,67 @@ impl ImplKind {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Import {\n-    crate kind: ImportKind,\n-    crate source: ImportSource,\n-    crate should_be_displayed: bool,\n+pub(crate) struct Import {\n+    pub(crate) kind: ImportKind,\n+    pub(crate) source: ImportSource,\n+    pub(crate) should_be_displayed: bool,\n }\n \n impl Import {\n-    crate fn new_simple(name: Symbol, source: ImportSource, should_be_displayed: bool) -> Self {\n+    pub(crate) fn new_simple(\n+        name: Symbol,\n+        source: ImportSource,\n+        should_be_displayed: bool,\n+    ) -> Self {\n         Self { kind: ImportKind::Simple(name), source, should_be_displayed }\n     }\n \n-    crate fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n+    pub(crate) fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Glob, source, should_be_displayed }\n     }\n }\n \n #[derive(Clone, Debug)]\n-crate enum ImportKind {\n+pub(crate) enum ImportKind {\n     // use source as str;\n     Simple(Symbol),\n     // use source::*;\n     Glob,\n }\n \n #[derive(Clone, Debug)]\n-crate struct ImportSource {\n-    crate path: Path,\n-    crate did: Option<DefId>,\n+pub(crate) struct ImportSource {\n+    pub(crate) path: Path,\n+    pub(crate) did: Option<DefId>,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Macro {\n-    crate source: String,\n+pub(crate) struct Macro {\n+    pub(crate) source: String,\n }\n \n #[derive(Clone, Debug)]\n-crate struct ProcMacro {\n-    crate kind: MacroKind,\n-    crate helpers: Vec<Symbol>,\n+pub(crate) struct ProcMacro {\n+    pub(crate) kind: MacroKind,\n+    pub(crate) helpers: Vec<Symbol>,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct TypeBinding {\n-    crate assoc: PathSegment,\n-    crate kind: TypeBindingKind,\n+pub(crate) struct TypeBinding {\n+    pub(crate) assoc: PathSegment,\n+    pub(crate) kind: TypeBindingKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum TypeBindingKind {\n+pub(crate) enum TypeBindingKind {\n     Equality { term: Term },\n     Constraint { bounds: Vec<GenericBound> },\n }\n \n impl TypeBinding {\n-    crate fn term(&self) -> &Term {\n+    pub(crate) fn term(&self) -> &Term {\n         match self.kind {\n             TypeBindingKind::Equality { ref term } => term,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n@@ -2450,18 +2454,18 @@ impl TypeBinding {\n ///\n /// `public_fn`'s docs will show it as returning `Vec<i32>`, since `PrivAlias` is private.\n /// [`SubstParam`] is used to record that `T` should be mapped to `i32`.\n-crate enum SubstParam {\n+pub(crate) enum SubstParam {\n     Type(Type),\n     Lifetime(Lifetime),\n     Constant(Constant),\n }\n \n impl SubstParam {\n-    crate fn as_ty(&self) -> Option<&Type> {\n+    pub(crate) fn as_ty(&self) -> Option<&Type> {\n         if let Self::Type(ty) = self { Some(ty) } else { None }\n     }\n \n-    crate fn as_lt(&self) -> Option<&Lifetime> {\n+    pub(crate) fn as_lt(&self) -> Option<&Lifetime> {\n         if let Self::Lifetime(lt) = self { Some(lt) } else { None }\n     }\n }"}, {"sha": "7a12ea0d5c21569da4de0dc075800dfd99fb9b7f", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -25,7 +25,7 @@ use std::mem;\n #[cfg(test)]\n mod tests;\n \n-crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit();\n \n     for &cnum in cx.tcx.crates(()) {\n@@ -75,7 +75,7 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     Crate { module, primitives, external_traits: cx.external_traits.clone() }\n }\n \n-crate fn substs_to_args(\n+pub(crate) fn substs_to_args(\n     cx: &mut DocContext<'_>,\n     substs: &[ty::subst::GenericArg<'_>],\n     mut skip_first: bool,\n@@ -146,15 +146,15 @@ pub(super) fn external_path(\n }\n \n /// Remove the generic arguments from a path.\n-crate fn strip_path_generics(mut path: Path) -> Path {\n+pub(crate) fn strip_path_generics(mut path: Path) -> Path {\n     for ps in path.segments.iter_mut() {\n         ps.args = GenericArgs::AngleBracketed { args: vec![], bindings: ThinVec::new() }\n     }\n \n     path\n }\n \n-crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n+pub(crate) fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, path) => &path.segments,\n         hir::QPath::TypeRelative(_, segment) => return segment.ident.to_string(),\n@@ -173,7 +173,11 @@ crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     s\n }\n \n-crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n+pub(crate) fn build_deref_target_impls(\n+    cx: &mut DocContext<'_>,\n+    items: &[Item],\n+    ret: &mut Vec<Item>,\n+) {\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -196,7 +200,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n     }\n }\n \n-crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n+pub(crate) fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n     use rustc_hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n@@ -229,7 +233,7 @@ crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n     })\n }\n \n-crate fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n+pub(crate) fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n     match n.val() {\n         ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) => {\n             let mut s = if let Some(def) = def.as_local() {\n@@ -259,7 +263,7 @@ crate fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n     }\n }\n \n-crate fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String> {\n+pub(crate) fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String> {\n     tcx.const_eval_poly(def_id).ok().and_then(|val| {\n         let ty = tcx.type_of(def_id);\n         match (val, ty.kind()) {\n@@ -323,7 +327,7 @@ fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> S\n     }\n }\n \n-crate fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     if let hir::Node::Expr(expr) = tcx.hir().get(hir_id) {\n         if let hir::ExprKind::Lit(_) = &expr.kind {\n             return true;\n@@ -339,7 +343,7 @@ crate fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n-crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n+pub(crate) fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n     let hir = tcx.hir();\n     let value = &hir.body(body).value;\n \n@@ -353,7 +357,7 @@ crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n+pub(crate) fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n     debug!(\"resolve_type({:?})\", path);\n \n     match path.res {\n@@ -367,7 +371,7 @@ crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n     }\n }\n \n-crate fn get_auto_trait_and_blanket_impls(\n+pub(crate) fn get_auto_trait_and_blanket_impls(\n     cx: &mut DocContext<'_>,\n     item_def_id: DefId,\n ) -> impl Iterator<Item = Item> {\n@@ -389,7 +393,7 @@ crate fn get_auto_trait_and_blanket_impls(\n /// This is later used by [`href()`] to determine the HTML link for the item.\n ///\n /// [`href()`]: crate::html::format::href\n-crate fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n+pub(crate) fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n     use DefKind::*;\n     debug!(\"register_res({:?})\", res);\n \n@@ -428,14 +432,14 @@ crate fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n     did\n }\n \n-crate fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportSource {\n+pub(crate) fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.res.opt_def_id().is_none() { None } else { Some(register_res(cx, path.res)) },\n         path,\n     }\n }\n \n-crate fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n+pub(crate) fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n where\n     F: FnOnce(&mut DocContext<'_>) -> R,\n {\n@@ -447,7 +451,7 @@ where\n }\n \n /// Find the nearest parent module of a [`DefId`].\n-crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+pub(crate) fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if def_id.is_top_level_module() {\n         // The crate root has no parent. Use it as the root instead.\n         Some(def_id)\n@@ -474,7 +478,7 @@ crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<De\n ///\n /// This function exists because it runs on `hir::Attributes` whereas the other is a\n /// `clean::Attributes` method.\n-crate fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n+pub(crate) fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n     tcx.get_attrs(did, sym::doc).any(|attr| {\n         attr.meta_item_list().map_or(false, |l| rustc_attr::list_contains_name(&l, flag))\n     })\n@@ -484,7 +488,7 @@ crate fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n /// so that the channel is consistent.\n ///\n /// Set by `bootstrap::Builder::doc_rust_lang_org_channel` in order to keep tests passing on beta/stable.\n-crate const DOC_RUST_LANG_ORG_CHANNEL: &str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n+pub(crate) const DOC_RUST_LANG_ORG_CHANNEL: &str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n \n /// Render a sequence of macro arms in a format suitable for displaying to the user\n /// as part of an item declaration."}, {"sha": "b934a1a59d717ac726917d3a309bbaf8a10b2895", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -31,7 +31,7 @@ use crate::scrape_examples::{AllCallLocations, ScrapeExamplesOptions};\n use crate::theme;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-crate enum OutputFormat {\n+pub(crate) enum OutputFormat {\n     Json,\n     Html,\n }\n@@ -43,7 +43,7 @@ impl Default for OutputFormat {\n }\n \n impl OutputFormat {\n-    crate fn is_json(&self) -> bool {\n+    pub(crate) fn is_json(&self) -> bool {\n         matches!(self, OutputFormat::Json)\n     }\n }\n@@ -62,100 +62,100 @@ impl TryFrom<&str> for OutputFormat {\n \n /// Configuration options for rustdoc.\n #[derive(Clone)]\n-crate struct Options {\n+pub(crate) struct Options {\n     // Basic options / Options passed directly to rustc\n     /// The crate root or Markdown file to load.\n-    crate input: PathBuf,\n+    pub(crate) input: PathBuf,\n     /// The name of the crate being documented.\n-    crate crate_name: Option<String>,\n+    pub(crate) crate_name: Option<String>,\n     /// Whether or not this is a proc-macro crate\n-    crate proc_macro_crate: bool,\n+    pub(crate) proc_macro_crate: bool,\n     /// How to format errors and warnings.\n-    crate error_format: ErrorOutputType,\n+    pub(crate) error_format: ErrorOutputType,\n     /// Library search paths to hand to the compiler.\n-    crate libs: Vec<SearchPath>,\n+    pub(crate) libs: Vec<SearchPath>,\n     /// Library search paths strings to hand to the compiler.\n-    crate lib_strs: Vec<String>,\n+    pub(crate) lib_strs: Vec<String>,\n     /// The list of external crates to link against.\n-    crate externs: Externs,\n+    pub(crate) externs: Externs,\n     /// The list of external crates strings to link against.\n-    crate extern_strs: Vec<String>,\n+    pub(crate) extern_strs: Vec<String>,\n     /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n-    crate cfgs: Vec<String>,\n+    pub(crate) cfgs: Vec<String>,\n     /// List of check cfg flags to hand to the compiler.\n-    crate check_cfgs: Vec<String>,\n+    pub(crate) check_cfgs: Vec<String>,\n     /// Codegen options to hand to the compiler.\n-    crate codegen_options: CodegenOptions,\n+    pub(crate) codegen_options: CodegenOptions,\n     /// Codegen options strings to hand to the compiler.\n-    crate codegen_options_strs: Vec<String>,\n+    pub(crate) codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n-    crate debugging_opts: DebuggingOptions,\n+    pub(crate) debugging_opts: DebuggingOptions,\n     /// Debugging (`-Z`) options strings to pass to the compiler.\n-    crate debugging_opts_strs: Vec<String>,\n+    pub(crate) debugging_opts_strs: Vec<String>,\n     /// The target used to compile the crate against.\n-    crate target: TargetTriple,\n+    pub(crate) target: TargetTriple,\n     /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n     /// compiling doctests from the crate.\n-    crate edition: Edition,\n+    pub(crate) edition: Edition,\n     /// The path to the sysroot. Used during the compilation process.\n-    crate maybe_sysroot: Option<PathBuf>,\n+    pub(crate) maybe_sysroot: Option<PathBuf>,\n     /// Lint information passed over the command-line.\n-    crate lint_opts: Vec<(String, Level)>,\n+    pub(crate) lint_opts: Vec<(String, Level)>,\n     /// Whether to ask rustc to describe the lints it knows.\n-    crate describe_lints: bool,\n+    pub(crate) describe_lints: bool,\n     /// What level to cap lints at.\n-    crate lint_cap: Option<Level>,\n+    pub(crate) lint_cap: Option<Level>,\n \n     // Options specific to running doctests\n     /// Whether we should run doctests instead of generating docs.\n-    crate should_test: bool,\n+    pub(crate) should_test: bool,\n     /// List of arguments to pass to the test harness, if running tests.\n-    crate test_args: Vec<String>,\n+    pub(crate) test_args: Vec<String>,\n     /// The working directory in which to run tests.\n-    crate test_run_directory: Option<PathBuf>,\n+    pub(crate) test_run_directory: Option<PathBuf>,\n     /// Optional path to persist the doctest executables to, defaults to a\n     /// temporary directory if not set.\n-    crate persist_doctests: Option<PathBuf>,\n+    pub(crate) persist_doctests: Option<PathBuf>,\n     /// Runtool to run doctests with\n-    crate runtool: Option<String>,\n+    pub(crate) runtool: Option<String>,\n     /// Arguments to pass to the runtool\n-    crate runtool_args: Vec<String>,\n+    pub(crate) runtool_args: Vec<String>,\n     /// Whether to allow ignoring doctests on a per-target basis\n     /// For example, using ignore-foo to ignore running the doctest on any target that\n     /// contains \"foo\" as a substring\n-    crate enable_per_target_ignores: bool,\n+    pub(crate) enable_per_target_ignores: bool,\n     /// Do not run doctests, compile them if should_test is active.\n-    crate no_run: bool,\n+    pub(crate) no_run: bool,\n \n     /// The path to a rustc-like binary to build tests with. If not set, we\n     /// default to loading from `$sysroot/bin/rustc`.\n-    crate test_builder: Option<PathBuf>,\n+    pub(crate) test_builder: Option<PathBuf>,\n \n     // Options that affect the documentation process\n     /// Whether to run the `calculate-doc-coverage` pass, which counts the number of public items\n     /// with and without documentation.\n-    crate show_coverage: bool,\n+    pub(crate) show_coverage: bool,\n \n     // Options that alter generated documentation pages\n     /// Crate version to note on the sidebar of generated docs.\n-    crate crate_version: Option<String>,\n+    pub(crate) crate_version: Option<String>,\n     /// Collected options specific to outputting final pages.\n-    crate render_options: RenderOptions,\n+    pub(crate) render_options: RenderOptions,\n     /// The format that we output when rendering.\n     ///\n     /// Currently used only for the `--show-coverage` option.\n-    crate output_format: OutputFormat,\n+    pub(crate) output_format: OutputFormat,\n     /// If this option is set to `true`, rustdoc will only run checks and not generate\n     /// documentation.\n-    crate run_check: bool,\n+    pub(crate) run_check: bool,\n     /// Whether doctests should emit unused externs\n-    crate json_unused_externs: JsonUnusedExterns,\n+    pub(crate) json_unused_externs: JsonUnusedExterns,\n     /// Whether to skip capturing stdout and stderr of tests.\n-    crate nocapture: bool,\n+    pub(crate) nocapture: bool,\n \n     /// Configuration for scraping examples from the current crate. If this option is Some(..) then\n     /// the compiler will scrape examples and not generate documentation.\n-    crate scrape_examples_options: Option<ScrapeExamplesOptions>,\n+    pub(crate) scrape_examples_options: Option<ScrapeExamplesOptions>,\n }\n \n impl fmt::Debug for Options {\n@@ -205,83 +205,83 @@ impl fmt::Debug for Options {\n \n /// Configuration options for the HTML page-creation process.\n #[derive(Clone, Debug)]\n-crate struct RenderOptions {\n+pub(crate) struct RenderOptions {\n     /// Output directory to generate docs into. Defaults to `doc`.\n-    crate output: PathBuf,\n+    pub(crate) output: PathBuf,\n     /// External files to insert into generated pages.\n-    crate external_html: ExternalHtml,\n+    pub(crate) external_html: ExternalHtml,\n     /// A pre-populated `IdMap` with the default headings and any headings added by Markdown files\n     /// processed by `external_html`.\n-    crate id_map: IdMap,\n+    pub(crate) id_map: IdMap,\n     /// If present, playground URL to use in the \"Run\" button added to code samples.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    crate playground_url: Option<String>,\n+    pub(crate) playground_url: Option<String>,\n     /// Whether to sort modules alphabetically on a module page instead of using declaration order.\n     /// `true` by default.\n     //\n     // FIXME(misdreavus): the flag name is `--sort-modules-by-appearance` but the meaning is\n     // inverted once read.\n-    crate sort_modules_alphabetically: bool,\n+    pub(crate) sort_modules_alphabetically: bool,\n     /// List of themes to extend the docs with. Original argument name is included to assist in\n     /// displaying errors if it fails a theme check.\n-    crate themes: Vec<StylePath>,\n+    pub(crate) themes: Vec<StylePath>,\n     /// If present, CSS file that contains rules to add to the default CSS.\n-    crate extension_css: Option<PathBuf>,\n+    pub(crate) extension_css: Option<PathBuf>,\n     /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n-    crate extern_html_root_urls: BTreeMap<String, String>,\n+    pub(crate) extern_html_root_urls: BTreeMap<String, String>,\n     /// Whether to give precedence to `html_root_url` or `--exten-html-root-url`.\n-    crate extern_html_root_takes_precedence: bool,\n+    pub(crate) extern_html_root_takes_precedence: bool,\n     /// A map of the default settings (values are as for DOM storage API). Keys should lack the\n     /// `rustdoc-` prefix.\n-    crate default_settings: FxHashMap<String, String>,\n+    pub(crate) default_settings: FxHashMap<String, String>,\n     /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n-    crate resource_suffix: String,\n+    pub(crate) resource_suffix: String,\n     /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n     /// default.\n     //\n     // FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n     // once read.\n-    crate enable_minification: bool,\n+    pub(crate) enable_minification: bool,\n     /// Whether to create an index page in the root of the output directory. If this is true but\n     /// `enable_index_page` is None, generate a static listing of crates instead.\n-    crate enable_index_page: bool,\n+    pub(crate) enable_index_page: bool,\n     /// A file to use as the index page at the root of the output directory. Overrides\n     /// `enable_index_page` to be true if set.\n-    crate index_page: Option<PathBuf>,\n+    pub(crate) index_page: Option<PathBuf>,\n     /// An optional path to use as the location of static files. If not set, uses combinations of\n     /// `../` to reach the documentation root.\n-    crate static_root_path: Option<String>,\n+    pub(crate) static_root_path: Option<String>,\n \n     // Options specific to reading standalone Markdown files\n     /// Whether to generate a table of contents on the output file when reading a standalone\n     /// Markdown file.\n-    crate markdown_no_toc: bool,\n+    pub(crate) markdown_no_toc: bool,\n     /// Additional CSS files to link in pages generated from standalone Markdown files.\n-    crate markdown_css: Vec<String>,\n+    pub(crate) markdown_css: Vec<String>,\n     /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n     /// standalone Markdown files. If not present, `playground_url` is used.\n-    crate markdown_playground_url: Option<String>,\n+    pub(crate) markdown_playground_url: Option<String>,\n     /// Document items that have lower than `pub` visibility.\n-    crate document_private: bool,\n+    pub(crate) document_private: bool,\n     /// Document items that have `doc(hidden)`.\n-    crate document_hidden: bool,\n+    pub(crate) document_hidden: bool,\n     /// If `true`, generate a JSON file in the crate folder instead of HTML redirection files.\n-    crate generate_redirect_map: bool,\n+    pub(crate) generate_redirect_map: bool,\n     /// Show the memory layout of types in the docs.\n-    crate show_type_layout: bool,\n-    crate unstable_features: rustc_feature::UnstableFeatures,\n-    crate emit: Vec<EmitType>,\n+    pub(crate) show_type_layout: bool,\n+    pub(crate) unstable_features: rustc_feature::UnstableFeatures,\n+    pub(crate) emit: Vec<EmitType>,\n     /// If `true`, HTML source pages will generate links for items to their definition.\n-    crate generate_link_to_definition: bool,\n+    pub(crate) generate_link_to_definition: bool,\n     /// Set of function-call locations to include as examples\n-    crate call_locations: AllCallLocations,\n+    pub(crate) call_locations: AllCallLocations,\n     /// If `true`, Context::init will not emit shared files.\n-    crate no_emit_shared: bool,\n+    pub(crate) no_emit_shared: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-crate enum EmitType {\n+pub(crate) enum EmitType {\n     Unversioned,\n     Toolchain,\n     InvocationSpecific,\n@@ -302,15 +302,15 @@ impl FromStr for EmitType {\n }\n \n impl RenderOptions {\n-    crate fn should_emit_crate(&self) -> bool {\n+    pub(crate) fn should_emit_crate(&self) -> bool {\n         self.emit.is_empty() || self.emit.contains(&EmitType::InvocationSpecific)\n     }\n }\n \n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code.\n-    crate fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n+    pub(crate) fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n         // Check for unstable options.\n         nightly_options::check_nightly_options(matches, &opts());\n \n@@ -745,7 +745,7 @@ impl Options {\n     }\n \n     /// Returns `true` if the file given as `self.input` is a Markdown file.\n-    crate fn markdown_input(&self) -> bool {\n+    pub(crate) fn markdown_input(&self) -> bool {\n         self.input.extension().map_or(false, |e| e == \"md\" || e == \"markdown\")\n     }\n }"}, {"sha": "53281bfde2e4f104f265ba766f29b3ef64d65bcc", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -32,70 +32,74 @@ use crate::formats::cache::Cache;\n use crate::passes::collect_intra_doc_links::PreprocessedMarkdownLink;\n use crate::passes::{self, Condition::*};\n \n-crate use rustc_session::config::{DebuggingOptions, Input, Options};\n+pub(crate) use rustc_session::config::{DebuggingOptions, Input, Options};\n \n-crate struct ResolverCaches {\n-    crate markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n-    crate doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n+pub(crate) struct ResolverCaches {\n+    pub(crate) markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n+    pub(crate) doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n-    crate traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n-    crate all_traits: Option<Vec<DefId>>,\n-    crate all_trait_impls: Option<Vec<DefId>>,\n-    crate all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n+    pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n+    pub(crate) all_traits: Option<Vec<DefId>>,\n+    pub(crate) all_trait_impls: Option<Vec<DefId>>,\n+    pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n }\n \n-crate struct DocContext<'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct DocContext<'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     /// Name resolver. Used for intra-doc links.\n     ///\n     /// The `Rc<RefCell<...>>` wrapping is needed because that is what's returned by\n     /// [`rustc_interface::Queries::expansion()`].\n     // FIXME: see if we can get rid of this RefCell somehow\n-    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    crate resolver_caches: ResolverCaches,\n+    pub(crate) resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    pub(crate) resolver_caches: ResolverCaches,\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n-    crate param_env: ParamEnv<'tcx>,\n+    pub(crate) param_env: ParamEnv<'tcx>,\n     /// Later on moved through `clean::Crate` into `cache`\n-    crate external_traits: Rc<RefCell<FxHashMap<DefId, clean::TraitWithExtraInfo>>>,\n+    pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, clean::TraitWithExtraInfo>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    crate active_extern_traits: FxHashSet<DefId>,\n+    pub(crate) active_extern_traits: FxHashSet<DefId>,\n     // The current set of parameter substitutions,\n     // for expanding type aliases at the HIR level:\n     /// Table `DefId` of type, lifetime, or const parameter -> substituted type, lifetime, or const\n-    crate substs: FxHashMap<DefId, clean::SubstParam>,\n+    pub(crate) substs: FxHashMap<DefId, clean::SubstParam>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n-    crate impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n+    pub(crate) impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n-    crate generated_synthetics: FxHashSet<(Ty<'tcx>, DefId)>,\n-    crate auto_traits: Vec<DefId>,\n+    pub(crate) generated_synthetics: FxHashSet<(Ty<'tcx>, DefId)>,\n+    pub(crate) auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n-    crate render_options: RenderOptions,\n+    pub(crate) render_options: RenderOptions,\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n-    crate cache: Cache,\n+    pub(crate) cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n-    crate inlined: FxHashSet<ItemId>,\n+    pub(crate) inlined: FxHashSet<ItemId>,\n     /// Used by `calculate_doc_coverage`.\n-    crate output_format: OutputFormat,\n+    pub(crate) output_format: OutputFormat,\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    crate fn sess(&self) -> &'tcx Session {\n+    pub(crate) fn sess(&self) -> &'tcx Session {\n         self.tcx.sess\n     }\n \n-    crate fn with_param_env<T, F: FnOnce(&mut Self) -> T>(&mut self, def_id: DefId, f: F) -> T {\n+    pub(crate) fn with_param_env<T, F: FnOnce(&mut Self) -> T>(\n+        &mut self,\n+        def_id: DefId,\n+        f: F,\n+    ) -> T {\n         let old_param_env = mem::replace(&mut self.param_env, self.tcx.param_env(def_id));\n         let ret = f(self);\n         self.param_env = old_param_env;\n         ret\n     }\n \n-    crate fn enter_resolver<F, R>(&self, f: F) -> R\n+    pub(crate) fn enter_resolver<F, R>(&self, f: F) -> R\n     where\n         F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n     {\n@@ -104,7 +108,11 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n-    crate fn enter_alias<F, R>(&mut self, substs: FxHashMap<DefId, clean::SubstParam>, f: F) -> R\n+    pub(crate) fn enter_alias<F, R>(\n+        &mut self,\n+        substs: FxHashMap<DefId, clean::SubstParam>,\n+        f: F,\n+    ) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n@@ -116,7 +124,7 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, item_id: ItemId) -> Option<HirId> {\n+    pub(crate) fn as_local_hir_id(tcx: TyCtxt<'_>, item_id: ItemId) -> Option<HirId> {\n         match item_id {\n             ItemId::DefId(real_id) => {\n                 real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n@@ -126,13 +134,13 @@ impl<'tcx> DocContext<'tcx> {\n         }\n     }\n \n-    crate fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+    pub(crate) fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n         let all_traits = self.resolver_caches.all_traits.take();\n         f(self, all_traits.as_ref().expect(\"`all_traits` are already borrowed\"));\n         self.resolver_caches.all_traits = all_traits;\n     }\n \n-    crate fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+    pub(crate) fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n         let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n         f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n         self.resolver_caches.all_trait_impls = all_trait_impls;\n@@ -143,7 +151,7 @@ impl<'tcx> DocContext<'tcx> {\n ///\n /// If the given `error_format` is `ErrorOutputType::Json` and no `SourceMap` is given, a new one\n /// will be created for the handler.\n-crate fn new_handler(\n+pub(crate) fn new_handler(\n     error_format: ErrorOutputType,\n     source_map: Option<Lrc<source_map::SourceMap>>,\n     debugging_opts: &DebuggingOptions,\n@@ -194,7 +202,7 @@ crate fn new_handler(\n }\n \n /// Parse, resolve, and typecheck the given crate.\n-crate fn create_config(\n+pub(crate) fn create_config(\n     RustdocOptions {\n         input,\n         crate_name,\n@@ -311,7 +319,7 @@ crate fn create_config(\n     }\n }\n \n-crate fn run_global_ctxt(\n+pub(crate) fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n     resolver_caches: ResolverCaches,\n@@ -535,7 +543,7 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-crate enum ImplTraitParam {\n+pub(crate) enum ImplTraitParam {\n     DefId(DefId),\n     ParamIndex(u32),\n }"}, {"sha": "be066bdafa14a1bcf2b9d7876f0a8c6b35728a08", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -15,38 +15,38 @@ use std::path::{Path, PathBuf};\n use std::string::ToString;\n use std::sync::mpsc::Sender;\n \n-crate trait PathError {\n+pub(crate) trait PathError {\n     fn new<S, P: AsRef<Path>>(e: S, path: P) -> Self\n     where\n         S: ToString + Sized;\n }\n \n-crate struct DocFS {\n+pub(crate) struct DocFS {\n     sync_only: bool,\n     errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    crate fn new(errors: Sender<String>) -> DocFS {\n+    pub(crate) fn new(errors: Sender<String>) -> DocFS {\n         DocFS { sync_only: false, errors: Some(errors) }\n     }\n \n-    crate fn set_sync_only(&mut self, sync_only: bool) {\n+    pub(crate) fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n-    crate fn close(&mut self) {\n+    pub(crate) fn close(&mut self) {\n         self.errors = None;\n     }\n \n-    crate fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+    pub(crate) fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n         // and directory creation.\n         fs::create_dir_all(path)\n     }\n \n-    crate fn write<E>(\n+    pub(crate) fn write<E>(\n         &self,\n         path: PathBuf,\n         contents: impl 'static + Send + AsRef<[u8]>,"}, {"sha": "3005bd9e4a4dd4dbb7e32788402839d480083b96", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -40,14 +40,14 @@ use crate::passes::span_of_attrs;\n \n /// Options that apply to all doctests in a crate or Markdown file (for `rustdoc foo.md`).\n #[derive(Clone, Default)]\n-crate struct GlobalTestOptions {\n+pub(crate) struct GlobalTestOptions {\n     /// Whether to disable the default `extern crate my_crate;` when creating doctests.\n-    crate no_crate_inject: bool,\n+    pub(crate) no_crate_inject: bool,\n     /// Additional crate-level attributes to add to doctests.\n-    crate attrs: Vec<String>,\n+    pub(crate) attrs: Vec<String>,\n }\n \n-crate fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n+pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = crate::lint::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -207,7 +207,11 @@ crate fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n     Ok(())\n }\n \n-crate fn run_tests(mut test_args: Vec<String>, nocapture: bool, tests: Vec<test::TestDescAndFn>) {\n+pub(crate) fn run_tests(\n+    mut test_args: Vec<String>,\n+    nocapture: bool,\n+    tests: Vec<test::TestDescAndFn>,\n+) {\n     test_args.insert(0, \"rustdoctest\".to_string());\n     if nocapture {\n         test_args.push(\"--nocapture\".to_string());\n@@ -488,7 +492,7 @@ fn run_test(\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n /// lines before the test code begins as well as if the output stream supports colors or not.\n-crate fn make_test(\n+pub(crate) fn make_test(\n     s: &str,\n     crate_name: Option<&str>,\n     dont_insert_main: bool,\n@@ -840,16 +844,16 @@ fn partition_source(s: &str, edition: Edition) -> (String, String, String) {\n     (before, after, crates)\n }\n \n-crate trait Tester {\n+pub(crate) trait Tester {\n     fn add_test(&mut self, test: String, config: LangString, line: usize);\n     fn get_line(&self) -> usize {\n         0\n     }\n     fn register_header(&mut self, _name: &str, _level: u32) {}\n }\n \n-crate struct Collector {\n-    crate tests: Vec<test::TestDescAndFn>,\n+pub(crate) struct Collector {\n+    pub(crate) tests: Vec<test::TestDescAndFn>,\n \n     // The name of the test displayed to the user, separated by `::`.\n     //\n@@ -887,7 +891,7 @@ crate struct Collector {\n }\n \n impl Collector {\n-    crate fn new(\n+    pub(crate) fn new(\n         crate_name: Symbol,\n         rustdoc_options: RustdocOptions,\n         use_headers: bool,\n@@ -922,7 +926,7 @@ impl Collector {\n         format!(\"{} - {}(line {})\", filename.prefer_local(), item_path, line)\n     }\n \n-    crate fn set_position(&mut self, position: Span) {\n+    pub(crate) fn set_position(&mut self, position: Span) {\n         self.position = position;\n     }\n "}, {"sha": "6ed7eab1abae6ae3097b36979d8454b859d91938", "filename": "src/librustdoc/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ferror.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -5,9 +5,9 @@ use std::path::{Path, PathBuf};\n use crate::docfs::PathError;\n \n #[derive(Debug)]\n-crate struct Error {\n-    crate file: PathBuf,\n-    crate error: String,\n+pub(crate) struct Error {\n+    pub(crate) file: PathBuf,\n+    pub(crate) error: String,\n }\n \n impl error::Error for Error {}"}, {"sha": "37fd909c93342aa33e6b4af93018112c05c4beb6", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -7,20 +7,20 @@ use std::str;\n use serde::Serialize;\n \n #[derive(Clone, Debug, Serialize)]\n-crate struct ExternalHtml {\n+pub(crate) struct ExternalHtml {\n     /// Content that will be included inline in the `<head>` section of a\n     /// rendered Markdown file or generated documentation\n-    crate in_header: String,\n+    pub(crate) in_header: String,\n     /// Content that will be included inline between `<body>` and the content of\n     /// a rendered Markdown file or generated documentation\n-    crate before_content: String,\n+    pub(crate) before_content: String,\n     /// Content that will be included inline between the content and `</body>` of\n     /// a rendered Markdown file or generated documentation\n-    crate after_content: String,\n+    pub(crate) after_content: String,\n }\n \n impl ExternalHtml {\n-    crate fn load(\n+    pub(crate) fn load(\n         in_header: &[String],\n         before_content: &[String],\n         after_content: &[String],\n@@ -70,12 +70,12 @@ impl ExternalHtml {\n     }\n }\n \n-crate enum LoadStringError {\n+pub(crate) enum LoadStringError {\n     ReadFail,\n     BadUtf8,\n }\n \n-crate fn load_string<P: AsRef<Path>>(\n+pub(crate) fn load_string<P: AsRef<Path>>(\n     file_path: P,\n     diag: &rustc_errors::Handler,\n ) -> Result<String, LoadStringError> {"}, {"sha": "f3e075bc12a344577a1b672820fe890af9cc4dfe", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,13 +1,13 @@\n use crate::clean::*;\n \n-crate fn strip_item(mut item: Item) -> Item {\n+pub(crate) fn strip_item(mut item: Item) -> Item {\n     if !matches!(*item.kind, StrippedItem(..)) {\n         item.kind = box StrippedItem(item.kind);\n     }\n     item\n }\n \n-crate trait DocFolder: Sized {\n+pub(crate) trait DocFolder: Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         Some(self.fold_item_recur(item))\n     }"}, {"sha": "f5c0b5e6762bfeef783316df6b4b96b1950b9307", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -26,25 +26,25 @@ use crate::html::render::IndexItem;\n /// to `Send` so it may be stored in an `Arc` instance and shared among the various\n /// rendering threads.\n #[derive(Default)]\n-crate struct Cache {\n+pub(crate) struct Cache {\n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate [`clean::Type::Path`]s, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    crate impls: FxHashMap<DefId, Vec<Impl>>,\n+    pub(crate) impls: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    crate paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n+    pub(crate) paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    crate external_paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n+    pub(crate) external_paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Maps local `DefId`s of exported types to fully qualified paths.\n     /// Unlike 'paths', this mapping ignores any renames that occur\n@@ -56,56 +56,56 @@ crate struct Cache {\n     /// to the path used if the corresponding type is inlined. By\n     /// doing this, we can detect duplicate impls on a trait page, and only display\n     /// the impl for the inlined type.\n-    crate exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n+    pub(crate) exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    crate traits: FxHashMap<DefId, clean::TraitWithExtraInfo>,\n+    pub(crate) traits: FxHashMap<DefId, clean::TraitWithExtraInfo>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n+    pub(crate) implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n-    crate extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n+    pub(crate) extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n \n     /// Cache of where documentation for primitives can be found.\n-    crate primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+    pub(crate) primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from the privacy check pass.\n-    crate access_levels: AccessLevels<DefId>,\n+    pub(crate) access_levels: AccessLevels<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    crate crate_version: Option<String>,\n+    pub(crate) crate_version: Option<String>,\n \n     /// Whether to document private items.\n     /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    crate document_private: bool,\n+    pub(crate) document_private: bool,\n \n     /// Crates marked with [`#[doc(masked)]`][doc_masked].\n     ///\n     /// [doc_masked]: https://doc.rust-lang.org/nightly/unstable-book/language-features/doc-masked.html\n-    crate masked_crates: FxHashSet<CrateNum>,\n+    pub(crate) masked_crates: FxHashSet<CrateNum>,\n \n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<Symbol>,\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     stripped_mod: bool,\n \n-    crate search_index: Vec<IndexItem>,\n+    pub(crate) search_index: Vec<IndexItem>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    crate orphan_impl_items: Vec<(DefId, clean::Item)>,\n+    pub(crate) orphan_impl_items: Vec<(DefId, clean::Item)>,\n \n     // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n     // even though the trait itself is not exported. This can happen if a trait\n@@ -119,9 +119,9 @@ crate struct Cache {\n     /// All intra-doc links resolved so far.\n     ///\n     /// Links are indexed by the DefId of the item they document.\n-    crate intra_doc_links: FxHashMap<ItemId, Vec<clean::ItemLink>>,\n+    pub(crate) intra_doc_links: FxHashMap<ItemId, Vec<clean::ItemLink>>,\n     /// Cfg that have been hidden via #![doc(cfg_hide(...))]\n-    crate hidden_cfg: FxHashSet<clean::cfg::Cfg>,\n+    pub(crate) hidden_cfg: FxHashSet<clean::cfg::Cfg>,\n }\n \n /// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`.\n@@ -133,13 +133,13 @@ struct CacheBuilder<'a, 'tcx> {\n }\n \n impl Cache {\n-    crate fn new(access_levels: AccessLevels<DefId>, document_private: bool) -> Self {\n+    pub(crate) fn new(access_levels: AccessLevels<DefId>, document_private: bool) -> Self {\n         Cache { access_levels, document_private, ..Cache::default() }\n     }\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n     /// in `krate` due to the data being moved into the `Cache`.\n-    crate fn populate(cx: &mut DocContext<'_>, mut krate: clean::Crate) -> clean::Crate {\n+    pub(crate) fn populate(cx: &mut DocContext<'_>, mut krate: clean::Crate) -> clean::Crate {\n         let tcx = cx.tcx;\n \n         // Crawl the crate to build various caches used for the output"}, {"sha": "eca5501cd339da075d8ba705db35adfdd75c9e79", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -21,7 +21,7 @@ use crate::clean;\n /// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n /// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)]\n-crate enum ItemType {\n+pub(crate) enum ItemType {\n     Module = 0,\n     ExternCrate = 1,\n     Import = 2,\n@@ -147,7 +147,7 @@ impl From<DefKind> for ItemType {\n }\n \n impl ItemType {\n-    crate fn as_str(&self) -> &'static str {\n+    pub(crate) fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module => \"mod\",\n             ItemType::ExternCrate => \"externcrate\","}, {"sha": "2367bde01671163f6fd54caafe8e5f0824ee342d", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,43 +1,43 @@\n-crate mod cache;\n-crate mod item_type;\n-crate mod renderer;\n+pub(crate) mod cache;\n+pub(crate) mod item_type;\n+pub(crate) mod renderer;\n \n use rustc_hir::def_id::DefId;\n \n-crate use renderer::{run_format, FormatRenderer};\n+pub(crate) use renderer::{run_format, FormatRenderer};\n \n use crate::clean::{self, ItemId};\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n-crate enum AssocItemRender<'a> {\n+pub(crate) enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Path, type_: &'a clean::Type, deref_mut_: bool },\n }\n \n /// For different handling of associated items from the Deref target of a type rather than the type\n /// itself.\n #[derive(Copy, Clone, PartialEq)]\n-crate enum RenderMode {\n+pub(crate) enum RenderMode {\n     Normal,\n     ForDeref { mut_: bool },\n }\n \n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n-crate struct Impl {\n-    crate impl_item: clean::Item,\n+pub(crate) struct Impl {\n+    pub(crate) impl_item: clean::Item,\n }\n \n impl Impl {\n-    crate fn inner_impl(&self) -> &clean::Impl {\n+    pub(crate) fn inner_impl(&self) -> &clean::Impl {\n         match *self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }\n     }\n \n-    crate fn trait_did(&self) -> Option<DefId> {\n+    pub(crate) fn trait_did(&self) -> Option<DefId> {\n         self.inner_impl().trait_.as_ref().map(|t| t.def_id())\n     }\n \n@@ -47,7 +47,7 @@ impl Impl {\n     /// with blanket impls).\n     ///\n     /// It panics if `self` is a `ItemId::Primitive`.\n-    crate fn def_id(&self) -> DefId {\n+    pub(crate) fn def_id(&self) -> DefId {\n         match self.impl_item.item_id {\n             ItemId::Blanket { impl_id, .. } => impl_id,\n             ItemId::Auto { trait_, .. } => trait_,"}, {"sha": "62ba984acc9619a06b3c5b4b1578bf3dc40a0d4b", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -9,7 +9,7 @@ use crate::formats::cache::Cache;\n /// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n-crate trait FormatRenderer<'tcx>: Sized {\n+pub(crate) trait FormatRenderer<'tcx>: Sized {\n     /// Gives a description of the renderer. Used for performance profiling.\n     fn descr() -> &'static str;\n \n@@ -48,7 +48,7 @@ crate trait FormatRenderer<'tcx>: Sized {\n }\n \n /// Main method for rendering a crate.\n-crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n+pub(crate) fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     krate: clean::Crate,\n     options: RenderOptions,\n     cache: Cache,"}, {"sha": "4a19d0a44c3655b4705f09f1a46c39bdb3ef741e", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n \n /// Wrapper struct which will emit the HTML-escaped version of the contained\n /// string when passed to a format string.\n-crate struct Escape<'a>(pub &'a str);\n+pub(crate) struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Display for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "3c492f51786c1314a0911102f99102e553b188d3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -33,7 +33,7 @@ use crate::html::render::Context;\n use super::url_parts_builder::estimate_item_path_byte_length;\n use super::url_parts_builder::UrlPartsBuilder;\n \n-crate trait Print {\n+pub(crate) trait Print {\n     fn print(self, buffer: &mut Buffer);\n }\n \n@@ -59,7 +59,7 @@ impl Print for &'_ str {\n }\n \n #[derive(Debug, Clone)]\n-crate struct Buffer {\n+pub(crate) struct Buffer {\n     for_html: bool,\n     buffer: String,\n }\n@@ -82,63 +82,63 @@ impl core::fmt::Write for Buffer {\n }\n \n impl Buffer {\n-    crate fn empty_from(v: &Buffer) -> Buffer {\n+    pub(crate) fn empty_from(v: &Buffer) -> Buffer {\n         Buffer { for_html: v.for_html, buffer: String::new() }\n     }\n \n-    crate fn html() -> Buffer {\n+    pub(crate) fn html() -> Buffer {\n         Buffer { for_html: true, buffer: String::new() }\n     }\n \n-    crate fn new() -> Buffer {\n+    pub(crate) fn new() -> Buffer {\n         Buffer { for_html: false, buffer: String::new() }\n     }\n \n-    crate fn is_empty(&self) -> bool {\n+    pub(crate) fn is_empty(&self) -> bool {\n         self.buffer.is_empty()\n     }\n \n-    crate fn into_inner(self) -> String {\n+    pub(crate) fn into_inner(self) -> String {\n         self.buffer\n     }\n \n-    crate fn insert_str(&mut self, idx: usize, s: &str) {\n+    pub(crate) fn insert_str(&mut self, idx: usize, s: &str) {\n         self.buffer.insert_str(idx, s);\n     }\n \n-    crate fn push_str(&mut self, s: &str) {\n+    pub(crate) fn push_str(&mut self, s: &str) {\n         self.buffer.push_str(s);\n     }\n \n-    crate fn push_buffer(&mut self, other: Buffer) {\n+    pub(crate) fn push_buffer(&mut self, other: Buffer) {\n         self.buffer.push_str(&other.buffer);\n     }\n \n     // Intended for consumption by write! and writeln! (std::fmt) but without\n     // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n     // import).\n-    crate fn write_str(&mut self, s: &str) {\n+    pub(crate) fn write_str(&mut self, s: &str) {\n         self.buffer.push_str(s);\n     }\n \n     // Intended for consumption by write! and writeln! (std::fmt) but without\n     // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n     // import).\n-    crate fn write_fmt(&mut self, v: fmt::Arguments<'_>) {\n+    pub(crate) fn write_fmt(&mut self, v: fmt::Arguments<'_>) {\n         use fmt::Write;\n         self.buffer.write_fmt(v).unwrap();\n     }\n \n-    crate fn to_display<T: Print>(mut self, t: T) -> String {\n+    pub(crate) fn to_display<T: Print>(mut self, t: T) -> String {\n         t.print(&mut self);\n         self.into_inner()\n     }\n \n-    crate fn is_for_html(&self) -> bool {\n+    pub(crate) fn is_for_html(&self) -> bool {\n         self.for_html\n     }\n \n-    crate fn reserve(&mut self, additional: usize) {\n+    pub(crate) fn reserve(&mut self, additional: usize) {\n         self.buffer.reserve(additional)\n     }\n }\n@@ -158,7 +158,7 @@ fn comma_sep<T: fmt::Display>(\n     })\n }\n \n-crate fn print_generic_bounds<'a, 'tcx: 'a>(\n+pub(crate) fn print_generic_bounds<'a, 'tcx: 'a>(\n     bounds: &'a [clean::GenericBound],\n     cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -176,7 +176,7 @@ crate fn print_generic_bounds<'a, 'tcx: 'a>(\n }\n \n impl clean::GenericParamDef {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -239,7 +239,7 @@ impl clean::GenericParamDef {\n }\n \n impl clean::Generics {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -262,7 +262,7 @@ impl clean::Generics {\n /// * The Generics from which to emit a where-clause.\n /// * The number of spaces to indent each line with.\n /// * Whether the where-clause needs to add a comma and newline after the last bound.\n-crate fn print_where_clause<'a, 'tcx: 'a>(\n+pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n     gens: &'a clean::Generics,\n     cx: &'a Context<'tcx>,\n     indent: usize,\n@@ -372,13 +372,13 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n }\n \n impl clean::Lifetime {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    pub(crate) fn print(&self) -> impl fmt::Display + '_ {\n         self.0.as_str()\n     }\n }\n \n impl clean::Constant {\n-    crate fn print(&self, tcx: TyCtxt<'_>) -> impl fmt::Display + '_ {\n+    pub(crate) fn print(&self, tcx: TyCtxt<'_>) -> impl fmt::Display + '_ {\n         let expr = self.expr(tcx);\n         display_fn(\n             move |f| {\n@@ -419,7 +419,7 @@ impl clean::PolyTrait {\n }\n \n impl clean::GenericBound {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -516,7 +516,7 @@ impl clean::GenericArgs {\n }\n \n // Possible errors when computing href link source for a `DefId`\n-crate enum HrefError {\n+pub(crate) enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///\n     /// This can only happen for non-local items.\n@@ -543,7 +543,7 @@ crate enum HrefError {\n }\n \n // Panics if `syms` is empty.\n-crate fn join_with_double_colon(syms: &[Symbol]) -> String {\n+pub(crate) fn join_with_double_colon(syms: &[Symbol]) -> String {\n     let mut s = String::with_capacity(estimate_item_path_byte_length(syms.len()));\n     s.push_str(&syms[0].as_str());\n     for sym in &syms[1..] {\n@@ -553,7 +553,7 @@ crate fn join_with_double_colon(syms: &[Symbol]) -> String {\n     s\n }\n \n-crate fn href_with_root_path(\n+pub(crate) fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n     root_path: Option<&str>,\n@@ -633,14 +633,17 @@ crate fn href_with_root_path(\n     Ok((url_parts.finish(), shortty, fqp.to_vec()))\n }\n \n-crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n+pub(crate) fn href(\n+    did: DefId,\n+    cx: &Context<'_>,\n+) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     href_with_root_path(did, cx, None)\n }\n \n /// Both paths should only be modules.\n /// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n /// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n-crate fn href_relative_parts<'fqp>(\n+pub(crate) fn href_relative_parts<'fqp>(\n     fqp: &'fqp [Symbol],\n     relative_to_fqp: &[Symbol],\n ) -> Box<dyn Iterator<Item = Symbol> + 'fqp> {\n@@ -787,7 +790,7 @@ fn tybounds<'a, 'tcx: 'a>(\n     })\n }\n \n-crate fn anchor<'a, 'cx: 'a>(\n+pub(crate) fn anchor<'a, 'cx: 'a>(\n     did: DefId,\n     text: Symbol,\n     cx: &'cx Context<'_>,\n@@ -1031,7 +1034,7 @@ fn fmt_type<'cx>(\n }\n \n impl clean::Type {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n@@ -1040,7 +1043,7 @@ impl clean::Type {\n }\n \n impl clean::Path {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n@@ -1049,7 +1052,7 @@ impl clean::Path {\n }\n \n impl clean::Impl {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         use_absolute: bool,\n         cx: &'a Context<'tcx>,\n@@ -1083,7 +1086,7 @@ impl clean::Impl {\n }\n \n impl clean::Arguments {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1107,7 +1110,7 @@ impl clean::Arguments {\n }\n \n impl clean::FnRetTy {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1142,7 +1145,7 @@ impl clean::BareFunctionDecl {\n }\n \n impl clean::FnDecl {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n@@ -1174,7 +1177,7 @@ impl clean::FnDecl {\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n     /// * `asyncness`: Whether the function is async or not.\n-    crate fn full_print<'a, 'tcx: 'a>(\n+    pub(crate) fn full_print<'a, 'tcx: 'a>(\n         &'a self,\n         header_len: usize,\n         indent: usize,\n@@ -1291,7 +1294,7 @@ impl clean::FnDecl {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'a, 'tcx: 'a>(\n+    pub(crate) fn print_with_space<'a, 'tcx: 'a>(\n         self,\n         item_did: ItemId,\n         cx: &'a Context<'tcx>,\n@@ -1339,7 +1342,7 @@ impl clean::Visibility {\n     /// This function is the same as print_with_space, except that it renders no links.\n     /// It's used for macros' rendered source view, which is syntax highlighted and cannot have\n     /// any HTML in it.\n-    crate fn to_src_with_space<'a, 'tcx: 'a>(\n+    pub(crate) fn to_src_with_space<'a, 'tcx: 'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         item_did: DefId,\n@@ -1374,7 +1377,7 @@ impl clean::Visibility {\n     }\n }\n \n-crate trait PrintWithSpace {\n+pub(crate) trait PrintWithSpace {\n     fn print_with_space(&self) -> &str;\n }\n \n@@ -1405,7 +1408,10 @@ impl PrintWithSpace for hir::Mutability {\n     }\n }\n \n-crate fn print_constness_with_space(c: &hir::Constness, s: Option<ConstStability>) -> &'static str {\n+pub(crate) fn print_constness_with_space(\n+    c: &hir::Constness,\n+    s: Option<ConstStability>,\n+) -> &'static str {\n     match (c, s) {\n         // const stable or when feature(staged_api) is not set\n         (\n@@ -1419,7 +1425,7 @@ crate fn print_constness_with_space(c: &hir::Constness, s: Option<ConstStability\n }\n \n impl clean::Import {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1443,7 +1449,7 @@ impl clean::Import {\n }\n \n impl clean::ImportSource {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1466,7 +1472,7 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1500,7 +1506,7 @@ impl clean::TypeBinding {\n     }\n }\n \n-crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n+pub(crate) fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n     display_fn(move |f| {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match abi {\n@@ -1510,12 +1516,12 @@ crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n     })\n }\n \n-crate fn print_default_space<'a>(v: bool) -> &'a str {\n+pub(crate) fn print_default_space<'a>(v: bool) -> &'a str {\n     if v { \"default \" } else { \"\" }\n }\n \n impl clean::GenericArg {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1529,7 +1535,7 @@ impl clean::GenericArg {\n }\n \n impl clean::types::Term {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1540,7 +1546,9 @@ impl clean::types::Term {\n     }\n }\n \n-crate fn display_fn(f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Display {\n+pub(crate) fn display_fn(\n+    f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+) -> impl fmt::Display {\n     struct WithFormatter<F>(Cell<Option<F>>);\n \n     impl<F> fmt::Display for WithFormatter<F>"}, {"sha": "480728b179790e6e4be8a702497db0e195edb258", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -22,21 +22,21 @@ use super::format::{self, Buffer};\n use super::render::LinkFromSrc;\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-crate struct ContextInfo<'a, 'b, 'c> {\n-    crate context: &'a Context<'b>,\n+pub(crate) struct ContextInfo<'a, 'b, 'c> {\n+    pub(crate) context: &'a Context<'b>,\n     /// This span contains the current file we're going through.\n-    crate file_span: Span,\n+    pub(crate) file_span: Span,\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n-    crate root_path: &'c str,\n+    pub(crate) root_path: &'c str,\n }\n \n /// Decorations are represented as a map from CSS class to vector of character ranges.\n /// Each range will be wrapped in a span with that class.\n-crate struct DecorationInfo(crate FxHashMap<&'static str, Vec<(u32, u32)>>);\n+pub(crate) struct DecorationInfo(pub(crate) FxHashMap<&'static str, Vec<(u32, u32)>>);\n \n /// Highlights `src`, returning the HTML output.\n-crate fn render_with_highlighting(\n+pub(crate) fn render_with_highlighting(\n     src: &str,\n     out: &mut Buffer,\n     class: Option<&str>,"}, {"sha": "de54347a0f74e0c7c889b49e540d12beb5e564f9", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -10,33 +10,33 @@ use crate::html::render::{ensure_trailing_slash, StylePath};\n use askama::Template;\n \n #[derive(Clone)]\n-crate struct Layout {\n-    crate logo: String,\n-    crate favicon: String,\n-    crate external_html: ExternalHtml,\n-    crate default_settings: FxHashMap<String, String>,\n-    crate krate: String,\n+pub(crate) struct Layout {\n+    pub(crate) logo: String,\n+    pub(crate) favicon: String,\n+    pub(crate) external_html: ExternalHtml,\n+    pub(crate) default_settings: FxHashMap<String, String>,\n+    pub(crate) krate: String,\n     /// The given user css file which allow to customize the generated\n     /// documentation theme.\n-    crate css_file_extension: Option<PathBuf>,\n+    pub(crate) css_file_extension: Option<PathBuf>,\n     /// If true, then scrape-examples.js will be included in the output HTML file\n-    crate scrape_examples_extension: bool,\n+    pub(crate) scrape_examples_extension: bool,\n }\n \n-crate struct Page<'a> {\n-    crate title: &'a str,\n-    crate css_class: &'a str,\n-    crate root_path: &'a str,\n-    crate static_root_path: Option<&'a str>,\n-    crate description: &'a str,\n-    crate keywords: &'a str,\n-    crate resource_suffix: &'a str,\n-    crate extra_scripts: &'a [&'a str],\n-    crate static_extra_scripts: &'a [&'a str],\n+pub(crate) struct Page<'a> {\n+    pub(crate) title: &'a str,\n+    pub(crate) css_class: &'a str,\n+    pub(crate) root_path: &'a str,\n+    pub(crate) static_root_path: Option<&'a str>,\n+    pub(crate) description: &'a str,\n+    pub(crate) keywords: &'a str,\n+    pub(crate) resource_suffix: &'a str,\n+    pub(crate) extra_scripts: &'a [&'a str],\n+    pub(crate) static_extra_scripts: &'a [&'a str],\n }\n \n impl<'a> Page<'a> {\n-    crate fn get_static_root_path(&self) -> &str {\n+    pub(crate) fn get_static_root_path(&self) -> &str {\n         self.static_root_path.unwrap_or(self.root_path)\n     }\n }\n@@ -51,10 +51,10 @@ struct PageLayout<'a> {\n     sidebar: String,\n     content: String,\n     krate_with_trailing_slash: String,\n-    crate rustdoc_version: &'a str,\n+    pub(crate) rustdoc_version: &'a str,\n }\n \n-crate fn render<T: Print, S: Print>(\n+pub(crate) fn render<T: Print, S: Print>(\n     layout: &Layout,\n     page: &Page<'_>,\n     sidebar: S,\n@@ -86,7 +86,7 @@ crate fn render<T: Print, S: Print>(\n     .unwrap()\n }\n \n-crate fn redirect(url: &str) -> String {\n+pub(crate) fn redirect(url: &str) -> String {\n     // <script> triggers a redirect before refresh, so this is fine.\n     format!(\n         r##\"<!DOCTYPE html>"}, {"sha": "8877f628332c981ffb97c8304b495a2761c9528a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -104,23 +104,23 @@ pub struct Markdown<'a> {\n     pub heading_offset: HeadingOffset,\n }\n /// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n-crate struct MarkdownWithToc<'a>(\n-    crate &'a str,\n-    crate &'a mut IdMap,\n-    crate ErrorCodes,\n-    crate Edition,\n-    crate &'a Option<Playground>,\n+pub(crate) struct MarkdownWithToc<'a>(\n+    pub(crate) &'a str,\n+    pub(crate) &'a mut IdMap,\n+    pub(crate) ErrorCodes,\n+    pub(crate) Edition,\n+    pub(crate) &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n-crate struct MarkdownHtml<'a>(\n-    crate &'a str,\n-    crate &'a mut IdMap,\n-    crate ErrorCodes,\n-    crate Edition,\n-    crate &'a Option<Playground>,\n+pub(crate) struct MarkdownHtml<'a>(\n+    pub(crate) &'a str,\n+    pub(crate) &'a mut IdMap,\n+    pub(crate) ErrorCodes,\n+    pub(crate) Edition,\n+    pub(crate) &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n-crate struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n+pub(crate) struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ErrorCodes {\n@@ -129,14 +129,14 @@ pub enum ErrorCodes {\n }\n \n impl ErrorCodes {\n-    crate fn from(b: bool) -> Self {\n+    pub(crate) fn from(b: bool) -> Self {\n         match b {\n             true => ErrorCodes::Yes,\n             false => ErrorCodes::No,\n         }\n     }\n \n-    crate fn as_bool(self) -> bool {\n+    pub(crate) fn as_bool(self) -> bool {\n         match self {\n             ErrorCodes::Yes => true,\n             ErrorCodes::No => false,\n@@ -716,7 +716,7 @@ impl<'a, I: Iterator<Item = SpannedEvent<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-crate fn find_testable_code<T: doctest::Tester>(\n+pub(crate) fn find_testable_code<T: doctest::Tester>(\n     doc: &str,\n     tests: &mut T,\n     error_codes: ErrorCodes,\n@@ -788,7 +788,7 @@ crate fn find_testable_code<T: doctest::Tester>(\n     }\n }\n \n-crate struct ExtraInfo<'tcx> {\n+pub(crate) struct ExtraInfo<'tcx> {\n     id: ExtraInfoId,\n     sp: Span,\n     tcx: TyCtxt<'tcx>,\n@@ -800,11 +800,11 @@ enum ExtraInfoId {\n }\n \n impl<'tcx> ExtraInfo<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n         ExtraInfo { id: ExtraInfoId::Hir(hir_id), sp, tcx }\n     }\n \n-    crate fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n+    pub(crate) fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n         ExtraInfo { id: ExtraInfoId::Def(did), sp, tcx }\n     }\n \n@@ -835,20 +835,20 @@ impl<'tcx> ExtraInfo<'tcx> {\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-crate struct LangString {\n+pub(crate) struct LangString {\n     original: String,\n-    crate should_panic: bool,\n-    crate no_run: bool,\n-    crate ignore: Ignore,\n-    crate rust: bool,\n-    crate test_harness: bool,\n-    crate compile_fail: bool,\n-    crate error_codes: Vec<String>,\n-    crate edition: Option<Edition>,\n+    pub(crate) should_panic: bool,\n+    pub(crate) no_run: bool,\n+    pub(crate) ignore: Ignore,\n+    pub(crate) rust: bool,\n+    pub(crate) test_harness: bool,\n+    pub(crate) compile_fail: bool,\n+    pub(crate) error_codes: Vec<String>,\n+    pub(crate) edition: Option<Edition>,\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-crate enum Ignore {\n+pub(crate) enum Ignore {\n     All,\n     None,\n     Some(Vec<String>),\n@@ -1058,7 +1058,7 @@ impl Markdown<'_> {\n }\n \n impl MarkdownWithToc<'_> {\n-    crate fn into_string(self) -> String {\n+    pub(crate) fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, main_body_opts()).into_offset_iter();\n@@ -1080,7 +1080,7 @@ impl MarkdownWithToc<'_> {\n }\n \n impl MarkdownHtml<'_> {\n-    crate fn into_string(self) -> String {\n+    pub(crate) fn into_string(self) -> String {\n         let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n@@ -1108,7 +1108,7 @@ impl MarkdownHtml<'_> {\n }\n \n impl MarkdownSummaryLine<'_> {\n-    crate fn into_string(self) -> String {\n+    pub(crate) fn into_string(self) -> String {\n         let MarkdownSummaryLine(md, links) = self;\n         // This is actually common enough to special-case\n         if md.is_empty() {\n@@ -1207,7 +1207,7 @@ fn markdown_summary_with_limit(\n /// Will shorten to 59 or 60 characters, including an ellipsis (\u2026) if it was shortened.\n ///\n /// See [`markdown_summary_with_limit`] for details about what is rendered and what is not.\n-crate fn short_markdown_summary(markdown: &str, link_names: &[RenderedLink]) -> String {\n+pub(crate) fn short_markdown_summary(markdown: &str, link_names: &[RenderedLink]) -> String {\n     let (mut s, was_shortened) = markdown_summary_with_limit(markdown, link_names, 59);\n \n     if was_shortened {\n@@ -1223,7 +1223,7 @@ crate fn short_markdown_summary(markdown: &str, link_names: &[RenderedLink]) ->\n /// - Headings, links, and formatting are stripped.\n /// - Inline code is rendered as-is, surrounded by backticks.\n /// - HTML and code blocks are ignored.\n-crate fn plain_text_summary(md: &str) -> String {\n+pub(crate) fn plain_text_summary(md: &str) -> String {\n     if md.is_empty() {\n         return String::new();\n     }\n@@ -1250,13 +1250,16 @@ crate fn plain_text_summary(md: &str) -> String {\n }\n \n #[derive(Debug)]\n-crate struct MarkdownLink {\n+pub(crate) struct MarkdownLink {\n     pub kind: LinkType,\n     pub link: String,\n     pub range: Range<usize>,\n }\n \n-crate fn markdown_links<R>(md: &str, filter_map: impl Fn(MarkdownLink) -> Option<R>) -> Vec<R> {\n+pub(crate) fn markdown_links<R>(\n+    md: &str,\n+    filter_map: impl Fn(MarkdownLink) -> Option<R>,\n+) -> Vec<R> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1337,19 +1340,19 @@ crate fn markdown_links<R>(md: &str, filter_map: impl Fn(MarkdownLink) -> Option\n }\n \n #[derive(Debug)]\n-crate struct RustCodeBlock {\n+pub(crate) struct RustCodeBlock {\n     /// The range in the markdown that the code block occupies. Note that this includes the fences\n     /// for fenced code blocks.\n-    crate range: Range<usize>,\n+    pub(crate) range: Range<usize>,\n     /// The range in the markdown that the code within the code block occupies.\n-    crate code: Range<usize>,\n-    crate is_fenced: bool,\n-    crate lang_string: LangString,\n+    pub(crate) code: Range<usize>,\n+    pub(crate) is_fenced: bool,\n+    pub(crate) lang_string: LangString,\n }\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n /// untagged (and assumed to be rust).\n-crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_>) -> Vec<RustCodeBlock> {\n+pub(crate) fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_>) -> Vec<RustCodeBlock> {\n     let mut code_blocks = vec![];\n \n     if md.is_empty() {\n@@ -1492,7 +1495,7 @@ impl IdMap {\n         IdMap { map: DEFAULT_ID_MAP.clone() }\n     }\n \n-    crate fn derive<S: AsRef<str> + ToString>(&mut self, candidate: S) -> String {\n+    pub(crate) fn derive<S: AsRef<str> + ToString>(&mut self, candidate: S) -> String {\n         let id = match self.map.get_mut(candidate.as_ref()) {\n             None => candidate.to_string(),\n             Some(a) => {"}, {"sha": "481ed16c05f7e0775051d947457eb278dab53379", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,14 +1,14 @@\n-crate mod escape;\n-crate mod format;\n-crate mod highlight;\n-crate mod layout;\n+pub(crate) mod escape;\n+pub(crate) mod format;\n+pub(crate) mod highlight;\n+pub(crate) mod layout;\n mod length_limit;\n // used by the error-index generator, so it needs to be public\n pub mod markdown;\n-crate mod render;\n-crate mod sources;\n-crate mod static_files;\n-crate mod toc;\n+pub(crate) mod render;\n+pub(crate) mod sources;\n+pub(crate) mod static_files;\n+pub(crate) mod toc;\n mod url_parts_builder;\n \n #[cfg(test)]"}, {"sha": "76377c438e832d3f59770ef68967a98b8836f472", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -42,13 +42,13 @@ use crate::try_err;\n /// It is intended that this context is a lightweight object which can be fairly\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n-crate struct Context<'tcx> {\n+pub(crate) struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub(crate) current: Vec<Symbol>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    crate dst: PathBuf,\n+    pub(crate) dst: PathBuf,\n     /// A flag, which when `true`, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n@@ -63,28 +63,28 @@ crate struct Context<'tcx> {\n     /// Issue for improving the situation: [#82381][]\n     ///\n     /// [#82381]: https://github.com/rust-lang/rust/issues/82381\n-    crate shared: Rc<SharedContext<'tcx>>,\n+    pub(crate) shared: Rc<SharedContext<'tcx>>,\n     /// This flag indicates whether source links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n-    crate include_sources: bool,\n+    pub(crate) include_sources: bool,\n }\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Context<'_>, 144);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n-crate struct SharedContext<'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct SharedContext<'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n-    crate src_root: PathBuf,\n+    pub(crate) src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n-    crate layout: layout::Layout,\n+    pub(crate) layout: layout::Layout,\n     /// The local file sources we've emitted and their respective url-paths.\n-    crate local_sources: FxHashMap<PathBuf, String>,\n+    pub(crate) local_sources: FxHashMap<PathBuf, String>,\n     /// Show the memory layout of types in the docs.\n     pub(super) show_type_layout: bool,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n@@ -97,15 +97,15 @@ crate struct SharedContext<'tcx> {\n     /// should be ordered alphabetically or in order of appearance (in the source code).\n     pub(super) sort_modules_alphabetically: bool,\n     /// Additional CSS files to be added to the generated docs.\n-    crate style_files: Vec<StylePath>,\n+    pub(crate) style_files: Vec<StylePath>,\n     /// Suffix to be added on resource files (if suffix is \"-v2\" then \"light.css\" becomes\n     /// \"light-v2.css\").\n-    crate resource_suffix: String,\n+    pub(crate) resource_suffix: String,\n     /// Optional path string to be used to load static files on output pages. If not set, uses\n     /// combinations of `../` to reach the documentation root.\n-    crate static_root_path: Option<String>,\n+    pub(crate) static_root_path: Option<String>,\n     /// The fs handle we are working with.\n-    crate fs: DocFS,\n+    pub(crate) fs: DocFS,\n     pub(super) codes: ErrorCodes,\n     pub(super) playground: Option<markdown::Playground>,\n     all: RefCell<AllTypes>,\n@@ -119,15 +119,15 @@ crate struct SharedContext<'tcx> {\n \n     /// Correspondance map used to link types used in the source code pages to allow to click on\n     /// links to jump to the type's definition.\n-    crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n+    pub(crate) span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n     /// The [`Cache`] used during rendering.\n-    crate cache: Cache,\n+    pub(crate) cache: Cache,\n \n-    crate call_locations: AllCallLocations,\n+    pub(crate) call_locations: AllCallLocations,\n }\n \n impl SharedContext<'_> {\n-    crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n+    pub(crate) fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n             try_err!(self.fs.create_dir_all(dst), dst);\n@@ -137,7 +137,7 @@ impl SharedContext<'_> {\n         Ok(())\n     }\n \n-    crate fn edition(&self) -> Edition {\n+    pub(crate) fn edition(&self) -> Edition {\n         self.tcx.sess.edition()\n     }\n }\n@@ -301,7 +301,7 @@ impl<'tcx> Context<'tcx> {\n         self.href_from_span(item.span(self.tcx()), true)\n     }\n \n-    crate fn href_from_span(&self, span: clean::Span, with_lines: bool) -> Option<String> {\n+    pub(crate) fn href_from_span(&self, span: clean::Span, with_lines: bool) -> Option<String> {\n         if span.is_dummy() {\n             return None;\n         }"}, {"sha": "0de50c60facb31e223235db2e66c6ff328d6e415", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -23,7 +23,7 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-crate mod search_index;\n+pub(crate) mod search_index;\n \n #[cfg(test)]\n mod tests;\n@@ -33,8 +33,8 @@ mod print_item;\n mod span_map;\n mod write_shared;\n \n-crate use self::context::*;\n-crate use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n+pub(crate) use self::context::*;\n+pub(crate) use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;\n@@ -81,9 +81,9 @@ use crate::try_none;\n use crate::DOC_RUST_LANG_ORG_CHANNEL;\n \n /// A pair of name and its optional document.\n-crate type NameDoc = (String, Option<String>);\n+pub(crate) type NameDoc = (String, Option<String>);\n \n-crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n+pub(crate) fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     crate::html::format::display_fn(move |f| {\n         if !v.ends_with('/') && !v.is_empty() { write!(f, \"{}/\", v) } else { f.write_str(v) }\n     })\n@@ -95,27 +95,27 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-crate struct IndexItem {\n-    crate ty: ItemType,\n-    crate name: String,\n-    crate path: String,\n-    crate desc: String,\n-    crate parent: Option<DefId>,\n-    crate parent_idx: Option<usize>,\n-    crate search_type: Option<IndexItemFunctionType>,\n-    crate aliases: Box<[Symbol]>,\n+pub(crate) struct IndexItem {\n+    pub(crate) ty: ItemType,\n+    pub(crate) name: String,\n+    pub(crate) path: String,\n+    pub(crate) desc: String,\n+    pub(crate) parent: Option<DefId>,\n+    pub(crate) parent_idx: Option<usize>,\n+    pub(crate) search_type: Option<IndexItemFunctionType>,\n+    pub(crate) aliases: Box<[Symbol]>,\n }\n \n /// A type used for the search index.\n #[derive(Debug)]\n-crate struct RenderType {\n+pub(crate) struct RenderType {\n     name: Option<String>,\n     generics: Option<Vec<TypeWithKind>>,\n }\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-crate struct IndexItemFunctionType {\n+pub(crate) struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Vec<TypeWithKind>,\n }\n@@ -143,7 +143,7 @@ impl Serialize for IndexItemFunctionType {\n }\n \n #[derive(Debug)]\n-crate struct TypeWithKind {\n+pub(crate) struct TypeWithKind {\n     ty: RenderType,\n     kind: ItemType,\n }\n@@ -170,13 +170,13 @@ impl Serialize for TypeWithKind {\n }\n \n #[derive(Debug, Clone)]\n-crate struct StylePath {\n+pub(crate) struct StylePath {\n     /// The path to the theme\n-    crate path: PathBuf,\n+    pub(crate) path: PathBuf,\n }\n \n impl StylePath {\n-    crate fn basename(&self) -> Result<String, Error> {\n+    pub(crate) fn basename(&self) -> Result<String, Error> {\n         Ok(try_none!(try_none!(self.path.file_stem(), &self.path).to_str(), &self.path).to_string())\n     }\n }\n@@ -203,7 +203,7 @@ impl ItemEntry {\n }\n \n impl ItemEntry {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    pub(crate) fn print(&self) -> impl fmt::Display + '_ {\n         crate::html::format::display_fn(move |f| {\n             write!(f, \"<a href=\\\"{}\\\">{}</a>\", self.url, Escape(&self.name))\n         })\n@@ -2580,7 +2580,7 @@ fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-crate const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";\n+pub(crate) const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";\n \n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls"}, {"sha": "12e6115e6fec7df955cac4d5e02e2ebed85d5a61", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -246,14 +246,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     // This call is to remove re-export duplicates in cases such as:\n     //\n     // ```\n-    // crate mod foo {\n-    //     crate mod bar {\n-    //         crate trait Double { fn foo(); }\n+    // pub(crate) mod foo {\n+    //     pub(crate) mod bar {\n+    //         pub(crate) trait Double { fn foo(); }\n     //     }\n     // }\n     //\n-    // crate use foo::bar::*;\n-    // crate use foo::*;\n+    // pub(crate) use foo::bar::*;\n+    // pub(crate) use foo::*;\n     // ```\n     //\n     // `Double` will appear twice in the generated docs.\n@@ -1473,7 +1473,7 @@ fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n }\n \n /// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n-crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+pub(crate) fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n     /// Takes a non-numeric and a numeric part from the given &str.\n     fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n         let i = s.find(|c: char| c.is_ascii_digit());"}, {"sha": "4e53ba4dc0cf6702a9feb844f4da05eac96d9070", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -15,7 +15,11 @@ use crate::html::markdown::short_markdown_summary;\n use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Builds the search index from the collected metadata\n-crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<'tcx>) -> String {\n+pub(crate) fn build_index<'tcx>(\n+    krate: &clean::Crate,\n+    cache: &mut Cache,\n+    tcx: TyCtxt<'tcx>,\n+) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_paths = vec![];\n \n@@ -185,7 +189,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     )\n }\n \n-crate fn get_function_type_for_search<'tcx>(\n+pub(crate) fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n     cache: &Cache,"}, {"sha": "287ce9611d75e107d90cb6f051414f0dcd9221e1", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -20,7 +20,7 @@ use std::path::{Path, PathBuf};\n /// Otherwise, we store the definition `DefId` and will generate a link to the documentation page\n /// instead of the source code directly.\n #[derive(Debug)]\n-crate enum LinkFromSrc {\n+pub(crate) enum LinkFromSrc {\n     Local(clean::Span),\n     External(DefId),\n     Primitive(PrimitiveType),\n@@ -36,7 +36,7 @@ crate enum LinkFromSrc {\n /// Note about the `span` correspondance map: the keys are actually `(lo, hi)` of `span`s. We don't\n /// need the `span` context later on, only their position, so instead of keep a whole `Span`, we\n /// only keep the `lo` and `hi`.\n-crate fn collect_spans_and_sources(\n+pub(crate) fn collect_spans_and_sources(\n     tcx: TyCtxt<'_>,\n     krate: &clean::Crate,\n     src_root: &Path,\n@@ -57,8 +57,8 @@ crate fn collect_spans_and_sources(\n }\n \n struct SpanMapVisitor<'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n-    crate matches: FxHashMap<Span, LinkFromSrc>,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+    pub(crate) matches: FxHashMap<Span, LinkFromSrc>,\n }\n \n impl<'tcx> SpanMapVisitor<'tcx> {"}, {"sha": "0bbdc37ea8972d20d95cd4d46b4bfc57e6037ad2", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -16,7 +16,7 @@ use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n \n-crate fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error> {\n+pub(crate) fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error> {\n     info!(\"emitting source files\");\n \n     let dst = cx.dst.join(\"src\").join(krate.name(cx.tcx()).as_str());\n@@ -27,7 +27,7 @@ crate fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error>\n     Ok(())\n }\n \n-crate fn collect_local_sources<'tcx>(\n+pub(crate) fn collect_local_sources<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     src_root: &Path,\n     krate: &clean::Crate,\n@@ -231,7 +231,7 @@ impl SourceCollector<'_, '_> {\n /// static HTML tree. Each component in the cleaned path will be passed as an\n /// argument to `f`. The very last component of the path (ie the file name) will\n /// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-crate fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+pub(crate) fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n where\n     F: FnMut(&OsStr),\n {\n@@ -253,14 +253,14 @@ where\n     }\n }\n \n-crate enum SourceContext {\n+pub(crate) enum SourceContext {\n     Standalone,\n     Embedded { offset: usize },\n }\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-crate fn print_src(\n+pub(crate) fn print_src(\n     buf: &mut Buffer,\n     s: &str,\n     edition: Edition,"}, {"sha": "75f2b7e3570d5627e4b2d47d6b01a569b4081d5e", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -8,131 +8,134 @@\n //! directly written to a `Write` handle.\n \n /// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n-crate static RUSTDOC_CSS: &str = include_str!(\"static/css/rustdoc.css\");\n+pub(crate) static RUSTDOC_CSS: &str = include_str!(\"static/css/rustdoc.css\");\n \n /// The file contents of `settings.css`, responsible for the items on the settings page.\n-crate static SETTINGS_CSS: &str = include_str!(\"static/css/settings.css\");\n+pub(crate) static SETTINGS_CSS: &str = include_str!(\"static/css/settings.css\");\n \n /// The file contents of the `noscript.css` file, used in case JS isn't supported or is disabled.\n-crate static NOSCRIPT_CSS: &str = include_str!(\"static/css/noscript.css\");\n+pub(crate) static NOSCRIPT_CSS: &str = include_str!(\"static/css/noscript.css\");\n \n /// The file contents of `normalize.css`, included to even out standard elements between browser\n /// implementations.\n-crate static NORMALIZE_CSS: &str = include_str!(\"static/css/normalize.css\");\n+pub(crate) static NORMALIZE_CSS: &str = include_str!(\"static/css/normalize.css\");\n \n /// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n /// including search behavior and docblock folding, among others.\n-crate static MAIN_JS: &str = include_str!(\"static/js/main.js\");\n+pub(crate) static MAIN_JS: &str = include_str!(\"static/js/main.js\");\n \n /// The file contents of `search.js`, which contains the search behavior.\n-crate static SEARCH_JS: &str = include_str!(\"static/js/search.js\");\n+pub(crate) static SEARCH_JS: &str = include_str!(\"static/js/search.js\");\n \n /// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n /// page.\n-crate static SETTINGS_JS: &str = include_str!(\"static/js/settings.js\");\n+pub(crate) static SETTINGS_JS: &str = include_str!(\"static/js/settings.js\");\n \n /// The file contents of `storage.js`, which contains functionality related to browser Local\n /// Storage, used to store documentation settings.\n-crate static STORAGE_JS: &str = include_str!(\"static/js/storage.js\");\n+pub(crate) static STORAGE_JS: &str = include_str!(\"static/js/storage.js\");\n \n /// The file contents of `scraped-examples.js`, which contains functionality related to the\n /// --scrape-examples flag that inserts automatically-found examples of usages of items.\n-crate static SCRAPE_EXAMPLES_JS: &str = include_str!(\"static/js/scrape-examples.js\");\n+pub(crate) static SCRAPE_EXAMPLES_JS: &str = include_str!(\"static/js/scrape-examples.js\");\n \n-crate static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/scrape-examples-help.md\");\n+pub(crate) static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/scrape-examples-help.md\");\n \n /// The file contents of `wheel.svg`, the icon used for the settings button.\n-crate static WHEEL_SVG: &[u8] = include_bytes!(\"static/images/wheel.svg\");\n+pub(crate) static WHEEL_SVG: &[u8] = include_bytes!(\"static/images/wheel.svg\");\n \n /// The file contents of `clipboard.svg`, the icon used for the \"copy path\" button.\n-crate static CLIPBOARD_SVG: &[u8] = include_bytes!(\"static/images/clipboard.svg\");\n+pub(crate) static CLIPBOARD_SVG: &[u8] = include_bytes!(\"static/images/clipboard.svg\");\n \n /// The file contents of `down-arrow.svg`, the icon used for the crate choice combobox.\n-crate static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/images/down-arrow.svg\");\n+pub(crate) static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/images/down-arrow.svg\");\n \n /// The file contents of `toggle-minus.svg`, the icon used for opened toggles.\n-crate static TOGGLE_MINUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-minus.svg\");\n+pub(crate) static TOGGLE_MINUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-minus.svg\");\n \n /// The file contents of `toggle-plus.svg`, the icon used for closed toggles.\n-crate static TOGGLE_PLUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-plus.svg\");\n+pub(crate) static TOGGLE_PLUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-plus.svg\");\n \n /// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n /// output.\n-crate static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+pub(crate) static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n \n /// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n-crate static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n+pub(crate) static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n \n /// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n-crate static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n+pub(crate) static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n \n /// The contents of `rust-logo.svg`, the default icon of the documentation.\n-crate static RUST_LOGO_SVG: &[u8] = include_bytes!(\"static/images/rust-logo.svg\");\n+pub(crate) static RUST_LOGO_SVG: &[u8] = include_bytes!(\"static/images/rust-logo.svg\");\n \n /// The default documentation favicons (SVG and PNG fallbacks)\n-crate static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/images/favicon.svg\");\n-crate static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/images/favicon-16x16.png\");\n-crate static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/images/favicon-32x32.png\");\n+pub(crate) static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/images/favicon.svg\");\n+pub(crate) static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/images/favicon-16x16.png\");\n+pub(crate) static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/images/favicon-32x32.png\");\n \n /// The built-in themes given to every documentation site.\n-crate mod themes {\n+pub(crate) mod themes {\n     /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n     /// the `--check-theme` functionality.\n-    crate static LIGHT: &str = include_str!(\"static/css/themes/light.css\");\n+    pub(crate) static LIGHT: &str = include_str!(\"static/css/themes/light.css\");\n \n     /// The \"dark\" theme.\n-    crate static DARK: &str = include_str!(\"static/css/themes/dark.css\");\n+    pub(crate) static DARK: &str = include_str!(\"static/css/themes/dark.css\");\n \n     /// The \"ayu\" theme.\n-    crate static AYU: &str = include_str!(\"static/css/themes/ayu.css\");\n+    pub(crate) static AYU: &str = include_str!(\"static/css/themes/ayu.css\");\n }\n \n /// Files related to the Fira Sans font.\n-crate mod fira_sans {\n+pub(crate) mod fira_sans {\n     /// The file `FiraSans-Regular.woff2`, the Regular variant of the Fira Sans font in woff2.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/FiraSans-Regular.woff2\");\n+    pub(crate) static REGULAR: &[u8] = include_bytes!(\"static/fonts/FiraSans-Regular.woff2\");\n \n     /// The file `FiraSans-Medium.woff2`, the Medium variant of the Fira Sans font in woff2.\n-    crate static MEDIUM: &[u8] = include_bytes!(\"static/fonts/FiraSans-Medium.woff2\");\n+    pub(crate) static MEDIUM: &[u8] = include_bytes!(\"static/fonts/FiraSans-Medium.woff2\");\n \n     /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/FiraSans-LICENSE.txt\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/FiraSans-LICENSE.txt\");\n }\n \n /// Files related to the Source Serif 4 font.\n-crate mod source_serif_4 {\n+pub(crate) mod source_serif_4 {\n     /// The file `SourceSerif4-Regular.ttf.woff2`, the Regular variant of the Source Serif 4 font in\n     /// woff2.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Regular.ttf.woff2\");\n+    pub(crate) static REGULAR: &[u8] =\n+        include_bytes!(\"static/fonts/SourceSerif4-Regular.ttf.woff2\");\n \n     /// The file `SourceSerif4-Bold.ttf.woff2`, the Bold variant of the Source Serif 4 font in\n     /// woff2.\n-    crate static BOLD: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Bold.ttf.woff2\");\n+    pub(crate) static BOLD: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Bold.ttf.woff2\");\n \n     /// The file `SourceSerif4-It.ttf.woff2`, the Italic variant of the Source Serif 4 font in\n     /// woff2.\n-    crate static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-It.ttf.woff2\");\n+    pub(crate) static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-It.ttf.woff2\");\n \n     /// The file `SourceSerif4-LICENSE.txt`, the license text for the Source Serif 4 font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-LICENSE.md\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-LICENSE.md\");\n }\n \n /// Files related to the Source Code Pro font.\n-crate mod source_code_pro {\n+pub(crate) mod source_code_pro {\n     /// The file `SourceCodePro-Regular.ttf.woff2`, the Regular variant of the Source Code Pro font\n     /// in woff2.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-Regular.ttf.woff2\");\n+    pub(crate) static REGULAR: &[u8] =\n+        include_bytes!(\"static/fonts/SourceCodePro-Regular.ttf.woff2\");\n \n     /// The file `SourceCodePro-Semibold.ttf.woff2`, the Semibold variant of the Source Code Pro\n     /// font in woff2.\n-    crate static SEMIBOLD: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-Semibold.ttf.woff2\");\n+    pub(crate) static SEMIBOLD: &[u8] =\n+        include_bytes!(\"static/fonts/SourceCodePro-Semibold.ttf.woff2\");\n \n     /// The file `SourceCodePro-It.ttf.woff2`, the Italic variant of the Source Code Pro font in\n     /// woff2.\n-    crate static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-It.ttf.woff2\");\n+    pub(crate) static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-It.ttf.woff2\");\n \n     /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-LICENSE.txt\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-LICENSE.txt\");\n }\n \n /// Files related to the Nanum Barun Gothic font.\n@@ -150,16 +153,16 @@ crate mod source_code_pro {\n /// --unicodes=U+AC00-D7AF,U+1100-11FF,U+3130-318F,U+A960-A97F,U+D7B0-D7FF \\\n /// --output-file=NanumBarunGothic.ttf.woff2 --flavor=woff2\n /// ```\n-crate mod nanum_barun_gothic {\n+pub(crate) mod nanum_barun_gothic {\n     /// The file `NanumBarunGothic.ttf.woff2`, the Regular variant of the Nanum Barun Gothic font.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic.ttf.woff2\");\n+    pub(crate) static REGULAR: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic.ttf.woff2\");\n \n     /// The file `NanumBarunGothic-LICENSE.txt`, the license text of the Nanum Barun Gothic font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic-LICENSE.txt\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic-LICENSE.txt\");\n }\n \n /// Files related to the sidebar in rustdoc sources.\n-crate mod sidebar {\n+pub(crate) mod sidebar {\n     /// File script to handle sidebar.\n-    crate static SOURCE_SCRIPT: &str = include_str!(\"static/js/source-script.js\");\n+    pub(crate) static SOURCE_SCRIPT: &str = include_str!(\"static/js/source-script.js\");\n }"}, {"sha": "07e33052aa7c3540292e9da520181c16c0401b4b", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -2,7 +2,7 @@\n \n /// A (recursive) table of contents\n #[derive(Debug, PartialEq)]\n-crate struct Toc {\n+pub(crate) struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n     /// `entries[0].level >= entries[1].level >= ...`\n@@ -26,7 +26,7 @@ impl Toc {\n }\n \n #[derive(Debug, PartialEq)]\n-crate struct TocEntry {\n+pub(crate) struct TocEntry {\n     level: u32,\n     sec_number: String,\n     name: String,\n@@ -36,7 +36,7 @@ crate struct TocEntry {\n \n /// Progressive construction of a table of contents.\n #[derive(PartialEq)]\n-crate struct TocBuilder {\n+pub(crate) struct TocBuilder {\n     top_level: Toc,\n     /// The current hierarchy of parent headings, the levels are\n     /// strictly increasing (i.e., `chain[0].level < chain[1].level <\n@@ -50,12 +50,12 @@ crate struct TocBuilder {\n }\n \n impl TocBuilder {\n-    crate fn new() -> TocBuilder {\n+    pub(crate) fn new() -> TocBuilder {\n         TocBuilder { top_level: Toc { entries: Vec::new() }, chain: Vec::new() }\n     }\n \n     /// Converts into a true `Toc` struct.\n-    crate fn into_toc(mut self) -> Toc {\n+    pub(crate) fn into_toc(mut self) -> Toc {\n         // we know all levels are >= 1.\n         self.fold_until(0);\n         self.top_level\n@@ -115,7 +115,7 @@ impl TocBuilder {\n     /// Push a level `level` heading into the appropriate place in the\n     /// hierarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n-    crate fn push(&mut self, level: u32, name: String, id: String) -> &str {\n+    pub(crate) fn push(&mut self, level: u32, name: String, id: String) -> &str {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we\n@@ -177,7 +177,7 @@ impl Toc {\n         }\n         v.push_str(\"</ul>\");\n     }\n-    crate fn print(&self) -> String {\n+    pub(crate) fn print(&self) -> String {\n         let mut v = String::new();\n         self.print_inner(&mut v);\n         v"}, {"sha": "1e6af6af63cc469154b6a6c825b152eec594cf49", "filename": "src/librustdoc/html/url_parts_builder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -8,14 +8,14 @@ use rustc_span::Symbol;\n /// This type is a wrapper around the final `String` buffer,\n /// but its API is like that of a `Vec` of URL components.\n #[derive(Debug)]\n-crate struct UrlPartsBuilder {\n+pub(crate) struct UrlPartsBuilder {\n     buf: String,\n }\n \n impl UrlPartsBuilder {\n     /// Create an empty buffer.\n     #[allow(dead_code)]\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         Self { buf: String::new() }\n     }\n \n@@ -43,7 +43,7 @@ impl UrlPartsBuilder {\n     /// builder.push_front(\"nightly\");\n     /// assert_eq!(builder.finish(), \"nightly/core/str\");\n     /// ```\n-    crate fn singleton(part: &str) -> Self {\n+    pub(crate) fn singleton(part: &str) -> Self {\n         Self { buf: part.to_owned() }\n     }\n \n@@ -60,7 +60,7 @@ impl UrlPartsBuilder {\n     /// builder.push(\"struct.Bytes.html\");\n     /// assert_eq!(builder.finish(), \"core/str/struct.Bytes.html\");\n     /// ```\n-    crate fn push(&mut self, part: &str) {\n+    pub(crate) fn push(&mut self, part: &str) {\n         if !self.buf.is_empty() {\n             self.buf.push('/');\n         }\n@@ -80,7 +80,7 @@ impl UrlPartsBuilder {\n     /// builder.push_fmt(format_args!(\"{}.{}.html\", \"struct\", \"Bytes\"));\n     /// assert_eq!(builder.finish(), \"core/str/struct.Bytes.html\");\n     /// ```\n-    crate fn push_fmt(&mut self, args: fmt::Arguments<'_>) {\n+    pub(crate) fn push_fmt(&mut self, args: fmt::Arguments<'_>) {\n         if !self.buf.is_empty() {\n             self.buf.push('/');\n         }\n@@ -101,7 +101,7 @@ impl UrlPartsBuilder {\n     /// builder.push(\"struct.Bytes.html\");\n     /// assert_eq!(builder.finish(), \"nightly/core/str/struct.Bytes.html\");\n     /// ```\n-    crate fn push_front(&mut self, part: &str) {\n+    pub(crate) fn push_front(&mut self, part: &str) {\n         let is_empty = self.buf.is_empty();\n         self.buf.reserve(part.len() + if !is_empty { 1 } else { 0 });\n         self.buf.insert_str(0, part);\n@@ -111,7 +111,7 @@ impl UrlPartsBuilder {\n     }\n \n     /// Get the final `String` buffer.\n-    crate fn finish(self) -> String {\n+    pub(crate) fn finish(self) -> String {\n         self.buf\n     }\n }\n@@ -134,7 +134,7 @@ const AVG_PART_LENGTH: usize = 8;\n ///\n /// **Note:** This is only to be used with, e.g., [`String::with_capacity()`];\n /// the return value is just a rough estimate.\n-crate const fn estimate_item_path_byte_length(segment_count: usize) -> usize {\n+pub(crate) const fn estimate_item_path_byte_length(segment_count: usize) -> usize {\n     AVG_PART_LENGTH * segment_count\n }\n "}, {"sha": "6f6f7e375a425a0e01da9aae67f6f0fdda340fae", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -91,11 +91,11 @@ impl JsonRenderer<'_> {\n     }\n }\n \n-crate trait FromWithTcx<T> {\n+pub(crate) trait FromWithTcx<T> {\n     fn from_tcx(f: T, tcx: TyCtxt<'_>) -> Self;\n }\n \n-crate trait IntoWithTcx<T> {\n+pub(crate) trait IntoWithTcx<T> {\n     fn into_tcx(self, tcx: TyCtxt<'_>) -> T;\n }\n \n@@ -108,7 +108,7 @@ where\n     }\n }\n \n-crate fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n+pub(crate) fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n     #[rustfmt::skip]\n     let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n     Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n@@ -173,7 +173,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_item_id(item_id: ItemId) -> Id {\n+pub(crate) fn from_item_id(item_id: ItemId) -> Id {\n     struct DisplayDefId(DefId);\n \n     impl fmt::Display for DisplayDefId {\n@@ -272,15 +272,15 @@ impl FromWithTcx<clean::Union> for Union {\n     }\n }\n \n-crate fn from_ctor_kind(struct_type: CtorKind) -> StructType {\n+pub(crate) fn from_ctor_kind(struct_type: CtorKind) -> StructType {\n     match struct_type {\n         CtorKind::Fictive => StructType::Plain,\n         CtorKind::Fn => StructType::Tuple,\n         CtorKind::Const => StructType::Unit,\n     }\n }\n \n-crate fn from_fn_header(header: &rustc_hir::FnHeader) -> Header {\n+pub(crate) fn from_fn_header(header: &rustc_hir::FnHeader) -> Header {\n     Header {\n         async_: header.is_async(),\n         const_: header.is_const(),\n@@ -390,7 +390,9 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n     }\n }\n \n-crate fn from_trait_bound_modifier(modifier: rustc_hir::TraitBoundModifier) -> TraitBoundModifier {\n+pub(crate) fn from_trait_bound_modifier(\n+    modifier: rustc_hir::TraitBoundModifier,\n+) -> TraitBoundModifier {\n     use rustc_hir::TraitBoundModifier::*;\n     match modifier {\n         None => TraitBoundModifier::None,\n@@ -554,7 +556,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n     }\n }\n \n-crate fn from_function(\n+pub(crate) fn from_function(\n     function: clean::Function,\n     header: rustc_hir::FnHeader,\n     tcx: TyCtxt<'_>,\n@@ -567,7 +569,7 @@ crate fn from_function(\n     }\n }\n \n-crate fn from_function_method(\n+pub(crate) fn from_function_method(\n     function: clean::Function,\n     has_body: bool,\n     header: rustc_hir::FnHeader,\n@@ -658,7 +660,7 @@ impl FromWithTcx<clean::ProcMacro> for ProcMacro {\n     }\n }\n \n-crate fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind {\n+pub(crate) fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind {\n     use rustc_span::hygiene::MacroKind::*;\n     match kind {\n         Bang => MacroKind::Bang,"}, {"sha": "08f61056d853f7952ae53f08ab02c3f8b85d3b49", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -29,7 +29,7 @@ use crate::json::conversions::{from_item_id, IntoWithTcx};\n use crate::{clean, try_err};\n \n #[derive(Clone)]\n-crate struct JsonRenderer<'tcx> {\n+pub(crate) struct JsonRenderer<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     /// A mapping of IDs that contains all local items for this crate which gets output as a top\n     /// level field of the JSON blob."}, {"sha": "61acf2de90d481f5631c2160b4d73df37004491d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -13,7 +13,6 @@\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]\n-#![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![feature(once_cell)]\n #![feature(type_ascription)]\n@@ -121,7 +120,7 @@ mod formats;\n // used by the error-index generator, so it needs to be public\n pub mod html;\n mod json;\n-crate mod lint;\n+pub(crate) mod lint;\n mod markdown;\n mod passes;\n mod scrape_examples;"}, {"sha": "08a1a868521f428cde748875dd5f3e025ce22950", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -169,7 +169,7 @@ declare_rustdoc_lint! {\n    \"codeblock could not be parsed as valid Rust or is empty\"\n }\n \n-crate static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n+pub(crate) static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     vec![\n         BROKEN_INTRA_DOC_LINKS,\n         PRIVATE_INTRA_DOC_LINKS,\n@@ -183,7 +183,7 @@ crate static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     ]\n });\n \n-crate fn register_lints(_sess: &Session, lint_store: &mut LintStore) {\n+pub(crate) fn register_lints(_sess: &Session, lint_store: &mut LintStore) {\n     lint_store.register_lints(&**RUSTDOC_LINTS);\n     lint_store.register_group(\n         true,"}, {"sha": "0b557ef244e94003a5b38292d8314a996bb5e7d4", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -36,7 +36,7 @@ fn extract_leading_metadata(s: &str) -> (Vec<&str>, &str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n-crate fn render<P: AsRef<Path>>(\n+pub(crate) fn render<P: AsRef<Path>>(\n     input: P,\n     options: RenderOptions,\n     edition: Edition,\n@@ -127,7 +127,7 @@ crate fn render<P: AsRef<Path>>(\n }\n \n /// Runs any tests/code examples in the markdown file `input`.\n-crate fn test(options: Options) -> Result<(), String> {\n+pub(crate) fn test(options: Options) -> Result<(), String> {\n     let input_str = read_to_string(&options.input)\n         .map_err(|err| format!(\"{}: {}\", options.input.display(), err))?;\n     let mut opts = GlobalTestOptions::default();"}, {"sha": "e9e810658ef85c5ea7e38d932d674781fcc4d1ab", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::Applicability;\n use std::lazy::SyncLazy;\n use std::mem;\n \n-crate const CHECK_BARE_URLS: Pass = Pass {\n+pub(crate) const CHECK_BARE_URLS: Pass = Pass {\n     name: \"check-bare-urls\",\n     run: check_bare_urls,\n     description: \"detects URLs that are not hyperlinks\",\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> BareUrlsLinter<'a, 'tcx> {\n     }\n }\n \n-crate fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     BareUrlsLinter { cx }.visit_crate(&krate);\n     krate\n }"}, {"sha": "3981d49a8a904f74148b97111505991778f9402b", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -16,7 +16,7 @@ use serde::Serialize;\n use std::collections::BTreeMap;\n use std::ops;\n \n-crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n+pub(crate) const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     name: \"calculate-doc-coverage\",\n     run: calculate_doc_coverage,\n     description: \"counts the number of items with and without documentation\","}, {"sha": "8a50938f82b0a66f6f4cbdb3ca858b55c5cacd86", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -14,13 +14,16 @@ use crate::html::markdown::{self, RustCodeBlock};\n use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n-crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n+pub(crate) const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n     run: check_code_block_syntax,\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-crate fn check_code_block_syntax(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn check_code_block_syntax(\n+    krate: clean::Crate,\n+    cx: &mut DocContext<'_>,\n+) -> clean::Crate {\n     SyntaxChecker { cx }.visit_crate(&krate);\n     krate\n }"}, {"sha": "0fb0c7dbdd7ca46c705035a3f1e6e0daaa8b0d97", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::lint::LintLevelSource;\n use rustc_session::lint;\n use rustc_span::symbol::sym;\n \n-crate const CHECK_DOC_TEST_VISIBILITY: Pass = Pass {\n+pub(crate) const CHECK_DOC_TEST_VISIBILITY: Pass = Pass {\n     name: \"check_doc_test_visibility\",\n     run: check_doc_test_visibility,\n     description: \"run various visibility-related lints on doctests\",\n@@ -27,7 +27,7 @@ struct DocTestVisibilityLinter<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n }\n \n-crate fn check_doc_test_visibility(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn check_doc_test_visibility(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     let mut coll = DocTestVisibilityLinter { cx };\n     coll.visit_crate(&krate);\n     krate\n@@ -55,7 +55,7 @@ impl crate::doctest::Tester for Tests {\n     }\n }\n \n-crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n+pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n     if !cx.cache.access_levels.is_public(item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n@@ -106,7 +106,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n     level != lint::Level::Allow || matches!(source, LintLevelSource::Default)\n }\n \n-crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n+pub(crate) fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n     let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.item_id)\n     else {\n         // If non-local, no need to check anything."}, {"sha": "ea0f5102539f6ccf780eda2ec5a88362d69d71b3", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -33,9 +33,9 @@ use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n mod early;\n-crate use early::early_resolve_intra_doc_links;\n+pub(crate) use early::early_resolve_intra_doc_links;\n \n-crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n+pub(crate) const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n     description: \"resolves intra-doc links\",\n@@ -219,14 +219,14 @@ enum MalformedGenerics {\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-crate enum UrlFragment {\n+pub(crate) enum UrlFragment {\n     Item(ItemFragment),\n     UserWritten(String),\n }\n \n impl UrlFragment {\n     /// Render the fragment, including the leading `#`.\n-    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         match self {\n             UrlFragment::Item(frag) => frag.render(s, tcx),\n             UrlFragment::UserWritten(raw) => write!(s, \"#{}\", raw),\n@@ -235,10 +235,10 @@ impl UrlFragment {\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-crate struct ItemFragment(FragmentKind, DefId);\n+pub(crate) struct ItemFragment(FragmentKind, DefId);\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-crate enum FragmentKind {\n+pub(crate) enum FragmentKind {\n     Method,\n     TyMethod,\n     AssociatedConstant,\n@@ -276,7 +276,7 @@ impl FragmentKind {\n \n impl ItemFragment {\n     /// Render the fragment, including the leading `#`.\n-    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         write!(s, \"#\")?;\n         match *self {\n             ItemFragment(kind, def_id) => {\n@@ -954,7 +954,10 @@ struct PreprocessingInfo {\n }\n \n // Not a typedef to avoid leaking several private structures from this module.\n-crate struct PreprocessedMarkdownLink(Result<PreprocessingInfo, PreprocessingError>, MarkdownLink);\n+pub(crate) struct PreprocessedMarkdownLink(\n+    Result<PreprocessingInfo, PreprocessingError>,\n+    MarkdownLink,\n+);\n \n /// Returns:\n /// - `None` if the link should be ignored."}, {"sha": "a38c44bc888556d8daaf382c4e8c0367fd4e11e9", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -21,7 +21,7 @@ use rustc_span::{Symbol, SyntaxContext};\n use std::collections::hash_map::Entry;\n use std::mem;\n \n-crate fn early_resolve_intra_doc_links(\n+pub(crate) fn early_resolve_intra_doc_links(\n     resolver: &mut Resolver<'_>,\n     sess: &Session,\n     krate: &ast::Crate,"}, {"sha": "aa7028247bed49d739712b5a4b74b0ad2606a35a", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -12,13 +12,13 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n-crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n+pub(crate) const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n     run: collect_trait_impls,\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     let synth_impls = cx.sess().time(\"collect_synthetic_impls\", || {\n         let mut synth = SyntheticImplCollector { cx, impls: Vec::new() };\n         synth.visit_crate(&krate);"}, {"sha": "3012db0cad66206939e48007c0f64e55c444484b", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -11,7 +11,7 @@ use std::iter::Peekable;\n use std::ops::Range;\n use std::str::CharIndices;\n \n-crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n+pub(crate) const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n     name: \"check-invalid-html-tags\",\n     run: check_invalid_html_tags,\n     description: \"detects invalid HTML tags in doc comments\",\n@@ -21,7 +21,7 @@ struct InvalidHtmlTagsLinter<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n }\n \n-crate fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     if cx.tcx.sess.is_nightly_build() {\n         let mut coll = InvalidHtmlTagsLinter { cx };\n         coll.visit_crate(&krate);"}, {"sha": "f81b38ea39574f1c08ccad79ac4c550d85222d8e", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -10,61 +10,61 @@ use crate::clean::{self, DocFragmentKind};\n use crate::core::DocContext;\n \n mod stripper;\n-crate use stripper::*;\n+pub(crate) use stripper::*;\n \n mod bare_urls;\n-crate use self::bare_urls::CHECK_BARE_URLS;\n+pub(crate) use self::bare_urls::CHECK_BARE_URLS;\n \n mod strip_hidden;\n-crate use self::strip_hidden::STRIP_HIDDEN;\n+pub(crate) use self::strip_hidden::STRIP_HIDDEN;\n \n mod strip_private;\n-crate use self::strip_private::STRIP_PRIVATE;\n+pub(crate) use self::strip_private::STRIP_PRIVATE;\n \n mod strip_priv_imports;\n-crate use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n+pub(crate) use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n mod propagate_doc_cfg;\n-crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n+pub(crate) use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n-crate mod collect_intra_doc_links;\n-crate use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n+pub(crate) mod collect_intra_doc_links;\n+pub(crate) use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n mod check_doc_test_visibility;\n-crate use self::check_doc_test_visibility::CHECK_DOC_TEST_VISIBILITY;\n+pub(crate) use self::check_doc_test_visibility::CHECK_DOC_TEST_VISIBILITY;\n \n mod collect_trait_impls;\n-crate use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n+pub(crate) use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n mod check_code_block_syntax;\n-crate use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n+pub(crate) use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n \n mod calculate_doc_coverage;\n-crate use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n+pub(crate) use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n \n mod html_tags;\n-crate use self::html_tags::CHECK_INVALID_HTML_TAGS;\n+pub(crate) use self::html_tags::CHECK_INVALID_HTML_TAGS;\n \n /// A single pass over the cleaned documentation.\n ///\n /// Runs in the compiler context, so it has access to types and traits and the like.\n #[derive(Copy, Clone)]\n-crate struct Pass {\n-    crate name: &'static str,\n-    crate run: fn(clean::Crate, &mut DocContext<'_>) -> clean::Crate,\n-    crate description: &'static str,\n+pub(crate) struct Pass {\n+    pub(crate) name: &'static str,\n+    pub(crate) run: fn(clean::Crate, &mut DocContext<'_>) -> clean::Crate,\n+    pub(crate) description: &'static str,\n }\n \n /// In a list of passes, a pass that may or may not need to be run depending on options.\n #[derive(Copy, Clone)]\n-crate struct ConditionalPass {\n-    crate pass: Pass,\n-    crate condition: Condition,\n+pub(crate) struct ConditionalPass {\n+    pub(crate) pass: Pass,\n+    pub(crate) condition: Condition,\n }\n \n /// How to decide whether to run a conditional pass.\n #[derive(Copy, Clone)]\n-crate enum Condition {\n+pub(crate) enum Condition {\n     Always,\n     /// When `--document-private-items` is passed.\n     WhenDocumentPrivate,\n@@ -75,7 +75,7 @@ crate enum Condition {\n }\n \n /// The full list of passes.\n-crate const PASSES: &[Pass] = &[\n+pub(crate) const PASSES: &[Pass] = &[\n     CHECK_DOC_TEST_VISIBILITY,\n     STRIP_HIDDEN,\n     STRIP_PRIVATE,\n@@ -90,7 +90,7 @@ crate const PASSES: &[Pass] = &[\n ];\n \n /// The list of passes run by default.\n-crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n+pub(crate) const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n     ConditionalPass::always(CHECK_DOC_TEST_VISIBILITY),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n@@ -104,29 +104,29 @@ crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-crate const COVERAGE_PASSES: &[ConditionalPass] = &[\n+pub(crate) const COVERAGE_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n     ConditionalPass::always(CALCULATE_DOC_COVERAGE),\n ];\n \n impl ConditionalPass {\n-    crate const fn always(pass: Pass) -> Self {\n+    pub(crate) const fn always(pass: Pass) -> Self {\n         Self::new(pass, Always)\n     }\n \n-    crate const fn new(pass: Pass, condition: Condition) -> Self {\n+    pub(crate) const fn new(pass: Pass, condition: Condition) -> Self {\n         ConditionalPass { pass, condition }\n     }\n }\n \n /// Returns the given default set of passes.\n-crate fn defaults(show_coverage: bool) -> &'static [ConditionalPass] {\n+pub(crate) fn defaults(show_coverage: bool) -> &'static [ConditionalPass] {\n     if show_coverage { COVERAGE_PASSES } else { DEFAULT_PASSES }\n }\n \n /// Returns a span encompassing all the given attributes.\n-crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n+pub(crate) fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n     if attrs.doc_strings.is_empty() {\n         return None;\n     }\n@@ -143,7 +143,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n /// This method will return `None` if we cannot construct a span from the source map or if the\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n-crate fn source_span_for_markdown_range(\n+pub(crate) fn source_span_for_markdown_range(\n     tcx: TyCtxt<'_>,\n     markdown: &str,\n     md_range: &Range<usize>,"}, {"sha": "0c5d836551823ca322cd5b99f8e38730c1b92ffe", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -7,13 +7,13 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n-crate const PROPAGATE_DOC_CFG: Pass = Pass {\n+pub(crate) const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n     run: propagate_doc_cfg,\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-crate fn propagate_doc_cfg(cr: Crate, _: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn propagate_doc_cfg(cr: Crate, _: &mut DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "ab5526e0612b7b12bb37e5b62c076bbd382a8ed8", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -8,14 +8,14 @@ use crate::core::DocContext;\n use crate::fold::{strip_item, DocFolder};\n use crate::passes::{ImplStripper, Pass};\n \n-crate const STRIP_HIDDEN: Pass = Pass {\n+pub(crate) const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n     run: strip_hidden,\n     description: \"strips all `#[doc(hidden)]` items from the output\",\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-crate fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     let mut retained = ItemIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "85be8fa109a7e078fb71394b43e5e5ec42158798", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -5,12 +5,12 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImportStripper, Pass};\n \n-crate const STRIP_PRIV_IMPORTS: Pass = Pass {\n+pub(crate) const STRIP_PRIV_IMPORTS: Pass = Pass {\n     name: \"strip-priv-imports\",\n     run: strip_priv_imports,\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-crate fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "6c94912bc536811821154b043f1169d28e90c7d6", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -5,7 +5,7 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n \n-crate const STRIP_PRIVATE: Pass = Pass {\n+pub(crate) const STRIP_PRIVATE: Pass = Pass {\n     name: \"strip-private\",\n     run: strip_private,\n     description: \"strips all private items from a crate which cannot be seen externally, \\\n@@ -14,7 +14,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = ItemIdSet::default();\n "}, {"sha": "d5db919dc4b2abee4a14f35771daf64938051219", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -7,10 +7,10 @@ use crate::clean::{self, Item, ItemIdSet};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n \n-crate struct Stripper<'a> {\n-    crate retained: &'a mut ItemIdSet,\n-    crate access_levels: &'a AccessLevels<DefId>,\n-    crate update_retained: bool,\n+pub(crate) struct Stripper<'a> {\n+    pub(crate) retained: &'a mut ItemIdSet,\n+    pub(crate) access_levels: &'a AccessLevels<DefId>,\n+    pub(crate) update_retained: bool,\n }\n \n impl<'a> DocFolder for Stripper<'a> {\n@@ -116,9 +116,9 @@ impl<'a> DocFolder for Stripper<'a> {\n }\n \n /// This stripper discards all impls which reference stripped items\n-crate struct ImplStripper<'a> {\n-    crate retained: &'a ItemIdSet,\n-    crate cache: &'a Cache,\n+pub(crate) struct ImplStripper<'a> {\n+    pub(crate) retained: &'a ItemIdSet,\n+    pub(crate) cache: &'a Cache,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -159,7 +159,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n }\n \n /// This stripper discards all private import statements (`use`, `extern crate`)\n-crate struct ImportStripper;\n+pub(crate) struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {"}, {"sha": "0fa492af1ad0adfb471377f28c7fa6e6748d6437", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -31,14 +31,14 @@ use std::fs;\n use std::path::PathBuf;\n \n #[derive(Debug, Clone)]\n-crate struct ScrapeExamplesOptions {\n+pub(crate) struct ScrapeExamplesOptions {\n     output_path: PathBuf,\n     target_crates: Vec<String>,\n-    crate scrape_tests: bool,\n+    pub(crate) scrape_tests: bool,\n }\n \n impl ScrapeExamplesOptions {\n-    crate fn new(\n+    pub(crate) fn new(\n         matches: &getopts::Matches,\n         diag: &rustc_errors::Handler,\n     ) -> Result<Option<Self>, i32> {\n@@ -65,9 +65,9 @@ impl ScrapeExamplesOptions {\n }\n \n #[derive(Encodable, Decodable, Debug, Clone)]\n-crate struct SyntaxRange {\n-    crate byte_span: (u32, u32),\n-    crate line_span: (usize, usize),\n+pub(crate) struct SyntaxRange {\n+    pub(crate) byte_span: (u32, u32),\n+    pub(crate) line_span: (usize, usize),\n }\n \n impl SyntaxRange {\n@@ -83,10 +83,10 @@ impl SyntaxRange {\n }\n \n #[derive(Encodable, Decodable, Debug, Clone)]\n-crate struct CallLocation {\n-    crate call_expr: SyntaxRange,\n-    crate call_ident: SyntaxRange,\n-    crate enclosing_item: SyntaxRange,\n+pub(crate) struct CallLocation {\n+    pub(crate) call_expr: SyntaxRange,\n+    pub(crate) call_ident: SyntaxRange,\n+    pub(crate) enclosing_item: SyntaxRange,\n }\n \n impl CallLocation {\n@@ -105,15 +105,15 @@ impl CallLocation {\n }\n \n #[derive(Encodable, Decodable, Debug, Clone)]\n-crate struct CallData {\n-    crate locations: Vec<CallLocation>,\n-    crate url: String,\n-    crate display_name: String,\n-    crate edition: Edition,\n+pub(crate) struct CallData {\n+    pub(crate) locations: Vec<CallLocation>,\n+    pub(crate) url: String,\n+    pub(crate) display_name: String,\n+    pub(crate) edition: Edition,\n }\n \n-crate type FnCallLocations = FxHashMap<PathBuf, CallData>;\n-crate type AllCallLocations = FxHashMap<DefPathHash, FnCallLocations>;\n+pub(crate) type FnCallLocations = FxHashMap<PathBuf, CallData>;\n+pub(crate) type AllCallLocations = FxHashMap<DefPathHash, FnCallLocations>;\n \n /// Visitor for traversing a crate and finding instances of function calls.\n struct FindCalls<'a, 'tcx> {\n@@ -270,7 +270,7 @@ where\n     }\n }\n \n-crate fn run(\n+pub(crate) fn run(\n     krate: clean::Crate,\n     mut renderopts: config::RenderOptions,\n     cache: formats::cache::Cache,\n@@ -328,7 +328,7 @@ crate fn run(\n }\n \n // Note: the Handler must be passed in explicitly because sess isn't available while parsing options\n-crate fn load_call_locations(\n+pub(crate) fn load_call_locations(\n     with_examples: Vec<String>,\n     diag: &rustc_errors::Handler,\n ) -> Result<AllCallLocations, i32> {"}, {"sha": "20258c3b1dc1c67d01c57e7f17a0c13f8fec7157", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -9,9 +9,9 @@ use rustc_errors::Handler;\n mod tests;\n \n #[derive(Debug, Clone, Eq)]\n-crate struct CssPath {\n-    crate name: String,\n-    crate children: FxHashSet<CssPath>,\n+pub(crate) struct CssPath {\n+    pub(crate) name: String,\n+    pub(crate) children: FxHashSet<CssPath>,\n }\n \n // This PartialEq implementation IS NOT COMMUTATIVE!!!\n@@ -214,7 +214,7 @@ fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n     paths.iter().cloned().collect()\n }\n \n-crate fn load_css_paths(v: &[u8]) -> CssPath {\n+pub(crate) fn load_css_paths(v: &[u8]) -> CssPath {\n     let events = load_css_events(v);\n     let mut pos = 0;\n \n@@ -223,7 +223,7 @@ crate fn load_css_paths(v: &[u8]) -> CssPath {\n     parent\n }\n \n-crate fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n+pub(crate) fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n     if against.name == other.name {\n         for child in &against.children {\n             let mut found = false;\n@@ -250,7 +250,7 @@ crate fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>\n     }\n }\n \n-crate fn test_theme_against<P: AsRef<Path>>(\n+pub(crate) fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n     against: &CssPath,\n     diag: &Handler,"}, {"sha": "fa8be9a97c5a3df39099234e8e5d6b75f0834f03", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,6 +1,6 @@\n use crate::clean::*;\n \n-crate trait DocVisitor: Sized {\n+pub(crate) trait DocVisitor: Sized {\n     fn visit_item(&mut self, item: &Item) {\n         self.visit_item_recur(item)\n     }"}, {"sha": "519ace7b89a3009222e6a945de34908c304a2157", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -21,22 +21,22 @@ use crate::core;\n /// This module is used to store stuff from Rust's AST in a more convenient\n /// manner (and with prettier names) before cleaning.\n #[derive(Debug)]\n-crate struct Module<'hir> {\n-    crate name: Symbol,\n-    crate where_inner: Span,\n-    crate mods: Vec<Module<'hir>>,\n-    crate id: hir::HirId,\n+pub(crate) struct Module<'hir> {\n+    pub(crate) name: Symbol,\n+    pub(crate) where_inner: Span,\n+    pub(crate) mods: Vec<Module<'hir>>,\n+    pub(crate) id: hir::HirId,\n     // (item, renamed)\n-    crate items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n-    crate foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n+    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n+    pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n impl Module<'_> {\n-    crate fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Self {\n+    pub(crate) fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Self {\n         Module { name, id, where_inner, mods: Vec::new(), items: Vec::new(), foreigns: Vec::new() }\n     }\n \n-    crate fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {\n+    pub(crate) fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.hir().span(self.id)\n     }\n }\n@@ -48,7 +48,7 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-crate fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n     while let Some(id) = tcx.hir().get_enclosing_scope(node) {\n         node = id;\n         if tcx.hir().attrs(node).lists(sym::doc).has_word(sym::hidden) {\n@@ -61,7 +61,7 @@ crate fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n \n-crate struct RustdocVisitor<'a, 'tcx> {\n+pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n@@ -71,7 +71,7 @@ crate struct RustdocVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n+    pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n-    crate fn visit(mut self) -> Module<'tcx> {\n+    pub(crate) fn visit(mut self) -> Module<'tcx> {\n         let mut top_level_module = self.visit_mod_contents(\n             hir::CRATE_HIR_ID,\n             self.cx.tcx.hir().root_module(),"}, {"sha": "f01ec38665c015e8fd65fe3e7d825ace57168029", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::TyCtxt;\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-crate struct LibEmbargoVisitor<'a, 'tcx> {\n+pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: &'a mut AccessLevels<DefId>,\n@@ -19,7 +19,7 @@ crate struct LibEmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    crate fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n+    pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n             access_levels: &mut cx.cache.access_levels,\n@@ -28,7 +28,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    crate fn visit_lib(&mut self, cnum: CrateNum) {\n+    pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = cnum.as_def_id();\n         self.update(did, Some(AccessLevel::Public));\n         self.visit_mod(did);\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    crate fn visit_mod(&mut self, def_id: DefId) {\n+    pub(crate) fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }"}, {"sha": "4099b54f0815209706ddcf6750221c3e17df23da", "filename": "src/test/rustdoc/visibility.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Frustdoc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Frustdoc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvisibility.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,15 +1,13 @@\n // compile-flags: --document-private-items\n \n-#![feature(crate_visibility_modifier)]\n-\n #![crate_name = \"foo\"]\n \n // @!has 'foo/index.html' '//a[@href=\"struct.FooPublic.html\"]/..' 'FooPublic \ud83d\udd12'\n // @has 'foo/struct.FooPublic.html' '//pre' 'pub struct FooPublic'\n pub struct FooPublic;\n // @has 'foo/index.html' '//a[@href=\"struct.FooJustCrate.html\"]/..' 'FooJustCrate \ud83d\udd12'\n // @has 'foo/struct.FooJustCrate.html' '//pre' 'pub(crate) struct FooJustCrate'\n-crate struct FooJustCrate;\n+pub(crate) struct FooJustCrate;\n // @has 'foo/index.html' '//a[@href=\"struct.FooPubCrate.html\"]/..' 'FooPubCrate \ud83d\udd12'\n // @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n pub(crate) struct FooPubCrate;"}, {"sha": "871dde91a3e6b9267626eafd09e60409fdf367b9", "filename": "src/test/ui/lint/dead-code/issue-85255.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -2,7 +2,6 @@\n // check-pass\n \n #![warn(dead_code)]\n-#![feature(crate_visibility_modifier)]\n \n struct Foo {\n     a: i32, //~ WARNING: field is never read\n@@ -28,12 +27,12 @@ impl Bar1 {\n     pub fn b(&self) -> i32 { 6 } //~ WARNING: associated function is never used\n }\n \n-crate struct Foo2 {\n+pub(crate) struct Foo2 {\n     a: i32, //~ WARNING: field is never read\n     pub b: i32, //~ WARNING: field is never read\n }\n \n-crate struct Bar2;\n+pub(crate) struct Bar2;\n \n impl Bar2 {\n     fn a(&self) -> i32 { 5 } //~ WARNING: associated function is never used"}, {"sha": "5f786d5a2a847db0183851363b59feee5ea0a659", "filename": "src/test/ui/lint/dead-code/issue-85255.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,5 +1,5 @@\n warning: field is never read: `a`\n-  --> $DIR/issue-85255.rs:8:5\n+  --> $DIR/issue-85255.rs:7:5\n    |\n LL |     a: i32,\n    |     ^^^^^^\n@@ -11,67 +11,67 @@ LL | #![warn(dead_code)]\n    |         ^^^^^^^^^\n \n warning: field is never read: `b`\n-  --> $DIR/issue-85255.rs:9:5\n+  --> $DIR/issue-85255.rs:8:5\n    |\n LL |     pub b: i32,\n    |     ^^^^^^^^^^\n \n warning: associated function is never used: `a`\n-  --> $DIR/issue-85255.rs:15:8\n+  --> $DIR/issue-85255.rs:14:8\n    |\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n \n warning: associated function is never used: `b`\n-  --> $DIR/issue-85255.rs:16:12\n+  --> $DIR/issue-85255.rs:15:12\n    |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^\n \n warning: field is never read: `a`\n-  --> $DIR/issue-85255.rs:20:5\n+  --> $DIR/issue-85255.rs:19:5\n    |\n LL |     a: i32,\n    |     ^^^^^^\n \n warning: field is never read: `b`\n-  --> $DIR/issue-85255.rs:21:5\n+  --> $DIR/issue-85255.rs:20:5\n    |\n LL |     pub b: i32,\n    |     ^^^^^^^^^^\n \n warning: associated function is never used: `a`\n-  --> $DIR/issue-85255.rs:27:8\n+  --> $DIR/issue-85255.rs:26:8\n    |\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n \n warning: associated function is never used: `b`\n-  --> $DIR/issue-85255.rs:28:12\n+  --> $DIR/issue-85255.rs:27:12\n    |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^\n \n warning: field is never read: `a`\n-  --> $DIR/issue-85255.rs:32:5\n+  --> $DIR/issue-85255.rs:31:5\n    |\n LL |     a: i32,\n    |     ^^^^^^\n \n warning: field is never read: `b`\n-  --> $DIR/issue-85255.rs:33:5\n+  --> $DIR/issue-85255.rs:32:5\n    |\n LL |     pub b: i32,\n    |     ^^^^^^^^^^\n \n warning: associated function is never used: `a`\n-  --> $DIR/issue-85255.rs:39:8\n+  --> $DIR/issue-85255.rs:38:8\n    |\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n \n warning: associated function is never used: `b`\n-  --> $DIR/issue-85255.rs:40:12\n+  --> $DIR/issue-85255.rs:39:12\n    |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^"}, {"sha": "af2bd84bd53bedc9ff227eb6f666051e94c4136f", "filename": "src/test/ui/lint/unnecessary-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Funnecessary-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Funnecessary-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funnecessary-extern-crate.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n \n #![deny(unused_extern_crates)]\n-#![feature(test, rustc_private, crate_visibility_modifier)]\n+#![feature(test, rustc_private)]\n \n extern crate libc;\n //~^ ERROR unused extern crate\n@@ -21,7 +21,7 @@ pub extern crate alloc;\n \n pub(crate) extern crate alloc as a;\n \n-crate extern crate alloc as b;\n+pub(crate) extern crate alloc as b;\n \n mod foo {\n     pub(in crate::foo) extern crate alloc as c;"}, {"sha": "4dc951985ae4d14a398d223b9ade6a4eb71f9bfb", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,72 +0,0 @@\n-// This is just like unreachable_pub.rs, but without the\n-// `crate_visibility_modifier` feature (so that we can test the suggestions to\n-// use `pub(crate)` that are given when that feature is off, as opposed to the\n-// suggestions to use `crate` given when it is on). When that feature becomes\n-// stable, this test can be deleted.\n-\n-// check-pass\n-\n-\n-#![warn(unreachable_pub)]\n-\n-mod private_mod {\n-    // non-leaked `pub` items in private module should be linted\n-    pub use std::fmt; //~ WARNING unreachable_pub\n-    pub use std::env::{Args}; // braced-use has different item spans than unbraced\n-    //~^ WARNING unreachable_pub\n-\n-    pub struct Hydrogen { //~ WARNING unreachable_pub\n-        // `pub` struct fields, too\n-        pub neutrons: usize, //~ WARNING unreachable_pub\n-        // (... but not more-restricted fields)\n-        pub(crate) electrons: usize\n-    }\n-    impl Hydrogen {\n-        // impls, too\n-        pub fn count_neutrons(&self) -> usize { self.neutrons } //~ WARNING unreachable_pub\n-        pub(crate) fn count_electrons(&self) -> usize { self.electrons }\n-    }\n-    impl Clone for Hydrogen {\n-        fn clone(&self) -> Hydrogen {\n-            Hydrogen { neutrons: self.neutrons, electrons: self.electrons }\n-        }\n-    }\n-\n-    pub enum Helium {} //~ WARNING unreachable_pub\n-    pub union Lithium { c1: usize, c2: u8 } //~ WARNING unreachable_pub\n-    pub fn beryllium() {} //~ WARNING unreachable_pub\n-    pub trait Boron {} //~ WARNING unreachable_pub\n-    pub const CARBON: usize = 1; //~ WARNING unreachable_pub\n-    pub static NITROGEN: usize = 2; //~ WARNING unreachable_pub\n-    pub type Oxygen = bool; //~ WARNING unreachable_pub\n-\n-    macro_rules! define_empty_struct_with_visibility {\n-        ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-        //~^ WARNING unreachable_pub\n-    }\n-    define_empty_struct_with_visibility!(pub, Fluorine);\n-\n-    extern \"C\" {\n-        pub fn catalyze() -> bool; //~ WARNING unreachable_pub\n-    }\n-\n-    // items leaked through signatures (see `get_neon` below) are OK\n-    pub struct Neon {}\n-\n-    // crate-visible items are OK\n-    pub(crate) struct Sodium {}\n-}\n-\n-pub mod public_mod {\n-    // module is public: these are OK, too\n-    pub struct Magnesium {}\n-    pub(crate) struct Aluminum {}\n-}\n-\n-pub fn get_neon() -> private_mod::Neon {\n-    private_mod::Neon {}\n-}\n-\n-fn main() {\n-    let _ = get_neon();\n-}"}, {"sha": "6c05a030138bc04bdd72ba4b85eccc720a7d3e1f", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.stderr", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,148 +0,0 @@\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:14:5\n-   |\n-LL |     pub use std::fmt;\n-   |     ---^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/unreachable_pub-pub_crate.rs:10:9\n-   |\n-LL | #![warn(unreachable_pub)]\n-   |         ^^^^^^^^^^^^^^^\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:15:24\n-   |\n-LL |     pub use std::env::{Args}; // braced-use has different item spans than unbraced\n-   |     ---                ^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:18:5\n-   |\n-LL |     pub struct Hydrogen {\n-   |     ---^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` field\n-  --> $DIR/unreachable_pub-pub_crate.rs:20:9\n-   |\n-LL |         pub neutrons: usize,\n-   |         ---^^^^^^^^^^^^^^^^\n-   |         |\n-   |         help: consider restricting its visibility: `pub(crate)`\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:26:9\n-   |\n-LL |         pub fn count_neutrons(&self) -> usize { self.neutrons }\n-   |         ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         help: consider restricting its visibility: `pub(crate)`\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:35:5\n-   |\n-LL |     pub enum Helium {}\n-   |     ---^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:36:5\n-   |\n-LL |     pub union Lithium { c1: usize, c2: u8 }\n-   |     ---^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:37:5\n-   |\n-LL |     pub fn beryllium() {}\n-   |     ---^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:38:5\n-   |\n-LL |     pub trait Boron {}\n-   |     ---^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:39:5\n-   |\n-LL |     pub const CARBON: usize = 1;\n-   |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:40:5\n-   |\n-LL |     pub static NITROGEN: usize = 2;\n-   |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:41:5\n-   |\n-LL |     pub type Oxygen = bool;\n-   |     ---^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:44:47\n-   |\n-LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n-   |     ---------------------------------------------------\n-   |     |                                    |\n-   |     |                                    help: consider restricting its visibility: `pub(crate)`\n-   |     in this macro invocation\n-   |\n-   = help: or consider exporting it for use by other crates\n-   = note: this warning originates in the macro `define_empty_struct_with_visibility` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:50:9\n-   |\n-LL |         pub fn catalyze() -> bool;\n-   |         ---^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: 14 warnings emitted\n-"}, {"sha": "a50467ce82daf14e8367fd7bca5e501109087ebb", "filename": "src/test/ui/lint/unreachable_pub.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(crate_visibility_modifier)]\n-\n #![allow(unused)]\n #![warn(unreachable_pub)]\n \n@@ -15,12 +13,12 @@ mod private_mod {\n         // `pub` struct fields, too\n         pub neutrons: usize, //~ WARNING unreachable_pub\n         // (... but not more-restricted fields)\n-        crate electrons: usize\n+        pub(crate) electrons: usize\n     }\n     impl Hydrogen {\n         // impls, too\n         pub fn count_neutrons(&self) -> usize { self.neutrons } //~ WARNING unreachable_pub\n-        crate fn count_electrons(&self) -> usize { self.electrons }\n+        pub(crate) fn count_electrons(&self) -> usize { self.electrons }\n     }\n     impl Clone for Hydrogen {\n         fn clone(&self) -> Hydrogen {\n@@ -50,13 +48,13 @@ mod private_mod {\n     pub struct Neon {}\n \n     // crate-visible items are OK\n-    crate struct Sodium {}\n+    pub(crate) struct Sodium {}\n }\n \n pub mod public_mod {\n     // module is public: these are OK, too\n     pub struct Magnesium {}\n-    crate struct Aluminum {}\n+    pub(crate) struct Aluminum {}\n }\n \n pub fn get_neon() -> private_mod::Neon {"}, {"sha": "ce22eca1b8ce61e89eb795e6d9d17a7717bc22f1", "filename": "src/test/ui/lint/unreachable_pub.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,146 +1,146 @@\n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:10:5\n+  --> $DIR/unreachable_pub.rs:8:5\n    |\n LL |     pub use std::fmt;\n    |     ---^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n note: the lint level is defined here\n-  --> $DIR/unreachable_pub.rs:6:9\n+  --> $DIR/unreachable_pub.rs:4:9\n    |\n LL | #![warn(unreachable_pub)]\n    |         ^^^^^^^^^^^^^^^\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:11:24\n+  --> $DIR/unreachable_pub.rs:9:24\n    |\n LL |     pub use std::env::{Args}; // braced-use has different item spans than unbraced\n    |     ---                ^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:14:5\n+  --> $DIR/unreachable_pub.rs:12:5\n    |\n LL |     pub struct Hydrogen {\n    |     ---^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` field\n-  --> $DIR/unreachable_pub.rs:16:9\n+  --> $DIR/unreachable_pub.rs:14:9\n    |\n LL |         pub neutrons: usize,\n    |         ---^^^^^^^^^^^^^^^^\n    |         |\n-   |         help: consider restricting its visibility: `crate`\n+   |         help: consider restricting its visibility: `pub(crate)`\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:22:9\n+  --> $DIR/unreachable_pub.rs:20:9\n    |\n LL |         pub fn count_neutrons(&self) -> usize { self.neutrons }\n    |         ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         help: consider restricting its visibility: `crate`\n+   |         help: consider restricting its visibility: `pub(crate)`\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:31:5\n+  --> $DIR/unreachable_pub.rs:29:5\n    |\n LL |     pub enum Helium {}\n    |     ---^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:32:5\n+  --> $DIR/unreachable_pub.rs:30:5\n    |\n LL |     pub union Lithium { c1: usize, c2: u8 }\n    |     ---^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:33:5\n+  --> $DIR/unreachable_pub.rs:31:5\n    |\n LL |     pub fn beryllium() {}\n    |     ---^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:34:5\n+  --> $DIR/unreachable_pub.rs:32:5\n    |\n LL |     pub trait Boron {}\n    |     ---^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:35:5\n+  --> $DIR/unreachable_pub.rs:33:5\n    |\n LL |     pub const CARBON: usize = 1;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:36:5\n+  --> $DIR/unreachable_pub.rs:34:5\n    |\n LL |     pub static NITROGEN: usize = 2;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:37:5\n+  --> $DIR/unreachable_pub.rs:35:5\n    |\n LL |     pub type Oxygen = bool;\n    |     ---^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:40:47\n+  --> $DIR/unreachable_pub.rs:38:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n    |     ---------------------------------------------------\n    |     |                                    |\n-   |     |                                    help: consider restricting its visibility: `crate`\n+   |     |                                    help: consider restricting its visibility: `pub(crate)`\n    |     in this macro invocation\n    |\n    = help: or consider exporting it for use by other crates\n    = note: this warning originates in the macro `define_empty_struct_with_visibility` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:46:9\n+  --> $DIR/unreachable_pub.rs:44:9\n    |\n LL |         pub fn catalyze() -> bool;\n    |         ---^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         help: consider restricting its visibility: `crate`\n+   |         help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n "}, {"sha": "7b02a70be0942c2009bdf229025ec457c11dea0f", "filename": "src/test/ui/macros/macro-pub-matcher.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fmacros%2Fmacro-pub-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fmacros%2Fmacro-pub-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-pub-matcher.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n #![allow(dead_code, unused_imports, unused_macro_rules)]\n-#![feature(crate_visibility_modifier)]\n \n /**\n Ensure that `:vis` matches can be captured in existing positions, and passed\n@@ -56,15 +55,15 @@ mod with_pub_restricted {\n }\n \n mod with_crate {\n-    vis_passthru! { crate const A: i32 = 0; }\n-    vis_passthru! { crate enum B {} }\n-    vis_passthru! { crate extern \"C\" fn c() {} }\n-    vis_passthru! { crate mod d {} }\n-    vis_passthru! { crate static E: i32 = 0; }\n-    vis_passthru! { crate struct F; }\n-    vis_passthru! { crate trait G {} }\n-    vis_passthru! { crate type H = i32; }\n-    vis_passthru! { crate use A as I; }\n+    vis_passthru! { pub(crate) const A: i32 = 0; }\n+    vis_passthru! { pub(crate) enum B {} }\n+    vis_passthru! { pub(crate) extern \"C\" fn c() {} }\n+    vis_passthru! { pub(crate) mod d {} }\n+    vis_passthru! { pub(crate) static E: i32 = 0; }\n+    vis_passthru! { pub(crate) struct F; }\n+    vis_passthru! { pub(crate) trait G {} }\n+    vis_passthru! { pub(crate) type H = i32; }\n+    vis_passthru! { pub(crate) use A as I; }\n }\n \n mod garden {"}, {"sha": "6f115e78e147b38cf52de11c24bc98084f3838a5", "filename": "src/test/ui/privacy/issue-46209-private-enum-variant-reexport.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(crate_visibility_modifier)]\n-\n #[deny(unused_imports)]\n mod rank {\n     pub use self::Professor::*;\n@@ -31,7 +29,7 @@ mod rank {\n         MasterChief\n     }\n \n-    crate enum Crewman {\n+    pub(crate) enum Crewman {\n         Recruit,\n         Apprentice,\n         Full"}, {"sha": "59b181fab40012e0a4a6b99dca480529d92e09a2", "filename": "src/test/ui/privacy/issue-46209-private-enum-variant-reexport.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.stderr?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,47 +1,47 @@\n error[E0364]: `JuniorGrade` is private, and cannot be re-exported\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:32\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:32\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                ^^^^^^^^^^^\n    |\n note: consider marking `JuniorGrade` as `pub` in the imported module\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:32\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:32\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                ^^^^^^^^^^^\n \n error[E0364]: `Full` is private, and cannot be re-exported\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:45\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:45\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                             ^^^^\n    |\n note: consider marking `Full` as `pub` in the imported module\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:45\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:45\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                             ^^^^\n \n error: glob import doesn't reexport anything because no candidate is public enough\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:13\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:3:13\n    |\n LL |     pub use self::Professor::*;\n    |             ^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:3:8\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:1:8\n    |\n LL | #[deny(unused_imports)]\n    |        ^^^^^^^^^^^^^^\n \n error: glob import doesn't reexport anything because no candidate is public enough\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:10:13\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:8:13\n    |\n LL |     pub use self::PettyOfficer::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n error: glob import doesn't reexport anything because no candidate is public enough\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:12:13\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:10:13\n    |\n LL |     pub use self::Crewman::*;\n    |             ^^^^^^^^^^^^^^^^"}, {"sha": "a4013e6ac60b29cee26433f87c2236d08103bc40", "filename": "src/test/ui/privacy/restricted/auxiliary/pub_restricted.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fauxiliary%2Fpub_restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fauxiliary%2Fpub_restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fauxiliary%2Fpub_restricted.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,16 +1,14 @@\n-#![feature(crate_visibility_modifier)]\n-\n pub(crate) struct Crate;\n \n #[derive(Default)]\n pub struct Universe {\n     pub x: i32,\n     pub(crate) y: i32,\n-    crate z: i32,\n+    pub(crate) z: i32,\n }\n \n impl Universe {\n     pub fn f(&self) {}\n     pub(crate) fn g(&self) {}\n-    crate fn h(&self) {}\n+    pub(crate) fn h(&self) {}\n }"}, {"sha": "1e3dbdf73b96c93bed0428b9ec6c139ca3adaec6", "filename": "src/test/ui/privacy/restricted/private-in-public.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,12 +1,10 @@\n-#![feature(crate_visibility_modifier)]\n-\n mod foo {\n     struct Priv;\n     mod bar {\n         use foo::Priv;\n         pub(super) fn f(_: Priv) {}\n         pub(crate) fn g(_: Priv) {} //~ ERROR E0446\n-        crate fn h(_: Priv) {} //~ ERROR E0446\n+        pub(crate) fn h(_: Priv) {} //~ ERROR E0446\n     }\n }\n "}, {"sha": "ee9c031ebff231752494c1997c9c8127d82cbfa7", "filename": "src/test/ui/privacy/restricted/private-in-public.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,5 +1,5 @@\n error[E0446]: private type `Priv` in public interface\n-  --> $DIR/private-in-public.rs:8:9\n+  --> $DIR/private-in-public.rs:6:9\n    |\n LL |     struct Priv;\n    |     ------------ `Priv` declared as private\n@@ -8,13 +8,13 @@ LL |         pub(crate) fn g(_: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0446]: private type `Priv` in public interface\n-  --> $DIR/private-in-public.rs:9:9\n+  --> $DIR/private-in-public.rs:7:9\n    |\n LL |     struct Priv;\n    |     ------------ `Priv` declared as private\n ...\n-LL |         crate fn h(_: Priv) {}\n-   |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n+LL |         pub(crate) fn h(_: Priv) {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5a85aef2b175b4539bdb77b319b48ce75115be4e", "filename": "src/test/ui/privacy/restricted/test.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -29,7 +29,7 @@ LL |     use pub_restricted::Crate;\n    |                         ^^^^^ private struct\n    |\n note: the struct `Crate` is defined here\n-  --> $DIR/auxiliary/pub_restricted.rs:3:1\n+  --> $DIR/auxiliary/pub_restricted.rs:1:1\n    |\n LL | pub(crate) struct Crate;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -88,7 +88,7 @@ error[E0624]: associated function `g` is private\n LL |     u.g();\n    |       ^ private associated function\n    |\n-  ::: $DIR/auxiliary/pub_restricted.rs:14:5\n+  ::: $DIR/auxiliary/pub_restricted.rs:12:5\n    |\n LL |     pub(crate) fn g(&self) {}\n    |     ---------------------- private associated function defined here\n@@ -99,10 +99,10 @@ error[E0624]: associated function `h` is private\n LL |     u.h();\n    |       ^ private associated function\n    |\n-  ::: $DIR/auxiliary/pub_restricted.rs:15:5\n+  ::: $DIR/auxiliary/pub_restricted.rs:13:5\n    |\n-LL |     crate fn h(&self) {}\n-   |     ----------------- private associated function defined here\n+LL |     pub(crate) fn h(&self) {}\n+   |     ---------------------- private associated function defined here\n \n error: aborting due to 12 previous errors\n "}, {"sha": "7ebd259189d6d8f236546f0757c148d88c8a3345", "filename": "src/test/ui/resolve/crate-in-paths.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,9 +1,7 @@\n // edition:2018\n \n-#![feature(crate_visibility_modifier)]\n-\n mod bar {\n-    crate struct Foo;\n+    pub(crate) struct Foo;\n }\n \n fn main() {"}, {"sha": "b7cf4950759e36bb0454e605ca1cf4304ef03404", "filename": "src/test/ui/resolve/crate-in-paths.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.stderr?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find value `Foo` in this scope\n-  --> $DIR/crate-in-paths.rs:10:5\n+  --> $DIR/crate-in-paths.rs:8:5\n    |\n LL |     Foo;\n    |     ^^^ not found in this scope"}, {"sha": "85d106bc11f68aff502f36ed20e66719920667b1", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,14 +1,14 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n mod foo {\n-    crate trait Foo {\n+    pub(crate) trait Foo {\n         type Bar;\n     }\n \n-    crate struct Baz {}\n+    pub(crate) struct Baz {}\n \n     impl Foo for Baz {\n         type Bar = ();"}, {"sha": "9ff3c2e5fcff44f87b228d178cf7f9fcb016c0bf", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,14 +1,14 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n mod foo {\n-    crate trait Foo {\n+    pub(crate) trait Foo {\n         type Bar;\n     }\n \n-    crate struct Baz {}\n+    pub(crate) struct Baz {}\n \n     impl Foo for Baz {\n         type Bar = ();"}, {"sha": "f25d46ce30d0a2c16487d3e266d4f0d3537d760f", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.fixed", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,16 +1,16 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n #![allow(unused_imports)]\n #![allow(dead_code)]\n \n-crate mod foo {\n-    crate mod bar {\n-        crate mod baz { }\n-        crate mod baz1 { }\n+pub(crate) mod foo {\n+    pub(crate) mod bar {\n+        pub(crate) mod baz { }\n+        pub(crate) mod baz1 { }\n \n-        crate struct XX;\n+        pub(crate) struct XX;\n     }\n }\n "}, {"sha": "9be1680c1ce74594b2bb2285aff8e10cfc980f7c", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,16 +1,16 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n #![allow(unused_imports)]\n #![allow(dead_code)]\n \n-crate mod foo {\n-    crate mod bar {\n-        crate mod baz { }\n-        crate mod baz1 { }\n+pub(crate) mod foo {\n+    pub(crate) mod bar {\n+        pub(crate) mod baz { }\n+        pub(crate) mod baz1 { }\n \n-        crate struct XX;\n+        pub(crate) struct XX;\n     }\n }\n "}, {"sha": "a04937ae8ee3b38cf2dab74b7672c154f89e226a", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.fixed", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n use crate::foo::{a, b};\n@@ -10,9 +10,9 @@ use crate::foo::{a, b};\n //~| this is accepted in the current edition\n \n mod foo {\n-    crate fn a() {}\n-    crate fn b() {}\n-    crate fn c() {}\n+    pub(crate) fn a() {}\n+    pub(crate) fn b() {}\n+    pub(crate) fn c() {}\n }\n \n fn main() {"}, {"sha": "e622a8e24be633632d2cc62d446a6bbc6c72bdb9", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n use foo::{a, b};\n@@ -10,9 +10,9 @@ use foo::{a, b};\n //~| this is accepted in the current edition\n \n mod foo {\n-    crate fn a() {}\n-    crate fn b() {}\n-    crate fn c() {}\n+    pub(crate) fn a() {}\n+    pub(crate) fn b() {}\n+    pub(crate) fn c() {}\n }\n \n fn main() {"}, {"sha": "12a50c013a91f3ccca9dc88084191525b6a6dac8", "filename": "src/tools/rustfmt/tests/source/fn-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ffn-simple.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -63,7 +63,7 @@ mod foo {\n // #2082\n pub(crate) fn init() {}\n \n-crate fn init() {}\n+pub(crate) fn init() {}\n \n // #2630\n fn make_map<T, F: (Fn(&T) -> String)>(records: &Vec<T>, key_fn: F) -> HashMap<String, usize> {}"}, {"sha": "5683acbf3aa936dd622a536906c06a6faf9a9d39", "filename": "src/tools/rustfmt/tests/source/pub-restricted.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fpub-restricted.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -24,19 +24,6 @@ pub(  crate  ) enum WriteState<D> {\n     WriteData(Writer<D>),\n }\n \n-  crate   enum WriteState<D> {\n-    WriteId {\n-        id: U64Writer,\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteSize {\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteData(Writer<D>),\n-}\n-\n pub(in  ::global::  path :: to::some_mod  ) enum WriteState<D> {\n     WriteId {\n         id: U64Writer,"}, {"sha": "e725269360d2cf23b8c4fd6b162e72bf74be7c47", "filename": "src/tools/rustfmt/tests/target/fn-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ffn-simple.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -105,7 +105,7 @@ mod foo {\n // #2082\n pub(crate) fn init() {}\n \n-crate fn init() {}\n+pub(crate) fn init() {}\n \n // #2630\n fn make_map<T, F: (Fn(&T) -> String)>(records: &Vec<T>, key_fn: F) -> HashMap<String, usize> {}"}, {"sha": "0e178ef10136e3965f7185ef1998b329b5982da5", "filename": "src/tools/rustfmt/tests/target/pub-restricted.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69702468865d582f512df31a52ac2608afe5df0d/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fpub-restricted.rs?ref=69702468865d582f512df31a52ac2608afe5df0d", "patch": "@@ -24,19 +24,6 @@ pub(crate) enum WriteState<D> {\n     WriteData(Writer<D>),\n }\n \n-crate enum WriteState<D> {\n-    WriteId {\n-        id: U64Writer,\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteSize {\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteData(Writer<D>),\n-}\n-\n pub(in global::path::to::some_mod) enum WriteState<D> {\n     WriteId {\n         id: U64Writer,"}]}