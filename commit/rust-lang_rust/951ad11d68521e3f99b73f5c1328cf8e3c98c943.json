{"sha": "951ad11d68521e3f99b73f5c1328cf8e3c98c943", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MWFkMTFkNjg1MjFlM2Y5OWI3M2Y1YzEzMjhjZjhlM2M5OGM5NDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-07T06:57:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-07T06:57:08Z"}, "message": "auto merge of #4815 : thestinger/rust/treemap, r=pcwalton\n\n5283a8b reworks the TreeMap lazy iterator to use `&mut` again, which closes #4763. It gets the performance of the set methods back in the same ballpark that it was pre-INHTWAMA which is nice. These can be turned back into methods eventually.\r\n\r\ne5b6334 removes the transitional smallintmap attributes which closes #4737.", "tree": {"sha": "8cebceb0468765f5755932ee6656f7a4eda6b45d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cebceb0468765f5755932ee6656f7a4eda6b45d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/951ad11d68521e3f99b73f5c1328cf8e3c98c943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/951ad11d68521e3f99b73f5c1328cf8e3c98c943", "html_url": "https://github.com/rust-lang/rust/commit/951ad11d68521e3f99b73f5c1328cf8e3c98c943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/951ad11d68521e3f99b73f5c1328cf8e3c98c943/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8280c815137193d2069954a1dda60c118c6872d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8280c815137193d2069954a1dda60c118c6872d0", "html_url": "https://github.com/rust-lang/rust/commit/8280c815137193d2069954a1dda60c118c6872d0"}, {"sha": "dab2f2fac0d5147b088489abfbcf43714ed36156", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab2f2fac0d5147b088489abfbcf43714ed36156", "html_url": "https://github.com/rust-lang/rust/commit/dab2f2fac0d5147b088489abfbcf43714ed36156"}], "stats": {"total": 162, "additions": 72, "deletions": 90}, "files": [{"sha": "88981f514cff35ee823d987dd9f75b25d6fff502", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=951ad11d68521e3f99b73f5c1328cf8e3c98c943", "patch": "@@ -49,9 +49,8 @@ pub mod linear {\n         buckets: ~[Option<Bucket<K, V>>],\n     }\n \n-    // FIXME(#3148) -- we could rewrite FoundEntry\n-    // to have type Option<&Bucket<K, V>> which would be nifty\n-    // However, that won't work until #3148 is fixed\n+    // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n+    // which would be nifty\n     enum SearchResult {\n         FoundEntry(uint), FoundHole(uint), TableFull\n     }\n@@ -296,8 +295,6 @@ pub mod linear {\n                 FoundEntry(idx) => {\n                     match self.buckets[idx] {\n                         Some(ref bkt) => {\n-                            // FIXME(#3148)---should be inferred\n-                            let bkt: &self/Bucket<K, V> = bkt;\n                             Some(&bkt.value)\n                         }\n                         None => {"}, {"sha": "13b58c433006ef82fa066332a6700a59dc6a19d6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=951ad11d68521e3f99b73f5c1328cf8e3c98c943", "patch": "@@ -856,9 +856,6 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                // FIXME(#3148)---should be inferred\n-                let list: &self/~[Json] = list;\n-\n                 self.stack.push(&list[idx]);\n                 f()\n             }\n@@ -885,9 +882,6 @@ pub impl Decoder: serialize::Decoder {\n         let top = self.peek();\n         match *top {\n             Object(ref obj) => {\n-                // FIXME(#3148) This hint should not be necessary.\n-                let obj: &self/~Object = obj;\n-\n                 match obj.find(&name.to_owned()) {\n                     None => die!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n@@ -917,8 +911,6 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                // FIXME(#3148)---should be inferred\n-                let list: &self/~[Json] = list;\n                 self.stack.push(&list[idx]);\n                 f()\n             }"}, {"sha": "1cd35722ab466655d9a76b5147bdf89d9066553c", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=951ad11d68521e3f99b73f5c1328cf8e3c98c943", "patch": "@@ -116,8 +116,6 @@ pub impl<V> SmallIntMap<V> {\n }\n \n pub impl<V: Copy> SmallIntMap<V> {\n-    // FIXME: #4733, remove after the next snapshot\n-    #[cfg(stage2)]\n     fn update_with_key(&mut self, key: uint, val: V,\n                        ff: fn(uint, V, V) -> V) -> bool {\n         match self.find(&key) {\n@@ -126,8 +124,6 @@ pub impl<V: Copy> SmallIntMap<V> {\n         }\n     }\n \n-    // FIXME: #4733, remove after the next snapshot\n-    #[cfg(stage2)]\n     fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }"}, {"sha": "3cc287b16a32eab2d074e70a72e708916f06f1ce", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 70, "deletions": 73, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951ad11d68521e3f99b73f5c1328cf8e3c98c943/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=951ad11d68521e3f99b73f5c1328cf8e3c98c943", "patch": "@@ -49,8 +49,8 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    x = x.next();\n-                    y = y.next();\n+                    map_next(&mut x);\n+                    map_next(&mut y);\n                     // FIXME: #4492 (ICE), x.get() == y.get()\n                     let (x1, x2) = x.get().unwrap();\n                     let (y1, y2) = y.get().unwrap();\n@@ -74,8 +74,8 @@ pure fn lt<K: Ord, V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            map_next(&mut x);\n+            map_next(&mut y);\n             let (key_a,_) = x.get().unwrap();\n             let (key_b,_) = y.get().unwrap();\n             if *key_a < *key_b { return true; }\n@@ -142,7 +142,6 @@ impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n         loop {\n             match *current {\n               Some(ref r) => {\n-                let r: &self/~TreeNode<K, V> = r; // FIXME: #3148\n                 if *key < r.key {\n                     current = &r.left;\n                 } else if r.key < *key {\n@@ -211,32 +210,30 @@ impl <K: Ord, V> TreeMapIterator<K, V> {\n     // Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<(&self/K, &self/V)> {\n         match self.current {\n-            Some(res) => Some((&res.key, &res.value)),\n-            None => None\n+          Some(res) => Some((&res.key, &res.value)),\n+          None => None\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator\n-    /// is finished, does nothing.\n-    fn next(self) -> TreeMapIterator/&self<K, V> {\n-        let mut this = self;\n-        while !this.stack.is_empty() || this.node.is_some() {\n-            match *this.node {\n-              Some(ref x) => {\n-                this.stack.push(x);\n-                this.node = &x.left;\n-              }\n-              None => {\n-                let res = this.stack.pop();\n-                this.node = &res.right;\n-                this.current = Some(res);\n-                return this;\n-              }\n-            }\n+/// Advance the iterator to the next node (in order). If this iterator\n+/// is finished, does nothing.\n+pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+    while !iter.stack.is_empty() || iter.node.is_some() {\n+        match *iter.node {\n+          Some(ref x) => {\n+            iter.stack.push(x);\n+            iter.node = &x.left;\n+          }\n+          None => {\n+            let res = iter.stack.pop();\n+            iter.node = &res.right;\n+            iter.current = Some(res);\n+            return;\n+          }\n         }\n-        this.current = None;\n-        return this;\n     }\n+    iter.current = None;\n }\n \n pub struct TreeSet<T> {\n@@ -298,18 +295,18 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else if b1 < a1 {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     return false;\n@@ -329,8 +326,8 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while b.is_some() {\n@@ -346,10 +343,10 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n-                x = x.next();\n+                set_next(&mut x);\n                 a = x.get();\n             }\n         }\n@@ -362,15 +359,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -379,11 +376,11 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n-                    if !(b1 < a1) { x = x.next(); a = x.get() }\n-                    y = y.next();\n+                    if !(b1 < a1) { set_next(&mut x); a = x.get() }\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -397,15 +394,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -414,21 +411,21 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        x = x.next();\n+                        set_next(&mut x);\n                         a = x.get();\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { y = y.next(); y.get() } else { None }\n+                if f(b1) { set_next(&mut y); y.get() } else { None }\n             }\n         }\n     }\n@@ -439,22 +436,22 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -467,15 +464,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -484,15 +481,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        y = y.next();\n+                        set_next(&mut y);\n                         b = y.get()\n                     }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 }\n             }\n@@ -525,16 +522,16 @@ impl <T: Ord> TreeSetIterator<T> {\n     /// Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<&self/T> {\n         match self.iter.get() {\n-            None => None,\n-            Some((k, _)) => Some(k)\n+          None => None,\n+          Some((k, _)) => Some(k)\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator is\n-    /// finished, does nothing.\n-    fn next(self) -> TreeSetIterator/&self<T> {\n-        TreeSetIterator { iter: self.iter.next() }\n-    }\n+/// Advance the iterator to the next node (in order). If this iterator is\n+/// finished, does nothing.\n+pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&a<T>) {\n+    map_next(&mut iter.iter);\n }\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -746,8 +743,8 @@ mod test_treemap {\n         let v1 = str::to_bytes(~\"baz\");\n         let v2 = str::to_bytes(~\"foobar\");\n \n-        m.insert(k1, v1);\n-        m.insert(k2, v2);\n+        m.insert(copy k1, copy v1);\n+        m.insert(copy k2, copy v2);\n \n         assert m.find(&k2) == Some(&v2);\n         assert m.find(&k1) == Some(&v1);\n@@ -966,20 +963,20 @@ mod test_treemap {\n         let m = m;\n         let mut iter = m.iter();\n \n-        // FIXME: #4492 (ICE): iter.next() == Some((&x1, &y1))\n+        // FIXME: #4492 (ICE): iter.get() == Some((&x1, &y1))\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x1, &y1);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x2, &y2);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x3, &y3);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x4, &y4);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x5, &y5);\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().is_none();\n     }\n }"}]}