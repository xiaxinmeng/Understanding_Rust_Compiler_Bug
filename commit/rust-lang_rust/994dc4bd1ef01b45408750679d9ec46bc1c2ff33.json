{"sha": "994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NGRjNGJkMWVmMDFiNDU0MDg3NTA2NzlkOWVjNDZiYzFjMmZmMzM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-15T17:30:14Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-19T19:50:09Z"}, "message": "Classify outlives constraints when type checking\n\nThe MIR/NLL type checker is in a much better position to classify\nconstraints and already has to classify into boring and interesting.\nAdds spans to Locations::All for error reporting\nAdds more constraint categories", "tree": {"sha": "ce4dcc1465d2dd39a822cef8e1fac59457e3a6c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce4dcc1465d2dd39a822cef8e1fac59457e3a6c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "html_url": "https://github.com/rust-lang/rust/commit/994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e425219f1067096463b2e48c00ba7d7d2d8fdde", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e425219f1067096463b2e48c00ba7d7d2d8fdde", "html_url": "https://github.com/rust-lang/rust/commit/6e425219f1067096463b2e48c00ba7d7d2d8fdde"}], "stats": {"total": 681, "additions": 377, "deletions": 304}, "files": [{"sha": "c6f910c4ad7a4b638a896d5bbdfc55b533bf51e5", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+    pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,"}, {"sha": "2e018f746f38937f697ed7cc856f6fb8780f8020", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n use borrow_check::nll::type_check::Locations;\n-use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{ConstraintCategory, ConstraintIndex};\n+use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use syntax_pos::DUMMY_SP;\n \n /// The construct graph organizes the constraints by their end-points.\n /// It can be used to view a `R1: R2` constraint as either an edge `R1\n@@ -174,7 +176,8 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n             Some(OutlivesConstraint {\n                 sup: self.static_region,\n                 sub: next_static_idx.into(),\n-                locations: Locations::All,\n+                locations: Locations::All(DUMMY_SP),\n+                category: ConstraintCategory::Internal,\n             })\n         } else {\n             None"}, {"sha": "76ebc06bfd2f612617bfc144948a1f4ce6472f10", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -23,6 +23,42 @@ crate struct ConstraintSet {\n     constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n }\n \n+/// Constraints can be categorized to determine whether and why they are\n+/// interesting. Order of variants indicates sort order of the category,\n+/// thereby influencing diagnostic output.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+pub enum ConstraintCategory {\n+    Return,\n+    TypeAnnotation,\n+    Cast,\n+    CallArgument,\n+\n+    /// A constraint that came from checking the body of a closure.\n+    ///\n+    /// Ideally we would give an explanation that points to the relevant part\n+    /// of the closure's body.\n+    ClosureBounds,\n+    CopyBound,\n+    SizedBound,\n+    Assignment,\n+    OpaqueType,\n+\n+    /// A \"boring\" constraint (caused by the given location) is one that\n+    /// the user probably doesn't want to see described in diagnostics,\n+    /// because it is kind of an artifact of the type system setup.\n+    /// Example: `x = Foo { field: y }` technically creates\n+    /// intermediate regions representing the \"type of `Foo { field: y\n+    /// }`\", and data flows from `y` into those variables, but they\n+    /// are not very interesting. The assignment into `x` on the other\n+    /// hand might be.\n+    Boring,\n+    // Boring and applicable everywhere.\n+    BoringNoLocation,\n+\n+    /// A constraint that doesn't correspond to anything the user sees.\n+    Internal,\n+}\n+\n impl ConstraintSet {\n     crate fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n@@ -87,6 +123,9 @@ pub struct OutlivesConstraint {\n \n     /// Where did this constraint arise?\n     pub locations: Locations,\n+\n+    /// What caused this constraint?\n+    pub category: ConstraintCategory,\n }\n \n impl fmt::Debug for OutlivesConstraint {"}, {"sha": "ee900afc44de8872548a0afe32330b702d544752", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -88,11 +88,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 sup,\n                 sub,\n                 locations,\n+                category,\n             } = constraint;\n             with_msg(&format!(\n-                \"{:?}: {:?} due to {:?}\",\n+                \"{:?}: {:?} due to {:?} at {:?}\",\n                 sup,\n                 sub,\n+                category,\n                 locations,\n             ))?;\n         }"}, {"sha": "1abc105ac2890370298fa12ddbdde0f637f5125a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 129, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::constraints::{OutlivesConstraint, ConstraintCategory};\n use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n-use rustc::ty::{self, TyCtxt, RegionVid};\n+use rustc::mir::{Location, Mir};\n+use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use std::collections::VecDeque;\n@@ -28,19 +27,6 @@ mod var_name;\n \n use self::region_name::RegionName;\n \n-/// Constraints that are considered interesting can be categorized to\n-/// determine why they are interesting. Order of variants indicates\n-/// sort order of the category, thereby influencing diagnostic output.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n-enum ConstraintCategory {\n-    Cast,\n-    Assignment,\n-    Return,\n-    CallArgument,\n-    Other,\n-    Boring,\n-}\n-\n impl fmt::Display for ConstraintCategory {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Must end with a space. Allows for empty names to be provided.\n@@ -49,7 +35,14 @@ impl fmt::Display for ConstraintCategory {\n             ConstraintCategory::Return => write!(f, \"returning this value \"),\n             ConstraintCategory::Cast => write!(f, \"cast \"),\n             ConstraintCategory::CallArgument => write!(f, \"argument \"),\n-            _ => write!(f, \"\"),\n+            ConstraintCategory::TypeAnnotation => write!(f, \"type annotation \"),\n+            ConstraintCategory::ClosureBounds => write!(f, \"closure body \"),\n+            ConstraintCategory::SizedBound => write!(f, \"proving this value is `Sized` \"),\n+            ConstraintCategory::CopyBound => write!(f, \"copying this value \"),\n+            ConstraintCategory::OpaqueType => write!(f, \"opaque type \"),\n+            ConstraintCategory::Boring\n+            | ConstraintCategory::BoringNoLocation\n+            | ConstraintCategory::Internal => write!(f, \"\"),\n         }\n     }\n }\n@@ -71,7 +64,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn best_blame_constraint(\n         &self,\n         mir: &Mir<'tcx>,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, Span, RegionVid) {\n@@ -96,7 +88,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<(ConstraintCategory, Span)> = path\n             .iter()\n-            .map(|&index| self.classify_constraint(index, mir, tcx))\n+            .map(|constraint| (constraint.category, constraint.locations.span(mir)))\n             .collect();\n         debug!(\n             \"best_blame_constraint: categorized_path={:#?}\",\n@@ -129,12 +121,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n             match categorized_path[i].0 {\n-                ConstraintCategory::Boring => false,\n-                ConstraintCategory::Other => {\n-                    // other isn't interesting when the two lifetimes\n-                    // are unified.\n-                    constraint_sup_scc != self.constraint_sccs.scc(constraint.sub)\n-                }\n+                ConstraintCategory::OpaqueType\n+                | ConstraintCategory::Boring\n+                | ConstraintCategory::BoringNoLocation\n+                | ConstraintCategory::Internal => false,\n                 _ => constraint_sup_scc != target_scc,\n             }\n         });\n@@ -220,106 +210,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         None\n     }\n \n-    /// This function will return true if a constraint is interesting and false if a constraint\n-    /// is not. It is useful in filtering constraint paths to only interesting points.\n-    fn constraint_is_interesting(&self, constraint: OutlivesConstraint) -> bool {\n-        debug!(\n-            \"constraint_is_interesting: locations={:?} constraint={:?}\",\n-            constraint.locations, constraint\n-        );\n-\n-        match constraint.locations {\n-            Locations::Interesting(_) | Locations::All => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// This function classifies a constraint from a location.\n-    fn classify_constraint(\n-        &self,\n-        constraint: OutlivesConstraint,\n-        mir: &Mir<'tcx>,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-    ) -> (ConstraintCategory, Span) {\n-        debug!(\"classify_constraint: constraint={:?}\", constraint);\n-        let span = constraint.locations.span(mir);\n-        let location = constraint\n-            .locations\n-            .from_location()\n-            .unwrap_or(Location::START);\n-\n-        if !self.constraint_is_interesting(constraint) {\n-            return (ConstraintCategory::Boring, span);\n-        }\n-\n-        let data = &mir[location.block];\n-        debug!(\n-            \"classify_constraint: location={:?} data={:?}\",\n-            location, data\n-        );\n-        let category = if location.statement_index == data.statements.len() {\n-            if let Some(ref terminator) = data.terminator {\n-                debug!(\"classify_constraint: terminator.kind={:?}\", terminator.kind);\n-                match terminator.kind {\n-                    TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n-                    // Classify calls differently depending on whether or not\n-                    // the sub region appears in the destination type (so the\n-                    // sup region is in the return type). If the return type\n-                    // contains the sub-region, then this is either an\n-                    // assignment or a return, depending on whether we are\n-                    // writing to the RETURN_PLACE or not.\n-                    //\n-                    // The idea here is that the region is being propagated\n-                    // from an input into the output place, so it's a kind of\n-                    // assignment. Otherwise, if the sub-region only appears in\n-                    // the argument types, then use the CallArgument\n-                    // classification.\n-                    TerminatorKind::Call { destination: Some((ref place, _)), .. } => {\n-                        if tcx.any_free_region_meets(\n-                            &place.ty(mir, tcx).to_ty(tcx),\n-                            |region| self.to_region_vid(region) == constraint.sub,\n-                        ) {\n-                            match place {\n-                                Place::Local(mir::RETURN_PLACE) => ConstraintCategory::Return,\n-                                _ => ConstraintCategory::Assignment,\n-                            }\n-                        } else {\n-                            ConstraintCategory::CallArgument\n-                        }\n-                    }\n-                    TerminatorKind::Call { destination: None, .. } => {\n-                        ConstraintCategory::CallArgument\n-                    }\n-                    _ => ConstraintCategory::Other,\n-                }\n-            } else {\n-                ConstraintCategory::Other\n-            }\n-        } else {\n-            let statement = &data.statements[location.statement_index];\n-            debug!(\"classify_constraint: statement.kind={:?}\", statement.kind);\n-            match statement.kind {\n-                StatementKind::Assign(ref place, ref rvalue) => {\n-                    debug!(\"classify_constraint: place={:?} rvalue={:?}\", place, rvalue);\n-                    if *place == Place::Local(mir::RETURN_PLACE) {\n-                        ConstraintCategory::Return\n-                    } else {\n-                        match rvalue {\n-                            Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                            Rvalue::Use(..) | Rvalue::Aggregate(..) => {\n-                                ConstraintCategory::Assignment\n-                            }\n-                            _ => ConstraintCategory::Other,\n-                        }\n-                    }\n-                }\n-                _ => ConstraintCategory::Other,\n-            }\n-        };\n-\n-        (category, span)\n-    }\n-\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -341,7 +231,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let (category, span, _) = self.best_blame_constraint(\n             mir,\n-            infcx.tcx,\n             fr,\n             |r| r == outlived_fr\n         );\n@@ -574,11 +463,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn find_outlives_blame_span(\n         &self,\n         mir: &Mir<'tcx>,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> Span {\n-        let (_, span, _) = self.best_blame_constraint(mir, tcx, fr1, |r| r == fr2);\n+        let (_, span, _) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n         span\n     }\n }"}, {"sha": "75f14a6bbdac8f87b2de738ff0881d783e08c541", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -1062,7 +1062,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr, shorter_fr,\n             );\n \n-            let blame_span = self.find_outlives_blame_span(mir, infcx.tcx, longer_fr, shorter_fr);\n+            let blame_span = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -1147,7 +1147,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let span = self.find_outlives_blame_span(mir, infcx.tcx, longer_fr, error_region);\n+        let span = self.find_outlives_blame_span(mir, longer_fr, error_region);\n \n         // Obviously, this error message is far from satisfactory.\n         // At present, though, it only appears in unit tests --"}, {"sha": "430c8d673921b57cde4e0b2fe153d3254427ba91", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n use borrow_check::nll::type_check::Locations;\n@@ -30,6 +30,7 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     outlives_constraints: &'a mut ConstraintSet,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n     all_facts: &'a mut Option<AllFacts>,\n@@ -44,6 +45,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n+        category: ConstraintCategory,\n         outlives_constraints: &'a mut ConstraintSet,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n         all_facts: &'a mut Option<AllFacts>,\n@@ -56,6 +58,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             implicit_region_bound,\n             param_env,\n             locations,\n+            category,\n             outlives_constraints,\n             type_tests,\n             all_facts,\n@@ -183,6 +186,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n         self.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n+            category: self.category,\n             sub,\n             sup,\n         });"}, {"sha": "61c612b3c01186a263a252d3de7cd76f5d56ba26", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -14,6 +14,7 @@ use borrow_check::nll::type_check::constraint_conversion;\n use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::constraints::ConstraintCategory;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n@@ -23,6 +24,7 @@ use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use std::rc::Rc;\n+use syntax_pos::DUMMY_SP;\n \n #[derive(Debug)]\n crate struct UniversalRegionRelations<'tcx> {\n@@ -283,7 +285,8 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n                 &self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n-                Locations::All,\n+                Locations::All(DUMMY_SP),\n+                ConstraintCategory::Internal,\n                 &mut self.constraints.outlives_constraints,\n                 &mut self.constraints.type_tests,\n                 &mut self.all_facts,"}, {"sha": "6c7e2e9b72e302165969b287cea4ad404605f203", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -29,8 +29,9 @@ use rustc::ty::subst::Subst;\n use rustc::ty::Ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n+use syntax_pos::Span;\n \n-use super::{Locations, TypeChecker};\n+use super::{ConstraintCategory, Locations, TypeChecker};\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n@@ -56,7 +57,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             );\n \n             let mir_input_ty = mir.local_decls[local].ty;\n-            self.equate_normalized_input_or_output(normalized_input_ty, mir_input_ty);\n+            let mir_input_span = mir.local_decls[local].source_info.span;\n+            self.equate_normalized_input_or_output(\n+                normalized_input_ty,\n+                mir_input_ty,\n+                mir_input_span,\n+            );\n         }\n \n         assert!(\n@@ -65,16 +71,19 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n-            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty);\n+            let yield_span = mir.local_decls[RETURN_PLACE].source_info.span;\n+            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty, yield_span);\n         }\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n         let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n+        let output_span = mir.local_decls[RETURN_PLACE].source_info.span;\n         let opaque_type_map =\n             self.fully_perform_op(\n-                Locations::All,\n+                Locations::All(output_span),\n+                ConstraintCategory::BoringNoLocation,\n                 CustomTypeOp::new(\n                     |infcx| {\n                         let mut obligations = ObligationAccumulator::default();\n@@ -152,26 +161,38 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(opaque_type_map) = opaque_type_map {\n-            self.fully_perform_op(\n-                Locations::All,\n-                CustomTypeOp::new(\n-                    |_cx| {\n-                        infcx.constrain_opaque_types(&opaque_type_map, universal_region_relations);\n-                        Ok(InferOk {\n-                            value: (),\n-                            obligations: vec![],\n-                        })\n-                    },\n-                    || \"opaque_type_map\".to_string(),\n-                ),\n-            ).unwrap();\n+            for (opaque_def_id, opaque_decl) in opaque_type_map {\n+                self.fully_perform_op(\n+                    Locations::All(infcx.tcx.def_span(opaque_def_id)),\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |_cx| {\n+                            infcx.constrain_opaque_type(\n+                                opaque_def_id,\n+                                &opaque_decl,\n+                                universal_region_relations\n+                            );\n+                            Ok(InferOk {\n+                                value: (),\n+                                obligations: vec![],\n+                            })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                ).unwrap();\n+            }\n         }\n     }\n \n-    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, span: Span) {\n         debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n \n-        if let Err(terr) = self.eq_types(a, b, Locations::All) {\n+        if let Err(terr) = self.eq_types(\n+            a,\n+            b,\n+            Locations::All(span),\n+            ConstraintCategory::BoringNoLocation,\n+        ) {\n             span_mirbug!(\n                 self,\n                 Location::START,"}, {"sha": "e706c1adaddfbb00a9b51e0c280718f44f0a0420", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::constraints::ConstraintCategory;\n use borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n use borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n use borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n-use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::type_check::NormalizeLocation;\n use borrow_check::nll::type_check::TypeChecker;\n use dataflow::move_paths::indexes::MovePathIndex;\n use dataflow::move_paths::MoveData;\n@@ -487,7 +488,11 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         if let Some(data) = &drop_data.region_constraint_data {\n             for &drop_location in drop_locations {\n                 self.typeck\n-                    .push_region_constraints(drop_location.boring(), data);\n+                    .push_region_constraints(\n+                        drop_location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                        data,\n+                    );\n             }\n         }\n "}, {"sha": "c58518011aaf1eb9f56ccf96623b147aac315e9e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 242, "deletions": 145, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -13,7 +13,7 @@\n \n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n@@ -252,7 +252,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 constant.ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n-                location.boring(),\n+                location.to_locations(),\n+                ConstraintCategory::Boring,\n             ) {\n                 span_mirbug!(\n                     self,\n@@ -281,7 +282,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 local_decl.ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n-                Locations::All,\n+                Locations::All(local_decl.source_info.span),\n+                ConstraintCategory::TypeAnnotation,\n             ) {\n                 span_mirbug!(\n                     self,\n@@ -364,14 +366,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n             type_checker.normalize_and_prove_instantiated_predicates(\n                 instantiated_predicates,\n-                location.boring(),\n+                location.to_locations(),\n             );\n         }\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n         if let Err(terr) = self.cx\n-            .eq_types(constant.literal.ty, constant.ty, location.boring())\n+            .eq_types(\n+                constant.literal.ty,\n+                constant.ty,\n+                location.to_locations(),\n+                ConstraintCategory::Boring,\n+            )\n         {\n             span_mirbug!(\n                 self,\n@@ -417,7 +424,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(ty, sty, location.boring()) {\n+                if let Err(terr) = self.cx.eq_types(\n+                    ty,\n+                    sty,\n+                    location.to_locations(),\n+                    ConstraintCategory::Boring,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -461,7 +473,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             // (e.g., #29149). Note that we decide to use Copy before knowing whether the bounds\n             // fully apply: in effect, the rule is that if a value of some type could implement\n             // Copy, then it must.\n-            self.cx.prove_trait_ref(trait_ref, location.interesting());\n+            self.cx.prove_trait_ref(\n+                trait_ref,\n+                location.to_locations(),\n+                ConstraintCategory::CopyBound,\n+            );\n         }\n         place_ty\n     }\n@@ -560,7 +576,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n                 match self.field_ty(place, base, field, location) {\n-                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.boring()) {\n+                    Ok(ty) => if let Err(terr) = self.cx.eq_types(\n+                        ty,\n+                        fty,\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                    ) {\n                         span_mirbug!(\n                             self,\n                             place,\n@@ -740,43 +761,32 @@ pub enum Locations {\n     /// user-given type annotations; e.g., if the user wrote `let mut\n     /// x: &'static u32 = ...`, we would ensure that all values\n     /// assigned to `x` are of `'static` lifetime.\n-    All,\n-\n-    /// A \"boring\" constraint (caused by the given location) is one that\n-    /// the user probably doesn't want to see described in diagnostics,\n-    /// because it is kind of an artifact of the type system setup.\n     ///\n-    /// Example: `x = Foo { field: y }` technically creates\n-    /// intermediate regions representing the \"type of `Foo { field: y\n-    /// }`\", and data flows from `y` into those variables, but they\n-    /// are not very interesting. The assignment into `x` on the other\n-    /// hand might be.\n-    Boring(Location),\n-\n-    /// An *important* outlives constraint (caused by the given\n-    /// location) is one that would be useful to highlight in\n-    /// diagnostics, because it represents a point where references\n-    /// flow from one spot to another (e.g., `x = y`)\n-    Interesting(Location),\n+    /// The span points to the place the constraint arose. For example,\n+    /// it points to the type in a user-given type annotation. If\n+    /// there's no sensible span then it's DUMMY_SP.\n+    All(Span),\n+\n+    /// An outlives constraint that only has to hold at a single location,\n+    /// usually it represents a point where references flow from one spot to\n+    /// another (e.g., `x = y`)\n+    Single(Location),\n }\n \n impl Locations {\n     pub fn from_location(&self) -> Option<Location> {\n         match self {\n-            Locations::All => None,\n-            Locations::Boring(from_location) | Locations::Interesting(from_location) => {\n-                Some(*from_location)\n-            }\n+            Locations::All(_) => None,\n+            Locations::Single(from_location) => Some(*from_location),\n         }\n     }\n \n     /// Gets a span representing the location.\n     pub fn span(&self, mir: &Mir<'_>) -> Span {\n-        let span_location = match self {\n-            Locations::All => Location::START,\n-            Locations::Boring(l) | Locations::Interesting(l) => *l,\n-        };\n-        mir.source_info(span_location).span\n+        match self {\n+            Locations::All(span) => *span,\n+            Locations::Single(l) => mir.source_info(*l).span,\n+        }\n     }\n }\n \n@@ -816,12 +826,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn fully_perform_op<R>(\n         &mut self,\n         locations: Locations,\n+        category: ConstraintCategory,\n         op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Fallible<R> {\n         let (r, opt_data) = op.fully_perform(self.infcx)?;\n \n         if let Some(data) = &opt_data {\n-            self.push_region_constraints(locations, data);\n+            self.push_region_constraints(locations, category, data);\n         }\n \n         Ok(r)\n@@ -830,6 +841,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n+        category: ConstraintCategory,\n         data: &[QueryRegionConstraint<'tcx>],\n     ) {\n         debug!(\n@@ -846,29 +858,44 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.implicit_region_bound,\n                 self.param_env,\n                 locations,\n+                category,\n                 &mut borrowck_context.constraints.outlives_constraints,\n                 &mut borrowck_context.constraints.type_tests,\n                 &mut borrowck_context.all_facts,\n             ).convert_all(&data);\n         }\n     }\n \n-    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n         relate_tys::sub_types(\n             self.infcx,\n             sub,\n             sup,\n             locations,\n+            category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n \n-    fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n+    fn eq_types(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n         relate_tys::eq_types(\n             self.infcx,\n             a,\n             b,\n             locations,\n+            category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n@@ -879,13 +906,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         v: ty::Variance,\n         b: CanonicalTy<'tcx>,\n         locations: Locations,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         relate_tys::relate_type_and_user_type(\n             self.infcx,\n             a,\n             v,\n             b,\n             locations,\n+            category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n@@ -903,21 +932,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n-                let is_temp = if let Place::Local(l) = *place {\n-                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n-                } else {\n-                    false\n-                };\n-\n-                let locations = if is_temp {\n-                    location.boring()\n-                } else {\n-                    location.interesting()\n+                let category = match *place {\n+                    Place::Local(RETURN_PLACE) => ConstraintCategory::Return,\n+                    Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n+                        ConstraintCategory::Boring\n+                    }\n+                    _ => ConstraintCategory::Assignment,\n                 };\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n+                if let Err(terr) = self.sub_types(\n+                    rv_ty,\n+                    place_ty,\n+                    location.to_locations(),\n+                    category,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -933,7 +963,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         rv_ty,\n                         ty::Variance::Invariant,\n                         user_ty,\n-                        location.boring(),\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n                     ) {\n                         span_mirbug!(\n                             self,\n@@ -952,7 +983,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         def_id: tcx.lang_items().sized_trait().unwrap(),\n                         substs: tcx.mk_substs_trait(place_ty, &[]),\n                     };\n-                    self.prove_trait_ref(trait_ref, location.interesting());\n+                    self.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                    ConstraintCategory::SizedBound,\n+                    );\n                 }\n             }\n             StatementKind::SetDiscriminant {\n@@ -983,7 +1018,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) =\n-                    self.relate_type_and_user_type(place_ty, variance, c_ty, Locations::All)\n+                    self.relate_type_and_user_type(\n+                        place_ty,\n+                        variance,\n+                        c_ty,\n+                        Locations::All(stmt.source_info.span),\n+                        ConstraintCategory::TypeAnnotation,\n+                    )\n                 {\n                     span_mirbug!(\n                         self,\n@@ -1035,8 +1076,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = term_location.interesting();\n-                if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n+                let locations = term_location.to_locations();\n+                if let Err(terr) = self.sub_types(\n+                    rv_ty,\n+                    place_ty,\n+                    locations,\n+                    ConstraintCategory::Assignment,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1053,7 +1099,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.boring()) {\n+                if let Err(terr) = self.sub_types(\n+                    discr_ty,\n+                    switch_ty,\n+                    term_location.to_locations(),\n+                    ConstraintCategory::Assignment,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1093,7 +1144,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 self.prove_predicates(\n                     sig.inputs().iter().map(|ty| ty::Predicate::WellFormed(ty)),\n-                    term_location.boring(),\n+                    term_location.to_locations(),\n+                    ConstraintCategory::Boring,\n                 );\n \n                 // The ordinary liveness rules will ensure that all\n@@ -1139,7 +1191,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.interesting())\n+                        if let Err(terr) = self.sub_types(\n+                            value_ty,\n+                            ty,\n+                            term_location.to_locations(),\n+                            ConstraintCategory::Return,\n+                        )\n                         {\n                             span_mirbug!(\n                                 self,\n@@ -1168,19 +1225,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let is_temp = if let Place::Local(l) = *dest {\n-                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n-                } else {\n-                    false\n+                let category = match *dest {\n+                    Place::Local(RETURN_PLACE) => ConstraintCategory::Return,\n+                    Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n+                        ConstraintCategory::Boring\n+                    }\n+                    _ => ConstraintCategory::Assignment,\n                 };\n \n-                let locations = if is_temp {\n-                    term_location.boring()\n-                } else {\n-                    term_location.interesting()\n-                };\n+                let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types(sig.output(), dest_ty, locations) {\n+                if let Err(terr) = self.sub_types(\n+                    sig.output(),\n+                    dest_ty,\n+                    locations,\n+                    category,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1221,7 +1281,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.interesting()) {\n+            if let Err(terr) = self.sub_types(\n+                op_arg_ty,\n+                fn_arg,\n+                term_location.to_locations(),\n+                ConstraintCategory::CallArgument,\n+            ) {\n                 span_mirbug!(\n                     self,\n                     term,\n@@ -1470,7 +1535,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(operand_ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location.interesting());\n+                self.prove_trait_ref(\n+                    trait_ref,\n+                    location.to_locations(),\n+                    ConstraintCategory::CopyBound,\n+                );\n             },\n \n             Rvalue::NullaryOp(_, ty) => {\n@@ -1485,91 +1554,116 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location.interesting());\n+                self.prove_trait_ref(\n+                    trait_ref,\n+                    location.to_locations(),\n+                    ConstraintCategory::SizedBound,\n+                );\n             }\n \n-            Rvalue::Cast(cast_kind, op, ty) => match cast_kind {\n-                CastKind::ReifyFnPointer => {\n-                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+            Rvalue::Cast(cast_kind, op, ty) => {\n+                match cast_kind {\n+                    CastKind::ReifyFnPointer => {\n+                        let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n \n-                    // The type that we see in the fcx is like\n-                    // `foo::<'a, 'b>`, where `foo` is the path to a\n-                    // function definition. When we extract the\n-                    // signature, it comes from the `fn_sig` query,\n-                    // and hence may contain unnormalized results.\n-                    let fn_sig = self.normalize(fn_sig, location);\n+                        // The type that we see in the fcx is like\n+                        // `foo::<'a, 'b>`, where `foo` is the path to a\n+                        // function definition. When we extract the\n+                        // signature, it comes from the `fn_sig` query,\n+                        // and hence may contain unnormalized results.\n+                        let fn_sig = self.normalize(fn_sig, location);\n \n-                    let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n+                        let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n-                        span_mirbug!(\n+                        if let Err(terr) = self.eq_types(\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n                             self,\n                             rvalue,\n                             \"equating {:?} with {:?} yields {:?}\",\n                             ty_fn_ptr_from,\n                             ty,\n                             terr\n                         );\n+                        }\n                     }\n-                }\n \n-                CastKind::ClosureFnPointer => {\n-                    let sig = match op.ty(mir, tcx).sty {\n-                        ty::Closure(def_id, substs) => {\n-                            substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n-                        }\n-                        _ => bug!(),\n-                    };\n-                    let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n+                    CastKind::ClosureFnPointer => {\n+                        let sig = match op.ty(mir, tcx).sty {\n+                            ty::Closure(def_id, substs) => {\n+                                substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n+                            }\n+                            _ => bug!(),\n+                        };\n+                        let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n-                        span_mirbug!(\n+                        if let Err(terr) = self.eq_types(\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n                             self,\n                             rvalue,\n                             \"equating {:?} with {:?} yields {:?}\",\n                             ty_fn_ptr_from,\n                             ty,\n                             terr\n                         );\n+                        }\n                     }\n-                }\n \n-                CastKind::UnsafeFnPointer => {\n-                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+                    CastKind::UnsafeFnPointer => {\n+                        let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n \n-                    // The type that we see in the fcx is like\n-                    // `foo::<'a, 'b>`, where `foo` is the path to a\n-                    // function definition. When we extract the\n-                    // signature, it comes from the `fn_sig` query,\n-                    // and hence may contain unnormalized results.\n-                    let fn_sig = self.normalize(fn_sig, location);\n+                        // The type that we see in the fcx is like\n+                        // `foo::<'a, 'b>`, where `foo` is the path to a\n+                        // function definition. When we extract the\n+                        // signature, it comes from the `fn_sig` query,\n+                        // and hence may contain unnormalized results.\n+                        let fn_sig = self.normalize(fn_sig, location);\n \n-                    let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n+                        let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n-                        span_mirbug!(\n+                        if let Err(terr) = self.eq_types(\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n                             self,\n                             rvalue,\n                             \"equating {:?} with {:?} yields {:?}\",\n                             ty_fn_ptr_from,\n                             ty,\n                             terr\n                         );\n+                        }\n                     }\n-                }\n \n-                CastKind::Unsize => {\n-                    let &ty = ty;\n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                        substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n-                    };\n+                    CastKind::Unsize => {\n+                        let &ty = ty;\n+                        let trait_ref = ty::TraitRef {\n+                            def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+                            substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n+                        };\n \n-                    self.prove_trait_ref(trait_ref, location.interesting());\n-                }\n+                        self.prove_trait_ref(\n+                            trait_ref,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        );\n+                    }\n \n-                CastKind::Misc => {}\n-            },\n+                    CastKind::Misc => {}\n+                }\n+            }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n                 self.add_reborrow_constraint(location, region, borrowed_place);\n@@ -1644,7 +1738,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             };\n             let operand_ty = operand.ty(mir, tcx);\n \n-            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.boring()) {\n+            if let Err(terr) = self.sub_types(\n+                operand_ty,\n+                field_ty,\n+                location.to_locations(),\n+                ConstraintCategory::Boring,\n+            ) {\n                 span_mirbug!(\n                     self,\n                     rvalue,\n@@ -1723,7 +1822,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n-                                locations: location.boring(),\n+                                locations: location.to_locations(),\n+                                category: ConstraintCategory::Boring,\n                             });\n \n                             if let Some(all_facts) = all_facts {\n@@ -1839,8 +1939,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         *substs,\n                     );\n \n-                    // Hmm, are these constraints *really* boring?\n-                    self.push_region_constraints(location.boring(), &closure_constraints);\n+                    self.push_region_constraints(\n+                        location.to_locations(),\n+                        ConstraintCategory::ClosureBounds,\n+                        &closure_constraints,\n+                    );\n                 }\n \n                 tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n@@ -1855,16 +1958,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         self.normalize_and_prove_instantiated_predicates(\n             instantiated_predicates,\n-            location.boring(),\n+            location.to_locations(),\n         );\n     }\n \n-    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, locations: Locations) {\n+    fn prove_trait_ref(\n+        &mut self,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n         self.prove_predicates(\n             Some(ty::Predicate::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n             )),\n             locations,\n+            category,\n         );\n     }\n \n@@ -1875,26 +1984,32 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) {\n         for predicate in instantiated_predicates.predicates {\n             let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations);\n+            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n         }\n     }\n \n     fn prove_predicates(\n         &mut self,\n         predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n         locations: Locations,\n+        category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n             debug!(\n                 \"prove_predicates(predicate={:?}, locations={:?})\",\n                 predicate, locations,\n             );\n \n-            self.prove_predicate(predicate, locations);\n+            self.prove_predicate(predicate, locations, category);\n         }\n     }\n \n-    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, locations: Locations) {\n+    fn prove_predicate(\n+        &mut self,\n+        predicate: ty::Predicate<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n         debug!(\n             \"prove_predicate(predicate={:?}, location={:?})\",\n             predicate, locations,\n@@ -1903,6 +2018,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             locations,\n+            category,\n             param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n         ).unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n@@ -1943,6 +2059,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n+            ConstraintCategory::Boring,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n         ).unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n@@ -1996,26 +2113,6 @@ impl MirPass for TypeckMir {\n     }\n }\n \n-pub trait AtLocation {\n-    /// Indicates a \"boring\" constraint that the user probably\n-    /// woudln't want to see highlights.\n-    fn boring(self) -> Locations;\n-\n-    /// Indicates an \"interesting\" edge, which is of significance only\n-    /// for diagnostics.\n-    fn interesting(self) -> Locations;\n-}\n-\n-impl AtLocation for Location {\n-    fn boring(self) -> Locations {\n-        Locations::Boring(self)\n-    }\n-\n-    fn interesting(self) -> Locations {\n-        Locations::Interesting(self)\n-    }\n-}\n-\n trait NormalizeLocation: fmt::Debug + Copy {\n     fn to_locations(self) -> Locations;\n }\n@@ -2028,6 +2125,6 @@ impl NormalizeLocation for Locations {\n \n impl NormalizeLocation for Location {\n     fn to_locations(self) -> Locations {\n-        self.boring()\n+        Locations::Single(self)\n     }\n }"}, {"sha": "130b4b31d08e830e4efe91eda5eaa5c3384f1b0c", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994dc4bd1ef01b45408750679d9ec46bc1c2ff33/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=994dc4bd1ef01b45408750679d9ec46bc1c2ff33", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::constraints::{ConstraintCategory, OutlivesConstraint};\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n@@ -28,13 +28,15 @@ pub(super) fn sub_types<'tcx>(\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n         infcx,\n         ty::Variance::Covariant,\n         locations,\n+        category,\n         borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n@@ -47,13 +49,15 @@ pub(super) fn eq_types<'tcx>(\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n         infcx,\n         ty::Variance::Invariant,\n         locations,\n+        category,\n         borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n@@ -69,6 +73,7 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     v: ty::Variance,\n     b: CanonicalTy<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\n@@ -89,6 +94,7 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n         infcx,\n         v1,\n         locations,\n+        category,\n         borrowck_context,\n         b_variables,\n     ).relate(&b_value, &a)?;\n@@ -124,6 +130,8 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     /// Where (and why) is this relation taking place?\n     locations: Locations,\n \n+    category: ConstraintCategory,\n+\n     /// This will be `Some` when we are running the type check as part\n     /// of NLL, and `None` if we are running a \"sanity check\".\n     borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n@@ -161,6 +169,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n         ambient_variance: ty::Variance,\n         locations: Locations,\n+        category: ConstraintCategory,\n         borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n         canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n@@ -171,6 +180,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n             borrowck_context,\n             locations,\n             canonical_var_values,\n+            category,\n             a_scopes: vec![],\n             b_scopes: vec![],\n         }\n@@ -264,6 +274,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n                     sup,\n                     sub,\n                     locations: self.locations,\n+                    category: self.category,\n                 });\n \n             // FIXME all facts!"}]}