{"sha": "dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYjdmM2QyYzZjZDAzNWY0NDZmYmRjZGEyNDQyOTU0ZGE0YWZkM2E=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-08T17:09:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-08T17:32:36Z"}, "message": "Remove relative_path dependency", "tree": {"sha": "4b90fb312b32dd8431140f52265c44c580e0a588", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b90fb312b32dd8431140f52265c44c580e0a588"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "html_url": "https://github.com/rust-lang/rust/commit/dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ae696ba7642aba92c2eed012d9e02c09bab7460", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae696ba7642aba92c2eed012d9e02c09bab7460", "html_url": "https://github.com/rust-lang/rust/commit/7ae696ba7642aba92c2eed012d9e02c09bab7460"}], "stats": {"total": 132, "additions": 90, "deletions": 42}, "files": [{"sha": "242fca7004bb71f788bb049080c7ef5ac6d19fa5", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "patch": "@@ -1020,7 +1020,6 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"ra_tt\",\n- \"relative-path\",\n  \"rustc-hash\",\n  \"salsa\",\n  \"stdx\",\n@@ -1408,12 +1407,6 @@ version = \"0.6.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"26412eb97c6b088a6997e05f69403a802a92d520de2f8e63c2b65f9e0f47c4e8\"\n \n-[[package]]\n-name = \"relative-path\"\n-version = \"1.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c602122c47b382cd045b10866a084b184035d45d8c2609cdd3762852ddfae2a1\"\n-\n [[package]]\n name = \"remove_dir_all\"\n version = \"0.5.3\""}, {"sha": "889142442a5de6d3089fa595fc3c45ca195bef0b", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "patch": "@@ -9,7 +9,6 @@ doctest = false\n \n [dependencies]\n salsa = \"0.15.0\"\n-relative-path = \"1.0.0\"\n rustc-hash = \"1.1.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "f25be24fe2371e0f4448a91e37b9cc06691ecc51", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "patch": "@@ -16,7 +16,6 @@ pub use crate::{\n         SourceRoot, SourceRootId,\n     },\n };\n-pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;\n pub use vfs::{file_set::FileSet, VfsPath};\n "}, {"sha": "9539616325a46d9ba7508a76bb14bb3351b653d7", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "patch": "@@ -1,41 +1,46 @@\n //! This module resolves `mod foo;` declaration to file.\n use hir_expand::name::Name;\n-use ra_db::{FileId, RelativePathBuf};\n+use ra_db::FileId;\n use ra_syntax::SmolStr;\n \n use crate::{db::DefDatabase, HirFileId};\n \n #[derive(Clone, Debug)]\n pub(super) struct ModDir {\n-    /// `.` for `mod.rs`, `lib.rs`\n-    /// `./foo` for `foo.rs`\n-    /// `./foo/bar` for `mod bar { mod x; }` nested in `foo.rs`\n-    path: RelativePathBuf,\n+    /// `` for `mod.rs`, `lib.rs`\n+    /// `foo/` for `foo.rs`\n+    /// `foo/bar/` for `mod bar { mod x; }` nested in `foo.rs`\n+    /// Invariant: path.is_empty() || path.ends_with('/')\n+    dir_path: DirPath,\n     /// inside `./foo.rs`, mods with `#[path]` should *not* be relative to `./foo/`\n     root_non_dir_owner: bool,\n }\n \n impl ModDir {\n     pub(super) fn root() -> ModDir {\n-        ModDir { path: RelativePathBuf::default(), root_non_dir_owner: false }\n+        ModDir { dir_path: DirPath::empty(), root_non_dir_owner: false }\n     }\n \n     pub(super) fn descend_into_definition(\n         &self,\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> ModDir {\n-        let mut path = self.path.clone();\n-        match attr_to_path(attr_path) {\n-            None => path.push(&name.to_string()),\n+        let path = match attr_path.map(|it| it.as_str()) {\n+            None => {\n+                let mut path = self.dir_path.clone();\n+                path.push(&name.to_string());\n+                path\n+            }\n             Some(attr_path) => {\n-                if self.root_non_dir_owner {\n-                    assert!(path.pop());\n+                let mut path = self.dir_path.join_attr(attr_path, self.root_non_dir_owner);\n+                if !(path.is_empty() || path.ends_with('/')) {\n+                    path.push('/')\n                 }\n-                path.push(attr_path);\n+                DirPath::new(path)\n             }\n-        }\n-        ModDir { path, root_non_dir_owner: false }\n+        };\n+        ModDir { dir_path: path, root_non_dir_owner: false }\n     }\n \n     pub(super) fn resolve_declaration(\n@@ -48,34 +53,87 @@ impl ModDir {\n         let file_id = file_id.original_file(db.upcast());\n \n         let mut candidate_files = Vec::new();\n-        match attr_to_path(attr_path) {\n+        match attr_path {\n             Some(attr_path) => {\n-                let base =\n-                    if self.root_non_dir_owner { self.path.parent().unwrap() } else { &self.path };\n-                candidate_files.push(base.join(attr_path).to_string())\n+                candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None => {\n-                candidate_files.push(self.path.join(&format!(\"{}.rs\", name)).to_string());\n-                candidate_files.push(self.path.join(&format!(\"{}/mod.rs\", name)).to_string());\n+                candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n+                candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n             }\n         };\n \n         for candidate in candidate_files.iter() {\n             if let Some(file_id) = db.resolve_path(file_id, candidate.as_str()) {\n-                let mut root_non_dir_owner = false;\n-                let mut mod_path = RelativePathBuf::new();\n                 let is_mod_rs = candidate.ends_with(\"mod.rs\");\n-                if !(is_mod_rs || attr_path.is_some()) {\n-                    root_non_dir_owner = true;\n-                    mod_path.push(&name.to_string());\n-                }\n-                return Ok((file_id, is_mod_rs, ModDir { path: mod_path, root_non_dir_owner }));\n+\n+                let (dir_path, root_non_dir_owner) = if is_mod_rs || attr_path.is_some() {\n+                    (DirPath::empty(), false)\n+                } else {\n+                    (DirPath::new(format!(\"{}/\", name)), true)\n+                };\n+                return Ok((file_id, is_mod_rs, ModDir { dir_path, root_non_dir_owner }));\n             }\n         }\n         Err(candidate_files.remove(0))\n     }\n }\n \n-fn attr_to_path(attr: Option<&SmolStr>) -> Option<RelativePathBuf> {\n-    attr.and_then(|it| RelativePathBuf::from_path(&it.replace(\"\\\\\", \"/\")).ok())\n+#[derive(Clone, Debug)]\n+struct DirPath(String);\n+\n+impl DirPath {\n+    fn assert_invariant(&self) {\n+        assert!(self.0.is_empty() || self.0.ends_with('/'));\n+    }\n+    fn new(repr: String) -> DirPath {\n+        let res = DirPath(repr);\n+        res.assert_invariant();\n+        res\n+    }\n+    fn empty() -> DirPath {\n+        DirPath::new(String::new())\n+    }\n+    fn push(&mut self, name: &str) {\n+        self.0.push_str(name);\n+        self.0.push('/');\n+        self.assert_invariant();\n+    }\n+    fn parent(&self) -> Option<&str> {\n+        if self.0.is_empty() {\n+            return None;\n+        };\n+        let idx =\n+            self.0[..self.0.len() - '/'.len_utf8()].rfind('/').map_or(0, |it| it + '/'.len_utf8());\n+        Some(&self.0[..idx])\n+    }\n+    /// So this is the case which doesn't really work I think if we try to be\n+    /// 100% platform agnostic:\n+    ///\n+    /// ```\n+    /// mod a {\n+    ///     #[path=\"C://sad/face\"]\n+    ///     mod b { mod c; }\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, we need to join logical dir path to a string path from an\n+    /// attribute. Ideally, we should somehow losslessly communicate the whole\n+    /// construction to `FileLoader`.\n+    fn join_attr(&self, mut attr: &str, relative_to_parent: bool) -> String {\n+        let base = if relative_to_parent { self.parent().unwrap() } else { &self.0 };\n+\n+        if attr.starts_with(\"./\") {\n+            attr = &attr[\"./\".len()..];\n+        }\n+        let tmp;\n+        let attr = if attr.contains('\\\\') {\n+            tmp = attr.replace('\\\\', \"/\");\n+            &tmp\n+        } else {\n+            attr\n+        };\n+        let res = format!(\"{}{}\", base, attr);\n+        res\n+    }\n }"}, {"sha": "d1a255dcfcf7e32315163af728c5022382bb447d", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab7f3d2c6cd035f446fbdcda2442954da4afd3a/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=dab7f3d2c6cd035f446fbdcda2442954da4afd3a", "patch": "@@ -5,8 +5,7 @@ use std::{fmt, sync::Arc, time};\n \n use ra_db::{\n     salsa::{Database, Durability, SweepStrategy},\n-    CrateGraph, FileId, RelativePathBuf, SourceDatabase, SourceDatabaseExt, SourceRoot,\n-    SourceRootId,\n+    CrateGraph, FileId, SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n use ra_prof::{memory_usage, profile, Bytes};\n use rustc_hash::FxHashSet;\n@@ -57,14 +56,14 @@ impl AnalysisChange {\n #[derive(Debug)]\n struct AddFile {\n     file_id: FileId,\n-    path: RelativePathBuf,\n+    path: String,\n     text: Arc<String>,\n }\n \n #[derive(Debug)]\n struct RemoveFile {\n     file_id: FileId,\n-    path: RelativePathBuf,\n+    path: String,\n }\n \n #[derive(Default)]"}]}