{"sha": "abc3a8aa1e76f3ecc3930e20453a52681843cec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYzNhOGFhMWU3NmYzZWNjMzkzMGUyMDQ1M2E1MjY4MTg0M2NlYzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-02T08:55:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-14T06:18:45Z"}, "message": "std::rt: Add JoinLatch\n\nThis is supposed to be an efficient way to link the lifetimes\nof tasks into a tree. JoinLatches form a tree and when `release`\nis called they wait on children then signal the parent.\n\nThis structure creates zombie tasks which currently keep the entire\ntask allocated. Zombie tasks are supposed to be tombstoned but that\ncode does not work correctly.", "tree": {"sha": "4bb0825a5c2df977c6238a7f9eaa64686284f3b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bb0825a5c2df977c6238a7f9eaa64686284f3b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abc3a8aa1e76f3ecc3930e20453a52681843cec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abc3a8aa1e76f3ecc3930e20453a52681843cec0", "html_url": "https://github.com/rust-lang/rust/commit/abc3a8aa1e76f3ecc3930e20453a52681843cec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abc3a8aa1e76f3ecc3930e20453a52681843cec0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d83d38c7fe3408848664de66a9a53587f627a01b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d83d38c7fe3408848664de66a9a53587f627a01b", "html_url": "https://github.com/rust-lang/rust/commit/d83d38c7fe3408848664de66a9a53587f627a01b"}], "stats": {"total": 669, "additions": 665, "deletions": 4}, "files": [{"sha": "6ffba992fdf41c49e690ed12fb49d3ac5b76589f", "filename": "src/libstd/rt/join_latch.rs", "status": "added", "additions": 645, "deletions": 0, "changes": 645, "blob_url": "https://github.com/rust-lang/rust/blob/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fjoin_latch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fjoin_latch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fjoin_latch.rs?ref=abc3a8aa1e76f3ecc3930e20453a52681843cec0", "patch": "@@ -0,0 +1,645 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The JoinLatch is a concurrent type that establishes the task\n+//! tree and propagates failure.\n+//!\n+//! Each task gets a JoinLatch that is derived from the JoinLatch\n+//! of its parent task. Every latch must be released by either calling\n+//! the non-blocking `release` method or the task-blocking `wait` method.\n+//! Releasing a latch does not complete until all of its child latches\n+//! complete.\n+//!\n+//! Latches carry a `success` flag that is set to `false` during task\n+//! failure and is propagated both from children to parents and parents\n+//! to children. The status af this flag may be queried for the purposes\n+//! of linked failure.\n+//!\n+//! In addition to failure propagation the task tree serves to keep the\n+//! default task schedulers alive. The runtime only sends the shutdown\n+//! message to schedulers once the root task exits.\n+//!\n+//! Under this scheme tasks that terminate before their children become\n+//! 'zombies' since they may not exit until their children do. Zombie\n+//! tasks are 'tombstoned' as `Tombstone(~JoinLatch)` and the tasks\n+//! themselves allowed to terminate.\n+//!\n+//! XXX: Propagate flag from parents to children.\n+//! XXX: Tombstoning actually doesn't work.\n+//! XXX: This could probably be done in a way that doesn't leak tombstones\n+//!      longer than the life of the child tasks.\n+\n+use comm::{GenericPort, Peekable, GenericSmartChan};\n+use clone::Clone;\n+use container::Container;\n+use option::{Option, Some, None};\n+use ops::Drop;\n+use rt::comm::{SharedChan, Port, stream};\n+use rt::local::Local;\n+use rt::sched::Scheduler;\n+use unstable::atomics::{AtomicUint, SeqCst};\n+use util;\n+use vec::OwnedVector;\n+\n+// FIXME #7026: Would prefer this to be an enum\n+pub struct JoinLatch {\n+    priv parent: Option<ParentLink>,\n+    priv child: Option<ChildLink>,\n+    closed: bool,\n+}\n+\n+// Shared between parents and all their children.\n+struct SharedState {\n+    /// Reference count, held by a parent and all children.\n+    count: AtomicUint,\n+    success: bool\n+}\n+\n+struct ParentLink {\n+    shared: *mut SharedState,\n+    // For communicating with the parent.\n+    chan: SharedChan<Message>\n+}\n+\n+struct ChildLink {\n+    shared: ~SharedState,\n+    // For receiving from children.\n+    port: Port<Message>,\n+    chan: SharedChan<Message>,\n+    // Prevents dropping the child SharedState reference counts multiple times.\n+    dropped_child: bool\n+}\n+\n+// Messages from child latches to parent.\n+enum Message {\n+    Tombstone(~JoinLatch),\n+    ChildrenTerminated\n+}\n+\n+impl JoinLatch {\n+    pub fn new_root() -> ~JoinLatch {\n+        let this = ~JoinLatch {\n+            parent: None,\n+            child: None,\n+            closed: false\n+        };\n+        rtdebug!(\"new root latch %x\", this.id());\n+        return this;\n+    }\n+\n+    fn id(&self) -> uint {\n+        unsafe { ::cast::transmute(&*self) }\n+    }\n+\n+    pub fn new_child(&mut self) -> ~JoinLatch {\n+        rtassert!(!self.closed);\n+\n+        if self.child.is_none() {\n+            // This is the first time spawning a child\n+            let shared = ~SharedState {\n+                count: AtomicUint::new(1),\n+                success: true\n+            };\n+            let (port, chan) = stream();\n+            let chan = SharedChan::new(chan);\n+            let child = ChildLink {\n+                shared: shared,\n+                port: port,\n+                chan: chan,\n+                dropped_child: false\n+            };\n+            self.child = Some(child);\n+        }\n+\n+        let child_link: &mut ChildLink = self.child.get_mut_ref();\n+        let shared_state: *mut SharedState = &mut *child_link.shared;\n+\n+        child_link.shared.count.fetch_add(1, SeqCst);\n+\n+        let child = ~JoinLatch {\n+            parent: Some(ParentLink {\n+                shared: shared_state,\n+                chan: child_link.chan.clone()\n+            }),\n+            child: None,\n+            closed: false\n+        };\n+        rtdebug!(\"NEW child latch %x\", child.id());\n+        return child;\n+    }\n+\n+    pub fn release(~self, local_success: bool) {\n+        // XXX: This should not block, but there's a bug in the below\n+        // code that I can't figure out.\n+        self.wait(local_success);\n+    }\n+\n+    // XXX: Should not require ~self\n+    fn release_broken(~self, local_success: bool) {\n+        rtassert!(!self.closed);\n+\n+        rtdebug!(\"releasing %x\", self.id());\n+\n+        let id = self.id();\n+        let _ = id; // XXX: `id` is only used in debug statements so appears unused\n+        let mut this = self;\n+        let mut child_success = true;\n+        let mut children_done = false;\n+\n+        if this.child.is_some() {\n+            rtdebug!(\"releasing children\");\n+            let child_link: &mut ChildLink = this.child.get_mut_ref();\n+            let shared: &mut SharedState = &mut *child_link.shared;\n+\n+            if !child_link.dropped_child {\n+                let last_count = shared.count.fetch_sub(1, SeqCst);\n+                rtdebug!(\"child count before sub %u %x\", last_count, id);\n+                if last_count == 1 {\n+                    assert!(child_link.chan.try_send(ChildrenTerminated));\n+                }\n+                child_link.dropped_child = true;\n+            }\n+\n+            // Wait for messages from children\n+            let mut tombstones = ~[];\n+            loop {\n+                if child_link.port.peek() {\n+                    match child_link.port.recv() {\n+                        Tombstone(t) => {\n+                            tombstones.push(t);\n+                        },\n+                        ChildrenTerminated => {\n+                            children_done = true;\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    break\n+                }\n+            }\n+\n+            rtdebug!(\"releasing %u tombstones %x\", tombstones.len(), id);\n+\n+            // Try to release the tombstones. Those that still have\n+            // outstanding will be re-enqueued.  When this task's\n+            // parents release their latch we'll end up back here\n+            // trying them again.\n+            while !tombstones.is_empty() {\n+                tombstones.pop().release(true);\n+            }\n+\n+            if children_done {\n+                let count = shared.count.load(SeqCst);\n+                assert!(count == 0);\n+                // self_count is the acquire-read barrier\n+                child_success = shared.success;\n+            }\n+        } else {\n+            children_done = true;\n+        }\n+\n+        let total_success = local_success && child_success;\n+\n+        rtassert!(this.parent.is_some());\n+\n+        unsafe {\n+            {\n+                let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                let shared: *mut SharedState = parent_link.shared;\n+\n+                if !total_success {\n+                    // parent_count is the write-wait barrier\n+                    (*shared).success = false;\n+                }\n+            }\n+\n+            if children_done {\n+                rtdebug!(\"children done\");\n+                do Local::borrow::<Scheduler> |sched| {\n+                    sched.metrics.release_tombstone += 1;\n+                }\n+                {\n+                    rtdebug!(\"RELEASING parent %x\", id);\n+                    let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                    let shared: *mut SharedState = parent_link.shared;\n+                    let last_count = (*shared).count.fetch_sub(1, SeqCst);\n+                    rtdebug!(\"count before parent sub %u %x\", last_count, id);\n+                    if last_count == 1 {\n+                        assert!(parent_link.chan.try_send(ChildrenTerminated));\n+                    }\n+                }\n+                this.closed = true;\n+                util::ignore(this);\n+            } else {\n+                rtdebug!(\"children not done\");\n+                rtdebug!(\"TOMBSTONING %x\", id);\n+                do Local::borrow::<Scheduler> |sched| {\n+                    sched.metrics.release_no_tombstone += 1;\n+                }\n+                let chan = {\n+                    let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                    parent_link.chan.clone()\n+                };\n+                assert!(chan.try_send(Tombstone(this)));\n+            }\n+        }\n+    }\n+\n+    // XXX: Should not require ~self\n+    pub fn wait(~self, local_success: bool) -> bool {\n+        rtassert!(!self.closed);\n+\n+        rtdebug!(\"WAITING %x\", self.id());\n+\n+        let mut this = self;\n+        let mut child_success = true;\n+\n+        if this.child.is_some() {\n+            rtdebug!(\"waiting for children\");\n+            let child_link: &mut ChildLink = this.child.get_mut_ref();\n+            let shared: &mut SharedState = &mut *child_link.shared;\n+\n+            if !child_link.dropped_child {\n+                let last_count = shared.count.fetch_sub(1, SeqCst);\n+                rtdebug!(\"child count before sub %u\", last_count);\n+                if last_count == 1 {\n+                    assert!(child_link.chan.try_send(ChildrenTerminated));\n+                }\n+                child_link.dropped_child = true;\n+            }\n+\n+            // Wait for messages from children\n+            loop {\n+                match child_link.port.recv() {\n+                    Tombstone(t) => {\n+                        t.wait(true);\n+                    }\n+                    ChildrenTerminated => break\n+                }\n+            }\n+\n+            let count = shared.count.load(SeqCst);\n+            if count != 0 { ::io::println(fmt!(\"%u\", count)); }\n+            assert!(count == 0);\n+            // self_count is the acquire-read barrier\n+            child_success = shared.success;\n+        }\n+\n+        let total_success = local_success && child_success;\n+\n+        if this.parent.is_some() {\n+            rtdebug!(\"releasing parent\");\n+            unsafe {\n+                let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                let shared: *mut SharedState = parent_link.shared;\n+\n+                if !total_success {\n+                    // parent_count is the write-wait barrier\n+                    (*shared).success = false;\n+                }\n+\n+                let last_count = (*shared).count.fetch_sub(1, SeqCst);\n+                rtdebug!(\"count before parent sub %u\", last_count);\n+                if last_count == 1 {\n+                    assert!(parent_link.chan.try_send(ChildrenTerminated));\n+                }\n+            }\n+        }\n+\n+        this.closed = true;\n+        util::ignore(this);\n+\n+        return total_success;\n+    }\n+}\n+\n+impl Drop for JoinLatch {\n+    fn finalize(&self) {\n+        rtdebug!(\"DESTROYING %x\", self.id());\n+        rtassert!(self.closed);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use cell::Cell;\n+    use container::Container;\n+    use iter::Times;\n+    use old_iter::BaseIter;\n+    use rt::test::*;\n+    use rand;\n+    use rand::RngUtil;\n+    use vec::{CopyableVector, ImmutableVector};\n+\n+    #[test]\n+    fn success_immediately() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+            do spawntask_immediately {\n+                let child_latch = child_latch.take();\n+                assert!(child_latch.wait(true));\n+            }\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn success_later() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+            do spawntask_later {\n+                let child_latch = child_latch.take();\n+                assert!(child_latch.wait(true));\n+            }\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_success() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            for 10.times {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let child_latch = child_latch.take();\n+                    assert!(child_latch.wait(true));\n+                }\n+            }\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_failure() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            let spawn = |status| {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let child_latch = child_latch.take();\n+                    child_latch.wait(status);\n+                }\n+            };\n+\n+            for 10.times { spawn(true) }\n+            spawn(false);\n+            for 10.times { spawn(true) }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_multi_level_success() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            fn child(latch: &mut JoinLatch, i: int) {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let mut child_latch = child_latch.take();\n+                    if i != 0 {\n+                        child(&mut *child_latch, i - 1);\n+                        child_latch.wait(true);\n+                    } else {\n+                        child_latch.wait(true);\n+                    }\n+                }\n+            }\n+\n+            child(&mut *latch, 10);\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_multi_level_failure() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            fn child(latch: &mut JoinLatch, i: int) {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let mut child_latch = child_latch.take();\n+                    if i != 0 {\n+                        child(&mut *child_latch, i - 1);\n+                        child_latch.wait(false);\n+                    } else {\n+                        child_latch.wait(true);\n+                    }\n+                }\n+            }\n+\n+            child(&mut *latch, 10);\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+\n+            do spawntask_immediately {\n+                let latch = child_latch.take();\n+                latch.release(false);\n+            }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child_tombstone() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+\n+            do spawntask_immediately {\n+                let mut latch = child_latch.take();\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_later {\n+                    let latch = child_latch.take();\n+                    latch.release(false);\n+                }\n+                latch.release(true);\n+            }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child_no_tombstone() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+\n+            do spawntask_later {\n+                let mut latch = child_latch.take();\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_immediately {\n+                    let latch = child_latch.take();\n+                    latch.release(false);\n+                }\n+                latch.release(true);\n+            }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child_tombstone_stress() {\n+        fn rand_orders() -> ~[bool] {\n+            let mut v = ~[false,.. 5];\n+            v[0] = true;\n+            let mut rng = rand::rng();\n+            return rng.shuffle(v);\n+        }\n+\n+        fn split_orders(orders: &[bool]) -> (~[bool], ~[bool]) {\n+            if orders.is_empty() {\n+                return (~[], ~[]);\n+            } else if orders.len() <= 2 {\n+                return (orders.to_owned(), ~[]);\n+            }\n+            let mut rng = rand::rng();\n+            let n = rng.gen_uint_range(1, orders.len());\n+            let first = orders.slice(0, n).to_owned();\n+            let last = orders.slice(n, orders.len()).to_owned();\n+            assert!(first.len() + last.len() == orders.len());\n+            return (first, last);\n+        }\n+\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                fn doit(latch: &mut JoinLatch, orders: ~[bool], depth: uint) {\n+                    let (my_orders, remaining_orders) = split_orders(orders);\n+                    rtdebug!(\"(my_orders, remaining): %?\", (&my_orders, &remaining_orders));\n+                    rtdebug!(\"depth: %u\", depth);\n+                    let mut remaining_orders = remaining_orders;\n+                    let mut num = 0;\n+                    for my_orders.each |&order| {\n+                        let child_latch = latch.new_child();\n+                        let child_latch = Cell(child_latch);\n+                        let (child_orders, remaining) = split_orders(remaining_orders);\n+                        rtdebug!(\"(child_orders, remaining): %?\", (&child_orders, &remaining));\n+                        remaining_orders = remaining;\n+                        let child_orders = Cell(child_orders);\n+                        let child_num = num;\n+                        let _ = child_num; // XXX unused except in rtdebug!\n+                        do spawntask_random {\n+                            rtdebug!(\"depth %u num %u\", depth, child_num);\n+                            let mut child_latch = child_latch.take();\n+                            let child_orders = child_orders.take();\n+                            doit(&mut *child_latch, child_orders, depth + 1);\n+                            child_latch.release(order);\n+                        }\n+\n+                        num += 1;\n+                    }\n+                }\n+\n+                let mut latch = JoinLatch::new_root();\n+                let orders = rand_orders();\n+                rtdebug!(\"orders: %?\", orders);\n+\n+                doit(&mut *latch, orders, 0);\n+\n+                assert!(!latch.wait(true));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn whateverman() {\n+        struct Order {\n+            immediate: bool,\n+            succeed: bool,\n+            orders: ~[Order]\n+        }\n+        fn next(latch: &mut JoinLatch, orders: ~[Order]) {\n+            for orders.each |order| {\n+                let suborders = copy order.orders;\n+                let child_latch = Cell(latch.new_child());\n+                let succeed = order.succeed;\n+                if order.immediate {\n+                    do spawntask_immediately {\n+                        let mut child_latch = child_latch.take();\n+                        next(&mut *child_latch, copy suborders);\n+                        rtdebug!(\"immediate releasing\");\n+                        child_latch.release(succeed);\n+                    }\n+                } else {\n+                    do spawntask_later {\n+                        let mut child_latch = child_latch.take();\n+                        next(&mut *child_latch, copy suborders);\n+                        rtdebug!(\"later releasing\");\n+                        child_latch.release(succeed);\n+                    }\n+                }\n+            }\n+        }\n+\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let orders = ~[ Order { // 0 0\n+                immediate: true,\n+                succeed: true,\n+                orders: ~[ Order { // 1 0\n+                    immediate: true,\n+                    succeed: false,\n+                    orders: ~[ Order { // 2 0\n+                        immediate: false,\n+                        succeed: false,\n+                        orders: ~[ Order { // 3 0\n+                            immediate: true,\n+                            succeed: false,\n+                            orders: ~[]\n+                        }, Order { // 3 1\n+                            immediate: false,\n+                            succeed: false,\n+                            orders: ~[]\n+                        }]\n+                    }]\n+                }]\n+            }];\n+\n+            next(&mut *latch, orders);\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+}"}, {"sha": "b0c0fa5d708623d216bdfb58bdf6947da29ada29", "filename": "src/libstd/rt/metrics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmetrics.rs?ref=abc3a8aa1e76f3ecc3930e20453a52681843cec0", "patch": "@@ -34,7 +34,11 @@ pub struct SchedMetrics {\n     // Message receives that do not block the receiver\n     rendezvous_recvs: uint,\n     // Message receives that block the receiver\n-    non_rendezvous_recvs: uint\n+    non_rendezvous_recvs: uint,\n+    // JoinLatch releases that create tombstones\n+    release_tombstone: uint,\n+    // JoinLatch releases that do not create tombstones\n+    release_no_tombstone: uint,\n }\n \n impl SchedMetrics {\n@@ -51,7 +55,9 @@ impl SchedMetrics {\n             rendezvous_sends: 0,\n             non_rendezvous_sends: 0,\n             rendezvous_recvs: 0,\n-            non_rendezvous_recvs: 0\n+            non_rendezvous_recvs: 0,\n+            release_tombstone: 0,\n+            release_no_tombstone: 0\n         }\n     }\n }\n@@ -70,6 +76,8 @@ impl ToStr for SchedMetrics {\n               non_rendezvous_sends: %u\\n\\\n               rendezvous_recvs: %u\\n\\\n               non_rendezvous_recvs: %u\\n\\\n+              release_tombstone: %u\\n\\\n+              release_no_tombstone: %u\\n\\\n               \",\n              self.turns,\n              self.messages_received,\n@@ -82,7 +90,9 @@ impl ToStr for SchedMetrics {\n              self.rendezvous_sends,\n              self.non_rendezvous_sends,\n              self.rendezvous_recvs,\n-             self.non_rendezvous_recvs\n+             self.non_rendezvous_recvs,\n+             self.release_tombstone,\n+             self.release_no_tombstone\n         )\n     }\n }\n\\ No newline at end of file"}, {"sha": "2008c4a180f60c7f06d8704427cdd2777ea6bf49", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=abc3a8aa1e76f3ecc3930e20453a52681843cec0", "patch": "@@ -133,6 +133,9 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n+/// A concurrent data structure with which parent tasks wait on child tasks.\n+pub mod join_latch;\n+\n pub mod metrics;\n \n "}, {"sha": "104eb4b8baefad373255d2dc7dd98846c14dd8fb", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3a8aa1e76f3ecc3930e20453a52681843cec0/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=abc3a8aa1e76f3ecc3930e20453a52681843cec0", "patch": "@@ -151,7 +151,10 @@ pub impl Scheduler {\n         // XXX: Reenable this once we're using a per-task queue. With a shared\n         // queue this is not true\n         //assert!(sched.work_queue.is_empty());\n-        rtdebug!(\"scheduler metrics: %s\\n\", sched.metrics.to_str());\n+        rtdebug!(\"scheduler metrics: %s\\n\", {\n+            use to_str::ToStr;\n+            sched.metrics.to_str()\n+        });\n         return sched;\n     }\n "}]}