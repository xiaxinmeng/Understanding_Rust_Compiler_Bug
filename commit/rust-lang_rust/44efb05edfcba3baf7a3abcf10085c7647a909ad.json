{"sha": "44efb05edfcba3baf7a3abcf10085c7647a909ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZWZiMDVlZGZjYmEzYmFmN2EzYWJjZjEwMDg1Yzc2NDdhOTA5YWQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-11T14:16:54Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-11T15:12:23Z"}, "message": "Add cs_fold1 for better derives", "tree": {"sha": "e7aaa91641c7a5b34e17372ebe0236d44023c8ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7aaa91641c7a5b34e17372ebe0236d44023c8ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44efb05edfcba3baf7a3abcf10085c7647a909ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44efb05edfcba3baf7a3abcf10085c7647a909ad", "html_url": "https://github.com/rust-lang/rust/commit/44efb05edfcba3baf7a3abcf10085c7647a909ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44efb05edfcba3baf7a3abcf10085c7647a909ad/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59ee333a0e952eb7b91d86447b489aa12efd0bd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/59ee333a0e952eb7b91d86447b489aa12efd0bd3", "html_url": "https://github.com/rust-lang/rust/commit/59ee333a0e952eb7b91d86447b489aa12efd0bd3"}], "stats": {"total": 109, "additions": 92, "deletions": 17}, "files": [{"sha": "11bd72691c56882d95feef42d5f18640fc55cb5f", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/44efb05edfcba3baf7a3abcf10085c7647a909ad/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44efb05edfcba3baf7a3abcf10085c7647a909ad/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=44efb05edfcba3baf7a3abcf10085c7647a909ad", "patch": "@@ -1676,12 +1676,55 @@ impl<'a> TraitDef<'a> {\n \n // helpful premade recipes\n \n+pub fn cs_fold_fields<'a, F>(use_foldl: bool,\n+                             mut f: F,\n+                             base: P<Expr>,\n+                             cx: &mut ExtCtxt,\n+                             all_fields: &[FieldInfo<'a>])\n+                             -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n+{\n+    if use_foldl {\n+        all_fields.iter().fold(base, |old, field| {\n+            f(cx, field.span, old, field.self_.clone(), &field.other)\n+        })\n+    } else {\n+        all_fields.iter().rev().fold(base, |old, field| {\n+            f(cx, field.span, old, field.self_.clone(), &field.other)\n+        })\n+    }\n+}\n+\n+pub fn cs_fold_enumnonmatch(mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                            cx: &mut ExtCtxt,\n+                            trait_span: Span,\n+                            substructure: &Substructure)\n+                            -> P<Expr>\n+{\n+    match *substructure.fields {\n+        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n+            enum_nonmatch_f(cx,\n+                            trait_span,\n+                            (&all_args[..], tuple),\n+                            substructure.nonself_args)\n+        }\n+        _ => cx.span_bug(trait_span, \"cs_fold_enumnonmatch expected an EnumNonMatchingCollapsed\")\n+    }\n+}\n+\n+pub fn cs_fold_static(cx: &mut ExtCtxt,\n+                      trait_span: Span)\n+                      -> P<Expr>\n+{\n+    cx.span_bug(trait_span, \"static function in `derive`\")\n+}\n+\n /// Fold the fields. `use_foldl` controls whether this is done\n /// left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold<F>(use_foldl: bool,\n-                  mut f: F,\n+                  f: F,\n                   base: P<Expr>,\n-                  mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                  enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                   cx: &mut ExtCtxt,\n                   trait_span: Span,\n                   substructure: &Substructure)\n@@ -1691,26 +1734,58 @@ pub fn cs_fold<F>(use_foldl: bool,\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) |\n         Struct(_, ref all_fields) => {\n-            if use_foldl {\n-                all_fields.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n-            } else {\n-                all_fields.iter().rev().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n-            }\n+            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n         }\n-        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n-            enum_nonmatch_f(cx,\n-                            trait_span,\n-                            (&all_args[..], tuple),\n-                            substructure.nonself_args)\n+        EnumNonMatchingCollapsed(..) => {\n+            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => {\n+            cs_fold_static(cx, trait_span)\n         }\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }\n \n+/// Special version of `cs_fold` that uses the result of a function call on the first field\n+/// as the base case when is at least 1 field, and the usual base case when there are zero fields.\n+pub fn cs_fold1<F, B>(use_foldl: bool,\n+                      f: F,\n+                      mut b: B,\n+                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                      cx: &mut ExtCtxt,\n+                      trait_span: Span,\n+                      substructure: &Substructure)\n+                      -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+          B: FnMut(&mut ExtCtxt, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>\n+{\n+    match *substructure.fields {\n+        EnumMatching(.., ref all_fields) |\n+        Struct(_, ref all_fields) => {\n+            let (base, all_fields) = match (all_fields.is_empty(), use_foldl) {\n+                (false, true) => {\n+                    let field = &all_fields[0];\n+                    let args = (field.span, field.self_.clone(), &field.other[..]);\n+                    (b(cx, Some(args)), &all_fields[1..])\n+                }\n+                (false, false) => {\n+                    let idx = all_fields.len() - 1;\n+                    let field = &all_fields[idx];\n+                    let args = (field.span, field.self_.clone(), &field.other[..]);\n+                    (b(cx, Some(args)), &all_fields[..idx])\n+                }\n+                (true, _) => (b(cx, None), &all_fields[..])\n+            };\n+\n+            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n+        }\n+        EnumNonMatchingCollapsed(..) => {\n+            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => {\n+            cs_fold_static(cx, trait_span)\n+        }\n+    }\n+}\n \n /// Call the method that is being derived on all the fields, and then\n /// process the collected results. i.e."}]}