{"sha": "c9119252438a0f6c6c7a289bac91dd9600d45dd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTE5MjUyNDM4YTBmNmM2YzdhMjg5YmFjOTFkZDk2MDBkNDVkZDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-03T16:14:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-03T16:14:31Z"}, "message": "rustc_mir: implement visit_local instead/along visit_lvalue where possible.", "tree": {"sha": "66f1ab3b1b410f50d5584b5bb3db2f1f04b10a80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66f1ab3b1b410f50d5584b5bb3db2f1f04b10a80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9119252438a0f6c6c7a289bac91dd9600d45dd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9119252438a0f6c6c7a289bac91dd9600d45dd0", "html_url": "https://github.com/rust-lang/rust/commit/c9119252438a0f6c6c7a289bac91dd9600d45dd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9119252438a0f6c6c7a289bac91dd9600d45dd0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f2b8b34c2a1e585117714f99b3858da5f1b92b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2b8b34c2a1e585117714f99b3858da5f1b92b5", "html_url": "https://github.com/rust-lang/rust/commit/2f2b8b34c2a1e585117714f99b3858da5f1b92b5"}], "stats": {"total": 452, "additions": 217, "deletions": 235}, "files": [{"sha": "6ee43953958009e11e6bb86547a6f64ce77c8744", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -256,7 +256,9 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_local(&mut self,\n-                                _local: & $($mutability)* Local) {\n+                            _local: & $($mutability)* Local,\n+                            _context: LvalueContext<'tcx>,\n+                            _location: Location) {\n             }\n \n             fn visit_visibility_scope(&mut self,\n@@ -610,7 +612,7 @@ macro_rules! make_mir_visitor {\n                             location: Location) {\n                 match *lvalue {\n                     Lvalue::Local(ref $($mutability)* local) => {\n-                        self.visit_local(local);\n+                        self.visit_local(local, context, location);\n                     }\n                     Lvalue::Static(ref $($mutability)* static_) => {\n                         self.visit_static(static_, context, location);"}, {"sha": "ac8ebd306d321e844b2beda2cca17d3a7517ac33", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -236,8 +236,7 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                let src_lvalue = Lvalue::Local(src_local);\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_lvalue);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_local);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");"}, {"sha": "8328bb9461eded2cb09d3a348f6fa20636ea08c2", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -88,7 +88,9 @@ struct RenameLocalVisitor {\n \n impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n     fn visit_local(&mut self,\n-                        local: &mut Local) {\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n         if *local == self.from {\n             *local = self.to;\n         }\n@@ -98,6 +100,13 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n struct DerefArgVisitor;\n \n impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        assert_ne!(*local, self_arg());\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n@@ -177,6 +186,13 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        assert_eq!(self.remap.get(local), None);\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,"}, {"sha": "3f8070fb3aa31929cb7b577060f64c9095978947", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -589,16 +589,6 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n         new\n     }\n \n-    fn update_local(&self, local: Local) -> Option<Local> {\n-        let idx = local.index();\n-        if idx < (self.args.len() + 1) {\n-            return None;\n-        }\n-        let idx = idx - (self.args.len() + 1);\n-        let local = Local::new(idx);\n-        self.local_map.get(local).cloned()\n-    }\n-\n     fn arg_index(&self, arg: Local) -> Option<usize> {\n         let idx = arg.index();\n         if idx > 0 && idx <= self.args.len() {\n@@ -610,32 +600,35 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _ctxt: LvalueContext<'tcx>,\n+                   _location: Location) {\n+        if *local == RETURN_POINTER {\n+            match self.destination {\n+                Lvalue::Local(l) => *local = l,\n+                ref lval => bug!(\"Return lvalue is {:?}, not local\", lval)\n+            }\n+        }\n+        let idx = local.index() - 1;\n+        if idx < self.args.len() {\n+            match self.args[idx] {\n+                Operand::Consume(Lvalue::Local(l)) => *local = l,\n+                ref op => bug!(\"Arg operand `{:?}` is {:?}, not local\", idx, op)\n+            }\n+        }\n+        *local = self.local_map[Local::new(idx - self.args.len())];\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n                     _ctxt: LvalueContext<'tcx>,\n                     _location: Location) {\n-        if let Lvalue::Local(ref mut local) = *lvalue {\n-            if let Some(l) = self.update_local(*local) {\n-                // Temp or Var; update the local reference\n-                *local = l;\n-                return;\n-            }\n-        }\n-        if let Lvalue::Local(local) = *lvalue {\n-            if local == RETURN_POINTER {\n-                // Return pointer; update the lvalue itself\n-                *lvalue = self.destination.clone();\n-            } else if local.index() < (self.args.len() + 1) {\n-                // Argument, once again update the the lvalue itself\n-                let idx = local.index() - 1;\n-                if let Operand::Consume(ref lval) = self.args[idx] {\n-                    *lvalue = lval.clone();\n-                } else {\n-                    bug!(\"Arg operand `{:?}` is not an Lvalue use.\", idx)\n-                }\n-            }\n+        if let Lvalue::Local(RETURN_POINTER) = *lvalue {\n+            // Return pointer; update the lvalue itself\n+            *lvalue = self.destination.clone();\n         } else {\n-            self.super_lvalue(lvalue, _ctxt, _location)\n+            self.super_lvalue(lvalue, _ctxt, _location);\n         }\n     }\n "}, {"sha": "53191806981a0a6b00958257deaa2f572beed131", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 43, "deletions": 49, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -83,52 +83,49 @@ struct TempCollector<'tcx> {\n }\n \n impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        self.super_lvalue(lvalue, context, location);\n-        if let Lvalue::Local(index) = *lvalue {\n-            // We're only interested in temporaries\n-            if self.mir.local_kind(index) != LocalKind::Temp {\n-                return;\n-            }\n+    fn visit_local(&mut self,\n+                   &index: &Local,\n+                   context: LvalueContext<'tcx>,\n+                   location: Location) {\n+        // We're only interested in temporaries\n+        if self.mir.local_kind(index) != LocalKind::Temp {\n+            return;\n+        }\n \n-            // Ignore drops, if the temp gets promoted,\n-            // then it's constant and thus drop is noop.\n-            // Storage live ranges are also irrelevant.\n-            if context.is_drop() || context.is_storage_marker() {\n-                return;\n-            }\n+        // Ignore drops, if the temp gets promoted,\n+        // then it's constant and thus drop is noop.\n+        // Storage live ranges are also irrelevant.\n+        if context.is_drop() || context.is_storage_marker() {\n+            return;\n+        }\n \n-            let temp = &mut self.temps[index];\n-            if *temp == TempState::Undefined {\n-                match context {\n-                    LvalueContext::Store |\n-                    LvalueContext::Call => {\n-                        *temp = TempState::Defined {\n-                            location,\n-                            uses: 0\n-                        };\n-                        return;\n-                    }\n-                    _ => { /* mark as unpromotable below */ }\n-                }\n-            } else if let TempState::Defined { ref mut uses, .. } = *temp {\n-                // We always allow borrows, even mutable ones, as we need\n-                // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n-                let allowed_use = match context {\n-                    LvalueContext::Borrow {..} => true,\n-                    _ => context.is_nonmutating_use()\n-                };\n-                if allowed_use {\n-                    *uses += 1;\n+        let temp = &mut self.temps[index];\n+        if *temp == TempState::Undefined {\n+            match context {\n+                LvalueContext::Store |\n+                LvalueContext::Call => {\n+                    *temp = TempState::Defined {\n+                        location,\n+                        uses: 0\n+                    };\n                     return;\n                 }\n-                /* mark as unpromotable below */\n+                _ => { /* mark as unpromotable below */ }\n             }\n-            *temp = TempState::Unpromotable;\n+        } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+            // We always allow borrows, even mutable ones, as we need\n+            // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n+            let allowed_use = match context {\n+                LvalueContext::Borrow {..} => true,\n+                _ => context.is_nonmutating_use()\n+            };\n+            if allowed_use {\n+                *uses += 1;\n+                return;\n+            }\n+            /* mark as unpromotable below */\n         }\n+        *temp = TempState::Unpromotable;\n     }\n \n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n@@ -326,16 +323,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        if let Lvalue::Local(ref mut temp) = *lvalue {\n-            if self.source.local_kind(*temp) == LocalKind::Temp {\n-                *temp = self.promote_temp(*temp);\n-            }\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        if self.source.local_kind(*local) == LocalKind::Temp {\n+            *local = self.promote_temp(*local);\n         }\n-        self.super_lvalue(lvalue, context, location);\n     }\n }\n "}, {"sha": "99e9f638a749b8175963c856f7d508ad3f191a95", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -499,33 +499,40 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n+    fn visit_local(&mut self,\n+                   &local: &Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        match self.mir.local_kind(local) {\n+            LocalKind::ReturnPointer => {\n+                self.not_const();\n+            }\n+            LocalKind::Arg => {\n+                self.add(Qualif::FN_ARGUMENT);\n+            }\n+            LocalKind::Var => {\n+                self.add(Qualif::NOT_CONST);\n+            }\n+            LocalKind::Temp => {\n+                if !self.temp_promotion_state[local].is_promotable() {\n+                    self.add(Qualif::NOT_PROMOTABLE);\n+                }\n+\n+                if let Some(qualif) = self.temp_qualif[local] {\n+                    self.add(qualif);\n+                } else {\n+                    self.not_const();\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n         match *lvalue {\n-            Lvalue::Local(local) => match self.mir.local_kind(local) {\n-                LocalKind::ReturnPointer => {\n-                    self.not_const();\n-                }\n-                LocalKind::Arg => {\n-                    self.add(Qualif::FN_ARGUMENT);\n-                }\n-                LocalKind::Var => {\n-                    self.add(Qualif::NOT_CONST);\n-                }\n-                LocalKind::Temp => {\n-                    if !self.temp_promotion_state[local].is_promotable() {\n-                        self.add(Qualif::NOT_PROMOTABLE);\n-                    }\n-\n-                    if let Some(qualif) = self.temp_qualif[local] {\n-                        self.add(qualif);\n-                    } else {\n-                        self.not_const();\n-                    }\n-                }\n-            },\n+            Lvalue::Local(ref local) => self.visit_local(local, context, location),\n             Lvalue::Static(ref global) => {\n                 self.add(Qualif::STATIC);\n "}, {"sha": "4b825e585aab9e97ff4db9adc770ffb14bdb9416", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -352,15 +352,11 @@ struct DeclMarker {\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {\n-    fn visit_lvalue(&mut self, lval: &Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n-        if ctx == LvalueContext::StorageLive || ctx == LvalueContext::StorageDead {\n-            // ignore these altogether, they get removed along with their otherwise unused decls.\n-            return;\n+    fn visit_local(&mut self, local: &Local, ctx: LvalueContext<'tcx>, _: Location) {\n+        // ignore these altogether, they get removed along with their otherwise unused decls.\n+        if ctx != LvalueContext::StorageLive && ctx != LvalueContext::StorageDead {\n+            self.locals.insert(local.index());\n         }\n-        if let Lvalue::Local(ref v) = *lval {\n-            self.locals.insert(v.index());\n-        }\n-        self.super_lvalue(lval, ctx, loc);\n     }\n }\n \n@@ -384,11 +380,7 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n         });\n         self.super_basic_block_data(block, data);\n     }\n-    fn visit_lvalue(&mut self, lval: &mut Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n-        match *lval {\n-            Lvalue::Local(ref mut l) => *l = Local::new(self.map[l.index()]),\n-            _ => (),\n-        };\n-        self.super_lvalue(lval, ctx, loc);\n+    fn visit_local(&mut self, l: &mut Local, _: LvalueContext<'tcx>, _: Location) {\n+        *l = Local::new(self.map[l.index()]);\n     }\n }"}, {"sha": "bd9fb4bc3cc5f6fd203c4372b3b5a31d1f170803", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -10,7 +10,7 @@\n \n //! Def-use analysis.\n \n-use rustc::mir::{Local, Location, Lvalue, Mir};\n+use rustc::mir::{Local, Location, Mir};\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::marker::PhantomData;\n@@ -51,7 +51,7 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n     }\n \n     fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n-                               where F: for<'a> FnMut(&'a mut Lvalue<'tcx>,\n+                               where F: for<'a> FnMut(&'a mut Local,\n                                                       LvalueContext<'tcx>,\n                                                       Location) {\n         for lvalue_use in &self.info[local].defs_and_uses {\n@@ -65,39 +65,24 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n                                           mir: &mut Mir<'tcx>,\n-                                          new_lvalue: Lvalue<'tcx>) {\n-        self.mutate_defs_and_uses(local, mir, |lvalue, _, _| *lvalue = new_lvalue.clone())\n+                                          new_local: Local) {\n+        self.mutate_defs_and_uses(local, mir, |local, _, _| *local = new_local)\n     }\n }\n \n struct DefUseFinder<'tcx> {\n     info: IndexVec<Local, Info<'tcx>>,\n }\n \n-impl<'tcx> DefUseFinder<'tcx> {\n-    fn lvalue_mut_info(&mut self, lvalue: &Lvalue<'tcx>) -> Option<&mut Info<'tcx>> {\n-        let info = &mut self.info;\n-\n-        if let Lvalue::Local(local) = *lvalue {\n-            Some(&mut info[local])\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for DefUseFinder<'tcx> {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        if let Some(ref mut info) = self.lvalue_mut_info(lvalue) {\n-            info.defs_and_uses.push(Use {\n-                context,\n-                location,\n-            })\n-        }\n-        self.super_lvalue(lvalue, context, location)\n+    fn visit_local(&mut self,\n+                   &local: &Local,\n+                   context: LvalueContext<'tcx>,\n+                   location: Location) {\n+        self.info[local].defs_and_uses.push(Use {\n+            context,\n+            location,\n+        });\n     }\n }\n \n@@ -134,7 +119,7 @@ struct MutateUseVisitor<'tcx, F> {\n impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n     fn new(query: Local, callback: F, _: &Mir<'tcx>)\n            -> MutateUseVisitor<'tcx, F>\n-           where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n+           where F: for<'a> FnMut(&'a mut Local, LvalueContext<'tcx>, Location) {\n         MutateUseVisitor {\n             query,\n             callback,\n@@ -144,16 +129,13 @@ impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n }\n \n impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n-              where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n+              where F: for<'a> FnMut(&'a mut Local, LvalueContext<'tcx>, Location) {\n+    fn visit_local(&mut self,\n+                    local: &mut Local,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n-        if let Lvalue::Local(local) = *lvalue {\n-            if local == self.query {\n-                (self.callback)(lvalue, context, location)\n-            }\n+        if *local == self.query {\n+            (self.callback)(local, context, location)\n         }\n-        self.super_lvalue(lvalue, context, location)\n     }\n }"}, {"sha": "e6d3a82ff9b5306509fb8fa6593b38531104ec5d", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -60,49 +60,45 @@ struct BlockInfoVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        if let Lvalue::Local(local) = *lvalue {\n-            match context {\n-                LvalueContext::Store |\n-\n-                // We let Call defined the result in both the success and unwind cases.\n-                // This may not be right.\n-                LvalueContext::Call |\n-\n-                // Storage live and storage dead aren't proper defines, but we can ignore\n-                // values that come before them.\n-                LvalueContext::StorageLive |\n-                LvalueContext::StorageDead => {\n-                    self.defs.add(&local);\n-                }\n-                LvalueContext::Projection(..) |\n-\n-                // Borrows only consider their local used at the point of the borrow.\n-                // This won't affect the results since we use this analysis for generators\n-                // and we only care about the result at suspension points. Borrows cannot\n-                // cross suspension points so this behavior is unproblematic.\n-                LvalueContext::Borrow { .. } |\n-\n-                LvalueContext::Inspect |\n-                LvalueContext::Consume |\n-                LvalueContext::Validate |\n-\n-                // We consider drops to always be uses of locals.\n-                // Drop eloboration should be run before this analysis otherwise\n-                // the results might be too pessimistic.\n-                LvalueContext::Drop => {\n-                    // Ignore uses which are already defined in this block\n-                    if !self.pre_defs.contains(&local) {\n-                        self.uses.add(&local);\n-                    }\n+    fn visit_local(&mut self,\n+                   &local: &Local,\n+                   context: LvalueContext<'tcx>,\n+                   _: Location) {\n+        match context {\n+            LvalueContext::Store |\n+\n+            // We let Call defined the result in both the success and unwind cases.\n+            // This may not be right.\n+            LvalueContext::Call |\n+\n+            // Storage live and storage dead aren't proper defines, but we can ignore\n+            // values that come before them.\n+            LvalueContext::StorageLive |\n+            LvalueContext::StorageDead => {\n+                self.defs.add(&local);\n+            }\n+            LvalueContext::Projection(..) |\n+\n+            // Borrows only consider their local used at the point of the borrow.\n+            // This won't affect the results since we use this analysis for generators\n+            // and we only care about the result at suspension points. Borrows cannot\n+            // cross suspension points so this behavior is unproblematic.\n+            LvalueContext::Borrow { .. } |\n+\n+            LvalueContext::Inspect |\n+            LvalueContext::Consume |\n+            LvalueContext::Validate |\n+\n+            // We consider drops to always be uses of locals.\n+            // Drop eloboration should be run before this analysis otherwise\n+            // the results might be too pessimistic.\n+            LvalueContext::Drop => {\n+                // Ignore uses which are already defined in this block\n+                if !self.pre_defs.contains(&local) {\n+                    self.uses.add(&local);\n                 }\n             }\n         }\n-\n-        self.super_lvalue(lvalue, context, location)\n     }\n }\n "}, {"sha": "95b76d32bf8484d450b040c15421cd6fb45f1200", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9119252438a0f6c6c7a289bac91dd9600d45dd0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c9119252438a0f6c6c7a289bac91dd9600d45dd0", "patch": "@@ -134,60 +134,61 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n-        // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Local(_) = proj.base {\n-                let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n-\n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n-                if common::type_is_imm_pair(self.cx.ccx, ty) {\n+            // Allow uses of projections of immediate pair fields.\n+            if let LvalueContext::Consume = context {\n+                if let mir::Lvalue::Local(_) = proj.base {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n-                        if let LvalueContext::Consume = context {\n+                        let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n+\n+                        let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+                        if common::type_is_imm_pair(self.cx.ccx, ty) {\n                             return;\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        if let mir::Lvalue::Local(index) = *lvalue {\n-            match context {\n-                LvalueContext::Call => {\n-                    self.mark_assigned(index);\n-                }\n+            // A deref projection only reads the pointer, never needs the lvalue.\n+            if let mir::ProjectionElem::Deref = proj.elem {\n+                return self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+            }\n+        }\n \n-                LvalueContext::StorageLive |\n-                LvalueContext::StorageDead |\n-                LvalueContext::Validate |\n-                LvalueContext::Inspect |\n-                LvalueContext::Consume => {}\n+        self.super_lvalue(lvalue, context, location);\n+    }\n \n-                LvalueContext::Store |\n-                LvalueContext::Borrow { .. } |\n-                LvalueContext::Projection(..) => {\n-                    self.mark_as_lvalue(index);\n-                }\n+    fn visit_local(&mut self,\n+                   &index: &mir::Local,\n+                   context: LvalueContext<'tcx>,\n+                   _: Location) {\n+        match context {\n+            LvalueContext::Call => {\n+                self.mark_assigned(index);\n+            }\n \n-                LvalueContext::Drop => {\n-                    let ty = lvalue.ty(self.cx.mir, self.cx.ccx.tcx());\n-                    let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+            LvalueContext::StorageLive |\n+            LvalueContext::StorageDead |\n+            LvalueContext::Validate |\n+            LvalueContext::Inspect |\n+            LvalueContext::Consume => {}\n \n-                    // Only need the lvalue if we're actually dropping it.\n-                    if self.cx.ccx.shared().type_needs_drop(ty) {\n-                        self.mark_as_lvalue(index);\n-                    }\n-                }\n+            LvalueContext::Store |\n+            LvalueContext::Borrow { .. } |\n+            LvalueContext::Projection(..) => {\n+                self.mark_as_lvalue(index);\n             }\n-        }\n \n-        // A deref projection only reads the pointer, never needs the lvalue.\n-        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+            LvalueContext::Drop => {\n+                let ty = mir::Lvalue::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n+                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+\n+                // Only need the lvalue if we're actually dropping it.\n+                if self.cx.ccx.shared().type_needs_drop(ty) {\n+                    self.mark_as_lvalue(index);\n+                }\n             }\n         }\n-\n-        self.super_lvalue(lvalue, context, location);\n     }\n }\n "}]}