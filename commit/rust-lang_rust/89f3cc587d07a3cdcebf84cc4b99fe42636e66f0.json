{"sha": "89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZjNjYzU4N2QwN2EzY2RjZWJmODRjYzRiOTlmZTQyNjM2ZTY2ZjA=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-08-15T20:53:42Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-08-26T19:44:50Z"}, "message": "Properly coerce never types", "tree": {"sha": "7cb5af59ad096a42bcdf85aea0662fb7bebd1965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cb5af59ad096a42bcdf85aea0662fb7bebd1965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "html_url": "https://github.com/rust-lang/rust/commit/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b612251fd8c741416d2fb320bd908b76134fde5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b612251fd8c741416d2fb320bd908b76134fde5", "html_url": "https://github.com/rust-lang/rust/commit/8b612251fd8c741416d2fb320bd908b76134fde5"}], "stats": {"total": 103, "additions": 46, "deletions": 57}, "files": [{"sha": "5b15eee901a9bde788ff3be6c76b9e800fde1a2a", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "patch": "@@ -11,10 +11,4 @@ test_utils::marks!(\n     match_ergonomics_ref\n     trait_resolution_on_fn_type\n     infer_while_let\n-    match_first_arm_never\n-    match_second_arm_never\n-    match_all_arms_never\n-    match_no_never_arms\n-    if_never\n-    if_else_never\n );"}, {"sha": "3911695df742373cf94b9ac191fff4d3e3d35586", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "patch": "@@ -297,7 +297,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             | (other, Ty::Infer(InferTy::IntVar(tv)))\n             | (Ty::Infer(InferTy::FloatVar(tv)), other)\n             | (other, Ty::Infer(InferTy::FloatVar(tv)))\n-                if !Self::is_never(other) =>\n+                if !is_never(other) =>\n             {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n@@ -984,24 +984,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n-                let then_ty = self.infer_expr(*then_branch, expected);\n+\n+                let mut branch_tys = Vec::with_capacity(2);\n+                let then_ty = self.infer_expr(*then_branch, &expected);\n                 match else_branch {\n                     Some(else_branch) => {\n-                        let else_ty = self.infer_expr(*else_branch, expected);\n-                        if Self::is_never(&then_ty) {\n-                            tested_by!(if_never);\n-                            else_ty\n-                        } else {\n-                            tested_by!(if_else_never);\n-                            then_ty\n-                        }\n+                        branch_tys.push(self.infer_expr(*else_branch, &expected));\n                     }\n                     None => {\n                         // no else branch -> unit\n                         self.unify(&then_ty, &Ty::unit()); // actually coerce\n-                        then_ty\n                     }\n-                }\n+                };\n+                branch_tys.push(then_ty);\n+                calculate_least_upper_bound(expected.ty.clone(), branch_tys)\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::TryBlock { body } => {\n@@ -1081,15 +1077,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n                 .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n+                let input_ty = self.infer_expr(*expr, &Expectation::none());\n                 let expected = if expected.ty == Ty::Unknown {\n                     Expectation::has_type(self.new_type_var())\n                 } else {\n                     expected.clone()\n                 };\n-                let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let mut resulting_match_ty = None;\n-                let mut all_arms_never = !arms.is_empty();\n+                let mut arm_tys = Vec::with_capacity(arms.len());\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -1101,28 +1096,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n-                    let arm_ty = self.infer_expr(arm.expr, &expected);\n-                    if all_arms_never && Self::is_never(&arm_ty) {\n-                        tested_by!(match_first_arm_never);\n-                        resulting_match_ty = Some(arm_ty);\n-                    } else {\n-                        tested_by!(match_second_arm_never);\n-                        all_arms_never = false;\n-                        resulting_match_ty = None;\n-                    }\n-                }\n-\n-                if let (Ty::Infer(expected_tv), Some(match_ty)) =\n-                    (&expected.ty, &resulting_match_ty)\n-                {\n-                    tested_by!(match_all_arms_never);\n-                    self.var_unification_table\n-                        .union_value(expected_tv.to_inner(), TypeVarValue::Known(match_ty.clone()));\n-                    match_ty.clone()\n-                } else {\n-                    tested_by!(match_no_never_arms);\n-                    expected.ty\n+                    arm_tys.push(self.infer_expr(arm.expr, &expected));\n                 }\n+                calculate_least_upper_bound(expected.ty.clone(), arm_tys)\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1397,14 +1373,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n-    fn is_never(ty: &Ty) -> bool {\n-        if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) = ty {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     fn infer_block(\n         &mut self,\n         statements: &[Statement],\n@@ -1653,3 +1621,37 @@ mod diagnostics {\n         }\n     }\n }\n+\n+fn is_never(ty: &Ty) -> bool {\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) = ty {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn calculate_least_upper_bound(expected_ty: Ty, actual_tys: Vec<Ty>) -> Ty {\n+    let mut all_never = true;\n+    let mut last_never_ty = None;\n+    let mut least_upper_bound = expected_ty;\n+\n+    for actual_ty in actual_tys {\n+        if is_never(&actual_ty) {\n+            last_never_ty = Some(actual_ty);\n+        } else {\n+            all_never = false;\n+            least_upper_bound = match (&actual_ty, &least_upper_bound) {\n+                (_, Ty::Unknown)\n+                | (Ty::Infer(_), Ty::Infer(InferTy::TypeVar(_)))\n+                | (Ty::Apply(_), _) => actual_ty,\n+                _ => least_upper_bound,\n+            }\n+        }\n+    }\n+\n+    if all_never && last_never_ty.is_some() {\n+        last_never_ty.unwrap()\n+    } else {\n+        least_upper_bound\n+    }\n+}"}, {"sha": "a30a645ebb174fa50e2d0a08c4d808d1a00d6a01", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "patch": "@@ -3597,11 +3597,9 @@ fn no_such_field_diagnostics() {\n \n mod branching_with_never_tests {\n     use super::type_at;\n-    use test_utils::covers;\n \n     #[test]\n     fn match_first_arm_never() {\n-        covers!(match_first_arm_never);\n         let t = type_at(\n             r#\"\n //- /main.rs\n@@ -3622,7 +3620,6 @@ fn test(a: i32) {\n \n     #[test]\n     fn if_never() {\n-        covers!(if_never);\n         let t = type_at(\n             r#\"\n //- /main.rs\n@@ -3642,7 +3639,6 @@ fn test() {\n \n     #[test]\n     fn if_else_never() {\n-        covers!(if_else_never);\n         let t = type_at(\n             r#\"\n //- /main.rs\n@@ -3662,7 +3658,6 @@ fn test(input: bool) {\n \n     #[test]\n     fn match_second_arm_never() {\n-        covers!(match_second_arm_never);\n         let t = type_at(\n             r#\"\n //- /main.rs\n@@ -3683,7 +3678,6 @@ fn test(a: i32) {\n \n     #[test]\n     fn match_all_arms_never() {\n-        covers!(match_all_arms_never);\n         let t = type_at(\n             r#\"\n //- /main.rs\n@@ -3702,7 +3696,6 @@ fn test(a: i32) {\n \n     #[test]\n     fn match_no_never_arms() {\n-        covers!(match_no_never_arms);\n         let t = type_at(\n             r#\"\n //- /main.rs"}]}