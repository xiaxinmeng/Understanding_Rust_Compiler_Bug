{"sha": "da4b3768971c7c025ba8a85ebf59572fd752dfb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNGIzNzY4OTcxYzdjMDI1YmE4YTg1ZWJmNTk1NzJmZDc1MmRmYjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-25T08:52:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-30T03:54:55Z"}, "message": "std: Stop using oldcomm", "tree": {"sha": "e47abf6553bffeaaa35d682f74f0cc42df5e913e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e47abf6553bffeaaa35d682f74f0cc42df5e913e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da4b3768971c7c025ba8a85ebf59572fd752dfb6", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da4b3768971c7c025ba8a85ebf59572fd752dfb6", "html_url": "https://github.com/rust-lang/rust/commit/da4b3768971c7c025ba8a85ebf59572fd752dfb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da4b3768971c7c025ba8a85ebf59572fd752dfb6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87acde8826af4dfd8391cbccc48526381796dab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/87acde8826af4dfd8391cbccc48526381796dab3", "html_url": "https://github.com/rust-lang/rust/commit/87acde8826af4dfd8391cbccc48526381796dab3"}], "stats": {"total": 878, "additions": 429, "deletions": 449}, "files": [{"sha": "e50245168b1af5dbb060f693afe5f3152046b5da", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -483,7 +483,6 @@ mod tests {\n     use arc::*;\n     use arc;\n \n-    use core::oldcomm::*;\n     use core::option::{Some, None};\n     use core::option;\n     use core::pipes;"}, {"sha": "c190d08687af46ebb1e68037f103c7284b09fa38", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -38,7 +38,6 @@\n #[forbid(deprecated_mode)];\n \n use core::libc;\n-use core::oldcomm;\n use core::option;\n use core::prelude::*;\n use core::ptr;"}, {"sha": "839d0d23a61fa717049a1ba9ff1103efc26e2964", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -12,8 +12,8 @@\n #[forbid(deprecated_mode)];\n \n use core::libc;\n-use core::oldcomm;\n use core::prelude::*;\n+use core::pipes::{stream, SharedChan};\n use core::ptr;\n use core::result;\n use core::str;\n@@ -113,40 +113,40 @@ enum IpGetAddrErr {\n  * A `result<~[ip_addr], ip_get_addr_err>` instance that will contain\n  * a vector of `ip_addr` results, in the case of success, or an error\n  * object in the case of failure\n- */\n+*/\n pub fn get_addr(node: &str, iotask: &iotask)\n-        -> result::Result<~[IpAddr], IpGetAddrErr> {\n-    do oldcomm::listen |output_ch| {\n-        do str::as_buf(node) |node_ptr, len| {\n-            unsafe {\n-                log(debug, fmt!(\"slice len %?\", len));\n-                let handle = create_uv_getaddrinfo_t();\n-                let handle_ptr = ptr::addr_of(&handle);\n-                let handle_data = GetAddrData {\n-                    output_ch: output_ch\n-                };\n-                let handle_data_ptr = ptr::addr_of(&handle_data);\n-                do interact(iotask) |loop_ptr| {\n-                    unsafe {\n-                        let result = uv_getaddrinfo(\n-                            loop_ptr,\n-                            handle_ptr,\n-                            get_addr_cb,\n-                            node_ptr,\n-                            ptr::null(),\n-                            ptr::null());\n-                        match result {\n-                          0i32 => {\n+    -> result::Result<~[IpAddr], IpGetAddrErr> {\n+    let (output_po, output_ch) = stream();\n+    let output_ch = SharedChan(output_ch);\n+    do str::as_buf(node) |node_ptr, len| {\n+        unsafe {\n+            log(debug, fmt!(\"slice len %?\", len));\n+            let handle = create_uv_getaddrinfo_t();\n+            let handle_ptr = ptr::addr_of(&handle);\n+            let handle_data = GetAddrData {\n+                output_ch: output_ch.clone()\n+            };\n+            let handle_data_ptr = ptr::addr_of(&handle_data);\n+            do interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    let result = uv_getaddrinfo(\n+                        loop_ptr,\n+                        handle_ptr,\n+                        get_addr_cb,\n+                        node_ptr,\n+                        ptr::null(),\n+                        ptr::null());\n+                    match result {\n+                        0i32 => {\n                             set_data_for_req(handle_ptr, handle_data_ptr);\n-                          }\n-                          _ => {\n+                        }\n+                        _ => {\n                             output_ch.send(result::Err(GetAddrUnknownError));\n-                          }\n                         }\n                     }\n-                };\n-                output_ch.recv()\n-            }\n+                }\n+            };\n+            output_po.recv()\n         }\n     }\n }\n@@ -300,7 +300,7 @@ pub mod v6 {\n }\n \n struct GetAddrData {\n-    output_ch: oldcomm::Chan<result::Result<~[IpAddr],IpGetAddrErr>>\n+    output_ch: SharedChan<result::Result<~[IpAddr],IpGetAddrErr>>\n }\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n@@ -309,6 +309,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n         log(debug, ~\"in get_addr_cb\");\n         let handle_data = get_data_for_req(handle) as\n             *GetAddrData;\n+        let output_ch = (*handle_data).output_ch.clone();\n         if status == 0i32 {\n             if res != (ptr::null::<addrinfo>()) {\n                 let mut out_vec = ~[];\n@@ -326,7 +327,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                     else {\n                         log(debug, ~\"curr_addr is not of family AF_INET or \"+\n                             ~\"AF_INET6. Error.\");\n-                        (*handle_data).output_ch.send(\n+                        output_ch.send(\n                             result::Err(GetAddrUnknownError));\n                         break;\n                     };\n@@ -344,17 +345,17 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                 }\n                 log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n                                 vec::len(out_vec)));\n-                (*handle_data).output_ch.send(result::Ok(move out_vec));\n+                output_ch.send(result::Ok(move out_vec));\n             }\n             else {\n                 log(debug, ~\"addrinfo pointer is NULL\");\n-                (*handle_data).output_ch.send(\n+                output_ch.send(\n                     result::Err(GetAddrUnknownError));\n             }\n         }\n         else {\n             log(debug, ~\"status != 0 error in get_addr_cb\");\n-            (*handle_data).output_ch.send(\n+            output_ch.send(\n                 result::Err(GetAddrUnknownError));\n         }\n         if res != (ptr::null::<addrinfo>()) {"}, {"sha": "d9e4bfc540ccba46e19014d406c5e5c119238dde", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 276, "deletions": 303, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -23,7 +23,7 @@ use core::io::{Reader, ReaderUtil, Writer};\n use core::io;\n use core::libc::size_t;\n use core::libc;\n-use core::oldcomm;\n+use core::pipes::{stream, Chan, Port, SharedChan};\n use core::prelude::*;\n use core::ptr;\n use core::result::{Result};\n@@ -146,19 +146,22 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                iotask: &IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> {\n     unsafe {\n-        let result_po = oldcomm::Port::<ConnAttempt>();\n-        let closed_signal_po = oldcomm::Port::<()>();\n-        let conn_data = {\n-            result_ch: oldcomm::Chan(&result_po),\n-            closed_signal_ch: oldcomm::Chan(&closed_signal_po)\n+        let (result_po, result_ch) = stream::<ConnAttempt>();\n+        let result_ch = SharedChan(result_ch);\n+        let (closed_signal_po, closed_signal_ch) = stream::<()>();\n+        let closed_signal_ch = SharedChan(closed_signal_ch);\n+        let conn_data = ConnectReqData {\n+            result_ch: result_ch,\n+            closed_signal_ch: closed_signal_ch\n         };\n         let conn_data_ptr = ptr::addr_of(&conn_data);\n-        let reader_po = oldcomm::Port::<result::Result<~[u8], TcpErrData>>();\n+        let (reader_po, reader_ch) = stream::<Result<~[u8], TcpErrData>>();\n+        let reader_ch = SharedChan(reader_ch);\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n         let socket_data = @TcpSocketData {\n-            reader_po: reader_po,\n-            reader_ch: oldcomm::Chan(&reader_po),\n+            reader_po: @reader_po,\n+            reader_ch: reader_ch,\n             stream_handle_ptr: stream_handle_ptr,\n             connect_req: uv::ll::connect_t(),\n             write_req: uv::ll::write_t(),\n@@ -169,7 +172,6 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             iotask: iotask.clone()\n         };\n         let socket_data_ptr = ptr::addr_of(&(*socket_data));\n-        debug!(\"tcp_connect result_ch %?\", conn_data.result_ch);\n         // get an unsafe representation of our stream_handle_ptr that\n         // we can send into the interact cb to be handled in libuv..\n         debug!(\"stream_handle_ptr outside interact %?\",\n@@ -238,8 +240,9 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 // somesuch\n                                 let err_data =\n                                     uv::ll::get_last_err_data(loop_ptr);\n-                                oldcomm::send((*conn_data_ptr).result_ch,\n-                                              ConnFailure(err_data));\n+                                let result_ch = (*conn_data_ptr)\n+                                    .result_ch.clone();\n+                                result_ch.send(ConnFailure(err_data));\n                                 uv::ll::set_data_for_uv_handle(\n                                     stream_handle_ptr,\n                                     conn_data_ptr);\n@@ -251,19 +254,19 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                     _ => {\n                         // failure to create a tcp handle\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        oldcomm::send((*conn_data_ptr).result_ch,\n-                                      ConnFailure(err_data));\n+                        let result_ch = (*conn_data_ptr).result_ch.clone();\n+                        result_ch.send(ConnFailure(err_data));\n                     }\n                 }\n             }\n         }\n-        match oldcomm::recv(result_po) {\n+        match result_po.recv() {\n             ConnSuccess => {\n                 debug!(\"tcp::connect - received success on result_po\");\n                 result::Ok(TcpSocket(socket_data))\n             }\n             ConnFailure(ref err_data) => {\n-                oldcomm::recv(closed_signal_po);\n+                closed_signal_po.recv();\n                 debug!(\"tcp::connect - received failure on result_po\");\n                 // still have to free the malloc'd stream handle..\n                 rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n@@ -359,7 +362,7 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  * `tcp_err_data` record\n  */\n pub fn read_start(sock: &TcpSocket)\n-    -> result::Result<oldcomm::Port<\n+    -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n     unsafe {\n         let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n@@ -374,12 +377,9 @@ pub fn read_start(sock: &TcpSocket)\n  *\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n-pub fn read_stop(sock: &TcpSocket,\n-             read_port: oldcomm::Port<result::Result<~[u8], TcpErrData>>) ->\n+pub fn read_stop(sock: &TcpSocket) ->\n     result::Result<(), TcpErrData> {\n     unsafe {\n-        debug!(\n-            \"taking the read_port out of commission %?\", read_port);\n         let socket_data = ptr::addr_of(&(*sock.socket_data));\n         read_stop_common_impl(socket_data)\n     }\n@@ -519,14 +519,16 @@ pub fn accept(new_conn: TcpNewConnection)\n             NewTcpConn(server_handle_ptr) => {\n                 let server_data_ptr = uv::ll::get_data_for_uv_handle(\n                     server_handle_ptr) as *TcpListenFcData;\n-                let reader_po = oldcomm::Port();\n+                let (reader_po, reader_ch) = stream::<\n+                    Result<~[u8], TcpErrData>>();\n+                let reader_ch = SharedChan(reader_ch);\n                 let iotask = &(*server_data_ptr).iotask;\n                 let stream_handle_ptr = malloc_uv_tcp_t();\n                 *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n                     uv::ll::tcp_t();\n                 let client_socket_data: @TcpSocketData = @TcpSocketData {\n-                    reader_po: reader_po,\n-                    reader_ch: oldcomm::Chan(&reader_po),\n+                    reader_po: @reader_po,\n+                    reader_ch: reader_ch,\n                     stream_handle_ptr : stream_handle_ptr,\n                     connect_req : uv::ll::connect_t(),\n                     write_req : uv::ll::write_t(),\n@@ -538,8 +540,8 @@ pub fn accept(new_conn: TcpNewConnection)\n                 let client_stream_handle_ptr =\n                     (*client_socket_data_ptr).stream_handle_ptr;\n \n-                let result_po = oldcomm::Port::<Option<TcpErrData>>();\n-                let result_ch = oldcomm::Chan(&result_po);\n+                let (result_po, result_ch) = stream::<Option<TcpErrData>>();\n+                let result_ch = SharedChan(result_ch);\n \n                 // UNSAFE LIBUV INTERACTION BEGIN\n                 // .. normally this happens within the context of\n@@ -565,25 +567,25 @@ pub fn accept(new_conn: TcpNewConnection)\n                                     client_stream_handle_ptr,\n                                     client_socket_data_ptr\n                                     as *libc::c_void);\n-                                oldcomm::send(result_ch, None);\n+                                result_ch.send(None);\n                             }\n                             _ => {\n                                 log(debug, ~\"failed to accept client conn\");\n-                                oldcomm::send(result_ch, Some(\n+                                result_ch.send(Some(\n                                     uv::ll::get_last_err_data(\n                                         loop_ptr).to_tcp_err()));\n                             }\n                         }\n                     }\n                     _ => {\n                         log(debug, ~\"failed to accept client stream\");\n-                        oldcomm::send(result_ch, Some(\n+                        result_ch.send(Some(\n                             uv::ll::get_last_err_data(\n                                 loop_ptr).to_tcp_err()));\n                     }\n                 }\n                 // UNSAFE LIBUV INTERACTION END\n-                match oldcomm::recv(result_po) {\n+                match result_po.recv() {\n                     Some(copy err_data) => result::Err(err_data),\n                     None => result::Ok(TcpSocket(client_socket_data))\n                 }\n@@ -622,9 +624,9 @@ pub fn accept(new_conn: TcpNewConnection)\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n               iotask: &IoTask,\n-              on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n+              on_establish_cb: fn~(SharedChan<Option<TcpErrData>>),\n               new_connect_cb: fn~(TcpNewConnection,\n-                                  oldcomm::Chan<Option<TcpErrData>>))\n+                                  SharedChan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> {\n     do listen_common(move host_ip, port, backlog, iotask,\n                      move on_establish_cb)\n@@ -634,27 +636,28 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n                 as *TcpListenFcData;\n             let new_conn = NewTcpConn(handle);\n-            let kill_ch = (*server_data_ptr).kill_ch;\n+            let kill_ch = (*server_data_ptr).kill_ch.clone();\n             new_connect_cb(new_conn, kill_ch);\n         }\n     }\n }\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: &IoTask,\n-          on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n+          on_establish_cb: fn~(SharedChan<Option<TcpErrData>>),\n           on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> {\n     unsafe {\n-        let stream_closed_po = oldcomm::Port::<()>();\n-        let kill_po = oldcomm::Port::<Option<TcpErrData>>();\n-        let kill_ch = oldcomm::Chan(&kill_po);\n+        let (stream_closed_po, stream_closed_ch) = stream::<()>();\n+        let stream_closed_ch = SharedChan(stream_closed_ch);\n+        let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n+        let kill_ch = SharedChan(kill_ch);\n         let server_stream = uv::ll::tcp_t();\n         let server_stream_ptr = ptr::addr_of(&server_stream);\n         let server_data: TcpListenFcData = TcpListenFcData {\n             server_stream_ptr: server_stream_ptr,\n-            stream_closed_ch: oldcomm::Chan(&stream_closed_po),\n-            kill_ch: kill_ch,\n+            stream_closed_ch: stream_closed_ch,\n+            kill_ch: kill_ch.clone(),\n             on_connect_cb: move on_connect_cb,\n             iotask: iotask.clone(),\n             ipv6: match &host_ip {\n@@ -665,77 +668,78 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n         };\n         let server_data_ptr = ptr::addr_of(&server_data);\n \n-        let setup_result = do oldcomm::listen |setup_ch| {\n-            // this is to address a compiler warning about\n-            // an implicit copy.. it seems that double nested\n-            // will defeat a move sigil, as is done to the host_ip\n-            // arg above.. this same pattern works w/o complaint in\n-            // tcp::connect (because the iotask::interact cb isn't\n-            // nested within a core::comm::listen block)\n-            let loc_ip = copy(host_ip);\n-            do iotask::interact(iotask) |move loc_ip, loop_ptr| {\n-                unsafe {\n-                    match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-                        0i32 => {\n-                            uv::ll::set_data_for_uv_handle(\n-                                server_stream_ptr,\n-                                server_data_ptr);\n-                            let addr_str = ip::format_addr(&loc_ip);\n-                            let bind_result = match loc_ip {\n-                                ip::Ipv4(ref addr) => {\n-                                    log(debug, fmt!(\"addr: %?\", addr));\n-                                    let in_addr = uv::ll::ip4_addr(\n-                                        addr_str,\n-                                        port as int);\n-                                    uv::ll::tcp_bind(server_stream_ptr,\n-                                                     ptr::addr_of(&in_addr))\n-                                }\n-                                ip::Ipv6(ref addr) => {\n-                                    log(debug, fmt!(\"addr: %?\", addr));\n-                                    let in_addr = uv::ll::ip6_addr(\n-                                        addr_str,\n-                                        port as int);\n-                                    uv::ll::tcp_bind6(server_stream_ptr,\n-                                                      ptr::addr_of(&in_addr))\n-                                }\n-                            };\n-                            match bind_result {\n-                                0i32 => {\n-                                    match uv::ll::listen(\n-                                        server_stream_ptr,\n-                                        backlog as libc::c_int,\n-                                        tcp_lfc_on_connection_cb) {\n-                                        0i32 => oldcomm::send(setup_ch, None),\n-                                        _ => {\n-                                            log(debug,\n-                                                ~\"failure to uv_tcp_init\");\n-                                            let err_data =\n-                                                uv::ll::get_last_err_data(\n-                                                    loop_ptr);\n-                                            oldcomm::send(setup_ch,\n-                                                          Some(err_data));\n-                                        }\n+        let (setup_po, setup_ch) = stream();\n+\n+        // this is to address a compiler warning about\n+        // an implicit copy.. it seems that double nested\n+        // will defeat a move sigil, as is done to the host_ip\n+        // arg above.. this same pattern works w/o complaint in\n+        // tcp::connect (because the iotask::interact cb isn't\n+        // nested within a core::comm::listen block)\n+        let loc_ip = copy(host_ip);\n+        do iotask::interact(iotask) |move loc_ip, loop_ptr| {\n+            unsafe {\n+                match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+                    0i32 => {\n+                        uv::ll::set_data_for_uv_handle(\n+                            server_stream_ptr,\n+                            server_data_ptr);\n+                        let addr_str = ip::format_addr(&loc_ip);\n+                        let bind_result = match loc_ip {\n+                            ip::Ipv4(ref addr) => {\n+                                log(debug, fmt!(\"addr: %?\", addr));\n+                                let in_addr = uv::ll::ip4_addr(\n+                                    addr_str,\n+                                    port as int);\n+                                uv::ll::tcp_bind(server_stream_ptr,\n+                                                 ptr::addr_of(&in_addr))\n+                            }\n+                            ip::Ipv6(ref addr) => {\n+                                log(debug, fmt!(\"addr: %?\", addr));\n+                                let in_addr = uv::ll::ip6_addr(\n+                                    addr_str,\n+                                    port as int);\n+                                uv::ll::tcp_bind6(server_stream_ptr,\n+                                                  ptr::addr_of(&in_addr))\n+                            }\n+                        };\n+                        match bind_result {\n+                            0i32 => {\n+                                match uv::ll::listen(\n+                                    server_stream_ptr,\n+                                    backlog as libc::c_int,\n+                                    tcp_lfc_on_connection_cb) {\n+                                    0i32 => setup_ch.send(None),\n+                                    _ => {\n+                                        log(debug,\n+                                            ~\"failure to uv_tcp_init\");\n+                                        let err_data =\n+                                            uv::ll::get_last_err_data(\n+                                                loop_ptr);\n+                                        setup_ch.send(Some(err_data));\n                                     }\n                                 }\n-                                _ => {\n-                                    log(debug, ~\"failure to uv_tcp_bind\");\n-                                    let err_data = uv::ll::get_last_err_data(\n-                                        loop_ptr);\n-                                    oldcomm::send(setup_ch, Some(err_data));\n-                                }\n+                            }\n+                            _ => {\n+                                log(debug, ~\"failure to uv_tcp_bind\");\n+                                let err_data = uv::ll::get_last_err_data(\n+                                    loop_ptr);\n+                                setup_ch.send(Some(err_data));\n                             }\n                         }\n-                        _ => {\n-                            log(debug, ~\"failure to uv_tcp_bind\");\n-                            let err_data = uv::ll::get_last_err_data(\n-                                loop_ptr);\n-                            oldcomm::send(setup_ch, Some(err_data));\n-                        }\n+                    }\n+                    _ => {\n+                        log(debug, ~\"failure to uv_tcp_bind\");\n+                        let err_data = uv::ll::get_last_err_data(\n+                            loop_ptr);\n+                        setup_ch.send(Some(err_data));\n                     }\n                 }\n             }\n-            setup_ch.recv()\n-        };\n+        }\n+\n+        let setup_result = setup_po.recv();\n+\n         match setup_result {\n             Some(ref err_data) => {\n                 do iotask::interact(iotask) |loop_ptr| {\n@@ -767,8 +771,8 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n                 }\n             }\n             None => {\n-                on_establish_cb(kill_ch);\n-                let kill_result = oldcomm::recv(kill_po);\n+                on_establish_cb(kill_ch.clone());\n+                let kill_result = kill_po.recv();\n                 do iotask::interact(iotask) |loop_ptr| {\n                     unsafe {\n                         log(debug,\n@@ -816,14 +820,13 @@ pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n impl TcpSocket {\n-    pub fn read_start() -> result::Result<oldcomm::Port<\n+    pub fn read_start() -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(&self)\n     }\n-    pub fn read_stop(read_port:\n-                 oldcomm::Port<result::Result<~[u8], TcpErrData>>) ->\n+    pub fn read_stop() ->\n         result::Result<(), TcpErrData> {\n-        read_stop(&self, move read_port)\n+        read_stop(&self)\n     }\n     fn read(timeout_msecs: uint) ->\n         result::Result<~[u8], TcpErrData> {\n@@ -995,9 +998,9 @@ impl TcpSocketBuf: io::Writer {\n \n fn tear_down_socket_data(socket_data: @TcpSocketData) {\n     unsafe {\n-        let closed_po = oldcomm::Port::<()>();\n-        let closed_ch = oldcomm::Chan(&closed_po);\n-        let close_data = {\n+        let (closed_po, closed_ch) = stream::<()>();\n+        let closed_ch = SharedChan(closed_ch);\n+        let close_data = TcpSocketCloseData {\n             closed_ch: closed_ch\n         };\n         let close_data_ptr = ptr::addr_of(&close_data);\n@@ -1012,7 +1015,7 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n                 uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n             }\n         };\n-        oldcomm::recv(closed_po);\n+        closed_po.recv();\n         //the line below will most likely crash\n         //log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n@@ -1038,9 +1041,9 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n             log(debug, ~\"tcp::read before recv_timeout\");\n             let read_result = if timeout_msecs > 0u {\n                 timer::recv_timeout(\n-                    iotask, timeout_msecs, result::get(&rs_result))\n+                    iotask, timeout_msecs, result::unwrap(rs_result))\n             } else {\n-                Some(oldcomm::recv(result::get(&rs_result)))\n+                Some(result::get(&rs_result).recv())\n             };\n             log(debug, ~\"tcp::read after recv_timeout\");\n             match move read_result {\n@@ -1068,26 +1071,25 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n     result::Result<(), TcpErrData> {\n     unsafe {\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-        let stop_po = oldcomm::Port::<Option<TcpErrData>>();\n-        let stop_ch = oldcomm::Chan(&stop_po);\n+        let (stop_po, stop_ch) = stream::<Option<TcpErrData>>();\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n                 log(debug, ~\"in interact cb for tcp::read_stop\");\n                 match uv::ll::read_stop(stream_handle_ptr\n                                         as *uv::ll::uv_stream_t) {\n                     0i32 => {\n                         log(debug, ~\"successfully called uv_read_stop\");\n-                        oldcomm::send(stop_ch, None);\n+                        stop_ch.send(None);\n                     }\n                     _ => {\n                         log(debug, ~\"failure in calling uv_read_stop\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        oldcomm::send(stop_ch, Some(err_data.to_tcp_err()));\n+                        stop_ch.send(Some(err_data.to_tcp_err()));\n                     }\n                 }\n             }\n         }\n-        match oldcomm::recv(stop_po) {\n+        match stop_po.recv() {\n             Some(move err_data) => Err(err_data),\n             None => Ok(())\n         }\n@@ -1096,12 +1098,11 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n \n // shared impl for read_start\n fn read_start_common_impl(socket_data: *TcpSocketData)\n-    -> result::Result<oldcomm::Port<\n+    -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n     unsafe {\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-        let start_po = oldcomm::Port::<Option<uv::ll::uv_err_data>>();\n-        let start_ch = oldcomm::Chan(&start_po);\n+        let (start_po, start_ch) = stream::<Option<uv::ll::uv_err_data>>();\n         log(debug, ~\"in tcp::read_start before interact loop\");\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n@@ -1113,19 +1114,22 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n                                          on_tcp_read_cb) {\n                     0i32 => {\n                         log(debug, ~\"success doing uv_read_start\");\n-                        oldcomm::send(start_ch, None);\n+                        start_ch.send(None);\n                     }\n                     _ => {\n                         log(debug, ~\"error attempting uv_read_start\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        oldcomm::send(start_ch, Some(err_data));\n+                        start_ch.send(Some(err_data));\n                     }\n                 }\n             }\n         }\n-        match oldcomm::recv(start_po) {\n-            Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n-            None => result::Ok((*socket_data).reader_po)\n+        match start_po.recv() {\n+            Some(ref err_data) => result::Err(\n+                err_data.to_tcp_err()),\n+            None => {\n+                result::Ok((*socket_data).reader_po)\n+            }\n         }\n     }\n }\n@@ -1144,9 +1148,10 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n             vec::raw::to_ptr(raw_write_data),\n             vec::len(raw_write_data)) ];\n         let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n-        let result_po = oldcomm::Port::<TcpWriteResult>();\n-        let write_data = {\n-            result_ch: oldcomm::Chan(&result_po)\n+        let (result_po, result_ch) = stream::<TcpWriteResult>();\n+        let result_ch = SharedChan(result_ch);\n+        let write_data = WriteReqData {\n+            result_ch: result_ch\n         };\n         let write_data_ptr = ptr::addr_of(&write_data);\n         do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n@@ -1165,8 +1170,8 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n                     _ => {\n                         log(debug, ~\"error invoking uv_write()\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        oldcomm::send((*write_data_ptr).result_ch,\n-                                      TcpWriteError(err_data.to_tcp_err()));\n+                        let result_ch = (*write_data_ptr).result_ch.clone();\n+                        result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n                     }\n                 }\n             }\n@@ -1175,7 +1180,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         // and waiting here for the write to complete, we should transfer\n         // ownership of everything to the I/O task and let it deal with the\n         // aftermath, so we don't have to sit here blocking.\n-        match oldcomm::recv(result_po) {\n+        match result_po.recv() {\n             TcpWriteSuccess => Ok(()),\n             TcpWriteError(move err_data) => Err(err_data)\n         }\n@@ -1188,8 +1193,8 @@ enum TcpNewConnection {\n \n struct TcpListenFcData {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n-    stream_closed_ch: oldcomm::Chan<()>,\n-    kill_ch: oldcomm::Chan<Option<TcpErrData>>,\n+    stream_closed_ch: SharedChan<()>,\n+    kill_ch: SharedChan<Option<TcpErrData>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     ipv6: bool,\n@@ -1200,7 +1205,8 @@ extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             handle) as *TcpListenFcData;\n-        oldcomm::send((*server_data_ptr).stream_closed_ch, ());\n+        let stream_closed_ch = (*server_data_ptr).stream_closed_ch.clone();\n+        stream_closed_ch.send(());\n     }\n }\n \n@@ -1209,13 +1215,13 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     unsafe {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n             as *TcpListenFcData;\n-        let kill_ch = (*server_data_ptr).kill_ch;\n+        let kill_ch = (*server_data_ptr).kill_ch.clone();\n         if (*server_data_ptr).active {\n             match status {\n               0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n               _ => {\n                 let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-                oldcomm::send(kill_ch,\n+                kill_ch.send(\n                            Some(uv::ll::get_last_err_data(loop_ptr)\n                                 .to_tcp_err()));\n                 (*server_data_ptr).active = false;\n@@ -1243,7 +1249,7 @@ enum TcpWriteResult {\n }\n \n enum TcpReadStartResult {\n-    TcpReadStartSuccess(oldcomm::Port<TcpReadResult>),\n+    TcpReadStartSuccess(Port<TcpReadResult>),\n     TcpReadStartError(TcpErrData)\n }\n \n@@ -1278,19 +1284,19 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n             let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n             log(debug, fmt!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n                             err_data.err_name, err_data.err_msg));\n-            let reader_ch = (*socket_data_ptr).reader_ch;\n-            oldcomm::send(reader_ch, result::Err(err_data));\n+            let reader_ch = &(*socket_data_ptr).reader_ch;\n+            reader_ch.send(result::Err(err_data));\n           }\n           // do nothing .. unneeded buf\n           0 => (),\n           // have data\n           _ => {\n             // we have data\n             log(debug, fmt!(\"tcp on_read_cb nread: %d\", nread as int));\n-            let reader_ch = (*socket_data_ptr).reader_ch;\n+            let reader_ch = &(*socket_data_ptr).reader_ch;\n             let buf_base = uv::ll::get_base_from_buf(buf);\n             let new_bytes = vec::from_buf(buf_base, nread as uint);\n-            oldcomm::send(reader_ch, result::Ok(new_bytes));\n+            reader_ch.send(result::Ok(new_bytes));\n           }\n         }\n         uv::ll::free_base_of_buf(buf);\n@@ -1313,15 +1319,15 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n }\n \n struct TcpSocketCloseData {\n-    closed_ch: oldcomm::Chan<()>,\n+    closed_ch: SharedChan<()>,\n }\n \n extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n         let data = uv::ll::get_data_for_uv_handle(handle)\n             as *TcpSocketCloseData;\n-        let closed_ch = (*data).closed_ch;\n-        oldcomm::send(closed_ch, ());\n+        let closed_ch = (*data).closed_ch.clone();\n+        closed_ch.send(());\n         log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n     }\n }\n@@ -1333,33 +1339,35 @@ extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n             as *WriteReqData;\n         if status == 0i32 {\n             log(debug, ~\"successful write complete\");\n-            oldcomm::send((*write_data_ptr).result_ch, TcpWriteSuccess);\n+            let result_ch = (*write_data_ptr).result_ch.clone();\n+            result_ch.send(TcpWriteSuccess);\n         } else {\n             let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n                 write_req);\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             log(debug, ~\"failure to write\");\n-            oldcomm::send((*write_data_ptr).result_ch,\n-                             TcpWriteError(err_data.to_tcp_err()));\n+            let result_ch = (*write_data_ptr).result_ch.clone();\n+            result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n         }\n     }\n }\n \n struct WriteReqData {\n-    result_ch: oldcomm::Chan<TcpWriteResult>,\n+    result_ch: SharedChan<TcpWriteResult>,\n }\n \n struct ConnectReqData {\n-    result_ch: oldcomm::Chan<ConnAttempt>,\n-    closed_signal_ch: oldcomm::Chan<()>,\n+    result_ch: SharedChan<ConnAttempt>,\n+    closed_signal_ch: SharedChan<()>,\n }\n \n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n         let data = uv::ll::get_data_for_uv_handle(handle) as\n             *ConnectReqData;\n-        oldcomm::send((*data).closed_signal_ch, ());\n+        let closed_signal_ch = (*data).closed_signal_ch.clone();\n+        closed_signal_ch.send(());\n         log(debug, fmt!(\"exiting steam_error_close_cb for %?\", handle));\n     }\n }\n@@ -1375,22 +1383,22 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n     unsafe {\n         let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n                           as *ConnectReqData);\n-        let result_ch = (*conn_data_ptr).result_ch;\n+        let result_ch = (*conn_data_ptr).result_ch.clone();\n         log(debug, fmt!(\"tcp_connect result_ch %?\", result_ch));\n         let tcp_stream_ptr =\n             uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n         match status {\n           0i32 => {\n             log(debug, ~\"successful tcp connection!\");\n-            oldcomm::send(result_ch, ConnSuccess);\n+            result_ch.send(ConnSuccess);\n           }\n           _ => {\n             log(debug, ~\"error in tcp_connect_on_connect_cb\");\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             log(debug, fmt!(\"err_data %? %?\", err_data.err_name,\n                             err_data.err_msg));\n-            oldcomm::send(result_ch, ConnFailure(err_data));\n+            result_ch.send(ConnFailure(err_data));\n             uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n                                            conn_data_ptr);\n             uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n@@ -1406,8 +1414,8 @@ enum ConnAttempt {\n }\n \n struct TcpSocketData {\n-    reader_po: oldcomm::Port<result::Result<~[u8], TcpErrData>>,\n-    reader_ch: oldcomm::Chan<result::Result<~[u8], TcpErrData>>,\n+    reader_po: @Port<result::Result<~[u8], TcpErrData>>,\n+    reader_ch: SharedChan<result::Result<~[u8], TcpErrData>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -1431,7 +1439,7 @@ pub mod test {\n     use uv;\n \n     use core::io;\n-    use core::oldcomm;\n+    use core::pipes::{stream, Chan, Port, SharedChan};\n     use core::prelude::*;\n     use core::result;\n     use core::str;\n@@ -1546,39 +1554,33 @@ pub mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = oldcomm::Port::<~str>();\n-        let server_result_ch = oldcomm::Chan(&server_result_po);\n+        let (server_result_po, server_result_ch) = stream::<~str>();\n \n-        let cont_po = oldcomm::Port::<()>();\n-        let cont_ch = oldcomm::Chan(&cont_po);\n+        let (cont_po, cont_ch) = stream::<()>();\n+        let cont_ch = SharedChan(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do oldcomm::listen |server_ch| {\n-                run_tcp_test_server(\n-                    server_ip,\n-                    server_port,\n-                    expected_resp,\n-                    server_ch,\n-                    cont_ch,\n-                    &hl_loop_clone)\n-            };\n+            let cont_ch = cont_ch.clone();\n+            let actual_req = run_tcp_test_server(\n+                server_ip,\n+                server_port,\n+                expected_resp,\n+                cont_ch.clone(),\n+                &hl_loop_clone);\n             server_result_ch.send(actual_req);\n         };\n-        oldcomm::recv(cont_po);\n+        cont_po.recv();\n         // client\n         debug!(\"server started, firing up client..\");\n-        let actual_resp_result = do oldcomm::listen |client_ch| {\n-            run_tcp_test_client(\n-                server_ip,\n-                server_port,\n-                expected_req,\n-                client_ch,\n-                hl_loop)\n-        };\n+        let actual_resp_result = run_tcp_test_client(\n+            server_ip,\n+            server_port,\n+            expected_req,\n+            hl_loop);\n         assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n-        let actual_req = oldcomm::recv(server_result_po);\n+        let actual_req = server_result_po.recv();\n         debug!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n@@ -1592,50 +1594,41 @@ pub mod test {\n         let server_port = 8887u;\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = oldcomm::Port::<~str>();\n-        let server_result_ch = oldcomm::Chan(&server_result_po);\n-\n-        let cont_po = oldcomm::Port::<()>();\n-        let cont_ch = oldcomm::Chan(&cont_po);\n+        let (cont_po, cont_ch) = stream::<()>();\n+        let cont_ch = SharedChan(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do oldcomm::listen |server_ch| {\n-                run_tcp_test_server(\n-                    server_ip,\n-                    server_port,\n-                    expected_resp,\n-                    server_ch,\n-                    cont_ch,\n-                    &hl_loop_clone)\n-            };\n-            server_result_ch.send(actual_req);\n+            let cont_ch = cont_ch.clone();\n+            run_tcp_test_server(\n+                server_ip,\n+                server_port,\n+                expected_resp,\n+                cont_ch.clone(),\n+                &hl_loop_clone);\n         };\n-        oldcomm::recv(cont_po);\n+        cont_po.recv();\n         // client\n         debug!(\"server started, firing up client..\");\n-        do oldcomm::listen |client_ch| {\n-            let server_ip_addr = ip::v4::parse_addr(server_ip);\n-            let iotask = uv::global_loop::get();\n-            let connect_result = connect(move server_ip_addr, server_port,\n-                                         &iotask);\n-\n-            let sock = result::unwrap(move connect_result);\n-\n-            debug!(\"testing peer address\");\n-            // This is what we are actually testing!\n-            assert net::ip::format_addr(&sock.get_peer_addr()) ==\n-                ~\"127.0.0.1\";\n-            assert net::ip::get_port(&sock.get_peer_addr()) == 8887;\n-\n-            // Fulfill the protocol the test server expects\n-            let resp_bytes = str::to_bytes(~\"ping\");\n-            tcp_write_single(&sock, resp_bytes);\n-            debug!(\"message sent\");\n-            let read_result = sock.read(0u);\n-            client_ch.send(str::from_bytes(read_result.get()));\n-            debug!(\"result read\");\n-        };\n+        let server_ip_addr = ip::v4::parse_addr(server_ip);\n+        let iotask = uv::global_loop::get();\n+        let connect_result = connect(move server_ip_addr, server_port,\n+                                     &iotask);\n+\n+        let sock = result::unwrap(move connect_result);\n+\n+        debug!(\"testing peer address\");\n+        // This is what we are actually testing!\n+        assert net::ip::format_addr(&sock.get_peer_addr()) ==\n+            ~\"127.0.0.1\";\n+        assert net::ip::get_port(&sock.get_peer_addr()) == 8887;\n+\n+        // Fulfill the protocol the test server expects\n+        let resp_bytes = str::to_bytes(~\"ping\");\n+        tcp_write_single(&sock, resp_bytes);\n+        debug!(\"message sent\");\n+        sock.read(0u);\n+        debug!(\"result read\");\n     }\n     pub fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1644,14 +1637,11 @@ pub mod test {\n         let expected_req = ~\"ping\";\n         // client\n         debug!(\"firing up client..\");\n-        let actual_resp_result = do oldcomm::listen |client_ch| {\n-            run_tcp_test_client(\n-                server_ip,\n-                server_port,\n-                expected_req,\n-                client_ch,\n-                hl_loop)\n-        };\n+        let actual_resp_result = run_tcp_test_client(\n+            server_ip,\n+            server_port,\n+            expected_req,\n+            hl_loop);\n         match actual_resp_result.get_err() {\n           ConnectionRefused => (),\n           _ => fail ~\"unknown error.. expected connection_refused\"\n@@ -1664,41 +1654,32 @@ pub mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = oldcomm::Port::<~str>();\n-        let server_result_ch = oldcomm::Chan(&server_result_po);\n-\n-        let cont_po = oldcomm::Port::<()>();\n-        let cont_ch = oldcomm::Chan(&cont_po);\n+        let (cont_po, cont_ch) = stream::<()>();\n+        let cont_ch = SharedChan(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do oldcomm::listen |server_ch| {\n-                run_tcp_test_server(\n-                    server_ip,\n-                    server_port,\n-                    expected_resp,\n-                    server_ch,\n-                    cont_ch,\n-                    &hl_loop_clone)\n-            };\n-            server_result_ch.send(actual_req);\n-        };\n-        oldcomm::recv(cont_po);\n+            let cont_ch = cont_ch.clone();\n+            run_tcp_test_server(\n+                server_ip,\n+                server_port,\n+                expected_resp,\n+                cont_ch.clone(),\n+                &hl_loop_clone);\n+        }\n+        cont_po.recv();\n         // this one should fail..\n         let listen_err = run_tcp_test_server_fail(\n                             server_ip,\n                             server_port,\n                             hl_loop);\n         // client.. just doing this so that the first server tears down\n         debug!(\"server started, firing up client..\");\n-        do oldcomm::listen |client_ch| {\n-            run_tcp_test_client(\n-                server_ip,\n-                server_port,\n-                expected_req,\n-                client_ch,\n-                hl_loop)\n-        };\n+        run_tcp_test_client(\n+            server_ip,\n+            server_port,\n+            expected_req,\n+            hl_loop);\n         match listen_err {\n           AddressInUse => {\n             assert true;\n@@ -1736,26 +1717,23 @@ pub mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = oldcomm::Port::<~str>();\n-        let server_result_ch = oldcomm::Chan(&server_result_po);\n+        let (server_result_po, server_result_ch) = stream::<~str>();\n \n-        let cont_po = oldcomm::Port::<()>();\n-        let cont_ch = oldcomm::Chan(&cont_po);\n+        let (cont_po, cont_ch) = stream::<()>();\n+        let cont_ch = SharedChan(cont_ch);\n         // server\n         let iotask_clone = iotask.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do oldcomm::listen |server_ch| {\n-                run_tcp_test_server(\n-                    server_ip,\n-                    server_port,\n-                    expected_resp,\n-                    server_ch,\n-                    cont_ch,\n-                    &iotask_clone)\n-            };\n+            let cont_ch = cont_ch.clone();\n+            let actual_req = run_tcp_test_server(\n+                server_ip,\n+                server_port,\n+                expected_resp,\n+                cont_ch.clone(),\n+                &iotask_clone);\n             server_result_ch.send(actual_req);\n         };\n-        oldcomm::recv(cont_po);\n+        cont_po.recv();\n         // client\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, iotask);\n@@ -1770,7 +1748,7 @@ pub mod test {\n             buf_read(sock_buf, resp_buf.len())\n         };\n \n-        let actual_req = oldcomm::recv(server_result_po);\n+        let actual_req = server_result_po.recv();\n         log(debug, fmt!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req));\n         log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n@@ -1788,26 +1766,20 @@ pub mod test {\n         let expected_req = ~\"GET /\";\n         let expected_resp = ~\"A string\\nwith multiple lines\\n\";\n \n-        let server_result_po = oldcomm::Port::<~str>();\n-        let server_result_ch = oldcomm::Chan(&server_result_po);\n-\n-        let cont_po = oldcomm::Port::<()>();\n-        let cont_ch = oldcomm::Chan(&cont_po);\n+        let (cont_po, cont_ch) = stream::<()>();\n+        let cont_ch = SharedChan(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do oldcomm::listen |server_ch| {\n-                run_tcp_test_server(\n-                    server_ip,\n-                    server_port,\n-                    expected_resp,\n-                    server_ch,\n-                    cont_ch,\n-                    &hl_loop_clone)\n-            };\n-            server_result_ch.send(actual_req);\n+            let cont_ch = cont_ch.clone();\n+            run_tcp_test_server(\n+                server_ip,\n+                server_port,\n+                expected_resp,\n+                cont_ch.clone(),\n+                &hl_loop_clone);\n         };\n-        oldcomm::recv(cont_po);\n+        cont_po.recv();\n         // client\n         debug!(\"server started, firing up client..\");\n         let server_addr = ip::v4::parse_addr(server_ip);\n@@ -1841,22 +1813,25 @@ pub mod test {\n     }\n \n     fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n-                          server_ch: oldcomm::Chan<~str>,\n-                          cont_ch: oldcomm::Chan<()>,\n+                          cont_ch: SharedChan<()>,\n                           iotask: &IoTask) -> ~str {\n+        let (server_po, server_ch) = stream::<~str>();\n+        let server_ch = SharedChan(server_ch);\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                debug!(\"establish_cb %?\", kill_ch);\n-                oldcomm::send(cont_ch, ());\n+                debug!(\"establish_cb %?\",\n+                    kill_ch);\n+                cont_ch.send(());\n             },\n             // risky to run this on the loop, but some users\n             // will want the POWER\n             |new_conn, kill_ch| {\n-            debug!(\"SERVER: new connection!\");\n-            do oldcomm::listen |cont_ch| {\n+                debug!(\"SERVER: new connection!\");\n+                let (cont_po, cont_ch) = stream();\n+                let server_ch = server_ch.clone();\n                 do task::spawn_sched(task::ManualThreads(1u)) {\n                     debug!(\"SERVER: starting worker for new req\");\n \n@@ -1865,8 +1840,9 @@ pub mod test {\n                     if result::is_err(&accept_result) {\n                         debug!(\"SERVER: error accept connection\");\n                         let err_data = result::get_err(&accept_result);\n-                        oldcomm::send(kill_ch, Some(err_data));\n-                        debug!(\"SERVER/WORKER: send on err cont ch\");\n+                        kill_ch.send(Some(err_data));\n+                        debug!(\n+                            \"SERVER/WORKER: send on err cont ch\");\n                         cont_ch.send(());\n                     }\n                     else {\n@@ -1889,22 +1865,20 @@ pub mod test {\n                             debug!(\"SERVER: before write\");\n                             tcp_write_single(&sock, str::to_bytes(resp));\n                             debug!(\"SERVER: after write.. die\");\n-                            oldcomm::send(kill_ch, None);\n+                            kill_ch.send(None);\n                           }\n                           result::Err(move err_data) => {\n                             debug!(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg);\n-                            oldcomm::send(kill_ch, Some(err_data));\n+                            kill_ch.send(Some(err_data));\n                             server_ch.send(~\"\");\n                           }\n                         }\n                         debug!(\"SERVER: worker spinning down\");\n                     }\n                 }\n                 debug!(\"SERVER: waiting to recv on cont_ch\");\n-                cont_ch.recv()\n-            };\n-            debug!(\"SERVER: recv'd on cont_ch..leaving listen cb\");\n+                cont_po.recv();\n         });\n         // err check on listen_result\n         if result::is_err(&listen_result) {\n@@ -1921,7 +1895,7 @@ pub mod test {\n               }\n             }\n         }\n-        let ret_val = server_ch.recv();\n+        let ret_val = server_po.recv();\n         debug!(\"SERVER: exited and got return val: '%s'\", ret_val);\n         ret_val\n     }\n@@ -1949,7 +1923,6 @@ pub mod test {\n     }\n \n     fn run_tcp_test_client(server_ip: &str, server_port: uint, resp: &str,\n-                          client_ch: oldcomm::Chan<~str>,\n                           iotask: &IoTask) -> result::Result<~str,\n                                                     TcpConnectErrData> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n@@ -1972,9 +1945,9 @@ pub mod test {\n                 Ok(~\"\")\n             }\n             else {\n-                client_ch.send(str::from_bytes(read_result.get()));\n-                let ret_val = client_ch.recv();\n-                debug!(\"CLIENT: after client_ch recv ret: '%s'\", ret_val);\n+                let ret_val = str::from_bytes(read_result.get());\n+                debug!(\"CLIENT: after client_ch recv ret: '%s'\",\n+                   ret_val);\n                 Ok(ret_val)\n             }\n         }"}, {"sha": "58bc32b71af69be8d3be19395ddc63de3dfa322c", "filename": "src/libstd/test.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -27,7 +27,7 @@ use core::either;\n use core::io::WriterUtil;\n use core::io;\n use core::libc::size_t;\n-use core::oldcomm;\n+use core::pipes::{stream, Chan, Port, SharedChan};\n use core::option;\n use core::prelude::*;\n use core::result;\n@@ -305,8 +305,8 @@ fn run_tests(opts: &TestOpts,\n     let mut wait_idx = 0;\n     let mut done_idx = 0;\n \n-    let p = oldcomm::Port();\n-    let ch = oldcomm::Chan(&p);\n+    let (p, ch) = stream();\n+    let ch = SharedChan(ch);\n \n     while done_idx < total {\n         while wait_idx < concurrency && run_idx < total {\n@@ -317,12 +317,12 @@ fn run_tests(opts: &TestOpts,\n                 // that hang forever.\n                 callback(TeWait(copy test));\n             }\n-            run_test(move test, ch);\n+            run_test(move test, ch.clone());\n             wait_idx += 1;\n             run_idx += 1;\n         }\n \n-        let (test, result) = oldcomm::recv(p);\n+        let (test, result) = p.recv();\n         if concurrency != 1 {\n             callback(TeWait(copy test));\n         }\n@@ -406,9 +406,9 @@ struct TestFuture {\n     wait: fn@() -> TestResult,\n }\n \n-pub fn run_test(test: TestDesc, monitor_ch: oldcomm::Chan<MonitorMsg>) {\n+pub fn run_test(test: TestDesc, monitor_ch: SharedChan<MonitorMsg>) {\n     if test.ignore {\n-        oldcomm::send(monitor_ch, (copy test, TrIgnored));\n+        monitor_ch.send((copy test, TrIgnored));\n         return;\n     }\n \n@@ -420,7 +420,7 @@ pub fn run_test(test: TestDesc, monitor_ch: oldcomm::Chan<MonitorMsg>) {\n         }).spawn(move testfn);\n         let task_result = option::unwrap(move result_future).recv();\n         let test_result = calc_result(&test, task_result == task::Success);\n-        oldcomm::send(monitor_ch, (copy test, test_result));\n+        monitor_ch.send((copy test, test_result));\n     };\n }\n \n@@ -440,7 +440,7 @@ mod tests {\n     use test::{TestOpts, run_test};\n \n     use core::either;\n-    use core::oldcomm;\n+    use core::pipes::{stream, SharedChan};\n     use core::option;\n     use core::vec;\n \n@@ -453,10 +453,10 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let p = oldcomm::Port();\n-        let ch = oldcomm::Chan(&p);\n+        let (p, ch) = stream();\n+        let ch = SharedChan(ch);\n         run_test(desc, ch);\n-        let (_, res) = oldcomm::recv(p);\n+        let (_, res) = p.recv();\n         assert res != TrOk;\n     }\n \n@@ -469,10 +469,10 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let p = oldcomm::Port();\n-        let ch = oldcomm::Chan(&p);\n+        let (p, ch) = stream();\n+        let ch = SharedChan(ch);\n         run_test(desc, ch);\n-        let (_, res) = oldcomm::recv(p);\n+        let (_, res) = p.recv();\n         assert res == TrIgnored;\n     }\n \n@@ -486,10 +486,10 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let p = oldcomm::Port();\n-        let ch = oldcomm::Chan(&p);\n+        let (p, ch) = stream();\n+        let ch = SharedChan(ch);\n         run_test(desc, ch);\n-        let (_, res) = oldcomm::recv(p);\n+        let (_, res) = p.recv();\n         assert res == TrOk;\n     }\n \n@@ -502,10 +502,10 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let p = oldcomm::Port();\n-        let ch = oldcomm::Chan(&p);\n+        let (p, ch) = stream();\n+        let ch = SharedChan(ch);\n         run_test(desc, ch);\n-        let (_, res) = oldcomm::recv(p);\n+        let (_, res) = p.recv();\n         assert res == TrFailed;\n     }\n "}, {"sha": "b967f92a22ebdc48c77fa633901aa82f39adcd30", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -18,7 +18,9 @@ use uv::iotask::IoTask;\n \n use core::either;\n use core::libc;\n-use core::oldcomm;\n+use core::libc::c_void;\n+use core::cast::transmute;\n+use core::pipes::{stream, Chan, SharedChan, Port, select2i};\n use core::prelude::*;\n use core::ptr;\n use core;\n@@ -41,12 +43,11 @@ use core;\n  */\n pub fn delayed_send<T: Owned>(iotask: &IoTask,\n                               msecs: uint,\n-                              ch: oldcomm::Chan<T>,\n+                              ch: &Chan<T>,\n                               val: T) {\n         unsafe {\n-            let timer_done_po = oldcomm::Port::<()>();\n-            let timer_done_ch = oldcomm::Chan(&timer_done_po);\n-            let timer_done_ch_ptr = ptr::addr_of(&timer_done_ch);\n+            let (timer_done_po, timer_done_ch) = stream::<()>();\n+            let timer_done_ch = SharedChan(timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(&timer);\n             do iotask::interact(iotask) |loop_ptr| {\n@@ -56,9 +57,15 @@ pub fn delayed_send<T: Owned>(iotask: &IoTask,\n                         let start_result = uv::ll::timer_start(\n                             timer_ptr, delayed_send_cb, msecs, 0u);\n                         if (start_result == 0i32) {\n+                            // Note: putting the channel into a ~\n+                            // to cast to *c_void\n+                            let timer_done_ch_clone = ~timer_done_ch.clone();\n+                            let timer_done_ch_ptr = transmute::<\n+                                ~SharedChan<()>, *c_void>(\n+                                timer_done_ch_clone);\n                             uv::ll::set_data_for_uv_handle(\n                                 timer_ptr,\n-                                timer_done_ch_ptr as *libc::c_void);\n+                                timer_done_ch_ptr);\n                         } else {\n                             let error_msg = uv::ll::get_last_err_info(\n                                 loop_ptr);\n@@ -73,11 +80,11 @@ pub fn delayed_send<T: Owned>(iotask: &IoTask,\n                 }\n             };\n             // delayed_send_cb has been processed by libuv\n-            oldcomm::recv(timer_done_po);\n+            timer_done_po.recv();\n             // notify the caller immediately\n-            oldcomm::send(ch, move(val));\n+            ch.send(val);\n             // uv_close for this timer has been processed\n-            oldcomm::recv(timer_done_po);\n+            timer_done_po.recv();\n     };\n }\n \n@@ -93,10 +100,9 @@ pub fn delayed_send<T: Owned>(iotask: &IoTask,\n  * * msecs - an amount of time, in milliseconds, for the current task to block\n  */\n pub fn sleep(iotask: &IoTask, msecs: uint) {\n-    let exit_po = oldcomm::Port::<()>();\n-    let exit_ch = oldcomm::Chan(&exit_po);\n-    delayed_send(iotask, msecs, exit_ch, ());\n-    oldcomm::recv(exit_po);\n+    let (exit_po, exit_ch) = stream::<()>();\n+    delayed_send(iotask, msecs, &exit_ch, ());\n+    exit_po.recv();\n }\n \n /**\n@@ -121,20 +127,17 @@ pub fn sleep(iotask: &IoTask, msecs: uint) {\n  */\n pub fn recv_timeout<T: Copy Owned>(iotask: &IoTask,\n                                    msecs: uint,\n-                                   wait_po: oldcomm::Port<T>)\n+                                   wait_po: &Port<T>)\n                                 -> Option<T> {\n-    let timeout_po = oldcomm::Port::<()>();\n-    let timeout_ch = oldcomm::Chan(&timeout_po);\n-    delayed_send(iotask, msecs, timeout_ch, ());\n+    let (timeout_po, timeout_ch) = stream::<()>();\n+    delayed_send(iotask, msecs, &timeout_ch, ());\n     // FIXME: This could be written clearer (#2618)\n     either::either(\n-        |left_val| {\n-            log(debug, fmt!(\"recv_time .. left_val %?\",\n-                           left_val));\n+        |_| {\n             None\n-        }, |right_val| {\n-            Some(*right_val)\n-        }, &oldcomm::select2(timeout_po, wait_po)\n+        }, |_| {\n+            Some(wait_po.recv())\n+        }, &select2i(&timeout_po, wait_po)\n     )\n }\n \n@@ -144,11 +147,14 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n     unsafe {\n         log(debug,\n             fmt!(\"delayed_send_cb handle %? status %?\", handle, status));\n-        let timer_done_ch =\n-            *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n+        // Faking a borrowed pointer to our ~SharedChan\n+        let timer_done_ch_ptr: &*c_void = &uv::ll::get_data_for_uv_handle(\n+            handle);\n+        let timer_done_ch_ptr = transmute::<&*c_void, &~SharedChan<()>>(\n+            timer_done_ch_ptr);\n         let stop_result = uv::ll::timer_stop(handle);\n         if (stop_result == 0i32) {\n-            oldcomm::send(timer_done_ch, ());\n+            timer_done_ch_ptr.send(());\n             uv::ll::close(handle, delayed_send_close_cb);\n         } else {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n@@ -161,9 +167,10 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) {\n     unsafe {\n         log(debug, fmt!(\"delayed_send_close_cb handle %?\", handle));\n-        let timer_done_ch =\n-            *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n-        oldcomm::send(timer_done_ch, ());\n+        let timer_done_ch_ptr = uv::ll::get_data_for_uv_handle(handle);\n+        let timer_done_ch = transmute::<*c_void, ~SharedChan<()>>(\n+            timer_done_ch_ptr);\n+        timer_done_ch.send(());\n     }\n }\n \n@@ -175,9 +182,9 @@ mod test {\n     use uv;\n \n     use core::iter;\n-    use core::oldcomm;\n     use core::rand;\n     use core::task;\n+    use core::pipes::{stream, SharedChan};\n \n     #[test]\n     pub fn test_gl_timer_simple_sleep_test() {\n@@ -195,8 +202,8 @@ mod test {\n \n     #[test]\n     pub fn test_gl_timer_sleep_stress2() {\n-        let po = oldcomm::Port();\n-        let ch = oldcomm::Chan(&po);\n+        let (po, ch) = stream();\n+        let ch = SharedChan(ch);\n         let hl_loop = &uv::global_loop::get();\n \n         let repeat = 20u;\n@@ -210,22 +217,24 @@ mod test {\n \n         for iter::repeat(repeat) {\n \n+            let ch = ch.clone();\n             for spec.each |spec| {\n                 let (times, maxms) = *spec;\n+                let ch = ch.clone();\n                 let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use rand::*;\n                     let rng = Rng();\n                     for iter::repeat(times) {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n-                    oldcomm::send(ch, ());\n+                    ch.send(());\n                 }\n             }\n         }\n \n         for iter::repeat(repeat * spec.len()) {\n-            oldcomm::recv(po)\n+            po.recv()\n         }\n     }\n \n@@ -246,14 +255,13 @@ mod test {\n             task::yield();\n \n             let expected = rand::rng().gen_str(16u);\n-            let test_po = core::comm::port::<str>();\n-            let test_ch = core::comm::chan(test_po);\n+            let (test_po, test_ch) = stream::<~str>();\n \n             do task::spawn() {\n-                delayed_send(hl_loop, 1u, test_ch, expected);\n+                delayed_send(hl_loop, 1u, &test_ch, expected);\n             };\n \n-            match recv_timeout(hl_loop, 10u, test_po) {\n+            match recv_timeout(hl_loop, 10u, &test_po) {\n               Some(val) => {\n                 assert val == expected;\n                 successes += 1;\n@@ -274,14 +282,13 @@ mod test {\n \n         for iter::repeat(times as uint) {\n             let expected = rand::Rng().gen_str(16u);\n-            let test_po = oldcomm::Port::<~str>();\n-            let test_ch = oldcomm::Chan(&test_po);\n+            let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {\n-                delayed_send(&hl_loop_clone, 50u, test_ch, expected);\n+                delayed_send(&hl_loop_clone, 50u, &test_ch, expected);\n             };\n \n-            match recv_timeout(&hl_loop, 1u, test_po) {\n+            match recv_timeout(&hl_loop, 1u, &test_po) {\n               None => successes += 1,\n               _ => failures += 1\n             };"}, {"sha": "6fcbccf8183c338ab1031e994e474a557d341bd9", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -209,16 +209,17 @@ mod test {\n \n     use core::iter;\n     use core::libc;\n-    use core::oldcomm;\n     use core::ptr;\n     use core::task;\n+    use core::pipes::{stream, Chan, SharedChan, Port};\n \n     extern fn async_close_cb(handle: *ll::uv_async_t) {\n         unsafe {\n             log(debug, fmt!(\"async_close_cb handle %?\", handle));\n-            let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n+            let exit_ch = &(*(ll::get_data_for_uv_handle(handle)\n                             as *AhData)).exit_ch;\n-            oldcomm::send(exit_ch, ());\n+            let exit_ch = exit_ch.clone();\n+            exit_ch.send(());\n         }\n     }\n     extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int) {\n@@ -230,17 +231,16 @@ mod test {\n     }\n     struct AhData {\n         iotask: IoTask,\n-        exit_ch: oldcomm::Chan<()>\n+        exit_ch: SharedChan<()>\n     }\n     fn impl_uv_iotask_async(iotask: &IoTask) {\n         unsafe {\n             let async_handle = ll::async_t();\n             let ah_ptr = ptr::addr_of(&async_handle);\n-            let exit_po = oldcomm::Port::<()>();\n-            let exit_ch = oldcomm::Chan(&exit_po);\n+            let (exit_po, exit_ch) = stream::<()>();\n             let ah_data = AhData {\n                 iotask: iotask.clone(),\n-                exit_ch: exit_ch\n+                exit_ch: SharedChan(exit_ch)\n             };\n             let ah_data_ptr: *AhData = unsafe {\n                 ptr::to_unsafe_ptr(&ah_data)\n@@ -256,13 +256,13 @@ mod test {\n                 }\n             };\n             debug!(\"waiting for async close\");\n-            oldcomm::recv(exit_po);\n+            exit_po.recv();\n         }\n     }\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n-    unsafe fn spawn_test_loop(exit_ch: oldcomm::Chan<()>) -> IoTask {\n+    unsafe fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n         let (iotask_port, iotask_ch) = stream::<IoTask>();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             debug!(\"about to run a test loop\");\n@@ -287,9 +287,8 @@ mod test {\n     #[test]\n     fn test_uv_iotask_async() {\n         unsafe {\n-            let exit_po = oldcomm::Port::<()>();\n-            let exit_ch = oldcomm::Chan(&exit_po);\n-            let iotask = &spawn_test_loop(exit_ch);\n+            let (exit_po, exit_ch) = stream::<()>();\n+            let iotask = &spawn_test_loop(~exit_ch);\n \n             debug!(\"spawned iotask\");\n \n@@ -300,24 +299,25 @@ mod test {\n             // race-condition type situations.. this ensures that the\n             // loop lives until, at least, all of the\n             // impl_uv_hl_async() runs have been called, at least.\n-            let work_exit_po = oldcomm::Port::<()>();\n-            let work_exit_ch = oldcomm::Chan(&work_exit_po);\n+            let (work_exit_po, work_exit_ch) = stream::<()>();\n+            let work_exit_ch = SharedChan(work_exit_ch);\n             for iter::repeat(7u) {\n                 let iotask_clone = iotask.clone();\n+                let work_exit_ch_clone = work_exit_ch.clone();\n                 do task::spawn_sched(task::ManualThreads(1u)) {\n                     debug!(\"async\");\n                     impl_uv_iotask_async(&iotask_clone);\n                     debug!(\"done async\");\n-                    oldcomm::send(work_exit_ch, ());\n+                    work_exit_ch_clone.send(());\n                 };\n             };\n             for iter::repeat(7u) {\n                 debug!(\"waiting\");\n-                oldcomm::recv(work_exit_po);\n+                work_exit_po.recv();\n             };\n             log(debug, ~\"sending teardown_loop msg..\");\n             exit(iotask);\n-            oldcomm::recv(exit_po);\n+            exit_po.recv();\n             log(debug, ~\"after recv on exit_po.. exiting..\");\n         }\n     }"}, {"sha": "8bef6eb6c91864b03fef66930c537c1d7d9b1387", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4b3768971c7c025ba8a85ebf59572fd752dfb6/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=da4b3768971c7c025ba8a85ebf59572fd752dfb6", "patch": "@@ -39,6 +39,7 @@ use core::ptr::to_unsafe_ptr;\n use core::ptr;\n use core::str;\n use core::vec;\n+use core::pipes::{stream, Chan, SharedChan, Port};\n \n // libuv struct mappings\n pub struct uv_ip4_addr {\n@@ -1132,7 +1133,6 @@ pub mod test {\n     use uv_ll::*;\n \n     use core::libc;\n-    use core::oldcomm;\n     use core::ptr;\n     use core::str;\n     use core::sys;\n@@ -1148,7 +1148,7 @@ pub mod test {\n     struct request_wrapper {\n         write_req: *uv_write_t,\n         req_buf: *~[uv_buf_t],\n-        read_chan: *oldcomm::Chan<~str>,\n+        read_chan: SharedChan<~str>,\n     }\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n@@ -1187,9 +1187,9 @@ pub mod test {\n                 let buf_base = get_base_from_buf(buf);\n                 let buf_len = get_len_from_buf(buf);\n                 let bytes = vec::from_buf(buf_base, buf_len as uint);\n-                let read_chan = *((*client_data).read_chan);\n+                let read_chan = (*client_data).read_chan.clone();\n                 let msg_from_server = str::from_bytes(bytes);\n-                oldcomm::send(read_chan, msg_from_server);\n+                read_chan.send(msg_from_server);\n                 close(stream as *libc::c_void, after_close_cb)\n             }\n             else if (nread == -1) {\n@@ -1257,7 +1257,7 @@ pub mod test {\n     }\n \n     fn impl_uv_tcp_request(ip: &str, port: int, req_str: &str,\n-                          client_chan: *oldcomm::Chan<~str>) {\n+                          client_chan: SharedChan<~str>) {\n         unsafe {\n             let test_loop = loop_new();\n             let tcp_handle = tcp_t();\n@@ -1283,9 +1283,11 @@ pub mod test {\n             log(debug, fmt!(\"tcp req: tcp stream: %d write_handle: %d\",\n                              tcp_handle_ptr as int,\n                              write_handle_ptr as int));\n-            let client_data = { writer_handle: write_handle_ptr,\n-                        req_buf: ptr::addr_of(&req_msg),\n-                        read_chan: client_chan };\n+            let client_data = request_wrapper {\n+                write_req: write_handle_ptr,\n+                req_buf: ptr::addr_of(&req_msg),\n+                read_chan: client_chan\n+            };\n \n             let tcp_init_result = tcp_init(\n                 test_loop as *libc::c_void, tcp_handle_ptr);\n@@ -1388,8 +1390,8 @@ pub mod test {\n                     log(debug, ~\"SERVER: client req contains kill_msg!\");\n                     log(debug, ~\"SERVER: sending response to client\");\n                     read_stop(client_stream_ptr);\n-                    let server_chan = *((*client_data).server_chan);\n-                    oldcomm::send(server_chan, request_str);\n+                    let server_chan = (*client_data).server_chan.clone();\n+                    server_chan.send(request_str);\n                     let write_result = write(\n                         write_req,\n                         client_stream_ptr as *libc::c_void,\n@@ -1484,12 +1486,12 @@ pub mod test {\n         server: *uv_tcp_t,\n         server_kill_msg: ~str,\n         server_resp_buf: *~[uv_buf_t],\n-        server_chan: *oldcomm::Chan<~str>,\n+        server_chan: SharedChan<~str>,\n         server_write_req: *uv_write_t,\n     }\n \n     struct async_handle_data {\n-        continue_chan: *oldcomm::Chan<bool>,\n+        continue_chan: SharedChan<bool>,\n     }\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n@@ -1506,9 +1508,9 @@ pub mod test {\n             // do its thang\n             let data = get_data_for_uv_handle(\n                 async_handle as *libc::c_void) as *async_handle_data;\n-            let continue_chan = *((*data).continue_chan);\n+            let continue_chan = (*data).continue_chan.clone();\n             let should_continue = status == 0i32;\n-            oldcomm::send(continue_chan, should_continue);\n+            continue_chan.send(should_continue);\n             close(async_handle as *libc::c_void, async_close_cb);\n         }\n     }\n@@ -1517,8 +1519,8 @@ pub mod test {\n                           server_port: int,\n                           +kill_server_msg: ~str,\n                           +server_resp_msg: ~str,\n-                          server_chan: *oldcomm::Chan<~str>,\n-                          continue_chan: *oldcomm::Chan<bool>) {\n+                          server_chan: SharedChan<~str>,\n+                          continue_chan: SharedChan<bool>) {\n         unsafe {\n             let test_loop = loop_new();\n             let tcp_server = tcp_t();\n@@ -1626,36 +1628,35 @@ pub mod test {\n             let port = 8886;\n             let kill_server_msg = ~\"does a dog have buddha nature?\";\n             let server_resp_msg = ~\"mu!\";\n-            let client_port = oldcomm::Port::<~str>();\n-            let client_chan = oldcomm::Chan::<~str>(&client_port);\n-            let server_port = oldcomm::Port::<~str>();\n-            let server_chan = oldcomm::Chan::<~str>(&server_port);\n+            let (client_port, client_chan) = stream::<~str>();\n+            let client_chan = SharedChan(client_chan);\n+            let (server_port, server_chan) = stream::<~str>();\n+            let server_chan = SharedChan(server_chan);\n \n-            let continue_port = oldcomm::Port::<bool>();\n-            let continue_chan = oldcomm::Chan::<bool>(&continue_port);\n-            let continue_chan_ptr = ptr::addr_of(&continue_chan);\n+            let (continue_port, continue_chan) = stream::<bool>();\n+            let continue_chan = SharedChan(continue_chan);\n \n             do task::spawn_sched(task::ManualThreads(1)) {\n                 impl_uv_tcp_server(bind_ip, port,\n                                    kill_server_msg,\n                                    server_resp_msg,\n-                                   ptr::addr_of(&server_chan),\n-                                   continue_chan_ptr);\n+                                   server_chan.clone(),\n+                                   continue_chan.clone());\n             };\n \n             // block until the server up is.. possibly a race?\n             log(debug, ~\"before receiving on server continue_port\");\n-            oldcomm::recv(continue_port);\n+            continue_port.recv();\n             log(debug, ~\"received on continue port, set up tcp client\");\n \n             do task::spawn_sched(task::ManualThreads(1u)) {\n                 impl_uv_tcp_request(request_ip, port,\n                                    kill_server_msg,\n-                                   ptr::addr_of(&client_chan));\n+                                   client_chan.clone());\n             };\n \n-            let msg_from_client = oldcomm::recv(server_port);\n-            let msg_from_server = oldcomm::recv(client_port);\n+            let msg_from_client = server_port.recv();\n+            let msg_from_server = client_port.recv();\n \n             assert str::contains(msg_from_client, kill_server_msg);\n             assert str::contains(msg_from_server, server_resp_msg);"}]}