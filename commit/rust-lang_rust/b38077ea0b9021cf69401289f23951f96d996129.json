{"sha": "b38077ea0b9021cf69401289f23951f96d996129", "node_id": "C_kwDOAAsO6NoAKGIzODA3N2VhMGI5MDIxY2Y2OTQwMTI4OWYyMzk1MWY5NmQ5OTYxMjk", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-02-21T21:43:15Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-02T10:20:56Z"}, "message": "change thir to use mir::ConstantKind instead of ty::Const", "tree": {"sha": "5826cef7324a41cee97dc8c4c3f311e9fcb624e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5826cef7324a41cee97dc8c4c3f311e9fcb624e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b38077ea0b9021cf69401289f23951f96d996129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b38077ea0b9021cf69401289f23951f96d996129", "html_url": "https://github.com/rust-lang/rust/commit/b38077ea0b9021cf69401289f23951f96d996129", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b38077ea0b9021cf69401289f23951f96d996129/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d843171d10b4b3f0847cc45933cfca8f99a4c63", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d843171d10b4b3f0847cc45933cfca8f99a4c63", "html_url": "https://github.com/rust-lang/rust/commit/9d843171d10b4b3f0847cc45933cfca8f99a4c63"}], "stats": {"total": 646, "additions": 534, "deletions": 112}, "files": [{"sha": "80f0a0b8b5ba3c3464ac08440d37c6541b3cf4d0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -2327,7 +2327,6 @@ dependencies = [\n  \"compiletest_rs\",\n  \"env_logger 0.9.0\",\n  \"getrandom 0.2.0\",\n- \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n  \"measureme 9.1.2\","}, {"sha": "d321dc28d8568d56cbc9b88a9219071bfd4120d4", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -172,6 +172,40 @@ pub(crate) fn try_destructure_const<'tcx>(\n     Ok(mir::DestructuredConst { variant, fields })\n }\n \n+pub(crate) fn destructure_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    val: mir::ConstantKind<'tcx>,\n+) -> mir::DestructuredMirConstant<'tcx> {\n+    trace!(\"destructure_const: {:?}\", val);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let op = ecx.mir_const_to_op(&val, None).unwrap();\n+\n+    // We go to `usize` as we cannot allocate anything bigger anyway.\n+    let (field_count, variant, down) = match val.ty().kind() {\n+        ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n+        ty::Adt(def, _) if def.variants.is_empty() => {\n+            return mir::DestructuredMirConstant { variant: None, fields: &[] };\n+        }\n+        ty::Adt(def, _) => {\n+            let variant = ecx.read_discriminant(&op).unwrap().1;\n+            let down = ecx.operand_downcast(&op, variant).unwrap();\n+            (def.variants[variant].fields.len(), Some(variant), down)\n+        }\n+        ty::Tuple(substs) => (substs.len(), None, op),\n+        _ => bug!(\"cannot destructure constant {:?}\", val),\n+    };\n+\n+    let fields_iter = (0..field_count).map(|i| {\n+        let field_op = ecx.operand_field(&down, i).unwrap();\n+        let val = op_to_const(&ecx, &field_op);\n+        mir::ConstantKind::Val(val, field_op.layout.ty)\n+    });\n+    let fields = tcx.arena.alloc_from_iter(fields_iter);\n+\n+    mir::DestructuredMirConstant { variant, fields }\n+}\n+\n pub(crate) fn deref_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -207,3 +241,39 @@ pub(crate) fn deref_const<'tcx>(\n \n     tcx.mk_const(ty::ConstS { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n }\n+\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(crate) fn deref_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    val: mir::ConstantKind<'tcx>,\n+) -> mir::ConstantKind<'tcx> {\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let op = ecx.mir_const_to_op(&val, None).unwrap();\n+    let mplace = ecx.deref_operand(&op).unwrap();\n+    if let Some(alloc_id) = mplace.ptr.provenance {\n+        assert_eq!(\n+            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().mutability,\n+            Mutability::Not,\n+            \"deref_const cannot be used with mutable allocations as \\\n+            that could allow pattern matching to observe mutable statics\",\n+        );\n+    }\n+\n+    let ty = match mplace.meta {\n+        MemPlaceMeta::None => mplace.layout.ty,\n+        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n+        // In case of unsized types, figure out the real type behind.\n+        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n+            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n+            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            _ => bug!(\n+                \"type {} should not have metadata, but had {:?}\",\n+                mplace.layout.ty,\n+                mplace.meta\n+            ),\n+        },\n+    };\n+\n+    mir::ConstantKind::Val(op_to_const(&ecx, &mplace.into()), ty)\n+}"}, {"sha": "493c8ec5fdd0c5e7f9e156e6d5c3e331a2f4e531", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -45,6 +45,10 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::try_destructure_const(tcx, param_env, value).ok()\n     };\n+    providers.destructure_mir_constant = |tcx, param_env_and_value| {\n+        let (param_env, value) = param_env_and_value.into_parts();\n+        const_eval::destructure_mir_constant(tcx, param_env, value)\n+    };\n     providers.const_to_valtree = |tcx, param_env_and_value| {\n         let (param_env, raw) = param_env_and_value.into_parts();\n         const_eval::const_to_valtree(tcx, param_env, raw)\n@@ -53,4 +57,8 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_const(tcx, param_env, value)\n     };\n+    providers.deref_mir_constant = |tcx, param_env_and_value| {\n+        let (param_env, value) = param_env_and_value.into_parts();\n+        const_eval::deref_mir_constant(tcx, param_env, value)\n+    }\n }"}, {"sha": "785df763b1c8bc826f6bbb54b0eb749dc7fb8864", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 201, "deletions": 9, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -9,13 +9,13 @@ use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::subst::{Subst, SubstsRef};\n+use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::{AdtDef, InstanceDef, Region, ScalarInt, UserTypeAnnotationIndex};\n \n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::{CtorKind, Namespace};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, GeneratorKind};\n use rustc_hir::{self as hir, HirId};\n use rustc_session::Session;\n@@ -2664,6 +2664,16 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n+    pub fn try_val(&self) -> Option<ConstValue<'tcx>> {\n+        match self {\n+            ConstantKind::Ty(c) => match c.val() {\n+                ty::ConstKind::Value(v) => Some(v),\n+                _ => None,\n+            },\n+            ConstantKind::Val(v, _) => Some(*v),\n+        }\n+    }\n+\n     #[inline]\n     pub fn try_to_value(self) -> Option<interpret::ConstValue<'tcx>> {\n         match self {\n@@ -2692,6 +2702,32 @@ impl<'tcx> ConstantKind<'tcx> {\n         self.try_to_scalar_int()?.try_into().ok()\n     }\n \n+    #[inline]\n+    pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n+        match self {\n+            Self::Ty(c) => {\n+                // FIXME Need to use a different evaluation function that directly returns a `ConstValue`\n+                // if evaluation succeeds and does not create a ValTree first\n+                if let Some(val) = c.val().try_eval(tcx, param_env) {\n+                    match val {\n+                        Ok(val) => Self::Val(val, c.ty()),\n+                        Err(ErrorReported) => Self::Ty(tcx.const_error(self.ty())),\n+                    }\n+                } else {\n+                    self\n+                }\n+            }\n+            Self::Val(_, _) => self,\n+        }\n+    }\n+\n+    #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n+    pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n+        self.try_eval_bits(tcx, param_env, ty)\n+            .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n+    }\n+\n     #[inline]\n     pub fn try_eval_bits(\n         &self,\n@@ -2726,25 +2762,181 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n+    pub fn from_bits(\n+        tcx: TyCtxt<'tcx>,\n+        bits: u128,\n+        param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Self {\n+        let size = tcx\n+            .layout_of(param_env_ty)\n+            .unwrap_or_else(|e| {\n+                bug!(\"could not compute layout for {:?}: {:?}\", param_env_ty.value, e)\n+            })\n+            .size;\n+        let cv = ConstValue::Scalar(Scalar::from_uint(bits, size));\n+\n+        Self::Val(cv, param_env_ty.value)\n+    }\n+\n     pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> Self {\n         let cv = ConstValue::from_bool(v);\n         Self::Val(cv, tcx.types.bool)\n     }\n \n-    pub fn from_zero_sized(ty: Ty<'tcx>) -> Self {\n+    pub fn zero_sized(ty: Ty<'tcx>) -> Self {\n         let cv = ConstValue::Scalar(Scalar::ZST);\n         Self::Val(cv, ty)\n     }\n \n     pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> Self {\n         let ty = tcx.types.usize;\n-        let size = tcx\n-            .layout_of(ty::ParamEnv::empty().and(ty))\n-            .unwrap_or_else(|e| bug!(\"could not compute layout for {:?}: {:?}\", ty, e))\n-            .size;\n-        let cv = ConstValue::Scalar(Scalar::from_uint(n as u128, size));\n+        Self::from_bits(tcx, n as u128, ty::ParamEnv::empty().and(ty))\n+    }\n \n-        Self::Val(cv, ty)\n+    #[instrument(skip(tcx), level = \"debug\")]\n+    pub fn try_eval_lit_or_param(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Option<Self> {\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => {\n+                Some(interpret::LitToConstInput { lit: &lit.node, ty, neg: false })\n+            }\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(interpret::LitToConstInput { lit: &lit.node, ty, neg: true })\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(lit_input) = lit_input {\n+            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n+            // mir.\n+            match tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n+                Ok(c) => return Some(c),\n+                Err(e) => {\n+                    tcx.sess.delay_span_bug(\n+                        expr.span,\n+                        &format!(\"Const::from_anon_const: couldn't lit_to_const {:?}\", e),\n+                    );\n+                }\n+            }\n+        }\n+        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n+        match expr.kind {\n+            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n+                // Find the name and index of the const parameter by indexing the generics of\n+                // the parent item and construct a `ParamConst`.\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+                let item_id = tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n+                let generics = tcx.generics_of(item_def_id.to_def_id());\n+                let index = generics.param_def_id_to_index[&def_id];\n+                let name = tcx.hir().name(hir_id);\n+                let ty_const = tcx.mk_const(ty::ConstS {\n+                    val: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n+                    ty,\n+                });\n+\n+                Some(Self::Ty(ty_const))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    #[instrument(skip(tcx), level = \"debug\")]\n+    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_inline_const can only process anonymous constants\"\n+            ),\n+        };\n+\n+        let expr = &tcx.hir().body(body_id).value;\n+\n+        let ty = tcx.typeck(def_id).node_type(hir_id);\n+\n+        let ret = match Self::try_eval_lit_or_param(tcx, ty, expr) {\n+            Some(v) => v,\n+            None => {\n+                let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n+                let parent_substs =\n+                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n+                let substs = ty::InlineConstSubsts::new(\n+                    tcx,\n+                    ty::InlineConstSubstsParts { parent_substs, ty },\n+                )\n+                .substs;\n+                let ty_const = tcx.mk_const(ty::ConstS {\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n+                        def: ty::WithOptConstParam::unknown(def_id).to_global(),\n+                        substs,\n+                        promoted: None,\n+                    }),\n+                    ty,\n+                });\n+\n+                Self::Ty(ty_const)\n+            }\n+        };\n+        debug_assert!(!ret.has_free_regions());\n+        ret\n+    }\n+\n+    /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n+    /// converted to a constant, everything else becomes `Unevaluated`.\n+    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n+        Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+    }\n+\n+    #[instrument(skip(tcx), level = \"debug\")]\n+    fn from_opt_const_arg_anon_const(\n+        tcx: TyCtxt<'tcx>,\n+        def: ty::WithOptConstParam<LocalDefId>,\n+    ) -> Self {\n+        let body_id = match tcx.hir().get_by_def_id(def.did) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def.did.to_def_id()),\n+                \"from_anon_const can only process anonymous constants\"\n+            ),\n+        };\n+\n+        let expr = &tcx.hir().body(body_id).value;\n+        debug!(?expr);\n+\n+        let ty = tcx.type_of(def.def_id_for_type_of());\n+\n+        match Self::try_eval_lit_or_param(tcx, ty, expr) {\n+            Some(v) => v,\n+            None => {\n+                let ty_const = tcx.mk_const(ty::ConstS {\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n+                        def: def.to_global(),\n+                        substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+                        promoted: None,\n+                    }),\n+                    ty,\n+                });\n+                Self::Ty(ty_const)\n+            }\n+        }\n     }\n }\n "}, {"sha": "978ed55c4e48ecca2308d1d6db73d2cbface2eef", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{Body, Promoted};\n+use crate::mir::{self, Body, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n@@ -421,6 +421,13 @@ pub struct DestructuredConst<'tcx> {\n     pub fields: &'tcx [ty::Const<'tcx>],\n }\n \n+/// The constituent parts of an ADT or array.\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct DestructuredMirConstant<'tcx> {\n+    pub variant: Option<VariantIdx>,\n+    pub fields: &'tcx [mir::ConstantKind<'tcx>],\n+}\n+\n /// Coverage information summarized from a MIR if instrumented for source code coverage (see\n /// compiler option `-Cinstrument-coverage`). This information is generated by the\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query."}, {"sha": "3d783a0d64c29e6bb398c9eb10623837d604e095", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -940,6 +940,13 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n+    /// Destructure an `mir::ConstantKind` ADT or array into its variant index\n+    /// and its field values.\n+    query destructure_mir_constant(key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>) -> mir::DestructuredMirConstant<'tcx> {\n+        desc { \"destructure mir constant\"}\n+        remap_env_constness\n+    }\n+\n     /// Dereference a constant reference or raw pointer and turn the result into a constant\n     /// again.\n     query deref_const(\n@@ -949,6 +956,15 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n+    /// Dereference a constant reference or raw pointer and turn the result into a constant\n+    /// again.\n+    query deref_mir_constant(\n+        key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n+    ) -> mir::ConstantKind<'tcx> {\n+        desc { \"deref constant\" }\n+        remap_env_constness\n+    }\n+\n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n         desc { \"get a &core::panic::Location referring to a span\" }\n     }\n@@ -960,6 +976,10 @@ rustc_queries! {\n         desc { \"converting literal to const\" }\n     }\n \n+    query lit_to_mir_constant(key: LitToConstInput<'tcx>) -> Result<mir::ConstantKind<'tcx>, LitToConstError> {\n+        desc { \"converting literal to mir constant\" }\n+    }\n+\n     query check_match(key: DefId) {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }"}, {"sha": "e4e3424cb893395edaa1c98a88614d192ebcc65a", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -19,11 +19,11 @@ use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::AllocId;\n use rustc_middle::mir::{\n-    BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp, UserTypeProjection,\n+    self, BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp, UserTypeProjection,\n };\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtDef, Const, Ty, UpvarSubsts, UserType};\n+use rustc_middle::ty::{self, AdtDef, Ty, UpvarSubsts, UserType};\n use rustc_middle::ty::{\n     CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n };\n@@ -193,7 +193,7 @@ pub enum StmtKind<'tcx> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 104);\n+rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n \n /// A THIR expression.\n #[derive(Debug, HashStable)]\n@@ -375,7 +375,7 @@ pub enum ExprKind<'tcx> {\n     /// An array literal constructed from one repeated element, e.g. `[1; 5]`.\n     Repeat {\n         value: ExprId,\n-        count: Const<'tcx>,\n+        count: ty::Const<'tcx>,\n     },\n     /// An array, e.g. `[a, b, c, d]`.\n     Array {\n@@ -522,7 +522,7 @@ pub enum InlineAsmOperand<'tcx> {\n         out_expr: Option<ExprId>,\n     },\n     Const {\n-        value: Const<'tcx>,\n+        value: mir::ConstantKind<'tcx>,\n         span: Span,\n     },\n     SymFn {\n@@ -661,7 +661,7 @@ pub enum PatKind<'tcx> {\n     /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n     ///   `PartialEq` and `Eq`.\n     Constant {\n-        value: ty::Const<'tcx>,\n+        value: mir::ConstantKind<'tcx>,\n     },\n \n     Range(PatRange<'tcx>),\n@@ -691,8 +691,8 @@ pub enum PatKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct PatRange<'tcx> {\n-    pub lo: ty::Const<'tcx>,\n-    pub hi: ty::Const<'tcx>,\n+    pub lo: mir::ConstantKind<'tcx>,\n+    pub hi: mir::ConstantKind<'tcx>,\n     pub end: RangeEnd,\n }\n "}, {"sha": "4cd195d29646f6f593f3634ea262c6eea00559c5", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -22,7 +22,7 @@ pub enum CastKind {\n /// A node of an `AbstractConst`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum Node<'tcx> {\n-    Leaf(ty::Const<'tcx>),\n+    Leaf(mir::ConstantKind<'tcx>),\n     Binop(mir::BinOp, NodeId, NodeId),\n     UnaryOp(mir::UnOp, NodeId),\n     FunctionCall(NodeId, &'tcx [NodeId]),"}, {"sha": "d052898991ddbe1341193d8b896932bc7c6d4944", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -1,6 +1,8 @@\n use super::{\n     Arm, Block, Expr, ExprKind, Guard, InlineAsmOperand, Pat, PatKind, Stmt, StmtKind, Thir,\n };\n+use crate::mir::ConstantKind;\n+use crate::ty::Const;\n \n pub trait Visitor<'a, 'tcx: 'a>: Sized {\n     fn thir(&self) -> &'a Thir<'tcx>;\n@@ -24,6 +26,8 @@ pub trait Visitor<'a, 'tcx: 'a>: Sized {\n     fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n         walk_pat(self, pat);\n     }\n+\n+    fn visit_constant(&mut self, _constant: ConstantKind<'tcx>) {}\n }\n \n pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n@@ -90,8 +94,13 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                 visitor.visit_expr(&visitor.thir()[value])\n             }\n         }\n+<<<<<<< HEAD\n         ConstBlock { did: _, substs: _ } => {}\n         Repeat { value, count: _ } => {\n+=======\n+        ConstBlock { value } => visitor.visit_constant(value),\n+        Repeat { value, count } => {\n+>>>>>>> 6064f16d846 (change thir to use mir::ConstantKind instead of ty::Const)\n             visitor.visit_expr(&visitor.thir()[value]);\n         }\n         Array { ref fields } | Tuple { ref fields } => {"}, {"sha": "26dc1a073666193c0a6028b4135eaeeb8b61e19d", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -126,7 +126,7 @@ impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n     /// return `None`.\n-    pub(super) fn try_eval(\n+    pub fn try_eval(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,"}, {"sha": "960f9c0acd48ddc427eb2a2c6edb68dd97c6aa9d", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -662,8 +662,8 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n impl<'tcx> Ty<'tcx> {\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<Const<'tcx>> {\n-        let val = match self.kind() {\n+    pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<u128> {\n+        match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n                 let val =\n@@ -676,14 +676,13 @@ impl<'tcx> Ty<'tcx> {\n                 ty::FloatTy::F64 => rustc_apfloat::ieee::Double::INFINITY.to_bits(),\n             }),\n             _ => None,\n-        };\n-        val.map(|v| Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+        }\n     }\n \n     /// Returns the minimum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<Const<'tcx>> {\n-        let val = match self.kind() {\n+    pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<u128> {\n+        match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n                 let val = if signed { size.truncate(size.signed_int_min() as u128) } else { 0 };\n@@ -695,8 +694,7 @@ impl<'tcx> Ty<'tcx> {\n                 ty::FloatTy::F64 => (-::rustc_apfloat::ieee::Double::INFINITY).to_bits(),\n             }),\n             _ => None,\n-        };\n-        val.map(|v| Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+        }\n     }\n \n     /// Checks whether values of this type `T` are *moved* or *copied*"}, {"sha": "ac92b03e5f38541252edf65b91ff69ffa93315ff", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> CFG<'tcx> {\n             Rvalue::Use(Operand::Constant(Box::new(Constant {\n                 span: source_info.span,\n                 user_ty: None,\n-                literal: ConstantKind::from_zero_sized(tcx.types.unit),\n+                literal: ConstantKind::zero_sized(tcx.types.unit),\n             }))),\n         );\n     }"}, {"sha": "00d26c5e12c9214e1a7efecf856255faf7067442", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -85,6 +85,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 Constant { span, user_ty: None, literal }\n             }\n+            ExprKind::ConstBlock { value } => {\n+                Constant { span: span, user_ty: None, literal: value }\n+            }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }"}, {"sha": "be777418433a5cf04fc2ce3b7671363952879138", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Constant(Box::new(Constant {\n                     span: expr_span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(this.tcx, this.tcx.types.unit).into(),\n+                    literal: ConstantKind::zero_sized(this.tcx.types.unit),\n                 }))))\n             }\n             ExprKind::Yield { .. }\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(ty);\n         let size = self.tcx.layout_of(param_ty).unwrap().size;\n-        let literal = ty::Const::from_bits(self.tcx, size.unsigned_int_max(), param_ty);\n+        let literal = ConstantKind::from_bits(self.tcx, size.unsigned_int_max(), param_ty);\n \n         self.literal_operand(span, literal)\n     }\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(ty);\n         let bits = self.tcx.layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n-        let literal = ty::Const::from_bits(self.tcx, n, param_ty);\n+        let literal = ConstantKind::from_bits(self.tcx, n, param_ty);\n \n         self.literal_operand(span, literal)\n     }"}, {"sha": "23bd085f6f674e32b11cd02a6091e05f15450080", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -964,13 +964,13 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: FxIndexMap<ty::Const<'tcx>, u128>,\n+        options: FxIndexMap<ConstantKind<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n     /// `ty`,\n     Eq {\n-        value: ty::Const<'tcx>,\n+        value: ConstantKind<'tcx>,\n         // Integer types are handled by `SwitchInt`, and constants with ADT\n         // types are converted back into patterns, so this can only be `&str`,\n         // `&[T]`, `f32` or `f64`."}, {"sha": "895df5808dbe16c6eb0cbb2abbeecab6d35c9598", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -228,9 +228,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => (None, 0),\n                 };\n                 if let Some((min, max, sz)) = range {\n-                    if let (Some(lo), Some(hi)) =\n-                        (lo.val().try_to_bits(sz), hi.val().try_to_bits(sz))\n-                    {\n+                    if let (Some(lo), Some(hi)) = (lo.try_to_bits(sz), hi.try_to_bits(sz)) {\n                         // We want to compare ranges numerically, but the order of the bitwise\n                         // representation of signed integers does not match their numeric order.\n                         // Thus, to correct the ordering, we need to shift the range of signed"}, {"sha": "983987f0799c343986d966e29c2752aa7f2ae23b", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut FxIndexMap<ty::Const<'tcx>, u128>,\n+        options: &mut FxIndexMap<ConstantKind<'tcx>, u128>,\n     ) -> bool {\n         let Some(match_pair) = candidate.match_pairs.iter().find(|mp| mp.place == *test_place) else {\n             return false;\n@@ -366,7 +366,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n-        value: ty::Const<'tcx>,\n+        value: ConstantKind<'tcx>,\n         place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n@@ -760,7 +760,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(match_pair.pattern.span, \"simplifyable pattern found: {:?}\", match_pair.pattern)\n     }\n \n-    fn const_range_contains(&self, range: PatRange<'tcx>, value: ty::Const<'tcx>) -> Option<bool> {\n+    fn const_range_contains(\n+        &self,\n+        range: PatRange<'tcx>,\n+        value: ConstantKind<'tcx>,\n+    ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n         let tcx = self.tcx;\n@@ -777,7 +781,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        options: &FxIndexMap<ty::Const<'tcx>, u128>,\n+        options: &FxIndexMap<ConstantKind<'tcx>, u128>,\n     ) -> Option<bool> {\n         for &val in options.keys() {\n             if self.const_range_contains(range, val)? {\n@@ -823,7 +827,7 @@ fn trait_method<'tcx>(\n     method_name: Symbol,\n     self_ty: Ty<'tcx>,\n     params: &[GenericArg<'tcx>],\n-) -> ty::Const<'tcx> {\n+) -> ConstantKind<'tcx> {\n     let substs = tcx.mk_substs_trait(self_ty, params);\n \n     // The unhygienic comparison here is acceptable because this is only\n@@ -836,5 +840,6 @@ fn trait_method<'tcx>(\n \n     let method_ty = tcx.type_of(item.def_id);\n     let method_ty = method_ty.subst(tcx, substs);\n-    ty::Const::zero_sized(tcx, method_ty)\n+\n+    ConstantKind::zero_sized(method_ty)\n }"}, {"sha": "8b1ab482ee8be109c1aa2eb8727f1eec592631b9", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -25,16 +25,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(&mut self, span: Span, literal: ty::Const<'tcx>) -> Operand<'tcx> {\n-        let literal = literal.into();\n+    crate fn literal_operand(&mut self, span: Span, literal: ConstantKind<'tcx>) -> Operand<'tcx> {\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)\n     }\n \n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = ty::Const::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n+        let literal = ConstantKind::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }"}, {"sha": "10be229f08495b9fb696161c3f497cb5d208eae1", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::ty::query::Providers;\n pub fn provide(providers: &mut Providers) {\n     providers.check_match = thir::pattern::check_match;\n     providers.lit_to_const = thir::constant::lit_to_const;\n+    providers.lit_to_mir_constant = thir::constant::lit_to_mir_constant;\n     providers.mir_built = build::mir_built;\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n     providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;"}, {"sha": "d955f2b2d96b60a47aacb10f4b36dcbfbf2063b4", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -3,6 +3,7 @@ use rustc_ast as ast;\n use rustc_middle::mir::interpret::{\n     Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n };\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::Size;"}, {"sha": "67384242ffa81cc5a193799792ff999ce7fc48fc", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::mir::{self, BinOp, BorrowKind, Field, UnOp};\n use rustc_middle::thir::*;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -491,7 +491,8 @@ impl<'tcx> Cx<'tcx> {\n                             hir::InlineAsmOperand::Const { ref anon_const } => {\n                                 let anon_const_def_id =\n                                     self.tcx.hir().local_def_id(anon_const.hir_id);\n-                                let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+                                let value =\n+                                    mir::ConstantKind::from_anon_const(self.tcx, anon_const_def_id);\n                                 let span = self.tcx.hir().span(anon_const.hir_id);\n \n                                 InlineAsmOperand::Const { value, span }"}, {"sha": "96c3986d796a612a5aa91c39e919f8417ad60af7", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -12,6 +12,8 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::HirId;\n use rustc_hir::Node;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::thir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Span;\n@@ -75,6 +77,24 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n+    crate fn const_eval_literal(\n+        &mut self,\n+        lit: &'tcx ast::LitKind,\n+        ty: Ty<'tcx>,\n+        sp: Span,\n+        neg: bool,\n+    ) -> ConstantKind<'tcx> {\n+        match self.tcx.at(sp).lit_to_mir_constant(LitToConstInput { lit, ty, neg }) {\n+            Ok(c) => c,\n+            Err(LitToConstError::Reported) => {\n+                // create a dummy value and continue compiling\n+                ConstantKind::Ty(self.tcx.const_error(ty))\n+            }\n+            Err(LitToConstError::TypeError) => bug!(\"const_eval_literal: had type error\"),\n+        }\n+    }\n+\n     crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,"}, {"sha": "e2b7958bde70dbb0328d1176671b4df3a3e077d3", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_middle::mir::Field;\n+use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n@@ -22,7 +22,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn const_to_pat(\n         &self,\n-        cv: ty::Const<'tcx>,\n+        cv: mir::ConstantKind<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n@@ -152,7 +152,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n-    fn to_pat(&mut self, cv: ty::Const<'tcx>, mir_structural_match_violation: bool) -> Pat<'tcx> {\n+    fn to_pat(\n+        &mut self,\n+        cv: mir::ConstantKind<'tcx>,\n+        mir_structural_match_violation: bool,\n+    ) -> Pat<'tcx> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n@@ -246,7 +250,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = ty::Const<'tcx>>,\n+        vals: impl Iterator<Item = mir::ConstantKind<'tcx>>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n             .map(|(idx, val)| {\n@@ -259,7 +263,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n     fn recur(\n         &self,\n-        cv: ty::Const<'tcx>,\n+        cv: mir::ConstantKind<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n         let id = self.id;\n@@ -365,7 +369,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let destructured = tcx.destructure_const(param_env.and(cv));\n+                let destructured = tcx.destructure_mir_constant(param_env.and(cv));\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n@@ -376,12 +380,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 }\n             }\n             ty::Tuple(_) | ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_const(param_env.and(cv));\n+                let destructured = tcx.destructure_mir_constant(param_env.and(cv));\n                 PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n             }\n             ty::Array(..) => PatKind::Array {\n                 prefix: tcx\n-                    .destructure_const(param_env.and(cv))\n+                    .destructure_mir_constant(param_env.and(cv))\n                     .fields\n                     .iter()\n                     .map(|val| self.recur(*val, false))\n@@ -412,12 +416,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // arrays.\n                 ty::Array(..) if !self.treat_byte_string_as_slice => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n                         subpattern: Pat {\n                             kind: Box::new(PatKind::Array {\n                                 prefix: tcx\n-                                    .destructure_const(param_env.and(array))\n+                                    .destructure_mir_constant(param_env.and(array))\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n@@ -438,12 +442,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // pattern.\n                 ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n                         subpattern: Pat {\n                             kind: Box::new(PatKind::Slice {\n                                 prefix: tcx\n-                                    .destructure_const(param_env.and(array))\n+                                    .destructure_mir_constant(param_env.and(array))\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n@@ -512,7 +516,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         // we fall back to a const pattern. If we do not do this, we may end up with\n                         // a !structural-match constant that is not of reference type, which makes it\n                         // very hard to invoke `PartialEq::eq` on it as a fallback.\n-                        let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n+                        let val = match self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false) {\n                             Ok(subpattern) => PatKind::Deref { subpattern },\n                             Err(_) => PatKind::Constant { value: cv },\n                         };"}, {"sha": "d237308fc50c3ae538e047afa48af718ed69cc9c", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -52,10 +52,10 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n \n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::Field;\n+use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt, VariantDef};\n+use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n use rustc_middle::{middle::stability::EvalResult, mir::interpret::ConstValue};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n@@ -136,20 +136,30 @@ impl IntRange {\n     fn from_const<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: Const<'tcx>,\n+        value: mir::ConstantKind<'tcx>,\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n             let val = (|| {\n-                if let ty::ConstKind::Value(ConstValue::Scalar(scalar)) = value.val() {\n-                    // For this specific pattern we can skip a lot of effort and go\n-                    // straight to the result, after doing a bit of checking. (We\n-                    // could remove this branch and just fall through, which\n-                    // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n-                        return Some(bits);\n+                match value {\n+                    mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n+                        // For this specific pattern we can skip a lot of effort and go\n+                        // straight to the result, after doing a bit of checking. (We\n+                        // could remove this branch and just fall through, which\n+                        // is more general but much slower.)\n+                        if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n+                            return Some(bits);\n+                        }\n                     }\n+                    mir::ConstantKind::Ty(c) => match c.val() {\n+                        ty::ConstKind::Value(_) => bug!(\n+                            \"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\"\n+                        ),\n+                        _ => {}\n+                    },\n+                    _ => {}\n                 }\n+\n                 // This is a more general form of the previous case.\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n@@ -234,8 +244,8 @@ impl IntRange {\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n         let env = ty::ParamEnv::empty().and(ty);\n-        let lo_const = ty::Const::from_bits(tcx, lo, env);\n-        let hi_const = ty::Const::from_bits(tcx, hi, env);\n+        let lo_const = mir::ConstantKind::from_bits(tcx, lo, env);\n+        let hi_const = mir::ConstantKind::from_bits(tcx, hi, env);\n \n         let kind = if lo == hi {\n             PatKind::Constant { value: lo_const }\n@@ -630,9 +640,9 @@ pub(super) enum Constructor<'tcx> {\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n-    FloatRange(ty::Const<'tcx>, ty::Const<'tcx>, RangeEnd),\n+    FloatRange(mir::ConstantKind<'tcx>, mir::ConstantKind<'tcx>, RangeEnd),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n-    Str(ty::Const<'tcx>),\n+    Str(mir::ConstantKind<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n     /// Constants that must not be matched structurally. They are treated as black"}, {"sha": "be11b57c830dc5f3ece37fed7f1fc155f2dcb7ed", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n-use rustc_middle::mir::UserTypeProjection;\n+use rustc_middle::mir::{self, UserTypeProjection};\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n@@ -121,8 +121,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_range(\n         &mut self,\n         ty: Ty<'tcx>,\n-        lo: ty::Const<'tcx>,\n-        hi: ty::Const<'tcx>,\n+        lo: mir::ConstantKind<'tcx>,\n+        hi: mir::ConstantKind<'tcx>,\n         end: RangeEnd,\n         span: Span,\n     ) -> PatKind<'tcx> {\n@@ -177,16 +177,24 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         lo: Option<&PatKind<'tcx>>,\n         hi: Option<&PatKind<'tcx>>,\n-    ) -> Option<(ty::Const<'tcx>, ty::Const<'tcx>)> {\n+    ) -> Option<(mir::ConstantKind<'tcx>, mir::ConstantKind<'tcx>)> {\n         match (lo, hi) {\n             (Some(PatKind::Constant { value: lo }), Some(PatKind::Constant { value: hi })) => {\n                 Some((*lo, *hi))\n             }\n             (Some(PatKind::Constant { value: lo }), None) => {\n-                Some((*lo, ty.numeric_max_val(self.tcx)?))\n+                let hi = ty.numeric_max_val(self.tcx)?;\n+                Some((\n+                    *lo,\n+                    mir::ConstantKind::from_bits(self.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                ))\n             }\n             (None, Some(PatKind::Constant { value: hi })) => {\n-                Some((ty.numeric_min_val(self.tcx)?, *hi))\n+                let lo = ty.numeric_min_val(self.tcx)?;\n+                Some((\n+                    mir::ConstantKind::from_bits(self.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                    *hi,\n+                ))\n             }\n             _ => None,\n         }\n@@ -488,9 +496,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n             Ok(value) => {\n-                let const_ =\n-                    ty::Const::from_value(self.tcx, value, self.typeck_results.node_type(id));\n-\n+                let const_ = mir::ConstantKind::Val(value, ty);\n                 let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n \n                 if !is_associated_const {\n@@ -539,25 +545,30 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> PatKind<'tcx> {\n         let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n-        let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);\n+        let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const_def_id);\n \n         // Evaluate early like we do in `lower_path`.\n         let value = value.eval(self.tcx, self.param_env);\n \n-        match value.val() {\n-            ConstKind::Param(_) => {\n-                self.errors.push(PatternError::ConstParamInPattern(span));\n-                return PatKind::Wild;\n-            }\n-            ConstKind::Unevaluated(_) => {\n-                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n-                return PatKind::Wild;\n+        match value {\n+            mir::ConstantKind::Ty(c) => {\n+                match c.val() {\n+                    ConstKind::Param(_) => {\n+                        self.errors.push(PatternError::ConstParamInPattern(span));\n+                        return PatKind::Wild;\n+                    }\n+                    ConstKind::Unevaluated(_) => {\n+                        // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                        self.tcx\n+                            .sess\n+                            .span_err(span, \"constant pattern depends on a generic parameter\");\n+                        return PatKind::Wild;\n+                    }\n+                    _ => bug!(\"Expected either ConstKind::Param or ConstKind::Unevaluated\"),\n+                }\n             }\n-            _ => (),\n+            mir::ConstantKind::Val(_, _) => *self.const_to_pat(value, id, span, false).kind,\n         }\n-\n-        *self.const_to_pat(value, id, span, false).kind\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n@@ -584,8 +595,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-        match self.tcx.at(expr.span).lit_to_const(lit_input) {\n-            Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n+        match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n+            Ok(constant) => *self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n             Err(LitToConstError::Reported) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n@@ -739,15 +750,14 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    a: ty::Const<'tcx>,\n-    b: ty::Const<'tcx>,\n+    a: mir::ConstantKind<'tcx>,\n+    b: mir::ConstantKind<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n-    trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n-\n     let from_bool = |v: bool| v.then_some(Ordering::Equal);\n \n     let fallback = || from_bool(a == b);\n@@ -759,7 +769,8 @@ crate fn compare_const_vals<'tcx>(\n \n     // Early return for equal constants (so e.g. references to ZSTs can be compared, even if they\n     // are just integer addresses).\n-    if a.val() == b.val() {\n+    // FIXME This might be wrong\n+    if a == b {\n         return from_bool(true);\n     }\n "}, {"sha": "47af6bae6bb2779d9b3fadd002ae8c6633303b5e", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -19,6 +19,7 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::span_bug;\n use rustc_middle::thir::abstract_const::Node as ACNode;\n use rustc_middle::ty::fold::TypeVisitor;\n@@ -156,7 +157,10 @@ where\n         ct: AbstractConst<'tcx>,\n     ) -> ControlFlow<V::BreakTy> {\n         const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n-            ACNode::Leaf(leaf) => self.visit_const(leaf),\n+            ACNode::Leaf(leaf) => match leaf {\n+                ConstantKind::Ty(c) => self.visit_const(c),\n+                ConstantKind::Val(_, ty) => self.visit_ty(ty),\n+            },\n             ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n             ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n                 ControlFlow::CONTINUE\n@@ -284,7 +288,7 @@ where\n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n-        if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n+        if let Ok(Some(ct)) = AbstractConst::from_constant(tcx, ConstantKind::Ty(c)) {\n             self.visit_abstract_const_expr(tcx, ct)?;\n         }\n         ControlFlow::CONTINUE"}, {"sha": "cdec38db12495a13ea7b52cca22036ef5b20a635", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -37,9 +37,14 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n+<<<<<<< HEAD\n     let tcx = infcx.tcx;\n \n     if tcx.features().generic_const_exprs {\n+=======\n+    if infcx.tcx.features().generic_const_exprs {\n+        let tcx = infcx.tcx;\n+>>>>>>> 6064f16d846 (change thir to use mir::ConstantKind instead of ty::Const)\n         match AbstractConst::new(tcx, uv)? {\n             // We are looking at a generic abstract constant.\n             Some(ct) => {\n@@ -244,7 +249,7 @@ impl<'tcx> AbstractConst<'tcx> {\n         Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs }))\n     }\n \n-    pub fn from_const(\n+    pub fn from_constant(\n         tcx: TyCtxt<'tcx>,\n         ct: ty::Const<'tcx>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n@@ -376,6 +381,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     visit::walk_pat(self, pat);\n                 }\n             }\n+\n+            fn visit_constant(&mut self, ct: mir::ConstantKind<'tcx>) {\n+                self.is_poly |= ct.has_param_types_or_consts();\n+            }\n         }\n \n         let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n@@ -414,10 +423,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.recurse_build(self.body_id)?;\n \n         for n in self.nodes.iter() {\n-            if let Node::Leaf(ty::Const(Interned(\n+            if let Node::Leaf(mir::ConstantKind::Ty(ty::Const(Interned(\n                 ty::ConstS { val: ty::ConstKind::Unevaluated(ct), ty: _ },\n                 _,\n-            ))) = n\n+            )))) = n\n             {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n                 // are not allowed.\n@@ -637,6 +646,7 @@ pub(super) fn thir_abstract_const<'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n@@ -806,3 +816,51 @@ impl<'tcx> ConstUnifyCtxt<'tcx> {\n         }\n     }\n }\n+\n+/* Think I need these changes\n+=======\n+            match (a_ct, b_ct) {\n+                (mir::ConstantKind::Ty(a_ct), mir::ConstantKind::Ty(b_ct)) => {\n+                    match (a_ct.val(), b_ct.val()) {\n+                        // We can just unify errors with everything to reduce the amount of\n+                        // emitted errors here.\n+                        (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                        (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                            a_param == b_param\n+                        }\n+                        (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => {\n+                            a_val == b_val\n+                        }\n+\n+                        // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                        // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                        // means that we only allow inference variables if they are equal.\n+                        (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => {\n+                            a_val == b_val\n+                        }\n+                        // We expand generic anonymous constants at the start of this function, so this\n+                        // branch should only be taking when dealing with associated constants, at\n+                        // which point directly comparing them seems like the desired behavior.\n+                        //\n+                        // FIXME(generic_const_exprs): This isn't actually the case.\n+                        // We also take this branch for concrete anonymous constants and\n+                        // expand generic anonymous constants with concrete substs.\n+                        (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                            a_uv == b_uv\n+                        }\n+                        // FIXME(generic_const_exprs): We may want to either actually try\n+                        // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                        // this, for now we just return false here.\n+                        _ => false,\n+                    }\n+                }\n+                (mir::ConstantKind::Val(a_val, a_ty), mir::ConstantKind::Val(b_val, b_ty)) => {\n+                    a_val == b_val && a_ty == b_ty\n+                }\n+                _ => {\n+                    // FIXME Can it happen that we need to compare ConstantKind::Ty(ConstKind::Value)\n+                    // with a ConstantKind::Val and vice versa?\n+                    false\n+>>>>>>> 6064f16d846 (change thir to use mir::ConstantKind instead of ty::Const)\n+\n+ */\n\\ No newline at end of file"}, {"sha": "d82876eeac12c8bf384af69a803a364e4aae7ca9", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     let pred =\n                         ty::Binder::dummy(infcx.replace_bound_vars_with_placeholders(binder));\n                     ProcessResult::Changed(mk_pending(vec![\n-                        obligation.with(pred.to_predicate(self.selcx.tcx())),\n+                        obligation.with(pred.to_predicate(self.selcx.tcx()))\n                     ]))\n                 }\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {"}, {"sha": "67f153e0abdd7822207ac53d47da3a4c8f39cc7d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38077ea0b9021cf69401289f23951f96d996129/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=b38077ea0b9021cf69401289f23951f96d996129", "patch": "@@ -17,6 +17,7 @@ use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::FatalError;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_middle::ty::{Predicate, ToPredicate};\n@@ -836,7 +837,10 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n                 const_evaluatable::walk_abstract_const(self.tcx, ct, |node| {\n                     match node.root(self.tcx) {\n-                        Node::Leaf(leaf) => self.visit_const(leaf),\n+                        Node::Leaf(leaf) => match leaf {\n+                            ConstantKind::Ty(c) => self.visit_const(c),\n+                            ConstantKind::Val(_, ty) => self.visit_ty(ty),\n+                        },\n                         Node::Cast(_, _, ty) => self.visit_ty(ty),\n                         Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n                             ControlFlow::CONTINUE"}]}