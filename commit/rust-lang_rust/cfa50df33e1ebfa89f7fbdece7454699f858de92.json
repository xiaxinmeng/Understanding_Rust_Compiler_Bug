{"sha": "cfa50df33e1ebfa89f7fbdece7454699f858de92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYTUwZGYzM2UxZWJmYTg5ZjdmYmRlY2U3NDU0Njk5Zjg1OGRlOTI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-02T17:12:49Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-02T18:33:13Z"}, "message": "Refactor a bit", "tree": {"sha": "f793df3b6eab65a110bf1cc22258eaad15f77df9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f793df3b6eab65a110bf1cc22258eaad15f77df9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfa50df33e1ebfa89f7fbdece7454699f858de92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa50df33e1ebfa89f7fbdece7454699f858de92", "html_url": "https://github.com/rust-lang/rust/commit/cfa50df33e1ebfa89f7fbdece7454699f858de92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfa50df33e1ebfa89f7fbdece7454699f858de92/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "456d52fdfa8525af2a54e76ee5300f0a40ef582a", "url": "https://api.github.com/repos/rust-lang/rust/commits/456d52fdfa8525af2a54e76ee5300f0a40ef582a", "html_url": "https://github.com/rust-lang/rust/commit/456d52fdfa8525af2a54e76ee5300f0a40ef582a"}], "stats": {"total": 151, "additions": 74, "deletions": 77}, "files": [{"sha": "b0024c6e1c99b22b049af9cf42b2da6e2483a6d0", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cfa50df33e1ebfa89f7fbdece7454699f858de92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa50df33e1ebfa89f7fbdece7454699f858de92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=cfa50df33e1ebfa89f7fbdece7454699f858de92", "patch": "@@ -206,7 +206,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     AssocItemId::TypeAliasId(_) => unreachable!(),\n                 };\n                 let substs = match container {\n-                    ContainerId::ImplId(_) => self.find_self_types(&def, ty.clone()),\n+                    ContainerId::ImplId(impl_id) => {\n+                        method_resolution::inherent_impl_substs(self.db, impl_id, &ty)\n+                    }\n                     ContainerId::TraitId(trait_) => {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, trait_)\n@@ -231,38 +233,4 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             },\n         )\n     }\n-\n-    fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n-        if let ValueNs::FunctionId(func) = *def {\n-            // We only do the infer if parent has generic params\n-            let gen = self.db.generic_params(func.into());\n-            if gen.count_parent_params() == 0 {\n-                return None;\n-            }\n-\n-            let impl_id = match func.lookup(self.db).container {\n-                ContainerId::ImplId(it) => it,\n-                _ => return None,\n-            };\n-            let self_ty = self.db.impl_self_ty(impl_id).clone();\n-            let self_ty_substs = self_ty.substs()?;\n-            let actual_substs = actual_def_ty.substs()?;\n-\n-            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n-\n-            // The following code *link up* the function actual parma type\n-            // and impl_block type param index\n-            self_ty_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n-                if let Ty::Param { idx, .. } = param {\n-                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n-                        *s = pty.clone();\n-                    }\n-                }\n-            });\n-\n-            Some(Substs(new_substs.into()))\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "21efb196af19ac88072866ee99bc0cc73539a074", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cfa50df33e1ebfa89f7fbdece7454699f858de92/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa50df33e1ebfa89f7fbdece7454699f858de92/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=cfa50df33e1ebfa89f7fbdece7454699f858de92", "patch": "@@ -191,13 +191,13 @@ pub fn iterate_method_candidates<T>(\n             let ty = InEnvironment { value: ty.clone(), environment };\n             let krate = resolver.krate()?;\n \n-            // We have to be careful about the order of operations here.\n-            // Consider the case where we're resolving `x.clone()` where `x:\n-            // &Vec<_>`. This resolves to the clone method with self type\n-            // `Vec<_>`, *not* `&_`. I.e. we need to consider methods where the\n-            // receiver type exactly matches before cases where we have to do\n-            // autoref. But in the autoderef steps, the `&_` self type comes up\n-            // *before* the `Vec<_>` self type.\n+            // We have to be careful about the order we're looking at candidates\n+            // in here. Consider the case where we're resolving `x.clone()`\n+            // where `x: &Vec<_>`. This resolves to the clone method with self\n+            // type `Vec<_>`, *not* `&_`. I.e. we need to consider methods where\n+            // the receiver type exactly matches before cases where we have to\n+            // do autoref. But in the autoderef steps, the `&_` self type comes\n+            // up *before* the `Vec<_>` self type.\n             //\n             // On the other hand, we don't want to just pick any by-value method\n             // before any by-autoref method; it's just that we need to consider\n@@ -206,7 +206,7 @@ pub fn iterate_method_candidates<T>(\n \n             let deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty.clone()).collect();\n             for i in 0..deref_chain.len() {\n-                if let Some(result) = iterate_method_candidates_autoref(\n+                if let Some(result) = iterate_method_candidates_with_autoref(\n                     &deref_chain[i..],\n                     db,\n                     resolver,\n@@ -220,12 +220,12 @@ pub fn iterate_method_candidates<T>(\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n-            iterate_method_candidates_inner(&ty, db, resolver, name, None, &mut callback)\n+            iterate_method_candidates_for_self_ty(&ty, db, resolver, name, &mut callback)\n         }\n     }\n }\n \n-fn iterate_method_candidates_autoref<T>(\n+fn iterate_method_candidates_with_autoref<T>(\n     deref_chain: &[Canonical<Ty>],\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n@@ -275,18 +275,25 @@ fn iterate_method_candidates_autoref<T>(\n \n fn iterate_method_candidates_by_receiver<T>(\n     receiver_ty: &Canonical<Ty>,\n-    deref_chain: &[Canonical<Ty>],\n+    rest_of_deref_chain: &[Canonical<Ty>],\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    // TODO: do we need to do the whole loop for inherents before traits?\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n-    for self_ty in std::iter::once(receiver_ty).chain(deref_chain) {\n-        if let Some(result) = iterate_method_candidates_inner(\n+    let krate = resolver.krate()?;\n+    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+        if let Some(result) =\n+            iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback)\n+        {\n+            return Some(result);\n+        }\n+    }\n+    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+        if let Some(result) = iterate_trait_method_candidates(\n             self_ty,\n             db,\n             resolver,\n@@ -300,22 +307,19 @@ fn iterate_method_candidates_by_receiver<T>(\n     None\n }\n \n-fn iterate_method_candidates_inner<T>(\n+fn iterate_method_candidates_for_self_ty<T>(\n     self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n-    if let Some(result) =\n-        iterate_inherent_methods(self_ty, db, name, receiver_ty, krate, &mut callback)\n-    {\n+    if let Some(result) = iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n         return Some(result);\n     }\n     if let Some(result) =\n-        iterate_trait_method_candidates(self_ty, db, resolver, name, receiver_ty, &mut callback)\n+        iterate_trait_method_candidates(self_ty, db, resolver, name, None, &mut callback)\n     {\n         return Some(result);\n     }\n@@ -412,29 +416,11 @@ fn is_valid_candidate(\n                 if !data.has_self_param {\n                     return false;\n                 }\n-                let substs = match m.lookup(db).container {\n-                    hir_def::ContainerId::TraitId(_) => Substs::build_for_def(db, item)\n-                        .push(self_ty.value.clone())\n-                        .fill_with_unknown()\n-                        .build(),\n-                    hir_def::ContainerId::ImplId(impl_id) => {\n-                        let vars =\n-                            Substs::build_for_def(db, impl_id).fill_with_bound_vars(0).build();\n-                        let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n-                        let self_ty_with_vars =\n-                            Canonical { num_vars: vars.len(), value: &self_ty_with_vars };\n-                        if let Some(substs) = super::infer::unify(self_ty_with_vars, &self_ty.value)\n-                        {\n-                            substs\n-                        } else {\n-                            return false;\n-                        }\n-                    }\n-                    hir_def::ContainerId::ModuleId(_) => unreachable!(),\n+                let transformed_receiver_ty = match transform_receiver_ty(db, m, self_ty) {\n+                    Some(ty) => ty,\n+                    None => return false,\n                 };\n-                let sig = db.callable_item_signature(m.into());\n-                let receiver = sig.params()[0].clone().subst(&substs);\n-                if receiver != receiver_ty.value {\n+                if transformed_receiver_ty != receiver_ty.value {\n                     return false;\n                 }\n             }\n@@ -448,6 +434,34 @@ fn is_valid_candidate(\n     }\n }\n \n+pub(crate) fn inherent_impl_substs(\n+    db: &impl HirDatabase,\n+    impl_id: ImplId,\n+    self_ty: &Ty,\n+) -> Option<Substs> {\n+    let vars = Substs::build_for_def(db, impl_id).fill_with_bound_vars(0).build();\n+    let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n+    let self_ty_with_vars = Canonical { num_vars: vars.len(), value: &self_ty_with_vars };\n+    super::infer::unify(self_ty_with_vars, self_ty)\n+}\n+\n+fn transform_receiver_ty(\n+    db: &impl HirDatabase,\n+    function_id: FunctionId,\n+    self_ty: &Canonical<Ty>,\n+) -> Option<Ty> {\n+    let substs = match function_id.lookup(db).container {\n+        hir_def::ContainerId::TraitId(_) => Substs::build_for_def(db, function_id)\n+            .push(self_ty.value.clone())\n+            .fill_with_unknown()\n+            .build(),\n+        hir_def::ContainerId::ImplId(impl_id) => inherent_impl_substs(db, impl_id, &self_ty.value)?,\n+        hir_def::ContainerId::ModuleId(_) => unreachable!(),\n+    };\n+    let sig = db.callable_item_signature(function_id.into());\n+    Some(sig.params()[0].clone().subst(&substs))\n+}\n+\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,"}, {"sha": "d28e835c7245c7467f0ce1b44c3c8c22fbc55058", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfa50df33e1ebfa89f7fbdece7454699f858de92/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa50df33e1ebfa89f7fbdece7454699f858de92/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=cfa50df33e1ebfa89f7fbdece7454699f858de92", "patch": "@@ -3493,6 +3493,21 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"i8\");\n }\n \n+#[test]\n+fn method_resolution_impl_ref_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n #[test]\n fn method_resolution_trait_autoderef() {\n     let t = type_at("}]}