{"sha": "14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZDNjNmU4ZjQ2NzM1YWQ2NGU4ZGZiOTA3ODI0ZGQzZWE3N2RiY2Q=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-04T20:14:02Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-27T09:43:15Z"}, "message": "Make opaque::Encoder append-only and make it infallible", "tree": {"sha": "5f512c1961f7c154156a39f5669ec54e31c14dad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f512c1961f7c154156a39f5669ec54e31c14dad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "html_url": "https://github.com/rust-lang/rust/commit/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "971f7d34d4e8afa663b3972b58528a069a25b436", "url": "https://api.github.com/repos/rust-lang/rust/commits/971f7d34d4e8afa663b3972b58528a069a25b436", "html_url": "https://github.com/rust-lang/rust/commit/971f7d34d4e8afa663b3972b58528a069a25b436"}], "stats": {"total": 198, "additions": 80, "deletions": 118}, "files": [{"sha": "2a3b1ce6a36a5075fcf33ff85b6224cfe705baf0", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -52,7 +52,8 @@ impl Fingerprint {\n     pub fn encode_opaque(&self, encoder: &mut Encoder) -> EncodeResult {\n         let bytes: [u8; 16] = unsafe { mem::transmute([self.0.to_le(), self.1.to_le()]) };\n \n-        encoder.emit_raw_bytes(&bytes)\n+        encoder.emit_raw_bytes(&bytes);\n+        Ok(())\n     }\n \n     pub fn decode_opaque<'a>(decoder: &mut Decoder<'a>) -> Result<Fingerprint, String> {\n@@ -92,7 +93,7 @@ impl serialize::UseSpecializedEncodable for Fingerprint { }\n \n impl serialize::UseSpecializedDecodable for Fingerprint { }\n \n-impl<'a> serialize::SpecializedEncoder<Fingerprint> for serialize::opaque::Encoder<'a> {\n+impl serialize::SpecializedEncoder<Fingerprint> for serialize::opaque::Encoder {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(self)\n     }"}, {"sha": "967a3324cfb2a92113d202133085d0b80df2d9bb", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -54,7 +54,7 @@ pub trait TyEncoder: Encoder {\n     fn position(&self) -> usize;\n }\n \n-impl<'buf> TyEncoder for opaque::Encoder<'buf> {\n+impl TyEncoder for opaque::Encoder {\n     #[inline]\n     fn position(&self) -> usize {\n         self.position()"}, {"sha": "c42323e3d4a23de4695d376b57569ce7d287f53f", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -979,7 +979,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 't\n }\n \n impl<'enc, 'a, 'tcx> SpecializedEncoder<Fingerprint>\n-for CacheEncoder<'enc, 'a, 'tcx, opaque::Encoder<'enc>>\n+for CacheEncoder<'enc, 'a, 'tcx, opaque::Encoder>\n {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.encoder)\n@@ -1057,7 +1057,7 @@ impl IntEncodedWithFixedSize {\n impl UseSpecializedEncodable for IntEncodedWithFixedSize {}\n impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n \n-impl<'enc> SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder<'enc> {\n+impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n     fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n         let start_pos = self.position();\n         for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {"}, {"sha": "c553eca08e6b4979a929d9dafbf49c3c40e6727d", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -230,8 +230,7 @@ impl WasmEncoder {\n     }\n \n     fn u32(&mut self, val: u32) {\n-        let at = self.data.len();\n-        leb128::write_u32_leb128(&mut self.data, at, val);\n+        leb128::write_u32_leb128(&mut self.data, val);\n     }\n \n     fn byte(&mut self, val: u8) {"}, {"sha": "98f7873fda0e41da5c569fcb237117881aaed3f0", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -25,6 +25,7 @@ use std::fs;\n use std::env;\n \n use rustc::session::config::nightly_options;\n+use rustc_serialize::opaque::Encoder;\n \n /// The first few bytes of files generated by incremental compilation\n const FILE_MAGIC: &'static [u8] = b\"RSIC\";\n@@ -37,17 +38,15 @@ const HEADER_FORMAT_VERSION: u16 = 0;\n /// the git commit hash.\n const RUSTC_VERSION: Option<&'static str> = option_env!(\"CFG_VERSION\");\n \n-pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n-    stream.write_all(FILE_MAGIC)?;\n-    stream.write_all(&[(HEADER_FORMAT_VERSION >> 0) as u8,\n-                       (HEADER_FORMAT_VERSION >> 8) as u8])?;\n+pub fn write_file_header(stream: &mut Encoder) {\n+    stream.emit_raw_bytes(FILE_MAGIC);\n+    stream.emit_raw_bytes(&[(HEADER_FORMAT_VERSION >> 0) as u8,\n+                       (HEADER_FORMAT_VERSION >> 8) as u8]);\n \n     let rustc_version = rustc_version();\n     assert_eq!(rustc_version.len(), (rustc_version.len() as u8) as usize);\n-    stream.write_all(&[rustc_version.len() as u8])?;\n-    stream.write_all(rustc_version.as_bytes())?;\n-\n-    Ok(())\n+    stream.emit_raw_bytes(&[rustc_version.len() as u8]);\n+    stream.emit_raw_bytes(rustc_version.as_bytes());\n }\n \n /// Reads the contents of a file with a file header as defined in this module."}, {"sha": "06b0ea946d778fc99847092fbb00a60a054923dd", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n-use std::io::{self, Cursor};\n use std::fs;\n use std::path::PathBuf;\n \n@@ -98,7 +97,7 @@ pub fn save_work_product_index(sess: &Session,\n }\n \n fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n-    where F: FnOnce(&mut Encoder) -> io::Result<()>\n+    where F: FnOnce(&mut Encoder)\n {\n     debug!(\"save: storing data in {}\", path_buf.display());\n \n@@ -121,20 +120,12 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n \n     // generate the data in a memory buffer\n-    let mut wr = Cursor::new(Vec::new());\n-    file_format::write_file_header(&mut wr).unwrap();\n-    match encode(&mut Encoder::new(&mut wr)) {\n-        Ok(()) => {}\n-        Err(err) => {\n-            sess.err(&format!(\"could not encode dep-graph to `{}`: {}\",\n-                              path_buf.display(),\n-                              err));\n-            return;\n-        }\n-    }\n+    let mut encoder = Encoder::new(Vec::new());\n+    file_format::write_file_header(&mut encoder);\n+    encode(&mut encoder);\n \n     // write the data out\n-    let data = wr.into_inner();\n+    let data = encoder.into_inner();\n     match fs::write(&path_buf, data) {\n         Ok(_) => {\n             debug!(\"save: data written to disk successfully\");\n@@ -149,10 +140,9 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n }\n \n fn encode_dep_graph(tcx: TyCtxt,\n-                    encoder: &mut Encoder)\n-                    -> io::Result<()> {\n+                    encoder: &mut Encoder) {\n     // First encode the commandline arguments hash\n-    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n+    tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n \n     // Encode the graph data.\n     let serialized_graph = time(tcx.sess, \"getting serialized graph\", || {\n@@ -234,14 +224,12 @@ fn encode_dep_graph(tcx: TyCtxt,\n     }\n \n     time(tcx.sess, \"encoding serialized graph\", || {\n-        serialized_graph.encode(encoder)\n-    })?;\n-\n-    Ok(())\n+        serialized_graph.encode(encoder).unwrap();\n+    });\n }\n \n fn encode_work_product_index(work_products: &FxHashMap<WorkProductId, WorkProduct>,\n-                             encoder: &mut Encoder) -> io::Result<()> {\n+                             encoder: &mut Encoder) {\n     let serialized_products: Vec<_> = work_products\n         .iter()\n         .map(|(id, work_product)| {\n@@ -252,13 +240,12 @@ fn encode_work_product_index(work_products: &FxHashMap<WorkProductId, WorkProduc\n         })\n         .collect();\n \n-    serialized_products.encode(encoder)\n+    serialized_products.encode(encoder).unwrap();\n }\n \n fn encode_query_cache(tcx: TyCtxt,\n-                      encoder: &mut Encoder)\n-                      -> io::Result<()> {\n+                      encoder: &mut Encoder) {\n     time(tcx.sess, \"serialize query result cache\", || {\n-        tcx.serialize_query_result_cache(encoder)\n+        tcx.serialize_query_result_cache(encoder).unwrap();\n     })\n }"}, {"sha": "46c4a3a1abe80aff682ce27a2ffc5d17f1118c73", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -35,8 +35,6 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n \n use std::hash::Hash;\n-use std::io::prelude::*;\n-use std::io::Cursor;\n use std::path::Path;\n use rustc_data_structures::sync::Lrc;\n use std::u32;\n@@ -52,7 +50,7 @@ use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    opaque: opaque::Encoder<'a>,\n+    opaque: opaque::Encoder,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     link_meta: &'a LinkMeta,\n \n@@ -76,7 +74,7 @@ macro_rules! encoder_methods {\n }\n \n impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n-    type Error = <opaque::Encoder<'a> as Encoder>::Error;\n+    type Error = <opaque::Encoder as Encoder>::Error;\n \n     fn emit_nil(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n@@ -480,7 +478,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Index the items\n         i = self.position();\n-        let index = items.write_index(&mut self.opaque.cursor);\n+        let index = items.write_index(&mut self.opaque);\n         let index_bytes = self.position() - i;\n \n         let attrs = tcx.hir.krate_attrs();\n@@ -537,7 +535,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         if self.tcx.sess.meta_stats() {\n             let mut zero_bytes = 0;\n-            for e in self.opaque.cursor.get_ref() {\n+            for e in self.opaque.data.iter() {\n                 if *e == 0 {\n                     zero_bytes += 1;\n                 }\n@@ -1797,15 +1795,15 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n {\n-    let mut cursor = Cursor::new(vec![]);\n-    cursor.write_all(METADATA_HEADER).unwrap();\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n-    cursor.write_all(&[0, 0, 0, 0]).unwrap();\n+    encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n \n-    let root = {\n+    let (root, mut result) = {\n         let mut ecx = EncodeContext {\n-            opaque: opaque::Encoder::new(&mut cursor),\n+            opaque: encoder,\n             tcx,\n             link_meta,\n             lazy_state: LazyState::NoNode,\n@@ -1821,9 +1819,9 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Encode all the entries and extra information in the crate,\n         // culminating in the `CrateRoot` which points to all of it.\n-        ecx.encode_crate_root()\n+        let root = ecx.encode_crate_root();\n+        (root, ecx.opaque.into_inner())\n     };\n-    let mut result = cursor.into_inner();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();"}, {"sha": "0b4f7e579acb91fb133ee069fd7ab637458fae7c", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -11,7 +11,7 @@\n use schema::*;\n \n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace};\n-use std::io::{Cursor, Write};\n+use rustc_serialize::opaque::Encoder;\n use std::slice;\n use std::u32;\n \n@@ -54,15 +54,15 @@ impl Index {\n         self.positions[space_index][array_index] = position.to_le();\n     }\n \n-    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) -> LazySeq<Index> {\n+    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Index> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n-        buf.write_all(words_to_bytes(&[(self.positions[0].len() as u32).to_le()])).unwrap();\n+        buf.emit_raw_bytes(words_to_bytes(&[(self.positions[0].len() as u32).to_le()]));\n         // ... then the values in the lower range ...\n-        buf.write_all(words_to_bytes(&self.positions[0][..])).unwrap();\n+        buf.emit_raw_bytes(words_to_bytes(&self.positions[0][..]));\n         // ... then the values in the higher range.\n-        buf.write_all(words_to_bytes(&self.positions[1][..])).unwrap();\n+        buf.emit_raw_bytes(words_to_bytes(&self.positions[1][..]));\n         LazySeq::with_position_and_length(pos as usize,\n             self.positions[0].len() + self.positions[1].len() + 1)\n     }"}, {"sha": "ae7f25c7fedbe43ecfbe5c82de45b8ab4d8c0e85", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -9,12 +9,8 @@\n // except according to those terms.\n \n #[inline]\n-pub fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n-    if position == vec.len() {\n-        vec.push(byte);\n-    } else {\n-        vec[position] = byte;\n-    }\n+pub fn write_to_vec(vec: &mut Vec<u8>, byte: u8) {\n+    vec.push(byte);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -33,24 +29,20 @@ macro_rules! leb128_size {\n macro_rules! impl_write_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => (\n         #[inline]\n-        pub fn $fn_name(out: &mut Vec<u8>, start_position: usize, mut value: $int_ty) -> usize {\n-            let mut position = start_position;\n+        pub fn $fn_name(out: &mut Vec<u8>, mut value: $int_ty) {\n             for _ in 0 .. leb128_size!($int_ty) {\n                 let mut byte = (value & 0x7F) as u8;\n                 value >>= 7;\n                 if value != 0 {\n                     byte |= 0x80;\n                 }\n \n-                write_to_vec(out, position, byte);\n-                position += 1;\n+                write_to_vec(out, byte);\n \n                 if value == 0 {\n                     break;\n                 }\n             }\n-\n-            position - start_position\n         }\n     )\n }\n@@ -105,11 +97,9 @@ impl_read_unsigned_leb128!(read_usize_leb128, usize);\n /// The callback `write` is called once for each position\n /// that is to be written to with the byte to be encoded\n /// at that position.\n-pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W) -> usize\n-    where W: FnMut(usize, u8)\n+pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W)\n+    where W: FnMut(u8)\n {\n-    let mut position = 0;\n-\n     loop {\n         let mut byte = (value as u8) & 0x7f;\n         value >>= 7;\n@@ -120,18 +110,16 @@ pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W) -> usize\n             byte |= 0x80; // Mark this byte to show that more bytes will follow.\n         }\n \n-        write(position, byte);\n-        position += 1;\n+        write(byte);\n \n         if !more {\n             break;\n         }\n     }\n-    position\n }\n \n-pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i128) -> usize {\n-    write_signed_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n+pub fn write_signed_leb128(out: &mut Vec<u8>, value: i128) {\n+    write_signed_leb128_to(value, |v| write_to_vec(out, v))\n }\n \n #[inline]\n@@ -167,9 +155,7 @@ macro_rules! impl_test_unsigned_leb128 {\n             let mut stream = Vec::new();\n \n             for x in 0..62 {\n-                let pos = stream.len();\n-                let bytes_written = $write_fn_name(&mut stream, pos, (3u64 << x) as $int_ty);\n-                assert_eq!(stream.len(), pos + bytes_written);\n+                $write_fn_name(&mut stream, (3u64 << x) as $int_ty);\n             }\n \n             let mut position = 0;\n@@ -195,9 +181,7 @@ fn test_signed_leb128() {\n     let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();\n     let mut stream = Vec::new();\n     for &x in &values {\n-        let pos = stream.len();\n-        let bytes_written = write_signed_leb128(&mut stream, pos, x);\n-        assert_eq!(stream.len(), pos + bytes_written);\n+        write_signed_leb128(&mut stream, x);\n     }\n     let mut pos = 0;\n     for &x in &values {"}, {"sha": "a5f4b32b329e7c22a51c791035a9cb05d168076d", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -23,6 +23,7 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(specialization)]\n+#![feature(never_type)]\n #![cfg_attr(test, feature(test))]\n \n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};"}, {"sha": "a77d1d9b88b89a0e048c6f8123de8386ef727a98", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -10,50 +10,48 @@\n \n use leb128::{self, read_signed_leb128, write_signed_leb128};\n use std::borrow::Cow;\n-use std::io::{self, Write};\n use serialize;\n \n // -----------------------------------------------------------------------------\n // Encoder\n // -----------------------------------------------------------------------------\n \n-pub type EncodeResult = io::Result<()>;\n+pub type EncodeResult = Result<(), !>;\n \n-pub struct Encoder<'a> {\n-    pub cursor: &'a mut io::Cursor<Vec<u8>>,\n+pub struct Encoder {\n+    pub data: Vec<u8>,\n }\n \n-impl<'a> Encoder<'a> {\n-    pub fn new(cursor: &'a mut io::Cursor<Vec<u8>>) -> Encoder<'a> {\n-        Encoder { cursor: cursor }\n+impl Encoder {\n+    pub fn new(data: Vec<u8>) -> Encoder {\n+        Encoder { data }\n     }\n \n-    pub fn emit_raw_bytes(&mut self, s: &[u8]) -> EncodeResult {\n-        self.cursor.write_all(s)\n+    pub fn into_inner(self) -> Vec<u8> {\n+        self.data\n     }\n-}\n \n+    pub fn emit_raw_bytes(&mut self, s: &[u8]) {\n+        self.data.extend_from_slice(s);\n+    }\n+}\n \n macro_rules! write_uleb128 {\n     ($enc:expr, $value:expr, $fun:ident) => {{\n-        let pos = $enc.cursor.position() as usize;\n-        let bytes_written = leb128::$fun($enc.cursor.get_mut(), pos, $value);\n-        $enc.cursor.set_position((pos + bytes_written) as u64);\n+        leb128::$fun(&mut $enc.data, $value);\n         Ok(())\n     }}\n }\n \n macro_rules! write_sleb128 {\n     ($enc:expr, $value:expr) => {{\n-        let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i128);\n-        $enc.cursor.set_position((pos + bytes_written) as u64);\n+        write_signed_leb128(&mut $enc.data, $value as i128);\n         Ok(())\n     }}\n }\n \n-impl<'a> serialize::Encoder for Encoder<'a> {\n-    type Error = io::Error;\n+impl serialize::Encoder for Encoder {\n+    type Error = !;\n \n     #[inline]\n     fn emit_nil(&mut self) -> EncodeResult {\n@@ -87,9 +85,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n \n     #[inline]\n     fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        let pos = self.cursor.position() as usize;\n-        leb128::write_to_vec(self.cursor.get_mut(), pos, v);\n-        self.cursor.set_position((pos + 1) as u64);\n+        self.data.push(v);\n         Ok(())\n     }\n \n@@ -153,15 +149,15 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     #[inline]\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         self.emit_usize(v.len())?;\n-        let _ = self.cursor.write_all(v.as_bytes());\n+        self.emit_raw_bytes(v.as_bytes());\n         Ok(())\n     }\n }\n \n-impl<'a> Encoder<'a> {\n+impl Encoder {\n     #[inline]\n     pub fn position(&self) -> usize {\n-        self.cursor.position() as usize\n+        self.data.len()\n     }\n }\n \n@@ -339,7 +335,6 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n #[cfg(test)]\n mod tests {\n     use serialize::{Encodable, Decodable};\n-    use std::io::Cursor;\n     use std::fmt::Debug;\n     use super::{Encoder, Decoder};\n \n@@ -368,14 +363,13 @@ mod tests {\n \n \n     fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n-        let mut cursor = Cursor::new(Vec::new());\n+        let mut encoder = Encoder::new(Vec::new());\n \n         for value in &values {\n-            let mut encoder = Encoder::new(&mut cursor);\n             Encodable::encode(&value, &mut encoder).unwrap();\n         }\n \n-        let data = cursor.into_inner();\n+        let data = encoder.into_inner();\n         let mut decoder = Decoder::new(&data[..], 0);\n \n         for value in values {"}, {"sha": "4f419e70074fc673a329cecb20e89b9f859b2612", "filename": "src/test/run-pass-fulldeps/issue-11881.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs?ref=14d3c6e8f46735ad64e8dfb907824dd3ea77dbcd", "patch": "@@ -41,17 +41,16 @@ enum WireProtocol {\n fn encode_json<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     write!(wr, \"{}\", json::as_json(val));\n }\n-fn encode_opaque<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n+fn encode_opaque<T: Encodable>(val: &T, wr: Vec<u8>) {\n     let mut encoder = opaque::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n \n pub fn main() {\n     let target = Foo{baz: false,};\n-    let mut wr = Cursor::new(Vec::new());\n     let proto = WireProtocol::JSON;\n     match proto {\n-        WireProtocol::JSON => encode_json(&target, &mut wr),\n-        WireProtocol::Opaque => encode_opaque(&target, &mut wr)\n+        WireProtocol::JSON => encode_json(&target, &mut Cursor::new(Vec::new())),\n+        WireProtocol::Opaque => encode_opaque(&target, Vec::new())\n     }\n }"}]}