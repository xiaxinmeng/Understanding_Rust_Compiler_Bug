{"sha": "e2729460661c9bafb2e1862ddd0a63f75ae553e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNzI5NDYwNjYxYzliYWZiMmUxODYyZGRkMGE2M2Y3NWFlNTUzZTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-02T10:47:28Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:08Z"}, "message": "def_collector: Simplify tracking of macro invocation parents\n\nAvoid the tricky scheme with callbacks and keep the invocation parent data where it logically belongs - in `Definitions`.\n\nThis also allows to create `InvocationData` entries in resolve when the data is actually ready, and remove cells and \"uninitialized\" variants from it.", "tree": {"sha": "e4a32afa10949c695be7cd7b731cc1204f0a8fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4a32afa10949c695be7cd7b731cc1204f0a8fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2729460661c9bafb2e1862ddd0a63f75ae553e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2729460661c9bafb2e1862ddd0a63f75ae553e7", "html_url": "https://github.com/rust-lang/rust/commit/e2729460661c9bafb2e1862ddd0a63f75ae553e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2729460661c9bafb2e1862ddd0a63f75ae553e7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aff9738462e8959c0a3eef57124b08d5f811cdec", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff9738462e8959c0a3eef57124b08d5f811cdec", "html_url": "https://github.com/rust-lang/rust/commit/aff9738462e8959c0a3eef57124b08d5f811cdec"}], "stats": {"total": 142, "additions": 55, "deletions": 87}, "files": [{"sha": "f946ca2903ac8192f846b1d59bc1ccda1afac809", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=e2729460661c9bafb2e1862ddd0a63f75ae553e7", "patch": "@@ -1,6 +1,5 @@\n use crate::hir::map::definitions::*;\n-use crate::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n-use crate::session::CrateDisambiguator;\n+use crate::hir::def_id::DefIndex;\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -14,31 +13,12 @@ pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     expansion: Mark,\n-    pub visit_macro_invoc: Option<&'a mut dyn FnMut(MacroInvocationData)>,\n-}\n-\n-pub struct MacroInvocationData {\n-    pub mark: Mark,\n-    pub def_index: DefIndex,\n }\n \n impl<'a> DefCollector<'a> {\n     pub fn new(definitions: &'a mut Definitions, expansion: Mark) -> Self {\n-        DefCollector {\n-            definitions,\n-            expansion,\n-            parent_def: None,\n-            visit_macro_invoc: None,\n-        }\n-    }\n-\n-    pub fn collect_root(&mut self,\n-                        crate_name: &str,\n-                        crate_disambiguator: CrateDisambiguator) {\n-        let root = self.definitions.create_root_def(crate_name,\n-                                                    crate_disambiguator);\n-        assert_eq!(root, CRATE_DEF_INDEX);\n-        self.parent_def = Some(root);\n+        let parent_def = Some(definitions.invocation_parent(expansion));\n+        DefCollector { definitions, parent_def, expansion }\n     }\n \n     fn create_def(&mut self,\n@@ -97,12 +77,7 @@ impl<'a> DefCollector<'a> {\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId) {\n-        if let Some(ref mut visit) = self.visit_macro_invoc {\n-            visit(MacroInvocationData {\n-                mark: id.placeholder_to_mark(),\n-                def_index: self.parent_def.unwrap(),\n-            })\n-        }\n+        self.definitions.set_invocation_parent(id.placeholder_to_mark(), self.parent_def.unwrap());\n     }\n }\n "}, {"sha": "9188a78e489ef03107e2a8940605161747c683ec", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e2729460661c9bafb2e1862ddd0a63f75ae553e7", "patch": "@@ -100,6 +100,9 @@ pub struct Definitions {\n     expansions_that_defined: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n+    /// When collecting definitions from an AST fragment produced by a macro invocation `Mark`\n+    /// we know what parent node that fragment should be attached to thanks to this table.\n+    invocation_parents: FxHashMap<Mark, DefIndex>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -434,6 +437,7 @@ impl Definitions {\n         assert!(self.def_index_to_node.is_empty());\n         self.def_index_to_node.push(ast::CRATE_NODE_ID);\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n+        self.set_invocation_parent(Mark::root(), root_index);\n \n         // Allocate some other DefIndices that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n@@ -526,6 +530,15 @@ impl Definitions {\n     pub fn add_parent_module_of_macro_def(&mut self, mark: Mark, module: DefId) {\n         self.parent_modules_of_macro_defs.insert(mark, module);\n     }\n+\n+    pub fn invocation_parent(&self, invoc_id: Mark) -> DefIndex {\n+        self.invocation_parents[&invoc_id]\n+    }\n+\n+    pub fn set_invocation_parent(&mut self, invoc_id: Mark, parent: DefIndex) {\n+        let old_parent = self.invocation_parents.insert(invoc_id, parent);\n+        assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n+    }\n }\n \n impl DefPathData {"}, {"sha": "f9092196ab3cdfc82318088b1ee866f8925a864b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e2729460661c9bafb2e1862ddd0a63f75ae553e7", "patch": "@@ -1,5 +1,5 @@\n use self::collector::NodeCollector;\n-pub use self::def_collector::{DefCollector, MacroInvocationData};\n+pub use self::def_collector::DefCollector;\n pub use self::definitions::{\n     Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData, DefPathHash\n };"}, {"sha": "8515029193e9b60e34674b15ad627cca0dc25ab3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e2729460661c9bafb2e1862ddd0a63f75ae553e7", "patch": "@@ -944,12 +944,19 @@ pub struct BuildReducedGraphVisitor<'a, 'b> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let mark = id.placeholder_to_mark();\n-        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n-        let invocation = self.resolver.invocations[&mark];\n-        invocation.module.set(self.resolver.current_module);\n-        invocation.parent_legacy_scope.set(self.current_legacy_scope);\n-        invocation\n+        let invoc_id = id.placeholder_to_mark();\n+\n+        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+\n+        let invocation_data = self.resolver.arenas.alloc_invocation_data(InvocationData {\n+            module: self.resolver.current_module,\n+            parent_legacy_scope: self.current_legacy_scope,\n+            output_legacy_scope: Cell::new(None),\n+        });\n+        let old_invocation_data = self.resolver.invocations.insert(invoc_id, invocation_data);\n+        assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n+\n+        invocation_data\n     }\n }\n "}, {"sha": "09d7d8ace6bc02cdf1d8b633d83dbca60af2fa02", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e2729460661c9bafb2e1862ddd0a63f75ae553e7", "patch": "@@ -19,7 +19,7 @@ use GenericParameters::*;\n use RibKind::*;\n use smallvec::smallvec;\n \n-use rustc::hir::map::{Definitions, DefCollector};\n+use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n@@ -1901,8 +1901,7 @@ impl<'a> Resolver<'a> {\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n         let mut definitions = Definitions::default();\n-        DefCollector::new(&mut definitions, Mark::root())\n-            .collect_root(crate_name, session.local_crate_disambiguator());\n+        definitions.create_root_def(crate_name, session.local_crate_disambiguator());\n \n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> =\n             session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))"}, {"sha": "8361bbe45c48361bec6f3eb6b8a1171db75cc5b7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2729460661c9bafb2e1862ddd0a63f75ae553e7/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e2729460661c9bafb2e1862ddd0a63f75ae553e7", "patch": "@@ -8,7 +8,7 @@ use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc::hir::map::{self, DefCollector};\n+use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident};\n@@ -32,14 +32,14 @@ use rustc_data_structures::sync::Lrc;\n \n type Res = def::Res<ast::NodeId>;\n \n+// FIXME: Merge this with `ParentScope`.\n #[derive(Clone, Debug)]\n pub struct InvocationData<'a> {\n-    def_index: DefIndex,\n     /// The module in which the macro was invoked.\n-    crate module: Cell<Module<'a>>,\n+    crate module: Module<'a>,\n     /// The legacy scope in which the macro was invoked.\n     /// The invocation path is resolved in this scope.\n-    crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n+    crate parent_legacy_scope: LegacyScope<'a>,\n     /// The legacy scope *produced* by expanding this macro invocation,\n     /// includes all the macro_rules items, other invocations, etc generated by it.\n     /// `None` if the macro is not expanded yet.\n@@ -49,10 +49,9 @@ pub struct InvocationData<'a> {\n impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         InvocationData {\n-            module: Cell::new(graph_root),\n-            def_index: CRATE_DEF_INDEX,\n-            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n+            module: graph_root,\n+            parent_legacy_scope: LegacyScope::Empty,\n+            output_legacy_scope: Cell::new(None),\n         }\n     }\n }\n@@ -74,9 +73,6 @@ pub struct LegacyBinding<'a> {\n /// can potentially expand into macro definitions.\n #[derive(Copy, Clone, Debug)]\n pub enum LegacyScope<'a> {\n-    /// Created when invocation data is allocated in the arena;\n-    /// must be replaced with a proper scope later.\n-    Uninitialized,\n     /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n     /// The scope introduced by a `macro_rules!` macro definition.\n@@ -139,11 +135,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh(Mark::root());\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n+        self.definitions.set_invocation_parent(mark, module.def_id().unwrap().index);\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n-            module: Cell::new(module),\n-            def_index: module.def_id().unwrap().index,\n-            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n+            module,\n+            parent_legacy_scope: LegacyScope::Empty,\n+            output_legacy_scope: Cell::new(None),\n         }));\n         mark\n     }\n@@ -160,16 +156,20 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]) {\n-        let invocation = self.invocations[&mark];\n-        self.collect_def_ids(mark, invocation, fragment);\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, mark));\n \n-        self.current_module = invocation.module.get();\n+        let invocation = self.invocations[&mark];\n+        self.current_module = invocation.module;\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n+        let parent_def = self.definitions.invocation_parent(mark);\n+        for &derive_invoc_id in derives {\n+            self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n+        }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n-            current_legacy_scope: invocation.parent_legacy_scope.get(),\n+            current_legacy_scope: invocation.parent_legacy_scope,\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n@@ -259,9 +259,9 @@ impl<'a> Resolver<'a> {\n     fn invoc_parent_scope(&self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n         let invoc = self.invocations[&invoc_id];\n         ParentScope {\n-            module: invoc.module.get().nearest_item_scope(),\n+            module: invoc.module.nearest_item_scope(),\n             expansion: invoc_id.parent(),\n-            legacy: invoc.parent_legacy_scope.get(),\n+            legacy: invoc.parent_legacy_scope,\n             derives,\n         }\n     }\n@@ -829,10 +829,9 @@ impl<'a> Resolver<'a> {\n                         binding.parent_legacy_scope\n                     ),\n                     LegacyScope::Invocation(invoc) => WhereToResolve::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope.get())\n+                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n                     ),\n                     LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n-                    LegacyScope::Uninitialized => unreachable!(),\n                 }\n                 WhereToResolve::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1084,31 +1083,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self,\n-                       mark: Mark,\n-                       invocation: &'a InvocationData<'a>,\n-                       fragment: &AstFragment) {\n-        let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n-        let InvocationData { def_index, .. } = *invocation;\n-\n-        let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n-            invocations.entry(invoc.mark).or_insert_with(|| {\n-                arenas.alloc_invocation_data(InvocationData {\n-                    def_index: invoc.def_index,\n-                    module: Cell::new(graph_root),\n-                    parent_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n-                    output_legacy_scope: Cell::new(None),\n-                })\n-            });\n-        };\n-\n-        let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n-        def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n-        def_collector.with_parent(def_index, |def_collector| {\n-            fragment.visit_with(def_collector)\n-        });\n-    }\n-\n     crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`."}]}