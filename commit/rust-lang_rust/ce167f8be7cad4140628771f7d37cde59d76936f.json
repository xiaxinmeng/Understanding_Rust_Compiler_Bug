{"sha": "ce167f8be7cad4140628771f7d37cde59d76936f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMTY3ZjhiZTdjYWQ0MTQwNjI4NzcxZjdkMzdjZGU1OWQ3NjkzNmY=", "commit": {"author": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-09-25T18:19:02Z"}, "committer": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-10-10T13:19:13Z"}, "message": "Fix type mismatching for different OSes.", "tree": {"sha": "21746bde5490138fa427108fa661e7df01ea4c3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21746bde5490138fa427108fa661e7df01ea4c3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce167f8be7cad4140628771f7d37cde59d76936f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce167f8be7cad4140628771f7d37cde59d76936f", "html_url": "https://github.com/rust-lang/rust/commit/ce167f8be7cad4140628771f7d37cde59d76936f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce167f8be7cad4140628771f7d37cde59d76936f/comments", "author": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "889c9272cb670891ed3b2dca4aef4f333110fee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/889c9272cb670891ed3b2dca4aef4f333110fee7", "html_url": "https://github.com/rust-lang/rust/commit/889c9272cb670891ed3b2dca4aef4f333110fee7"}], "stats": {"total": 146, "additions": 105, "deletions": 41}, "files": [{"sha": "c53b213e0f9332bd3a0e488b7eab6d2dfa92de80", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "modified", "additions": 105, "deletions": 41, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/ce167f8be7cad4140628771f7d37cde59d76936f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce167f8be7cad4140628771f7d37cde59d76936f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=ce167f8be7cad4140628771f7d37cde59d76936f", "patch": "@@ -4,7 +4,7 @@ use crate::marker::PhantomData;\n use crate::mem::{size_of, zeroed};\n use crate::os::unix::io::RawFd;\n use crate::path::Path;\n-use crate::ptr::{null_mut, read_unaligned};\n+use crate::ptr::read_unaligned;\n use crate::slice::from_raw_parts;\n use crate::sys::unix::ext::net::addr::{sockaddr_un, SocketAddr};\n use crate::sys::unix::net::Socket;\n@@ -20,19 +20,31 @@ pub(super) fn recv_vectored_with_ancillary_from(\n     unsafe {\n         let mut msg_name: libc::sockaddr_un = zeroed();\n \n-        let mut msg = libc::msghdr {\n-            msg_name: &mut msg_name as *mut _ as *mut _,\n-            msg_namelen: size_of::<libc::sockaddr_un>() as libc::socklen_t,\n-            msg_iov: bufs.as_mut_ptr().cast(),\n-            msg_iovlen: bufs.len(),\n-            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n-            msg_controllen: ancillary.buffer.len(),\n-            msg_flags: 0,\n-        };\n+        let mut msg: libc::msghdr = zeroed();\n+        msg.msg_name = &mut msg_name as *mut _ as *mut _;\n+        msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+        msg.msg_iov = bufs.as_mut_ptr().cast();\n+        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                msg.msg_iovlen = bufs.len() as libc::size_t;\n+                msg.msg_controllen = ancillary.buffer.len() as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                msg.msg_iovlen = bufs.len() as libc::c_int;\n+                msg.msg_controllen = ancillary.buffer.len() as libc::socklen_t;\n+            }\n+        }\n \n         let count = socket.recv_msg(&mut msg)?;\n \n-        ancillary.length = msg.msg_controllen;\n+        ancillary.length = msg.msg_controllen as usize;\n         ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n \n         let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n@@ -52,15 +64,27 @@ pub(super) fn send_vectored_with_ancillary_to(\n         let (mut msg_name, msg_namelen) =\n             if let Some(path) = path { sockaddr_un(path)? } else { (zeroed(), 0) };\n \n-        let mut msg = libc::msghdr {\n-            msg_name: &mut msg_name as *mut _ as *mut _,\n-            msg_namelen,\n-            msg_iov: bufs.as_mut_ptr().cast(),\n-            msg_iovlen: bufs.len(),\n-            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n-            msg_controllen: ancillary.length,\n-            msg_flags: 0,\n-        };\n+        let mut msg: libc::msghdr = zeroed();\n+        msg.msg_name = &mut msg_name as *mut _ as *mut _;\n+        msg.msg_namelen = msg_namelen;\n+        msg.msg_iov = bufs.as_mut_ptr().cast();\n+        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                msg.msg_iovlen = bufs.len() as libc::size_t;\n+                msg.msg_controllen = ancillary.length as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                msg.msg_iovlen = bufs.len() as libc::c_int;\n+                msg.msg_controllen = ancillary.length as libc::socklen_t;\n+            }\n+        }\n \n         ancillary.truncated = false;\n \n@@ -102,15 +126,22 @@ fn add_to_ancillary_data<T>(\n \n         *length = new_length;\n \n-        let msg = libc::msghdr {\n-            msg_name: null_mut(),\n-            msg_namelen: 0,\n-            msg_iov: null_mut(),\n-            msg_iovlen: 0,\n-            msg_control: buffer.as_mut_ptr().cast(),\n-            msg_controllen: *length,\n-            msg_flags: 0,\n-        };\n+        let mut msg: libc::msghdr = zeroed();\n+        msg.msg_control = buffer.as_mut_ptr().cast();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                msg.msg_controllen = *length as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                msg.msg_controllen = *length as libc::socklen_t;\n+            }\n+        }\n \n         let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n         let mut previous_cmsg = cmsg;\n@@ -125,7 +156,20 @@ fn add_to_ancillary_data<T>(\n \n         (*previous_cmsg).cmsg_level = cmsg_level;\n         (*previous_cmsg).cmsg_type = cmsg_type;\n-        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as usize;\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as libc::socklen_t;\n+            }\n+        }\n \n         let data = libc::CMSG_DATA(previous_cmsg).cast();\n \n@@ -295,10 +339,23 @@ impl<'a> AncillaryData<'a> {\n \n     fn try_from_cmsghdr(cmsg: &'a libc::cmsghdr) -> Result<Self, AncillaryError> {\n         unsafe {\n-            let cmsg_len_zero = libc::CMSG_LEN(0) as usize;\n+            cfg_if::cfg_if! {\n+                if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                    let cmsg_len_zero = libc::CMSG_LEN(0) as libc::size_t;\n+                } else if #[cfg(any(\n+                              target_os = \"dragonfly\",\n+                              target_os = \"emscripten\",\n+                              target_os = \"freebsd\",\n+                              all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"netbsd\",\n+                              target_os = \"openbsd\",\n+                          ))] {\n+                    let cmsg_len_zero = libc::CMSG_LEN(0) as libc::socklen_t;\n+                }\n+            }\n             let data_len = (*cmsg).cmsg_len - cmsg_len_zero;\n             let data = libc::CMSG_DATA(cmsg).cast();\n-            let data = from_raw_parts(data, data_len);\n+            let data = from_raw_parts(data, data_len as usize);\n \n             match (*cmsg).cmsg_level {\n                 libc::SOL_SOCKET => match (*cmsg).cmsg_type {\n@@ -330,15 +387,22 @@ impl<'a> Iterator for Messages<'a> {\n \n     fn next(&mut self) -> Option<Self::Item> {\n         unsafe {\n-            let msg = libc::msghdr {\n-                msg_name: null_mut(),\n-                msg_namelen: 0,\n-                msg_iov: null_mut(),\n-                msg_iovlen: 0,\n-                msg_control: self.buffer.as_ptr() as *mut _,\n-                msg_controllen: self.buffer.len(),\n-                msg_flags: 0,\n-            };\n+            let mut msg: libc::msghdr = zeroed();\n+            msg.msg_control = self.buffer.as_ptr() as *mut _;\n+            cfg_if::cfg_if! {\n+                if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                    msg.msg_controllen = self.buffer.len() as libc::size_t;\n+                } else if #[cfg(any(\n+                              target_os = \"dragonfly\",\n+                              target_os = \"emscripten\",\n+                              target_os = \"freebsd\",\n+                              all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"netbsd\",\n+                              target_os = \"openbsd\",\n+                          ))] {\n+                    msg.msg_controllen = self.buffer.len() as libc::socklen_t;;\n+                }\n+            }\n \n             let cmsg = if let Some(current) = self.current {\n                 libc::CMSG_NXTHDR(&msg, current)"}]}