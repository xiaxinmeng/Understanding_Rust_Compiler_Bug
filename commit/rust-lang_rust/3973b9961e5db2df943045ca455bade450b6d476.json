{"sha": "3973b9961e5db2df943045ca455bade450b6d476", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NzNiOTk2MWU1ZGIyZGY5NDMwNDVjYTQ1NWJhZGU0NTBiNmQ0NzY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-19T06:43:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-19T06:43:18Z"}, "message": "Merge pull request #85 from oli-obk/storage_dead\n\ndeallocate all locals on function exit and transitively freeze constants through pointers", "tree": {"sha": "f84b6dac248d4d9cfe4cadccd667a74e768e64c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f84b6dac248d4d9cfe4cadccd667a74e768e64c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3973b9961e5db2df943045ca455bade450b6d476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3973b9961e5db2df943045ca455bade450b6d476", "html_url": "https://github.com/rust-lang/rust/commit/3973b9961e5db2df943045ca455bade450b6d476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3973b9961e5db2df943045ca455bade450b6d476/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7cb9a09e4f05260f19c9e626457e3a7f2835c81", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7cb9a09e4f05260f19c9e626457e3a7f2835c81", "html_url": "https://github.com/rust-lang/rust/commit/f7cb9a09e4f05260f19c9e626457e3a7f2835c81"}, {"sha": "fd6a90860c97442df45101ee15ca4637b5ab963f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6a90860c97442df45101ee15ca4637b5ab963f", "html_url": "https://github.com/rust-lang/rust/commit/fd6a90860c97442df45101ee15ca4637b5ab963f"}], "stats": {"total": 132, "additions": 115, "deletions": 17}, "files": [{"sha": "0fd35ff65652677f79f0f92f6668d8e7cbbee69a", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -7,7 +7,7 @@ use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n     NoMirFor(String),\n@@ -48,6 +48,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n+    ReallocatedFrozenMemory,\n+    DeallocatedFrozenMemory,\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -110,6 +112,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"cannot evaluate inline assembly\",\n             EvalError::TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n+            EvalError::ReallocatedFrozenMemory =>\n+                \"tried to reallocate frozen memory\",\n+            EvalError::DeallocatedFrozenMemory =>\n+                \"tried to deallocate frozen memory\",\n         }\n     }\n "}, {"sha": "8f3d06f8301fb98b83f0b7af258d0f4a02dbb94b", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -364,6 +364,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let global_value = self.globals\n                                        .get_mut(&id)\n                                        .expect(\"global should have been cached (freeze)\");\n+                match global_value.data.expect(\"global should have been initialized\") {\n+                    Value::ByRef(ptr) => self.memory.freeze(ptr.alloc_id)?,\n+                    Value::ByVal(val) => if let Some(alloc_id) = val.relocation {\n+                        self.memory.freeze(alloc_id)?;\n+                    },\n+                    Value::ByValPair(a, b) => {\n+                        if let Some(alloc_id) = a.relocation {\n+                            self.memory.freeze(alloc_id)?;\n+                        }\n+                        if let Some(alloc_id) = b.relocation {\n+                            self.memory.freeze(alloc_id)?;\n+                        }\n+                    },\n+                }\n                 if let Value::ByRef(ptr) = global_value.data.expect(\"global should have been initialized\") {\n                     self.memory.freeze(ptr.alloc_id)?;\n                 }\n@@ -375,7 +389,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n         }\n-        // TODO(solson): Deallocate local variables.\n+        // deallocate all locals that are backed by an allocation\n+        for (i, local) in frame.locals.into_iter().enumerate() {\n+            if let Some(Value::ByRef(ptr)) = local {\n+                trace!(\"deallocating local {}: {:?}\", i + 1, ptr);\n+                self.memory.dump(ptr.alloc_id);\n+                match self.memory.deallocate(ptr) {\n+                    // Any frozen memory means that it belongs to a constant or something referenced\n+                    // by a constant. We could alternatively check whether the alloc_id is frozen\n+                    // before calling deallocate, but this is much simpler and is probably the\n+                    // rare case.\n+                    Ok(()) | Err(EvalError::DeallocatedFrozenMemory) => {},\n+                    other => return other,\n+                }\n+            }\n+        }\n         Ok(())\n     }\n \n@@ -729,6 +757,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // Skip the initial 0 intended for LLVM GEP.\n         for field_index in path {\n             let field_offset = self.get_field_offset(ty, field_index)?;\n+            trace!(\"field_path_offset_and_ty: {}, {}, {:?}, {:?}\", field_index, ty, field_offset, offset);\n             ty = self.get_field_ty(ty, field_index)?;\n             offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n         }\n@@ -1595,8 +1624,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         let val = self.stack[frame].get_local(local);\n         let val = f(self, val)?;\n-        // can't use `set_local` here, because that's only meant for going to an initialized value\n-        self.stack[frame].locals[local.index() - 1] = val;\n+        if let Some(val) = val {\n+            self.stack[frame].set_local(local, val);\n+        } else {\n+            self.deallocate_local(frame, local)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn deallocate_local(&mut self, frame: usize, local: mir::Local) -> EvalResult<'tcx, ()> {\n+        if let Some(Value::ByRef(ptr)) = self.stack[frame].get_local(local) {\n+            self.memory.deallocate(ptr)?;\n+        }\n+        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n+        self.stack[frame].locals[local.index() - 1] = None;\n         Ok(())\n     }\n }"}, {"sha": "90564cd2fcc91e0aa14fa541c99386fbfaf5a19b", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -81,8 +81,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Assign(ref lvalue, ref rvalue) => self.eval_rvalue_into_lvalue(rvalue, lvalue)?,\n             SetDiscriminant { .. } => unimplemented!(),\n \n-            // Miri can safely ignore these. Only translation needs them.\n-            StorageLive(_) | StorageDead(_) => {}\n+            // Miri can safely ignore these. Only translation needs it.\n+            StorageLive(_) |\n+            StorageDead(_) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly."}, {"sha": "b0c24fc344f2a05b27fdb9f0956d044977fb0bf4", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n+    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n         let span = self.frame().span;\n         // add them to the stack in reverse order, because the impl that needs to run the last\n         // is the one that needs to be at the bottom of the stack\n@@ -249,6 +249,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty);\n+        trace!(\"read_discriminant_value {:?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, signed: false, .. } => {\n@@ -263,12 +264,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             RawNullablePointer { nndiscr, value } => {\n                 let discr_size = value.size(&self.tcx.data_layout).bytes() as usize;\n+                trace!(\"rawnullablepointer with size {}\", discr_size);\n                 self.read_nonnull_discriminant_value(adt_ptr, nndiscr, discr_size)?\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n                 let nonnull = adt_ptr.offset(offset.bytes() as isize);\n+                trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n                 self.read_nonnull_discriminant_value(nonnull, nndiscr, discr_size)?\n@@ -515,7 +518,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     /// push DefIds of drop impls and their argument on the given vector\n-    fn drop(\n+    pub fn drop(\n         &mut self,\n         lval: Lvalue<'tcx>,\n         ty: Ty<'tcx>,"}, {"sha": "548eb78c9678e47241103492a8ff55b9ba10ee17", "filename": "src/memory.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -1,7 +1,7 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian, self};\n use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr};\n+use std::{fmt, iter, ptr, mem};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, BareFnTy, ClosureTy, ClosureSubsts, TyCtxt};\n@@ -212,6 +212,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return self.allocate(new_size, align);\n         }\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+            return Err(EvalError::ReallocatedFrozenMemory);\n+        }\n \n         let size = self.get(ptr.alloc_id)?.bytes.len();\n \n@@ -242,6 +245,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+            return Err(EvalError::DeallocatedFrozenMemory);\n+        }\n \n         if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n             self.memory_usage -= alloc.bytes.len();\n@@ -333,11 +339,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n         while let Some(id) = allocs_to_print.pop_front() {\n             allocs_seen.insert(id);\n+            if id == ZST_ALLOC_ID || id == NEVER_ALLOC_ID { continue; }\n             let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n-            if id == ZST_ALLOC_ID {\n-                trace!(\"{} zst allocation\", msg);\n-                continue;\n-            }\n             let prefix_len = msg.len();\n             let mut relocations = vec![];\n \n@@ -379,7 +382,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 let relocation_width = (self.pointer_size() - 1) * 3;\n                 for (i, target_id) in relocations {\n                     write!(msg, \"{:1$}\", \"\", (i - pos) * 3).unwrap();\n-                    write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", format!(\"({})\", target_id), relocation_width).unwrap();\n+                    let target = match target_id {\n+                        ZST_ALLOC_ID => String::from(\"zst\"),\n+                        NEVER_ALLOC_ID => String::from(\"int ptr\"),\n+                        _ => format!(\"({})\", target_id),\n+                    };\n+                    write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width).unwrap();\n                     pos = i + self.pointer_size();\n                 }\n                 trace!(\"{}\", msg);\n@@ -446,10 +454,25 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n-        // It's not possible to freeze the zero-sized allocation, because it doesn't exist.\n-        if alloc_id != ZST_ALLOC_ID {\n-            self.get_mut(alloc_id)?.immutable = true;\n+        // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n+        // sub-element or have circular pointers (e.g. `Rc`-cycles)\n+        let relocations = match self.alloc_map.get_mut(&alloc_id) {\n+            Some(ref mut alloc) if !alloc.immutable => {\n+                alloc.immutable = true;\n+                // take out the relocations vector to free the borrow on self, so we can call\n+                // freeze recursively\n+                mem::replace(&mut alloc.relocations, Default::default())\n+            },\n+            None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => return Ok(()),\n+            None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n+            _ => return Ok(()),\n+        };\n+        // recurse into inner allocations\n+        for &alloc in relocations.values() {\n+            self.freeze(alloc)?;\n         }\n+        // put back the relocations\n+        self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;\n         Ok(())\n     }\n "}, {"sha": "5a8fd189aae7de18435b00723393429bb5bc17dc", "filename": "tests/compile-fail/modifying_constants.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is frozen, not the pointee\n+    let y = unsafe { &mut *(x as *const i32 as *mut i32) };\n+    *y = 42; //~ ERROR tried to modify constant memory\n+    assert_eq!(*x, 42);\n+}"}, {"sha": "2e6320eb8025725ac802390ccbe674e9068d6791", "filename": "tests/run-pass/move-arg-3-unique.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3973b9961e5db2df943045ca455bade450b6d476/tests%2Frun-pass%2Fmove-arg-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3973b9961e5db2df943045ca455bade450b6d476/tests%2Frun-pass%2Fmove-arg-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-3-unique.rs?ref=3973b9961e5db2df943045ca455bade450b6d476", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_features, unused_variables)]\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 10;\n+    let y = x;\n+    assert_eq!(*y, 10);\n+}"}]}