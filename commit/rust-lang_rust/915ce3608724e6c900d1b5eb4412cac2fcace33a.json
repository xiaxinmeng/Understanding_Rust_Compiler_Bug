{"sha": "915ce3608724e6c900d1b5eb4412cac2fcace33a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNWNlMzYwODcyNGU2YzkwMGQxYjVlYjQ0MTJjYWMyZmNhY2UzM2E=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-10-17T23:11:59Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-10-17T23:18:59Z"}, "message": "manual_unwrap_or / support Result::unwrap_or", "tree": {"sha": "76143203eaa513b4c489e14ec41fefbf1e580c9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76143203eaa513b4c489e14ec41fefbf1e580c9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/915ce3608724e6c900d1b5eb4412cac2fcace33a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/915ce3608724e6c900d1b5eb4412cac2fcace33a", "html_url": "https://github.com/rust-lang/rust/commit/915ce3608724e6c900d1b5eb4412cac2fcace33a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/915ce3608724e6c900d1b5eb4412cac2fcace33a/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01dd31fa60d2decef6322b94b65bd25a1194537e", "url": "https://api.github.com/repos/rust-lang/rust/commits/01dd31fa60d2decef6322b94b65bd25a1194537e", "html_url": "https://github.com/rust-lang/rust/commit/01dd31fa60d2decef6322b94b65bd25a1194537e"}], "stats": {"total": 247, "additions": 216, "deletions": 31}, "files": [{"sha": "f3f1e31abde73829e7a9179d49ffaaa8e7ce1396", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/915ce3608724e6c900d1b5eb4412cac2fcace33a/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915ce3608724e6c900d1b5eb4412cac2fcace33a/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=915ce3608724e6c900d1b5eb4412cac2fcace33a", "patch": "@@ -2,15 +2,15 @@ use crate::consts::constant_simple;\n use crate::utils;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Arm, Expr, ExprKind, PatKind, QPath};\n+use rustc_hir::{def, Arm, Expr, ExprKind, Pat, PatKind, QPath};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Finds patterns that reimplement `Option::unwrap_or`.\n+    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n     ///\n     /// **Why is this bad?**\n     /// Concise code helps focusing on behavior instead of boilerplate.\n@@ -33,7 +33,7 @@ declare_clippy_lint! {\n     /// ```\n     pub MANUAL_UNWRAP_OR,\n     complexity,\n-    \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\"\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n }\n \n declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n@@ -43,32 +43,50 @@ impl LateLintPass<'_> for ManualUnwrapOr {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        lint_option_unwrap_or_case(cx, expr);\n+        lint_manual_unwrap_or(cx, expr);\n     }\n }\n \n-fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_none_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+#[derive(Copy, Clone)]\n+enum Case {\n+    Option,\n+    Result,\n+}\n+\n+impl Case {\n+    fn unwrap_fn_path(&self) -> &str {\n+        match self {\n+            Case::Option => \"Option::unwrap_or\",\n+            Case::Result => \"Result::unwrap_or\",\n+        }\n+    }\n+}\n+\n+fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn applicable_or_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n             if arms.len() == 2;\n             if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, none_arm)) = arms.iter().enumerate().find(|(_, arm)|\n-                if let PatKind::Path(ref qpath) = arm.pat.kind {\n-                    utils::match_qpath(qpath, &utils::paths::OPTION_NONE)\n-                } else {\n-                    false\n+            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+                match arm.pat.kind {\n+                    PatKind::Path(ref some_qpath) =>\n+                        utils::match_qpath(some_qpath, &utils::paths::OPTION_NONE),\n+                    PatKind::TupleStruct(ref err_qpath, &[Pat { kind: PatKind::Wild, .. }], _) =>\n+                        utils::match_qpath(err_qpath, &utils::paths::RESULT_ERR),\n+                    _ => false,\n                 }\n             );\n-            let some_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref some_qpath, &[some_binding], _) = some_arm.pat.kind;\n-            if utils::match_qpath(some_qpath, &utils::paths::OPTION_SOME);\n-            if let PatKind::Binding(_, binding_hir_id, ..) = some_binding.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, body_path)) = some_arm.body.kind;\n+            let unwrap_arm = &arms[1 - idx];\n+            if let PatKind::TupleStruct(ref unwrap_qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n+            if utils::match_qpath(unwrap_qpath, &utils::paths::OPTION_SOME)\n+                || utils::match_qpath(unwrap_qpath, &utils::paths::RESULT_OK);\n+            if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, body_path)) = unwrap_arm.body.kind;\n             if let def::Res::Local(body_path_hir_id) = body_path.res;\n             if body_path_hir_id == binding_hir_id;\n-            if !utils::usage::contains_return_break_continue_macro(none_arm.body);\n+            if !utils::usage::contains_return_break_continue_macro(or_arm.body);\n             then {\n-                Some(none_arm)\n+                Some(or_arm)\n             } else {\n                 None\n             }\n@@ -78,24 +96,35 @@ fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tc\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if utils::is_type_diagnostic_item(cx, ty, sym!(option_type));\n-        if let Some(none_arm) = applicable_none_arm(match_arms);\n+        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+            Some(Case::Option)\n+        } else if utils::is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+            Some(Case::Result)\n+        } else {\n+            None\n+        };\n+        if let Some(or_arm) = applicable_or_arm(match_arms);\n         if let Some(scrutinee_snippet) = utils::snippet_opt(cx, scrutinee.span);\n-        if let Some(none_body_snippet) = utils::snippet_opt(cx, none_arm.body.span);\n+        if let Some(or_body_snippet) = utils::snippet_opt(cx, or_arm.body.span);\n         if let Some(indent) = utils::indent_of(cx, expr.span);\n-        if constant_simple(cx, cx.typeck_results(), none_arm.body).is_some();\n+        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n         then {\n-            let reindented_none_body =\n-                utils::reindent_multiline(none_body_snippet.into(), true, Some(indent));\n+            let reindented_or_body =\n+                utils::reindent_multiline(or_body_snippet.into(), true, Some(indent));\n+            let wrap_in_parens = !matches!(scrutinee, Expr { kind: ExprKind::Call(..), .. });\n+            let l_paren = if wrap_in_parens { \"(\" } else { \"\" };\n+            let r_paren = if wrap_in_parens { \")\" } else { \"\" };\n             utils::span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n-                \"this pattern reimplements `Option::unwrap_or`\",\n+                &format!(\"this pattern reimplements `{}`\", case.unwrap_fn_path()),\n                 \"replace with\",\n                 format!(\n-                    \"{}.unwrap_or({})\",\n+                    \"{}{}{}.unwrap_or({})\",\n+                    l_paren,\n                     scrutinee_snippet,\n-                    reindented_none_body,\n+                    r_paren,\n+                    reindented_or_body,\n                 ),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "b930d9aedcff30909e9916b1afbb83c4c4dacee2", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/915ce3608724e6c900d1b5eb4412cac2fcace33a/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915ce3608724e6c900d1b5eb4412cac2fcace33a/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=915ce3608724e6c900d1b5eb4412cac2fcace33a", "patch": "@@ -1183,7 +1183,7 @@ vec![\n     Lint {\n         name: \"manual_unwrap_or\",\n         group: \"complexity\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\",\n         deprecation: None,\n         module: \"manual_unwrap_or\",\n     },"}, {"sha": "ceb8985d3d5142c340f1e88fccb595d370af7dcd", "filename": "tests/ui/manual_unwrap_or.fixed", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/915ce3608724e6c900d1b5eb4412cac2fcace33a/tests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/915ce3608724e6c900d1b5eb4412cac2fcace33a/tests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.fixed?ref=915ce3608724e6c900d1b5eb4412cac2fcace33a", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n #![allow(dead_code)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     Some(1).unwrap_or(42);\n \n@@ -65,4 +65,46 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    (Ok(1) as Result<i32, &str>).unwrap_or(42);\n+\n+    // int case reversed\n+    (Ok(1) as Result<i32, &str>).unwrap_or(42);\n+\n+    // richer none expr\n+    (Ok(1) as Result<i32, &str>).unwrap_or(1 + 42);\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    (Ok(1) as Result<i32, &str>).unwrap_or({\n+        42 + 42\n+            + 42 + 42 + 42\n+            + 42 + 42 + 42\n+    });\n+\n+    // string case\n+    (Ok(\"Bob\") as Result<&str, &str>).unwrap_or(\"Alice\");\n+\n+    // don't lint\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok(j) as Result<i32, &str> {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok(j) as Result<i32, &str> {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "beca1de0ed1651861e9107fdfed16a9cc23bea8f", "filename": "tests/ui/manual_unwrap_or.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/915ce3608724e6c900d1b5eb4412cac2fcace33a/tests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915ce3608724e6c900d1b5eb4412cac2fcace33a/tests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.rs?ref=915ce3608724e6c900d1b5eb4412cac2fcace33a", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n #![allow(dead_code)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     match Some(1) {\n         Some(i) => i,\n@@ -80,4 +80,61 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case reversed\n+    match Ok(1) as Result<i32, &str> {\n+        Err(_) => 42,\n+        Ok(i) => i,\n+    };\n+\n+    // richer none expr\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => 1 + 42,\n+    };\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => {\n+            42 + 42\n+                + 42 + 42 + 42\n+                + 42 + 42 + 42\n+        }\n+    };\n+\n+    // string case\n+    match Ok(\"Bob\") as Result<&str, &str> {\n+        Ok(i) => i,\n+        Err(_) => \"Alice\",\n+    };\n+\n+    // don't lint\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok(j) as Result<i32, &str> {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok(j) as Result<i32, &str> {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "5d465666caf0fd10fe119947b53a1377fee3ad4e", "filename": "tests/ui/manual_unwrap_or.stderr", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/915ce3608724e6c900d1b5eb4412cac2fcace33a/tests%2Fui%2Fmanual_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/915ce3608724e6c900d1b5eb4412cac2fcace33a/tests%2Fui%2Fmanual_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.stderr?ref=915ce3608724e6c900d1b5eb4412cac2fcace33a", "patch": "@@ -57,5 +57,62 @@ LL | |         None => \"Alice\",\n LL | |     };\n    | |_____^ help: replace with: `Some(\"Bob\").unwrap_or(\"Alice\")`\n \n-error: aborting due to 5 previous errors\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:85:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(1) as Result<i32, &str>).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:91:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Err(_) => 42,\n+LL | |         Ok(i) => i,\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(1) as Result<i32, &str>).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:97:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 1 + 42,\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(1) as Result<i32, &str>).unwrap_or(1 + 42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:104:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => {\n+LL | |             42 + 42\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     (Ok(1) as Result<i32, &str>).unwrap_or({\n+LL |         42 + 42\n+LL |             + 42 + 42 + 42\n+LL |             + 42 + 42 + 42\n+LL |     });\n+   |\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:114:5\n+   |\n+LL | /     match Ok(\"Bob\") as Result<&str, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => \"Alice\",\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(\"Bob\") as Result<&str, &str>).unwrap_or(\"Alice\")`\n+\n+error: aborting due to 10 previous errors\n "}]}