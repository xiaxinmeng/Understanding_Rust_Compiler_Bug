{"sha": "df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMDQ0ZWE0YWM4ZmI3Zjk5NjIyOTQ4ZjRmOGM0MGZiZDI0ZWRhMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-01T15:21:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-01T15:21:23Z"}, "message": "auto merge of #11944 : nathanielherman/rust/vec_opt, r=alexcrichton\n\nCloses #11733", "tree": {"sha": "f560de5e155ea54a734a977edc8bfe5a5397ca93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f560de5e155ea54a734a977edc8bfe5a5397ca93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "html_url": "https://github.com/rust-lang/rust/commit/df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "362cbbe01c58a8e2b233cdfa9038b6e31ca8d318", "url": "https://api.github.com/repos/rust-lang/rust/commits/362cbbe01c58a8e2b233cdfa9038b6e31ca8d318", "html_url": "https://github.com/rust-lang/rust/commit/362cbbe01c58a8e2b233cdfa9038b6e31ca8d318"}, {"sha": "d9fadbc04f5bbd520e4ce8665ac128288e9846c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9fadbc04f5bbd520e4ce8665ac128288e9846c0", "html_url": "https://github.com/rust-lang/rust/commit/d9fadbc04f5bbd520e4ce8665ac128288e9846c0"}], "stats": {"total": 112, "additions": 57, "deletions": 55}, "files": [{"sha": "a4c5038626232c184a48486bd6b527fc46f07557", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "patch": "@@ -303,7 +303,7 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n             &mut self.remaining2\n         };\n         self.nelts -= 1;\n-        Some(r.mut_shift_ref().get_mut_ref())\n+        Some(r.mut_shift_ref().unwrap().get_mut_ref())\n     }\n \n     #[inline]\n@@ -325,7 +325,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n             &mut self.remaining1\n         };\n         self.nelts -= 1;\n-        Some(r.mut_pop_ref().get_mut_ref())\n+        Some(r.mut_pop_ref().unwrap().get_mut_ref())\n     }\n }\n "}, {"sha": "acbbdf27d1c266cf37ba28ba1b3192021246e6ca", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "patch": "@@ -662,7 +662,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         // Check if a landing pad block exists; if not, create one.\n         {\n             let mut scopes = self.scopes.borrow_mut();\n-            let last_scope = scopes.get().mut_last();\n+            let last_scope = scopes.get().mut_last().unwrap();\n             match last_scope.cached_landing_pad {\n                 Some(llbb) => { return llbb; }\n                 None => {"}, {"sha": "7e4405fd545bde704d8563038aaecdf1c9e5bda7", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "patch": "@@ -1000,14 +1000,15 @@ pub trait ImmutableVector<'a, T> {\n      * Equivalent to:\n      *\n      * ```\n+     *     if self.len() == 0 { return None }\n      *     let head = &self[0];\n      *     *self = self.slice_from(1);\n-     *     head\n+     *     Some(head)\n      * ```\n      *\n-     * Fails if slice is empty.\n+     * Returns `None` if vector is empty\n      */\n-    fn shift_ref(&mut self) -> &'a T;\n+    fn shift_ref(&mut self) -> Option<&'a T>;\n \n     /**\n      * Returns a mutable reference to the last element in this slice\n@@ -1017,14 +1018,15 @@ pub trait ImmutableVector<'a, T> {\n      * Equivalent to:\n      *\n      * ```\n+     *     if self.len() == 0 { return None; }\n      *     let tail = &self[self.len() - 1];\n      *     *self = self.slice_to(self.len() - 1);\n-     *     tail\n+     *     Some(tail)\n      * ```\n      *\n-     * Fails if slice is empty.\n+     * Returns `None` if slice is empty.\n      */\n-    fn pop_ref(&mut self) -> &'a T;\n+    fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n@@ -1183,17 +1185,19 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         self.iter().map(f).collect()\n     }\n \n-    fn shift_ref(&mut self) -> &'a T {\n+    fn shift_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n-            &*raw::shift_ptr(s)\n+            Some(&*raw::shift_ptr(s))\n         }\n     }\n \n-    fn pop_ref(&mut self) -> &'a T {\n+    fn pop_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n-            &*raw::pop_ptr(s)\n+            Some(&*raw::pop_ptr(s))\n         }\n     }\n }\n@@ -2028,7 +2032,7 @@ pub trait MutableVector<'a, T> {\n     fn mut_iter(self) -> MutItems<'a, T>;\n \n     /// Returns a mutable pointer to the last item in the vector.\n-    fn mut_last(self) -> &'a mut T;\n+    fn mut_last(self) -> Option<&'a mut T>;\n \n     /// Returns a reversed iterator that allows modifying each value\n     fn mut_rev_iter(self) -> RevMutItems<'a, T>;\n@@ -2058,14 +2062,15 @@ pub trait MutableVector<'a, T> {\n      * Equivalent to:\n      *\n      * ```\n+     *     if self.len() == 0 { return None; }\n      *     let head = &mut self[0];\n      *     *self = self.mut_slice_from(1);\n-     *     head\n+     *     Some(head)\n      * ```\n      *\n-     * Fails if slice is empty.\n+     * Returns `None` if slice is empty\n      */\n-    fn mut_shift_ref(&mut self) -> &'a mut T;\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n \n     /**\n      * Returns a mutable reference to the last element in this slice\n@@ -2075,14 +2080,15 @@ pub trait MutableVector<'a, T> {\n      * Equivalent to:\n      *\n      * ```\n+     *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n      *     *self = self.mut_slice_to(self.len() - 1);\n-     *     tail\n+     *     Some(tail)\n      * ```\n      *\n-     * Fails if slice is empty.\n+     * Returns `None` if slice is empty.\n      */\n-    fn mut_pop_ref(&mut self) -> &'a mut T;\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n \n     /// Swaps two elements in a vector.\n     ///\n@@ -2293,10 +2299,10 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn mut_last(self) -> &'a mut T {\n+    fn mut_last(self) -> Option<&'a mut T> {\n         let len = self.len();\n-        if len == 0 { fail!(\"mut_last: empty vector\") }\n-        &mut self[len - 1]\n+        if len == 0 { return None; }\n+        Some(&mut self[len - 1])\n     }\n \n     #[inline]\n@@ -2315,17 +2321,19 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n-    fn mut_shift_ref(&mut self) -> &'a mut T {\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n-            cast::transmute_mut(&*raw::shift_ptr(s))\n+            Some(cast::transmute_mut(&*raw::shift_ptr(s)))\n         }\n     }\n \n-    fn mut_pop_ref(&mut self) -> &'a mut T {\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n-            cast::transmute_mut(&*raw::pop_ptr(s))\n+            Some(cast::transmute_mut(&*raw::pop_ptr(s)))\n         }\n     }\n \n@@ -4195,34 +4203,26 @@ mod tests {\n     fn test_shift_ref() {\n         let mut x: &[int] = [1, 2, 3, 4, 5];\n         let h = x.shift_ref();\n-        assert_eq!(*h, 1);\n+        assert_eq!(*h.unwrap(), 1);\n         assert_eq!(x.len(), 4);\n         assert_eq!(x[0], 2);\n         assert_eq!(x[3], 5);\n-    }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_shift_ref_empty() {\n-        let mut x: &[int] = [];\n-        x.shift_ref();\n+        let mut y: &[int] = [];\n+        assert_eq!(y.shift_ref(), None);\n     }\n \n     #[test]\n     fn test_pop_ref() {\n         let mut x: &[int] = [1, 2, 3, 4, 5];\n         let h = x.pop_ref();\n-        assert_eq!(*h, 5);\n+        assert_eq!(*h.unwrap(), 5);\n         assert_eq!(x.len(), 4);\n         assert_eq!(x[0], 1);\n         assert_eq!(x[3], 4);\n-    }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_pop_ref_empty() {\n-        let mut x: &[int] = [];\n-        x.pop_ref();\n+        let mut y: &[int] = [];\n+        assert!(y.pop_ref().is_none());\n     }\n \n     #[test]\n@@ -4285,34 +4285,36 @@ mod tests {\n     fn test_mut_shift_ref() {\n         let mut x: &mut [int] = [1, 2, 3, 4, 5];\n         let h = x.mut_shift_ref();\n-        assert_eq!(*h, 1);\n+        assert_eq!(*h.unwrap(), 1);\n         assert_eq!(x.len(), 4);\n         assert_eq!(x[0], 2);\n         assert_eq!(x[3], 5);\n-    }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_mut_shift_ref_empty() {\n-        let mut x: &mut [int] = [];\n-        x.mut_shift_ref();\n+        let mut y: &mut [int] = [];\n+        assert!(y.mut_shift_ref().is_none());\n     }\n \n     #[test]\n     fn test_mut_pop_ref() {\n         let mut x: &mut [int] = [1, 2, 3, 4, 5];\n         let h = x.mut_pop_ref();\n-        assert_eq!(*h, 5);\n+        assert_eq!(*h.unwrap(), 5);\n         assert_eq!(x.len(), 4);\n         assert_eq!(x[0], 1);\n         assert_eq!(x[3], 4);\n+\n+        let mut y: &mut [int] = [];\n+        assert!(y.mut_pop_ref().is_none());\n     }\n \n     #[test]\n-    #[should_fail]\n-    fn test_mut_pop_ref_empty() {\n-        let mut x: &mut [int] = [];\n-        x.mut_pop_ref();\n+    fn test_mut_last() {\n+        let mut x = [1, 2, 3, 4, 5];\n+        let h = x.mut_last();\n+        assert_eq!(*h.unwrap(), 5);\n+\n+        let mut y: &mut [int] = [];\n+        assert!(y.mut_last().is_none());\n     }\n }\n "}, {"sha": "c575e170bef45048120be162aaf5f8531f4a1d4d", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df044ea4ac8fb7f99622948f4f8c40fbd24eda13/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=df044ea4ac8fb7f99622948f4f8c40fbd24eda13", "patch": "@@ -62,10 +62,10 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pub fn mut_last<'a>(&'a mut self) -> &'a mut T {\n+    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n         match *self {\n             Vec(ref mut v) => v.mut_last(),\n-            Empty => fail!(\"mut_last on empty opt_vec\")\n+            Empty => None\n         }\n     }\n "}]}