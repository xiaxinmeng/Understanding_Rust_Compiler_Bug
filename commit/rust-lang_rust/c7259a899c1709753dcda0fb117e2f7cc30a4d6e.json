{"sha": "c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MjU5YTg5OWMxNzA5NzUzZGNkYTBmYjExN2UyZjdjYzMwYTRkNmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-14T09:54:03Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:52:05Z"}, "message": "remove ItemMap", "tree": {"sha": "410be0a8db17aca2d9878b0b2ac36d1921660990", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/410be0a8db17aca2d9878b0b2ac36d1921660990"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "html_url": "https://github.com/rust-lang/rust/commit/c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "html_url": "https://github.com/rust-lang/rust/commit/71e5adf694a4b253bc5bb48be96bb6ba08002d8c"}], "stats": {"total": 628, "additions": 59, "deletions": 569}, "files": [{"sha": "86c26f1d8a8ed6c0f0a81c42bdba12ce4bb320b8", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -173,16 +173,16 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(&self, db: &impl HirDatabase) -> ModuleScope {\n-        db.item_map(self.krate)[self.module_id].clone()\n+        db.crate_def_map(self.krate)[self.module_id].scope.clone()\n     }\n \n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         self.problems_impl(db)\n     }\n \n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n-        let item_map = db.item_map(self.krate);\n-        Resolver::default().push_module_scope(item_map, *self)\n+        let def_map = db.crate_def_map(self.krate);\n+        Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n \n     pub fn declarations(self, db: &impl HirDatabase) -> Vec<ModuleDef> {"}, {"sha": "0190f49872ca7c4594d120bf96af5e4b1ae84bcb", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n     macros::MacroExpansion,\n-    nameres::{Namespace, ItemMap, lower::{LoweredModule, ImportSourceMap}, crate_def_map::{RawItems, CrateDefMap}},\n+    nameres::{Namespace, lower::{LoweredModule, ImportSourceMap}, crate_def_map::{RawItems, CrateDefMap}},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n@@ -50,9 +50,6 @@ pub trait PersistentHirDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n \n-    #[salsa::invoke(crate::nameres::ItemMap::item_map_query)]\n-    fn item_map(&self, krate: Crate) -> Arc<ItemMap>;\n-\n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n "}, {"sha": "a188a3cc8ef4d155a48db5f6f2657dd32b066052", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -54,7 +54,7 @@ pub use self::{\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n-    nameres::{ItemMap, PerNs, Namespace},\n+    nameres::{PerNs, Namespace},\n     ty::{Ty, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},"}, {"sha": "2248842def7a19260dd9d969f3652088c91751e4", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 535, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -17,43 +17,15 @@\n pub(crate) mod lower;\n pub(crate) mod crate_def_map;\n \n-use std::{time, sync::Arc};\n-\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use ra_arena::map::ArenaMap;\n+use rustc_hash::FxHashMap;\n use ra_db::Edition;\n-use test_utils::tested_by;\n \n use crate::{\n-    Module, ModuleDef,\n-    Path, PathKind, PersistentHirDatabase,\n-    Crate, Name,\n-    nameres::{\n-        crate_def_map::{CrateDefMap, ModuleId},\n-        lower::{ImportId, LoweredModule, ImportData}\n-    },\n+    ModuleDef, Name,\n+    nameres::lower::ImportId,\n };\n \n-/// `ItemMap` is the result of module name resolution. It contains, for each\n-/// module, the set of visible items.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ItemMap {\n-    edition: Edition,\n-    /// The prelude module for this crate. This either comes from an import\n-    /// marked with the `prelude_import` attribute, or (in the normal case) from\n-    /// a dependency (`std` or `core`).\n-    pub(crate) prelude: Option<Module>,\n-    pub(crate) extern_prelude: FxHashMap<Name, ModuleDef>,\n-    per_module: ArenaMap<ModuleId, ModuleScope>,\n-}\n-\n-impl std::ops::Index<ModuleId> for ItemMap {\n-    type Output = ModuleScope;\n-    fn index(&self, id: ModuleId) -> &ModuleScope {\n-        &self.per_module[id]\n-    }\n-}\n+pub(crate) use self::crate_def_map::{CrateDefMap, ModuleId};\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n@@ -158,292 +130,6 @@ impl<T> PerNs<T> {\n     }\n }\n \n-struct Resolver<'a, DB> {\n-    db: &'a DB,\n-    input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-    krate: Crate,\n-    def_map: Arc<CrateDefMap>,\n-    processed_imports: FxHashSet<(ModuleId, ImportId)>,\n-    /// If module `a` has `use b::*`, then this contains the mapping b -> a (and the import)\n-    glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, ImportId)>>,\n-    result: ItemMap,\n-}\n-\n-impl<'a, DB> Resolver<'a, DB>\n-where\n-    DB: PersistentHirDatabase,\n-{\n-    fn new(\n-        db: &'a DB,\n-        input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-        krate: Crate,\n-    ) -> Resolver<'a, DB> {\n-        Resolver {\n-            db,\n-            input,\n-            krate,\n-            def_map: db.crate_def_map(krate),\n-            processed_imports: FxHashSet::default(),\n-            glob_imports: FxHashMap::default(),\n-            result: ItemMap {\n-                edition: krate.edition(db),\n-                prelude: None,\n-                extern_prelude: FxHashMap::default(),\n-                per_module: ArenaMap::default(),\n-            },\n-        }\n-    }\n-\n-    pub(crate) fn resolve(mut self) -> ItemMap {\n-        self.populate_extern_prelude();\n-        for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, Arc::clone(items));\n-        }\n-\n-        let mut iter = 0;\n-        loop {\n-            iter += 1;\n-            if iter > 1000 {\n-                panic!(\"failed to reach fixedpoint after 1000 iters\")\n-            }\n-            let processed_imports_count = self.processed_imports.len();\n-            for &module_id in self.input.keys() {\n-                self.db.check_canceled();\n-                self.resolve_imports(module_id);\n-            }\n-            if processed_imports_count == self.processed_imports.len() {\n-                // no new imports resolved\n-                break;\n-            }\n-        }\n-        self.result\n-    }\n-\n-    fn populate_extern_prelude(&mut self) {\n-        for dep in self.krate.dependencies(self.db) {\n-            log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n-            if let Some(module) = dep.krate.root_module(self.db) {\n-                self.result.extern_prelude.insert(dep.name.clone(), module.into());\n-            }\n-            // look for the prelude\n-            if self.result.prelude.is_none() {\n-                let item_map = self.db.item_map(dep.krate);\n-                if item_map.prelude.is_some() {\n-                    self.result.prelude = item_map.prelude;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn populate_module(&mut self, module_id: ModuleId, input: Arc<LoweredModule>) {\n-        let mut module_items = ModuleScope::default();\n-        for (import_id, import_data) in input.imports.iter() {\n-            if let Some(last_segment) = import_data.path.segments.iter().last() {\n-                if !import_data.is_glob {\n-                    let name =\n-                        import_data.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n-                    module_items\n-                        .items\n-                        .insert(name, Resolution { def: PerNs::none(), import: Some(import_id) });\n-                }\n-            }\n-        }\n-        // Populate explicitly declared items, except modules\n-        for (name, &def) in input.declarations.iter() {\n-            let resolution = Resolution { def, import: None };\n-            module_items.items.insert(name.clone(), resolution);\n-        }\n-\n-        // Populate modules\n-        for (name, module_id) in self.def_map[module_id].children.iter() {\n-            let module = Module { module_id: *module_id, krate: self.krate };\n-            self.add_module_item(&mut module_items, name.clone(), PerNs::types(module.into()));\n-        }\n-\n-        self.result.per_module.insert(module_id, module_items);\n-    }\n-\n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def: PerNs<ModuleDef>) {\n-        let resolution = Resolution { def, import: None };\n-        module_items.items.insert(name, resolution);\n-    }\n-\n-    fn resolve_imports(&mut self, module_id: ModuleId) {\n-        for (import_id, import_data) in self.input[&module_id].imports.iter() {\n-            if self.processed_imports.contains(&(module_id, import_id)) {\n-                // already done\n-                continue;\n-            }\n-            if self.resolve_import(module_id, import_id, import_data) == ReachedFixedPoint::Yes {\n-                log::debug!(\"import {:?} resolved (or definite error)\", import_id);\n-                self.processed_imports.insert((module_id, import_id));\n-            }\n-        }\n-    }\n-\n-    fn resolve_import(\n-        &mut self,\n-        module_id: ModuleId,\n-        import_id: ImportId,\n-        import: &ImportData,\n-    ) -> ReachedFixedPoint {\n-        log::debug!(\"resolving import: {:?} ({:?})\", import, self.result.edition);\n-        let original_module = Module { krate: self.krate, module_id };\n-\n-        let (def, reached_fixedpoint) = if import.is_extern_crate {\n-            let res = self.result.resolve_name_in_extern_prelude(\n-                &import\n-                    .path\n-                    .as_ident()\n-                    .expect(\"extern crate should have been desugared to one-element path\"),\n-            );\n-            (res, if res.is_none() { ReachedFixedPoint::No } else { ReachedFixedPoint::Yes })\n-        } else {\n-            let res = self.result.resolve_path_fp(\n-                self.db,\n-                ResolveMode::Import,\n-                original_module,\n-                &import.path,\n-            );\n-\n-            (res.resolved_def, res.reached_fixedpoint)\n-        };\n-\n-        if reached_fixedpoint != ReachedFixedPoint::Yes {\n-            return reached_fixedpoint;\n-        }\n-\n-        if import.is_glob {\n-            log::debug!(\"glob import: {:?}\", import);\n-            match def.take_types() {\n-                Some(ModuleDef::Module(m)) => {\n-                    if import.is_prelude {\n-                        tested_by!(std_prelude);\n-                        self.result.prelude = Some(m);\n-                    } else if m.krate != self.krate {\n-                        tested_by!(glob_across_crates);\n-                        // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.item_map(m.krate);\n-                        let scope = &item_map[m.module_id];\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &items);\n-                    } else {\n-                        // glob import from same crate => we do an initial\n-                        // import, and then need to propagate any further\n-                        // additions\n-                        let scope = &self.result[m.module_id];\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &items);\n-                        // record the glob import in case we add further items\n-                        self.glob_imports\n-                            .entry(m.module_id)\n-                            .or_default()\n-                            .push((module_id, import_id));\n-                    }\n-                }\n-                Some(ModuleDef::Enum(e)) => {\n-                    tested_by!(glob_enum);\n-                    // glob import from enum => just import all the variants\n-                    let variants = e.variants(self.db);\n-                    let resolutions = variants\n-                        .into_iter()\n-                        .filter_map(|variant| {\n-                            let res = Resolution {\n-                                def: PerNs::both(variant.into(), variant.into()),\n-                                import: Some(import_id),\n-                            };\n-                            let name = variant.name(self.db)?;\n-                            Some((name, res))\n-                        })\n-                        .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n-                }\n-                Some(d) => {\n-                    log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n-                }\n-                None => {\n-                    log::debug!(\"glob import {:?} didn't resolve as type\", import);\n-                }\n-            }\n-        } else {\n-            let last_segment = import.path.segments.last().unwrap();\n-            let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n-            log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n-\n-            // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n-            if let Some(root_module) = self.krate.root_module(self.db) {\n-                if import.is_extern_crate && module_id == root_module.module_id {\n-                    if let Some(def) = def.take_types() {\n-                        self.result.extern_prelude.insert(name.clone(), def);\n-                    }\n-                }\n-            }\n-            let resolution = Resolution { def, import: Some(import_id) };\n-            self.update(module_id, None, &[(name, resolution)]);\n-        }\n-        reached_fixedpoint\n-    }\n-\n-    fn update(\n-        &mut self,\n-        module_id: ModuleId,\n-        import: Option<ImportId>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n-    }\n-\n-    fn update_recursive(\n-        &mut self,\n-        module_id: ModuleId,\n-        import: Option<ImportId>,\n-        resolutions: &[(Name, Resolution)],\n-        depth: usize,\n-    ) {\n-        if depth > 100 {\n-            // prevent stack overflows (but this shouldn't be possible)\n-            panic!(\"infinite recursion in glob imports!\");\n-        }\n-        let module_items = self.result.per_module.get_mut(module_id).unwrap();\n-        let mut changed = false;\n-        for (name, res) in resolutions {\n-            let existing = module_items.items.entry(name.clone()).or_default();\n-            if existing.def.types.is_none() && res.def.types.is_some() {\n-                existing.def.types = res.def.types;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.values.is_none() && res.def.values.is_some() {\n-                existing.def.values = res.def.values;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-        }\n-        if !changed {\n-            return;\n-        }\n-        let glob_imports = self\n-            .glob_imports\n-            .get(&module_id)\n-            .into_iter()\n-            .flat_map(|v| v.iter())\n-            .cloned()\n-            .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n-            // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone)]\n struct ResolvePathResult {\n     resolved_def: PerNs<ModuleDef>,\n@@ -476,220 +162,3 @@ enum ReachedFixedPoint {\n     Yes,\n     No,\n }\n-\n-impl ItemMap {\n-    pub(crate) fn item_map_query(db: &impl PersistentHirDatabase, krate: Crate) -> Arc<ItemMap> {\n-        let start = time::Instant::now();\n-        let def_map = db.crate_def_map(krate);\n-        let input = def_map\n-            .modules()\n-            .map(|module_id| (module_id, db.lower_module(Module { krate, module_id })))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        let resolver = Resolver::new(db, &input, krate);\n-        let res = resolver.resolve();\n-        let elapsed = start.elapsed();\n-        log::info!(\"item_map: {:?}\", elapsed);\n-        Arc::new(res)\n-    }\n-\n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        original_module: Module,\n-        path: &Path,\n-    ) -> (PerNs<ModuleDef>, Option<usize>) {\n-        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def, res.segment_index)\n-    }\n-\n-    fn resolve_in_prelude(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        original_module: Module,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        if let Some(prelude) = self.prelude {\n-            let resolution = if prelude.krate == original_module.krate {\n-                self[prelude.module_id].items.get(name).cloned()\n-            } else {\n-                db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n-            };\n-            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n-\n-    pub(crate) fn resolve_name_in_module(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        // Resolve in:\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_scope = self[module.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, module, name);\n-\n-        from_scope.or(from_extern_prelude).or(from_prelude)\n-    }\n-\n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n-    }\n-\n-    fn resolve_name_in_crate_root_or_extern_prelude(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        let crate_root = module.crate_root(db);\n-        let from_crate_root =\n-            self[crate_root.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n-\n-        from_crate_root.or(from_extern_prelude)\n-    }\n-\n-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n-    // the result.\n-    fn resolve_path_fp(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        mode: ResolveMode,\n-        original_module: Module,\n-        path: &Path,\n-    ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n-            PathKind::Crate => PerNs::types(original_module.crate_root(db).into()),\n-            PathKind::Self_ => PerNs::types(original_module.into()),\n-            // plain import or absolute path in 2015: crate-relative with\n-            // fallback to extern prelude (with the simplification in\n-            // rust-lang/rust#57745)\n-            // TODO there must be a nicer way to write this condition\n-            PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n-                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n-            {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(\n-                    db,\n-                    original_module,\n-                    &segment.name,\n-                )\n-            }\n-            PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n-            }\n-            PathKind::Super => {\n-                if let Some(p) = original_module.parent(db) {\n-                    PerNs::types(p.into())\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-                }\n-            }\n-            PathKind::Abs => {\n-                // 2018-style absolute path -- only extern prelude\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n-                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n-                } else {\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n-                }\n-            }\n-        };\n-\n-        for (i, segment) in segments {\n-            let curr = match curr_per_ns.as_ref().take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because `curr_per_ns` might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDef::Module(module) => {\n-                    if module.krate != original_module.krate {\n-                        let path = Path {\n-                            segments: path.segments[i..].iter().cloned().collect(),\n-                            kind: PathKind::Self_,\n-                        };\n-                        log::debug!(\"resolving {:?} in other crate\", path);\n-                        let item_map = db.item_map(module.krate);\n-                        let (def, s) = item_map.resolve_path(db, *module, &path);\n-                        return ResolvePathResult::with(\n-                            def,\n-                            ReachedFixedPoint::Yes,\n-                            s.map(|s| s + i),\n-                        );\n-                    }\n-\n-                    match self[module.module_id].items.get(&segment.name) {\n-                        Some(res) if !res.def.is_none() => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n-                }\n-                ModuleDef::Enum(e) => {\n-                    // enum variant\n-                    tested_by!(can_import_enum_variant);\n-                    match e.variant(db, &segment.name) {\n-                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n-                        None => {\n-                            return ResolvePathResult::with(\n-                                PerNs::types((*e).into()),\n-                                ReachedFixedPoint::Yes,\n-                                Some(i),\n-                            );\n-                        }\n-                    }\n-                }\n-                s => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated item\n-                    log::debug!(\n-                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n-                        curr,\n-                    );\n-\n-                    return ResolvePathResult::with(\n-                        PerNs::types((*s).into()),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-            };\n-        }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n-    }\n-}"}, {"sha": "cc4955053567da50cedeba25a4364b81b477f8a6", "filename": "crates/ra_hir/src/nameres/crate_def_map.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -149,8 +149,16 @@ impl CrateDefMap {\n         &self.problems\n     }\n \n-    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n-        self.modules.iter().map(|(id, _data)| id)\n+    pub(crate) fn mk_module(&self, module_id: ModuleId) -> Module {\n+        Module { krate: self.krate, module_id }\n+    }\n+\n+    pub(crate) fn prelude(&self) -> Option<Module> {\n+        self.prelude\n+    }\n+\n+    pub(crate) fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDef> {\n+        &self.extern_prelude\n     }\n \n     pub(crate) fn find_module_by_source(\n@@ -169,6 +177,16 @@ impl CrateDefMap {\n         Some(module_id)\n     }\n \n+    pub(crate) fn resolve_path(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        original_module: ModuleId,\n+        path: &Path,\n+    ) -> (PerNs<ModuleDef>, Option<usize>) {\n+        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def, res.segment_index)\n+    }\n+\n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n     fn resolve_path_fp(\n@@ -254,8 +272,8 @@ impl CrateDefMap {\n                             kind: PathKind::Self_,\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let item_map = db.item_map(module.krate);\n-                        let (def, s) = item_map.resolve_path(db, *module, &path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -313,7 +331,7 @@ impl CrateDefMap {\n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn resolve_name_in_module(\n+    pub(crate) fn resolve_name_in_module(\n         &self,\n         db: &impl PersistentHirDatabase,\n         module: ModuleId,\n@@ -340,7 +358,7 @@ impl CrateDefMap {\n             let resolution = if prelude.krate == self.krate {\n                 self[prelude.module_id].scope.items.get(name).cloned()\n             } else {\n-                db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n+                db.crate_def_map(prelude.krate)[prelude.module_id].scope.items.get(name).cloned()\n             };\n             resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n         } else {"}, {"sha": "8b727e2c93aa0ee5cd46a9ce6808e9ed2519e055", "filename": "crates/ra_hir/src/nameres/crate_def_map/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -26,9 +26,9 @@ pub(super) fn collect_defs(\n         }\n         // look for the prelude\n         if def_map.prelude.is_none() {\n-            let item_map = db.item_map(dep.krate);\n-            if item_map.prelude.is_some() {\n-                def_map.prelude = item_map.prelude;\n+            let map = db.crate_def_map(dep.krate);\n+            if map.prelude.is_some() {\n+                def_map.prelude = map.prelude;\n             }\n         }\n     }\n@@ -162,8 +162,8 @@ where\n                     } else if m.krate != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.item_map(m.krate);\n-                        let scope = &item_map[m.module_id];\n+                        let item_map = self.db.crate_def_map(m.krate);\n+                        let scope = &item_map[m.module_id].scope;\n                         let items = scope\n                             .items\n                             .iter()"}, {"sha": "e85447eeb37dc2260c99ae7005cfe18ad2348cb5", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7259a899c1709753dcda0fb117e2f7cc30a4d6e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=c7259a899c1709753dcda0fb117e2f7cc30a4d6e", "patch": "@@ -4,10 +4,10 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    ModuleDef, Module,\n+    ModuleDef,\n     db::HirDatabase,\n     name::{Name, KnownName},\n-    nameres::{PerNs, ItemMap},\n+    nameres::{PerNs, CrateDefMap, ModuleId},\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n     impl_block::ImplBlock,\n@@ -22,8 +22,8 @@ pub struct Resolver {\n // TODO how to store these best\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n-    item_map: Arc<ItemMap>,\n-    module: Module,\n+    crate_def_map: Arc<CrateDefMap>,\n+    module_id: ModuleId,\n }\n \n #[derive(Debug, Clone)]\n@@ -175,9 +175,9 @@ impl Resolver {\n         names\n     }\n \n-    fn module(&self) -> Option<(&ItemMap, Module)> {\n+    fn module(&self) -> Option<(&CrateDefMap, ModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n-            Scope::ModuleScope(m) => Some((&*m.item_map, m.module.clone())),\n+            Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n             _ => None,\n         })\n@@ -206,8 +206,12 @@ impl Resolver {\n         self.push_scope(Scope::ImplBlockScope(impl_block))\n     }\n \n-    pub(crate) fn push_module_scope(self, item_map: Arc<ItemMap>, module: Module) -> Resolver {\n-        self.push_scope(Scope::ModuleScope(ModuleItemMap { item_map, module }))\n+    pub(crate) fn push_module_scope(\n+        self,\n+        crate_def_map: Arc<CrateDefMap>,\n+        module_id: ModuleId,\n+    ) -> Resolver {\n+        self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }\n \n     pub(crate) fn push_expr_scope(\n@@ -224,9 +228,11 @@ impl Scope {\n         match self {\n             Scope::ModuleScope(m) => {\n                 if let Some(KnownName::SelfParam) = name.as_known_name() {\n-                    PerNs::types(Resolution::Def(m.module.into()))\n+                    PerNs::types(Resolution::Def(m.crate_def_map.mk_module(m.module_id).into()))\n                 } else {\n-                    m.item_map.resolve_name_in_module(db, m.module, name).map(Resolution::Def)\n+                    m.crate_def_map\n+                        .resolve_name_in_module(db, m.module_id, name)\n+                        .map(Resolution::Def)\n                 }\n             }\n             Scope::GenericParams(gp) => match gp.find_by_name(name) {\n@@ -261,15 +267,15 @@ impl Scope {\n                 //         def: m.module.into(),\n                 //     }),\n                 // );\n-                m.item_map[m.module.module_id].entries().for_each(|(name, res)| {\n+                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n                     f(name.clone(), res.def.map(Resolution::Def));\n                 });\n-                m.item_map.extern_prelude.iter().for_each(|(name, def)| {\n+                m.crate_def_map.extern_prelude().iter().for_each(|(name, def)| {\n                     f(name.clone(), PerNs::types(Resolution::Def(*def)));\n                 });\n-                if let Some(prelude) = m.item_map.prelude {\n-                    let prelude_item_map = db.item_map(prelude.krate);\n-                    prelude_item_map[prelude.module_id].entries().for_each(|(name, res)| {\n+                if let Some(prelude) = m.crate_def_map.prelude() {\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n                         f(name.clone(), res.def.map(Resolution::Def));\n                     });\n                 }"}]}