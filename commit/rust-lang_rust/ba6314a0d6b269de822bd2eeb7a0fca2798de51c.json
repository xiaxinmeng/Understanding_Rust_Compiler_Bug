{"sha": "ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNjMxNGEwZDZiMjY5ZGU4MjJiZDJlZWI3YTBmY2EyNzk4ZGU1MWM=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-24T19:18:16Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-12-27T18:21:16Z"}, "message": "Integrate chalk engine", "tree": {"sha": "7349fdfb5a7a1b3b68782e0fbe21b432d960c8a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7349fdfb5a7a1b3b68782e0fbe21b432d960c8a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "html_url": "https://github.com/rust-lang/rust/commit/ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea4187a84254c2b27a68699659b3683464b4c1e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea4187a84254c2b27a68699659b3683464b4c1e9", "html_url": "https://github.com/rust-lang/rust/commit/ea4187a84254c2b27a68699659b3683464b4c1e9"}], "stats": {"total": 487, "additions": 412, "deletions": 75}, "files": [{"sha": "e5fd0aa3c9cbd8d8af9d26d7a854d1504048c0d4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -648,6 +648,7 @@ define_dep_nodes!( <'tcx>\n     [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n+    [] EvaluateGoal(traits::ChalkCanonicalGoal<'tcx>),\n     [] TypeOpAscribeUserType(CanonicalTypeOpAscribeUserTypeGoal<'tcx>),\n     [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n     [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),"}, {"sha": "201831fb7b55e698f9eb43a68522e55810ffda22", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -1240,3 +1240,10 @@ impl_stable_hash_for!(\n         clauses,\n     }\n );\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, G> for struct traits::InEnvironment<'tcx, G> {\n+        environment,\n+        goal,\n+    }\n+);"}, {"sha": "408cba42ae04b3d7779311e1ae2375a7291458a2", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -330,9 +330,13 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::Infer(ty::TyVar(vid)) => {\n+                debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.unwrap().probe_ty_var(vid) {\n                     // `t` could be a float / int variable: canonicalize that instead\n-                    Ok(t) => self.fold_ty(t),\n+                    Ok(t) => {\n+                        debug!(\"(resolved to {:?})\", t);\n+                        self.fold_ty(t)\n+                    }\n \n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n                     // result\n@@ -448,7 +452,12 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n \n         // Fast path: nothing that needs to be canonicalized.\n         if !value.has_type_flags(needs_canonical_flags) {\n-            let out_value = gcx.lift(value).unwrap();\n+            let out_value = gcx.lift(value).unwrap_or_else(|| {\n+                bug!(\n+                    \"failed to lift `{:?}` (nothing to canonicalize)\",\n+                    value\n+                )\n+            });\n             let canon_value = Canonical {\n                 max_universe: ty::UniverseIndex::ROOT,\n                 variables: List::empty(),"}, {"sha": "eaf72f5a687106d4377eee0a51e39a7ae7c6790b", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -420,9 +420,33 @@ BraceStructLiftImpl! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n-    fn len(&self) -> usize {\n+    pub fn len(&self) -> usize {\n         self.var_values.len()\n     }\n+\n+    /// Make an identity substitution from this one: each bound var\n+    /// is matched to the same bound var, preserving the original kinds.\n+    /// For example, if we have:\n+    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n+    /// we'll return a substitution `subst` with:\n+    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n+    pub fn make_identity<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        use ty::subst::UnpackedKind;\n+\n+        CanonicalVarValues {\n+            var_values: self.var_values.iter()\n+                .zip(0..)\n+                .map(|(kind, i)| match kind.unpack() {\n+                    UnpackedKind::Type(..) => tcx.mk_ty(\n+                        ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())\n+                    ).into(),\n+                    UnpackedKind::Lifetime(..) => tcx.mk_region(\n+                        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n+                    ).into(),\n+                })\n+                .collect()\n+        }\n+    }\n }\n \n impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {"}, {"sha": "df4e08e0eb5f30f49e019d6f375910d07e33618e", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -0,0 +1,165 @@\n+use traits::{\n+    Environment,\n+    InEnvironment,\n+    TraitEngine,\n+    ObligationCause,\n+    PredicateObligation,\n+    FulfillmentError,\n+    FulfillmentErrorCode,\n+    SelectionError,\n+};\n+use traits::query::NoSolution;\n+use infer::InferCtxt;\n+use infer::canonical::{Canonical, OriginalQueryValues};\n+use ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub type CanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;\n+\n+pub struct FulfillmentContext<'tcx> {\n+    obligations: FxHashSet<InEnvironment<'tcx, PredicateObligation<'tcx>>>,\n+}\n+\n+impl FulfillmentContext<'tcx> {\n+    crate fn new() -> Self {\n+        FulfillmentContext {\n+            obligations: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+fn in_environment(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    obligation: PredicateObligation<'tcx>\n+) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n+    assert!(!infcx.is_in_snapshot());\n+    let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+\n+    let environment = match obligation.param_env.def_id {\n+        Some(def_id) => infcx.tcx.environment(def_id),\n+        None if obligation.param_env.caller_bounds.is_empty() => Environment {\n+            clauses: ty::List::empty(),\n+        },\n+        _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n+    };\n+\n+    InEnvironment {\n+        environment,\n+        goal: obligation,\n+    }\n+}\n+\n+impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        _param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        _cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx> {\n+        infcx.tcx.mk_ty(ty::Projection(projection_ty))\n+    }\n+\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        self.obligations.insert(in_environment(infcx, obligation));\n+    }\n+\n+    fn select_all_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_where_possible(infcx)?;\n+\n+        if self.obligations.is_empty() {\n+            Ok(())\n+        } else {\n+            let errors = self.obligations.iter()\n+                .map(|obligation| FulfillmentError {\n+                    obligation: obligation.goal.clone(),\n+                    code: FulfillmentErrorCode::CodeAmbiguity,\n+                })\n+                .collect();\n+            Err(errors)\n+        }\n+    }\n+\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        let mut errors = Vec::new();\n+        let mut next_round = FxHashSet::default();\n+        let mut making_progress;\n+\n+        loop {\n+            making_progress = false;\n+\n+            // We iterate over all obligations, and record if we are able\n+            // to unambiguously prove at least one obligation.\n+            for obligation in self.obligations.drain() {\n+                let mut orig_values = OriginalQueryValues::default();\n+                let canonical_goal = infcx.canonicalize_query(&InEnvironment {\n+                    environment: obligation.environment,\n+                    goal: obligation.goal.predicate,\n+                }, &mut orig_values);\n+\n+                match infcx.tcx.global_tcx().evaluate_goal(canonical_goal) {\n+                    Ok(response) => {\n+                        if response.is_proven() {\n+                            making_progress = true;\n+\n+                            match infcx.instantiate_query_response_and_region_obligations(\n+                                &obligation.goal.cause,\n+                                obligation.goal.param_env,\n+                                &orig_values,\n+                                &response\n+                            ) {\n+                                Ok(infer_ok) => next_round.extend(\n+                                    infer_ok.obligations\n+                                        .into_iter()\n+                                        .map(|obligation| in_environment(infcx, obligation))\n+                                ),\n+\n+                                Err(_err) => errors.push(FulfillmentError {\n+                                    obligation: obligation.goal,\n+                                    code: FulfillmentErrorCode::CodeSelectionError(\n+                                        SelectionError::Unimplemented\n+                                    ),\n+                                }),\n+                            }\n+                        } else {\n+                            // Ambiguous: retry at next round.\n+                            next_round.insert(obligation);\n+                        }\n+                    }\n+\n+                    Err(NoSolution) => errors.push(FulfillmentError {\n+                        obligation: obligation.goal,\n+                        code: FulfillmentErrorCode::CodeSelectionError(\n+                            SelectionError::Unimplemented\n+                        ),\n+                    })\n+                }\n+            }\n+            next_round = std::mem::replace(&mut self.obligations, next_round);\n+\n+            if !making_progress {\n+                break;\n+            }\n+        }\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.iter().map(|obligation| obligation.goal.clone()).collect()\n+    }\n+}"}, {"sha": "c759a9ddf2ce6427469116a67e1d5916ec316187", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -1,8 +1,9 @@\n use infer::InferCtxt;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt, ToPredicate};\n+use traits::Obligation;\n use hir::def_id::DefId;\n \n-use super::{FulfillmentContext, FulfillmentError};\n+use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};\n use super::{ObligationCause, PredicateObligation};\n \n pub trait TraitEngine<'tcx>: 'tcx {\n@@ -14,14 +15,28 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         cause: ObligationCause<'tcx>,\n     ) -> Ty<'tcx>;\n \n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n     fn register_bound(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n         cause: ObligationCause<'tcx>,\n-    );\n+    ) {\n+        let trait_ref = ty::TraitRef {\n+            def_id,\n+            substs: infcx.tcx.mk_substs_trait(ty, &[]),\n+        };\n+        self.register_predicate_obligation(infcx, Obligation {\n+            cause,\n+            recursion_depth: 0,\n+            param_env,\n+            predicate: trait_ref.to_predicate()\n+        });\n+    }\n \n     fn register_predicate_obligation(\n         &mut self,\n@@ -63,7 +78,11 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n }\n \n impl dyn TraitEngine<'tcx> {\n-    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n-        Box::new(FulfillmentContext::new())\n+    pub fn new(tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        if tcx.sess.opts.debugging_opts.chalk {\n+            Box::new(ChalkFulfillmentContext::new())\n+        } else {\n+            Box::new(FulfillmentContext::new())\n+        }\n     }\n }"}, {"sha": "0e63ef666c75a02b2a9449a259982eaa8cba2ae9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -796,12 +796,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty)\n+                            )\n+                        }\n                     }\n \n                     ty::Predicate::ConstEvaluatable(..) => {"}, {"sha": "556b97dc9bcf1b4f4bae89d213f161c47643fd9f", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -1,19 +1,18 @@\n use infer::InferCtxt;\n use mir::interpret::{GlobalId, ErrorHandled};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_data_structures::obligation_forest::{ProcessResult};\n use std::marker::PhantomData;\n-use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::engine::{TraitEngine, TraitEngineExt};\n use super::{FulfillmentError, FulfillmentErrorCode};\n-use super::{ObligationCause, PredicateObligation, Obligation};\n+use super::{ObligationCause, PredicateObligation};\n use super::project;\n use super::select::SelectionContext;\n use super::{Unimplemented, ConstEvalFailure};\n@@ -173,28 +172,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         normalized_ty\n     }\n \n-    /// Requires that `ty` must implement the trait with `def_id` in\n-    /// the given environment. This trait must not have any type\n-    /// parameters (except for `Self`).\n-    fn register_bound<'a, 'gcx>(&mut self,\n-                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      ty: Ty<'tcx>,\n-                      def_id: DefId,\n-                      cause: ObligationCause<'tcx>)\n-    {\n-        let trait_ref = ty::TraitRef {\n-            def_id,\n-            substs: infcx.tcx.mk_substs_trait(ty, &[]),\n-        };\n-        self.register_predicate_obligation(infcx, Obligation {\n-            cause,\n-            recursion_depth: 0,\n-            param_env,\n-            predicate: trait_ref.to_predicate()\n-        });\n-    }\n-\n     fn register_predicate_obligation<'a, 'gcx>(&mut self,\n                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                      obligation: PredicateObligation<'tcx>)\n@@ -213,9 +190,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         });\n     }\n \n-    fn select_all_or_error<'a, 'gcx>(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_all_or_error<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>\n+    ) -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n "}, {"sha": "9d1b633238d2273275ff473ee539f56e2541be3a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -4,6 +4,7 @@\n \n #[allow(dead_code)]\n pub mod auto_trait;\n+mod chalk_fulfill;\n mod coherence;\n pub mod error_reporting;\n mod engine;\n@@ -61,6 +62,11 @@ pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_\n pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,\n                      Supertraits, SupertraitDefIds};\n \n+pub use self::chalk_fulfill::{\n+    CanonicalGoal as ChalkCanonicalGoal,\n+    FulfillmentContext as ChalkFulfillmentContext\n+};\n+\n pub use self::ObligationCauseCode::*;\n pub use self::FulfillmentErrorCode::*;\n pub use self::SelectionError::*;\n@@ -340,9 +346,9 @@ impl<'tcx> DomainGoal<'tcx> {\n }\n \n impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal<'a>(\n+    pub fn from_poly_domain_goal<'a, 'gcx>(\n         domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     ) -> GoalKind<'tcx> {\n         match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),"}, {"sha": "3464464aa229c9cc77dd5f0b47c26318dffd763b", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -106,6 +106,15 @@ impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::evaluate_goal<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt<'_, '_, '_>,\n+        goal: traits::ChalkCanonicalGoal<'tcx>\n+    ) -> Cow<'static, str> {\n+        format!(\"evaluating trait selection obligation `{}`\", goal.value.goal).into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,"}, {"sha": "cbdec2ef2ba81cf8e0be9cacc0ab3e24b331e4a3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -593,6 +593,13 @@ define_queries! { <'tcx>\n             CanonicalPredicateGoal<'tcx>\n         ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n \n+        [] fn evaluate_goal: EvaluateGoal(\n+            traits::ChalkCanonicalGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution\n+        >,\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         [] fn type_op_ascribe_user_type: TypeOpAscribeUserType(\n             CanonicalTypeOpAscribeUserTypeGoal<'tcx>"}, {"sha": "99da77491ca54866aa8c4f8875beb81fd72e5224", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -1103,6 +1103,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ImpliedOutlivesBounds |\n         DepKind::DropckOutlives |\n         DepKind::EvaluateObligation |\n+        DepKind::EvaluateGoal |\n         DepKind::TypeOpAscribeUserType |\n         DepKind::TypeOpEq |\n         DepKind::TypeOpSubtype |"}, {"sha": "28e7bc4c8da7771b329c79bcf03fdbc9a0ed1248", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 95, "deletions": 23, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -2,14 +2,15 @@ mod program_clauses;\n mod resolvent_ops;\n mod unify;\n \n-use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::fallible::Fallible;\n use chalk_engine::{\n     context,\n     hh::HhGoal,\n     DelayedLiteral,\n     Literal,\n-    ExClause\n+    ExClause,\n };\n+use chalk_engine::forest::Forest;\n use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::infer::canonical::{\n     Canonical,\n@@ -19,6 +20,7 @@ use rustc::infer::canonical::{\n     Certainty,\n };\n use rustc::traits::{\n+    self,\n     DomainGoal,\n     ExClauseFold,\n     ChalkContextLift,\n@@ -28,10 +30,13 @@ use rustc::traits::{\n     QuantifierKind,\n     Environment,\n     InEnvironment,\n+    ChalkCanonicalGoal,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n@@ -122,35 +127,50 @@ impl context::Context for ChalkArenas<'tcx> {\n impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     fn make_solution(\n         &self,\n-        _root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         mut simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n     ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n         use chalk_engine::SimplifiedAnswer;\n \n+        debug!(\"make_solution(root_goal = {:?})\", root_goal);\n+\n         if simplified_answers.peek_answer().is_none() {\n             return None;\n         }\n \n-        let SimplifiedAnswer { subst, ambiguous } = simplified_answers\n+        let SimplifiedAnswer { subst: constrained_subst, ambiguous } = simplified_answers\n             .next_answer()\n             .unwrap();\n \n+        debug!(\"make_solution: ambiguous flag = {}\", ambiguous);\n+\n         let ambiguous = simplified_answers.peek_answer().is_some() || ambiguous;\n \n-        Some(subst.unchecked_map(|subst| {\n-            QueryResponse {\n-                var_values: subst.subst,\n-                region_constraints: subst.constraints\n-                    .into_iter()\n-                    .map(|c| ty::Binder::bind(c))\n-                    .collect(),\n-                certainty: match ambiguous {\n-                    true => Certainty::Ambiguous,\n-                    false => Certainty::Proven,\n-                },\n+        let solution = constrained_subst.unchecked_map(|cs| match ambiguous {\n+            true => QueryResponse {\n+                var_values: cs.subst.make_identity(self.tcx),\n+                region_constraints: Vec::new(),\n+                certainty: Certainty::Ambiguous,\n                 value: (),\n-            }\n-        }))\n+            },\n+\n+            false => QueryResponse {\n+                var_values: cs.subst,\n+                region_constraints: Vec::new(),\n+\n+                // FIXME: restore this later once we get better at handling regions\n+                // region_constraints: cs.constraints\n+                //     .into_iter()\n+                //     .map(|c| ty::Binder::bind(c))\n+                //     .collect(),\n+                certainty: Certainty::Proven,\n+                value: (),\n+            },\n+        });\n+\n+        debug!(\"make_solution: solution = {:?}\", solution);\n+\n+        Some(solution)\n     }\n }\n \n@@ -334,16 +354,16 @@ impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn truncate_goal(\n         &mut self,\n-        subgoal: &InEnvironment<'tcx, Goal<'tcx>>,\n+        _subgoal: &InEnvironment<'tcx, Goal<'tcx>>,\n     ) -> Option<InEnvironment<'tcx, Goal<'tcx>>> {\n-        Some(*subgoal) // FIXME we should truncate at some point!\n+        None // FIXME we should truncate at some point!\n     }\n \n     fn truncate_answer(\n         &mut self,\n-        subst: &CanonicalVarValues<'tcx>,\n+        _subst: &CanonicalVarValues<'tcx>,\n     ) -> Option<CanonicalVarValues<'tcx>> {\n-        Some(subst.clone()) // FIXME we should truncate at some point!\n+        None // FIXME we should truncate at some point!\n     }\n }\n \n@@ -428,7 +448,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         b: &Kind<'tcx>,\n     ) -> Fallible<UnificationResult<'tcx>> {\n         self.infcx.commit_if_ok(|_| {\n-            unify(self.infcx, *environment, a, b).map_err(|_| NoSolution)\n+            unify(self.infcx, *environment, a, b).map_err(|_| chalk_engine::fallible::NoSolution)\n         })\n     }\n \n@@ -462,7 +482,10 @@ crate fn into_ex_clause(result: UnificationResult<'tcx>, ex_clause: &mut ChalkEx\n     ex_clause.subgoals.extend(\n         result.goals.into_iter().map(Literal::Positive)\n     );\n-    ex_clause.constraints.extend(result.constraints);\n+\n+    // FIXME: restore this later once we get better at handling regions\n+    let _ = result.constraints.len(); // trick `-D dead-code`\n+    // ex_clause.constraints.extend(result.constraints);\n }\n \n type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n@@ -625,3 +648,52 @@ impl<'tcx, 'gcx: 'tcx, T> Upcast<'tcx, 'gcx> for Canonical<'gcx, T>\n         }\n     }\n }\n+\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        evaluate_goal,\n+        ..*p\n+    };\n+}\n+\n+crate fn evaluate_goal<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    goal: ChalkCanonicalGoal<'tcx>\n+) -> Result<\n+    Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>,\n+    traits::query::NoSolution\n+> {\n+    use crate::lowering::Lower;\n+    use rustc::traits::WellFormed;\n+\n+    let goal = goal.unchecked_map(|goal| InEnvironment {\n+        environment: goal.environment,\n+        goal: match goal.goal {\n+            ty::Predicate::WellFormed(ty) => tcx.mk_goal(\n+                GoalKind::DomainGoal(DomainGoal::WellFormed(WellFormed::Ty(ty)))\n+            ),\n+\n+            other => tcx.mk_goal(\n+                GoalKind::from_poly_domain_goal(other.lower(), tcx)\n+            ),\n+        },\n+    });\n+\n+\n+    debug!(\"evaluate_goal(goal = {:?})\", goal);\n+\n+    let context = ChalkContext {\n+        _arenas: ChalkArenas {\n+            _phantom: PhantomData,\n+        },\n+        tcx,\n+    };\n+\n+    let mut forest = Forest::new(context);\n+    let solution = forest.solve(&goal);\n+\n+    debug!(\"evaluate_goal: solution = {:?}\", solution);\n+\n+    solution.map(|ok| Ok(Lrc::new(ok)))\n+        .unwrap_or(Err(traits::query::NoSolution))\n+}"}, {"sha": "4e7268cb2171c531ed1d70ac938d8e5899273eb7", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -350,6 +350,9 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<Clause<'tcx>> {\n         use rustc::traits::WhereClause::*;\n+        use rustc::infer::canonical::OriginalQueryValues;\n+\n+        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n \n         debug!(\"program_clauses(goal = {:?})\", goal);\n \n@@ -582,10 +585,12 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n         debug!(\"program_clauses: clauses = {:?}\", clauses);\n         debug!(\"program_clauses: adding clauses from environment = {:?}\", environment);\n \n-        let environment = self.infcx.tcx.lift_to_global(environment)\n-            .expect(\"environment is not global\");\n-\n-        let env_clauses = self.infcx.tcx.program_clauses_for_env(environment);\n+        let mut _orig_query_values = OriginalQueryValues::default();\n+        let canonical_environment = self.infcx.canonicalize_query(\n+            environment,\n+            &mut _orig_query_values\n+        ).value;\n+        let env_clauses = self.infcx.tcx.program_clauses_for_env(canonical_environment);\n \n         debug!(\"program_clauses: env_clauses = {:?}\", env_clauses);\n "}, {"sha": "e330bbcbbd4124c2b0dc31e95e10b939ad1b49f4", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -35,7 +35,9 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n         use chalk_engine::context::UnificationOps;\n \n-        self.infcx.probe(|_| {\n+        debug!(\"resolvent_clause(goal = {:?}, clause = {:?})\", goal, clause);\n+\n+        let result = self.infcx.probe(|_| {\n             let ProgramClause {\n                 goal: consequence,\n                 hypotheses,\n@@ -70,7 +72,10 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n             let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n             Ok(canonical_ex_clause)\n-        })\n+        });\n+\n+        debug!(\"resolvent_clause: result = {:?}\", result);\n+        result\n     }\n \n     fn apply_answer_subst(\n@@ -80,6 +85,12 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> Fallible<ChalkExClause<'tcx>> {\n+        debug!(\n+            \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n+            self.infcx.resolve_type_vars_if_possible(&ex_clause),\n+            self.infcx.resolve_type_vars_if_possible(selected_goal)\n+        );\n+\n         let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n             DUMMY_SP,\n             canonical_answer_subst\n@@ -96,8 +107,12 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         substitutor.relate(&answer_table_goal.value, &selected_goal)\n             .map_err(|_| NoSolution)?;\n \n-        let mut ex_clause = substitutor.ex_clause;\n-        ex_clause.constraints.extend(answer_subst.constraints);\n+        let ex_clause = substitutor.ex_clause;\n+\n+        // FIXME: restore this later once we get better at handling regions\n+        // ex_clause.constraints.extend(answer_subst.constraints);\n+\n+        debug!(\"apply_answer_subst: ex_clause = {:?}\", ex_clause);\n         Ok(ex_clause)\n     }\n }\n@@ -172,6 +187,7 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let b = self.infcx.shallow_resolve(b);\n+        debug!(\"AnswerSubstitutor::tys(a = {:?}, b = {:?})\", a, b);\n \n         if let &ty::Bound(debruijn, bound_ty) = &a.sty {\n             // Free bound var"}, {"sha": "865ccb1a31fa3f2d626c31c22120378a9ea02698", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -16,6 +16,12 @@ crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n     a: &T,\n     b: &T\n ) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n+    debug!(\"unify(\n+        a = {:?},\n+        b = {:?},\n+        environment = {:?},\n+    )\", a, b, environment);\n+\n     let mut delegate = ChalkTypeRelatingDelegate::new(\n         infcx,\n         environment\n@@ -27,6 +33,8 @@ crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n         ty::Variance::Invariant\n     ).relate(a, b)?;\n \n+    debug!(\"unify: goals = {:?}, constraints = {:?}\", delegate.goals, delegate.constraints);\n+\n     Ok(UnificationResult {\n         goals: delegate.goals,\n         constraints: delegate.constraints,"}, {"sha": "a220b9219136948785a9d98a88c270623c3ae678", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6314a0d6b269de822bd2eeb7a0fca2798de51c/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=ba6314a0d6b269de822bd2eeb7a0fca2798de51c", "patch": "@@ -35,6 +35,7 @@ pub fn provide(p: &mut Providers) {\n     evaluate_obligation::provide(p);\n     implied_outlives_bounds::provide(p);\n     lowering::provide(p);\n+    chalk_context::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);"}]}