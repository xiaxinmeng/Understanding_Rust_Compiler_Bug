{"sha": "4c16ff516d97bb4a69ad965b93e6db61343be381", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMTZmZjUxNmQ5N2JiNGE2OWFkOTY1YjkzZTZkYjYxMzQzYmUzODE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-14T23:45:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-14T23:45:51Z"}, "message": "Convert a couple hundred ~\"\"s to \"\"s, in trans functions.", "tree": {"sha": "fc10e77f1d688b9724ff48258b514bbd8d4a8093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc10e77f1d688b9724ff48258b514bbd8d4a8093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c16ff516d97bb4a69ad965b93e6db61343be381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c16ff516d97bb4a69ad965b93e6db61343be381", "html_url": "https://github.com/rust-lang/rust/commit/4c16ff516d97bb4a69ad965b93e6db61343be381", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c16ff516d97bb4a69ad965b93e6db61343be381/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1fad0775844a9413484fd2eaa10adcfdfbc2883", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1fad0775844a9413484fd2eaa10adcfdfbc2883", "html_url": "https://github.com/rust-lang/rust/commit/c1fad0775844a9413484fd2eaa10adcfdfbc2883"}], "stats": {"total": 560, "additions": 280, "deletions": 280}, "files": [{"sha": "eaf1011f181632b4717bf0506371d75e18e87298", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -41,7 +41,7 @@ enum opt_result {\n     range_result(result, result),\n }\n fn trans_opt(bcx: block, o: opt) -> opt_result {\n-    let _icx = bcx.insn_ctxt(~\"alt::trans_opt\");\n+    let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match o {\n@@ -303,7 +303,7 @@ fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n    {vals: ~[ValueRef], bcx: block} {\n-    let _icx = bcx.insn_ctxt(~\"alt::extract_variant_args\");\n+    let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match check ty::get(node_id_type(bcx, pat_id))\n         .struct {\n@@ -449,7 +449,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n       For an empty match, a fall-through case must exist\n      */\n     assert(m.len() > 0u || is_some(chk));\n-    let _icx = bcx.insn_ctxt(~\"alt::compile_submatch\");\n+    let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u { Br(bcx, option::get(chk)()); return; }\n@@ -735,7 +735,7 @@ fn make_phi_bindings(bcx: block,\n                      map: ~[exit_node],\n                      ids: pat_util::pat_id_map)\n     -> option<phi_bindings_list> {\n-    let _icx = bcx.insn_ctxt(~\"alt::make_phi_bindings\");\n+    let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n     let mut phi_bindings = ~[];\n     for ids.each |name, node_id| {\n@@ -815,15 +815,15 @@ fn trans_alt(bcx: block,\n              arms: ~[ast::arm],\n              mode: ast::alt_mode,\n              dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"alt::trans_alt\");\n+    let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n     do with_scope(bcx, alt_expr.info(), ~\"alt\") |bcx| {\n         trans_alt_inner(bcx, expr, arms, mode, dest)\n     }\n }\n \n fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n                    mode: ast::alt_mode, dest: dest) -> block {\n-    let _icx = scope_cx.insn_ctxt(~\"alt::trans_alt_inner\");\n+    let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n     let bcx = scope_cx, tcx = bcx.tcx();\n     let mut bodies = ~[], matches = ~[];\n \n@@ -897,7 +897,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> block {\n-    let _icx = bcx.insn_ctxt(~\"alt::bind_irrefutable_pat\");\n+    let _icx = bcx.insn_ctxt(\"alt::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n "}, {"sha": "7b901ae973952760222f25b56f51bdf7a20b99f2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 128, "deletions": 128, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -94,27 +94,27 @@ class icx_popper {\n }\n \n trait get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper;\n+    fn insn_ctxt(s: &str) -> icx_popper;\n }\n \n impl @crate_ctxt: get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper {\n+    fn insn_ctxt(s: &str) -> icx_popper {\n         debug!{\"new insn_ctxt: %s\", s};\n         if self.sess.count_llvm_insns() {\n-            vec::push(*self.stats.llvm_insn_ctxt, s);\n+            vec::push(*self.stats.llvm_insn_ctxt, str::from_slice(s));\n         }\n         icx_popper(self)\n     }\n }\n \n impl block: get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper {\n+    fn insn_ctxt(s: &str) -> icx_popper {\n         self.ccx().insn_ctxt(s)\n     }\n }\n \n impl fn_ctxt: get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper {\n+    fn insn_ctxt(s: &str) -> icx_popper {\n         self.ccx.insn_ctxt(s)\n     }\n }\n@@ -219,7 +219,7 @@ fn get_simple_extern_fn(cx: block,\n                         externs: hashmap<~str, ValueRef>,\n                         llmod: ModuleRef,\n                         name: ~str, n_args: int) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"get_simple_extern_fn\");\n+    let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n     let output = ccx.int_type;\n@@ -230,7 +230,7 @@ fn get_simple_extern_fn(cx: block,\n fn trans_foreign_call(cx: block, externs: hashmap<~str, ValueRef>,\n                       llmod: ModuleRef, name: ~str, args: ~[ValueRef]) ->\n    ValueRef {\n-    let _icx = cx.insn_ctxt(~\"trans_foreign_call\");\n+    let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n     let llforeign: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n@@ -242,24 +242,24 @@ fn trans_foreign_call(cx: block, externs: hashmap<~str, ValueRef>,\n }\n \n fn trans_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_free\");\n+    let _icx = cx.insn_ctxt(\"trans_free\");\n     trans_rtcall(cx, ~\"free\", ~[PointerCast(cx, v, T_ptr(T_i8()))], ignore)\n }\n \n fn trans_unique_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_unique_free\");\n+    let _icx = cx.insn_ctxt(\"trans_unique_free\");\n     trans_rtcall(cx, ~\"exchange_free\", ~[PointerCast(cx, v, T_ptr(T_i8()))],\n                  ignore)\n }\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"umax\");\n+    let _icx = cx.insn_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, b, a);\n }\n \n fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"umin\");\n+    let _icx = cx.insn_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, a, b);\n }\n@@ -273,7 +273,7 @@ fn alloca_zeroed(cx: block, t: TypeRef) -> ValueRef {\n }\n \n fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"alloca\");\n+    let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable { return llvm::LLVMGetUndef(t); }\n     let initcx = raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n     let p = Alloca(initcx, t);\n@@ -282,7 +282,7 @@ fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n }\n \n fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n-    let _icx = cx.insn_ctxt(~\"zero_mem\");\n+    let _icx = cx.insn_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n@@ -291,7 +291,7 @@ fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n }\n \n fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"arrayalloca\");\n+    let _icx = cx.insn_ctxt(\"arrayalloca\");\n     if cx.unreachable { return llvm::LLVMGetUndef(t); }\n     return ArrayAlloca(\n         raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n@@ -301,7 +301,7 @@ fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"ptr_offs\");\n+    let _icx = bcx.insn_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n     InBoundsGEP(bcx, raw, ~[sz])\n }\n@@ -310,7 +310,7 @@ fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n // to a given type.\n fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"bump_ptr\");\n+    let _icx = bcx.insn_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n     let typ = T_ptr(type_of(ccx, t));\n@@ -323,7 +323,7 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n             variant_id: ast::def_id, ty_substs: ~[ty::t],\n             ix: uint) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"GEP_enum\");\n+    let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n     let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n     assert ix < variant.args.len();\n@@ -344,7 +344,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n fn opaque_box_body(bcx: block,\n                    body_t: ty::t,\n                    boxptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"opaque_box_body\");\n+    let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n     let bodyptr = GEPi(bcx, boxptr, ~[1u]);\n@@ -355,7 +355,7 @@ fn opaque_box_body(bcx: block,\n // potentially dynamic size.\n fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n                   size: ValueRef) -> result {\n-    let _icx = bcx.insn_ctxt(~\"malloc_raw\");\n+    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n     let (mk_fn, rtcall) = match heap {\n@@ -390,7 +390,7 @@ fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> result {\n // and pulls out the body\n fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> {bcx: block, box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(~\"malloc_general\");\n+    let _icx = bcx.insn_ctxt(\"malloc_general\");\n     let {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, llbox);\n     let body = GEPi(bcx, non_gc_box, ~[0u, abi::box_field_body]);\n@@ -487,7 +487,7 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: ~str) {\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n-    let _icx = ccx.insn_ctxt(~\"declare_tydesc\");\n+    let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     let llty = type_of(ccx, t);\n \n     if ccx.sess.count_type_sizes() {\n@@ -524,7 +524,7 @@ type glue_helper = fn@(block, ValueRef, ty::t);\n \n fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: ~str) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"declare_generic_glue\");\n+    let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let mut fn_nm;\n     //XXX this triggers duplicate LLVM symbols\n@@ -541,7 +541,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n \n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"make_generic_glue_inner\");\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, none);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n@@ -564,7 +564,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, name: ~str)\n     -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"make_generic_glue\");\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n         return make_generic_glue_inner(ccx, t, llfn, helper);\n     }\n@@ -578,7 +578,7 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n }\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n-    let _icx = ccx.insn_ctxt(~\"emit_tydescs\");\n+    let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     for ccx.tydescs.each |key, val| {\n         let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n         let ti = val;\n@@ -644,7 +644,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n }\n \n fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(~\"make_take_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -686,7 +686,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n }\n \n fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n-    let _icx = cx.insn_ctxt(~\"incr_refcnt_of_boxed\");\n+    let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, ~[0u, abi::box_field_refcnt]);\n@@ -696,7 +696,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n }\n \n fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(~\"make_visit_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key(@~\"ty_visitor\");\n     let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(@~\"ty_visitor\");\n@@ -708,7 +708,7 @@ fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(~\"make_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_free_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(body_mt) => {\n@@ -790,7 +790,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n \n fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(~\"make_drop_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -839,7 +839,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n                 parent_id: ast::def_id, substs: ~[ty::t])\n    -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"trans_res_dtor\");\n+    let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if (substs.len() > 0u) {\n         let did = if did.crate != ast::local_crate {\n             maybe_instantiate_inline(ccx, did)\n@@ -871,7 +871,7 @@ fn maybe_validate_box(_cx: block, _box_ptr: ValueRef) {\n }\n \n fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"decr_refcnt_maybe_free\");\n+    let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n     maybe_validate_box(bcx, box_ptr);\n \n@@ -923,7 +923,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n // A helper function to do the actual comparison of scalar values.\n fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"compare_scalar_values\");\n+    let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die_(cx: block) -> ! {\n         cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n           comparison operator\");\n@@ -994,13 +994,13 @@ fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n // Iterates through the elements of a structural type.\n fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                       f: val_and_ty_fn) -> block {\n-    let _icx = cx.insn_ctxt(~\"iter_structural_ty\");\n+    let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, a_tup: ValueRef,\n                     variant: ty::variant_info,\n                     tps: ~[ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> block {\n-        let _icx = cx.insn_ctxt(~\"iter_variant\");\n+        let _icx = cx.insn_ctxt(\"iter_variant\");\n         if variant.args.len() == 0u { return cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n@@ -1108,7 +1108,7 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n \n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n                            ti: @tydesc_info) {\n-    let _icx = ccx.insn_ctxt(~\"lazily_emit_tydesc_glue\");\n+    let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx, ti.ty);\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue {\n@@ -1168,7 +1168,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n // See [Note-arg-mode]\n fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n-    let _icx = bcx.insn_ctxt(~\"call_tydesc_glue_full\");\n+    let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n         if bcx.unreachable { return; }\n     let ccx = bcx.ccx();\n \n@@ -1228,7 +1228,7 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n // See [Note-arg-mode]\n fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"call_tydesc_glue\");\n+    let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, some(ti));\n     return cx;\n@@ -1238,7 +1238,7 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n                  llop: ValueRef) -> ValueRef {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n-    let _icx = bcx.insn_ctxt(~\"call_cmp_glue\");\n+    let _icx = bcx.insn_ctxt(\"call_cmp_glue\");\n \n     let lllhs = spill_if_immediate(bcx, lhs, t);\n     let llrhs = spill_if_immediate(bcx, rhs, t);\n@@ -1257,7 +1257,7 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(~\"take_ty\");\n+    let _icx = cx.insn_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n@@ -1266,15 +1266,15 @@ fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(~\"drop_ty\");\n+    let _icx = cx.insn_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     return cx;\n }\n \n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"drop_ty_immediate\");\n+    let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).struct {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -1291,7 +1291,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(~\"take_ty_immediate\");\n+    let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n     match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n@@ -1312,15 +1312,15 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n \n fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(~\"free_ty\");\n+    let _icx = cx.insn_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     return cx;\n }\n \n fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"free_ty_immediate\");\n+    let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n     match ty::get(t).struct {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -1343,7 +1343,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     // alignment information when the alignment is statically known (it must\n     // be nothing more than a constant int, or LLVM complains -- not even a\n     // constant element of a tydesc works).\n-    let _icx = cx.insn_ctxt(~\"call_memmove\");\n+    let _icx = cx.insn_ctxt(\"call_memmove\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n       session::arch_x86 | session::arch_arm => ~\"llvm.memmove.p0i8.p0i8.i32\",\n@@ -1359,7 +1359,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n }\n \n fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(~\"memmove_ty\");\n+    let _icx = bcx.insn_ctxt(\"memmove_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n         let llsz = llsize_of(ccx, type_of(ccx, t));\n@@ -1382,7 +1382,7 @@ fn type_is_structural_or_param(t: ty::t) -> bool {\n \n fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n             src: ValueRef, t: ty::t) -> block {\n-    let _icx = cx.insn_ctxt(~\"copy_val\");\n+    let _icx = cx.insn_ctxt(\"copy_val\");\n     if action == DROP_EXISTING &&\n         (type_is_structural_or_param(t) ||\n          ty::type_is_unique(t)) {\n@@ -1399,7 +1399,7 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n \n fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"copy_val_no_check\");\n+    let _icx = bcx.insn_ctxt(\"copy_val_no_check\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if ty::type_is_scalar(t) || ty::type_is_region_ptr(t) {\n@@ -1430,7 +1430,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n \n-    let _icx = cx.insn_ctxt(~\"move_val\");\n+    let _icx = cx.insn_ctxt(\"move_val\");\n     let mut src_val = src.val;\n     let tcx = cx.tcx();\n     let mut cx = cx;\n@@ -1463,7 +1463,7 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n                    src: lval_result, t: ty::t, last_use: bool)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_temp_expr\");\n+    let _icx = cx.insn_ctxt(\"trans_temp_expr\");\n     // Lvals in memory are not temporaries. Copy them.\n     if src.kind != lv_temporary && !last_use {\n         let v = if src.kind == lv_owned {\n@@ -1477,7 +1477,7 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n }\n \n fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_lit\");\n+    let _icx = cx.insn_ctxt(\"trans_lit\");\n     if dest == ignore { return cx; }\n     match lit.node {\n         ast::lit_str(s) => tvec::trans_estr(cx, s, none, dest),\n@@ -1488,7 +1488,7 @@ fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n                     t: ty::t, heap: heap,\n                     dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_boxed_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n     let {bcx, box, body} = malloc_general(bcx, t, heap);\n     add_clean_free(bcx, box, heap);\n     let bcx = trans_expr_save_in(bcx, contents, body);\n@@ -1498,7 +1498,7 @@ fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n \n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_unary\");\n+    let _icx = bcx.insn_ctxt(\"trans_unary\");\n     // Check for user-defined method call\n     match bcx.ccx().maps.method_map.find(un_expr.id) {\n       some(mentry) => {\n@@ -1542,7 +1542,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n }\n \n fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_addr_of\");\n+    let _icx = cx.insn_ctxt(\"trans_addr_of\");\n     let mut {bcx, val, kind} = trans_temp_lval(cx, e);\n     let ety = expr_ty(cx, e);\n     let is_immediate = ty::type_is_immediate(ety);\n@@ -1554,7 +1554,7 @@ fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n \n fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n-    let _icx = cx.insn_ctxt(~\"trans_compare\");\n+    let _icx = cx.insn_ctxt(\"trans_compare\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n       return rslt(rs.bcx, rs.val);\n@@ -1650,7 +1650,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n     -> block {\n     let mut cx = cx;\n-    let _icx = cx.insn_ctxt(~\"trans_eager_binop\");\n+    let _icx = cx.insn_ctxt(\"trans_eager_binop\");\n     if dest == ignore { return cx; }\n     let intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n@@ -1721,7 +1721,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n     debug!{\"%s\", expr_to_str(ex)};\n-    let _icx = bcx.insn_ctxt(~\"trans_assign_op\");\n+    let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == lv_owned);\n@@ -1762,7 +1762,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n \n fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n               scope_id: ast::node_id) {\n-    let _icx = bcx.insn_ctxt(~\"root_value\");\n+    let _icx = bcx.insn_ctxt(\"root_value\");\n \n     if bcx.sess().trace() {\n         trans_trace(\n@@ -1780,7 +1780,7 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n fn autoderef(cx: block, e_id: ast::node_id,\n              v: ValueRef, t: ty::t,\n              max: uint) -> result_t {\n-    let _icx = cx.insn_ctxt(~\"autoderef\");\n+    let _icx = cx.insn_ctxt(\"autoderef\");\n     let mut v1: ValueRef = v;\n     let mut t1: ty::t = t;\n     let ccx = cx.ccx();\n@@ -1845,7 +1845,7 @@ enum lazy_binop_ty { lazy_and, lazy_or }\n \n fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_lazy_binop\");\n+    let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let {bcx: past_lhs, val: lhs} = {\n         do with_scope_result(bcx, a.info(), ~\"lhs\") |bcx| {\n             trans_temp_expr(bcx, a)\n@@ -1873,7 +1873,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n \n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_binary\");\n+    let _icx = bcx.insn_ctxt(\"trans_binary\");\n     // User-defined operators\n     match bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) => {\n@@ -1912,7 +1912,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n             els: option<@ast::expr>, dest: dest)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_if\");\n+    let _icx = cx.insn_ctxt(\"trans_if\");\n     let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n \n     let then_dest = dup_for_join(dest);\n@@ -1949,7 +1949,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n \n fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_while\");\n+    let _icx = cx.insn_ctxt(\"trans_while\");\n     let next_cx = sub_block(cx, ~\"while next\");\n     let loop_cx = loop_scope_block(cx, next_cx, ~\"`while`\", body.info());\n     let cond_cx = scope_block(loop_cx, cond.info(), ~\"while loop cond\");\n@@ -1965,7 +1965,7 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n }\n \n fn trans_loop(cx:block, body: ast::blk) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_loop\");\n+    let _icx = cx.insn_ctxt(\"trans_loop\");\n     let next_cx = sub_block(cx, ~\"next\");\n     let body_cx = loop_scope_block(cx, next_cx, ~\"`loop`\", body.info());\n     let body_end = trans_block(body_cx, body, ignore);\n@@ -2111,7 +2111,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n                   vtables: option<typeck::vtable_res>,\n                   ref_id: option<ast::node_id>)\n     -> {val: ValueRef, must_cast: bool} {\n-    let _icx = ccx.insn_ctxt(~\"monomorphic_fn\");\n+    let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n         match normalize_for_monomorphization(ccx.tcx, t) {\n@@ -2295,7 +2295,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n-    let _icx = ccx.insn_ctxt(~\"maybe_instantiate_inline\");\n+    let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(fn_id) {\n       some(some(node_id)) => {\n         // Already inline\n@@ -2373,7 +2373,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n \n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"lval_static_fn\");\n+    let _icx = bcx.insn_ctxt(\"lval_static_fn\");\n     let vts = option::map(bcx.ccx().maps.vtable_map.find(id), |vts| {\n         impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n     });\n@@ -2383,7 +2383,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                         tys: ~[ty::t], vtables: option<typeck::vtable_res>)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"lval_static_fn_inner\");\n+    let _icx = bcx.insn_ctxt(\"lval_static_fn_inner\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let tpt = ty::lookup_item_type(tcx, fn_id);\n \n@@ -2433,7 +2433,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"lookup_discriminant\");\n+    let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n     match ccx.discrims.find(vid) {\n       none => {\n         // It's an external discriminant that we haven't seen yet.\n@@ -2456,7 +2456,7 @@ fn cast_self(cx: block, slf: val_self_pair) -> ValueRef {\n }\n \n fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n-    let _icx = cx.insn_ctxt(~\"trans_local_var\");\n+    let _icx = cx.insn_ctxt(\"trans_local_var\");\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n         match table.find(id) {\n@@ -2495,7 +2495,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n \n fn trans_path(cx: block, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let _icx = cx.insn_ctxt(~\"trans_path\");\n+    let _icx = cx.insn_ctxt(\"trans_path\");\n     match cx.tcx().def_map.find(id) {\n       none => cx.sess().bug(~\"trans_path: unbound node ID\"),\n       some(df) => {\n@@ -2505,7 +2505,7 @@ fn trans_path(cx: block, id: ast::node_id)\n }\n \n fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n-    let _icx = cx.insn_ctxt(~\"trans_var\");\n+    let _icx = cx.insn_ctxt(\"trans_var\");\n     let ccx = cx.ccx();\n     match def {\n       ast::def_fn(did, _) => {\n@@ -2548,7 +2548,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n \n fn trans_rec_field(bcx: block, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n-    let _icx = bcx.insn_ctxt(~\"trans_rec_field\");\n+    let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} =\n         autoderef(bcx, base.id, val, expr_ty(bcx, base),\n@@ -2593,7 +2593,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n \n fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n                idx: @ast::expr) -> lval_result {\n-    let _icx = cx.insn_ctxt(~\"trans_index\");\n+    let _icx = cx.insn_ctxt(\"trans_index\");\n     let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, base.id, exp.val, base_ty, uint::max_value);\n@@ -2650,7 +2650,7 @@ fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n }\n \n fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"trans_callee\");\n+    let _icx = bcx.insn_ctxt(\"trans_callee\");\n     match e.node {\n       ast::expr_path(path) => return trans_path(bcx, e.id),\n       ast::expr_field(base, _, _) => {\n@@ -2691,7 +2691,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n                                  scope_id});\n         }\n \n-        let _icx = lv.bcx.insn_ctxt(~\"root_value_lval\");\n+        let _icx = lv.bcx.insn_ctxt(\"root_value_lval\");\n         let ty = expr_ty(lv.bcx, e);\n         let root_loc = alloca_zeroed(lv.bcx, type_of(cx.ccx(), ty));\n         let bcx = store_temp_expr(lv.bcx, INIT, root_loc, lv, ty, false);\n@@ -2701,7 +2701,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n     };\n \n     fn unrooted(cx: block, e: @ast::expr) -> lval_result {\n-        let _icx = cx.insn_ctxt(~\"trans_lval\");\n+        let _icx = cx.insn_ctxt(\"trans_lval\");\n         match e.node {\n           ast::expr_path(_) => {\n             let v = trans_path(cx, e.id);\n@@ -2773,7 +2773,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, sp: span) -> lval_result {\n \n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"int_cast\");\n+    let _icx = bcx.insn_ctxt(\"int_cast\");\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n     return if dstsz == srcsz {\n@@ -2787,7 +2787,7 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n \n fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n               llsrc: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"float_cast\");\n+    let _icx = bcx.insn_ctxt(\"float_cast\");\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n     return if dstsz > srcsz {\n@@ -2815,7 +2815,7 @@ fn cast_type_kind(t: ty::t) -> cast_kind {\n \n fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_cast\");\n+    let _icx = cx.insn_ctxt(\"trans_cast\");\n     let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n     match ty::get(t_out).struct {\n@@ -2903,7 +2903,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n                   derefs: uint)\n     -> result {\n     debug!{\"+++ trans_arg_expr on %s\", expr_to_str(e)};\n-    let _icx = cx.insn_ctxt(~\"trans_arg_expr\");\n+    let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n@@ -3077,7 +3077,7 @@ enum call_args {\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n               dest: dest, ret_flag: option<ValueRef>)\n     -> {bcx: block, args: ~[ValueRef], retslot: ValueRef} {\n-    let _icx = cx.insn_ctxt(~\"trans_args\");\n+    let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     let mut llargs: ~[ValueRef] = ~[];\n@@ -3139,7 +3139,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n fn trans_call(in_cx: block, call_ex: @ast::expr, f: @ast::expr,\n               args: call_args, id: ast::node_id, dest: dest)\n     -> block {\n-    let _icx = in_cx.insn_ctxt(~\"trans_call\");\n+    let _icx = in_cx.insn_ctxt(\"trans_call\");\n     trans_call_inner(\n         in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n         |cx| trans_callee(cx, f), args, dest)\n@@ -3257,7 +3257,7 @@ fn trans_call_inner(\n }\n \n fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef]) -> block {\n-    let _icx = bcx.insn_ctxt(~\"invoke_\");\n+    let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }\n     if need_invoke(bcx) {\n         log(debug, ~\"invoking\");\n@@ -3336,7 +3336,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n }\n \n fn get_landing_pad(bcx: block) -> BasicBlockRef {\n-    let _icx = bcx.insn_ctxt(~\"get_landing_pad\");\n+    let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n     let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n     do in_lpad_scope_cx(bcx) |inf| {\n@@ -3386,7 +3386,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n }\n \n fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_tup\");\n+    let _icx = bcx.insn_ctxt(\"trans_tup\");\n     let mut bcx = bcx;\n     let addr = match dest {\n       ignore => {\n@@ -3411,7 +3411,7 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n fn trans_rec(bcx: block, fields: ~[ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_rec\");\n+    let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n     let addr = match check dest {\n@@ -3475,7 +3475,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                 base: option<@ast::expr>, id: ast::node_id, dest: dest)\n              -> block {\n \n-    let _instruction_context = block_context.insn_ctxt(~\"trans_struct\");\n+    let _instruction_context = block_context.insn_ctxt(\"trans_struct\");\n     let mut block_context = block_context;\n     let type_context = block_context.ccx().tcx;\n \n@@ -3615,7 +3615,7 @@ fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n-    let _icx = bcx.insn_ctxt(~\"trans_temp_lval\");\n+    let _icx = bcx.insn_ctxt(\"trans_temp_lval\");\n     let mut bcx = bcx;\n     if expr_is_lval(bcx, e) {\n         return trans_lval(bcx, e);\n@@ -3641,7 +3641,7 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n // Use only for intermediate values. See trans_expr and trans_expr_save_in for\n // expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n-    let _icx = bcx.insn_ctxt(~\"trans_temp_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_temp_expr\");\n     lval_result_to_result(trans_temp_lval(bcx, e), expr_ty(bcx, e))\n }\n \n@@ -3702,7 +3702,7 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n // - exprs returning nil or bot always get dest=ignore\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_expr\");\n     debuginfo::update_source_pos(bcx, e.span);\n \n     if expr_is_lval(bcx, e) {\n@@ -3724,7 +3724,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                                   scope_id});\n         }\n \n-        let _icx = bcx.insn_ctxt(~\"root_value_expr\");\n+        let _icx = bcx.insn_ctxt(\"root_value_expr\");\n         add_root_cleanup(bcx, scope_id, root_loc, ty);\n         let lv = {bcx: bcx, val: root_loc, kind: lv_owned};\n         lval_result_to_dps(lv, ty, false, dest)\n@@ -3982,20 +3982,20 @@ fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n }\n \n fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"spill_if_immediate\");\n+    let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"load_if_immediate\");\n+    let _icx = cx.insn_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(t) { return Load(cx, v); }\n     return v;\n }\n \n fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n              bcx: block, e: @ast::expr) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_log\");\n+    let _icx = bcx.insn_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n        return trans_expr(bcx, lvl, ignore);\n@@ -4046,7 +4046,7 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n \n fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n                     pred_expr: @ast::expr, s: ~str) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_check_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n     let expr_str = s + ~\" \" + expr_to_str(pred_expr) + ~\" failed\";\n     let {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n@@ -4060,7 +4060,7 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n \n fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n                    fail_expr: option<@ast::expr>) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_fail_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n       some(expr) => {\n@@ -4087,7 +4087,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n \n fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n-    let _icx = bcx.insn_ctxt(~\"trans_trace\");\n+    let _icx = bcx.insn_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let {V_filename, V_line} = match sp_opt {\n@@ -4111,14 +4111,14 @@ fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n \n fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: ~str) ->\n     block {\n-    let _icx = bcx.insn_ctxt(~\"trans_fail\");\n+    let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n fn trans_fail_value(bcx: block, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_fail_value\");\n+    let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let {V_filename, V_line} = match sp_opt {\n       some(sp) => {\n@@ -4157,7 +4157,7 @@ fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: dest)\n \n fn trans_break_cont(bcx: block, to_end: bool)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_break_cont\");\n+    let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut target;\n@@ -4198,7 +4198,7 @@ fn trans_cont(cx: block) -> block {\n }\n \n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_ret\");\n+    let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let retptr = match copy bcx.fcx.loop_ret {\n       some({flagptr, retptr}) => {\n@@ -4227,7 +4227,7 @@ fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n }\n \n fn build_return(bcx: block) {\n-    let _icx = bcx.insn_ctxt(~\"build_return\");\n+    let _icx = bcx.insn_ctxt(\"build_return\");\n     Br(bcx, bcx.fcx.llreturn);\n }\n \n@@ -4238,7 +4238,7 @@ fn ignore_lhs(_bcx: block, local: @ast::local) -> bool {\n }\n \n fn init_local(bcx: block, local: @ast::local) -> block {\n-    let _icx = bcx.insn_ctxt(~\"init_local\");\n+    let _icx = bcx.insn_ctxt(\"init_local\");\n     let ty = node_id_type(bcx, local.node.id);\n \n     if ignore_lhs(bcx, local) {\n@@ -4277,7 +4277,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_stmt\");\n+    let _icx = cx.insn_ctxt(\"trans_stmt\");\n     debug!{\"trans_stmt(%s)\", stmt_to_str(s)};\n \n     if !cx.sess().no_asm_comments() {\n@@ -4384,7 +4384,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) -> block {\n \n fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n    block {\n-    let _icx = bcx.insn_ctxt(~\"trans_block_cleanups\");\n+    let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n     if bcx.unreachable { return bcx; }\n     let mut bcx = bcx;\n     match check cleanup_cx.kind {\n@@ -4411,7 +4411,7 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n // instruction.\n fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n-    let _icx = bcx.insn_ctxt(~\"cleanup_and_leave\");\n+    let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == none;\n     loop {\n@@ -4454,12 +4454,12 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n \n fn cleanup_and_Br(bcx: block, upto: block,\n                   target: BasicBlockRef) {\n-    let _icx = bcx.insn_ctxt(~\"cleanup_and_Br\");\n+    let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, some(upto.llbb), some(target));\n }\n \n fn leave_block(bcx: block, out_of: block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"leave_block\");\n+    let _icx = bcx.insn_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), ~\"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n@@ -4468,7 +4468,7 @@ fn leave_block(bcx: block, out_of: block) -> block {\n \n fn with_scope(bcx: block, opt_node_info: option<node_info>,\n               name: ~str, f: fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"with_scope\");\n+    let _icx = bcx.insn_ctxt(\"with_scope\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     leave_block(f(scope_cx), scope_cx)\n@@ -4477,15 +4477,15 @@ fn with_scope(bcx: block, opt_node_info: option<node_info>,\n fn with_scope_result(bcx: block, opt_node_info: option<node_info>,\n                      name: ~str, f: fn(block) -> result)\n     -> result {\n-    let _icx = bcx.insn_ctxt(~\"with_scope_result\");\n+    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let {bcx, val} = f(scope_cx);\n     {bcx: leave_block(bcx, scope_cx), val: val}\n }\n \n fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"with_cond\");\n+    let _icx = bcx.insn_ctxt(\"with_cond\");\n     let next_cx = sub_block(bcx, ~\"next\"), cond_cx = sub_block(bcx, ~\"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n@@ -4510,7 +4510,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n }\n \n fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"alloc_ty\");\n+    let _icx = bcx.insn_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let llty = type_of(ccx, t);\n     if ty::type_has_params(t) { log(error, ppaux::ty_to_str(ccx.tcx, t)); }\n@@ -4520,7 +4520,7 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n }\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n-    let _icx = cx.insn_ctxt(~\"alloc_local\");\n+    let _icx = cx.insn_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n       ast::pat_ident(_, pth, none) => some(path_to_ident(pth)),\n@@ -4540,7 +4540,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_block\");\n+    let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| { bcx = alloc_local(bcx, local); };\n     for vec::each(b.node.stmts) |s| {\n@@ -4622,7 +4622,7 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              ty_self: self_arg,\n                              args: ~[ast::arg]) {\n-    let _icx = cx.insn_ctxt(~\"create_llargs_for_fn_args\");\n+    let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n     // Skip the implicit arguments 0, and 1.\n     let mut arg_n = first_real_arg;\n     match ty_self {\n@@ -4647,7 +4647,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n \n fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n                         arg_tys: ~[ty::arg]) -> block {\n-    let _icx = fcx.insn_ctxt(~\"copy_args_to_allocas\");\n+    let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let tcx = bcx.tcx();\n     let mut arg_n: uint = 0u, bcx = bcx;\n     let epic_fail = fn@() -> ! {\n@@ -4685,14 +4685,14 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(~\"finish_fn\");\n+    let _icx = fcx.insn_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n     let ret_cx = raw_block(fcx, false, fcx.llreturn);\n     RetVoid(ret_cx);\n }\n \n fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(~\"tie_up_header_blocks\");\n+    let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n     Br(raw_block(fcx, false, fcx.llstaticallocas), fcx.llloadenv);\n     Br(raw_block(fcx, false, fcx.llloadenv), lltop);\n }\n@@ -4709,7 +4709,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  id: ast::node_id,\n                  maybe_load_env: fn(fn_ctxt),\n                  finish: fn(block)) {\n-    let _icx = ccx.insn_ctxt(~\"trans_closure\");\n+    let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -4765,7 +4765,7 @@ fn trans_fn(ccx: @crate_ctxt,\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0i64, nsec: 0i32} };\n-    let _icx = ccx.insn_ctxt(~\"trans_fn\");\n+    let _icx = ccx.insn_ctxt(\"trans_fn\");\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id,\n                   |fcx| {\n@@ -4787,7 +4787,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                       disr: int, is_degen: bool,\n                       param_substs: option<param_substs>,\n                       llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(~\"trans_enum_variant\");\n+    let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n     let fn_args = vec::map(args, |varg|\n         {mode: ast::expl(ast::by_copy),\n@@ -4968,7 +4968,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n }\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n-    let _icx = ccx.insn_ctxt(~\"trans_item\");\n+    let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) => p\n     };\n@@ -5068,7 +5068,7 @@ fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n-    let _icx = ccx.insn_ctxt(~\"trans_mod\");\n+    let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for vec::each(m.items) |item| { trans_item(ccx, *item); }\n }\n \n@@ -5375,7 +5375,7 @@ fn trans_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n \n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n-    let _icx = ccx.insn_ctxt(~\"trans_constant\");\n+    let _icx = ccx.insn_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(enum_definition, _) => {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n@@ -5814,12 +5814,12 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     gather_rtcalls(ccx, crate);\n \n     {\n-        let _icx = ccx.insn_ctxt(~\"data\");\n+        let _icx = ccx.insn_ctxt(\"data\");\n         trans_constants(ccx, crate);\n     }\n \n     {\n-        let _icx = ccx.insn_ctxt(~\"text\");\n+        let _icx = ccx.insn_ctxt(\"text\");\n         trans_mod(ccx, crate.node.module);\n     }\n "}, {"sha": "915be95c6cafb9c295b49118cab013c2a1c2dfe6", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -15,7 +15,7 @@ fn B(cx: block) -> BuilderRef {\n     return b;\n }\n \n-fn count_insn(cx: block, category: ~str) {\n+fn count_insn(cx: block, category: &str) {\n     if cx.ccx().sess.count_llvm_insns() {\n \n         let h = cx.ccx().stats.llvm_insns;\n@@ -70,15 +70,15 @@ fn RetVoid(cx: block) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"retvoid\");\n+    count_insn(cx, \"retvoid\");\n     llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: block, V: ValueRef) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"ret\");\n+    count_insn(cx, \"ret\");\n     llvm::LLVMBuildRet(B(cx), V);\n }\n \n@@ -96,7 +96,7 @@ fn Br(cx: block, Dest: BasicBlockRef) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"br\");\n+    count_insn(cx, \"br\");\n     llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n@@ -105,7 +105,7 @@ fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"condbr\");\n+    count_insn(cx, \"condbr\");\n     llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n@@ -126,7 +126,7 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"indirectbr\");\n+    count_insn(cx, \"indirectbr\");\n     llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n }\n \n@@ -147,7 +147,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n            str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, a)),\n                         ~\", \")};\n     unsafe {\n-        count_insn(cx, ~\"invoke\");\n+        count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                               Args.len() as c_uint, Then, Catch,\n                               noname());\n@@ -160,7 +160,7 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n-        count_insn(cx, ~\"fastinvoke\");\n+        count_insn(cx, \"fastinvoke\");\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                       Args.len() as c_uint,\n                                       Then, Catch, noname());\n@@ -172,7 +172,7 @@ fn Unreachable(cx: block) {\n     if cx.unreachable { return; }\n     cx.unreachable = true;\n     if !cx.terminated {\n-        count_insn(cx, ~\"unreachable\");\n+        count_insn(cx, \"unreachable\");\n         llvm::LLVMBuildUnreachable(B(cx));\n     }\n }\n@@ -184,218 +184,218 @@ fn _Undef(val: ValueRef) -> ValueRef {\n /* Arithmetic */\n fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"add\");\n+    count_insn(cx, \"add\");\n     return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nswadd\");\n+    count_insn(cx, \"nswadd\");\n     return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nuwadd\");\n+    count_insn(cx, \"nuwadd\");\n     return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"fadd\");\n+    count_insn(cx, \"fadd\");\n     return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"sub\");\n+    count_insn(cx, \"sub\");\n     return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nwsub\");\n+    count_insn(cx, \"nwsub\");\n     return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nuwsub\");\n+    count_insn(cx, \"nuwsub\");\n     return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"sub\");\n+    count_insn(cx, \"sub\");\n     return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"mul\");\n+    count_insn(cx, \"mul\");\n     return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nswmul\");\n+    count_insn(cx, \"nswmul\");\n     return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nuwmul\");\n+    count_insn(cx, \"nuwmul\");\n     return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"fmul\");\n+    count_insn(cx, \"fmul\");\n     return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"udiv\");\n+    count_insn(cx, \"udiv\");\n     return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"sdiv\");\n+    count_insn(cx, \"sdiv\");\n     return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"extractsdiv\");\n+    count_insn(cx, \"extractsdiv\");\n     return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"fdiv\");\n+    count_insn(cx, \"fdiv\");\n     return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"urem\");\n+    count_insn(cx, \"urem\");\n     return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"srem\");\n+    count_insn(cx, \"srem\");\n     return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"frem\");\n+    count_insn(cx, \"frem\");\n     return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"shl\");\n+    count_insn(cx, \"shl\");\n     return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"lshr\");\n+    count_insn(cx, \"lshr\");\n     return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"ashr\");\n+    count_insn(cx, \"ashr\");\n     return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"and\");\n+    count_insn(cx, \"and\");\n     return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"or\");\n+    count_insn(cx, \"or\");\n     return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"xor\");\n+    count_insn(cx, \"xor\");\n     return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"binop\");\n+    count_insn(cx, \"binop\");\n     return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn Neg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"neg\");\n+    count_insn(cx, \"neg\");\n     return llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"nswneg\");\n+    count_insn(cx, \"nswneg\");\n     return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"nuwneg\");\n+    count_insn(cx, \"nuwneg\");\n     return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"fneg\");\n+    count_insn(cx, \"fneg\");\n     return llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n fn Not(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"not\");\n+    count_insn(cx, \"not\");\n     return llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"malloc\");\n+    count_insn(cx, \"malloc\");\n     return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"arraymalloc\");\n+    count_insn(cx, \"arraymalloc\");\n     return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    count_insn(cx, ~\"alloca\");\n+    count_insn(cx, \"alloca\");\n     return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    count_insn(cx, ~\"arrayalloca\");\n+    count_insn(cx, \"arrayalloca\");\n     return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n fn Free(cx: block, PointerVal: ValueRef) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"free\");\n+    count_insn(cx, \"free\");\n     llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n@@ -407,7 +407,7 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         return llvm::LLVMGetUndef(eltty);\n     }\n-    count_insn(cx, ~\"load\");\n+    count_insn(cx, \"load\");\n     return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n@@ -416,14 +416,14 @@ fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     debug!{\"Store %s -> %s\",\n            val_str(cx.ccx().tn, Val),\n            val_str(cx.ccx().tn, Ptr)};\n-    count_insn(cx, ~\"store\");\n+    count_insn(cx, \"store\");\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-    count_insn(cx, ~\"gep\");\n+    count_insn(cx, \"gep\");\n     return llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n                                Indices.len() as c_uint, noname());\n     }\n@@ -434,15 +434,15 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n fn GEPi(cx: block, base: ValueRef, ixs: ~[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n     for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n-    count_insn(cx, ~\"gepi\");\n+    count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }\n \n fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        count_insn(cx, ~\"inboundsgep\");\n+        count_insn(cx, \"inboundsgep\");\n     return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                        vec::unsafe::to_ptr(Indices),\n                                        Indices.len() as c_uint,\n@@ -452,138 +452,138 @@ fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) ->\n \n fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    count_insn(cx, ~\"structgep\");\n+    count_insn(cx, \"structgep\");\n     return llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"globalstring\");\n+    count_insn(cx, \"globalstring\");\n     return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"globalstringptr\");\n+    count_insn(cx, \"globalstringptr\");\n     return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"trunc\");\n+    count_insn(cx, \"trunc\");\n     return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"zext\");\n+    count_insn(cx, \"zext\");\n     return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"sext\");\n+    count_insn(cx, \"sext\");\n     return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fptoui\");\n+    count_insn(cx, \"fptoui\");\n     return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fptosi\");\n+    count_insn(cx, \"fptosi\");\n     return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"uitofp\");\n+    count_insn(cx, \"uitofp\");\n     return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"sitofp\");\n+    count_insn(cx, \"sitofp\");\n     return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fptrunc\");\n+    count_insn(cx, \"fptrunc\");\n     return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fpext\");\n+    count_insn(cx, \"fpext\");\n     return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"ptrtoint\");\n+    count_insn(cx, \"ptrtoint\");\n     return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"inttoptr\");\n+    count_insn(cx, \"inttoptr\");\n     return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"bitcast\");\n+    count_insn(cx, \"bitcast\");\n     return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"zextorbitcast\");\n+    count_insn(cx, \"zextorbitcast\");\n     return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"sextorbitcast\");\n+    count_insn(cx, \"sextorbitcast\");\n     return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"truncorbitcast\");\n+    count_insn(cx, \"truncorbitcast\");\n     return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: *u8) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"cast\");\n+    count_insn(cx, \"cast\");\n     return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"pointercast\");\n+    count_insn(cx, \"pointercast\");\n     return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"intcast\");\n+    count_insn(cx, \"intcast\");\n     return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fpcast\");\n+    count_insn(cx, \"fpcast\");\n     return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n@@ -592,21 +592,21 @@ fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"icmp\");\n+    count_insn(cx, \"icmp\");\n     return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"fcmp\");\n+    count_insn(cx, \"fcmp\");\n     return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    count_insn(cx, ~\"emptyphi\");\n+    count_insn(cx, \"emptyphi\");\n     return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n@@ -616,7 +616,7 @@ fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n     assert vals.len() == bbs.len();\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n-        count_insn(cx, ~\"addincoming\");\n+        count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::unsafe::to_ptr(vals),\n                               vec::unsafe::to_ptr(bbs),\n                               vals.len() as c_uint);\n@@ -671,7 +671,7 @@ fn add_comment(bcx: block, text: ~str) {\n fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n-        count_insn(cx, ~\"call\");\n+        count_insn(cx, \"call\");\n \n         debug!{\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n@@ -685,7 +685,7 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n-        count_insn(cx, ~\"fastcall\");\n+        count_insn(cx, \"fastcall\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n@@ -697,7 +697,7 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n                 Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n-        count_insn(cx, ~\"callwithconv\");\n+        count_insn(cx, \"callwithconv\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, Conv);\n@@ -708,68 +708,68 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { return _Undef(Then); }\n-    count_insn(cx, ~\"select\");\n+    count_insn(cx, \"select\");\n     return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    count_insn(cx, ~\"vaarg\");\n+    count_insn(cx, \"vaarg\");\n     return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n-    count_insn(cx, ~\"extractelement\");\n+    count_insn(cx, \"extractelement\");\n     return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"insertelement\");\n+    count_insn(cx, \"insertelement\");\n     llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"shufflevector\");\n+    count_insn(cx, \"shufflevector\");\n     llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n-    count_insn(cx, ~\"extractvalue\");\n+    count_insn(cx, \"extractvalue\");\n     return llvm::LLVMBuildExtractValue(\n         B(cx), AggVal, Index as c_uint, noname());\n }\n \n fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"insertvalue\");\n+    count_insn(cx, \"insertvalue\");\n     llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n                                noname());\n }\n \n fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"isnull\");\n+    count_insn(cx, \"isnull\");\n     return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"isnotnull\");\n+    count_insn(cx, \"isnotnull\");\n     return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n-    count_insn(cx, ~\"ptrdiff\");\n+    count_insn(cx, \"ptrdiff\");\n     return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n@@ -785,7 +785,7 @@ fn Trap(cx: block) {\n     assert (T as int != 0);\n     let Args: ~[ValueRef] = ~[];\n     unsafe {\n-        count_insn(cx, ~\"trap\");\n+        count_insn(cx, \"trap\");\n         llvm::LLVMBuildCall(b, T, vec::unsafe::to_ptr(Args),\n                             Args.len() as c_uint, noname());\n     }\n@@ -794,20 +794,20 @@ fn Trap(cx: block) {\n fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n-    count_insn(cx, ~\"landingpad\");\n+    count_insn(cx, \"landingpad\");\n     return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                   NumClauses as c_uint, noname());\n }\n \n fn SetCleanup(cx: block, LandingPad: ValueRef) {\n-    count_insn(cx, ~\"setcleanup\");\n+    count_insn(cx, \"setcleanup\");\n     llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n }\n \n fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"resume\");\n+    count_insn(cx, \"resume\");\n     return llvm::LLVMBuildResume(B(cx), Exn);\n }\n "}, {"sha": "9e5bdc1964c3f023b03086224569c5ac2ce8b20a", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -137,11 +137,11 @@ fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n     -> result {\n-    let _icx = bcx.insn_ctxt(~\"closure::allocate_cbox\");\n+    let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, llbox: ValueRef) {\n-        let _icx = bcx.insn_ctxt(~\"closure::nuke_ref_count\");\n+        let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let llbox = PointerCast(bcx, llbox, T_opaque_box_ptr(ccx));\n@@ -178,7 +178,7 @@ type closure_result = {\n fn store_environment(bcx: block,\n                      bound_values: ~[environment_value],\n                      ck: ty::closure_kind) -> closure_result {\n-    let _icx = bcx.insn_ctxt(~\"closure::store_environment\");\n+    let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n@@ -251,7 +251,7 @@ fn build_closure(bcx0: block,\n                  ck: ty::closure_kind,\n                  id: ast::node_id,\n                  include_ret_handle: option<ValueRef>) -> closure_result {\n-    let _icx = bcx0.insn_ctxt(~\"closure::build_closure\");\n+    let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut env_vals = ~[];\n     let mut bcx = bcx0;\n@@ -312,7 +312,7 @@ fn load_environment(fcx: fn_ctxt,\n                     cap_vars: ~[capture::capture_var],\n                     load_ret_handle: bool,\n                     ck: ty::closure_kind) {\n-    let _icx = fcx.insn_ctxt(~\"closure::load_environment\");\n+    let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n     let bcx = raw_block(fcx, false, fcx.llloadenv);\n \n     // Load a pointer to the closure data, skipping over the box header:\n@@ -354,7 +354,7 @@ fn trans_expr_fn(bcx: block,\n                  cap_clause: ast::capture_clause,\n                  is_loop_body: option<option<ValueRef>>,\n                  dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"closure::trans_expr_fn\");\n+    let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n     if dest == ignore { return bcx; }\n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, id);\n@@ -407,7 +407,7 @@ fn make_fn_glue(\n     t: ty::t,\n     glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"closure::make_fn_glue\");\n+    let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n@@ -439,7 +439,7 @@ fn make_opaque_cbox_take_glue(\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n-    let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_take_glue\");\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match ck {\n       ty::ck_block => return bcx,\n       ty::ck_box => {\n@@ -491,7 +491,7 @@ fn make_opaque_cbox_drop_glue(\n     ck: ty::closure_kind,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_drop_glue\");\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match ck {\n       ty::ck_block => bcx,\n       ty::ck_box => {\n@@ -510,7 +510,7 @@ fn make_opaque_cbox_free_glue(\n     ck: ty::closure_kind,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match ck {\n       ty::ck_block => return bcx,\n       ty::ck_box | ty::ck_uniq => { /* hard cases: */ }"}, {"sha": "51b16fd19c826457f9a6b06ef22b7b26fe955273", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -4,7 +4,7 @@ import base::get_insn_ctxt;\n \n fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"trans_lit\");\n+    let _icx = cx.insn_ctxt(\"trans_lit\");\n     match lit.node {\n       ast::lit_int(i, t) => C_integral(T_int_ty(cx, t), i as u64, True),\n       ast::lit_uint(u, t) => C_integral(T_uint_ty(cx, t), u, False),\n@@ -82,7 +82,7 @@ fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n \n \n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"const_expr\");\n+    let _icx = cx.insn_ctxt(\"const_expr\");\n     match e.node {\n       ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n       ast::expr_binary(b, e1, e2) => {\n@@ -366,7 +366,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n }\n \n fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(~\"trans_const\");\n+    let _icx = ccx.insn_ctxt(\"trans_const\");\n     let v = const_expr(ccx, e);\n \n     // The scalars come back as 1st class LLVM vals"}, {"sha": "6df5a00f21d804a35731d8fd2aa6522f778e71b4", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -511,7 +511,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n                   arg_builder: wrap_arg_builder,\n                   ret_builder: wrap_ret_builder) {\n \n-    let _icx = ccx.insn_ctxt(~\"foreign::build_wrap_fn_\");\n+    let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, none);\n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n@@ -571,18 +571,18 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n fn trans_foreign_mod(ccx: @crate_ctxt,\n                     foreign_mod: ast::foreign_mod, abi: ast::foreign_abi) {\n \n-    let _icx = ccx.insn_ctxt(~\"foreign::trans_foreign_mod\");\n+    let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n     fn build_shim_fn(ccx: @crate_ctxt,\n                      foreign_item: @ast::foreign_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::build_shim_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(~\"foreign::shim::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n             let mut llargvals = ~[];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n@@ -628,7 +628,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n-            let _icx = bcx.insn_ctxt(~\"foreign::shim::build_ret\");\n+            let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             match tys.x86_64_tys {\n                 some(x86_64) => {\n                   do vec::iteri(x86_64.attrs) |i, a| {\n@@ -719,11 +719,11 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::build_wrap_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::wrap::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n             let implicit_args = first_real_arg; // return + env\n@@ -738,7 +738,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n         fn build_ret(bcx: block, _tys: @c_stack_tys,\n                      _llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::wrap::build_ret\");\n+            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n             RetVoid(bcx);\n         }\n \n@@ -987,12 +987,12 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                   body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n \n-    let _icx = ccx.insn_ctxt(~\"foreign::build_foreign_fn\");\n+    let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      decl: ast::fn_decl, body: ast::blk,\n                      id: ast::node_id) -> ValueRef {\n-        let _icx = ccx.insn_ctxt(~\"foreign::foreign::build_rust_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n             ccx, vec::append_one(path, ast_map::path_name(@~\"__rust_abi\")));\n@@ -1005,11 +1005,11 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::foreign::build_shim_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(~\"foreign::extern::shim::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n             let mut llargvals = ~[];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n@@ -1042,11 +1042,11 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::foreign::build_wrap_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::foreign::wrap::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n             match tys.x86_64_tys {\n                 option::some(x86_64) => {\n                     let mut atys = x86_64.arg_tys;\n@@ -1100,7 +1100,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::foreign::wrap::build_ret\");\n+            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n             match tys.x86_64_tys {\n                 option::some(x86_64) => {\n                     if x86_64.sret || !tys.ret_def {\n@@ -1144,7 +1144,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n fn register_foreign_fn(ccx: @crate_ctxt, sp: span,\n                      path: ast_map::path, node_id: ast::node_id)\n     -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"foreign::register_foreign_fn\");\n+    let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n     return if ccx.sess.targ_cfg.arch == arch_x86_64 {"}, {"sha": "9aa4f2ba97bc6acb125bd948d6ab20ae68062b8a", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -20,7 +20,7 @@ import syntax::print::pprust::expr_to_str;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: ~[@ast::method], tps: ~[ast::ty_param]) {\n-    let _icx = ccx.insn_ctxt(~\"impl::trans_impl\");\n+    let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |m| {\n@@ -41,7 +41,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n }\n \n fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_self_arg\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     let mut temp_cleanups = ~[];\n@@ -59,7 +59,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                        self: @ast::expr, mentry: typeck::method_map_entry)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_method_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     match mentry.origin {\n       typeck::method_static(did) => {\n         let {bcx, val} = trans_self_arg(bcx, self, mentry.derefs);\n@@ -89,7 +89,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n \n fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n                               callee_id: ast::node_id) -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_static_method_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     let mname = if method_id.crate == ast::local_crate {\n@@ -175,7 +175,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               trait_id: ast::def_id, n_method: uint,\n                               vtbl: typeck::vtable_origin)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_monomorphized_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     match vtbl {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n         let ccx = bcx.ccx();\n@@ -210,7 +210,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n fn trans_trait_callee(bcx: block, val: ValueRef,\n                       callee_ty: ty::t, n_method: uint)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_trait_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n     let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, ~[0u, 0u]),\n                                        T_ptr(T_ptr(T_vtable()))));\n@@ -299,7 +299,7 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n }\n \n fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"impl::make_vtable\");\n+    let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n     let vt_gvar = str::as_c_str(ccx.names(~\"vtable\"), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n@@ -312,7 +312,7 @@ fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n \n fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                     vtables: typeck::vtable_res) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"impl::make_impl_vtable\");\n+    let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n     // XXX: This should support multiple traits.\n@@ -345,7 +345,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_cast\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n     if dest == ignore { return trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);"}, {"sha": "9633284758810ac95d5f2cfb5b769893866caec6", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -32,7 +32,7 @@ fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n }\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"tvec::get_fill\");\n+    let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, ~[0u, abi::vec_elt_fill]))\n }\n fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n@@ -48,20 +48,20 @@ fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n \n fn get_dataptr(bcx: block, vptr: ValueRef)\n     -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"tvec::get_dataptr\");\n+    let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, ~[0u, abi::vec_elt_elems, 0u])\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"tvec::pointer_add\");\n+    let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, ~[bytes]), old_ty);\n }\n \n fn alloc_raw(bcx: block, unit_ty: ty::t,\n               fill: ValueRef, alloc: ValueRef, heap: heap) -> result {\n-    let _icx = bcx.insn_ctxt(~\"tvec::alloc_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n@@ -79,7 +79,7 @@ fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n }\n \n fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n-    let _icx = bcx.insn_ctxt(~\"tvec::alloc_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = llsize_of(ccx, llunitty);\n@@ -92,7 +92,7 @@ fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n }\n \n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(~\"tvec::duplicate_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n \n     let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -110,7 +110,7 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n \n fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::make_drop_glue_unboxed\");\n+    let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n         iter_vec_unboxed(bcx, vptr, vec_ty, base::drop_ty)\n@@ -124,7 +124,7 @@ enum evec_elements {\n \n fn trans_evec(bcx: block, elements: evec_elements,\n               vst: ast::vstore, id: ast::node_id, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::trans_evec\");\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_evec\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n@@ -318,7 +318,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n \n fn trans_estr(bcx: block, s: @~str, vstore: option<ast::vstore>,\n               dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::trans_estr\");\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");\n     if dest == base::ignore { return bcx; }\n     let ccx = bcx.ccx();\n \n@@ -362,7 +362,7 @@ type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_raw\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n@@ -393,14 +393,14 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n \n fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                  fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n                     f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_unboxed\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);\n     return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);"}, {"sha": "f9b4a76bced04c646a68f8d6b8aa56789b6a1e5a", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c16ff516d97bb4a69ad965b93e6db61343be381/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=4c16ff516d97bb4a69ad965b93e6db61343be381", "patch": "@@ -9,7 +9,7 @@ export make_free_glue, autoderef, duplicate;\n \n fn make_free_glue(bcx: block, vptrptr: ValueRef, t: ty::t)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"uniq::make_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n     let vptr = Load(bcx, vptrptr);\n     do with_cond(bcx, IsNotNull(bcx, vptr)) |bcx| {\n         let content_ty = content_ty(t);\n@@ -33,7 +33,7 @@ fn autoderef(bcx: block, v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n }\n \n fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(~\"uniq::duplicate\");\n+    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n     let content_ty = content_ty(t);\n     let {bcx: bcx, box: dst_box, body: dst_body} =\n         malloc_unique(bcx, content_ty);"}]}