{"sha": "5569fffe7d71ed52ce284d0ffc6691d0141874f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NjlmZmZlN2Q3MWVkNTJjZTI4NGQwZmZjNjY5MWQwMTQxODc0ZjI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-24T08:09:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-24T08:09:23Z"}, "message": "avoid having both Debug and Display for a type and using the wrong one", "tree": {"sha": "87a4c4a7d97b3858537b7101081d84fe3f241a5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a4c4a7d97b3858537b7101081d84fe3f241a5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5569fffe7d71ed52ce284d0ffc6691d0141874f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5569fffe7d71ed52ce284d0ffc6691d0141874f2", "html_url": "https://github.com/rust-lang/rust/commit/5569fffe7d71ed52ce284d0ffc6691d0141874f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5569fffe7d71ed52ce284d0ffc6691d0141874f2/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6f1010747104db6af41b2a49d168af66328910", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6f1010747104db6af41b2a49d168af66328910", "html_url": "https://github.com/rust-lang/rust/commit/ff6f1010747104db6af41b2a49d168af66328910"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "0c1e9b9c49aaf2c0aacea5216420e8c53ced8033", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5569fffe7d71ed52ce284d0ffc6691d0141874f2/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5569fffe7d71ed52ce284d0ffc6691d0141874f2/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=5569fffe7d71ed52ce284d0ffc6691d0141874f2", "patch": "@@ -18,16 +18,16 @@ pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n \n /// Tracking pointer provenance\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub enum Tag {\n     Tagged(PtrId),\n     Untagged,\n }\n \n-impl fmt::Display for Tag {\n+impl fmt::Debug for Tag {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            Tag::Tagged(id) => write!(f, \"{}\", id),\n+            Tag::Tagged(id) => write!(f, \"<{}>\", id),\n             Tag::Untagged => write!(f, \"<untagged>\"),\n         }\n     }\n@@ -48,7 +48,7 @@ pub enum Permission {\n }\n \n /// An item in the per-location borrow stack.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Item {\n     /// The permission this item grants.\n     perm: Permission,\n@@ -58,9 +58,9 @@ pub struct Item {\n     protector: Option<CallId>,\n }\n \n-impl fmt::Display for Item {\n+impl fmt::Debug for Item {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"[{:?} for {}\", self.perm, self.tag)?;\n+        write!(f, \"[{:?} for {:?}\", self.perm, self.tag)?;\n         if let Some(call) = self.protector {\n             write!(f, \" (call {})\", call)?;\n         }\n@@ -99,7 +99,7 @@ pub struct GlobalState {\n pub type MemoryState = Rc<RefCell<GlobalState>>;\n \n /// Indicates which kind of access is being performed.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub enum AccessKind {\n     Read,\n     Write,\n@@ -108,16 +108,16 @@ pub enum AccessKind {\n impl fmt::Display for AccessKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            AccessKind::Read => write!(f, \"read\"),\n-            AccessKind::Write => write!(f, \"write\"),\n+            AccessKind::Read => write!(f, \"read access\"),\n+            AccessKind::Write => write!(f, \"write access\"),\n         }\n     }\n }\n \n /// Indicates which kind of reference is being created.\n /// Used by high-level `reborrow` to compute which permissions to grant to the\n /// new pointer.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub enum RefKind {\n     /// `&mut` and `Box`.\n     Unique { two_phase: bool },\n@@ -261,12 +261,12 @@ impl<'tcx> Stack {\n             if global.is_active(call) {\n                 if let Some(tag) = tag {\n                     return err!(MachineError(format!(\n-                        \"not granting access to tag {} because incompatible item is protected: {}\",\n+                        \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                         tag, item\n                     )));\n                 } else {\n                     return err!(MachineError(format!(\n-                        \"deallocating while item is protected: {}\", item\n+                        \"deallocating while item is protected: {:?}\", item\n                     )));\n                 }\n             }\n@@ -287,7 +287,7 @@ impl<'tcx> Stack {\n         // Step 1: Find granting item.\n         let granting_idx = self.find_granting(access, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                \"no item granting {} access to tag {} found in borrow stack\",\n+                \"no item granting {} to tag {:?} found in borrow stack\",\n                 access, tag,\n             )))?;\n \n@@ -298,7 +298,7 @@ impl<'tcx> Stack {\n             // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n             let first_incompatible_idx = self.find_first_write_incompaible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n-                trace!(\"access: popping item {}\", item);\n+                trace!(\"access: popping item {:?}\", item);\n                 Stack::check_protector(&item, Some(tag), global)?;\n             }\n         } else {\n@@ -313,7 +313,7 @@ impl<'tcx> Stack {\n             for idx in (granting_idx+1 .. self.borrows.len()).rev() {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n-                    trace!(\"access: disabling item {}\", item);\n+                    trace!(\"access: disabling item {:?}\", item);\n                     Stack::check_protector(item, Some(tag), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n@@ -334,7 +334,7 @@ impl<'tcx> Stack {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                \"no item granting write access for deallocation to tag {} found in borrow stack\",\n+                \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n                 tag,\n             )))?;\n \n@@ -383,7 +383,7 @@ impl<'tcx> Stack {\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                \"trying to reborrow for {:?}, but parent tag {} does not have an appropriate item in the borrow stack\", new.perm, derived_from,\n+                \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\", new.perm, derived_from,\n             )))?;\n \n         // Compute where to put the new item.\n@@ -412,9 +412,9 @@ impl<'tcx> Stack {\n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n         if self.borrows[new_idx-1] == new || self.borrows.get(new_idx) == Some(&new) {\n             // Optimization applies, done.\n-            trace!(\"reborrow: avoiding adding redundant item {}\", new);\n+            trace!(\"reborrow: avoiding adding redundant item {:?}\", new);\n         } else {\n-            trace!(\"reborrow: adding item {}\", new);\n+            trace!(\"reborrow: adding item {:?}\", new);\n             self.borrows.insert(new_idx, new);\n         }\n \n@@ -497,7 +497,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"read access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Read, ptr.tag, global)?;\n             Ok(())\n@@ -510,7 +510,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"write access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Write, ptr.tag, global)?;\n             Ok(())\n@@ -523,7 +523,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.dealloc(ptr.tag, global)\n         })\n@@ -545,7 +545,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n-        trace!(\"reborrow: {} reference {} derived from {} (pointee {}): {:?}, size {}\",\n+        trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind, new_tag, ptr.tag, place.layout.ty, ptr, size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`."}]}