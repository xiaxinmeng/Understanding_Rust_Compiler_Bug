{"sha": "dc5df61bc1914224d50d92cdd5599b6337ac68f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNWRmNjFiYzE5MTQyMjRkNTBkOTJjZGQ1NTk5YjYzMzdhYzY4ZjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-02T00:54:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T00:00:51Z"}, "message": "librustc: Update the serializer to work properly with INHTWAMA, removing mutable fields in the process", "tree": {"sha": "1365352083cfe8b3d8864b3c3620ae4e7e51d3c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1365352083cfe8b3d8864b3c3620ae4e7e51d3c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc5df61bc1914224d50d92cdd5599b6337ac68f2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5df61bc1914224d50d92cdd5599b6337ac68f2", "html_url": "https://github.com/rust-lang/rust/commit/dc5df61bc1914224d50d92cdd5599b6337ac68f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc5df61bc1914224d50d92cdd5599b6337ac68f2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2e429041da1990a91477e37316c73729cb6fe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2e429041da1990a91477e37316c73729cb6fe2", "html_url": "https://github.com/rust-lang/rust/commit/6f2e429041da1990a91477e37316c73729cb6fe2"}], "stats": {"total": 5976, "additions": 5381, "deletions": 595}, "files": [{"sha": "1be49528b9e797d799132ec0228893b3344d6ae0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -272,12 +272,21 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n     @bounds\n }\n \n+#[cfg(stage0)]\n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n     reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n         Decodable::decode(&reader::Decoder(*doc))\n     })\n }\n \n+#[cfg(not(stage0))]\n+fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n+    reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n+        let mut decoder = reader::Decoder(*doc);\n+        Decodable::decode(&mut decoder)\n+    })\n+}\n+\n fn item_ty_param_count(item: ebml::Doc) -> uint {\n     let mut n = 0u;\n     reader::tagged_docs(item, tag_items_data_item_ty_param_bounds,"}, {"sha": "77373076137b90d92f7dad9d75ab5f2c2a629bb6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1488, "deletions": 150, "changes": 1638, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -42,11 +42,18 @@ use writer = std::ebml::writer;\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n+#[cfg(stage0)]\n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n                                    ebml_w: &writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n+#[cfg(not(stage0))]\n+pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n+                                   ebml_w: &mut writer::Encoder,\n+                                   path: &[ast_map::path_elt],\n+                                   ii: ast::inlined_item);\n+\n pub struct EncodeParams {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n@@ -91,21 +98,47 @@ pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n+#[cfg(stage0)]\n fn encode_name(ecx: @EncodeContext, ebml_w: &writer::Encoder, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+#[cfg(not(stage0))]\n+fn encode_name(ecx: @EncodeContext,\n+               ebml_w: &mut writer::Encoder,\n+               name: ident) {\n+    ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n+}\n+\n+#[cfg(stage0)]\n+fn encode_impl_type_basename(ecx: @EncodeContext,\n+                             ebml_w: &writer::Encoder,\n+                             name: ident) {\n+    ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n+                         *ecx.tcx.sess.str_of(name));\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_impl_type_basename(ecx: @EncodeContext,\n+                             ebml_w: &mut writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          *ecx.tcx.sess.str_of(name));\n }\n \n+#[cfg(stage0)]\n pub fn encode_def_id(ebml_w: &writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+#[cfg(not(stage0))]\n+pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n+    ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n+}\n+\n+#[cfg(stage0)]\n+fn encode_region_param(ecx: @EncodeContext,\n+                       ebml_w: &writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n     for opt_rp.each |rp| {\n@@ -115,6 +148,19 @@ fn encode_region_param(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_region_param(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n+                       it: @ast::item) {\n+    let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n+    for opt_rp.each |rp| {\n+        ebml_w.start_tag(tag_region_param);\n+        rp.encode(ebml_w);\n+        ebml_w.end_tag();\n+    }\n+}\n+\n+#[cfg(stage0)]\n fn encode_mutability(ebml_w: &writer::Encoder, mt: struct_mutability) {\n     do ebml_w.wr_tag(tag_struct_mut) {\n         let val = match mt {\n@@ -125,13 +171,45 @@ fn encode_mutability(ebml_w: &writer::Encoder, mt: struct_mutability) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_mutability(ebml_w: &mut writer::Encoder, mt: struct_mutability) {\n+    ebml_w.start_tag(tag_struct_mut);\n+    let val = match mt {\n+      struct_immutable => 'a',\n+      struct_mutable => 'm'\n+    };\n+    ebml_w.writer.write(&[val as u8]);\n+    ebml_w.end_tag();\n+}\n+\n struct entry<T> {\n     val: T,\n     pos: uint\n }\n \n-fn add_to_index(ecx: @EncodeContext, ebml_w: &writer::Encoder, path: &[ident],\n-                index: &mut ~[entry<~str>], name: ident) {\n+#[cfg(stage0)]\n+fn add_to_index(ecx: @EncodeContext,\n+                ebml_w: &writer::Encoder,\n+                path: &[ident],\n+                index: &mut ~[entry<~str>],\n+                name: ident) {\n+    let mut full_path = ~[];\n+    full_path.push_all(path);\n+    full_path.push(name);\n+    index.push(\n+        entry {\n+            val: ast_util::path_name_i(full_path,\n+                                       ecx.tcx.sess.parse_sess.interner),\n+            pos: ebml_w.writer.tell()\n+        });\n+}\n+\n+#[cfg(not(stage0))]\n+fn add_to_index(ecx: @EncodeContext,\n+                ebml_w: &mut writer::Encoder,\n+                path: &[ident],\n+                index: &mut ~[entry<~str>],\n+                name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n     full_path.push(name);\n@@ -143,11 +221,28 @@ fn add_to_index(ecx: @EncodeContext, ebml_w: &writer::Encoder, path: &[ident],\n         });\n }\n \n+#[cfg(stage0)]\n fn encode_trait_ref(ebml_w: &writer::Encoder,\n                     ecx: @EncodeContext,\n                     trait_ref: &ty::TraitRef,\n-                    tag: uint)\n-{\n+                    tag: uint) {\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+\n+    ebml_w.start_tag(tag);\n+    tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n+                    ecx: @EncodeContext,\n+                    trait_ref: &ty::TraitRef,\n+                    tag: uint) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -161,14 +256,26 @@ fn encode_trait_ref(ebml_w: &writer::Encoder,\n }\n \n // Item info table encoding\n+#[cfg(stage0)]\n fn encode_family(ebml_w: &writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n-pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n+// Item info table encoding\n+#[cfg(not(stage0))]\n+fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n+    ebml_w.start_tag(tag_items_data_item_family);\n+    ebml_w.writer.write(&[c as u8]);\n+    ebml_w.end_tag();\n+}\n+\n+pub fn def_to_str(did: def_id) -> ~str {\n+    fmt!(\"%d:%d\", did.crate, did.node)\n+}\n \n+#[cfg(stage0)]\n fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n                              ecx: @EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n@@ -186,6 +293,25 @@ fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n+                             ecx: @EncodeContext,\n+                             params: @~[ty::TypeParameterDef],\n+                             tag: uint) {\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    for params.each |param| {\n+        ebml_w.start_tag(tag);\n+        tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n+        ebml_w.end_tag();\n+    }\n+}\n+\n+#[cfg(stage0)]\n fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n@@ -195,13 +321,31 @@ fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n                               tag_items_data_item_ty_param_bounds);\n }\n \n+#[cfg(not(stage0))]\n+fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n+                            ecx: @EncodeContext,\n+                            params: &OptVec<TyParam>) {\n+    let ty_param_defs =\n+        @params.map_to_vec(|param| *ecx.tcx.ty_param_defs.get(&param.id));\n+    encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n+                              tag_items_data_item_ty_param_bounds);\n+}\n \n+#[cfg(stage0)]\n fn encode_variant_id(ebml_w: &writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n+    ebml_w.start_tag(tag_items_data_item_variant);\n+    ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -212,7 +356,35 @@ pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+#[cfg(not(stage0))]\n+pub fn write_type(ecx: @EncodeContext,\n+                  ebml_w: &mut writer::Encoder,\n+                  typ: ty::t) {\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n+}\n+\n+#[cfg(stage0)]\n+pub fn write_vstore(ecx: @EncodeContext,\n+                    ebml_w: &writer::Encoder,\n+                    vstore: ty::vstore) {\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n+}\n+\n+#[cfg(not(stage0))]\n+pub fn write_vstore(ecx: @EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -223,27 +395,65 @@ pub fn write_vstore(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n+#[cfg(stage0)]\n fn encode_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_type(ecx: @EncodeContext,\n+               ebml_w: &mut writer::Encoder,\n+               typ: ty::t) {\n+    ebml_w.start_tag(tag_items_data_item_type);\n+    write_type(ecx, ebml_w, typ);\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n fn encode_transformed_self_ty(ecx: @EncodeContext,\n                               ebml_w: &writer::Encoder,\n-                              opt_typ: Option<ty::t>)\n-{\n+                              opt_typ: Option<ty::t>) {\n+    for opt_typ.each |&typ| {\n+        ebml_w.start_tag(tag_item_method_transformed_self_ty);\n+        write_type(ecx, ebml_w, typ);\n+        ebml_w.end_tag();\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_transformed_self_ty(ecx: @EncodeContext,\n+                              ebml_w: &mut writer::Encoder,\n+                              opt_typ: Option<ty::t>) {\n     for opt_typ.each |&typ| {\n         ebml_w.start_tag(tag_item_method_transformed_self_ty);\n         write_type(ecx, ebml_w, typ);\n         ebml_w.end_tag();\n     }\n }\n \n+#[cfg(stage0)]\n fn encode_method_fty(ecx: @EncodeContext,\n                      ebml_w: &writer::Encoder,\n-                     typ: &ty::BareFnTy)\n-{\n+                     typ: &ty::BareFnTy) {\n+    ebml_w.start_tag(tag_item_method_fty);\n+\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n+\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_method_fty(ecx: @EncodeContext,\n+                     ebml_w: &mut writer::Encoder,\n+                     typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n     let ty_str_ctxt = @tyencode::ctxt {\n@@ -257,6 +467,7 @@ fn encode_method_fty(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n+#[cfg(stage0)]\n fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n@@ -272,28 +483,123 @@ fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+#[cfg(not(stage0))]\n+fn encode_symbol(ecx: @EncodeContext,\n+                 ebml_w: &mut writer::Encoder,\n+                 id: node_id) {\n+    ebml_w.start_tag(tag_items_data_item_symbol);\n+    match ecx.item_symbols.find(&id) {\n+        Some(x) => {\n+            debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n+            ebml_w.writer.write(str::to_bytes(*x));\n+        }\n+        None => {\n+            ecx.diag.handler().bug(\n+                fmt!(\"encode_symbol: id not found %d\", id));\n+        }\n+    }\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_discriminant(ecx: @EncodeContext,\n+                       ebml_w: &writer::Encoder,\n+                       id: node_id) {\n+    ebml_w.start_tag(tag_items_data_item_symbol);\n+    ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_discriminant(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+#[cfg(stage0)]\n+fn encode_disr_val(_: @EncodeContext,\n+                   ebml_w: &writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_disr_val(_: @EncodeContext,\n+                   ebml_w: &mut writer::Encoder,\n+                   disr_val: int) {\n+    ebml_w.start_tag(tag_disr_val);\n+    ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n fn encode_parent_item(ebml_w: &writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                            id: node_id, variants: &[variant],\n+#[cfg(not(stage0))]\n+fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n+    ebml_w.start_tag(tag_items_data_parent_item);\n+    ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_enum_variant_info(ecx: @EncodeContext,\n+                            ebml_w: &writer::Encoder,\n+                            id: node_id,\n+                            variants: &[variant],\n+                            path: &[ast_map::path_elt],\n+                            index: @mut ~[entry<int>],\n+                            generics: &ast::Generics) {\n+    debug!(\"encode_enum_variant_info(id=%?)\", id);\n+\n+    let mut disr_val = 0;\n+    let mut i = 0;\n+    let vi = ty::enum_variants(ecx.tcx,\n+                               ast::def_id { crate: local_crate, node: id });\n+    for variants.each |variant| {\n+        index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(variant.node.id));\n+        encode_family(ebml_w, 'v');\n+        encode_name(ecx, ebml_w, variant.node.name);\n+        encode_parent_item(ebml_w, local_def(id));\n+        encode_type(ecx, ebml_w,\n+                    node_id_to_type(ecx.tcx, variant.node.id));\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(ref args)\n+                    if args.len() > 0 && generics.ty_params.len() == 0 => {\n+                encode_symbol(ecx, ebml_w, variant.node.id);\n+            }\n+            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {}\n+        }\n+        encode_discriminant(ecx, ebml_w, variant.node.id);\n+        if vi[i].disr_val != disr_val {\n+            encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n+            disr_val = vi[i].disr_val;\n+        }\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_path(ecx, ebml_w, path,\n+                    ast_map::path_name(variant.node.name));\n+        ebml_w.end_tag();\n+        disr_val += 1;\n+        i += 1;\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_enum_variant_info(ecx: @EncodeContext,\n+                            ebml_w: &mut writer::Encoder,\n+                            id: node_id,\n+                            variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n                             generics: &ast::Generics) {\n@@ -333,8 +639,11 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     }\n }\n \n-fn encode_path(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-               path: &[ast_map::path_elt], name: ast_map::path_elt) {\n+#[cfg(stage0)]\n+fn encode_path(ecx: @EncodeContext,\n+               ebml_w: &writer::Encoder,\n+               path: &[ast_map::path_elt],\n+               name: ast_map::path_elt) {\n     fn encode_path_elt(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n@@ -354,8 +663,37 @@ fn encode_path(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                       md: &_mod, id: node_id, path: &[ast_map::path_elt],\n+#[cfg(not(stage0))]\n+fn encode_path(ecx: @EncodeContext,\n+               ebml_w: &mut writer::Encoder,\n+               path: &[ast_map::path_elt],\n+               name: ast_map::path_elt) {\n+    fn encode_path_elt(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n+                       elt: ast_map::path_elt) {\n+        let (tag, name) = match elt {\n+          ast_map::path_mod(name) => (tag_path_elt_mod, name),\n+          ast_map::path_name(name) => (tag_path_elt_name, name)\n+        };\n+\n+        ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n+    }\n+\n+    ebml_w.start_tag(tag_path);\n+    ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n+    for path.each |pe| {\n+        encode_path_elt(ecx, ebml_w, *pe);\n+    }\n+    encode_path_elt(ecx, ebml_w, name);\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_info_for_mod(ecx: @EncodeContext,\n+                       ebml_w: &writer::Encoder,\n+                       md: &_mod,\n+                       id: node_id,\n+                       path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -412,32 +750,164 @@ fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: &writer::Encoder,\n-                              visibility: visibility) {\n-    encode_family(ebml_w, match visibility {\n-        public => 'g',\n-        private => 'j',\n-        inherited => 'N'\n-    });\n-}\n-\n-fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n-    ebml_w.start_tag(tag_items_data_item_visibility);\n-    let ch = match visibility {\n-        public => 'y',\n-        private => 'n',\n-        inherited => 'i',\n-    };\n-    ebml_w.wr_str(str::from_char(ch));\n-    ebml_w.end_tag();\n-}\n+#[cfg(not(stage0))]\n+fn encode_info_for_mod(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n+                       md: &_mod,\n+                       id: node_id,\n+                       path: &[ast_map::path_elt],\n+                       name: ident) {\n+    ebml_w.start_tag(tag_items_data_item);\n+    encode_def_id(ebml_w, local_def(id));\n+    encode_family(ebml_w, 'm');\n+    encode_name(ecx, ebml_w, name);\n+    debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n \n-fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n-    ebml_w.start_tag(tag_item_trait_method_self_ty);\n+    // Encode info about all the module children.\n+    for md.items.each |item| {\n+        match item.node {\n+            item_impl(*) => {\n+                let (ident, did) = (item.ident, item.id);\n+                debug!(\"(encoding info for module) ... encoding impl %s \\\n+                        (%?/%?)\",\n+                        *ecx.tcx.sess.str_of(ident),\n+                        did,\n+                        ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n+                                                .sess.parse_sess.interner));\n \n-    // Encode the base self type.\n-    match self_type {\n-        sty_static => {\n+                ebml_w.start_tag(tag_mod_impl);\n+                ebml_w.wr_str(def_to_str(local_def(did)));\n+                ebml_w.end_tag();\n+            }\n+            _ => {} // FIXME #4573: Encode these too.\n+        }\n+    }\n+\n+    encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n+\n+    // Encode the reexports of this module.\n+    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    match ecx.reexports2.find(&id) {\n+        Some(ref exports) => {\n+            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            for exports.each |exp| {\n+                debug!(\"(encoding info for module) reexport '%s' for %d\",\n+                       *exp.name, id);\n+                ebml_w.start_tag(tag_items_data_item_reexport);\n+                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                ebml_w.wr_str(def_to_str(exp.def_id));\n+                ebml_w.end_tag();\n+                ebml_w.start_tag(tag_items_data_item_reexport_name);\n+                ebml_w.wr_str(*exp.name);\n+                ebml_w.end_tag();\n+                ebml_w.end_tag();\n+            }\n+        }\n+        None => {\n+            debug!(\"(encoding info for module) found no reexports for %d\",\n+                   id);\n+        }\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_struct_field_family(ebml_w: &writer::Encoder,\n+                              visibility: visibility) {\n+    encode_family(ebml_w, match visibility {\n+        public => 'g',\n+        private => 'j',\n+        inherited => 'N'\n+    });\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n+                              visibility: visibility) {\n+    encode_family(ebml_w, match visibility {\n+        public => 'g',\n+        private => 'j',\n+        inherited => 'N'\n+    });\n+}\n+\n+#[cfg(stage0)]\n+fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n+    ebml_w.start_tag(tag_items_data_item_visibility);\n+    let ch = match visibility {\n+        public => 'y',\n+        private => 'n',\n+        inherited => 'i',\n+    };\n+    ebml_w.wr_str(str::from_char(ch));\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n+    ebml_w.start_tag(tag_items_data_item_visibility);\n+    let ch = match visibility {\n+        public => 'y',\n+        private => 'n',\n+        inherited => 'i',\n+    };\n+    ebml_w.wr_str(str::from_char(ch));\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n+    ebml_w.start_tag(tag_item_trait_method_self_ty);\n+\n+    // Encode the base self type.\n+    match self_type {\n+        sty_static => {\n+            ebml_w.writer.write(&[ 's' as u8 ]);\n+        }\n+        sty_value => {\n+            ebml_w.writer.write(&[ 'v' as u8 ]);\n+        }\n+        sty_region(_, m) => {\n+            // FIXME(#4846) encode custom lifetime\n+            ebml_w.writer.write(&[ '&' as u8 ]);\n+            encode_mutability(ebml_w, m);\n+        }\n+        sty_box(m) => {\n+            ebml_w.writer.write(&[ '@' as u8 ]);\n+            encode_mutability(ebml_w, m);\n+        }\n+        sty_uniq(m) => {\n+            ebml_w.writer.write(&[ '~' as u8 ]);\n+            encode_mutability(ebml_w, m);\n+        }\n+    }\n+\n+    ebml_w.end_tag();\n+\n+    fn encode_mutability(ebml_w: &writer::Encoder,\n+                         m: ast::mutability) {\n+        match m {\n+            m_imm => {\n+                ebml_w.writer.write(&[ 'i' as u8 ]);\n+            }\n+            m_mutbl => {\n+                ebml_w.writer.write(&[ 'm' as u8 ]);\n+            }\n+            m_const => {\n+                ebml_w.writer.write(&[ 'c' as u8 ]);\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_self_type(ebml_w: &mut writer::Encoder, self_type: ast::self_ty_) {\n+    ebml_w.start_tag(tag_item_trait_method_self_ty);\n+\n+    // Encode the base self type.\n+    match self_type {\n+        sty_static => {\n             ebml_w.writer.write(&[ 's' as u8 ]);\n         }\n         sty_value => {\n@@ -476,17 +946,68 @@ fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n     }\n }\n \n+#[cfg(stage0)]\n fn encode_method_sort(ebml_w: &writer::Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n+    ebml_w.start_tag(tag_item_trait_method_sort);\n+    ebml_w.writer.write(&[ sort as u8 ]);\n+    ebml_w.end_tag();\n+}\n+\n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                         path: &[ast_map::path_elt],\n-                         fields: &[@struct_field],\n-                         global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n+#[cfg(stage0)]\n+fn encode_info_for_struct(ecx: @EncodeContext,\n+                          ebml_w: &writer::Encoder,\n+                          path: &[ast_map::path_elt],\n+                          fields: &[@struct_field],\n+                          global_index: @mut~[entry<int>])\n+                          -> ~[entry<int>] {\n+    /* Each class has its own index, since different classes\n+       may have fields with the same name */\n+    let index = @mut ~[];\n+    let tcx = ecx.tcx;\n+     /* We encode both private and public fields -- need to include\n+        private fields to get the offsets right */\n+    for fields.each |field| {\n+        let (nm, mt, vis) = match field.node.kind {\n+            named_field(nm, mt, vis) => (nm, mt, vis),\n+            unnamed_field => (\n+                special_idents::unnamed_field,\n+                struct_immutable,\n+                inherited\n+            )\n+        };\n+\n+        let id = field.node.id;\n+        index.push(entry {val: id, pos: ebml_w.writer.tell()});\n+        global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n+        ebml_w.start_tag(tag_items_data_item);\n+        debug!(\"encode_info_for_struct: doing %s %d\",\n+               *tcx.sess.str_of(nm), id);\n+        encode_struct_field_family(ebml_w, vis);\n+        encode_name(ecx, ebml_w, nm);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n+        encode_mutability(ebml_w, mt);\n+        encode_def_id(ebml_w, local_def(id));\n+        ebml_w.end_tag();\n+    }\n+    /*bad*/copy *index\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_info_for_struct(ecx: @EncodeContext,\n+                          ebml_w: &mut writer::Encoder,\n+                          path: &[ast_map::path_elt],\n+                          fields: &[@struct_field],\n+                          global_index: @mut ~[entry<int>])\n+                          -> ~[entry<int>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let index = @mut ~[];\n@@ -521,6 +1042,7 @@ fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n }\n \n // This is for encoding info for ctors and dtors\n+#[cfg(stage0)]\n fn encode_info_for_ctor(ecx: @EncodeContext,\n                         ebml_w: &writer::Encoder,\n                         id: node_id,\n@@ -550,6 +1072,37 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_info_for_ctor(ecx: @EncodeContext,\n+                        ebml_w: &mut writer::Encoder,\n+                        id: node_id,\n+                        ident: ident,\n+                        path: &[ast_map::path_elt],\n+                        item: Option<inlined_item>,\n+                        generics: &ast::Generics) {\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_name(ecx, ebml_w, ident);\n+        encode_def_id(ebml_w, local_def(id));\n+        encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        let its_ty = node_id_to_type(ecx.tcx, id);\n+        debug!(\"fn name = %s ty = %s its node id = %d\",\n+               *ecx.tcx.sess.str_of(ident),\n+               ty_to_str(ecx.tcx, its_ty), id);\n+        encode_type(ecx, ebml_w, its_ty);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n+        match item {\n+           Some(it) => {\n+             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n+           }\n+           None => {\n+             encode_symbol(ecx, ebml_w, id);\n+           }\n+        }\n+        ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n                                ebml_w: &writer::Encoder,\n                                path: &[ast_map::path_elt],\n@@ -569,100 +1122,489 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n         encode_symbol(ecx, ebml_w, ctor_id);\n     }\n \n-    ebml_w.end_tag();\n-}\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n+                               ebml_w: &mut writer::Encoder,\n+                               path: &[ast_map::path_elt],\n+                               name: ast::ident,\n+                               ctor_id: node_id,\n+                               index: @mut ~[entry<int>]) {\n+    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n+\n+    ebml_w.start_tag(tag_items_data_item);\n+    encode_def_id(ebml_w, local_def(ctor_id));\n+    encode_family(ebml_w, 'f');\n+    encode_name(ecx, ebml_w, name);\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n+    encode_path(ecx, ebml_w, path, ast_map::path_name(name));\n+\n+    if ecx.item_symbols.contains_key(&ctor_id) {\n+        encode_symbol(ecx, ebml_w, ctor_id);\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_method_ty_fields(ecx: @EncodeContext,\n+                           ebml_w: &writer::Encoder,\n+                           method_ty: &ty::method) {\n+    encode_def_id(ebml_w, method_ty.def_id);\n+    encode_name(ecx, ebml_w, method_ty.ident);\n+    encode_ty_type_param_defs(ebml_w, ecx,\n+                              method_ty.generics.type_param_defs,\n+                              tag_item_method_tps);\n+    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n+    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n+    encode_visibility(ebml_w, method_ty.vis);\n+    encode_self_type(ebml_w, method_ty.self_ty);\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_method_ty_fields(ecx: @EncodeContext,\n+                           ebml_w: &mut writer::Encoder,\n+                           method_ty: &ty::method) {\n+    encode_def_id(ebml_w, method_ty.def_id);\n+    encode_name(ecx, ebml_w, method_ty.ident);\n+    encode_ty_type_param_defs(ebml_w, ecx,\n+                              method_ty.generics.type_param_defs,\n+                              tag_item_method_tps);\n+    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n+    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n+    encode_visibility(ebml_w, method_ty.vis);\n+    encode_self_type(ebml_w, method_ty.self_ty);\n+}\n+\n+#[cfg(stage0)]\n+fn encode_info_for_method(ecx: @EncodeContext,\n+                          ebml_w: &writer::Encoder,\n+                          impl_path: &[ast_map::path_elt],\n+                          should_inline: bool,\n+                          parent_id: node_id,\n+                          m: @method,\n+                          owner_generics: &ast::Generics,\n+                          method_generics: &ast::Generics) {\n+    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n+           *ecx.tcx.sess.str_of(m.ident),\n+           owner_generics.ty_params.len(),\n+           method_generics.ty_params.len());\n+    ebml_w.start_tag(tag_items_data_item);\n+\n+    let method_def_id = local_def(m.id);\n+    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n+    encode_method_ty_fields(ecx, ebml_w, method_ty);\n+\n+    match m.self_ty.node {\n+        ast::sty_static => {\n+            encode_family(ebml_w, purity_static_method_family(m.purity));\n+        }\n+        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n+    }\n+\n+    let mut combined_ty_params = opt_vec::Empty;\n+    combined_ty_params.push_all(&owner_generics.ty_params);\n+    combined_ty_params.push_all(&method_generics.ty_params);\n+    let len = combined_ty_params.len();\n+    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n+\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n+    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n+\n+    if len > 0u || should_inline {\n+        (ecx.encode_inlined_item)(\n+           ecx, ebml_w, impl_path,\n+           ii_method(local_def(parent_id), m));\n+    } else {\n+        encode_symbol(ecx, ebml_w, m.id);\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_info_for_method(ecx: @EncodeContext,\n+                          ebml_w: &mut writer::Encoder,\n+                          impl_path: &[ast_map::path_elt],\n+                          should_inline: bool,\n+                          parent_id: node_id,\n+                          m: @method,\n+                          owner_generics: &ast::Generics,\n+                          method_generics: &ast::Generics) {\n+    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n+           *ecx.tcx.sess.str_of(m.ident),\n+           owner_generics.ty_params.len(),\n+           method_generics.ty_params.len());\n+    ebml_w.start_tag(tag_items_data_item);\n+\n+    let method_def_id = local_def(m.id);\n+    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n+    encode_method_ty_fields(ecx, ebml_w, method_ty);\n+\n+    match m.self_ty.node {\n+        ast::sty_static => {\n+            encode_family(ebml_w, purity_static_method_family(m.purity));\n+        }\n+        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n+    }\n+\n+    let mut combined_ty_params = opt_vec::Empty;\n+    combined_ty_params.push_all(&owner_generics.ty_params);\n+    combined_ty_params.push_all(&method_generics.ty_params);\n+    let len = combined_ty_params.len();\n+    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n+\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n+    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n+\n+    if len > 0u || should_inline {\n+        (ecx.encode_inlined_item)(\n+           ecx, ebml_w, impl_path,\n+           ii_method(local_def(parent_id), m));\n+    } else {\n+        encode_symbol(ecx, ebml_w, m.id);\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n+fn purity_fn_family(p: purity) -> char {\n+    match p {\n+      unsafe_fn => 'u',\n+      pure_fn => 'p',\n+      impure_fn => 'f',\n+      extern_fn => 'e'\n+    }\n+}\n+\n+fn purity_static_method_family(p: purity) -> char {\n+    match p {\n+      unsafe_fn => 'U',\n+      pure_fn => 'P',\n+      impure_fn => 'F',\n+      _ => fail!(~\"extern fn can't be static\")\n+    }\n+}\n+\n+\n+fn should_inline(attrs: &[attribute]) -> bool {\n+    match attr::find_inline_attr(attrs) {\n+        attr::ia_none | attr::ia_never  => false,\n+        attr::ia_hint | attr::ia_always => true\n+    }\n+}\n+\n+#[cfg(stage0)]\n+fn encode_info_for_item(ecx: @EncodeContext,\n+                        ebml_w: &writer::Encoder,\n+                        item: @item,\n+                        index: @mut ~[entry<int>],\n+                        path: &[ast_map::path_elt]) {\n+    let tcx = ecx.tcx;\n+    let must_write =\n+        match item.node {\n+          item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n+          item_mod(*) | item_foreign_mod(*) | item_const(*) => true,\n+          _ => false\n+        };\n+    if !must_write && !reachable(ecx, item.id) { return; }\n+\n+    fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n+                     index: @mut ~[entry<int>]) {\n+        index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n+    }\n+    let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n+\n+    debug!(\"encoding info for item at %s\",\n+           ecx.tcx.sess.codemap.span_to_str(item.span));\n+\n+    match item.node {\n+      item_const(_, _) => {\n+        add_to_index();\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'c');\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_symbol(ecx, ebml_w, item.id);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        ebml_w.end_tag();\n+      }\n+      item_fn(_, purity, _, ref generics, _) => {\n+        add_to_index();\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, purity_fn_family(purity));\n+        let tps_len = generics.ty_params.len();\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_attributes(ebml_w, item.attrs);\n+        if tps_len > 0u || should_inline(item.attrs) {\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        } else {\n+            encode_symbol(ecx, ebml_w, item.id);\n+        }\n+        ebml_w.end_tag();\n+      }\n+      item_mod(ref m) => {\n+        add_to_index();\n+        encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n+      }\n+      item_foreign_mod(_) => {\n+        add_to_index();\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'n');\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        ebml_w.end_tag();\n+      }\n+      item_ty(_, ref generics) => {\n+        add_to_index();\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'y');\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ecx, ebml_w, item);\n+        ebml_w.end_tag();\n+      }\n+      item_enum(ref enum_definition, ref generics) => {\n+        add_to_index();\n+        do ebml_w.wr_tag(tag_items_data_item) {\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_family(ebml_w, 't');\n+            encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+            encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+            encode_name(ecx, ebml_w, item.ident);\n+            for (*enum_definition).variants.each |v| {\n+                encode_variant_id(ebml_w, local_def(v.node.id));\n+            }\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+            encode_region_param(ecx, ebml_w, item);\n+        }\n+        encode_enum_variant_info(ecx,\n+                                 ebml_w,\n+                                 item.id,\n+                                 (*enum_definition).variants,\n+                                 path,\n+                                 index,\n+                                 generics);\n+      }\n+      item_struct(struct_def, ref generics) => {\n+        /* First, encode the fields\n+           These come first because we need to write them to make\n+           the index, and the index needs to be in the item for the\n+           class itself */\n+        let idx = encode_info_for_struct(ecx, ebml_w, path,\n+                                         struct_def.fields, index);\n+\n+        /* Index the class*/\n+        add_to_index();\n+\n+        /* Now, make an item for the class itself */\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'S');\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+\n+        // If this is a tuple- or enum-like struct, encode the type of the\n+        // constructor.\n+        if struct_def.fields.len() > 0 &&\n+                struct_def.fields[0].node.kind == ast::unnamed_field {\n+            let ctor_id = match struct_def.ctor_id {\n+                Some(ctor_id) => ctor_id,\n+                None => ecx.tcx.sess.bug(~\"struct def didn't have ctor id\"),\n+            };\n+\n+            encode_info_for_struct_ctor(ecx,\n+                                        ebml_w,\n+                                        path,\n+                                        item.ident,\n+                                        ctor_id,\n+                                        index);\n+        }\n+\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ecx, ebml_w, item);\n+\n+        /* Encode def_ids for each field and method\n+         for methods, write all the stuff get_trait_method\n+        needs to know*/\n+        for struct_def.fields.each |f| {\n+            match f.node.kind {\n+                named_field(ident, _, vis) => {\n+                   ebml_w.start_tag(tag_item_field);\n+                   encode_struct_field_family(ebml_w, vis);\n+                   encode_name(ecx, ebml_w, ident);\n+                   encode_def_id(ebml_w, local_def(f.node.id));\n+                   ebml_w.end_tag();\n+                }\n+                unnamed_field => {\n+                    ebml_w.start_tag(tag_item_unnamed_field);\n+                    encode_def_id(ebml_w, local_def(f.node.id));\n+                    ebml_w.end_tag();\n+                }\n+            }\n+        }\n+\n+        /* Each class has its own index -- encode it */\n+        let bkts = create_index(idx);\n+        encode_index(ebml_w, bkts, write_int);\n+        ebml_w.end_tag();\n+      }\n+      item_impl(ref generics, opt_trait, ty, ref methods) => {\n+        add_to_index();\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'i');\n+        encode_region_param(ecx, ebml_w, item);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_attributes(ebml_w, item.attrs);\n+        match ty.node {\n+            ast::ty_path(path, _) if path.idents.len() == 1 => {\n+                encode_impl_type_basename(ecx, ebml_w,\n+                                          ast_util::path_to_ident(path));\n+            }\n+            _ => {}\n+        }\n+        for methods.each |m| {\n+            ebml_w.start_tag(tag_item_impl_method);\n+            let method_def_id = local_def(m.id);\n+            ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n+            ebml_w.end_tag();\n+        }\n+        for opt_trait.each |ast_trait_ref| {\n+            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n+        }\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        ebml_w.end_tag();\n+\n+        // >:-<\n+        let mut impl_path = vec::append(~[], path);\n+        impl_path += ~[ast_map::path_name(item.ident)];\n+\n+        for methods.each |m| {\n+            index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n+            encode_info_for_method(ecx,\n+                                   ebml_w,\n+                                   impl_path,\n+                                   should_inline(m.attrs),\n+                                   item.id,\n+                                   *m,\n+                                   generics,\n+                                   &m.generics);\n+        }\n+      }\n+      item_trait(ref generics, ref super_traits, ref ms) => {\n+        add_to_index();\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'I');\n+        encode_region_param(ecx, ebml_w, item);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        let trait_def = ty::lookup_trait_def(tcx, local_def(item.id));\n+        encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_attributes(ebml_w, item.attrs);\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n+            ebml_w.start_tag(tag_item_trait_method);\n+            encode_def_id(ebml_w, method_def_id);\n+            ebml_w.end_tag();\n+        }\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        for super_traits.each |ast_trait_ref| {\n+            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n+        }\n+        ebml_w.end_tag();\n+\n+        // Now output the method info for each method.\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n+            assert!(method_def_id.crate == ast::local_crate);\n \n-fn encode_method_ty_fields(ecx: @EncodeContext,\n-                           ebml_w: &writer::Encoder,\n-                           method_ty: &ty::method)\n-{\n-    encode_def_id(ebml_w, method_ty.def_id);\n-    encode_name(ecx, ebml_w, method_ty.ident);\n-    encode_ty_type_param_defs(ebml_w, ecx,\n-                              method_ty.generics.type_param_defs,\n-                              tag_item_method_tps);\n-    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n-    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n-    encode_visibility(ebml_w, method_ty.vis);\n-    encode_self_type(ebml_w, method_ty.self_ty);\n-}\n+            let method_ty: @ty::method = ty::method(tcx, method_def_id);\n \n-fn encode_info_for_method(ecx: @EncodeContext,\n-                          ebml_w: &writer::Encoder,\n-                          impl_path: &[ast_map::path_elt],\n-                          should_inline: bool,\n-                          parent_id: node_id,\n-                          m: @method,\n-                          owner_generics: &ast::Generics,\n-                          method_generics: &ast::Generics) {\n-    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident),\n-           owner_generics.ty_params.len(),\n-           method_generics.ty_params.len());\n-    ebml_w.start_tag(tag_items_data_item);\n+            index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n \n-    let method_def_id = local_def(m.id);\n-    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n-    encode_method_ty_fields(ecx, ebml_w, method_ty);\n+            ebml_w.start_tag(tag_items_data_item);\n \n-    match m.self_ty.node {\n-        ast::sty_static => {\n-            encode_family(ebml_w, purity_static_method_family(m.purity));\n-        }\n-        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n-    }\n+            encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n-    let mut combined_ty_params = opt_vec::Empty;\n-    combined_ty_params.push_all(&owner_generics.ty_params);\n-    combined_ty_params.push_all(&method_generics.ty_params);\n-    let len = combined_ty_params.len();\n-    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n+            encode_parent_item(ebml_w, local_def(item.id));\n \n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n-    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n+            let mut trait_path = vec::append(~[], path);\n+            trait_path.push(ast_map::path_name(item.ident));\n+            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n \n-    if len > 0u || should_inline {\n-        (ecx.encode_inlined_item)(\n-           ecx, ebml_w, impl_path,\n-           ii_method(local_def(parent_id), m));\n-    } else {\n-        encode_symbol(ecx, ebml_w, m.id);\n-    }\n+            match method_ty.self_ty {\n+                sty_static => {\n+                    encode_family(ebml_w,\n+                                  purity_static_method_family(\n+                                      method_ty.fty.purity));\n \n-    ebml_w.end_tag();\n-}\n+                    let tpt = ty::lookup_item_type(tcx, method_def_id);\n+                    encode_ty_type_param_defs(ebml_w, ecx,\n+                                              tpt.generics.type_param_defs,\n+                                              tag_items_data_item_ty_param_bounds);\n+                    encode_type(ecx, ebml_w, tpt.ty);\n+                }\n \n-fn purity_fn_family(p: purity) -> char {\n-    match p {\n-      unsafe_fn => 'u',\n-      pure_fn => 'p',\n-      impure_fn => 'f',\n-      extern_fn => 'e'\n-    }\n-}\n+                _ => {\n+                    encode_family(ebml_w,\n+                                  purity_fn_family(\n+                                      method_ty.fty.purity));\n+                }\n+            }\n \n-fn purity_static_method_family(p: purity) -> char {\n-    match p {\n-      unsafe_fn => 'U',\n-      pure_fn => 'P',\n-      impure_fn => 'F',\n-      _ => fail!(~\"extern fn can't be static\")\n-    }\n-}\n+            match ms[i] {\n+                required(_) => {\n+                    encode_method_sort(ebml_w, 'r');\n+                }\n \n+                provided(m) => {\n+                    // This is obviously a bogus assert but I don't think this\n+                    // ever worked before anyhow...near as I can tell, before\n+                    // we would emit two items.\n+                    if method_ty.self_ty == sty_static {\n+                        tcx.sess.span_unimpl(\n+                            item.span,\n+                            fmt!(\"Method %s is both provided and static\",\n+                                 *tcx.sess.intr().get(method_ty.ident)));\n+                    }\n+                    encode_type_param_bounds(ebml_w, ecx,\n+                                             &m.generics.ty_params);\n+                    encode_method_sort(ebml_w, 'p');\n+                    (ecx.encode_inlined_item)(\n+                        ecx, ebml_w, path,\n+                        ii_method(local_def(item.id), m));\n+                }\n+            }\n \n-fn should_inline(attrs: &[attribute]) -> bool {\n-    match attr::find_inline_attr(attrs) {\n-        attr::ia_none | attr::ia_never  => false,\n-        attr::ia_hint | attr::ia_always => true\n+            ebml_w.end_tag();\n+        }\n+      }\n+      item_mac(*) => fail!(~\"item macros unimplemented\")\n     }\n }\n \n-\n-fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                        item: @item, index: @mut ~[entry<int>],\n+#[cfg(not(stage0))]\n+fn encode_info_for_item(ecx: @EncodeContext,\n+                        ebml_w: &mut writer::Encoder,\n+                        item: @item,\n+                        index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n-\n     let tcx = ecx.tcx;\n     let must_write =\n         match item.node {\n@@ -737,19 +1679,21 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n       }\n       item_enum(ref enum_definition, ref generics) => {\n         add_to_index();\n-        do ebml_w.wr_tag(tag_items_data_item) {\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-            encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-            encode_name(ecx, ebml_w, item.ident);\n-            for (*enum_definition).variants.each |v| {\n-                encode_variant_id(ebml_w, local_def(v.node.id));\n-            }\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n-            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-            encode_region_param(ecx, ebml_w, item);\n+\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 't');\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n+        for (*enum_definition).variants.each |v| {\n+            encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ecx, ebml_w, item);\n+        ebml_w.end_tag();\n+\n         encode_enum_variant_info(ecx,\n                                  ebml_w,\n                                  item.id,\n@@ -960,6 +1904,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     }\n }\n \n+#[cfg(stage0)]\n fn encode_info_for_foreign_item(ecx: @EncodeContext,\n                                 ebml_w: &writer::Encoder,\n                                 nitem: @foreign_item,\n@@ -994,8 +1939,46 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                         crate: &crate) -> ~[entry<int>] {\n+#[cfg(not(stage0))]\n+fn encode_info_for_foreign_item(ecx: @EncodeContext,\n+                                ebml_w: &mut writer::Encoder,\n+                                nitem: @foreign_item,\n+                                index: @mut ~[entry<int>],\n+                                path: ast_map::path,\n+                                abi: AbiSet) {\n+    if !reachable(ecx, nitem.id) { return; }\n+    index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n+\n+    ebml_w.start_tag(tag_items_data_item);\n+    match nitem.node {\n+      foreign_item_fn(_, purity, ref generics) => {\n+        encode_def_id(ebml_w, local_def(nitem.id));\n+        encode_family(ebml_w, purity_fn_family(purity));\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        if abi.is_intrinsic() {\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n+        } else {\n+            encode_symbol(ecx, ebml_w, nitem.id);\n+        }\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n+      }\n+      foreign_item_const(*) => {\n+        encode_def_id(ebml_w, local_def(nitem.id));\n+        encode_family(ebml_w, 'c');\n+        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_symbol(ecx, ebml_w, nitem.id);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n+      }\n+    }\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n+fn encode_info_for_items(ecx: @EncodeContext,\n+                         ebml_w: &writer::Encoder,\n+                         crate: &crate)\n+                         -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n@@ -1038,6 +2021,57 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     return /*bad*/copy *index;\n }\n \n+#[cfg(not(stage0))]\n+fn encode_info_for_items(ecx: @EncodeContext,\n+                         ebml_w: &mut writer::Encoder,\n+                         crate: &crate)\n+                         -> ~[entry<int>] {\n+    let index = @mut ~[];\n+    ebml_w.start_tag(tag_items_data);\n+    index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n+    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n+                        crate_node_id, ~[],\n+                        syntax::parse::token::special_idents::invalid);\n+    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n+        visit_expr: |_e, _cx, _v| { },\n+        visit_item: {\n+            let ebml_w = copy *ebml_w;\n+            |i, cx, v| {\n+                visit::visit_item(i, cx, v);\n+                match *ecx.tcx.items.get(&i.id) {\n+                    ast_map::node_item(_, pt) => {\n+                        let mut ebml_w = copy ebml_w;\n+                        encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n+                    }\n+                    _ => fail!(~\"bad item\")\n+                }\n+            }\n+        },\n+        visit_foreign_item: {\n+            let ebml_w = copy *ebml_w;\n+            |ni, cx, v| {\n+                visit::visit_foreign_item(ni, cx, v);\n+                match *ecx.tcx.items.get(&ni.id) {\n+                    ast_map::node_foreign_item(_, abi, _, pt) => {\n+                        let mut ebml_w = copy ebml_w;\n+                        encode_info_for_foreign_item(ecx,\n+                                                     &mut ebml_w,\n+                                                     ni,\n+                                                     index,\n+                                                     /*bad*/copy *pt,\n+                                                     abi);\n+                    }\n+                    // case for separate item and foreign-item tables\n+                    _ => fail!(~\"bad foreign item\")\n+                }\n+            }\n+        },\n+        ..*visit::default_visitor()\n+    }));\n+    ebml_w.end_tag();\n+    return /*bad*/copy *index;\n+}\n+\n \n // Path and definition ID indexing\n \n@@ -1049,15 +2083,47 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n         let h = elt.val.hash() as uint;\n         buckets[h % 256].push(*elt);\n     }\n-\n-    let mut buckets_frozen = ~[];\n-    for buckets.each |bucket| {\n-        buckets_frozen.push(@/*bad*/copy **bucket);\n+\n+    let mut buckets_frozen = ~[];\n+    for buckets.each |bucket| {\n+        buckets_frozen.push(@/*bad*/copy **bucket);\n+    }\n+    return buckets_frozen;\n+}\n+\n+#[cfg(stage0)]\n+fn encode_index<T>(ebml_w: &writer::Encoder,\n+                   buckets: ~[@~[entry<T>]],\n+                   write_fn: &fn(@io::Writer, &T)) {\n+    let writer = ebml_w.writer;\n+    ebml_w.start_tag(tag_index);\n+    let mut bucket_locs: ~[uint] = ~[];\n+    ebml_w.start_tag(tag_index_buckets);\n+    for buckets.each |bucket| {\n+        bucket_locs.push(ebml_w.writer.tell());\n+        ebml_w.start_tag(tag_index_buckets_bucket);\n+        for vec::each(**bucket) |elt| {\n+            ebml_w.start_tag(tag_index_buckets_bucket_elt);\n+            assert!(elt.pos < 0xffff_ffff);\n+            writer.write_be_u32(elt.pos as u32);\n+            write_fn(writer, &elt.val);\n+            ebml_w.end_tag();\n+        }\n+        ebml_w.end_tag();\n+    }\n+    ebml_w.end_tag();\n+    ebml_w.start_tag(tag_index_table);\n+    for bucket_locs.each |pos| {\n+        assert!(*pos < 0xffff_ffff);\n+        writer.write_be_u32(*pos as u32);\n     }\n-    return buckets_frozen;\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n }\n \n-fn encode_index<T>(ebml_w: &writer::Encoder, buckets: ~[@~[entry<T>]],\n+#[cfg(not(stage0))]\n+fn encode_index<T>(ebml_w: &mut writer::Encoder,\n+                   buckets: ~[@~[entry<T>]],\n                    write_fn: &fn(@io::Writer, &T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -1085,13 +2151,16 @@ fn encode_index<T>(ebml_w: &writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @io::Writer, s: ~str) { writer.write_str(s); }\n+fn write_str(writer: @io::Writer, s: ~str) {\n+    writer.write_str(s);\n+}\n \n fn write_int(writer: @io::Writer, &n: &int) {\n     assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n+#[cfg(stage0)]\n fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n     match mi.node {\n       meta_word(name) => {\n@@ -1129,6 +2198,45 @@ fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n+    match mi.node {\n+      meta_word(name) => {\n+        ebml_w.start_tag(tag_meta_item_word);\n+        ebml_w.start_tag(tag_meta_item_name);\n+        ebml_w.writer.write(str::to_bytes(*name));\n+        ebml_w.end_tag();\n+        ebml_w.end_tag();\n+      }\n+      meta_name_value(name, value) => {\n+        match value.node {\n+          lit_str(value) => {\n+            ebml_w.start_tag(tag_meta_item_name_value);\n+            ebml_w.start_tag(tag_meta_item_name);\n+            ebml_w.writer.write(str::to_bytes(*name));\n+            ebml_w.end_tag();\n+            ebml_w.start_tag(tag_meta_item_value);\n+            ebml_w.writer.write(str::to_bytes(*value));\n+            ebml_w.end_tag();\n+            ebml_w.end_tag();\n+          }\n+          _ => {/* FIXME (#623): encode other variants */ }\n+        }\n+      }\n+      meta_list(name, ref items) => {\n+        ebml_w.start_tag(tag_meta_item_list);\n+        ebml_w.start_tag(tag_meta_item_name);\n+        ebml_w.writer.write(str::to_bytes(*name));\n+        ebml_w.end_tag();\n+        for items.each |inner_item| {\n+            encode_meta_item(ebml_w, *inner_item);\n+        }\n+        ebml_w.end_tag();\n+      }\n+    }\n+}\n+\n+#[cfg(stage0)]\n fn encode_attributes(ebml_w: &writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n@@ -1139,6 +2247,17 @@ fn encode_attributes(ebml_w: &writer::Encoder, attrs: &[attribute]) {\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n+    ebml_w.start_tag(tag_attributes);\n+    for attrs.each |attr| {\n+        ebml_w.start_tag(tag_attribute);\n+        encode_meta_item(ebml_w, attr.node.value);\n+        ebml_w.end_tag();\n+    }\n+    ebml_w.end_tag();\n+}\n+\n // So there's a special crate attribute called 'link' which defines the\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n@@ -1193,6 +2312,7 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     return attrs;\n }\n \n+#[cfg(stage0)]\n fn encode_crate_deps(ecx: @EncodeContext,\n                      ebml_w: &writer::Encoder,\n                      cstore: @mut cstore::CStore) {\n@@ -1235,6 +2355,50 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_crate_deps(ecx: @EncodeContext,\n+                     ebml_w: &mut writer::Encoder,\n+                     cstore: @mut cstore::CStore) {\n+    fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n+                     -> ~[decoder::crate_dep] {\n+        type numdep = decoder::crate_dep;\n+\n+        // Pull the cnums and name,vers,hash out of cstore\n+        let mut deps = ~[];\n+        do cstore::iter_crate_data(cstore) |key, val| {\n+            let dep = decoder::crate_dep {cnum: key,\n+                       name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n+                       vers: decoder::get_crate_vers(val.data),\n+                       hash: decoder::get_crate_hash(val.data)};\n+            deps.push(dep);\n+        };\n+\n+        // Sort by cnum\n+        std::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n+\n+        // Sanity-check the crate numbers\n+        let mut expected_cnum = 1;\n+        for deps.each |n| {\n+            assert!((n.cnum == expected_cnum));\n+            expected_cnum += 1;\n+        }\n+\n+        // mut -> immutable hack for vec::map\n+        deps.slice(0, deps.len()).to_owned()\n+    }\n+\n+    // We're just going to write a list of crate 'name-hash-version's, with\n+    // the assumption that they are numbered 1 to n.\n+    // FIXME (#2166): This is not nearly enough to support correct versioning\n+    // but is enough to get transitive crate dependencies working.\n+    ebml_w.start_tag(tag_crate_deps);\n+    for get_ordered_deps(ecx, cstore).each |dep| {\n+        encode_crate_dep(ecx, ebml_w, *dep);\n+    }\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n@@ -1259,8 +2423,47 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_link_args(ecx: @EncodeContext,\n-                    ebml_w: &writer::Encoder) {\n+#[cfg(not(stage0))]\n+fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n+    ebml_w.start_tag(tag_lang_items);\n+\n+    for ecx.tcx.lang_items.each_item |def_id, i| {\n+        if def_id.crate != local_crate {\n+            loop;\n+        }\n+\n+        ebml_w.start_tag(tag_lang_items_item);\n+\n+        ebml_w.start_tag(tag_lang_items_item_id);\n+        ebml_w.writer.write_be_u32(i as u32);\n+        ebml_w.end_tag();   // tag_lang_items_item_id\n+\n+        ebml_w.start_tag(tag_lang_items_item_node_id);\n+        ebml_w.writer.write_be_u32(def_id.node as u32);\n+        ebml_w.end_tag();   // tag_lang_items_item_node_id\n+\n+        ebml_w.end_tag();   // tag_lang_items_item\n+    }\n+\n+    ebml_w.end_tag();   // tag_lang_items\n+}\n+\n+#[cfg(stage0)]\n+fn encode_link_args(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n+    ebml_w.start_tag(tag_link_args);\n+\n+    let link_args = cstore::get_used_link_args(ecx.cstore);\n+    for link_args.each |link_arg| {\n+        ebml_w.start_tag(tag_link_args_arg);\n+        ebml_w.writer.write_str(link_arg.to_str());\n+        ebml_w.end_tag();\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n@@ -1273,7 +2476,26 @@ fn encode_link_args(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+#[cfg(stage0)]\n+fn encode_crate_dep(ecx: @EncodeContext,\n+                    ebml_w: &writer::Encoder,\n+                    dep: decoder::crate_dep) {\n+    ebml_w.start_tag(tag_crate_dep);\n+    ebml_w.start_tag(tag_crate_dep_name);\n+    ebml_w.writer.write(str::to_bytes(*ecx.tcx.sess.str_of(dep.name)));\n+    ebml_w.end_tag();\n+    ebml_w.start_tag(tag_crate_dep_vers);\n+    ebml_w.writer.write(str::to_bytes(*dep.vers));\n+    ebml_w.end_tag();\n+    ebml_w.start_tag(tag_crate_dep_hash);\n+    ebml_w.writer.write(str::to_bytes(*dep.hash));\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(not(stage0))]\n+fn encode_crate_dep(ecx: @EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1288,12 +2510,20 @@ fn encode_crate_dep(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     ebml_w.end_tag();\n }\n \n+#[cfg(stage0)]\n fn encode_hash(ebml_w: &writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n }\n \n+#[cfg(not(stage0))]\n+fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n+    ebml_w.start_tag(tag_crate_hash);\n+    ebml_w.writer.write(str::to_bytes(hash));\n+    ebml_w.end_tag();\n+}\n+\n // NB: Increment this as you change the metadata encoding version.\n pub static metadata_encoding_version : &'static [u8] =\n     &[0x72, //'r' as u8,\n@@ -1302,6 +2532,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n+#[cfg(stage0)]\n pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let stats = Stats {\n@@ -1408,6 +2639,113 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     }) + flate::deflate_bytes(wr.bytes)\n }\n \n+#[cfg(not(stage0))]\n+pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n+    let wr = @io::BytesWriter();\n+    let stats = Stats {\n+        inline_bytes: 0,\n+        attr_bytes: 0,\n+        dep_bytes: 0,\n+        lang_item_bytes: 0,\n+        link_args_bytes: 0,\n+        item_bytes: 0,\n+        index_bytes: 0,\n+        zero_bytes: 0,\n+        total_bytes: 0,\n+        n_inlines: 0\n+    };\n+    let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n+                     discrim_symbols, cstore, encode_inlined_item,\n+                     link_meta, _} = parms;\n+    let ecx = @EncodeContext {\n+        diag: diag,\n+        tcx: tcx,\n+        stats: @mut stats,\n+        reachable: reachable,\n+        reexports2: reexports2,\n+        item_symbols: item_symbols,\n+        discrim_symbols: discrim_symbols,\n+        link_meta: link_meta,\n+        cstore: cstore,\n+        encode_inlined_item: encode_inlined_item,\n+        type_abbrevs: @mut HashMap::new()\n+     };\n+\n+    let mut ebml_w = writer::Encoder(wr as @io::Writer);\n+\n+    encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n+\n+    let mut i = wr.pos;\n+    let crate_attrs = synthesize_crate_attrs(ecx, crate);\n+    encode_attributes(&mut ebml_w, crate_attrs);\n+    ecx.stats.attr_bytes = wr.pos - i;\n+\n+    i = wr.pos;\n+    encode_crate_deps(ecx, &mut ebml_w, ecx.cstore);\n+    ecx.stats.dep_bytes = wr.pos - i;\n+\n+    // Encode the language items.\n+    i = wr.pos;\n+    encode_lang_items(ecx, &mut ebml_w);\n+    ecx.stats.lang_item_bytes = wr.pos - i;\n+\n+    // Encode the link args.\n+    i = wr.pos;\n+    encode_link_args(ecx, &mut ebml_w);\n+    ecx.stats.link_args_bytes = wr.pos - i;\n+\n+    // Encode and index the items.\n+    ebml_w.start_tag(tag_items);\n+    i = wr.pos;\n+    let items_index = encode_info_for_items(ecx, &mut ebml_w, crate);\n+    ecx.stats.item_bytes = wr.pos - i;\n+\n+    i = wr.pos;\n+    let items_buckets = create_index(items_index);\n+    encode_index(&mut ebml_w, items_buckets, write_int);\n+    ecx.stats.index_bytes = wr.pos - i;\n+    ebml_w.end_tag();\n+\n+    ecx.stats.total_bytes = wr.pos;\n+\n+    if (tcx.sess.meta_stats()) {\n+\n+        do wr.bytes.each |e| {\n+            if *e == 0 {\n+                ecx.stats.zero_bytes += 1;\n+            }\n+            true\n+        }\n+\n+        io::println(\"metadata stats:\");\n+        io::println(fmt!(\"    inline bytes: %u\", ecx.stats.inline_bytes));\n+        io::println(fmt!(\" attribute bytes: %u\", ecx.stats.attr_bytes));\n+        io::println(fmt!(\"       dep bytes: %u\", ecx.stats.dep_bytes));\n+        io::println(fmt!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes));\n+        io::println(fmt!(\" link args bytes: %u\", ecx.stats.link_args_bytes));\n+        io::println(fmt!(\"      item bytes: %u\", ecx.stats.item_bytes));\n+        io::println(fmt!(\"     index bytes: %u\", ecx.stats.index_bytes));\n+        io::println(fmt!(\"      zero bytes: %u\", ecx.stats.zero_bytes));\n+        io::println(fmt!(\"     total bytes: %u\", ecx.stats.total_bytes));\n+    }\n+\n+    // Pad this, since something (LLVM, presumably) is cutting off the\n+    // remaining % 4 bytes.\n+    wr.write(&[0u8, 0u8, 0u8, 0u8]);\n+\n+    // FIXME #3396: weird bug here, for reasons unclear this emits random\n+    // looking bytes (mostly 0x1) if we use the version byte-array constant\n+    // above; so we use a string constant inline instead.\n+    //\n+    // Should be:\n+    //\n+    //   vec::from_slice(metadata_encoding_version) +\n+\n+    (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n+        vec::slice(*bytes, 0, 8).to_vec()\n+    }) + flate::deflate_bytes(wr.bytes)\n+}\n+\n // Get the encoded string for a type\n pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n     let cx = @tyencode::ctxt {"}, {"sha": "2a9f19fc8469551297c7b1447158ba1fd8d5dab0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 795, "deletions": 93, "changes": 888, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -77,6 +77,7 @@ trait tr_intern {\n // ______________________________________________________________________\n // Top-level methods.\n \n+#[cfg(stage0)]\n pub fn encode_inlined_item(ecx: @e::EncodeContext,\n                            ebml_w: &writer::Encoder,\n                            path: &[ast_map::path_elt],\n@@ -100,6 +101,32 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n+#[cfg(not(stage0))]\n+pub fn encode_inlined_item(ecx: @e::EncodeContext,\n+                           ebml_w: &mut writer::Encoder,\n+                           path: &[ast_map::path_elt],\n+                           ii: ast::inlined_item,\n+                           maps: Maps) {\n+    debug!(\"> Encoding inlined item: %s::%s (%u)\",\n+           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n+           *ecx.tcx.sess.str_of(ii.ident()),\n+           ebml_w.writer.tell());\n+\n+    let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n+\n+    ebml_w.start_tag(c::tag_ast as uint);\n+    id_range.encode(ebml_w);\n+    encode_ast(ebml_w, simplify_ast(&ii));\n+    encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n+    ebml_w.end_tag();\n+\n+    debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n+           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n+           *ecx.tcx.sess.str_of(ii.ident()),\n+           ebml_w.writer.tell());\n+}\n+\n+#[cfg(stage0)]\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n@@ -145,6 +172,52 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n+                           tcx: ty::ctxt,\n+                           maps: Maps,\n+                           path: ast_map::path,\n+                           par_doc: ebml::Doc)\n+                        -> Option<ast::inlined_item> {\n+    let dcx = @DecodeContext {\n+        cdata: cdata,\n+        tcx: tcx,\n+        maps: maps\n+    };\n+    match par_doc.opt_child(c::tag_ast) {\n+      None => None,\n+      Some(ast_doc) => {\n+        debug!(\"> Decoding inlined fn: %s::?\",\n+               ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n+        let mut ast_dsr = reader::Decoder(ast_doc);\n+        let from_id_range = Decodable::decode(&mut ast_dsr);\n+        let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n+        let xcx = @ExtendedDecodeContext {\n+            dcx: dcx,\n+            from_id_range: from_id_range,\n+            to_id_range: to_id_range\n+        };\n+        let raw_ii = decode_ast(ast_doc);\n+        let ii = renumber_ast(xcx, raw_ii);\n+        debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n+        debug!(\"< Decoded inlined fn: %s::%s\",\n+               ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n+               *tcx.sess.str_of(ii.ident()));\n+        ast_map::map_decoded_item(tcx.sess.diagnostic(),\n+                                  dcx.tcx.items, path, &ii);\n+        decode_side_tables(xcx, ast_doc);\n+        match ii {\n+          ast::ii_item(i) => {\n+            debug!(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n+                   syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n+          }\n+          _ => { }\n+        }\n+        Some(ii)\n+      }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n@@ -236,28 +309,56 @@ impl tr for span {\n     }\n }\n \n+#[cfg(stage0)]\n trait def_id_encoder_helpers {\n     fn emit_def_id(&self, did: ast::def_id);\n }\n \n+#[cfg(not(stage0))]\n+trait def_id_encoder_helpers {\n+    fn emit_def_id(&mut self, did: ast::def_id);\n+}\n+\n+#[cfg(stage0)]\n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n     fn emit_def_id(&self, did: ast::def_id) {\n         did.encode(self)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n+    fn emit_def_id(&mut self, did: ast::def_id) {\n+        did.encode(self)\n+    }\n+}\n+\n+#[cfg(stage0)]\n trait def_id_decoder_helpers {\n     fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n-impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n+#[cfg(not(stage0))]\n+trait def_id_decoder_helpers {\n+    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n+}\n \n+#[cfg(stage0)]\n+impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n     fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n         let did: ast::def_id = Decodable::decode(self);\n         did.tr(xcx)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n+    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+        let did: ast::def_id = Decodable::decode(self);\n+        did.tr(xcx)\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding the AST itself\n //\n@@ -273,12 +374,20 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n+#[cfg(stage0)]\n fn encode_ast(ebml_w: &writer::Encoder, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         item.encode(ebml_w)\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n+    ebml_w.start_tag(c::tag_tree as uint);\n+    item.encode(ebml_w);\n+    ebml_w.end_tag();\n+}\n+\n // Produces a simplified copy of the AST which does not include things\n // that we do not need to or do not want to export.  For example, we\n // do not include any nested items: if these nested items are to be\n@@ -330,12 +439,20 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     }\n }\n \n+#[cfg(stage0)]\n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let d = &reader::Decoder(chi_doc);\n     Decodable::decode(d)\n }\n \n+#[cfg(not(stage0))]\n+fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n+    let chi_doc = par_doc.get(c::tag_tree as uint);\n+    let mut d = reader::Decoder(chi_doc);\n+    Decodable::decode(&mut d)\n+}\n+\n fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     -> ast::inlined_item {\n     let fld = fold::make_fold(@fold::AstFoldFns{\n@@ -360,16 +477,30 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n+#[cfg(stage0)]\n fn encode_def(ebml_w: &writer::Encoder, def: ast::def) {\n     def.encode(ebml_w)\n }\n \n+#[cfg(not(stage0))]\n+fn encode_def(ebml_w: &mut writer::Encoder, def: ast::def) {\n+    def.encode(ebml_w)\n+}\n+\n+#[cfg(stage0)]\n fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n     let dsr = &reader::Decoder(doc);\n     let def: ast::def = Decodable::decode(dsr);\n     def.tr(xcx)\n }\n \n+#[cfg(not(stage0))]\n+fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n+    let mut dsr = reader::Decoder(doc);\n+    let def: ast::def = Decodable::decode(&mut dsr);\n+    def.tr(xcx)\n+}\n+\n impl tr for ast::def {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n         match *self {\n@@ -471,18 +602,41 @@ impl tr for ty::bound_region {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n+#[cfg(stage0)]\n fn encode_freevar_entry(ebml_w: &writer::Encoder, fv: @freevar_entry) {\n     (*fv).encode(ebml_w)\n }\n \n+#[cfg(not(stage0))]\n+fn encode_freevar_entry(ebml_w: &mut writer::Encoder, fv: @freevar_entry) {\n+    (*fv).encode(ebml_w)\n+}\n+\n+#[cfg(stage0)]\n trait ebml_decoder_helper {\n     fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n-                         -> freevar_entry;\n+                          -> freevar_entry;\n+}\n+\n+#[cfg(not(stage0))]\n+trait ebml_decoder_helper {\n+    fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                          -> freevar_entry;\n }\n \n+#[cfg(stage0)]\n impl ebml_decoder_helper for reader::Decoder {\n     fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n-                         -> freevar_entry {\n+                          -> freevar_entry {\n+        let fv: freevar_entry = Decodable::decode(self);\n+        fv.tr(xcx)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl ebml_decoder_helper for reader::Decoder {\n+    fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                          -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self);\n         fv.tr(xcx)\n     }\n@@ -500,14 +654,31 @@ impl tr for freevar_entry {\n // ______________________________________________________________________\n // Encoding and decoding of CaptureVar information\n \n+#[cfg(stage0)]\n trait capture_var_helper {\n     fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n-                       -> moves::CaptureVar;\n+                        -> moves::CaptureVar;\n }\n \n+#[cfg(not(stage0))]\n+trait capture_var_helper {\n+    fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n+                        -> moves::CaptureVar;\n+}\n+\n+#[cfg(stage0)]\n impl capture_var_helper for reader::Decoder {\n     fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n-                       -> moves::CaptureVar {\n+                        -> moves::CaptureVar {\n+        let cvar: moves::CaptureVar = Decodable::decode(self);\n+        cvar.tr(xcx)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl capture_var_helper for reader::Decoder {\n+    fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n+                        -> moves::CaptureVar {\n         let cvar: moves::CaptureVar = Decodable::decode(self);\n         cvar.tr(xcx)\n     }\n@@ -527,14 +698,18 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of method_map_entry\n \n trait read_method_map_entry_helper {\n+    #[cfg(stage0)]\n     fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-                            -> method_map_entry;\n+                             -> method_map_entry;\n+    #[cfg(not(stage0))]\n+    fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                             -> method_map_entry;\n }\n \n #[cfg(stage0)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: &writer::Encoder,\n-                              mme: method_map_entry) {\n+                           ebml_w: &writer::Encoder,\n+                           mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n@@ -551,23 +726,21 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: &writer::Encoder,\n-                              mme: method_map_entry) {\n-    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n-        do ebml_w.emit_struct_field(\"self_arg\", 0u) {\n+                           ebml_w: &mut writer::Encoder,\n+                           mme: method_map_entry) {\n+    do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n+        do ebml_w.emit_struct_field(\"self_arg\", 0u) |ebml_w| {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n-        do ebml_w.emit_struct_field(\"explicit_self\", 2u) {\n+        do ebml_w.emit_struct_field(\"explicit_self\", 2u) |ebml_w| {\n             mme.explicit_self.encode(ebml_w);\n         }\n-        do ebml_w.emit_struct_field(\"origin\", 1u) {\n+        do ebml_w.emit_struct_field(\"origin\", 1u) |ebml_w| {\n             mme.origin.encode(ebml_w);\n         }\n-        do ebml_w.emit_struct_field(\"self_mode\", 3) {\n+        do ebml_w.emit_struct_field(\"self_mode\", 3) |ebml_w| {\n             mme.self_mode.encode(ebml_w);\n         }\n     }\n@@ -576,7 +749,7 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n impl read_method_map_entry_helper for reader::Decoder {\n     #[cfg(stage0)]\n     fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-        -> method_map_entry {\n+                             -> method_map_entry {\n         do self.read_struct(\"method_map_entry\", 3) {\n             method_map_entry {\n                 self_arg: self.read_field(~\"self_arg\", 0u, || {\n@@ -599,27 +772,27 @@ impl read_method_map_entry_helper for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-        -> method_map_entry {\n-        do self.read_struct(\"method_map_entry\", 3) {\n+    #[cfg(not(stage0))]\n+    fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                             -> method_map_entry {\n+        do self.read_struct(\"method_map_entry\", 3) |this| {\n             method_map_entry {\n-                self_arg: self.read_struct_field(\"self_arg\", 0u, || {\n-                    self.read_arg(xcx)\n+                self_arg: this.read_struct_field(\"self_arg\", 0, |this| {\n+                    this.read_arg(xcx)\n                 }),\n-                explicit_self: self.read_struct_field(\"explicit_self\", 2, || {\n-                    let self_type: ast::self_ty_ = Decodable::decode(self);\n+                explicit_self: this.read_struct_field(\"explicit_self\",\n+                                                      2,\n+                                                      |this| {\n+                    let self_type: ast::self_ty_ = Decodable::decode(this);\n                     self_type\n                 }),\n-                origin: self.read_struct_field(\"origin\", 1u, || {\n+                origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: method_origin =\n-                        Decodable::decode(self);\n+                        Decodable::decode(this);\n                     method_origin.tr(xcx)\n                 }),\n-                self_mode: self.read_struct_field(\"self_mode\", 3, || {\n-                    let self_mode: ty::SelfMode = Decodable::decode(self);\n+                self_mode: this.read_struct_field(\"self_mode\", 3, |this| {\n+                    let self_mode: ty::SelfMode = Decodable::decode(this);\n                     self_mode\n                 }),\n             }\n@@ -657,6 +830,7 @@ impl tr for method_origin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n+#[cfg(stage0)]\n fn encode_vtable_res(ecx: @e::EncodeContext,\n                      ebml_w: &writer::Encoder,\n                      dr: typeck::vtable_res) {\n@@ -669,6 +843,20 @@ fn encode_vtable_res(ecx: @e::EncodeContext,\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_vtable_res(ecx: @e::EncodeContext,\n+                     ebml_w: &mut writer::Encoder,\n+                     dr: typeck::vtable_res) {\n+    // can't autogenerate this code because automatic code of\n+    // ty::t doesn't work, and there is no way (atm) to have\n+    // hand-written encoding routines combine with auto-generated\n+    // ones.  perhaps we should fix this.\n+    do ebml_w.emit_from_vec(*dr) |ebml_w, vtable_origin| {\n+        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+    }\n+}\n+\n+#[cfg(stage0)]\n fn encode_vtable_origin(ecx: @e::EncodeContext,\n                         ebml_w: &writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n@@ -699,24 +887,72 @@ fn encode_vtable_origin(ecx: @e::EncodeContext,\n           }\n         }\n     }\n+}\n \n+#[cfg(not(stage0))]\n+fn encode_vtable_origin(ecx: @e::EncodeContext,\n+                        ebml_w: &mut writer::Encoder,\n+                        vtable_origin: &typeck::vtable_origin) {\n+    do ebml_w.emit_enum(~\"vtable_origin\") |ebml_w| {\n+        match *vtable_origin {\n+          typeck::vtable_static(def_id, ref tys, vtable_res) => {\n+            do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) |ebml_w| {\n+                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+                    ebml_w.emit_def_id(def_id)\n+                }\n+                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n+                    ebml_w.emit_tys(ecx, /*bad*/copy *tys);\n+                }\n+                do ebml_w.emit_enum_variant_arg(2u) |ebml_w| {\n+                    encode_vtable_res(ecx, ebml_w, vtable_res);\n+                }\n+            }\n+          }\n+          typeck::vtable_param(pn, bn) => {\n+            do ebml_w.emit_enum_variant(~\"vtable_param\", 1u, 2u) |ebml_w| {\n+                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+                    ebml_w.emit_uint(pn);\n+                }\n+                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n+                    ebml_w.emit_uint(bn);\n+                }\n+            }\n+          }\n+        }\n+    }\n }\n \n trait vtable_decoder_helpers {\n+    #[cfg(stage0)]\n     fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res;\n+    #[cfg(not(stage0))]\n+    fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n+                      -> typeck::vtable_res;\n+    #[cfg(stage0)]\n     fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n-        -> typeck::vtable_origin;\n+                          -> typeck::vtable_origin;\n+    #[cfg(not(stage0))]\n+    fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n+                          -> typeck::vtable_origin;\n }\n \n impl vtable_decoder_helpers for reader::Decoder {\n+    #[cfg(stage0)]\n     fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n+        @self.read_to_vec(|| self.read_vtable_origin(xcx))\n     }\n \n+    #[cfg(not(stage0))]\n+    fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n+                      -> typeck::vtable_res {\n+        @self.read_to_vec(|this| this.read_vtable_origin(xcx))\n+    }\n+\n+    #[cfg(stage0)]\n     fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n-        -> typeck::vtable_origin {\n+                          -> typeck::vtable_origin {\n         do self.read_enum(\"vtable_origin\") {\n             do self.read_enum_variant([\"vtable_static\", \"vtable_param\"]) |i| {\n                 match i {\n@@ -749,6 +985,43 @@ impl vtable_decoder_helpers for reader::Decoder {\n             }\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n+        -> typeck::vtable_origin {\n+        do self.read_enum(\"vtable_origin\") |this| {\n+            do this.read_enum_variant([\"vtable_static\", \"vtable_param\"])\n+                    |this, i| {\n+                match i {\n+                  0 => {\n+                    typeck::vtable_static(\n+                        do this.read_enum_variant_arg(0u) |this| {\n+                            this.read_def_id(xcx)\n+                        },\n+                        do this.read_enum_variant_arg(1u) |this| {\n+                            this.read_tys(xcx)\n+                        },\n+                        do this.read_enum_variant_arg(2u) |this| {\n+                            this.read_vtable_res(xcx)\n+                        }\n+                    )\n+                  }\n+                  1 => {\n+                    typeck::vtable_param(\n+                        do this.read_enum_variant_arg(0u) |this| {\n+                            this.read_uint()\n+                        },\n+                        do this.read_enum_variant_arg(1u) |this| {\n+                            this.read_uint()\n+                        }\n+                    )\n+                  }\n+                  // hard to avoid - user input\n+                  _ => fail!(~\"bad enum variant\")\n+                }\n+            }\n+        }\n+    }\n }\n \n // ______________________________________________________________________\n@@ -769,6 +1042,7 @@ impl get_ty_str_ctxt for e::EncodeContext {\n     }\n }\n \n+#[cfg(stage0)]\n trait ebml_writer_helpers {\n     fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg);\n     fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t);\n@@ -781,31 +1055,78 @@ trait ebml_writer_helpers {\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n \n+#[cfg(not(stage0))]\n+trait ebml_writer_helpers {\n+    fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg);\n+    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n+    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore);\n+    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: ~[ty::t]);\n+    fn emit_type_param_def(&mut self,\n+                           ecx: @e::EncodeContext,\n+                           type_param_def: &ty::TypeParameterDef);\n+    fn emit_tpbt(&mut self,\n+                 ecx: @e::EncodeContext,\n+                 tpbt: ty::ty_param_bounds_and_ty);\n+}\n+\n impl ebml_writer_helpers for writer::Encoder {\n+    #[cfg(stage0)]\n     fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t) {\n+        do self.emit_opaque |this| {\n+            e::write_type(ecx, this, ty)\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque {\n             e::write_vstore(ecx, self, vstore)\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n+        do self.emit_opaque |this| {\n+            e::write_vstore(ecx, this, vstore)\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg) {\n         do self.emit_opaque {\n             tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg) {\n+        do self.emit_opaque |this| {\n+            tyencode::enc_arg(this.writer, ecx.ty_str_ctxt(), arg);\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn emit_tys(&self, ecx: @e::EncodeContext, tys: ~[ty::t]) {\n         do self.emit_from_vec(tys) |ty| {\n             self.emit_ty(ecx, *ty)\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: ~[ty::t]) {\n+        do self.emit_from_vec(tys) |this, ty| {\n+            this.emit_ty(ecx, *ty)\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn emit_type_param_def(&self,\n                            ecx: @e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n@@ -815,16 +1136,27 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn emit_type_param_def(&mut self,\n+                           ecx: @e::EncodeContext,\n+                           type_param_def: &ty::TypeParameterDef) {\n+        do self.emit_opaque |this| {\n+            tyencode::enc_type_param_def(this.writer,\n+                                         ecx.ty_str_ctxt(),\n+                                         type_param_def)\n+        }\n+    }\n+\n     #[cfg(stage0)]\n-    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+    fn emit_tpbt(&self,\n+                 ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n             do self.emit_field(~\"generics\", 0) {\n                 do self.emit_struct(\"Generics\", 2) {\n                     do self.emit_field(~\"type_param_defs\", 0) {\n                         do self.emit_from_vec(*tpbt.generics.type_param_defs)\n-                            |type_param_def|\n-                        {\n+                                |type_param_def| {\n                             self.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n@@ -839,38 +1171,44 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+    #[cfg(not(stage0))]\n+    fn emit_tpbt(&mut self,\n+                 ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n-            do self.emit_struct_field(\"generics\", 0) {\n-                do self.emit_struct(\"Generics\", 2) {\n-                    do self.emit_struct_field(\"type_param_defs\", 0) {\n-                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n-                            |type_param_def|\n-                        {\n-                            self.emit_type_param_def(ecx, type_param_def);\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n+            do this.emit_struct_field(~\"generics\", 0) |this| {\n+                do this.emit_struct(\"Generics\", 2) |this| {\n+                    do this.emit_struct_field(~\"type_param_defs\", 0) |this| {\n+                        do this.emit_from_vec(*tpbt.generics.type_param_defs)\n+                                |this, type_param_def| {\n+                            this.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n-                    do self.emit_struct_field(\"region_param\", 1) {\n-                        tpbt.generics.region_param.encode(self);\n+                    do this.emit_struct_field(~\"region_param\", 1) |this| {\n+                        tpbt.generics.region_param.encode(this);\n                     }\n                 }\n             }\n-            do self.emit_struct_field(\"ty\", 1) {\n-                self.emit_ty(ecx, tpbt.ty);\n+            do this.emit_struct_field(~\"ty\", 1) |this| {\n+                this.emit_ty(ecx, tpbt.ty);\n             }\n         }\n     }\n }\n \n+#[cfg(stage0)]\n trait write_tag_and_id {\n     fn tag(&self, tag_id: c::astencode_tag, f: &fn());\n     fn id(&self, id: ast::node_id);\n }\n \n+#[cfg(not(stage0))]\n+trait write_tag_and_id {\n+    fn tag(&mut self, tag_id: c::astencode_tag, f: &fn(&mut Self));\n+    fn id(&mut self, id: ast::node_id);\n+}\n+\n+#[cfg(stage0)]\n impl write_tag_and_id for writer::Encoder {\n     fn tag(&self, tag_id: c::astencode_tag, f: &fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n@@ -881,6 +1219,22 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl write_tag_and_id for writer::Encoder {\n+    fn tag(&mut self,\n+           tag_id: c::astencode_tag,\n+           f: &fn(&mut writer::Encoder)) {\n+        self.start_tag(tag_id as uint);\n+        f(self);\n+        self.end_tag();\n+    }\n+\n+    fn id(&mut self, id: ast::node_id) {\n+        self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n+    }\n+}\n+\n+#[cfg(stage0)]\n fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &writer::Encoder,\n@@ -899,6 +1253,26 @@ fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n+                             maps: Maps,\n+                             ebml_w: &mut writer::Encoder,\n+                             ii: &ast::inlined_item) {\n+    ebml_w.start_tag(c::tag_table as uint);\n+    let new_ebml_w = copy *ebml_w;\n+    ast_util::visit_ids_for_inlined_item(\n+        ii,\n+        |id: ast::node_id| {\n+            // Note: this will cause a copy of ebml_w, which is bad as\n+            // it is mutable. But I believe it's harmless since we generate\n+            // balanced EBML.\n+            let mut new_ebml_w = copy new_ebml_w;\n+            encode_side_tables_for_id(ecx, maps, &mut new_ebml_w, id)\n+        });\n+    ebml_w.end_tag();\n+}\n+\n+#[cfg(stage0)]\n fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &writer::Encoder,\n@@ -1028,6 +1402,136 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n+                             maps: Maps,\n+                             ebml_w: &mut writer::Encoder,\n+                             id: ast::node_id) {\n+    let tcx = ecx.tcx;\n+\n+    debug!(\"Encoding side tables for id %d\", id);\n+\n+    for tcx.def_map.find(&id).each |def| {\n+        do ebml_w.tag(c::tag_table_def) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                (*def).encode(ebml_w)\n+            }\n+        }\n+    }\n+\n+    for tcx.node_types.find(&(id as uint)).each |&ty| {\n+        do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.emit_ty(ecx, *ty);\n+            }\n+        }\n+    }\n+\n+    for tcx.node_type_substs.find(&id).each |tys| {\n+        do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                // FIXME(#5562): removing this copy causes a segfault\n+                //               before stage2\n+                ebml_w.emit_tys(ecx, /*bad*/copy **tys)\n+            }\n+        }\n+    }\n+\n+    for tcx.freevars.find(&id).each |&fv| {\n+        do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n+                    encode_freevar_entry(ebml_w, *fv_entry)\n+                }\n+            }\n+        }\n+    }\n+\n+    let lid = ast::def_id { crate: ast::local_crate, node: id };\n+    for tcx.tcache.find(&lid).each |&tpbt| {\n+        do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.emit_tpbt(ecx, *tpbt);\n+            }\n+        }\n+    }\n+\n+    for tcx.ty_param_defs.find(&id).each |&type_param_def| {\n+        do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.emit_type_param_def(ecx, type_param_def)\n+            }\n+        }\n+    }\n+\n+    if maps.mutbl_map.contains(&id) {\n+        do ebml_w.tag(c::tag_table_mutbl) |ebml_w| {\n+            ebml_w.id(id);\n+        }\n+    }\n+\n+    for maps.last_use_map.find(&id).each |&m| {\n+        do ebml_w.tag(c::tag_table_last_use) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                do ebml_w.emit_from_vec(/*bad*/ copy **m) |ebml_w, id| {\n+                    id.encode(ebml_w);\n+                }\n+            }\n+        }\n+    }\n+\n+    for maps.method_map.find(&id).each |&mme| {\n+        do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                encode_method_map_entry(ecx, ebml_w, *mme)\n+            }\n+        }\n+    }\n+\n+    for maps.vtable_map.find(&id).each |&dr| {\n+        do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                encode_vtable_res(ecx, ebml_w, *dr);\n+            }\n+        }\n+    }\n+\n+    for tcx.adjustments.find(&id).each |adj| {\n+        do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                (**adj).encode(ebml_w)\n+            }\n+        }\n+    }\n+\n+    if maps.moves_map.contains(&id) {\n+        do ebml_w.tag(c::tag_table_moves_map) |ebml_w| {\n+            ebml_w.id(id);\n+        }\n+    }\n+\n+    for maps.capture_map.find(&id).each |&cap_vars| {\n+        do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n+                    cap_var.encode(ebml_w);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n trait doc_decoder_helpers {\n     fn as_int(&self) -> int;\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc>;\n@@ -1040,6 +1544,7 @@ impl doc_decoder_helpers for ebml::Doc {\n     }\n }\n \n+#[cfg(stage0)]\n trait ebml_decoder_decoder_helpers {\n     fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg;\n     fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t;\n@@ -1052,7 +1557,24 @@ trait ebml_decoder_decoder_helpers {\n                       did: ast::def_id) -> ast::def_id;\n }\n \n+#[cfg(not(stage0))]\n+trait ebml_decoder_decoder_helpers {\n+    fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg;\n+    fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n+    fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n+                           -> ty::TypeParameterDef;\n+    fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n+                                -> ty::ty_param_bounds_and_ty;\n+    fn convert_def_id(&mut self,\n+                      xcx: @ExtendedDecodeContext,\n+                      source: DefIdSource,\n+                      did: ast::def_id)\n+                      -> ast::def_id;\n+}\n+\n impl ebml_decoder_decoder_helpers for reader::Decoder {\n+    #[cfg(stage0)]\n     fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg {\n         do self.read_opaque |doc| {\n             tydecode::parse_arg_data(\n@@ -1061,6 +1583,19 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg {\n+        do self.read_opaque |this, doc| {\n+            tydecode::parse_arg_data(\n+                doc.data,\n+                xcx.dcx.cdata.cnum,\n+                doc.start,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a))\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1088,32 +1623,85 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n+        // Note: regions types embed local node ids.  In principle, we\n+        // should translate these node ids into the new decode\n+        // context.  However, we do not bother, because region types\n+        // are not used during trans.\n+\n+        return do self.read_opaque |this, doc| {\n+            let ty = tydecode::parse_ty_data(\n+                doc.data,\n+                xcx.dcx.cdata.cnum,\n+                doc.start,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a));\n+\n+            debug!(\"read_ty(%s) = %s\",\n+                   type_string(doc),\n+                   ty_to_str(xcx.dcx.tcx, ty));\n+\n+            ty\n+        };\n+\n+        fn type_string(doc: ebml::Doc) -> ~str {\n+            let mut str = ~\"\";\n+            for uint::range(doc.start, doc.end) |i| {\n+                str::push_char(&mut str, doc.data[i] as char);\n+            }\n+            str\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n         self.read_to_vec(|| self.read_ty(xcx) )\n     }\n \n-    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext) -> ty::TypeParameterDef {\n+    #[cfg(not(stage0))]\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n+        self.read_to_vec(|this| this.read_ty(xcx) )\n+    }\n+\n+    #[cfg(stage0)]\n+    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext)\n+                           -> ty::TypeParameterDef {\n         do self.read_opaque |doc| {\n             tydecode::parse_type_param_def_data(\n                 doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n                 |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n+                           -> ty::TypeParameterDef {\n+        do self.read_opaque |this, doc| {\n+            tydecode::parse_type_param_def_data(\n+                doc.data,\n+                doc.start,\n+                xcx.dcx.cdata.cnum,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a))\n+        }\n+    }\n+\n     #[cfg(stage0)]\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n-        -> ty::ty_param_bounds_and_ty\n-    {\n+                                   -> ty::ty_param_bounds_and_ty {\n         do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n             ty::ty_param_bounds_and_ty {\n-                generics: do self.read_struct(\"Generics\", 2) {\n-                    ty::Generics {\n-                        type_param_defs: self.read_field(\"type_param_defs\", 0, || {\n-                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n-                        }),\n-                        region_param: self.read_field(~\"region_param\", 1, || {\n-                            Decodable::decode(self)\n-                        })\n+                generics: do self.read_field(\"generics\", 0) {\n+                    do self.read_struct(\"Generics\", 2) {\n+                        ty::Generics {\n+                            type_param_defs: self.read_field(\"type_param_defs\", 0, || {\n+                                @self.read_to_vec(|| self.read_type_param_def(xcx))\n+                            }),\n+                            region_param: self.read_field(~\"region_param\", 1, || {\n+                                Decodable::decode(self)\n+                            })\n+                        }\n                     }\n                 },\n                 ty: self.read_field(~\"ty\", 1, || {\n@@ -1123,34 +1711,71 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n-        -> ty::ty_param_bounds_and_ty\n-    {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n+    #[cfg(not(stage0))]\n+    fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n+                                   -> ty::ty_param_bounds_and_ty {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n             ty::ty_param_bounds_and_ty {\n-                generics: do self.read_struct(\"Generics\", 2) {\n-                    ty::Generics {\n-                        type_param_defs: self.read_struct_field(\"type_param_defs\", 0, || {\n-                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n-                        }),\n-                        region_param: self.read_struct_field(~\"region_param\", 1, || {\n-                            Decodable::decode(self)\n-                        })\n+                generics: do this.read_struct_field(\"generics\", 0) |this| {\n+                    do this.read_struct(\"Generics\", 2) |this| {\n+                        ty::Generics {\n+                            type_param_defs:\n+                                this.read_struct_field(\"type_param_defs\",\n+                                                       0,\n+                                                       |this| {\n+                                    @this.read_to_vec(|this|\n+                                        this.read_type_param_def(xcx))\n+                            }),\n+                            region_param:\n+                                this.read_struct_field(\"region_param\",\n+                                                       1,\n+                                                       |this| {\n+                                    Decodable::decode(this)\n+                                })\n+                        }\n                     }\n                 },\n-                ty: self.read_struct_field(\"ty\", 1, || {\n-                    self.read_ty(xcx)\n+                ty: this.read_struct_field(\"ty\", 1, |this| {\n+                    this.read_ty(xcx)\n                 })\n             }\n         }\n     }\n \n-    fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n+    #[cfg(stage0)]\n+    fn convert_def_id(&self,\n+                      xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n-                      did: ast::def_id) -> ast::def_id {\n+                      did: ast::def_id)\n+                      -> ast::def_id {\n+        /*!\n+         *\n+         * Converts a def-id that appears in a type.  The correct\n+         * translation will depend on what kind of def-id this is.\n+         * This is a subtle point: type definitions are not\n+         * inlined into the current crate, so if the def-id names\n+         * a nominal type or type alias, then it should be\n+         * translated to refer to the source crate.\n+         *\n+         * However, *type parameters* are cloned along with the function\n+         * they are attached to.  So we should translate those def-ids\n+         * to refer to the new, cloned copy of the type parameter.\n+         */\n+\n+        let r = match source {\n+            NominalType | TypeWithId => xcx.tr_def_id(did),\n+            TypeParameter => xcx.tr_intern_def_id(did)\n+        };\n+        debug!(\"convert_def_id(source=%?, did=%?)=%?\", source, did, r);\n+        return r;\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn convert_def_id(&mut self,\n+                      xcx: @ExtendedDecodeContext,\n+                      source: tydecode::DefIdSource,\n+                      did: ast::def_id)\n+                      -> ast::def_id {\n         /*!\n          *\n          * Converts a def-id that appears in a type.  The correct\n@@ -1174,6 +1799,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     }\n }\n \n+#[cfg(stage0)]\n fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n@@ -1248,21 +1874,97 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn decode_side_tables(xcx: @ExtendedDecodeContext,\n+                      ast_doc: ebml::Doc) {\n+    let dcx = xcx.dcx;\n+    let tbl_doc = ast_doc.get(c::tag_table as uint);\n+    for reader::docs(tbl_doc) |tag, entry_doc| {\n+        let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n+        let id = xcx.tr_id(id0);\n+\n+        debug!(\">> Side table document with tag 0x%x \\\n+                found for id %d (orig %d)\",\n+               tag, id, id0);\n+\n+        if tag == (c::tag_table_mutbl as uint) {\n+            dcx.maps.mutbl_map.insert(id);\n+        } else if tag == (c::tag_table_moves_map as uint) {\n+            dcx.maps.moves_map.insert(id);\n+        } else {\n+            let val_doc = entry_doc.get(c::tag_table_val as uint);\n+            let mut val_dsr = reader::Decoder(val_doc);\n+            let val_dsr = &mut val_dsr;\n+            if tag == (c::tag_table_def as uint) {\n+                let def = decode_def(xcx, val_doc);\n+                dcx.tcx.def_map.insert(id, def);\n+            } else if tag == (c::tag_table_node_type as uint) {\n+                let ty = val_dsr.read_ty(xcx);\n+                debug!(\"inserting ty for node %?: %s\",\n+                       id, ty_to_str(dcx.tcx, ty));\n+                dcx.tcx.node_types.insert(id as uint, ty);\n+            } else if tag == (c::tag_table_node_type_subst as uint) {\n+                let tys = val_dsr.read_tys(xcx);\n+                dcx.tcx.node_type_substs.insert(id, tys);\n+            } else if tag == (c::tag_table_freevars as uint) {\n+                let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n+                    @val_dsr.read_freevar_entry(xcx)\n+                });\n+                dcx.tcx.freevars.insert(id, fv_info);\n+            } else if tag == (c::tag_table_tcache as uint) {\n+                let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n+                let lid = ast::def_id { crate: ast::local_crate, node: id };\n+                dcx.tcx.tcache.insert(lid, tpbt);\n+            } else if tag == (c::tag_table_param_defs as uint) {\n+                let bounds = val_dsr.read_type_param_def(xcx);\n+                dcx.tcx.ty_param_defs.insert(id, bounds);\n+            } else if tag == (c::tag_table_last_use as uint) {\n+                let ids = val_dsr.read_to_vec(|val_dsr| {\n+                    xcx.tr_id(val_dsr.read_int())\n+                });\n+                dcx.maps.last_use_map.insert(id, @mut ids);\n+            } else if tag == (c::tag_table_method_map as uint) {\n+                dcx.maps.method_map.insert(\n+                    id,\n+                    val_dsr.read_method_map_entry(xcx));\n+            } else if tag == (c::tag_table_vtable_map as uint) {\n+                dcx.maps.vtable_map.insert(id,\n+                                           val_dsr.read_vtable_res(xcx));\n+            } else if tag == (c::tag_table_adjustments as uint) {\n+                let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n+                adj.tr(xcx);\n+                dcx.tcx.adjustments.insert(id, adj);\n+            } else if tag == (c::tag_table_capture_map as uint) {\n+                let cvars =\n+                    at_vec::from_owned(\n+                        val_dsr.read_to_vec(\n+                            |val_dsr| val_dsr.read_capture_var(xcx)));\n+                dcx.maps.capture_map.insert(id, cvars);\n+            } else {\n+                xcx.dcx.tcx.sess.bug(\n+                    fmt!(\"unknown tag found in side tables: %x\", tag));\n+            }\n+        }\n+\n+        debug!(\">< Side table doc loaded\");\n+    }\n+}\n+\n // ______________________________________________________________________\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &writer::Encoder, item: @ast::item) {\n-    do ebml_w.wr_tag(c::tag_tree as uint) {\n-        (*item).encode(ebml_w)\n-    }\n+fn encode_item_ast(ebml_w: &mut writer::Encoder, item: @ast::item) {\n+    ebml_w.start_tag(c::tag_tree as uint);\n+    (*item).encode(ebml_w);\n+    ebml_w.end_tag();\n }\n \n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n-    let d = &reader::Decoder(chi_doc);\n-    @Decodable::decode(d)\n+    let mut d = reader::Decoder(chi_doc);\n+    @Decodable::decode(&mut d)\n }\n \n #[cfg(test)]\n@@ -1303,8 +2005,8 @@ fn roundtrip(in_item: Option<@ast::item>) {\n \n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = writer::Encoder(wr);\n-        encode_item_ast(&ebml_w, in_item);\n+        let mut ebml_w = writer::Encoder(wr);\n+        encode_item_ast(&mut ebml_w, in_item);\n     };\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);"}, {"sha": "0e9b2ed3da89c79bd5db0745b4c33cb5f59beada", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -348,7 +348,7 @@ pub impl Arena {\n \n #[test]\n fn test_arena_destructors() {\n-    let arena = Arena();\n+    let mut arena = Arena();\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n@@ -363,7 +363,7 @@ fn test_arena_destructors() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_arena_destructors_fail() {\n-    let arena = Arena();\n+    let mut arena = Arena();\n     // Put some stuff in the arena.\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it"}, {"sha": "41c5a0f7690cb4852c684bd7a67a5db5b6755dd8", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 754, "deletions": 64, "changes": 818, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -36,13 +36,27 @@ pub struct TaggedDoc {\n }\n \n pub enum EbmlEncoderTag {\n-    EsUint, EsU64, EsU32, EsU16, EsU8,\n-    EsInt, EsI64, EsI32, EsI16, EsI8,\n-    EsBool,\n-    EsStr,\n-    EsF64, EsF32, EsFloat,\n-    EsEnum, EsEnumVid, EsEnumBody,\n-    EsVec, EsVecLen, EsVecElt,\n+    EsUint,     // 0\n+    EsU64,      // 1\n+    EsU32,      // 2\n+    EsU16,      // 3\n+    EsU8,       // 4\n+    EsInt,      // 5\n+    EsI64,      // 6\n+    EsI32,      // 7\n+    EsI16,      // 8\n+    EsI8,       // 9\n+    EsBool,     // 10\n+    EsStr,      // 11\n+    EsF64,      // 12\n+    EsF32,      // 13\n+    EsFloat,    // 14\n+    EsEnum,     // 15\n+    EsEnumVid,  // 16\n+    EsEnumBody, // 17\n+    EsVec,      // 18\n+    EsVecLen,   // 19\n+    EsVecElt,   // 20\n \n     EsOpaque,\n \n@@ -249,17 +263,27 @@ pub mod reader {\n     pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n-\n+    #[cfg(stage0)]\n     pub struct Decoder {\n         priv mut parent: Doc,\n         priv mut pos: uint,\n     }\n \n+    #[cfg(not(stage0))]\n+    pub struct Decoder {\n+        priv parent: Doc,\n+        priv pos: uint,\n+    }\n+\n     pub fn Decoder(d: Doc) -> Decoder {\n-        Decoder { parent: d, pos: d.start }\n+        Decoder {\n+            parent: d,\n+            pos: d.start\n+        }\n     }\n \n     priv impl Decoder {\n+        #[cfg(stage0)]\n         fn _check_label(&self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n@@ -269,13 +293,33 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = doc_as_str(r_doc);\n                     if lbl != str {\n-                        fail!(fmt!(\"Expected label %s but found %s\", lbl,\n-                            str));\n+                        fail!(fmt!(\"Expected label %s but found %s\",\n+                                   lbl,\n+                                   str));\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[cfg(not(stage0))]\n+        fn _check_label(&mut self, lbl: &str) {\n+            if self.pos < self.parent.end {\n+                let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                    doc_at(self.parent.data, self.pos);\n+\n+                if r_tag == (EsLabel as uint) {\n+                    self.pos = r_doc.end;\n+                    let str = doc_as_str(r_doc);\n+                    if lbl != str {\n+                        fail!(fmt!(\"Expected label %s but found %s\",\n+                                   lbl,\n+                                   str));\n                     }\n                 }\n             }\n         }\n \n+        #[cfg(stage0)]\n         fn next_doc(&self, exp_tag: EbmlEncoderTag) -> Doc {\n             debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n             if self.pos >= self.parent.end {\n@@ -298,6 +342,30 @@ pub mod reader {\n             r_doc\n         }\n \n+        #[cfg(not(stage0))]\n+        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n+            debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n+            if self.pos >= self.parent.end {\n+                fail!(~\"no more documents in current node!\");\n+            }\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n+            debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+                   copy self.parent.start, copy self.parent.end,\n+                   copy self.pos, r_tag, r_doc.start, r_doc.end);\n+            if r_tag != (exp_tag as uint) {\n+                fail!(fmt!(\"expected EBML doc with tag %? but found tag %?\",\n+                          exp_tag, r_tag));\n+            }\n+            if r_doc.end > self.parent.end {\n+                fail!(fmt!(\"invalid EBML, child extends to 0x%x, \\\n+                           parent to 0x%x\", r_doc.end, self.parent.end));\n+            }\n+            self.pos = r_doc.end;\n+            r_doc\n+        }\n+\n+        #[cfg(stage0)]\n         fn push_doc<T>(&self, d: Doc, f: &fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -309,21 +377,58 @@ pub mod reader {\n             r\n         }\n \n+        #[cfg(not(stage0))]\n+        fn push_doc<T>(&mut self, d: Doc, f: &fn() -> T) -> T {\n+            let old_parent = self.parent;\n+            let old_pos = self.pos;\n+            self.parent = d;\n+            self.pos = d.start;\n+            let r = f();\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            r\n+        }\n+\n+        #[cfg(stage0)]\n         fn _next_uint(&self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n             debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n             r as uint\n         }\n+\n+        #[cfg(not(stage0))]\n+        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n+            let r = doc_as_u32(self.next_doc(exp_tag));\n+            debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n+            r as uint\n+        }\n     }\n \n     pub impl Decoder {\n+        #[cfg(stage0)]\n         fn read_opaque<R>(&self, op: &fn(Doc) -> R) -> R {\n             do self.push_doc(self.next_doc(EsOpaque)) {\n                 op(copy self.parent)\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R) -> R {\n+            let doc = self.next_doc(EsOpaque);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = doc.start;\n+\n+            let result = op(self, doc);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n     }\n \n+    #[cfg(stage0)]\n     impl serialize::Decoder for Decoder {\n         fn read_nil(&self) -> () { () }\n \n@@ -339,10 +444,18 @@ pub mod reader {\n             v as uint\n         }\n \n-        fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n-        fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n-        fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n-        fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n+        fn read_i64(&self) -> i64 {\n+            doc_as_u64(self.next_doc(EsI64)) as i64\n+        }\n+        fn read_i32(&self) -> i32 {\n+            doc_as_u32(self.next_doc(EsI32)) as i32\n+        }\n+        fn read_i16(&self) -> i16 {\n+            doc_as_u16(self.next_doc(EsI16)) as i16\n+        }\n+        fn read_i8 (&self) -> i8 {\n+            doc_as_u8(self.next_doc(EsI8 )) as i8\n+        }\n         fn read_int(&self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n             if v > (int::max_value as i64) || v < (int::min_value as i64) {\n@@ -351,8 +464,9 @@ pub mod reader {\n             v as int\n         }\n \n-        fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool))\n-                                         as bool }\n+        fn read_bool(&self) -> bool {\n+            doc_as_u8(self.next_doc(EsBool)) as bool\n+        }\n \n         fn read_f64(&self) -> f64 { fail!(~\"read_f64()\"); }\n         fn read_f32(&self) -> f32 { fail!(~\"read_f32()\"); }\n@@ -367,7 +481,10 @@ pub mod reader {\n             self.push_doc(self.next_doc(EsEnum), f)\n         }\n \n-        fn read_enum_variant<T>(&self, _names: &[&str], f: &fn(uint) -> T) -> T {\n+        fn read_enum_variant<T>(&self,\n+                                _: &[&str],\n+                                f: &fn(uint) -> T)\n+                                -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n             debug!(\"  idx=%u\", idx);\n@@ -376,12 +493,17 @@ pub mod reader {\n             }\n         }\n \n-        fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        fn read_enum_variant_arg<T>(&self,\n+                                    idx: uint,\n+                                    f: &fn() -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n             f()\n         }\n \n-        fn read_enum_struct_variant<T>(&self, _names: &[&str], f: &fn(uint) -> T) -> T {\n+        fn read_enum_struct_variant<T>(&self,\n+                                       _: &[&str],\n+                                       f: &fn(uint) -> T)\n+                                       -> T {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n             debug!(\"  idx=%u\", idx);\n@@ -390,32 +512,34 @@ pub mod reader {\n             }\n         }\n \n-        fn read_enum_struct_variant_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        fn read_enum_struct_variant_field<T>(&self,\n+                                             name: &str,\n+                                             idx: uint,\n+                                             f: &fn() -> T)\n+                                             -> T {\n             debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n             f()\n         }\n \n-        fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n+        fn read_struct<T>(&self,\n+                          name: &str,\n+                          _: uint,\n+                          f: &fn() -> T)\n+                          -> T {\n             debug!(\"read_struct(name=%s)\", name);\n             f()\n         }\n \n-        #[cfg(stage0)]\n-        fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        fn read_field<T>(&self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: &fn() -> T)\n+                         -> T {\n             debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n             self._check_label(name);\n             f()\n         }\n \n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        #[cfg(stage3)]\n-        fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n-            self._check_label(name);\n-            f()\n-        }\n-\n         fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_tuple()\");\n             self.read_seq(f)\n@@ -426,12 +550,18 @@ pub mod reader {\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T>(&self, name: &str, f: &fn(uint) -> T) -> T {\n+        fn read_tuple_struct<T>(&self,\n+                                name: &str,\n+                                f: &fn(uint) -> T)\n+                                -> T {\n             debug!(\"read_tuple_struct(name=%?)\", name);\n             self.read_tuple(f)\n         }\n \n-        fn read_tuple_struct_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        fn read_tuple_struct_arg<T>(&self,\n+                                    idx: uint,\n+                                    f: &fn() -> T)\n+                                    -> T {\n             debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n@@ -478,6 +608,245 @@ pub mod reader {\n             fail!(~\"read_map_elt_val is unimplemented\");\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    impl serialize::Decoder for Decoder {\n+        fn read_nil(&mut self) -> () { () }\n+\n+        fn read_u64(&mut self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+        fn read_u32(&mut self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+        fn read_u16(&mut self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+        fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+        fn read_uint(&mut self) -> uint {\n+            let v = doc_as_u64(self.next_doc(EsUint));\n+            if v > (::core::uint::max_value as u64) {\n+                fail!(fmt!(\"uint %? too large for this architecture\", v));\n+            }\n+            v as uint\n+        }\n+\n+        fn read_i64(&mut self) -> i64 {\n+            doc_as_u64(self.next_doc(EsI64)) as i64\n+        }\n+        fn read_i32(&mut self) -> i32 {\n+            doc_as_u32(self.next_doc(EsI32)) as i32\n+        }\n+        fn read_i16(&mut self) -> i16 {\n+            doc_as_u16(self.next_doc(EsI16)) as i16\n+        }\n+        fn read_i8 (&mut self) -> i8 {\n+            doc_as_u8(self.next_doc(EsI8 )) as i8\n+        }\n+        fn read_int(&mut self) -> int {\n+            let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n+            if v > (int::max_value as i64) || v < (int::min_value as i64) {\n+                fail!(fmt!(\"int %? out of range for this architecture\", v));\n+            }\n+            v as int\n+        }\n+\n+        fn read_bool(&mut self) -> bool {\n+            doc_as_u8(self.next_doc(EsBool)) as bool\n+        }\n+\n+        fn read_f64(&mut self) -> f64 { fail!(~\"read_f64()\"); }\n+        fn read_f32(&mut self) -> f32 { fail!(~\"read_f32()\"); }\n+        fn read_float(&mut self) -> float { fail!(~\"read_float()\"); }\n+        fn read_char(&mut self) -> char { fail!(~\"read_char()\"); }\n+        fn read_str(&mut self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+\n+        // Compound types:\n+        fn read_enum<T>(&mut self,\n+                        name: &str,\n+                        f: &fn(&mut Decoder) -> T)\n+                        -> T {\n+            debug!(\"read_enum(%s)\", name);\n+            self._check_label(name);\n+\n+            let doc = self.next_doc(EsEnum);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_enum_variant<T>(&mut self,\n+                                _: &[&str],\n+                                f: &fn(&mut Decoder, uint) -> T)\n+                                -> T {\n+            debug!(\"read_enum_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx=%u\", idx);\n+\n+            let doc = self.next_doc(EsEnumBody);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self, idx);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_enum_variant_arg<T>(&mut self,\n+                                    idx: uint,\n+                                    f: &fn(&mut Decoder) -> T) -> T {\n+            debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+            f(self)\n+        }\n+\n+        fn read_enum_struct_variant<T>(&mut self,\n+                                       _: &[&str],\n+                                       f: &fn(&mut Decoder, uint) -> T)\n+                                       -> T {\n+            debug!(\"read_enum_struct_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx=%u\", idx);\n+\n+            let doc = self.next_doc(EsEnumBody);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self, idx);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_enum_struct_variant_field<T>(&mut self,\n+                                             name: &str,\n+                                             idx: uint,\n+                                             f: &fn(&mut Decoder) -> T)\n+                                             -> T {\n+            debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n+            f(self)\n+        }\n+\n+        fn read_struct<T>(&mut self,\n+                          name: &str,\n+                          _: uint,\n+                          f: &fn(&mut Decoder) -> T)\n+                          -> T {\n+            debug!(\"read_struct(name=%s)\", name);\n+            f(self)\n+        }\n+\n+        fn read_struct_field<T>(&mut self,\n+                                name: &str,\n+                                idx: uint,\n+                                f: &fn(&mut Decoder) -> T)\n+                                -> T {\n+            debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+            self._check_label(name);\n+            f(self)\n+        }\n+\n+        fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+            debug!(\"read_tuple()\");\n+            self.read_seq(f)\n+        }\n+\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+                             -> T {\n+            debug!(\"read_tuple_arg(idx=%u)\", idx);\n+            self.read_seq_elt(idx, f)\n+        }\n+\n+        fn read_tuple_struct<T>(&mut self,\n+                                name: &str,\n+                                f: &fn(&mut Decoder, uint) -> T)\n+                                -> T {\n+            debug!(\"read_tuple_struct(name=%?)\", name);\n+            self.read_tuple(f)\n+        }\n+\n+        fn read_tuple_struct_arg<T>(&mut self,\n+                                    idx: uint,\n+                                    f: &fn(&mut Decoder) -> T)\n+                                    -> T {\n+            debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+            self.read_tuple_arg(idx, f)\n+        }\n+\n+        fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n+            debug!(\"read_option()\");\n+            do self.read_enum(\"Option\") |this| {\n+                do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n+                    match idx {\n+                        0 => f(this, false),\n+                        1 => f(this, true),\n+                        _ => fail!(),\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+            debug!(\"read_seq()\");\n+            let doc = self.next_doc(EsVec);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let len = self._next_uint(EsVecLen);\n+            debug!(\"  len=%u\", len);\n+            let result = f(self, len);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+                           -> T {\n+            debug!(\"read_seq_elt(idx=%u)\", idx);\n+            let doc = self.next_doc(EsVecElt);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_map<T>(&mut self, _: &fn(&mut Decoder, uint) -> T) -> T {\n+            debug!(\"read_map()\");\n+            fail!(~\"read_map is unimplemented\");\n+        }\n+\n+        fn read_map_elt_key<T>(&mut self,\n+                               idx: uint,\n+                               _: &fn(&mut Decoder) -> T)\n+                               -> T {\n+            debug!(\"read_map_elt_key(idx=%u)\", idx);\n+            fail!(~\"read_map_elt_val is unimplemented\");\n+        }\n+\n+        fn read_map_elt_val<T>(&mut self,\n+                               idx: uint,\n+                               _: &fn(&mut Decoder) -> T)\n+                               -> T {\n+            debug!(\"read_map_elt_val(idx=%u)\", idx);\n+            fail!(~\"read_map_elt_val is unimplemented\");\n+        }\n+    }\n }\n \n pub mod writer {\n@@ -522,6 +891,7 @@ pub mod writer {\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n+    #[cfg(stage0)]\n     pub impl Encoder {\n         fn start_tag(&self, tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n@@ -617,13 +987,111 @@ pub mod writer {\n         }\n     }\n \n+    // FIXME (#2741): Provide a function to write the standard ebml header.\n+    #[cfg(not(stage0))]\n+    pub impl Encoder {\n+        fn start_tag(&mut self, tag_id: uint) {\n+            debug!(\"Start tag %u\", tag_id);\n+\n+            // Write the enum ID:\n+            write_vuint(self.writer, tag_id);\n+\n+            // Write a placeholder four-byte size.\n+            self.size_positions.push(self.writer.tell());\n+            let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n+            self.writer.write(zeroes);\n+        }\n+\n+        fn end_tag(&mut self) {\n+            let last_size_pos = self.size_positions.pop();\n+            let cur_pos = self.writer.tell();\n+            self.writer.seek(last_size_pos as int, io::SeekSet);\n+            let size = (cur_pos - last_size_pos - 4u);\n+            write_sized_vuint(self.writer, size, 4u);\n+            self.writer.seek(cur_pos as int, io::SeekSet);\n+\n+            debug!(\"End tag (size = %u)\", size);\n+        }\n+\n+        fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n+            self.start_tag(tag_id);\n+            blk();\n+            self.end_tag();\n+        }\n+\n+        fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n+            write_vuint(self.writer, tag_id);\n+            write_vuint(self.writer, vec::len(b));\n+            self.writer.write(b);\n+        }\n+\n+        fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n+            do io::u64_to_be_bytes(v, 8u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n+\n+        fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n+            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n+\n+        fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n+            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n+\n+        fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n+            self.wr_tagged_bytes(tag_id, &[v]);\n+        }\n+\n+        fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n+            do io::u64_to_be_bytes(v as u64, 8u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n+\n+        fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n+            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n+\n+        fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n+            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n+\n+        fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n+            self.wr_tagged_bytes(tag_id, &[v as u8]);\n+        }\n+\n+        fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n+            str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n+        }\n+\n+        fn wr_bytes(&mut self, b: &[u8]) {\n+            debug!(\"Write %u bytes\", vec::len(b));\n+            self.writer.write(b);\n+        }\n+\n+        fn wr_str(&mut self, s: &str) {\n+            debug!(\"Write str: %?\", s);\n+            self.writer.write(str::to_bytes(s));\n+        }\n+    }\n+\n     // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n     // efficiently encode sizes; this is a fixed point iteration\n \n     // Set to true to generate more debugging in EBML code.\n     // Totally lame approach.\n-    static debug: bool = false;\n+    static debug: bool = true;\n \n+    #[cfg(stage0)]\n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n@@ -642,6 +1110,26 @@ pub mod writer {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    priv impl Encoder {\n+        // used internally to emit things like the vector length and so on\n+        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n+            assert!(v <= 0xFFFF_FFFF_u);\n+            self.wr_tagged_u32(t as uint, v as u32);\n+        }\n+\n+        fn _emit_label(&mut self, label: &str) {\n+            // There are various strings that we have access to, such as\n+            // the name of a record field, which do not actually appear in\n+            // the encoded EBML (normally).  This is just for\n+            // efficiency.  When debugging, though, we can emit such\n+            // labels and then they will be checked by decoder to\n+            // try and check failures more quickly.\n+            if debug { self.wr_tagged_str(EsLabel as uint, label) }\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     pub impl Encoder {\n         fn emit_opaque(&self, f: &fn()) {\n             do self.wr_tag(EsOpaque as uint) {\n@@ -650,24 +1138,50 @@ pub mod writer {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    pub impl Encoder {\n+        fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsOpaque as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     impl ::serialize::Encoder for Encoder {\n         fn emit_nil(&self) {}\n \n         fn emit_uint(&self, v: uint) {\n             self.wr_tagged_u64(EsUint as uint, v as u64);\n         }\n-        fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-        fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-        fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-        fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n+        fn emit_u64(&self, v: u64) {\n+            self.wr_tagged_u64(EsU64 as uint, v);\n+        }\n+        fn emit_u32(&self, v: u32) {\n+            self.wr_tagged_u32(EsU32 as uint, v);\n+        }\n+        fn emit_u16(&self, v: u16) {\n+            self.wr_tagged_u16(EsU16 as uint, v);\n+        }\n+        fn emit_u8(&self, v: u8) {\n+            self.wr_tagged_u8(EsU8 as uint, v);\n+        }\n \n         fn emit_int(&self, v: int) {\n             self.wr_tagged_i64(EsInt as uint, v as i64);\n         }\n-        fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-        fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-        fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-        fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n+        fn emit_i64(&self, v: i64) {\n+            self.wr_tagged_i64(EsI64 as uint, v);\n+        }\n+        fn emit_i32(&self, v: i32) {\n+            self.wr_tagged_i32(EsI32 as uint, v);\n+        }\n+        fn emit_i16(&self, v: i16) {\n+            self.wr_tagged_i16(EsI16 as uint, v);\n+        }\n+        fn emit_i8(&self, v: i8) {\n+            self.wr_tagged_i8(EsI8 as uint, v);\n+        }\n \n         fn emit_bool(&self, v: bool) {\n             self.wr_tagged_u8(EsBool as uint, v as u8)\n@@ -697,41 +1211,56 @@ pub mod writer {\n             self.wr_tag(EsEnum as uint, f)\n         }\n \n-        fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n+        fn emit_enum_variant(&self,\n+                             _: &str,\n+                             v_id: uint,\n+                             _: uint,\n                              f: &fn()) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.wr_tag(EsEnumBody as uint, f)\n         }\n \n-        fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n+        fn emit_enum_variant_arg(&self, _: uint, f: &fn()) {\n+            f()\n+        }\n \n-        fn emit_enum_struct_variant(&self, v_name: &str, v_id: uint, cnt: uint, f: &fn()) {\n+        fn emit_enum_struct_variant(&self,\n+                                    v_name: &str,\n+                                    v_id: uint,\n+                                    cnt: uint,\n+                                    f: &fn()) {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field(&self, _f_name: &str, idx: uint, f: &fn()) {\n+        fn emit_enum_struct_variant_field(&self,\n+                                          _: &str,\n+                                          idx: uint,\n+                                          f: &fn()) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n-        #[cfg(stage0)]\n-        fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n-            self._emit_label(name);\n+        fn emit_struct(&self, _: &str, _len: uint, f: &fn()) {\n             f()\n         }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        #[cfg(stage3)]\n-        fn emit_struct_field(&self, name: &str, _idx: uint, f: &fn()) {\n+\n+        fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()\n         }\n \n-        fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-        fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+        fn emit_tuple(&self, len: uint, f: &fn()) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_arg(&self, idx: uint, f: &fn()) {\n+            self.emit_seq_elt(idx, f)\n+        }\n \n-        fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-        fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+        fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) {\n+            self.emit_seq_elt(idx, f)\n+        }\n \n         fn emit_option(&self, f: &fn()) {\n             self.emit_enum(\"Option\", f);\n@@ -766,6 +1295,167 @@ pub mod writer {\n             fail!(~\"emit_map_elt_val is unimplemented\");\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    impl ::serialize::Encoder for Encoder {\n+        fn emit_nil(&mut self) {}\n+\n+        fn emit_uint(&mut self, v: uint) {\n+            self.wr_tagged_u64(EsUint as uint, v as u64);\n+        }\n+        fn emit_u64(&mut self, v: u64) {\n+            self.wr_tagged_u64(EsU64 as uint, v);\n+        }\n+        fn emit_u32(&mut self, v: u32) {\n+            self.wr_tagged_u32(EsU32 as uint, v);\n+        }\n+        fn emit_u16(&mut self, v: u16) {\n+            self.wr_tagged_u16(EsU16 as uint, v);\n+        }\n+        fn emit_u8(&mut self, v: u8) {\n+            self.wr_tagged_u8(EsU8 as uint, v);\n+        }\n+\n+        fn emit_int(&mut self, v: int) {\n+            self.wr_tagged_i64(EsInt as uint, v as i64);\n+        }\n+        fn emit_i64(&mut self, v: i64) {\n+            self.wr_tagged_i64(EsI64 as uint, v);\n+        }\n+        fn emit_i32(&mut self, v: i32) {\n+            self.wr_tagged_i32(EsI32 as uint, v);\n+        }\n+        fn emit_i16(&mut self, v: i16) {\n+            self.wr_tagged_i16(EsI16 as uint, v);\n+        }\n+        fn emit_i8(&mut self, v: i8) {\n+            self.wr_tagged_i8(EsI8 as uint, v);\n+        }\n+\n+        fn emit_bool(&mut self, v: bool) {\n+            self.wr_tagged_u8(EsBool as uint, v as u8)\n+        }\n+\n+        // FIXME (#2742): implement these\n+        fn emit_f64(&mut self, _v: f64) {\n+            fail!(~\"Unimplemented: serializing an f64\");\n+        }\n+        fn emit_f32(&mut self, _v: f32) {\n+            fail!(~\"Unimplemented: serializing an f32\");\n+        }\n+        fn emit_float(&mut self, _v: float) {\n+            fail!(~\"Unimplemented: serializing a float\");\n+        }\n+\n+        fn emit_char(&mut self, _v: char) {\n+            fail!(~\"Unimplemented: serializing a char\");\n+        }\n+\n+        fn emit_str(&mut self, v: &str) {\n+            self.wr_tagged_str(EsStr as uint, v)\n+        }\n+\n+        fn emit_enum(&mut self, name: &str, f: &fn(&mut Encoder)) {\n+            self._emit_label(name);\n+            self.start_tag(EsEnum as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_enum_variant(&mut self,\n+                             _: &str,\n+                             v_id: uint,\n+                             _: uint,\n+                             f: &fn(&mut Encoder)) {\n+            self._emit_tagged_uint(EsEnumVid, v_id);\n+            self.start_tag(EsEnumBody as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: &fn(&mut Encoder)) {\n+            f(self)\n+        }\n+\n+        fn emit_enum_struct_variant(&mut self,\n+                                    v_name: &str,\n+                                    v_id: uint,\n+                                    cnt: uint,\n+                                    f: &fn(&mut Encoder)) {\n+            self.emit_enum_variant(v_name, v_id, cnt, f)\n+        }\n+\n+        fn emit_enum_struct_variant_field(&mut self,\n+                                          _: &str,\n+                                          idx: uint,\n+                                          f: &fn(&mut Encoder)) {\n+            self.emit_enum_variant_arg(idx, f)\n+        }\n+\n+        fn emit_struct(&mut self, _: &str, _len: uint, f: &fn(&mut Encoder)) {\n+            f(self)\n+        }\n+\n+        fn emit_struct_field(&mut self,\n+                             name: &str,\n+                             _: uint,\n+                             f: &fn(&mut Encoder)) {\n+            self._emit_label(name);\n+            f(self)\n+        }\n+\n+        fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+            self.emit_seq_elt(idx, f)\n+        }\n+\n+        fn emit_tuple_struct(&mut self,\n+                             _: &str,\n+                             len: uint,\n+                             f: &fn(&mut Encoder)) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+            self.emit_seq_elt(idx, f)\n+        }\n+\n+        fn emit_option(&mut self, f: &fn(&mut Encoder)) {\n+            self.emit_enum(\"Option\", f);\n+        }\n+        fn emit_option_none(&mut self) {\n+            self.emit_enum_variant(\"None\", 0, 0, |_| ())\n+        }\n+        fn emit_option_some(&mut self, f: &fn(&mut Encoder)) {\n+            self.emit_enum_variant(\"Some\", 1, 1, f)\n+        }\n+\n+        fn emit_seq(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsVec as uint);\n+            self._emit_tagged_uint(EsVecLen, len);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsVecElt as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_map(&mut self, _len: uint, _f: &fn(&mut Encoder)) {\n+            fail!(~\"emit_map is unimplemented\");\n+        }\n+\n+        fn emit_map_elt_key(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n+            fail!(~\"emit_map_elt_key is unimplemented\");\n+        }\n+\n+        fn emit_map_elt_val(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n+            fail!(~\"emit_map_elt_val is unimplemented\");\n+        }\n+    }\n }\n \n // ___________________________________________________________________________\n@@ -786,12 +1476,12 @@ mod tests {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == %?\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = writer::Encoder(wr);\n-                v.encode(&ebml_w)\n+                let mut ebml_w = writer::Encoder(wr);\n+                v.encode(&mut ebml_w)\n             };\n             let ebml_doc = reader::Doc(@bytes);\n-            let deser = reader::Decoder(ebml_doc);\n-            let v1 = serialize::Decodable::decode(&deser);\n+            let mut deser = reader::Decoder(ebml_doc);\n+            let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == %?\", v1);\n             assert!(v == v1);\n         }"}, {"sha": "55ea9c2948b01061a41b966e96e8bab816967f57", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -438,23 +438,52 @@ pub mod flatteners {\n     SerializingFlattener\n     */\n \n+    #[cfg(stage0)]\n     pub fn deserialize_buffer<D: Decoder + FromReader,\n-                              T: Decodable<D>>(buf: &[u8]) -> T {\n+                              T: Decodable<D>>(\n+                              buf: &[u8])\n+                              -> T {\n         let buf = vec::from_slice(buf);\n         let buf_reader = @BufReader::new(buf);\n         let reader = buf_reader as @Reader;\n         let deser: D = FromReader::from_reader(reader);\n         Decodable::decode(&deser)\n     }\n \n+    #[cfg(not(stage0))]\n+    pub fn deserialize_buffer<D: Decoder + FromReader,\n+                              T: Decodable<D>>(\n+                              buf: &[u8])\n+                              -> T {\n+        let buf = vec::from_slice(buf);\n+        let buf_reader = @BufReader::new(buf);\n+        let reader = buf_reader as @Reader;\n+        let mut deser: D = FromReader::from_reader(reader);\n+        Decodable::decode(&mut deser)\n+    }\n+\n+    #[cfg(stage0)]\n     pub fn serialize_value<D: Encoder + FromWriter,\n-                           T: Encodable<D>>(val: &T) -> ~[u8] {\n+                           T: Encodable<D>>(\n+                           val: &T)\n+                           -> ~[u8] {\n         do io::with_bytes_writer |writer| {\n             let ser = FromWriter::from_writer(writer);\n             val.encode(&ser);\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    pub fn serialize_value<D: Encoder + FromWriter,\n+                           T: Encodable<D>>(\n+                           val: &T)\n+                           -> ~[u8] {\n+        do io::with_bytes_writer |writer| {\n+            let mut ser = FromWriter::from_writer(writer);\n+            val.encode(&mut ser);\n+        }\n+    }\n+\n     pub trait FromReader {\n         fn from_reader(r: @Reader) -> Self;\n     }"}, {"sha": "6951ee377c92aa94b0b88bf4a806a42da231eb8e", "filename": "src/libstd/json.rs", "status": "modified", "additions": 795, "deletions": 76, "changes": 871, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -72,9 +72,12 @@ pub struct Encoder {\n }\n \n pub fn Encoder(wr: @io::Writer) -> Encoder {\n-    Encoder { wr: wr }\n+    Encoder {\n+        wr: wr\n+    }\n }\n \n+#[cfg(stage0)]\n impl serialize::Encoder for Encoder {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n@@ -109,7 +112,11 @@ impl serialize::Encoder for Encoder {\n \n     fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_variant(&self,\n+                         name: &str,\n+                         _id: uint,\n+                         cnt: uint,\n+                         f: &fn()) {\n         // enums are encoded as strings or vectors:\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n@@ -130,26 +137,35 @@ impl serialize::Encoder for Encoder {\n         f();\n     }\n \n-    fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_struct_variant(&self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: &fn()) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&self, _field: &str, idx: uint, f: &fn()) {\n+    fn emit_enum_struct_variant_field(&self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: &fn()) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n+    fn emit_struct(&self, _: &str, _: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n+\n     #[cfg(stage0)]\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n         f();\n     }\n+\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n@@ -161,10 +177,16 @@ impl serialize::Encoder for Encoder {\n     }\n \n     fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple_arg(&self, idx: uint, f: &fn()) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n-    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n@@ -198,15 +220,163 @@ impl serialize::Encoder for Encoder {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl serialize::Encoder for Encoder {\n+    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n+\n+    fn emit_uint(&mut self, v: uint) { self.emit_float(v as float); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_float(v as float); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_float(v as float); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_float(v as float); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_float(v as float); }\n+\n+    fn emit_int(&mut self, v: int) { self.emit_float(v as float); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_float(v as float); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_float(v as float); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_float(v as float); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_float(v as float); }\n+\n+    fn emit_bool(&mut self, v: bool) {\n+        if v {\n+            self.wr.write_str(\"true\");\n+        } else {\n+            self.wr.write_str(\"false\");\n+        }\n+    }\n+\n+    fn emit_f64(&mut self, v: f64) { self.emit_float(v as float); }\n+    fn emit_f32(&mut self, v: f32) { self.emit_float(v as float); }\n+    fn emit_float(&mut self, v: float) {\n+        self.wr.write_str(float::to_str_digits(v, 6u));\n+    }\n+\n+    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)) }\n+\n+    fn emit_enum(&mut self, _name: &str, f: &fn(&mut Encoder)) { f(self) }\n+\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _id: uint,\n+                         cnt: uint,\n+                         f: &fn(&mut Encoder)) {\n+        // enums are encoded as strings or vectors:\n+        // Bunny => \"Bunny\"\n+        // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n+\n+        if cnt == 0 {\n+            self.wr.write_str(escape_str(name));\n+        } else {\n+            self.wr.write_char('[');\n+            self.wr.write_str(escape_str(name));\n+            self.wr.write_char(',');\n+            f(self);\n+            self.wr.write_char(']');\n+        }\n+    }\n+\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        if idx != 0 {\n+            self.wr.write_char(',');\n+        }\n+        f(self);\n+    }\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: &fn(&mut Encoder)) {\n+        self.emit_enum_variant(name, id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: &fn(&mut Encoder)) {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+    fn emit_struct(&mut self, _: &str, _: uint, f: &fn(&mut Encoder)) {\n+        self.wr.write_char('{');\n+        f(self);\n+        self.wr.write_char('}');\n+    }\n+\n+    fn emit_struct_field(&mut self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: &fn(&mut Encoder)) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_char(':');\n+        f(self);\n+    }\n+\n+    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_tuple_struct(&mut self,\n+                         _name: &str,\n+                         len: uint,\n+                         f: &fn(&mut Encoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_option(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+    fn emit_option_none(&mut self) { self.emit_nil(); }\n+    fn emit_option_some(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+\n+    fn emit_seq(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n+        self.wr.write_char('[');\n+        f(self);\n+        self.wr.write_char(']');\n+    }\n+\n+    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        if idx != 0 {\n+            self.wr.write_char(',');\n+        }\n+        f(self)\n+    }\n+\n+    fn emit_map(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n+        self.wr.write_char('{');\n+        f(self);\n+        self.wr.write_char('}');\n+    }\n+\n+    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        f(self)\n+    }\n+\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        self.wr.write_char(':');\n+        f(self)\n+    }\n+}\n+\n pub struct PrettyEncoder {\n     priv wr: @io::Writer,\n     priv mut indent: uint,\n }\n \n pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n-    PrettyEncoder { wr: wr, indent: 0 }\n+    PrettyEncoder {\n+        wr: wr,\n+        indent: 0,\n+    }\n }\n \n+#[cfg(stage0)]\n impl serialize::Encoder for PrettyEncoder {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n@@ -241,7 +411,11 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_variant(&self,\n+                         name: &str,\n+                         _: uint,\n+                         cnt: uint,\n+                         f: &fn()) {\n         if cnt == 0 {\n             self.wr.write_str(escape_str(name));\n         } else {\n@@ -267,11 +441,18 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_struct_variant(&self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: &fn()) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&self, _field: &str, idx: uint, f: &fn()) {\n+    fn emit_enum_struct_variant_field(&self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: &fn()) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n@@ -289,6 +470,7 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char('}');\n         }\n     }\n+\n     #[cfg(stage0)]\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n@@ -301,6 +483,7 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(\": \");\n         f();\n     }\n+\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n@@ -316,11 +499,19 @@ impl serialize::Encoder for PrettyEncoder {\n         f();\n     }\n \n-    fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple(&self, len: uint, f: &fn()) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&self, idx: uint, f: &fn()) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n-    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n@@ -339,6 +530,7 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char(']');\n         }\n     }\n+\n     fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n@@ -362,6 +554,7 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char('}');\n         }\n     }\n+\n     fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n@@ -378,6 +571,201 @@ impl serialize::Encoder for PrettyEncoder {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl serialize::Encoder for PrettyEncoder {\n+    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n+\n+    fn emit_uint(&mut self, v: uint) { self.emit_float(v as float); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_float(v as float); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_float(v as float); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_float(v as float); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_float(v as float); }\n+\n+    fn emit_int(&mut self, v: int) { self.emit_float(v as float); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_float(v as float); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_float(v as float); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_float(v as float); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_float(v as float); }\n+\n+    fn emit_bool(&mut self, v: bool) {\n+        if v {\n+            self.wr.write_str(\"true\");\n+        } else {\n+            self.wr.write_str(\"false\");\n+        }\n+    }\n+\n+    fn emit_f64(&mut self, v: f64) { self.emit_float(v as float); }\n+    fn emit_f32(&mut self, v: f32) { self.emit_float(v as float); }\n+    fn emit_float(&mut self, v: float) {\n+        self.wr.write_str(float::to_str_digits(v, 6u));\n+    }\n+\n+    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)); }\n+\n+    fn emit_enum(&mut self, _name: &str, f: &fn(&mut PrettyEncoder)) {\n+        f(self)\n+    }\n+\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _: uint,\n+                         cnt: uint,\n+                         f: &fn(&mut PrettyEncoder)) {\n+        if cnt == 0 {\n+            self.wr.write_str(escape_str(name));\n+        } else {\n+            self.wr.write_char('[');\n+            self.indent += 2;\n+            self.wr.write_char('\\n');\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_str(escape_str(name));\n+            self.wr.write_str(\",\\n\");\n+            f(self);\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char(']');\n+        }\n+    }\n+\n+    fn emit_enum_variant_arg(&mut self,\n+                             idx: uint,\n+                             f: &fn(&mut PrettyEncoder)) {\n+        if idx != 0 {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        f(self)\n+    }\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: &fn(&mut PrettyEncoder)) {\n+        self.emit_enum_variant(name, id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: &fn(&mut PrettyEncoder)) {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+\n+    fn emit_struct(&mut self,\n+                   _: &str,\n+                   len: uint,\n+                   f: &fn(&mut PrettyEncoder)) {\n+        if len == 0 {\n+            self.wr.write_str(\"{}\");\n+        } else {\n+            self.wr.write_char('{');\n+            self.indent += 2;\n+            f(self);\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char('}');\n+        }\n+    }\n+\n+    fn emit_struct_field(&mut self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: &fn(&mut PrettyEncoder)) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_str(\": \");\n+        f(self);\n+    }\n+\n+    fn emit_tuple(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_tuple_struct(&mut self,\n+                         _: &str,\n+                         len: uint,\n+                         f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&mut self,\n+                             idx: uint,\n+                             f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_option(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+    fn emit_option_none(&mut self) { self.emit_nil(); }\n+    fn emit_option_some(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+\n+    fn emit_seq(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+        if len == 0 {\n+            self.wr.write_str(\"[]\");\n+        } else {\n+            self.wr.write_char('[');\n+            self.indent += 2;\n+            f(self);\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char(']');\n+        }\n+    }\n+\n+    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        f(self)\n+    }\n+\n+    fn emit_map(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+        if len == 0 {\n+            self.wr.write_str(\"{}\");\n+        } else {\n+            self.wr.write_char('{');\n+            self.indent += 2;\n+            f(self);\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char('}');\n+        }\n+    }\n+\n+    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        f(self);\n+    }\n+\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut PrettyEncoder)) {\n+        self.wr.write_str(\": \");\n+        f(self);\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n     fn encode(&self, e: &E) {\n         match *self {\n@@ -391,9 +779,32 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n+    fn encode(&self, e: &mut E) {\n+        match *self {\n+            Number(v) => v.encode(e),\n+            String(ref v) => v.encode(e),\n+            Boolean(v) => v.encode(e),\n+            List(ref v) => v.encode(e),\n+            Object(ref v) => v.encode(e),\n+            Null => e.emit_nil(),\n+        }\n+    }\n+}\n+\n /// Encodes a json value into a io::writer\n+#[cfg(stage0)]\n pub fn to_writer(wr: @io::Writer, json: &Json) {\n-    json.encode(&Encoder(wr))\n+    let encoder = Encoder(wr);\n+    json.encode(&encoder)\n+}\n+\n+/// Encodes a json value into a io::writer\n+#[cfg(not(stage0))]\n+pub fn to_writer(wr: @io::Writer, json: &Json) {\n+    let mut encoder = Encoder(wr);\n+    json.encode(&mut encoder)\n }\n \n /// Encodes a json value into a string\n@@ -402,8 +813,17 @@ pub fn to_str(json: &Json) -> ~str {\n }\n \n /// Encodes a json value into a io::writer\n+#[cfg(stage0)]\n pub fn to_pretty_writer(wr: @io::Writer, json: &Json) {\n-    json.encode(&PrettyEncoder(wr))\n+    let encoder = PrettyEncoder(wr);\n+    json.encode(&encoder)\n+}\n+\n+/// Encodes a json value into a io::writer\n+#[cfg(not(stage0))]\n+pub fn to_pretty_writer(wr: @io::Writer, json: &Json) {\n+    let mut encoder = PrettyEncoder(wr);\n+    json.encode(&mut encoder)\n }\n \n /// Encodes a json value into a string\n@@ -794,9 +1214,12 @@ pub struct Decoder {\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n-    Decoder { stack: ~[json] }\n+    Decoder {\n+        stack: ~[json]\n+    }\n }\n \n+#[cfg(stage0)]\n impl serialize::Decoder for Decoder {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n@@ -856,7 +1279,10 @@ impl serialize::Decoder for Decoder {\n         f()\n     }\n \n-    fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n+    fn read_enum_variant<T>(&self,\n+                            names: &[&str],\n+                            f: &fn(uint) -> T)\n+                            -> T {\n         debug!(\"read_enum_variant(names=%?)\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n@@ -883,13 +1309,20 @@ impl serialize::Decoder for Decoder {\n         f()\n     }\n \n-    fn read_enum_struct_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n+    fn read_enum_struct_variant<T>(&self,\n+                                   names: &[&str],\n+                                   f: &fn(uint) -> T)\n+                                   -> T {\n         debug!(\"read_enum_struct_variant(names=%?)\", names);\n         self.read_enum_variant(names, f)\n     }\n \n \n-    fn read_enum_struct_variant_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+    fn read_enum_struct_variant_field<T>(&self,\n+                                         name: &str,\n+                                         idx: uint,\n+                                         f: &fn() -> T)\n+                                         -> T {\n         debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n@@ -924,7 +1357,11 @@ impl serialize::Decoder for Decoder {\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+    fn read_struct_field<T>(&self,\n+                            name: &str,\n+                            idx: uint,\n+                            f: &fn() -> T)\n+                            -> T {\n         debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n@@ -1018,6 +1455,262 @@ impl serialize::Decoder for Decoder {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl serialize::Decoder for Decoder {\n+    fn read_nil(&mut self) -> () {\n+        debug!(\"read_nil\");\n+        match self.stack.pop() {\n+            Null => (),\n+            value => fail!(fmt!(\"not a null: %?\", value))\n+        }\n+    }\n+\n+    fn read_u64(&mut self)  -> u64  { self.read_float() as u64 }\n+    fn read_u32(&mut self)  -> u32  { self.read_float() as u32 }\n+    fn read_u16(&mut self)  -> u16  { self.read_float() as u16 }\n+    fn read_u8 (&mut self)  -> u8   { self.read_float() as u8 }\n+    fn read_uint(&mut self) -> uint { self.read_float() as uint }\n+\n+    fn read_i64(&mut self) -> i64 { self.read_float() as i64 }\n+    fn read_i32(&mut self) -> i32 { self.read_float() as i32 }\n+    fn read_i16(&mut self) -> i16 { self.read_float() as i16 }\n+    fn read_i8 (&mut self) -> i8  { self.read_float() as i8 }\n+    fn read_int(&mut self) -> int { self.read_float() as int }\n+\n+    fn read_bool(&mut self) -> bool {\n+        debug!(\"read_bool\");\n+        match self.stack.pop() {\n+            Boolean(b) => b,\n+            value => fail!(fmt!(\"not a boolean: %?\", value))\n+        }\n+    }\n+\n+    fn read_f64(&mut self) -> f64 { self.read_float() as f64 }\n+    fn read_f32(&mut self) -> f32 { self.read_float() as f32 }\n+    fn read_float(&mut self) -> float {\n+        debug!(\"read_float\");\n+        match self.stack.pop() {\n+            Number(f) => f,\n+            value => fail!(fmt!(\"not a number: %?\", value))\n+        }\n+    }\n+\n+    fn read_char(&mut self) -> char {\n+        let mut v = ~[];\n+        for str::each_char(self.read_str()) |c| { v.push(c) }\n+        if v.len() != 1 { fail!(~\"string must have one character\") }\n+        v[0]\n+    }\n+\n+    fn read_str(&mut self) -> ~str {\n+        debug!(\"read_str\");\n+        match self.stack.pop() {\n+            String(s) => s,\n+            json => fail!(fmt!(\"not a string: %?\", json))\n+        }\n+    }\n+\n+    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n+        debug!(\"read_enum(%s)\", name);\n+        f(self)\n+    }\n+\n+    fn read_enum_variant<T>(&mut self,\n+                            names: &[&str],\n+                            f: &fn(&mut Decoder, uint) -> T)\n+                            -> T {\n+        debug!(\"read_enum_variant(names=%?)\", names);\n+        let name = match self.stack.pop() {\n+            String(s) => s,\n+            List(list) => {\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                match self.stack.pop() {\n+                    String(s) => s,\n+                    value => fail!(fmt!(\"invalid variant name: %?\", value)),\n+                }\n+            }\n+            ref json => fail!(fmt!(\"invalid variant: %?\", *json)),\n+        };\n+        let idx = match vec::position(names, |n| str::eq_slice(*n, name)) {\n+            Some(idx) => idx,\n+            None => fail!(fmt!(\"Unknown variant name: %?\", name)),\n+        };\n+        f(self, idx)\n+    }\n+\n+    fn read_enum_variant_arg<T>(&mut self,\n+                                idx: uint,\n+                                f: &fn(&mut Decoder) -> T)\n+                                -> T {\n+        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+        f(self)\n+    }\n+\n+    fn read_enum_struct_variant<T>(&mut self,\n+                                   names: &[&str],\n+                                   f: &fn(&mut Decoder, uint) -> T)\n+                                   -> T {\n+        debug!(\"read_enum_struct_variant(names=%?)\", names);\n+        self.read_enum_variant(names, f)\n+    }\n+\n+\n+    fn read_enum_struct_variant_field<T>(&mut self,\n+                                         name: &str,\n+                                         idx: uint,\n+                                         f: &fn(&mut Decoder) -> T)\n+                                         -> T {\n+        debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n+        self.read_enum_variant_arg(idx, f)\n+    }\n+\n+    fn read_struct<T>(&mut self,\n+                      name: &str,\n+                      len: uint,\n+                      f: &fn(&mut Decoder) -> T)\n+                      -> T {\n+        debug!(\"read_struct(name=%s, len=%u)\", name, len);\n+        let value = f(self);\n+        self.stack.pop();\n+        value\n+    }\n+\n+    #[cfg(stage0)]\n+    fn read_field<T>(&mut self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n+        match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let value = match obj.pop(&name.to_owned()) {\n+                    None => fail!(fmt!(\"no such field: %s\", name)),\n+                    Some(json) => {\n+                        self.stack.push(json);\n+                        f()\n+                    }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n+            }\n+            value => fail!(fmt!(\"not an object: %?\", value))\n+        }\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_struct_field<T>(&mut self,\n+                            name: &str,\n+                            idx: uint,\n+                            f: &fn(&mut Decoder) -> T)\n+                            -> T {\n+        debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+        match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let value = match obj.pop(&name.to_owned()) {\n+                    None => fail!(fmt!(\"no such field: %s\", name)),\n+                    Some(json) => {\n+                        self.stack.push(json);\n+                        f(self)\n+                    }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n+            }\n+            value => fail!(fmt!(\"not an object: %?\", value))\n+        }\n+    }\n+\n+    fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        debug!(\"read_tuple()\");\n+        self.read_seq(f)\n+    }\n+\n+    fn read_tuple_arg<T>(&mut self,\n+                         idx: uint,\n+                         f: &fn(&mut Decoder) -> T)\n+                         -> T {\n+        debug!(\"read_tuple_arg(idx=%u)\", idx);\n+        self.read_seq_elt(idx, f)\n+    }\n+\n+    fn read_tuple_struct<T>(&mut self,\n+                            name: &str,\n+                            f: &fn(&mut Decoder, uint) -> T)\n+                            -> T {\n+        debug!(\"read_tuple_struct(name=%?)\", name);\n+        self.read_tuple(f)\n+    }\n+\n+    fn read_tuple_struct_arg<T>(&mut self,\n+                                idx: uint,\n+                                f: &fn(&mut Decoder) -> T)\n+                                -> T {\n+        debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+        self.read_tuple_arg(idx, f)\n+    }\n+\n+    fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n+        match self.stack.pop() {\n+            Null => f(self, false),\n+            value => { self.stack.push(value); f(self, true) }\n+        }\n+    }\n+\n+    fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        debug!(\"read_seq()\");\n+        let len = match self.stack.pop() {\n+            List(list) => {\n+                let len = list.len();\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                len\n+            }\n+            _ => fail!(~\"not a list\"),\n+        };\n+        f(self, len)\n+    }\n+\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n+        debug!(\"read_seq_elt(idx=%u)\", idx);\n+        f(self)\n+    }\n+\n+    fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        debug!(\"read_map()\");\n+        let len = match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let len = obj.len();\n+                do obj.consume |key, value| {\n+                    self.stack.push(value);\n+                    self.stack.push(String(key));\n+                }\n+                len\n+            }\n+            json => fail!(fmt!(\"not an object: %?\", json)),\n+        };\n+        f(self, len)\n+    }\n+\n+    fn read_map_elt_key<T>(&mut self,\n+                           idx: uint,\n+                           f: &fn(&mut Decoder) -> T)\n+                           -> T {\n+        debug!(\"read_map_elt_key(idx=%u)\", idx);\n+        f(self)\n+    }\n+\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+                           -> T {\n+        debug!(\"read_map_elt_val(idx=%u)\", idx);\n+        f(self)\n+    }\n+}\n+\n impl Eq for Json {\n     fn eq(&self, other: &Json) -> bool {\n         match (self) {\n@@ -1452,31 +2145,31 @@ mod tests {\n         let animal = Dog;\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = Encoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = Encoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = PrettyEncoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = PrettyEncoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = Encoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = Encoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\"\n         );\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = PrettyEncoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = PrettyEncoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"\\\n             [\\n  \\\n@@ -1491,15 +2184,15 @@ mod tests {\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n         let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = Encoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = do io::with_str_writer |wr| {\n-            let encoder = PrettyEncoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = PrettyEncoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n     }\n@@ -1508,14 +2201,14 @@ mod tests {\n     fn test_write_none() {\n         let value: Option<~str> = None;\n         let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = Encoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"null\");\n \n         let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = Encoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"null\");\n     }\n@@ -1563,13 +2256,16 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let v: () = Decodable::decode(&Decoder(from_str(~\"null\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let v: bool = Decodable::decode(&Decoder(from_str(~\"true\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"true\").unwrap());\n+        let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let v: bool = Decodable::decode(&Decoder(from_str(~\"false\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"false\").unwrap());\n+        let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n \n@@ -1603,25 +2299,32 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let v: float = Decodable::decode(&Decoder(from_str(~\"3\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"3\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"3.1\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"3.1\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"-1.2\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"-1.2\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e5\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4e5\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e15\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4e15\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e-01\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4e-01\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01f);\n     }\n \n@@ -1648,31 +2351,40 @@ mod tests {\n \n     #[test]\n     fn test_decode_str() {\n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"foo\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"foo\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n \n@@ -1704,23 +2416,28 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let v: ~[()] = Decodable::decode(&Decoder(from_str(~\"[]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[]\").unwrap());\n+        let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let v: ~[()] = Decodable::decode(&Decoder(from_str(~\"[null]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[null]\").unwrap());\n+        let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-\n-        let v: ~[bool] = Decodable::decode(&Decoder(from_str(~\"[true]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let v: ~[bool] = Decodable::decode(&Decoder(from_str(~\"[true]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let v: ~[int] = Decodable::decode(&Decoder(from_str(~\"[3, 1]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[3, 1]\").unwrap());\n+        let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let v: ~[~[uint]] = Decodable::decode(&Decoder(from_str(~\"[[3], [1, 2]]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[[3], [1, 2]]\").unwrap());\n+        let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n \n@@ -1822,7 +2539,8 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let v: Outer = Decodable::decode(&Decoder(from_str(s).unwrap()));\n+        let mut decoder = Decoder(from_str(s).unwrap());\n+        let v: Outer = Decodable::decode(&mut decoder);\n         assert_eq!(\n             v,\n             Outer {\n@@ -1835,31 +2553,32 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let decoder = Decoder(from_str(~\"null\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n-        let value: Animal = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n+        let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n-        let decoder = Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n-        let value: Animal = Decodable::decode(&decoder);\n+        let mut decoder =\n+            Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n+        let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n-        let decoder = Decoder(from_str(s).unwrap());\n-        let mut map: HashMap<~str, Animal> = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(s).unwrap());\n+        let mut map: HashMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n         assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));"}, {"sha": "33efb2c6a5af4ff2c3123be92d100885fa54c688", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 1089, "deletions": 56, "changes": 1145, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -25,6 +25,7 @@ use dlist::DList;\n #[cfg(stage3)]\n use treemap::{TreeMap, TreeSet};\n \n+#[cfg(stage0)]\n pub trait Encoder {\n     // Primitive types:\n     fn emit_nil(&self);\n@@ -48,11 +49,22 @@ pub trait Encoder {\n     // Compound types:\n     fn emit_enum(&self, name: &str, f: &fn());\n \n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, len: uint, f: &fn());\n+    fn emit_enum_variant(&self,\n+                         v_name: &str,\n+                         v_id: uint,\n+                         len: uint,\n+                         f: &fn());\n     fn emit_enum_variant_arg(&self, a_idx: uint, f: &fn());\n \n-    fn emit_enum_struct_variant(&self, v_name: &str, v_id: uint, len: uint, f: &fn());\n-    fn emit_enum_struct_variant_field(&self, f_name: &str, f_idx: uint, f: &fn());\n+    fn emit_enum_struct_variant(&self,\n+                                v_name: &str,\n+                                v_id: uint,\n+                                len: uint,\n+                                f: &fn());\n+    fn emit_enum_struct_variant_field(&self,\n+                                      f_name: &str,\n+                                      f_idx: uint,\n+                                      f: &fn());\n \n     fn emit_struct(&self, name: &str, len: uint, f: &fn());\n     #[cfg(stage0)]\n@@ -81,6 +93,73 @@ pub trait Encoder {\n     fn emit_map_elt_val(&self, idx: uint, f: &fn());\n }\n \n+#[cfg(not(stage0))]\n+pub trait Encoder {\n+    // Primitive types:\n+    fn emit_nil(&mut self);\n+    fn emit_uint(&mut self, v: uint);\n+    fn emit_u64(&mut self, v: u64);\n+    fn emit_u32(&mut self, v: u32);\n+    fn emit_u16(&mut self, v: u16);\n+    fn emit_u8(&mut self, v: u8);\n+    fn emit_int(&mut self, v: int);\n+    fn emit_i64(&mut self, v: i64);\n+    fn emit_i32(&mut self, v: i32);\n+    fn emit_i16(&mut self, v: i16);\n+    fn emit_i8(&mut self, v: i8);\n+    fn emit_bool(&mut self, v: bool);\n+    fn emit_float(&mut self, v: float);\n+    fn emit_f64(&mut self, v: f64);\n+    fn emit_f32(&mut self, v: f32);\n+    fn emit_char(&mut self, v: char);\n+    fn emit_str(&mut self, v: &str);\n+\n+    // Compound types:\n+    fn emit_enum(&mut self, name: &str, f: &fn(&mut Self));\n+\n+    fn emit_enum_variant(&mut self,\n+                         v_name: &str,\n+                         v_id: uint,\n+                         len: uint,\n+                         f: &fn(&mut Self));\n+    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: &fn(&mut Self));\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                v_name: &str,\n+                                v_id: uint,\n+                                len: uint,\n+                                f: &fn(&mut Self));\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      f_name: &str,\n+                                      f_idx: uint,\n+                                      f: &fn(&mut Self));\n+\n+    fn emit_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n+    fn emit_struct_field(&mut self,\n+                         f_name: &str,\n+                         f_idx: uint,\n+                         f: &fn(&mut Self));\n+\n+    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Self));\n+    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Self));\n+\n+    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n+    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: &fn(&mut Self));\n+\n+    // Specialized types:\n+    fn emit_option(&mut self, f: &fn(&mut Self));\n+    fn emit_option_none(&mut self);\n+    fn emit_option_some(&mut self, f: &fn(&mut Self));\n+\n+    fn emit_seq(&mut self, len: uint, f: &fn(this: &mut Self));\n+    fn emit_seq_elt(&mut self, idx: uint, f: &fn(this: &mut Self));\n+\n+    fn emit_map(&mut self, len: uint, f: &fn(&mut Self));\n+    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Self));\n+    fn emit_map_elt_val(&mut self, idx: uint, f: &fn(&mut Self));\n+}\n+\n+#[cfg(stage0)]\n pub trait Decoder {\n     // Primitive types:\n     fn read_nil(&self) -> ();\n@@ -104,19 +183,37 @@ pub trait Decoder {\n     // Compound types:\n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n \n-    fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n+    fn read_enum_variant<T>(&self,\n+                            names: &[&str],\n+                            f: &fn(uint) -> T)\n+                            -> T;\n     fn read_enum_variant_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_enum_struct_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n-    fn read_enum_struct_variant_field<T>(&self, &f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n+    fn read_enum_struct_variant<T>(&self,\n+                                   names: &[&str],\n+                                   f: &fn(uint) -> T)\n+                                   -> T;\n+    fn read_enum_struct_variant_field<T>(&self,\n+                                         &f_name: &str,\n+                                         f_idx: uint,\n+                                         f: &fn() -> T)\n+                                         -> T;\n \n     fn read_struct<T>(&self, s_name: &str, len: uint, f: &fn() -> T) -> T;\n     #[cfg(stage0)]\n-    fn read_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n+    fn read_field<T>(&self,\n+                     f_name: &str,\n+                     f_idx: uint,\n+                     f: &fn() -> T)\n+                     -> T;\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    fn read_struct_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n+    fn read_struct_field<T>(&self,\n+                            f_name: &str,\n+                            f_idx: uint,\n+                            f: &fn() -> T)\n+                            -> T;\n \n     fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T;\n     fn read_tuple_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n@@ -135,215 +232,673 @@ pub trait Decoder {\n     fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;\n }\n \n+#[cfg(not(stage0))]\n+pub trait Decoder {\n+    // Primitive types:\n+    fn read_nil(&mut self) -> ();\n+    fn read_uint(&mut self) -> uint;\n+    fn read_u64(&mut self) -> u64;\n+    fn read_u32(&mut self) -> u32;\n+    fn read_u16(&mut self) -> u16;\n+    fn read_u8(&mut self) -> u8;\n+    fn read_int(&mut self) -> int;\n+    fn read_i64(&mut self) -> i64;\n+    fn read_i32(&mut self) -> i32;\n+    fn read_i16(&mut self) -> i16;\n+    fn read_i8(&mut self) -> i8;\n+    fn read_bool(&mut self) -> bool;\n+    fn read_f64(&mut self) -> f64;\n+    fn read_f32(&mut self) -> f32;\n+    fn read_float(&mut self) -> float;\n+    fn read_char(&mut self) -> char;\n+    fn read_str(&mut self) -> ~str;\n+\n+    // Compound types:\n+    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Self) -> T) -> T;\n+\n+    fn read_enum_variant<T>(&mut self,\n+                            names: &[&str],\n+                            f: &fn(&mut Self, uint) -> T)\n+                            -> T;\n+    fn read_enum_variant_arg<T>(&mut self,\n+                                a_idx: uint,\n+                                f: &fn(&mut Self) -> T)\n+                                -> T;\n+\n+    fn read_enum_struct_variant<T>(&mut self,\n+                                   names: &[&str],\n+                                   f: &fn(&mut Self, uint) -> T)\n+                                   -> T;\n+    fn read_enum_struct_variant_field<T>(&mut self,\n+                                         &f_name: &str,\n+                                         f_idx: uint,\n+                                         f: &fn(&mut Self) -> T)\n+                                         -> T;\n+\n+    fn read_struct<T>(&mut self,\n+                      s_name: &str,\n+                      len: uint,\n+                      f: &fn(&mut Self) -> T)\n+                      -> T;\n+    #[cfg(stage0)]\n+    fn read_field<T>(&mut self,\n+                     f_name: &str,\n+                     f_idx: uint,\n+                     f: &fn() -> T)\n+                     -> T;\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_struct_field<T>(&mut self,\n+                            f_name: &str,\n+                            f_idx: uint,\n+                            f: &fn(&mut Self) -> T)\n+                            -> T;\n+\n+    fn read_tuple<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n+    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: &fn(&mut Self) -> T) -> T;\n+\n+    fn read_tuple_struct<T>(&mut self,\n+                            s_name: &str,\n+                            f: &fn(&mut Self, uint) -> T)\n+                            -> T;\n+    fn read_tuple_struct_arg<T>(&mut self,\n+                                a_idx: uint,\n+                                f: &fn(&mut Self) -> T)\n+                                -> T;\n+\n+    // Specialized types:\n+    fn read_option<T>(&mut self, f: &fn(&mut Self, bool) -> T) -> T;\n+\n+    fn read_seq<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+\n+    fn read_map<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+}\n+\n+#[cfg(stage0)]\n pub trait Encodable<S:Encoder> {\n     fn encode(&self, s: &S);\n }\n \n+#[cfg(not(stage0))]\n+pub trait Encodable<S:Encoder> {\n+    fn encode(&self, s: &mut S);\n+}\n+\n+#[cfg(stage0)]\n pub trait Decodable<D:Decoder> {\n     fn decode(d: &D) -> Self;\n }\n \n+#[cfg(not(stage0))]\n+pub trait Decodable<D:Decoder> {\n+    fn decode(d: &mut D) -> Self;\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for uint {\n-    fn encode(&self, s: &S) { s.emit_uint(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_uint(*self)\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for uint {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_uint(*self)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for uint {\n     fn decode(d: &D) -> uint {\n         d.read_uint()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for uint {\n+    fn decode(d: &mut D) -> uint {\n+        d.read_uint()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for u8 {\n-    fn encode(&self, s: &S) { s.emit_u8(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_u8(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for u8 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u8(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for u8 {\n     fn decode(d: &D) -> u8 {\n         d.read_u8()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for u8 {\n+    fn decode(d: &mut D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for u16 {\n-    fn encode(&self, s: &S) { s.emit_u16(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_u16(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for u16 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u16(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for u16 {\n     fn decode(d: &D) -> u16 {\n         d.read_u16()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for u16 {\n+    fn decode(d: &mut D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for u32 {\n-    fn encode(&self, s: &S) { s.emit_u32(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_u32(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for u32 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u32(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for u32 {\n     fn decode(d: &D) -> u32 {\n         d.read_u32()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for u32 {\n+    fn decode(d: &mut D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for u64 {\n+    fn encode(&self, s: &S) {\n+        s.emit_u64(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for u64 {\n-    fn encode(&self, s: &S) { s.emit_u64(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u64(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for u64 {\n     fn decode(d: &D) -> u64 {\n         d.read_u64()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for u64 {\n+    fn decode(d: &mut D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for int {\n-    fn encode(&self, s: &S) { s.emit_int(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_int(*self)\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for int {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_int(*self)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for int {\n     fn decode(d: &D) -> int {\n         d.read_int()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for int {\n+    fn decode(d: &mut D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for i8 {\n+    fn encode(&self, s: &S) {\n+        s.emit_i8(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i8 {\n-    fn encode(&self, s: &S) { s.emit_i8(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i8(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for i8 {\n     fn decode(d: &D) -> i8 {\n         d.read_i8()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for i8 {\n+    fn decode(d: &mut D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for i16 {\n+    fn encode(&self, s: &S) {\n+        s.emit_i16(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i16 {\n-    fn encode(&self, s: &S) { s.emit_i16(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i16(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for i16 {\n     fn decode(d: &D) -> i16 {\n         d.read_i16()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for i16 {\n+    fn decode(d: &mut D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for i32 {\n+    fn encode(&self, s: &S) {\n+        s.emit_i32(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i32 {\n-    fn encode(&self, s: &S) { s.emit_i32(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i32(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for i32 {\n     fn decode(d: &D) -> i32 {\n         d.read_i32()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for i32 {\n+    fn decode(d: &mut D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for i64 {\n-    fn encode(&self, s: &S) { s.emit_i64(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_i64(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for i64 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i64(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for i64 {\n     fn decode(d: &D) -> i64 {\n         d.read_i64()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for i64 {\n+    fn decode(d: &mut D) -> i64 {\n+        d.read_i64()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<'self, S:Encoder> Encodable<S> for &'self str {\n-    fn encode(&self, s: &S) { s.emit_str(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_str(*self)\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<'self, S:Encoder> Encodable<S> for &'self str {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for ~str {\n+    fn encode(&self, s: &S) {\n+        s.emit_str(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for ~str {\n-    fn encode(&self, s: &S) { s.emit_str(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for ~str {\n     fn decode(d: &D) -> ~str {\n         d.read_str()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for ~str {\n+    fn decode(d: &mut D) -> ~str {\n+        d.read_str()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for @str {\n+    fn encode(&self, s: &S) {\n+        s.emit_str(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for @str {\n-    fn encode(&self, s: &S) { s.emit_str(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for @str {\n-    fn decode(d: &D) -> @str { d.read_str().to_managed() }\n+    fn decode(d: &D) -> @str {\n+        d.read_str().to_managed()\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for @str {\n+    fn decode(d: &mut D) -> @str {\n+        d.read_str().to_managed()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for float {\n-    fn encode(&self, s: &S) { s.emit_float(*self) }\n+    fn encode(&self, s: &S) {\n+        s.emit_float(*self)\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for float {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_float(*self)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for float {\n     fn decode(d: &D) -> float {\n         d.read_float()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for float {\n+    fn decode(d: &mut D) -> float {\n+        d.read_float()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for f32 {\n+    fn encode(&self, s: &S) {\n+        s.emit_f32(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for f32 {\n-    fn encode(&self, s: &S) { s.emit_f32(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_f32(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for f32 {\n     fn decode(d: &D) -> f32 {\n-        d.read_f32() }\n+        d.read_f32()\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for f32 {\n+    fn decode(d: &mut D) -> f32 {\n+        d.read_f32()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for f64 {\n+    fn encode(&self, s: &S) {\n+        s.emit_f64(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for f64 {\n-    fn encode(&self, s: &S) { s.emit_f64(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_f64(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for f64 {\n     fn decode(d: &D) -> f64 {\n         d.read_f64()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for f64 {\n+    fn decode(d: &mut D) -> f64 {\n+        d.read_f64()\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<S:Encoder> Encodable<S> for bool {\n+    fn encode(&self, s: &S) {\n+        s.emit_bool(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for bool {\n-    fn encode(&self, s: &S) { s.emit_bool(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_bool(*self)\n+    }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for bool {\n     fn decode(d: &D) -> bool {\n         d.read_bool()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for bool {\n+    fn decode(d: &mut D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for () {\n-    fn encode(&self, s: &S) { s.emit_nil() }\n+    fn encode(&self, s: &S) {\n+        s.emit_nil()\n+    }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for () {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_nil()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for () {\n     fn decode(d: &D) -> () {\n         d.read_nil()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for () {\n+    fn decode(d: &mut D) -> () {\n+        d.read_nil()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n     fn encode(&self, s: &S) {\n         (**self).encode(s)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n     fn encode(&self, s: &S) {\n         (**self).encode(s)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n     fn decode(d: &D) -> ~T {\n         ~Decodable::decode(d)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n+    fn decode(d: &mut D) -> ~T {\n+        ~Decodable::decode(d)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n     fn encode(&self, s: &S) {\n         (**self).encode(s)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     fn decode(d: &D) -> @T {\n         @Decodable::decode(d)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n+    fn decode(d: &mut D) -> @T {\n+        @Decodable::decode(d)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &S) {\n         do s.emit_seq(self.len()) {\n@@ -354,6 +909,18 @@ impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            for self.eachi |i, e| {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_seq(self.len()) {\n@@ -364,6 +931,18 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            for self.eachi |i, e| {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     fn decode(d: &D) -> ~[T] {\n         do d.read_seq |len| {\n@@ -374,6 +953,18 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n+    fn decode(d: &mut D) -> ~[T] {\n+        do d.read_seq |d, len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_seq(self.len()) {\n@@ -384,6 +975,18 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            for self.eachi |i, e| {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     fn decode(d: &D) -> @[T] {\n         do d.read_seq |len| {\n@@ -394,6 +997,18 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n+    fn decode(d: &mut D) -> @[T] {\n+        do d.read_seq |d, len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &S) {\n         do s.emit_option {\n@@ -405,6 +1020,19 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_option |s| {\n+            match *self {\n+                None => s.emit_option_none(),\n+                Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     fn decode(d: &D) -> Option<T> {\n         do d.read_option |b| {\n@@ -417,6 +1045,20 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n+    fn decode(d: &mut D) -> Option<T> {\n+        do d.read_option |d, b| {\n+            if b {\n+                Some(Decodable::decode(d))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     fn encode(&self, s: &S) {\n         match *self {\n@@ -430,6 +1072,21 @@ impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_seq(2) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     fn decode(d: &D) -> (T0, T1) {\n         do d.read_seq |len| {\n@@ -442,6 +1099,20 @@ impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n+    fn decode(d: &mut D) -> (T0, T1) {\n+        do d.read_seq |d, len| {\n+            assert!(len == 2);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     S: Encoder,\n     T0: Encodable<S>,\n@@ -461,6 +1132,27 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>\n+> Encodable<S> for (T0, T1, T2) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_seq(3) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     D: Decoder,\n     T0: Decodable<D>,\n@@ -479,6 +1171,26 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>\n+> Decodable<D> for (T0, T1, T2) {\n+    fn decode(d: &mut D) -> (T0, T1, T2) {\n+        do d.read_seq |d, len| {\n+            assert!(len == 3);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     S: Encoder,\n     T0: Encodable<S>,\n@@ -500,6 +1212,29 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>\n+> Encodable<S> for (T0, T1, T2, T3) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_seq(4) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                    s.emit_seq_elt(3, |s| t3.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     D: Decoder,\n     T0: Decodable<D>,\n@@ -520,6 +1255,28 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>\n+> Decodable<D> for (T0, T1, T2, T3) {\n+    fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n+        do d.read_seq |d, len| {\n+            assert!(len == 4);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d)),\n+                d.read_seq_elt(3, |d| Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     S: Encoder,\n     T0: Encodable<S>,\n@@ -543,6 +1300,31 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>,\n+    T4: Encodable<S>\n+> Encodable<S> for (T0, T1, T2, T3, T4) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_seq(5) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                    s.emit_seq_elt(3, |s| t3.encode(s));\n+                    s.emit_seq_elt(4, |s| t4.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     D: Decoder,\n     T0: Decodable<D>,\n@@ -551,8 +1333,7 @@ impl<\n     T3: Decodable<D>,\n     T4: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n-    fn decode(d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n+    fn decode(d: &D) -> (T0, T1, T2, T3, T4) {\n         do d.read_seq |len| {\n             assert!(len == 5);\n             (\n@@ -566,6 +1347,30 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>,\n+    T4: Decodable<D>\n+> Decodable<D> for (T0, T1, T2, T3, T4) {\n+    fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n+        do d.read_seq |d, len| {\n+            assert!(len == 5);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d)),\n+                d.read_seq_elt(3, |d| Decodable::decode(d)),\n+                d.read_seq_elt(4, |d| Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Copy\n@@ -581,6 +1386,23 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Copy\n+> Encodable<S> for @mut DList<T> {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.size) |s| {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n     fn decode(d: &D) -> @mut DList<T> {\n         let list = DList();\n@@ -593,6 +1415,20 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n+    fn decode(d: &mut D) -> @mut DList<T> {\n+        let list = DList();\n+        do d.read_seq |d, len| {\n+            for uint::range(0, len) |i| {\n+                list.push(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+        }\n+        list\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     S: Encoder,\n     T: Encodable<S>\n@@ -606,6 +1442,21 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for Deque<T> {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            for self.eachi |i, e| {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n     fn decode(d: &D) -> Deque<T> {\n         let mut deque = Deque::new();\n@@ -618,6 +1469,20 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n+    fn decode(d: &mut D) -> Deque<T> {\n+        let mut deque = Deque::new();\n+        do d.read_seq |d, len| {\n+            for uint::range(0, len) |i| {\n+                deque.add_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+        }\n+        deque\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     E: Encoder,\n     K: Encodable<E> + Hash + IterBytes + Eq,\n@@ -635,6 +1500,25 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Hash + IterBytes + Eq,\n+    V: Encodable<E>\n+> Encodable<E> for HashMap<K, V> {\n+    fn encode(&self, e: &mut E) {\n+        do e.emit_map(self.len()) |e| {\n+            let mut i = 0;\n+            for self.each |key, val| {\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     D: Decoder,\n     K: Decodable<D> + Hash + IterBytes + Eq,\n@@ -653,6 +1537,26 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Hash + IterBytes + Eq,\n+    V: Decodable<D>\n+> Decodable<D> for HashMap<K, V> {\n+    fn decode(d: &mut D) -> HashMap<K, V> {\n+        do d.read_map |d, len| {\n+            let mut map = HashMap::with_capacity(len);\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Hash + IterBytes + Eq\n@@ -668,6 +1572,23 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Hash + IterBytes + Eq\n+> Encodable<S> for HashSet<T> {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     D: Decoder,\n     T: Decodable<D> + Hash + IterBytes + Eq\n@@ -683,6 +1604,23 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Hash + IterBytes + Eq\n+> Decodable<D> for HashSet<T> {\n+    fn decode(d: &mut D) -> HashSet<T> {\n+        do d.read_seq |d, len| {\n+            let mut set = HashSet::with_capacity(len);\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     E: Encoder,\n     V: Encodable<E>\n@@ -699,6 +1637,24 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    E: Encoder,\n+    V: Encodable<E>\n+> Encodable<E> for TrieMap<V> {\n+    fn encode(&self, e: &mut E) {\n+        do e.emit_map(self.len()) |e| {\n+            let mut i = 0;\n+            for self.each |key, val| {\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<\n     D: Decoder,\n     V: Decodable<D>\n@@ -716,6 +1672,25 @@ impl<\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<\n+    D: Decoder,\n+    V: Decodable<D>\n+> Decodable<D> for TrieMap<V> {\n+    fn decode(d: &mut D) -> TrieMap<V> {\n+        do d.read_map |d, len| {\n+            let mut map = TrieMap::new();\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &S) {\n         do s.emit_seq(self.len()) {\n@@ -728,6 +1703,20 @@ impl<S: Encoder> Encodable<S> for TrieSet {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S: Encoder> Encodable<S> for TrieSet {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D: Decoder> Decodable<D> for TrieSet {\n     fn decode(d: &D) -> TrieSet {\n         do d.read_seq |len| {\n@@ -740,77 +1729,82 @@ impl<D: Decoder> Decodable<D> for TrieSet {\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n+impl<D: Decoder> Decodable<D> for TrieSet {\n+    fn decode(d: &mut D) -> TrieSet {\n+        do d.read_seq |d, len| {\n+            let mut set = TrieSet::new();\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<\n     E: Encoder,\n     K: Encodable<E> + Eq + TotalOrd,\n     V: Encodable<E> + Eq\n > Encodable<E> for TreeMap<K, V> {\n-    fn encode(&self, e: &E) {\n-        do e.emit_map(self.len()) {\n+    fn encode(&self, e: &mut E) {\n+        do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n             for self.each |key, val| {\n-                e.emit_map_elt_key(i, || key.encode(e));\n-                e.emit_map_elt_val(i, || val.encode(e));\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n         }\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     K: Decodable<D> + Eq + TotalOrd,\n     V: Decodable<D> + Eq\n > Decodable<D> for TreeMap<K, V> {\n-    fn decode(d: &D) -> TreeMap<K, V> {\n-        do d.read_map |len| {\n+    fn decode(d: &mut D) -> TreeMap<K, V> {\n+        do d.read_map |d, len| {\n             let mut map = TreeMap::new();\n             for uint::range(0, len) |i| {\n-                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n         }\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Eq + TotalOrd\n > Encodable<S> for TreeSet<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n             for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n+                s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     T: Decodable<D> + Eq + TotalOrd\n > Decodable<D> for TreeSet<T> {\n-    fn decode(d: &D) -> TreeSet<T> {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> TreeSet<T> {\n+        do d.read_seq |d, len| {\n             let mut set = TreeSet::new();\n             for uint::range(0, len) |i| {\n-                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n         }\n@@ -822,10 +1816,17 @@ impl<\n //\n // In some cases, these should eventually be coded as traits.\n \n+#[cfg(stage0)]\n pub trait EncoderHelpers {\n     fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T));\n }\n \n+#[cfg(not(stage0))]\n+pub trait EncoderHelpers {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut Self, v: &T));\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T)) {\n         do self.emit_seq(v.len()) {\n@@ -838,10 +1839,30 @@ impl<S:Encoder> EncoderHelpers for S {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> EncoderHelpers for S {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n+        do self.emit_seq(v.len()) |this| {\n+            for v.eachi |i, e| {\n+                do this.emit_seq_elt(i) |this| {\n+                    f(this, e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n pub trait DecoderHelpers {\n     fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T];\n }\n \n+#[cfg(not(stage0))]\n+pub trait DecoderHelpers {\n+    fn read_to_vec<T>(&mut self, f: &fn(&mut Self) -> T) -> ~[T];\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T] {\n         do self.read_seq |len| {\n@@ -851,3 +1872,15 @@ impl<D:Decoder> DecoderHelpers for D {\n         }\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl<D:Decoder> DecoderHelpers for D {\n+    fn read_to_vec<T>(&mut self, f: &fn(&mut D) -> T) -> ~[T] {\n+        do self.read_seq |this, len| {\n+            do vec::from_fn(len) |i| {\n+                this.read_seq_elt(i, |this| f(this))\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "2cdf36c71c79fbf9e2aee6c5b1e8d9865a82efa1", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -140,6 +140,7 @@ impl WorkMap {\n     fn new() -> WorkMap { WorkMap(HashMap::new()) }\n }\n \n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &S) {\n         let mut d = ~[];\n@@ -151,6 +152,19 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for WorkMap {\n+    fn encode(&self, s: &mut S) {\n+        let mut d = ~[];\n+        for self.each |k, v| {\n+            d.push((copy *k, copy *v))\n+        }\n+        sort::tim_sort(d);\n+        d.encode(s)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n@@ -162,6 +176,18 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for WorkMap {\n+    fn decode(d: &mut D) -> WorkMap {\n+        let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n+        let mut w = WorkMap::new();\n+        for v.each |&(k, v)| {\n+            w.insert(copy k, copy v);\n+        }\n+        w\n+    }\n+}\n+\n struct Database {\n     db_filename: Path,\n     db_cache: HashMap<~str, ~str>,\n@@ -171,8 +197,8 @@ struct Database {\n pub impl Database {\n     fn prepare(&mut self,\n                fn_name: &str,\n-               declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n-    {\n+               declared_inputs: &WorkMap)\n+               -> Option<(WorkMap, WorkMap, ~str)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n@@ -229,17 +255,38 @@ struct Work<T> {\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n+#[cfg(stage0)]\n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n     do io::with_str_writer |wr| {\n         t.encode(&json::Encoder(wr));\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n+    do io::with_str_writer |wr| {\n+        let mut encoder = json::Encoder(wr);\n+        t.encode(&mut encoder);\n+    }\n+}\n+\n+// FIXME(#5121)\n+#[cfg(stage0)]\n+fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n+    do io::with_str_reader(s) |rdr| {\n+        let j = result::unwrap(json::from_reader(rdr));\n+        let decoder = json::Decoder(j);\n+        Decodable::decode(&decoder)\n+    }\n+}\n+\n // FIXME(#5121)\n+#[cfg(not(stage0))]\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n-        Decodable::decode(&json::Decoder(j))\n+        let mut decoder = json::Decoder(j);\n+        Decodable::decode(&mut decoder)\n     }\n }\n "}, {"sha": "77e79866160864a93dd02f925613efe3668c3a1d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -70,21 +70,53 @@ pub type Name = uint;\n // with a macro expansion\n pub type Mrk = uint;\n \n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &S) {\n+        unsafe {\n+            let intr =\n+                match task::local_data::local_data_get(interner_key!()) {\n+                    None => fail!(~\"encode: TLS interner not set up\"),\n+                    Some(intr) => intr\n+                };\n+\n+            s.emit_str(*(*intr).get(*self));\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for ident {\n+    fn encode(&self, s: &mut S) {\n+        unsafe {\n+            let intr =\n+                match task::local_data::local_data_get(interner_key!()) {\n+                    None => fail!(~\"encode: TLS interner not set up\"),\n+                    Some(intr) => intr\n+                };\n+\n+            s.emit_str(*(*intr).get(*self));\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<D:Decoder> Decodable<D> for ident {\n+    fn decode(d: &D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n-            None => fail!(~\"encode: TLS interner not set up\"),\n+            None => fail!(~\"decode: TLS interner not set up\"),\n             Some(intr) => intr\n         };\n \n-        s.emit_str(*(*intr).get(*self));\n+        (*intr).intern(@d.read_str())\n     }\n }\n \n+#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for ident {\n-    fn decode(d: &D) -> ident {\n+    fn decode(d: &mut D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {"}, {"sha": "bbb390e9dc9486cc1d2c918ef7f37ff6703b94ae", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -125,17 +125,34 @@ impl cmp::Eq for span {\n     fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, _s: &S) { _s.emit_nil() }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder> Encodable<S> for span {\n+    /* Note #1972 -- spans are encoded but not decoded */\n+    fn encode(&self, s: &mut S) {\n+        s.emit_nil()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for span {\n     fn decode(_d: &D) -> span {\n         dummy_sp()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder> Decodable<D> for span {\n+    fn decode(_d: &mut D) -> span {\n+        dummy_sp()\n+    }\n+}\n+\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }"}, {"sha": "bdf0a2a1dd07c10b71cba074a98b908003a9bf67", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 200, "deletions": 104, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -238,7 +238,8 @@ trait ExtCtxtMethods {\n     fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n     fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n     fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n-    fn lambda(&self, blk: ast::blk) -> @ast::expr;\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n     fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n     fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n     fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n@@ -254,8 +255,15 @@ trait ExtCtxtMethods {\n                         ident: ast::ident,\n                         args: ~[@ast::expr])\n                         -> @ast::expr;\n-    fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n+                    -> @ast::expr;\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_1(&self,\n+                      span: span,\n+                      stmts: ~[@ast::stmt],\n+                      ident: ast::ident)\n+                      -> @ast::expr;\n }\n \n impl ExtCtxtMethods for @ext_ctxt {\n@@ -388,12 +396,18 @@ impl ExtCtxtMethods for @ext_ctxt {\n                                 span: span}))\n     }\n \n-    fn lambda(&self, blk: ast::blk) -> @ast::expr {\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n         quote_expr!( || $blk_e )\n     }\n \n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n+        let ext_cx = *self;\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        quote_expr!( |$ident| $blk_e )\n+    }\n+\n     fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n         codemap::spanned {\n             node: ast::blk_ {\n@@ -461,15 +475,29 @@ impl ExtCtxtMethods for @ext_ctxt {\n         ident: ast::ident,\n         args: ~[@ast::expr]\n     ) -> @ast::expr {\n-        self.expr(span, ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+        self.expr(span,\n+                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+    }\n+\n+    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n+        self.lambda0(self.expr_blk(expr))\n+    }\n+\n+    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n+                    -> @ast::expr {\n+        self.lambda1(self.expr_blk(expr), ident)\n     }\n \n-    fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr {\n-        self.lambda(self.expr_blk(expr))\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda0(self.blk(span, stmts))\n     }\n \n-    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda(self.blk(span, stmts))\n+    fn lambda_stmts_1(&self,\n+                      span: span,\n+                      stmts: ~[@ast::stmt],\n+                      ident: ast::ident)\n+                      -> @ast::expr {\n+        self.lambda1(self.blk(span, stmts), ident)\n     }\n }\n \n@@ -644,7 +672,7 @@ fn mk_ser_method(\n             None,\n             ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n-                mutbl: ast::m_imm\n+                mutbl: ast::m_mutbl\n             }\n         ),\n         span: span,\n@@ -706,7 +734,7 @@ fn mk_deser_method(\n             None,\n             ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n-                mutbl: ast::m_imm\n+                mutbl: ast::m_mutbl\n             }\n         ),\n         span: span,\n@@ -758,8 +786,8 @@ fn mk_struct_ser_impl(\n     generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n-        // ast for `|| self.$(name).encode(__s)`\n-        let expr_lambda = cx.lambda_expr(\n+        // ast for `|__s| self.$(name).encode(__s)`\n+        let expr_lambda = cx.lambda_expr_1(\n             cx.expr_method_call(\n                 span,\n                 cx.expr_field(\n@@ -769,7 +797,8 @@ fn mk_struct_ser_impl(\n                 ),\n                 cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n-            )\n+            ),\n+            cx.ident_of(~\"__s\")\n         );\n \n         // ast for `__s.emit_struct_field($(name), $(idx), $(expr_lambda))`\n@@ -787,15 +816,15 @@ fn mk_struct_ser_impl(\n         )\n     };\n \n-    // ast for `__s.emit_struct($(name), || $(fields))`\n+    // ast for `__s.emit_struct($(name), |__s| $(fields))`\n     let ser_body = cx.expr_method_call(\n         span,\n         cx.expr_var(span, ~\"__s\"),\n         cx.ident_of(~\"emit_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n-            cx.lambda_stmts(span, fields),\n+            cx.lambda_stmts_1(span, fields, cx.ident_of(~\"__s\")),\n         ]\n     );\n \n@@ -810,8 +839,8 @@ fn mk_struct_deser_impl(\n     generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n-        // ast for `|| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda(\n+        // ast for `|__d| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda1(\n             cx.expr_blk(\n                 cx.expr_call(\n                     span,\n@@ -823,7 +852,8 @@ fn mk_struct_deser_impl(\n                     ]),\n                     ~[cx.expr_var(span, ~\"__d\")]\n                 )\n-            )\n+            ),\n+            cx.ident_of(~\"__d\")\n         );\n \n         // ast for `__d.read_struct_field($(name), $(idx), $(expr_lambda))`\n@@ -848,23 +878,24 @@ fn mk_struct_deser_impl(\n         }\n     };\n \n-    // ast for `read_struct($(name), || $(fields))`\n+    // ast for `read_struct($(name), |__d| $(fields))`\n     let body = cx.expr_method_call(\n         span,\n         cx.expr_var(span, ~\"__d\"),\n         cx.ident_of(~\"read_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n-            cx.lambda_expr(\n+            cx.lambda_expr_1(\n                 cx.expr(\n                     span,\n                     ast::expr_struct(\n                         cx.path(span, ~[ident]),\n                         fields,\n                         None\n                     )\n-                )\n+                ),\n+                cx.ident_of(~\"__d\")\n             ),\n         ]\n     );\n@@ -974,14 +1005,15 @@ fn ser_variant(\n             cx.ident_of(~\"emit_enum_variant_arg\")\n         );\n \n-        // ast for `|| $(v).encode(__s)`\n-        let expr_encode = cx.lambda_expr(\n-             cx.expr_method_call(\n+        // ast for `|__s| $(v).encode(__s)`\n+        let expr_encode = cx.lambda_expr_1(\n+            cx.expr_method_call(\n                 span,\n                  cx.expr_path(span, ~[names[a_idx]]),\n                  cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n-            )\n+            ),\n+            cx.ident_of(~\"__s\")\n         );\n \n         // ast for `$(expr_emit)($(a_idx), $(expr_encode))`\n@@ -1003,7 +1035,7 @@ fn ser_variant(\n             cx.lit_str(span, @cx.str_of(v_name)),\n             cx.lit_uint(span, v_idx),\n             cx.lit_uint(span, stmts.len()),\n-            cx.lambda_stmts(span, stmts),\n+            cx.lambda_stmts_1(span, stmts, cx.ident_of(~\"__s\")),\n         ]\n     );\n \n@@ -1050,7 +1082,7 @@ fn mk_enum_ser_body(\n         cx.ident_of(~\"emit_enum\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(name)),\n-            cx.lambda_expr(match_expr),\n+            cx.lambda_expr_1(match_expr, cx.ident_of(~\"__s\")),\n         ]\n     )\n }\n@@ -1062,8 +1094,8 @@ fn mk_enum_deser_variant_nary(\n     args: ~[ast::variant_arg]\n ) -> @ast::expr {\n     let args = do args.mapi |idx, _arg| {\n-        // ast for `|| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda_expr(\n+        // ast for `|__s| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda_expr_1(\n             cx.expr_call(\n                 span,\n                 cx.expr_path_global(span, ~[\n@@ -1073,7 +1105,8 @@ fn mk_enum_deser_variant_nary(\n                     cx.ident_of(~\"decode\"),\n                 ]),\n                 ~[cx.expr_var(span, ~\"__d\")]\n-            )\n+            ),\n+            cx.ident_of(~\"__d\")\n         );\n \n         // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n@@ -1163,24 +1196,44 @@ fn mk_enum_deser_body(\n         span,\n         ast::expr_fn_block(\n             ast::fn_decl {\n-                inputs: ~[ast::arg {\n-                    is_mutbl: false,\n-                    ty: @ast::Ty {\n+                inputs: ~[\n+                    ast::arg {\n+                        is_mutbl: false,\n+                        ty: @ast::Ty {\n+                            id: ext_cx.next_id(),\n+                            node: ast::ty_infer,\n+                            span: span\n+                        },\n+                        pat: @ast::pat {\n+                            id: ext_cx.next_id(),\n+                            node: ast::pat_ident(\n+                                ast::bind_by_copy,\n+                                ast_util::ident_to_path(span,\n+                                    ext_cx.ident_of(~\"__d\")),\n+                                None),\n+                            span: span,\n+                        },\n                         id: ext_cx.next_id(),\n-                        node: ast::ty_infer,\n-                        span: span\n                     },\n-                    pat: @ast::pat {\n+                    ast::arg {\n+                        is_mutbl: false,\n+                        ty: @ast::Ty {\n+                            id: ext_cx.next_id(),\n+                            node: ast::ty_infer,\n+                            span: span\n+                        },\n+                        pat: @ast::pat {\n+                            id: ext_cx.next_id(),\n+                            node: ast::pat_ident(\n+                                ast::bind_by_copy,\n+                                ast_util::ident_to_path(span,\n+                                    ext_cx.ident_of(~\"i\")),\n+                                None),\n+                            span: span,\n+                        },\n                         id: ext_cx.next_id(),\n-                        node: ast::pat_ident(\n-                            ast::bind_by_copy,\n-                            ast_util::ident_to_path(span,\n-                                ext_cx.ident_of(~\"i\")),\n-                            None),\n-                        span: span,\n-                    },\n-                    id: ext_cx.next_id(),\n-                }],\n+                    }\n+                ],\n                 output: @ast::Ty {\n                     id: ext_cx.next_id(),\n                     node: ast::ty_infer,\n@@ -1198,13 +1251,14 @@ fn mk_enum_deser_body(\n     );\n \n     // ast for `__d.read_enum_variant($expr_arm_names, $(expr_lambda))`\n-    let expr_lambda = ext_cx.lambda_expr(\n+    let expr_lambda = ext_cx.lambda_expr_1(\n         ext_cx.expr_method_call(\n             span,\n             ext_cx.expr_var(span, ~\"__d\"),\n             ext_cx.ident_of(~\"read_enum_variant\"),\n             ~[expr_arm_names, expr_lambda]\n-        )\n+        ),\n+        ext_cx.ident_of(~\"__d\")\n     );\n \n     // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n@@ -1256,105 +1310,147 @@ mod test {\n     }\n \n     impl Encoder for TestEncoder {\n-        fn emit_nil(&self) { self.add_to_log(CallToEmitNil) }\n+        fn emit_nil(&mut self) { self.add_to_log(CallToEmitNil) }\n \n-        fn emit_uint(&self, v: uint) {self.add_to_log(CallToEmitUint(v)); }\n-        fn emit_u64(&self, _v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&self, _v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&self, _v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&self, _v: u8)   { self.add_unknown_to_log(); }\n+        fn emit_uint(&mut self, v: uint) {\n+            self.add_to_log(CallToEmitUint(v));\n+        }\n+        fn emit_u64(&mut self, _v: u64) { self.add_unknown_to_log(); }\n+        fn emit_u32(&mut self, _v: u32) { self.add_unknown_to_log(); }\n+        fn emit_u16(&mut self, _v: u16) { self.add_unknown_to_log(); }\n+        fn emit_u8(&mut self, _v: u8)   { self.add_unknown_to_log(); }\n \n-        fn emit_int(&self, _v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&self, _v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&self, _v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&self, _v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&self, _v: i8)   { self.add_unknown_to_log(); }\n+        fn emit_int(&mut self, _v: int) { self.add_unknown_to_log(); }\n+        fn emit_i64(&mut self, _v: i64) { self.add_unknown_to_log(); }\n+        fn emit_i32(&mut self, _v: i32) { self.add_unknown_to_log(); }\n+        fn emit_i16(&mut self, _v: i16) { self.add_unknown_to_log(); }\n+        fn emit_i8(&mut self, _v: i8)   { self.add_unknown_to_log(); }\n \n-        fn emit_bool(&self, _v: bool) { self.add_unknown_to_log(); }\n+        fn emit_bool(&mut self, _v: bool) { self.add_unknown_to_log(); }\n \n-        fn emit_f64(&self, _v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&self, _v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&self, _v: float) { self.add_unknown_to_log(); }\n+        fn emit_f64(&mut self, _v: f64) { self.add_unknown_to_log(); }\n+        fn emit_f32(&mut self, _v: f32) { self.add_unknown_to_log(); }\n+        fn emit_float(&mut self, _v: float) { self.add_unknown_to_log(); }\n \n-        fn emit_char(&self, _v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&self, _v: &str) { self.add_unknown_to_log(); }\n+        fn emit_char(&mut self, _v: char) { self.add_unknown_to_log(); }\n+        fn emit_str(&mut self, _v: &str) { self.add_unknown_to_log(); }\n \n-        fn emit_enum(&self, name: &str, f: &fn()) {\n-            self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n+        fn emit_enum(&mut self, name: &str, f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnum(name.to_str()));\n+            f(self);\n+        }\n \n-        fn emit_enum_variant(&self, name: &str, id: uint,\n-                             cnt: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n-            f();\n+        fn emit_enum_variant(&mut self,\n+                             name: &str,\n+                             id: uint,\n+                             cnt: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnumVariant(name.to_str(), id, cnt));\n+            f(self);\n         }\n \n-        fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n+        fn emit_enum_variant_arg(&mut self,\n+                                 idx: uint,\n+                                 f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnumVariantArg(idx));\n+            f(self);\n         }\n \n-        fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+        fn emit_enum_struct_variant(&mut self,\n+                                    name: &str,\n+                                    id: uint,\n+                                    cnt: uint,\n+                                    f: &fn(&mut TestEncoder)) {\n             self.emit_enum_variant(name, id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field(&self, _name: &str, idx: uint, f: &fn()) {\n+        fn emit_enum_struct_variant_field(&mut self,\n+                                          _name: &str,\n+                                          idx: uint,\n+                                          f: &fn(&mut TestEncoder)) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&self, name: &str, len: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n+        fn emit_struct(&mut self,\n+                       name: &str,\n+                       len: uint,\n+                       f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitStruct (name.to_str(),len));\n+            f(self);\n         }\n-        fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n+        fn emit_struct_field(&mut self,\n+                             name: &str,\n+                             idx: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitField (name.to_str(),idx));\n+            f(self);\n         }\n \n-        fn emit_tuple(&self, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_tuple(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_tuple_arg(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_tuple_arg(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n \n-        fn emit_tuple_struct(&self, _name: &str, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_tuple_struct(&mut self,\n+                             _name: &str,\n+                             _len: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_tuple_struct_arg(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+\n+        fn emit_tuple_struct_arg(&mut self,\n+                                 _idx: uint,\n+                                 f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n \n-        fn emit_option(&self, f: &fn()) {\n+        fn emit_option(&mut self, f: &fn(&mut TestEncoder)) {\n             self.add_to_log(CallToEmitOption);\n-            f();\n+            f(self);\n         }\n-        fn emit_option_none(&self) {\n+        fn emit_option_none(&mut self) {\n             self.add_to_log(CallToEmitOptionNone);\n         }\n-        fn emit_option_some(&self, f: &fn()) {\n+        fn emit_option_some(&mut self, f: &fn(&mut TestEncoder)) {\n             self.add_to_log(CallToEmitOptionSome);\n-            f();\n+            f(self);\n         }\n \n-        fn emit_seq(&self, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_seq(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n \n-        fn emit_map(&self, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_map(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_map_elt_key(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n     }\n \n \n     fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n-        let mut te = TestEncoder {call_log: @mut ~[]};\n-        val.encode(&te);\n+        let mut te = TestEncoder {\n+            call_log: @mut ~[]\n+        };\n+        val.encode(&mut te);\n         copy *te.call_log\n     }\n "}, {"sha": "fe270abc2e4f224d017f14ac6e908a3f93a64273", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -96,7 +96,7 @@ fn create_decode_method(\n         cx,\n         span,\n         build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\")),\n-        ast::m_imm\n+        ast::m_mutbl\n     );\n     let d_ident = cx.ident_of(~\"__d\");\n     let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n@@ -219,6 +219,11 @@ fn create_read_struct_field(\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n+    let d_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__d\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     let call_expr = build::mk_method_call(\n         cx,\n         span,\n@@ -227,7 +232,11 @@ fn create_read_struct_field(\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(ident)),\n             build::mk_uint(cx, span, idx),\n-            build::mk_lambda_no_args(cx, span, decode_expr),\n+            build::mk_lambda(cx,\n+                             span,\n+                             build::mk_fn_decl(~[d_arg],\n+                                               build::mk_ty_infer(cx, span)),\n+                             decode_expr),\n         ]\n     );\n \n@@ -282,6 +291,11 @@ fn expand_deriving_decodable_struct_method(\n         i += 1;\n     }\n \n+    let d_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__d\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     let read_struct_expr = build::mk_method_call(\n         cx,\n         span,\n@@ -294,9 +308,10 @@ fn expand_deriving_decodable_struct_method(\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n             build::mk_uint(cx, span, fields.len()),\n-            build::mk_lambda_no_args(\n+            build::mk_lambda(\n                 cx,\n                 span,\n+                build::mk_fn_decl(~[d_arg], build::mk_ty_infer(cx, span)),\n                 build::mk_struct_e(\n                     cx,\n                     span,\n@@ -334,14 +349,23 @@ fn create_read_variant_arg(\n             // Call the substructure method.\n             let expr = call_substructure_decode_method(cx, span);\n \n+            let d_arg = build::mk_arg(cx,\n+                                      span,\n+                                      cx.ident_of(~\"__d\"),\n+                                      build::mk_ty_infer(cx, span));\n+            let t_infer = build::mk_ty_infer(cx, span);\n+\n             let call_expr = build::mk_method_call(\n                 cx,\n                 span,\n                 build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n                 cx.ident_of(~\"read_enum_variant_arg\"),\n                 ~[\n                     build::mk_uint(cx, span, j),\n-                    build::mk_lambda_no_args(cx, span, expr),\n+                    build::mk_lambda(cx,\n+                                     span,\n+                                     build::mk_fn_decl(~[d_arg], t_infer),\n+                                     expr),\n                 ]\n             );\n \n@@ -399,6 +423,12 @@ fn create_read_enum_variant(\n                 span,\n                 build::mk_fn_decl(\n                     ~[\n+                        build::mk_arg(\n+                            cx,\n+                            span,\n+                            cx.ident_of(~\"__d\"),\n+                            build::mk_ty_infer(cx, span)\n+                        ),\n                         build::mk_arg(\n                             cx,\n                             span,\n@@ -434,6 +464,11 @@ fn expand_deriving_decodable_enum_method(\n         enum_definition\n     );\n \n+    let d_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__d\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     // Create the read_enum expression\n     let read_enum_expr = build::mk_method_call(\n         cx,\n@@ -442,7 +477,11 @@ fn expand_deriving_decodable_enum_method(\n         cx.ident_of(~\"read_enum\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_lambda_no_args(cx, span, read_enum_variant_expr),\n+            build::mk_lambda(cx,\n+                             span,\n+                             build::mk_fn_decl(~[d_arg],\n+                                               build::mk_ty_infer(cx, span)),\n+                             read_enum_variant_expr),\n         ]\n     );\n "}, {"sha": "8f8139790ade9be66bbd42512751e154318f4c94", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -94,10 +94,9 @@ fn create_encode_method(\n         cx,\n         span,\n         build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\")),\n-        ast::m_imm\n+        ast::m_mutbl\n     );\n-    let e_ident = cx.ident_of(~\"__e\");\n-    let e_arg = build::mk_arg(cx, span, e_ident, e_arg_type);\n+    let e_arg = build::mk_arg(cx, span, cx.ident_of(~\"__e\"), e_arg_type);\n \n     // Create the type of the return value.\n     let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n@@ -226,10 +225,16 @@ fn expand_deriving_encodable_struct_method(\n                     self_field\n                 );\n \n+                let e_ident = cx.ident_of(~\"__e\");\n+                let e_arg = build::mk_arg(cx,\n+                                          span,\n+                                          e_ident,\n+                                          build::mk_ty_infer(cx, span));\n+\n                 let blk_expr = build::mk_lambda(\n                     cx,\n                     span,\n-                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                     encode_expr\n                 );\n \n@@ -257,6 +262,11 @@ fn expand_deriving_encodable_struct_method(\n         idx += 1;\n     }\n \n+    let e_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__e\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     let emit_struct_stmt = build::mk_method_call(\n         cx,\n         span,\n@@ -272,7 +282,7 @@ fn expand_deriving_encodable_struct_method(\n             build::mk_lambda_stmts(\n                 cx,\n                 span,\n-                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                 statements\n             ),\n         ]\n@@ -309,10 +319,16 @@ fn expand_deriving_encodable_enum_method(\n             // Call the substructure method.\n             let expr = call_substructure_encode_method(cx, span, field);\n \n+            let e_ident = cx.ident_of(~\"__e\");\n+            let e_arg = build::mk_arg(cx,\n+                                      span,\n+                                      e_ident,\n+                                      build::mk_ty_infer(cx, span));\n+\n             let blk_expr = build::mk_lambda(\n                 cx,\n                 span,\n-                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                 expr\n             );\n \n@@ -331,6 +347,10 @@ fn expand_deriving_encodable_enum_method(\n         }\n \n         // Create the pattern body.\n+        let e_arg = build::mk_arg(cx,\n+                                  span,\n+                                  cx.ident_of(~\"__e\"),\n+                                  build::mk_ty_infer(cx, span));\n         let call_expr = build::mk_method_call(\n             cx,\n             span,\n@@ -343,7 +363,7 @@ fn expand_deriving_encodable_enum_method(\n                 build::mk_lambda_stmts(\n                     cx,\n                     span,\n-                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                     stmts\n                 )\n             ]\n@@ -359,11 +379,17 @@ fn expand_deriving_encodable_enum_method(\n         }\n     };\n \n+    let e_ident = cx.ident_of(~\"__e\");\n+    let e_arg = build::mk_arg(cx,\n+                              span,\n+                              e_ident,\n+                              build::mk_ty_infer(cx, span));\n+\n     // Create the method body.\n     let lambda_expr = build::mk_lambda(\n         cx,\n         span,\n-        build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+        build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n         expand_enum_or_struct_match(cx, span, arms)\n     );\n "}, {"sha": "0c024958a24d8c3af92d55d24591d7884c5e7d62", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -420,7 +420,8 @@ mod test {\n \n     #[cfg(test)] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n         do io::with_str_writer |writer| {\n-            val.encode(~std::json::Encoder(writer));\n+            let mut encoder = std::json::Encoder(writer);\n+            val.encode(&mut encoder);\n         }\n     }\n "}, {"sha": "c420e0cbb2fd01b8906a8ebce9e1d727eb787e00", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -1,3 +1,7 @@\n+// xfail-test\n+\n+// Broken due to arena API problems.\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,7 +14,6 @@\n \n extern mod std;\n use std::arena;\n-use methods = std::arena::Arena;\n \n enum tree<'self> {\n     nil,\n@@ -26,9 +29,7 @@ fn item_check(t: &tree) -> int {\n     }\n }\n \n-fn bottom_up_tree<'r>(arena: &'r arena::Arena,\n-                      item: int,\n-                      depth: int)\n+fn bottom_up_tree<'r>(arena: &'r mut arena::Arena, item: int, depth: int)\n                    -> &'r tree<'r> {\n     if depth > 0 {\n         return arena.alloc(\n@@ -58,25 +59,25 @@ fn main() {\n         max_depth = n;\n     }\n \n-    let stretch_arena = arena::Arena();\n+    let mut stretch_arena = arena::Arena();\n     let stretch_depth = max_depth + 1;\n-    let stretch_tree = bottom_up_tree(&stretch_arena, 0, stretch_depth);\n+    let stretch_tree = bottom_up_tree(&mut stretch_arena, 0, stretch_depth);\n \n     io::println(fmt!(\"stretch tree of depth %d\\t check: %d\",\n                           stretch_depth,\n                           item_check(stretch_tree)));\n \n-    let long_lived_arena = arena::Arena();\n-    let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n+    let mut long_lived_arena = arena::Arena();\n+    let long_lived_tree = bottom_up_tree(&mut long_lived_arena, 0, max_depth);\n     let mut depth = min_depth;\n     while depth <= max_depth {\n         let iterations = int::pow(2, (max_depth - depth + min_depth) as uint);\n         let mut chk = 0;\n         let mut i = 1;\n         while i <= iterations {\n-            let mut temp_tree = bottom_up_tree(&long_lived_arena, i, depth);\n+            let mut temp_tree = bottom_up_tree(&mut long_lived_arena, i, depth);\n             chk += item_check(temp_tree);\n-            temp_tree = bottom_up_tree(&long_lived_arena, -i, depth);\n+            temp_tree = bottom_up_tree(&mut long_lived_arena, -i, depth);\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n@@ -87,5 +88,5 @@ fn main() {\n     }\n     io::println(fmt!(\"long lived trees of depth %d\\t check: %d\",\n                      max_depth,\n-                          item_check(long_lived_tree)));\n+                     item_check(long_lived_tree)));\n }"}, {"sha": "cfac8e8cd061f000bbcd58e17697a65954819cf7", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -31,11 +31,12 @@ fn test_ebml<A:\n     Decodable<EBReader::Decoder>\n >(a1: &A) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = &EBWriter::Encoder(wr);\n-        a1.encode(ebml_w)\n+        let mut ebml_w = EBWriter::Encoder(wr);\n+        a1.encode(&mut ebml_w)\n     };\n     let d = EBReader::Doc(@bytes);\n-    let a2: A = Decodable::decode(&EBReader::Decoder(d));\n+    let mut decoder = EBReader::Decoder(d);\n+    let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);\n }\n "}, {"sha": "8b514b11625e4a28288a4112ab739704da0a3d2b", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -17,5 +17,6 @@ use self::std::serialize;\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n-    let _x: ~[int] = serialize::Decodable::decode(&json::Decoder(json));\n+    let mut decoder = json::Decoder(json);\n+    let _x: ~[int] = serialize::Decodable::decode(&mut decoder);\n }"}, {"sha": "166435cbc3d50f7fb776b35b4d6be9cdc06df85a", "filename": "src/test/run-pass/placement-new-arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -14,7 +14,8 @@ extern mod std;\n use std::arena;\n \n pub fn main() {\n-    let p = &arena::Arena();\n+    let mut arena = arena::Arena();\n+    let p = &mut arena;\n     let x = p.alloc(|| 4u);\n     io::print(fmt!(\"%u\", *x));\n     assert!(*x == 4u);"}, {"sha": "e9163505748834eccce0fef82923876eac953c76", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5df61bc1914224d50d92cdd5599b6337ac68f2/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=dc5df61bc1914224d50d92cdd5599b6337ac68f2", "patch": "@@ -21,31 +21,35 @@ struct Bcx<'self> {\n }\n \n struct Fcx<'self> {\n-    arena: &'self Arena,\n+    arena: &'self mut Arena,\n     ccx: &'self Ccx\n }\n \n struct Ccx {\n     x: int\n }\n \n-fn h<'r>(bcx : &'r Bcx<'r>) -> &'r Bcx<'r> {\n-    return bcx.fcx.arena.alloc(|| Bcx { fcx: bcx.fcx });\n+fn h<'r>(bcx : &'r mut Bcx<'r>) -> &'r mut Bcx<'r> {\n+    // XXX: Arena has a bad interface here; it should return mutable pointers.\n+    // But this patch is too big to roll that in.\n+    unsafe {\n+        cast::transmute(bcx.fcx.arena.alloc(|| Bcx { fcx: bcx.fcx }))\n+    }\n }\n \n-fn g(fcx : &Fcx) {\n-    let bcx = Bcx { fcx: fcx };\n-    h(&bcx);\n+fn g(fcx: &mut Fcx) {\n+    let mut bcx = Bcx { fcx: fcx };\n+    h(&mut bcx);\n }\n \n-fn f(ccx : &Ccx) {\n-    let a = Arena();\n-    let fcx = &Fcx { arena: &a, ccx: ccx };\n-    return g(fcx);\n+fn f(ccx: &mut Ccx) {\n+    let mut a = Arena();\n+    let mut fcx = Fcx { arena: &mut a, ccx: ccx };\n+    return g(&mut fcx);\n }\n \n pub fn main() {\n-    let ccx = Ccx { x: 0 };\n-    f(&ccx);\n+    let mut ccx = Ccx { x: 0 };\n+    f(&mut ccx);\n }\n "}]}