{"sha": "5d04234868428fe819fb17d78b8f7468161586b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMDQyMzQ4Njg0MjhmZTgxOWZiMTdkNzhiOGY3NDY4MTYxNTg2Yjk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-18T01:16:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-24T22:46:03Z"}, "message": "std::rt: Reduce SleeperList contention\n\nThis makes the lock much less contended. In the test I'm running the\nnumber of times it's contended goes from ~100000 down to ~1000.", "tree": {"sha": "fe92b1044aef8e48755580700eb338598a5b0c48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe92b1044aef8e48755580700eb338598a5b0c48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d04234868428fe819fb17d78b8f7468161586b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d04234868428fe819fb17d78b8f7468161586b9", "html_url": "https://github.com/rust-lang/rust/commit/5d04234868428fe819fb17d78b8f7468161586b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d04234868428fe819fb17d78b8f7468161586b9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bcb63983680b0953c8125f375e53db8d64a5dc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bcb63983680b0953c8125f375e53db8d64a5dc8", "html_url": "https://github.com/rust-lang/rust/commit/5bcb63983680b0953c8125f375e53db8d64a5dc8"}], "stats": {"total": 56, "additions": 44, "deletions": 12}, "files": [{"sha": "91ab87268f324c80f2c0f6891daa4b647ca74ab3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d04234868428fe819fb17d78b8f7468161586b9/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d04234868428fe819fb17d78b8f7468161586b9/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=5d04234868428fe819fb17d78b8f7468161586b9", "patch": "@@ -469,10 +469,7 @@ impl Scheduler {\n         // We've made work available. Notify a\n         // sleeping scheduler.\n \n-        // XXX: perf. Check for a sleeper without\n-        // synchronizing memory.  It's not critical\n-        // that we always find it.\n-        match this.sleeper_list.pop() {\n+        match this.sleeper_list.casual_pop() {\n             Some(handle) => {\n                         let mut handle = handle;\n                 handle.send(Wake)"}, {"sha": "7232afd6594b5ac9daadb14e2f6b51b7d63dcc16", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5d04234868428fe819fb17d78b8f7468161586b9/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d04234868428fe819fb17d78b8f7468161586b9/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=5d04234868428fe819fb17d78b8f7468161586b9", "patch": "@@ -15,33 +15,68 @@ use container::Container;\n use vec::OwnedVector;\n use option::{Option, Some, None};\n use cell::Cell;\n-use unstable::sync::Exclusive;\n+use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use rt::sched::SchedHandle;\n use clone::Clone;\n \n pub struct SleeperList {\n-    priv stack: Exclusive<~[SchedHandle]>\n+    priv state: UnsafeAtomicRcBox<State>\n+}\n+\n+struct State {\n+    count: uint,\n+    stack: ~[SchedHandle],\n+    lock: LittleLock\n }\n \n impl SleeperList {\n     pub fn new() -> SleeperList {\n         SleeperList {\n-            stack: Exclusive::new(~[])\n+            state: UnsafeAtomicRcBox::new(State {\n+                count: 0,\n+                stack: ~[],\n+                lock: LittleLock::new()\n+            })\n         }\n     }\n \n     pub fn push(&mut self, handle: SchedHandle) {\n         let handle = Cell::new(handle);\n         unsafe {\n-            self.stack.with(|s| s.push(handle.take()));\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                (*state).count += 1;\n+                (*state).stack.push(handle.take());\n+            }\n         }\n     }\n \n     pub fn pop(&mut self) -> Option<SchedHandle> {\n         unsafe {\n-            do self.stack.with |s| {\n-                if !s.is_empty() {\n-                    Some(s.pop())\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                if !(*state).stack.is_empty() {\n+                    (*state).count -= 1;\n+                    Some((*state).stack.pop())\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A pop that may sometimes miss enqueued elements, but is much faster\n+    /// to give up without doing any synchronization\n+    pub fn casual_pop(&mut self) -> Option<SchedHandle> {\n+        unsafe {\n+            let state = self.state.get();\n+            // NB: Unsynchronized check\n+            if (*state).count == 0 { return None; }\n+            do (*state).lock.lock {\n+                if !(*state).stack.is_empty() {\n+                    // NB: count is also protected by the lock\n+                    (*state).count -= 1;\n+                    Some((*state).stack.pop())\n                 } else {\n                     None\n                 }\n@@ -53,7 +88,7 @@ impl SleeperList {\n impl Clone for SleeperList {\n     fn clone(&self) -> SleeperList {\n         SleeperList {\n-            stack: self.stack.clone()\n+            state: self.state.clone()\n         }\n     }\n }"}]}