{"sha": "504335ae5aeb2f38b4b8281f313eceff066c1fb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNDMzNWFlNWFlYjJmMzhiNGI4MjgxZjMxM2VjZWZmMDY2YzFmYjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-13T03:32:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-14T21:58:00Z"}, "message": "libworkcache: Remove all uses of `~str` from `libworkcache`.", "tree": {"sha": "56a75d3d26de2d2841873fed28d1998351128e2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56a75d3d26de2d2841873fed28d1998351128e2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/504335ae5aeb2f38b4b8281f313eceff066c1fb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/504335ae5aeb2f38b4b8281f313eceff066c1fb2", "html_url": "https://github.com/rust-lang/rust/commit/504335ae5aeb2f38b4b8281f313eceff066c1fb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/504335ae5aeb2f38b4b8281f313eceff066c1fb2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95e310abdcbfe0f5ad511258097624719cbc84db", "url": "https://api.github.com/repos/rust-lang/rust/commits/95e310abdcbfe0f5ad511258097624719cbc84db", "html_url": "https://github.com/rust-lang/rust/commit/95e310abdcbfe0f5ad511258097624719cbc84db"}], "stats": {"total": 69, "additions": 39, "deletions": 30}, "files": [{"sha": "c2dd8459540d89724a7d8d4084445f51c188b196", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/504335ae5aeb2f38b4b8281f313eceff066c1fb2/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/504335ae5aeb2f38b4b8281f313eceff066c1fb2/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=504335ae5aeb2f38b4b8281f313eceff066c1fb2", "patch": "@@ -103,31 +103,31 @@ use std::io::{File, MemWriter};\n \n #[deriving(Clone, Eq, Encodable, Decodable, Ord, TotalOrd, TotalEq)]\n struct WorkKey {\n-    kind: ~str,\n-    name: ~str\n+    kind: StrBuf,\n+    name: StrBuf\n }\n \n impl WorkKey {\n     pub fn new(kind: &str, name: &str) -> WorkKey {\n         WorkKey {\n-            kind: kind.to_owned(),\n-            name: name.to_owned(),\n+            kind: kind.to_strbuf(),\n+            name: name.to_strbuf(),\n         }\n     }\n }\n \n-// FIXME #8883: The key should be a WorkKey and not a ~str.\n+// FIXME #8883: The key should be a WorkKey and not a StrBuf.\n // This is working around some JSON weirdness.\n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct WorkMap(TreeMap<~str, KindMap>);\n+struct WorkMap(TreeMap<StrBuf, KindMap>);\n \n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct KindMap(TreeMap<~str, ~str>);\n+struct KindMap(TreeMap<StrBuf, StrBuf>);\n \n impl WorkMap {\n     fn new() -> WorkMap { WorkMap(TreeMap::new()) }\n \n-    fn insert_work_key(&mut self, k: WorkKey, val: ~str) {\n+    fn insert_work_key(&mut self, k: WorkKey, val: StrBuf) {\n         let WorkKey { kind, name } = k;\n         let WorkMap(ref mut map) = *self;\n         match map.find_mut(&name) {\n@@ -142,7 +142,7 @@ impl WorkMap {\n \n pub struct Database {\n     db_filename: Path,\n-    db_cache: TreeMap<~str, ~str>,\n+    db_cache: TreeMap<StrBuf, StrBuf>,\n     pub db_dirty: bool,\n }\n \n@@ -163,11 +163,11 @@ impl Database {\n     pub fn prepare(&self,\n                    fn_name: &str,\n                    declared_inputs: &WorkMap)\n-                   -> Option<(WorkMap, WorkMap, ~str)> {\n+                   -> Option<(WorkMap, WorkMap, StrBuf)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n-            Some(v) => Some(json_decode(*v))\n+            Some(v) => Some(json_decode(v.as_slice()))\n         }\n     }\n \n@@ -188,7 +188,14 @@ impl Database {\n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) -> io::IoResult<()> {\n         let mut f = File::create(&self.db_filename);\n-        self.db_cache.to_json().to_pretty_writer(&mut f)\n+\n+        // FIXME(pcwalton): Yuck.\n+        let mut new_db_cache = TreeMap::new();\n+        for (ref k, ref v) in self.db_cache.iter() {\n+            new_db_cache.insert((*k).to_owned(), (*v).to_owned());\n+        }\n+\n+        new_db_cache.to_json().to_pretty_writer(&mut f)\n     }\n \n     fn load(&mut self) {\n@@ -222,7 +229,7 @@ impl Drop for Database {\n     }\n }\n \n-pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n+pub type FreshnessMap = TreeMap<StrBuf,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n pub struct Context {\n@@ -253,11 +260,11 @@ enum Work<'a, T> {\n     WorkFromTask(&'a Prep<'a>, Receiver<(Exec, T)>),\n }\n \n-fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> ~str {\n+fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> StrBuf {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     let _ = t.encode(&mut encoder);\n-    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_owned()\n+    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_strbuf()\n }\n \n // FIXME(#5121)\n@@ -308,19 +315,19 @@ impl Exec {\n                           dependency_val: &str) {\n         debug!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n-                                 dependency_val.to_owned());\n+                                 dependency_val.to_strbuf());\n     }\n     pub fn discover_output(&mut self,\n                            dependency_kind: &str,\n                            dependency_name: &str,\n                            dependency_val: &str) {\n         debug!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n-                                 dependency_val.to_owned());\n+                                 dependency_val.to_strbuf());\n     }\n \n     // returns pairs of (kind, name)\n-    pub fn lookup_discovered_inputs(&self) -> Vec<(~str, ~str)> {\n+    pub fn lookup_discovered_inputs(&self) -> Vec<(StrBuf, StrBuf)> {\n         let mut rs = vec![];\n         let WorkMap(ref discovered_inputs) = self.discovered_inputs;\n         for (k, v) in discovered_inputs.iter() {\n@@ -342,7 +349,7 @@ impl<'a> Prep<'a> {\n         }\n     }\n \n-    pub fn lookup_declared_inputs(&self) -> Vec<~str> {\n+    pub fn lookup_declared_inputs(&self) -> Vec<StrBuf> {\n         let mut rs = vec![];\n         let WorkMap(ref declared_inputs) = self.declared_inputs;\n         for (_, v) in declared_inputs.iter() {\n@@ -359,12 +366,11 @@ impl<'a> Prep<'a> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n         debug!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n-                                 val.to_owned());\n+                                 val.to_strbuf());\n     }\n \n-    fn is_fresh(&self, cat: &str, kind: &str,\n-                name: &str, val: &str) -> bool {\n-        let k = kind.to_owned();\n+    fn is_fresh(&self, cat: &str, kind: &str, name: &str, val: &str) -> bool {\n+        let k = kind.to_strbuf();\n         let f = self.ctxt.freshness.deref().find(&k);\n         debug!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n@@ -384,7 +390,10 @@ impl<'a> Prep<'a> {\n         for (k_name, kindmap) in map.iter() {\n             let KindMap(ref kindmap_) = *kindmap;\n             for (k_kind, v) in kindmap_.iter() {\n-               if ! self.is_fresh(cat, *k_kind, *k_name, *v) {\n+               if !self.is_fresh(cat,\n+                                 k_kind.as_slice(),\n+                                 k_name.as_slice(),\n+                                 v.as_slice()) {\n                   return false;\n             }\n           }\n@@ -420,7 +429,7 @@ impl<'a> Prep<'a> {\n                 debug!(\"Cache hit!\");\n                 debug!(\"Trying to decode: {:?} / {:?} / {}\",\n                        disc_in, disc_out, *res);\n-                Work::from_value(json_decode(*res))\n+                Work::from_value(json_decode(res.as_slice()))\n             }\n \n             _ => {\n@@ -467,7 +476,7 @@ impl<'a, T:Send +\n                                      &prep.declared_inputs,\n                                      &exe.discovered_inputs,\n                                      &exe.discovered_outputs,\n-                                     s);\n+                                     s.as_slice());\n                 v\n             }\n         }\n@@ -484,18 +493,18 @@ fn test() {\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n-    fn make_path(filename: ~str) -> Path {\n+    fn make_path(filename: StrBuf) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if pth.exists() {\n             fs::unlink(&pth).unwrap();\n         }\n         return pth;\n     }\n \n-    let pth = make_path(\"foo.c\".to_owned());\n+    let pth = make_path(\"foo.c\".to_strbuf());\n     File::create(&pth).write(bytes!(\"int main() { return 0; }\")).unwrap();\n \n-    let db_path = make_path(\"db.json\".to_owned());\n+    let db_path = make_path(\"db.json\".to_strbuf());\n \n     let cx = Context::new(Arc::new(RWLock::new(Database::new(db_path))),\n                           Arc::new(TreeMap::new()));\n@@ -511,7 +520,7 @@ fn test() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n         prep.exec(proc(_exe) {\n-            let out = make_path(\"foo.o\".to_owned());\n+            let out = make_path(\"foo.o\".to_strbuf());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             Process::status(compiler, [pth.as_str().unwrap().to_owned(),"}]}