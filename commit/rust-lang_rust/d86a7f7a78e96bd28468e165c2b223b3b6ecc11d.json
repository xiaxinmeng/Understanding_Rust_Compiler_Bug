{"sha": "d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NmE3ZjdhNzhlOTZiZDI4NDY4ZTE2NWMyYjIyM2IzYjZlY2MxMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-15T04:22:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-15T04:22:45Z"}, "message": "Auto merge of #44585 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 23 pull requests\n\n- Successful merges: #44131, #44254, #44368, #44374, #44378, #44388, #44430, #44450, #44453, #44472, #44476, #44477, #44485, #44497, #44521, #44534, #44536, #44541, #44552, #44559, #44563, #44569, #44572\n- Failed merges:", "tree": {"sha": "78839e9a358a6781af8c1dd0a21b3f9503382b3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78839e9a358a6781af8c1dd0a21b3f9503382b3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "html_url": "https://github.com/rust-lang/rust/commit/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d288a5ae5e2e72b1c40611db80f94bbec75639b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d288a5ae5e2e72b1c40611db80f94bbec75639b", "html_url": "https://github.com/rust-lang/rust/commit/2d288a5ae5e2e72b1c40611db80f94bbec75639b"}, {"sha": "68e0f28304249a4f2db6b177b3be156ba4774a92", "url": "https://api.github.com/repos/rust-lang/rust/commits/68e0f28304249a4f2db6b177b3be156ba4774a92", "html_url": "https://github.com/rust-lang/rust/commit/68e0f28304249a4f2db6b177b3be156ba4774a92"}], "stats": {"total": 440, "additions": 320, "deletions": 120}, "files": [{"sha": "741ced8f0912d21157b9919522f9b767a30ba164", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -400,30 +400,53 @@ labels to triage issues:\n \n * Magenta, **B**-prefixed labels identify bugs which are **blockers**.\n \n+* Dark blue, **beta-** labels track changes which need to be backported into\n+  the beta branches.\n+\n+* Light purple, **C**-prefixed labels represent the **category** of an issue.\n+\n * Green, **E**-prefixed labels explain the level of **experience** necessary\n   to fix the issue.\n \n+* The dark blue **final-comment-period** label marks bugs that are using the\n+  RFC signoff functionality of [rfcbot][rfcbot] and are currenty in the final\n+  comment period.\n+\n * Red, **I**-prefixed labels indicate the **importance** of the issue. The\n   [I-nominated][inom] label indicates that an issue has been nominated for\n   prioritizing at the next triage meeting.\n \n+* The purple **metabug** label marks lists of bugs collected by other\n+  categories.\n+\n+* Purple gray, **O**-prefixed labels are the **operating system** or platform\n+  that this issue is specific to.\n+\n * Orange, **P**-prefixed labels indicate a bug's **priority**. These labels\n   are only assigned during triage meetings, and replace the [I-nominated][inom]\n   label.\n \n-* Blue, **T**-prefixed bugs denote which **team** the issue belongs to.\n+* The gray **proposed-final-comment-period** label marks bugs that are using\n+  the RFC signoff functionality of [rfcbot][rfcbot] and are currently awaiting\n+  signoff of all team members in order to enter the final comment period.\n \n-* Dark blue, **beta-** labels track changes which need to be backported into\n-  the beta branches.\n+* Pink, **regression**-prefixed labels track regressions from stable to the\n+  release channels.\n \n-* The purple **metabug** label marks lists of bugs collected by other\n-  categories.\n+* The light orange **relnotes** label marks issues that should be documented in\n+  the release notes of the next release.\n+\n+* Gray, **S**-prefixed labels are used for tracking the **status** of pull\n+  requests.\n+\n+* Blue, **T**-prefixed bugs denote which **team** the issue belongs to.\n \n If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n \n [inom]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-nominated\n [eeasy]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy\n [lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n+[rfcbot]: https://github.com/dikaiosune/rust-dashboard/blob/master/RFCBOT.md\n \n ## Out-of-tree Contributions\n "}, {"sha": "79822675364cfd76ad912c0dd135cac285511a2b", "filename": "src/Cargo.lock", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -490,6 +490,14 @@ dependencies = [\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"error-chain\"\n version = \"0.11.0\"\n@@ -642,7 +650,7 @@ dependencies = [\n \n [[package]]\n name = \"handlebars\"\n-version = \"0.26.2\"\n+version = \"0.27.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -926,18 +934,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.0.22\"\n+version = \"0.0.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"handlebars 0.26.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"handlebars 0.27.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1398,7 +1410,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mdbook 0.0.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mdbook 0.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2463,6 +2475,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n+\"checksum error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9435d864e017c3c6afeac1654189b06cdb491cf2ff73dbf0d73b0f292f42ff8\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36df0166e856739905cd3d7e0b210fe818592211a008862599845e012d8d304c\"\n@@ -2478,7 +2491,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n \"checksum globset 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"feeb1b6840809ef5efcf7a4a990bc4e1b7ee3df8cf9e2379a75aeb2ba42ac9c3\"\n \"checksum hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf088f042a467089e9baa4972f57f9247e42a0cc549ba264c7a04fbb8ecb89d4\"\n-\"checksum handlebars 0.26.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fbba80e74e9591a5f6a4ffff6b7f9d645759a896e431cfbdc853e9184370294a\"\n+\"checksum handlebars 0.27.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef7567daf271a32e60301e4821fcb5b51a5b535167115d1ce04f46c3f0a15f0b\"\n \"checksum hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6a22814455d41612f41161581c2883c0c6a1c41852729b17d5ed88f01e153aa\"\n \"checksum home 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9f25ae61099d8f3fee8b483df0bd4ecccf4b2731897aad40d50eca1b641fe6db\"\n \"checksum html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5298d63081a642508fce965740ddb03a386c5d81bf1fef0579a815cf49cb8c68\"\n@@ -2503,7 +2516,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40d014c7011ac470ae28e2f76a02bfea4a8480f73e701353b49ad7a8d75f4699\"\n \"checksum markup5ever 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff834ac7123c6a37826747e5ca09db41fd7a83126792021c2e636ad174bb77d3\"\n \"checksum matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"100aabe6b8ff4e4a7e32c1c13523379802df0772b82466207ac25b013f193376\"\n-\"checksum mdbook 0.0.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"22911d86cde6f80fa9f0fb2a68bbbde85d97af4fe0ce267141c83a4187d28700\"\n+\"checksum mdbook 0.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"146eadfc6d141452a364c351f07bb19208d1401e931f40b8532f87bba3ecc40f\"\n \"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n \"checksum miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28eaee17666671fa872e567547e8428e83308ebe5808cdf6a0e28397dbe2c726\""}, {"sha": "a2c436627f6da0c360618ec4dc997d2dac04ad15", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -389,7 +389,8 @@ impl Step for Openssl {\n         drop(fs::remove_dir_all(&dst));\n         build.run(Command::new(\"tar\").arg(\"xf\").arg(&tarball).current_dir(&out));\n \n-        let mut configure = Command::new(obj.join(\"Configure\"));\n+        let mut configure = Command::new(\"perl\");\n+        configure.arg(obj.join(\"Configure\"));\n         configure.arg(format!(\"--prefix={}\", dst.display()));\n         configure.arg(\"no-dso\");\n         configure.arg(\"no-ssl2\");"}, {"sha": "7da6371cc19072dd94e001a317ebe107c6d4a46c", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -1110,15 +1110,13 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.b.next();\n-                    return self.a.next();\n-                }\n-                Greater => return self.b.next(),\n+        match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+            Less => self.a.next(),\n+            Equal => {\n+                self.b.next();\n+                self.a.next()\n             }\n+            Greater => self.b.next(),\n         }\n     }\n "}, {"sha": "62b5f13675c231c31012fa755749683a94255c59", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -855,6 +855,19 @@ impl str {\n     }\n \n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"Za\u017c\u00f3\u0142\u0107 g\u0119\u015bl\u0105 ja\u017a\u0144\";\n+    ///\n+    /// let utf8_len = text.len();\n+    /// let utf16_len = text.encode_utf16().count();\n+    ///\n+    /// assert!(utf16_len <= utf8_len);\n+    /// ```\n     #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n     pub fn encode_utf16(&self) -> EncodeUtf16 {\n         EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n@@ -1783,6 +1796,17 @@ impl str {\n     }\n \n     /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"this is a string\";\n+    /// let boxed_str = s.to_owned().into_boxed_str();\n+    /// let boxed_bytes = boxed_str.into_boxed_bytes();\n+    /// assert_eq!(*boxed_bytes, *s.as_bytes());\n+    /// ```\n     #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n     pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n         self.into()\n@@ -2050,6 +2074,17 @@ impl str {\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking\n /// that the string contains valid UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let smile_utf8 = Box::new([226, 152, 186]);\n+/// let smile = unsafe { std::str::from_boxed_utf8_unchecked(smile_utf8) };\n+///\n+/// assert_eq!(\"\u263a\", &*smile);\n+/// ```\n #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     mem::transmute(v)"}, {"sha": "46b96df1eabd7405720f29346e58484b800f1866", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -622,6 +622,13 @@ impl String {\n     /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n     /// invalid data with the replacement character (U+FFFD).\n     ///\n+    /// Unlike [`from_utf8_lossy`] which returns a [`Cow<'a, str>`],\n+    /// `from_utf16_lossy` returns a `String` since the UTF-16 to UTF-8\n+    /// conversion requires a memory allocation.\n+    ///\n+    /// [`from_utf8_lossy`]: #method.from_utf8_lossy\n+    /// [`Cow<'a, str>`]: ../borrow/enum.Cow.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -759,7 +766,22 @@ impl String {\n         self\n     }\n \n-    /// Extracts a string slice containing the entire string.\n+    /// Converts a `String` into a mutable string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let mut s = String::from(\"foobar\");\n+    /// let s_mut_str = s.as_mut_str();\n+    ///\n+    /// s_mut_str.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!(\"FOOBAR\", s_mut_str);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n     pub fn as_mut_str(&mut self) -> &mut str {"}, {"sha": "45574bad9ac07eb93b2abeb5629e73445fd6bbac", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -370,6 +370,7 @@ impl<T> Vec<T> {\n     ///\n     /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n     ///   (at least, it's highly likely to be incorrect if it wasn't).\n+    /// * `ptr`'s `T` needs to have the same size and alignment as it was allocated with.\n     /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n     ///\n@@ -1969,16 +1970,19 @@ impl<T> Vec<T> {\n     /// Using this method is equivalent to the following code:\n     ///\n     /// ```\n-    /// # let some_predicate = |x: &mut i32| { *x == 2 };\n-    /// # let mut vec = vec![1, 2, 3, 4, 5];\n+    /// # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6 };\n+    /// # let mut vec = vec![1, 2, 3, 4, 5, 6];\n     /// let mut i = 0;\n     /// while i != vec.len() {\n     ///     if some_predicate(&mut vec[i]) {\n     ///         let val = vec.remove(i);\n     ///         // your code here\n+    ///     } else {\n+    ///         i += 1;\n     ///     }\n-    ///     i += 1;\n     /// }\n+    ///\n+    /// # assert_eq!(vec, vec![1, 4, 5]);\n     /// ```\n     ///\n     /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,"}, {"sha": "f7f1dd12d28b150be07d9bd7b58a45ef5bc6e078", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -848,12 +848,12 @@ extern \"rust-intrinsic\" {\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n     /// // same Vec internals. Therefore the new inner type must have the\n-    /// // exact same size, and the same or lesser alignment, as the old\n-    /// // type. The same caveats exist for this method as transmute, for\n+    /// // exact same size, and the same alignment, as the old type.\n+    /// // The same caveats exist for this method as transmute, for\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n-    ///     Vec::from_raw_parts(v_orig.as_mut_ptr(),\n+    ///     Vec::from_raw_parts(v_orig.as_mut_ptr() as *mut Option<&i32>,\n     ///                         v_orig.len(),\n     ///                         v_orig.capacity())\n     /// };"}, {"sha": "bae1f4dee14f35b05e3a79efeddd04e47d3196aa", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -712,39 +712,39 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n /// Opaque type representing the discriminant of an enum.\n ///\n /// See the `discriminant` function in this module for more information.\n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n pub struct Discriminant<T>(u64, PhantomData<*const T>);\n \n // N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n \n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> Copy for Discriminant<T> {}\n \n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> clone::Clone for Discriminant<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> cmp::PartialEq for Discriminant<T> {\n     fn eq(&self, rhs: &Self) -> bool {\n         self.0 == rhs.0\n     }\n }\n \n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> cmp::Eq for Discriminant<T> {}\n \n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> hash::Hash for Discriminant<T> {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         self.0.hash(state);\n     }\n }\n \n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> fmt::Debug for Discriminant<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt.debug_tuple(\"Discriminant\")\n@@ -777,7 +777,7 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n /// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n /// ```\n-#[stable(feature = \"discriminant_value\", since = \"1.22.0\")]\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     unsafe {\n         Discriminant(intrinsics::discriminant_value(v), PhantomData)"}, {"sha": "d4fef45ae4e8f1f94cba2c903d4165b1b2076cb0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -302,6 +302,37 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n }\n \n /// Converts a mutable slice of bytes to a mutable string slice.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // \"Hello, Rust!\" as a mutable vector\n+/// let mut hellorust = vec![72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33];\n+///\n+/// // As we know these bytes are valid, we can use `unwrap()`\n+/// let outstr = str::from_utf8_mut(&mut hellorust).unwrap();\n+///\n+/// assert_eq!(\"Hello, Rust!\", outstr);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // Some invalid bytes in a mutable vector\n+/// let mut invalid = vec![128, 223];\n+///\n+/// assert!(str::from_utf8_mut(&mut invalid).is_err());\n+/// ```\n+/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n+/// errors that can be returned.\n+///\n+/// [error]: struct.Utf8Error.html\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     run_utf8_validation(v)?;\n@@ -382,6 +413,19 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n /// See the immutable version, [`from_utf8_unchecked()`][fromutf8], for more information.\n ///\n /// [fromutf8]: fn.from_utf8_unchecked.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// let mut heart = vec![240, 159, 146, 150];\n+/// let heart = unsafe { str::from_utf8_unchecked_mut(&mut heart) };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", heart);\n+/// ```\n #[inline]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {"}, {"sha": "d4fa03b508566aa489f2ed059ca2bf6b883233eb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -1487,12 +1487,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.ir.tcx.lint_node_note(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         &format!(\"variable `{}` is assigned to, but never used\",\n                                  name),\n-                        &format!(\"to disable this warning, consider using `_{}` instead\",\n+                        &format!(\"to avoid this warning, consider using `_{}` instead\",\n                                  name));\n                 } else if name != \"self\" {\n                     self.ir.tcx.lint_node_note(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         &format!(\"unused variable: `{}`\", name),\n-                        &format!(\"to disable this warning, consider using `_{}` instead\",\n+                        &format!(\"to avoid this warning, consider using `_{}` instead\",\n                                  name));\n                 }\n             }"}, {"sha": "500b75ec659a19236460c0c3f0fd9af508a39aee", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -54,13 +54,11 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::{abi, ast};\n-use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc::session::config::nightly_options::is_nightly_build;\n use rustc_data_structures::flock;\n \n use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability, Span};\n@@ -1764,9 +1762,13 @@ fn render_markdown(w: &mut fmt::Formatter,\n                    prefix: &str,\n                    scx: &SharedContext)\n                    -> fmt::Result {\n-    let hoedown_output = format!(\"{}\", Markdown(md_text, RenderType::Hoedown));\n     // We only emit warnings if the user has opted-in to Pulldown rendering.\n     let output = if render_type == RenderType::Pulldown {\n+        // Save the state of USED_ID_MAP so it only gets updated once even\n+        // though we're rendering twice.\n+        let orig_used_id_map = USED_ID_MAP.with(|map| map.borrow().clone());\n+        let hoedown_output = format!(\"{}\", Markdown(md_text, RenderType::Hoedown));\n+        USED_ID_MAP.with(|map| *map.borrow_mut() = orig_used_id_map);\n         let pulldown_output = format!(\"{}\", Markdown(md_text, RenderType::Pulldown));\n         let mut differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n         differences.retain(|s| {\n@@ -1787,7 +1789,7 @@ fn render_markdown(w: &mut fmt::Formatter,\n \n         pulldown_output\n     } else {\n-        hoedown_output\n+        format!(\"{}\", Markdown(md_text, RenderType::Hoedown))\n     };\n \n     write!(w, \"<div class='docblock'>{}{}</div>\", prefix, output)\n@@ -2192,14 +2194,9 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n-    // FIXME(#24111): remove when `const_fn` is stabilized\n-    let vis_constness = match UnstableFeatures::from_environment() {\n-        UnstableFeatures::Allow => f.constness,\n-        _ => hir::Constness::NotConst\n-    };\n     let name_len = format!(\"{}{}{}{:#}fn {}{:#}\",\n                            VisSpace(&it.visibility),\n-                           ConstnessSpace(vis_constness),\n+                           ConstnessSpace(f.constness),\n                            UnsafetySpace(f.unsafety),\n                            AbiSpace(f.abi),\n                            it.name.as_ref().unwrap(),\n@@ -2209,7 +2206,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n-           constness = ConstnessSpace(vis_constness),\n+           constness = ConstnessSpace(f.constness),\n            unsafety = UnsafetySpace(f.unsafety),\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n@@ -2591,14 +2588,8 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                 href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n-        // FIXME(#24111): remove when `const_fn` is stabilized\n-        let vis_constness = if is_nightly_build() {\n-            constness\n-        } else {\n-            hir::Constness::NotConst\n-        };\n         let mut head_len = format!(\"{}{}{:#}fn {}{:#}\",\n-                                   ConstnessSpace(vis_constness),\n+                                   ConstnessSpace(constness),\n                                    UnsafetySpace(unsafety),\n                                    AbiSpace(abi),\n                                    name,\n@@ -2611,7 +2602,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n         };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n-               ConstnessSpace(vis_constness),\n+               ConstnessSpace(constness),\n                UnsafetySpace(unsafety),\n                AbiSpace(abi),\n                href = href,"}, {"sha": "2a916b819cca32290a091321bc65d66ba533a262", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -560,14 +560,26 @@ impl OpenOptions {\n     ///\n     /// One maybe obvious note when using append-mode: make sure that all data\n     /// that belongs together is written to the file in one operation. This\n-    /// can be done by concatenating strings before passing them to `write()`,\n+    /// can be done by concatenating strings before passing them to [`write()`],\n     /// or using a buffered writer (with a buffer of adequate size),\n-    /// and calling `flush()` when the message is complete.\n+    /// and calling [`flush()`] when the message is complete.\n     ///\n     /// If a file is opened with both read and append access, beware that after\n     /// opening, and after every write, the position for reading may be set at the\n     /// end of the file. So, before writing, save the current position (using\n-    /// `seek(SeekFrom::Current(0))`, and restore it before the next read.\n+    /// [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`, and restore it before the next read.\n+    ///\n+    /// ## Note\n+    ///\n+    /// This function doesn't create the file if it doesn't exist. Use the [`create`]\n+    /// method to do so.\n+    ///\n+    /// [`write()`]: ../../std/fs/struct.File.html#method.write\n+    /// [`flush()`]: ../../std/fs/struct.File.html#method.flush\n+    /// [`seek`]: ../../std/fs/struct.File.html#method.seek\n+    /// [`SeekFrom`]: ../../std/io/enum.SeekFrom.html\n+    /// [`Current`]: ../../std/io/enum.SeekFrom.html#variant.Current\n+    /// [`create`]: #method.create\n     ///\n     /// # Examples\n     ///\n@@ -605,9 +617,12 @@ impl OpenOptions {\n     /// This option indicates whether a new file will be created if the file\n     /// does not yet already exist.\n     ///\n-    /// In order for the file to be created, `write` or `append` access must\n+    /// In order for the file to be created, [`write`] or [`append`] access must\n     /// be used.\n     ///\n+    /// [`write`]: #method.write\n+    /// [`append`]: #method.append\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -630,12 +645,15 @@ impl OpenOptions {\n     /// whether a file exists and creating a new one, the file may have been\n     /// created by another process (a TOCTOU race condition / attack).\n     ///\n-    /// If `.create_new(true)` is set, `.create()` and `.truncate()` are\n+    /// If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are\n     /// ignored.\n     ///\n     /// The file must be opened with write or append access in order to create\n     /// a new file.\n     ///\n+    /// [`.create()`]: #method.create\n+    /// [`.truncate()`]: #method.truncate\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "943a83a95fb2333eba161c9e8fed1be74c391a04", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -167,7 +167,7 @@ impl TcpStream {\n     /// connection request.\n     ///\n     /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n-    #[unstable(feature = \"tcpstream_connect_timeout\", issue = \"43079\")]\n+    #[stable(feature = \"tcpstream_connect_timeout\", since = \"1.22.0\")]\n     pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n         net_imp::TcpStream::connect_timeout(addr, timeout).map(TcpStream)\n     }"}, {"sha": "a8a242846d7cedb6522ec40e27a501d485adb573", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -48,11 +48,12 @@ use time::Duration;\n /// {\n ///     let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n ///\n-///     // read from the socket\n+///     // Receives a single datagram message on the socket. If `buf` is too small to hold\n+///     // the message, it will be cut off.\n ///     let mut buf = [0; 10];\n ///     let (amt, src) = socket.recv_from(&mut buf)?;\n ///\n-///     // send a reply to the socket we received data from\n+///     // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n ///     let buf = &mut buf[..amt];\n ///     buf.reverse();\n ///     socket.send_to(buf, &src)?;\n@@ -103,8 +104,12 @@ impl UdpSocket {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n     }\n \n-    /// Receives data from the socket. On success, returns the number of bytes\n-    /// read and the address from whence the data came.\n+    /// Receives a single datagram message on the socket. On success, returns the number\n+    /// of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// # Examples\n     ///\n@@ -115,19 +120,25 @@ impl UdpSocket {\n     /// let mut buf = [0; 10];\n     /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n     ///                                         .expect(\"Didn't receive data\");\n+    /// let filled_buf = &mut buf[..number_of_bytes];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.0.recv_from(buf)\n     }\n \n-    /// Receives data from the socket, without removing it from the queue.\n+    /// Receives a single datagram message on the socket, without removing it from the\n+    /// queue. On success, returns the number of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// Successive calls return the same data. This is accomplished by passing\n     /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n     ///\n-    /// On success, returns the number of bytes peeked and the address from\n-    /// whence the data came.\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n     ///\n     /// # Examples\n     ///\n@@ -138,6 +149,7 @@ impl UdpSocket {\n     /// let mut buf = [0; 10];\n     /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n     ///                                         .expect(\"Didn't receive data\");\n+    /// let filled_buf = &mut buf[..number_of_bytes];\n     /// ```\n     #[stable(feature = \"peek\", since = \"1.18.0\")]\n     pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n@@ -586,8 +598,11 @@ impl UdpSocket {\n     /// receive data from the specified address.\n     ///\n     /// If `addr` yields multiple addresses, `connect` will be attempted with\n-    /// each of the addresses until a connection is successful. If none of\n-    /// the addresses are able to be connected, the error returned from the\n+    /// each of the addresses until the underlying OS function returns no\n+    /// error. Note that usually, a successful `connect` call does not specify\n+    /// that there is a remote server listening on the port, rather, such an\n+    /// error would only be detected after the first send. If the OS returns an\n+    /// error for each of the specified addresses, the error returned from the\n     /// last connection attempt (the last address) is returned.\n     ///\n     /// # Examples\n@@ -602,20 +617,10 @@ impl UdpSocket {\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// ```\n     ///\n-    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n-    /// `127.0.0.1:8080`. If that connection fails, then the UDP socket will\n-    /// connect to `127.0.0.1:8081`:\n-    ///\n-    /// ```no_run\n-    /// use std::net::{SocketAddr, UdpSocket};\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n-    /// let connect_addrs = [\n-    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n-    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n-    /// ];\n-    /// socket.connect(&connect_addrs[..]).expect(\"connect function failed\");\n-    /// ```\n+    /// Unlike in the TCP case, passing an array of addresses to the `connect`\n+    /// function of a UDP socket is not a useful thing to do: The OS will be\n+    /// unable to determine whether something is listening on the remote\n+    /// address without the application sending data.\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n         super::each_addr(addr, |addr| self.0.connect(addr))\n@@ -642,8 +647,12 @@ impl UdpSocket {\n         self.0.send(buf)\n     }\n \n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected.\n+    /// Receives a single datagram message on the socket from the remote address to\n+    /// which it is connected. On success, returns the number of bytes read.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// The [`connect`] method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n@@ -659,7 +668,7 @@ impl UdpSocket {\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// let mut buf = [0; 10];\n     /// match socket.recv(&mut buf) {\n-    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Ok(received) => println!(\"received {} bytes {:?}\", received, &buf[..received]),\n     ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n     /// }\n     /// ```\n@@ -668,13 +677,25 @@ impl UdpSocket {\n         self.0.recv(buf)\n     }\n \n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n+    /// Receives single datagram on the socket from the remote address to which it is\n+    /// connected, without removing the message from input queue. On success, returns\n+    /// the number of bytes peeked.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// Successive calls return the same data. This is accomplished by passing\n     /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n     ///\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n+    ///\n+    /// The [`connect`] method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    ///\n+    /// [`connect`]: #method.connect\n+    ///\n     /// # Errors\n     ///\n     /// This method will fail if the socket is not connected. The `connect` method"}, {"sha": "9535ddfe5cada5143c22cee3dbf9a1f9a48ba84a", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -32,6 +32,7 @@ pub type DWORD = c_ulong;\n pub type HANDLE = LPVOID;\n pub type HINSTANCE = HANDLE;\n pub type HMODULE = HINSTANCE;\n+pub type HRESULT = LONG;\n pub type BOOL = c_int;\n pub type BYTE = u8;\n pub type BOOLEAN = BYTE;\n@@ -197,6 +198,8 @@ pub const ERROR_OPERATION_ABORTED: DWORD = 995;\n pub const ERROR_IO_PENDING: DWORD = 997;\n pub const ERROR_TIMEOUT: DWORD = 0x5B4;\n \n+pub const E_NOTIMPL: HRESULT = 0x80004001u32 as HRESULT;\n+\n pub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n \n pub const FACILITY_NT_BIT: DWORD = 0x1000_0000;\n@@ -1163,8 +1166,8 @@ extern \"system\" {\n                   timeout: *const timeval) -> c_int;\n }\n \n-// Functions that aren't available on Windows XP, but we still use them and just\n-// provide some form of a fallback implementation.\n+// Functions that aren't available on every version of Windows that we support,\n+// but we still use them and just provide some form of a fallback implementation.\n compat_fn! {\n     kernel32:\n \n@@ -1182,6 +1185,10 @@ compat_fn! {\n     pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }\n+    pub fn SetThreadDescription(hThread: HANDLE,\n+                                lpThreadDescription: LPCWSTR) -> HRESULT {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); E_NOTIMPL\n+    }\n     pub fn SetFileInformationByHandle(_hFile: HANDLE,\n                     _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n                     _lpFileInformation: LPVOID,"}, {"sha": "c47baaa2434025fe4476fd8ac4b6dc3431c31dad", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -19,6 +19,8 @@ use sys::handle::Handle;\n use sys_common::thread::*;\n use time::Duration;\n \n+use super::to_u16s;\n+\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n \n pub struct Thread {\n@@ -55,11 +57,12 @@ impl Thread {\n         }\n     }\n \n-    pub fn set_name(_name: &CStr) {\n-        // Windows threads are nameless\n-        // The names in MSVC debugger are obtained using a \"magic\" exception,\n-        // which requires a use of MS C++ extensions.\n-        // See https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n+    pub fn set_name(name: &CStr) {\n+        if let Ok(utf8) = name.to_str() {\n+            if let Ok(utf16) = to_u16s(utf8) {\n+                unsafe { c::SetThreadDescription(c::GetCurrentThread(), utf16.as_ptr()); };\n+            };\n+        };\n     }\n \n     pub fn join(self) {"}, {"sha": "27fbca19dcc4ca3a0211eb262ae3885df99ceb19", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -434,6 +434,12 @@ impl From<Span> for MultiSpan {\n     }\n }\n \n+impl From<Vec<Span>> for MultiSpan {\n+    fn from(spans: Vec<Span>) -> MultiSpan {\n+        MultiSpan::from_spans(spans)\n+    }\n+}\n+\n pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n \n /// Identifies an offset of a multi-byte character in a FileMap"}, {"sha": "c323681f60b0a1ac66997faa937c27d22f15721a", "filename": "src/test/rustdoc/const-fn.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftest%2Frustdoc%2Fconst-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftest%2Frustdoc%2Fconst-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-fn.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+#![crate_name = \"foo\"]\n+\n+// @has foo/fn.bar.html\n+// @has - '//*[@class=\"rust fn\"]' 'pub const fn bar() -> '\n+/// foo\n+pub const fn bar() -> usize {\n+    2\n+}\n+\n+// @has foo/struct.Foo.html\n+// @has - '//*[@class=\"method\"]' 'const fn new()'\n+pub struct Foo(usize);\n+\n+impl Foo {\n+    pub const fn new() -> Foo { Foo(0) }\n+}"}, {"sha": "718720ebf83839042e037999a41b6637c3368efe", "filename": "src/test/ui/span/issue-24690.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -10,7 +10,7 @@ note: lint level defined here\n 18 | #![warn(unused)]\n    |         ^^^^^^\n    = note: #[warn(unused_variables)] implied by #[warn(unused)]\n-   = note: to disable this warning, consider using `_theOtherTwo` instead\n+   = note: to avoid this warning, consider using `_theOtherTwo` instead\n \n warning: variable `theTwo` should have a snake case name such as `the_two`\n   --> $DIR/issue-24690.rs:22:9"}, {"sha": "e57c105008ade1a337ba612173813ca5ccb11b6c", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -8,5 +8,5 @@ license = \"MIT/Apache-2.0\"\n clap = \"2.25.0\"\n \n [dependencies.mdbook]\n-version = \"0.0.22\"\n+version = \"0.0.25\"\n default-features = false"}, {"sha": "a0c3e811a7aa2cc5b69c177f6e08ef11db258672", "filename": "src/tools/rustbook/src/main.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86a7f7a78e96bd28468e165c2b223b3b6ecc11d/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs?ref=d86a7f7a78e96bd28468e165c2b223b3b6ecc11d", "patch": "@@ -13,13 +13,13 @@ extern crate mdbook;\n extern crate clap;\n \n use std::env;\n-use std::error::Error;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n use clap::{App, ArgMatches, SubCommand, AppSettings};\n \n use mdbook::MDBook;\n+use mdbook::errors::Result;\n \n fn main() {\n     let d_message = \"-d, --dest-dir=[dest-dir]\n@@ -49,34 +49,21 @@ fn main() {\n         ::std::process::exit(101);\n     }\n }\n-\n // Build command implementation\n-fn build(args: &ArgMatches) -> Result<(), Box<Error>> {\n-    let book = build_mdbook_struct(args);\n+pub fn build(args: &ArgMatches) -> Result<()> {\n+    let book_dir = get_book_dir(args);\n+    let book = MDBook::new(&book_dir).read_config()?;\n \n     let mut book = match args.value_of(\"dest-dir\") {\n-        Some(dest_dir) => book.set_dest(Path::new(dest_dir)),\n-        None => book\n+        Some(dest_dir) => book.with_destination(dest_dir),\n+        None => book,\n     };\n \n-    try!(book.build());\n+    book.build()?;\n \n     Ok(())\n }\n \n-fn build_mdbook_struct(args: &ArgMatches) -> mdbook::MDBook {\n-    let book_dir = get_book_dir(args);\n-    let mut book = MDBook::new(&book_dir).read_config();\n-\n-    // By default mdbook will attempt to create non-existent files referenced\n-    // from SUMMARY.md files. This is problematic on CI where we mount the\n-    // source directory as readonly. To avoid any issues, we'll disabled\n-    // mdbook's implicit file creation feature.\n-    book.create_missing = false;\n-\n-    book\n-}\n-\n fn get_book_dir(args: &ArgMatches) -> PathBuf {\n     if let Some(dir) = args.value_of(\"dir\") {\n         // Check if path is relative from current dir, or absolute..."}]}