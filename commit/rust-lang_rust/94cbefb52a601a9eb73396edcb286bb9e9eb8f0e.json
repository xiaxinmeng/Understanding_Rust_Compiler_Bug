{"sha": "94cbefb52a601a9eb73396edcb286bb9e9eb8f0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0Y2JlZmI1MmE2MDFhOWViNzMzOTZlZGNiMjg2YmI5ZTllYjhmMGU=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-09-11T15:23:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-11T15:23:39Z"}, "message": "Rollup merge of #88147 - FabianWolff:issue-88097, r=jackh726\n\nFix non-capturing closure return type coercion\n\nFixes #88097. For the example given there:\n```rust\nfn peculiar() -> impl Fn(u8) -> u8 {\n    return |x| x + 1\n}\n```\nwhich incorrectly reports an error, I noticed something weird in the debug log:\n```\nDEBUG rustc_typeck::check::coercion coercion::try_find_coercion_lub([closure@test.rs:2:12: 2:21], [closure@test.rs:2:12: 2:21], exprs=1 exprs)\n```\nApparently, `try_find_coercion_lub()` thinks that the LUB for two closure types always has to be a function pointer (which explains the `expected closure, found fn pointer` error in #88097). There is one corner case where that isn't true, though \u2014 namely, when the two closure types are equal, in which case the trivial LUB is the type itself. This PR fixes this by inserting an explicit check for type equality in `try_find_coercion_lub()`.", "tree": {"sha": "7be06618c25d688e8da96613a1240d7e954361c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7be06618c25d688e8da96613a1240d7e954361c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhPMn7CRBK7hj4Ov3rIwAAyIAIAEPSLOnzszSSkpA0RGCWxCri\nWWU3jVfkthcgS4GjvyW7ko1yjHQt9S8LdW7i9Cbr7XatZXuCAOAmp03o3v6mqyq3\nVm4P6/eGiJNr+32pG+TvNjCYDpanBTh/vfukG/TmtQFyPartrrrkjJddKLr01h4E\n4XrJUMGUkWvc4YWv/JxcvqReII5l/Txz8msev6YZIljH7bA8pSiEfYgV9pbOq0iH\n/dkBnMbYWaR1+a3sjP7/Xbsy11VPDuDuuJYKBmjjidccuBi7O2nT7hE+k7op5AH1\n9E1N6sUhK/NpkSL65dXhTXEttIpCajja28Y5K2en0kilRONlj5xyMr4gv2LMBUw=\n=tqDy\n-----END PGP SIGNATURE-----\n", "payload": "tree 7be06618c25d688e8da96613a1240d7e954361c7\nparent 95b50eb6629a7877c06fb0ab545a6016ea579897\nparent bbe3be9bf8d8e8503b8effbe392d0e449224b406\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1631373819 -0700\ncommitter GitHub <noreply@github.com> 1631373819 -0700\n\nRollup merge of #88147 - FabianWolff:issue-88097, r=jackh726\n\nFix non-capturing closure return type coercion\n\nFixes #88097. For the example given there:\n```rust\nfn peculiar() -> impl Fn(u8) -> u8 {\n    return |x| x + 1\n}\n```\nwhich incorrectly reports an error, I noticed something weird in the debug log:\n```\nDEBUG rustc_typeck::check::coercion coercion::try_find_coercion_lub([closure@test.rs:2:12: 2:21], [closure@test.rs:2:12: 2:21], exprs=1 exprs)\n```\nApparently, `try_find_coercion_lub()` thinks that the LUB for two closure types always has to be a function pointer (which explains the `expected closure, found fn pointer` error in #88097). There is one corner case where that isn't true, though \u2014 namely, when the two closure types are equal, in which case the trivial LUB is the type itself. This PR fixes this by inserting an explicit check for type equality in `try_find_coercion_lub()`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e", "html_url": "https://github.com/rust-lang/rust/commit/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b50eb6629a7877c06fb0ab545a6016ea579897", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b50eb6629a7877c06fb0ab545a6016ea579897", "html_url": "https://github.com/rust-lang/rust/commit/95b50eb6629a7877c06fb0ab545a6016ea579897"}, {"sha": "bbe3be9bf8d8e8503b8effbe392d0e449224b406", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe3be9bf8d8e8503b8effbe392d0e449224b406", "html_url": "https://github.com/rust-lang/rust/commit/bbe3be9bf8d8e8503b8effbe392d0e449224b406"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "6fe96e4cc27b2f0811939203903e8379b1cc5f4c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=94cbefb52a601a9eb73396edcb286bb9e9eb8f0e", "patch": "@@ -1003,6 +1003,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             exprs.len()\n         );\n \n+        // The following check fixes #88097, where the compiler erroneously\n+        // attempted to coerce a closure type to itself via a function pointer.\n+        if prev_ty == new_ty {\n+            return Ok(prev_ty);\n+        }\n+\n         // Special-case that coercion alone cannot handle:\n         // Function items or non-capturing closures of differing IDs or InternalSubsts.\n         let (a_sig, b_sig) = {"}, {"sha": "e543e1bae9239f16f161600deb5308c921ec6d12", "filename": "src/test/ui/coercion/issue-88097.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e/src%2Ftest%2Fui%2Fcoercion%2Fissue-88097.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94cbefb52a601a9eb73396edcb286bb9e9eb8f0e/src%2Ftest%2Fui%2Fcoercion%2Fissue-88097.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fissue-88097.rs?ref=94cbefb52a601a9eb73396edcb286bb9e9eb8f0e", "patch": "@@ -0,0 +1,31 @@\n+// In #88097, the compiler attempted to coerce a closure type to itself via\n+// a function pointer, which caused an unnecessary error. Check that this\n+// behavior has been fixed.\n+\n+// check-pass\n+\n+fn peculiar() -> impl Fn(u8) -> u8 {\n+    return |x| x + 1\n+}\n+\n+fn peculiar2() -> impl Fn(u8) -> u8 {\n+    return |x| x + 1;\n+}\n+\n+fn peculiar3() -> impl Fn(u8) -> u8 {\n+    let f = |x| x + 1;\n+    return f\n+}\n+\n+fn peculiar4() -> impl Fn(u8) -> u8 {\n+    let f = |x| x + 1;\n+    f\n+}\n+\n+fn peculiar5() -> impl Fn(u8) -> u8 {\n+    let f = |x| x + 1;\n+    let g = |x| x + 2;\n+    return if true { f } else { g }\n+}\n+\n+fn main() {}"}]}