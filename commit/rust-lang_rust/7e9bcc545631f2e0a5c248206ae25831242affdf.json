{"sha": "7e9bcc545631f2e0a5c248206ae25831242affdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlOWJjYzU0NTYzMWYyZTBhNWMyNDgyMDZhZTI1ODMxMjQyYWZmZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T00:56:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T00:56:51Z"}, "message": "auto merge of #12401 : alexcrichton/rust/if-ok-2-try, r=brson\n\nThis \"bubble up an error\" macro was originally named if_ok! in order to get it\r\nlanded, but after the fact it was discovered that this name is not exactly\r\ndesirable.\r\n\r\nThe name `if_ok!` isn't immediately clear that is has much to do with error\r\nhandling, and it doesn't look fantastic in all contexts (if if_ok!(...) {}). In\r\ngeneral, the agreed opinion about `if_ok!` is that is came in as subpar.\r\n\r\nThe name `try!` is more invocative of error handling, it's shorter by 2 letters,\r\nand it looks fitting in almost all circumstances. One concern about the word\r\n`try!` is that it's too invocative of exceptions, but the belief is that this\r\nwill be overcome with documentation and examples.\r\n\r\nClose #12037", "tree": {"sha": "e7cb6168c26bebc970314dc837f018eb554d821b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7cb6168c26bebc970314dc837f018eb554d821b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e9bcc545631f2e0a5c248206ae25831242affdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9bcc545631f2e0a5c248206ae25831242affdf", "html_url": "https://github.com/rust-lang/rust/commit/7e9bcc545631f2e0a5c248206ae25831242affdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e9bcc545631f2e0a5c248206ae25831242affdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6532d2fa0d173e4f815ac2144ff9860f5343cd7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6532d2fa0d173e4f815ac2144ff9860f5343cd7d", "html_url": "https://github.com/rust-lang/rust/commit/6532d2fa0d173e4f815ac2144ff9860f5343cd7d"}, {"sha": "7bb498bd7a09f024fe46fc58ea17fe44cbc68df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb498bd7a09f024fe46fc58ea17fe44cbc68df0", "html_url": "https://github.com/rust-lang/rust/commit/7bb498bd7a09f024fe46fc58ea17fe44cbc68df0"}], "stats": {"total": 2452, "additions": 1224, "deletions": 1228}, "files": [{"sha": "370d1026c415d160af239dfc22ecc017285a7e9d", "filename": "src/libextra/json.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -246,7 +246,7 @@ use serialize::Encodable;\n use serialize;\n use collections::TreeMap;\n \n-macro_rules! if_ok( ($e:expr) => (\n+macro_rules! try( ($e:expr) => (\n     match $e { Ok(e) => e, Err(e) => { self.error = Err(e); return } }\n ) )\n \n@@ -342,7 +342,7 @@ impl<'a> Encoder<'a> {\n }\n \n impl<'a> serialize::Encoder for Encoder<'a> {\n-    fn emit_nil(&mut self) { if_ok!(write!(self.wr, \"null\")) }\n+    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")) }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -358,20 +358,20 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            if_ok!(write!(self.wr, \"true\"));\n+            try!(write!(self.wr, \"true\"));\n         } else {\n-            if_ok!(write!(self.wr, \"false\"));\n+            try!(write!(self.wr, \"false\"));\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) {\n-        if_ok!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n+        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n     }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) {\n-        if_ok!(write!(self.wr, \"{}\", escape_str(v)))\n+        try!(write!(self.wr, \"{}\", escape_str(v)))\n     }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n@@ -385,19 +385,19 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n         } else {\n-            if_ok!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n-            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n-            if_ok!(write!(self.wr, \",\\\"fields\\\":[\"));\n+            try!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n+            try!(write!(self.wr, \",\\\"fields\\\":[\"));\n             f(self);\n-            if_ok!(write!(self.wr, \"]\\\\}\"));\n+            try!(write!(self.wr, \"]\\\\}\"));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n-            if_ok!(write!(self.wr, \",\"));\n+            try!(write!(self.wr, \",\"));\n         }\n         f(self);\n     }\n@@ -418,17 +418,17 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n-        if_ok!(write!(self.wr, r\"\\{\"));\n+        try!(write!(self.wr, r\"\\{\"));\n         f(self);\n-        if_ok!(write!(self.wr, r\"\\}\"));\n+        try!(write!(self.wr, r\"\\}\"));\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: |&mut Encoder<'a>|) {\n-        if idx != 0 { if_ok!(write!(self.wr, \",\")) }\n-        if_ok!(write!(self.wr, \"{}:\", escape_str(name)));\n+        if idx != 0 { try!(write!(self.wr, \",\")) }\n+        try!(write!(self.wr, \"{}:\", escape_str(name)));\n         f(self);\n     }\n \n@@ -454,31 +454,31 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n \n     fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        if_ok!(write!(self.wr, \"[\"));\n+        try!(write!(self.wr, \"[\"));\n         f(self);\n-        if_ok!(write!(self.wr, \"]\"));\n+        try!(write!(self.wr, \"]\"));\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n-            if_ok!(write!(self.wr, \",\"));\n+            try!(write!(self.wr, \",\"));\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        if_ok!(write!(self.wr, r\"\\{\"));\n+        try!(write!(self.wr, r\"\\{\"));\n         f(self);\n-        if_ok!(write!(self.wr, r\"\\}\"));\n+        try!(write!(self.wr, r\"\\}\"));\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        if idx != 0 { if_ok!(write!(self.wr, \",\")) }\n+        if idx != 0 { try!(write!(self.wr, \",\")) }\n         f(self)\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-        if_ok!(write!(self.wr, \":\"));\n+        try!(write!(self.wr, \":\"));\n         f(self)\n     }\n }\n@@ -503,7 +503,7 @@ impl<'a> PrettyEncoder<'a> {\n }\n \n impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) { if_ok!(write!(self.wr, \"null\")); }\n+    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")); }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -519,20 +519,20 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            if_ok!(write!(self.wr, \"true\"));\n+            try!(write!(self.wr, \"true\"));\n         } else {\n-            if_ok!(write!(self.wr, \"false\"));\n+            try!(write!(self.wr, \"false\"));\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) {\n-        if_ok!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n+        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n     }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) {\n-        if_ok!(write!(self.wr, \"{}\", escape_str(v)));\n+        try!(write!(self.wr, \"{}\", escape_str(v)));\n     }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n@@ -545,24 +545,24 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>|) {\n         if cnt == 0 {\n-            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n         } else {\n             self.indent += 2;\n-            if_ok!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n+            try!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n                           escape_str(name)));\n             f(self);\n             self.indent -= 2;\n-            if_ok!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n+            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut PrettyEncoder<'a>|) {\n         if idx != 0 {\n-            if_ok!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.wr, \",\\n\"));\n         }\n-        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n@@ -587,13 +587,13 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                    len: uint,\n                    f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            if_ok!(write!(self.wr, \"\\\\{\\\\}\"));\n+            try!(write!(self.wr, \"\\\\{\\\\}\"));\n         } else {\n-            if_ok!(write!(self.wr, \"\\\\{\"));\n+            try!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            if_ok!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n+            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n         }\n     }\n \n@@ -602,11 +602,11 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                          idx: uint,\n                          f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            if_ok!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.wr, \"\\n\"));\n         } else {\n-            if_ok!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.wr, \",\\n\"));\n         }\n-        if_ok!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n+        try!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n         f(self);\n     }\n \n@@ -635,50 +635,50 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n \n     fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            if_ok!(write!(self.wr, \"[]\"));\n+            try!(write!(self.wr, \"[]\"));\n         } else {\n-            if_ok!(write!(self.wr, \"[\"));\n+            try!(write!(self.wr, \"[\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            if_ok!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n+            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            if_ok!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.wr, \"\\n\"));\n         } else {\n-            if_ok!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.wr, \",\\n\"));\n         }\n-        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n     fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            if_ok!(write!(self.wr, \"\\\\{\\\\}\"));\n+            try!(write!(self.wr, \"\\\\{\\\\}\"));\n         } else {\n-            if_ok!(write!(self.wr, \"\\\\{\"));\n+            try!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            if_ok!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n+            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            if_ok!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.wr, \"\\n\"));\n         } else {\n-            if_ok!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.wr, \",\\n\"));\n         }\n-        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self);\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        if_ok!(write!(self.wr, \": \"));\n+        try!(write!(self.wr, \": \"));\n         f(self);\n     }\n }"}, {"sha": "181ea6766c575d14bb3e08b2253a70c6209156ab", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -376,48 +376,48 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n     let range_width = width_hint - overhead_width;;\n     let char_step = range / (range_width as f64);\n \n-    if_ok!(write!(w, \"{} |\", lostr));\n+    try!(write!(w, \"{} |\", lostr));\n \n     let mut c = 0;\n     let mut v = lo;\n \n     while c < range_width && v < s.min {\n-        if_ok!(write!(w, \" \"));\n+        try!(write!(w, \" \"));\n         v += char_step;\n         c += 1;\n     }\n-    if_ok!(write!(w, \"[\"));\n+    try!(write!(w, \"[\"));\n     c += 1;\n     while c < range_width && v < q1 {\n-        if_ok!(write!(w, \"-\"));\n+        try!(write!(w, \"-\"));\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < q2 {\n-        if_ok!(write!(w, \"*\"));\n+        try!(write!(w, \"*\"));\n         v += char_step;\n         c += 1;\n     }\n-    if_ok!(write!(w, r\"\\#\"));\n+    try!(write!(w, r\"\\#\"));\n     c += 1;\n     while c < range_width && v < q3 {\n-        if_ok!(write!(w, \"*\"));\n+        try!(write!(w, \"*\"));\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < s.max {\n-        if_ok!(write!(w, \"-\"));\n+        try!(write!(w, \"-\"));\n         v += char_step;\n         c += 1;\n     }\n-    if_ok!(write!(w, \"]\"));\n+    try!(write!(w, \"]\"));\n     while c < range_width {\n-        if_ok!(write!(w, \" \"));\n+        try!(write!(w, \" \"));\n         v += char_step;\n         c += 1;\n     }\n \n-    if_ok!(write!(w, \"| {}\", histr));\n+    try!(write!(w, \"| {}\", histr));\n     Ok(())\n }\n "}, {"sha": "64acdbf7f489fe612a44e743a551f181582eab70", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -77,8 +77,8 @@ impl Drop for Inner {\n }\n \n fn connect(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n-    let (addr, len) = if_ok!(addr_to_sockaddr_un(addr));\n-    let inner = Inner { fd: if_ok!(unix_socket(ty)) };\n+    let (addr, len) = try!(addr_to_sockaddr_un(addr));\n+    let inner = Inner { fd: try!(unix_socket(ty)) };\n     let addrp = &addr as *libc::sockaddr_storage;\n     match retry(|| unsafe {\n         libc::connect(inner.fd, addrp as *libc::sockaddr,\n@@ -90,8 +90,8 @@ fn connect(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n }\n \n fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n-    let (addr, len) = if_ok!(addr_to_sockaddr_un(addr));\n-    let inner = Inner { fd: if_ok!(unix_socket(ty)) };\n+    let (addr, len) = try!(addr_to_sockaddr_un(addr));\n+    let inner = Inner { fd: try!(unix_socket(ty)) };\n     let addrp = &addr as *libc::sockaddr_storage;\n     match unsafe {\n         libc::bind(inner.fd, addrp as *libc::sockaddr, len as libc::socklen_t)\n@@ -198,7 +198,7 @@ impl UnixDatagram {\n     }\n \n     pub fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> {\n-        let (dst, len) = if_ok!(addr_to_sockaddr_un(dst));\n+        let (dst, len) = try!(addr_to_sockaddr_un(dst));\n         let dstp = &dst as *libc::sockaddr_storage;\n         let ret = retry(|| unsafe {\n             libc::sendto(self.fd(),"}, {"sha": "fc4fc0fa7893d84f08513b3e911248f092c4a083", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -262,7 +262,7 @@ impl UnixStream {\n impl rtio::RtioPipe for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.read.is_none() {\n-            self.read = Some(if_ok!(Event::new(true, false)));\n+            self.read = Some(try!(Event::new(true, false)));\n         }\n \n         let mut bytes_read = 0;\n@@ -298,7 +298,7 @@ impl rtio::RtioPipe for UnixStream {\n \n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.write.is_none() {\n-            self.write = Some(if_ok!(Event::new(true, false)));\n+            self.write = Some(try!(Event::new(true, false)));\n         }\n \n         let mut offset = 0;\n@@ -371,7 +371,7 @@ impl UnixListener {\n     pub fn native_listen(self) -> IoResult<UnixAcceptor> {\n         Ok(UnixAcceptor {\n             listener: self,\n-            event: if_ok!(Event::new(true, false)),\n+            event: try!(Event::new(true, false)),\n         })\n     }\n }"}, {"sha": "d5d784cc2de3224fac6950b5a48688acaa5387b5", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -161,7 +161,7 @@ impl Archive {\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        let files = if_ok!(fs::readdir(loc.path()));\n+        let files = try!(fs::readdir(loc.path()));\n         let mut inputs = ~[];\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n@@ -170,7 +170,7 @@ impl Archive {\n \n             let filename = format!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n-            if_ok!(fs::rename(file, &new_filename));\n+            try!(fs::rename(file, &new_filename));\n             inputs.push(new_filename);\n         }\n         if inputs.len() == 0 { return Ok(()) }"}, {"sha": "f2d82bfdf3c9b4288f5dc7217ae1d3d5c950371a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -521,9 +521,9 @@ fn write_out_deps(sess: Session,\n              })\n              .collect()\n     };\n-    let mut file = if_ok!(io::File::create(&deps_filename));\n+    let mut file = try!(io::File::create(&deps_filename));\n     for path in out_filenames.iter() {\n-        if_ok!(write!(&mut file as &mut Writer,\n+        try!(write!(&mut file as &mut Writer,\n                       \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n     }\n     Ok(())\n@@ -575,21 +575,21 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n     fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeItem(s, item) => {\n-                if_ok!(pp::space(&mut s.s));\n-                if_ok!(pprust::synth_comment(s, item.id.to_str()));\n+                try!(pp::space(&mut s.s));\n+                try!(pprust::synth_comment(s, item.id.to_str()));\n             }\n             pprust::NodeBlock(s, blk) => {\n-                if_ok!(pp::space(&mut s.s));\n-                if_ok!(pprust::synth_comment(s, ~\"block \" + blk.id.to_str()));\n+                try!(pp::space(&mut s.s));\n+                try!(pprust::synth_comment(s, ~\"block \" + blk.id.to_str()));\n             }\n             pprust::NodeExpr(s, expr) => {\n-                if_ok!(pp::space(&mut s.s));\n-                if_ok!(pprust::synth_comment(s, expr.id.to_str()));\n-                if_ok!(pprust::pclose(s));\n+                try!(pp::space(&mut s.s));\n+                try!(pprust::synth_comment(s, expr.id.to_str()));\n+                try!(pprust::pclose(s));\n             }\n             pprust::NodePat(s, pat) => {\n-                if_ok!(pp::space(&mut s.s));\n-                if_ok!(pprust::synth_comment(s, ~\"pat \" + pat.id.to_str()));\n+                try!(pp::space(&mut s.s));\n+                try!(pprust::synth_comment(s, ~\"pat \" + pat.id.to_str()));\n             }\n         }\n         Ok(())\n@@ -611,12 +611,12 @@ impl pprust::PpAnn for TypedAnnotation {\n         let tcx = self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(s, expr) => {\n-                if_ok!(pp::space(&mut s.s));\n-                if_ok!(pp::word(&mut s.s, \"as\"));\n-                if_ok!(pp::space(&mut s.s));\n-                if_ok!(pp::word(&mut s.s,\n+                try!(pp::space(&mut s.s));\n+                try!(pp::word(&mut s.s, \"as\"));\n+                try!(pp::space(&mut s.s));\n+                try!(pp::word(&mut s.s,\n                                 ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n-                if_ok!(pprust::pclose(s));\n+                try!(pprust::pclose(s));\n             }\n             _ => ()\n         }"}, {"sha": "58917eabb6466dbeebae12774a648aa4723c1f1b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -1088,11 +1088,11 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n \n fn list_crate_attributes(md: ebml::Doc, hash: &str,\n                          out: &mut io::Writer) -> io::IoResult<()> {\n-    if_ok!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n+    try!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        if_ok!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr)));\n+        try!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr)));\n     }\n \n     write!(out, \"\\n\\n\")\n@@ -1131,19 +1131,19 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n }\n \n fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n-    if_ok!(write!(out, \"=External Dependencies=\\n\"));\n+    try!(write!(out, \"=External Dependencies=\\n\"));\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n-        if_ok!(write!(out,\n+        try!(write!(out,\n                       \"{} {}-{}-{}\\n\",\n                       dep.cnum,\n                       token::get_ident(dep.name),\n                       dep.hash,\n                       dep.vers));\n     }\n \n-    if_ok!(write!(out, \"\\n\"));\n+    try!(write!(out, \"\\n\"));\n     Ok(())\n }\n \n@@ -1164,7 +1164,7 @@ pub fn get_crate_vers(data: &[u8]) -> ~str {\n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    if_ok!(list_crate_attributes(md, hash, out));\n+    try!(list_crate_attributes(md, hash, out));\n     list_crate_deps(bytes, out)\n }\n "}, {"sha": "e8e05b0979a0475cdb69bbaf3d07ef44212d5f51", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -113,8 +113,8 @@ impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n \n             let comment_str = format!(\"id {}: {}{}{}\",\n                                       id, entry_str, gens_str, kills_str);\n-            if_ok!(pprust::synth_comment(ps, comment_str));\n-            if_ok!(pp::space(&mut ps.s));\n+            try!(pprust::synth_comment(ps, comment_str));\n+            try!(pp::space(&mut ps.s));\n         }\n         Ok(())\n     }\n@@ -351,10 +351,10 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     fn pretty_print_to(&self, wr: ~io::Writer,\n                        blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n-        if_ok!(pprust::cbox(&mut ps, pprust::indent_unit));\n-        if_ok!(pprust::ibox(&mut ps, 0u));\n-        if_ok!(pprust::print_block(&mut ps, blk));\n-        if_ok!(pp::eof(&mut ps.s));\n+        try!(pprust::cbox(&mut ps, pprust::indent_unit));\n+        try!(pprust::ibox(&mut ps, 0u));\n+        try!(pprust::print_block(&mut ps, blk));\n+        try!(pp::eof(&mut ps.s));\n         Ok(())\n     }\n }"}, {"sha": "efe88b7847f2aabd2e6b97914a8dcc4871989fcb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -740,7 +740,7 @@ impl Liveness {\n         for var_idx in range(0u, self.ir.num_vars.get()) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                if_ok!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n+                try!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n             }\n         }\n         Ok(())"}, {"sha": "bb6b1eeaedd5ee3995f00afddce270cfac94a7f0", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    if_ok!(fmt.buf.write(pile_o_bits.slice(last, i).as_bytes()));\n+                    try!(fmt.buf.write(pile_o_bits.slice(last, i).as_bytes()));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,15 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    if_ok!(fmt.buf.write(s.as_bytes()));\n+                    try!(fmt.buf.write(s.as_bytes()));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            if_ok!(fmt.buf.write(pile_o_bits.slice_from(last).as_bytes()));\n+            try!(fmt.buf.write(pile_o_bits.slice_from(last).as_bytes()));\n         }\n         Ok(())\n     }"}, {"sha": "a8b7e374a6ab92b8a57bfa438328e70e5e34a4cc", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -50,46 +50,46 @@ impl PuritySpace {\n impl fmt::Show for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n-        if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n+        try!(f.buf.write(\"&lt;\".as_bytes()));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                if_ok!(f.buf.write(\", \".as_bytes()));\n+                try!(f.buf.write(\", \".as_bytes()));\n             }\n-            if_ok!(write!(f.buf, \"{}\", *life));\n+            try!(write!(f.buf, \"{}\", *life));\n         }\n \n         if self.type_params.len() > 0 {\n             if self.lifetimes.len() > 0 {\n-                if_ok!(f.buf.write(\", \".as_bytes()));\n+                try!(f.buf.write(\", \".as_bytes()));\n             }\n \n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    if_ok!(f.buf.write(\", \".as_bytes()))\n+                    try!(f.buf.write(\", \".as_bytes()))\n                 }\n-                if_ok!(f.buf.write(tp.name.as_bytes()));\n+                try!(f.buf.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n-                    if_ok!(f.buf.write(\": \".as_bytes()));\n+                    try!(f.buf.write(\": \".as_bytes()));\n                     for (i, bound) in tp.bounds.iter().enumerate() {\n                         if i > 0 {\n-                            if_ok!(f.buf.write(\" + \".as_bytes()));\n+                            try!(f.buf.write(\" + \".as_bytes()));\n                         }\n-                        if_ok!(write!(f.buf, \"{}\", *bound));\n+                        try!(write!(f.buf, \"{}\", *bound));\n                     }\n                 }\n             }\n         }\n-        if_ok!(f.buf.write(\"&gt;\".as_bytes()));\n+        try!(f.buf.write(\"&gt;\".as_bytes()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(f.buf.write(\"'\".as_bytes()));\n-        if_ok!(f.buf.write(self.get_ref().as_bytes()));\n+        try!(f.buf.write(\"'\".as_bytes()));\n+        try!(f.buf.write(self.get_ref().as_bytes()));\n         Ok(())\n     }\n }\n@@ -110,32 +110,32 @@ impl fmt::Show for clean::TyParamBound {\n impl fmt::Show for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n-            if_ok!(f.buf.write(\"::\".as_bytes()))\n+            try!(f.buf.write(\"::\".as_bytes()))\n         }\n         for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n-                if_ok!(f.buf.write(\"::\".as_bytes()))\n+                try!(f.buf.write(\"::\".as_bytes()))\n             }\n-            if_ok!(f.buf.write(seg.name.as_bytes()));\n+            try!(f.buf.write(seg.name.as_bytes()));\n \n             if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n+                try!(f.buf.write(\"&lt;\".as_bytes()));\n                 let mut comma = false;\n                 for lifetime in seg.lifetimes.iter() {\n                     if comma {\n-                        if_ok!(f.buf.write(\", \".as_bytes()));\n+                        try!(f.buf.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n-                    if_ok!(write!(f.buf, \"{}\", *lifetime));\n+                    try!(write!(f.buf, \"{}\", *lifetime));\n                 }\n                 for ty in seg.types.iter() {\n                     if comma {\n-                        if_ok!(f.buf.write(\", \".as_bytes()));\n+                        try!(f.buf.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n-                    if_ok!(write!(f.buf, \"{}\", *ty));\n+                    try!(write!(f.buf, \"{}\", *ty));\n                 }\n-                if_ok!(f.buf.write(\"&gt;\".as_bytes()));\n+                try!(f.buf.write(\"&gt;\".as_bytes()));\n             }\n         }\n         Ok(())\n@@ -222,11 +222,11 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         let mut root = root;\n                         for seg in path.segments.slice_to(amt).iter() {\n                             if \"super\" == seg.name || \"self\" == seg.name {\n-                                if_ok!(write!(w, \"{}::\", seg.name));\n+                                try!(write!(w, \"{}::\", seg.name));\n                             } else {\n                                 root.push_str(seg.name);\n                                 root.push_str(\"/\");\n-                                if_ok!(write!(w, \"<a class='mod'\n+                                try!(write!(w, \"<a class='mod'\n                                                     href='{}index.html'>{}</a>::\",\n                                               root,\n                                               seg.name));\n@@ -235,7 +235,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                     }\n                     None => {\n                         for seg in path.segments.slice_to(amt).iter() {\n-                            if_ok!(write!(w, \"{}::\", seg.name));\n+                            try!(write!(w, \"{}::\", seg.name));\n                         }\n                     }\n                 }\n@@ -263,15 +263,15 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         }\n                     }\n \n-                    if_ok!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                    try!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n                                   shortty, url, fqp.connect(\"::\"), last.name));\n                 }\n \n                 _ => {\n-                    if_ok!(write!(w, \"{}\", last.name));\n+                    try!(write!(w, \"{}\", last.name));\n                 }\n             }\n-            if_ok!(write!(w, \"{}\", generics));\n+            try!(write!(w, \"{}\", generics));\n             Ok(())\n         })\n     })\n@@ -282,14 +282,14 @@ fn typarams(w: &mut io::Writer,\n             typarams: &Option<~[clean::TyParamBound]>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n-            if_ok!(write!(w, \"&lt;\"));\n+            try!(write!(w, \"&lt;\"));\n             for (i, param) in params.iter().enumerate() {\n                 if i > 0 {\n-                    if_ok!(write!(w, \", \"));\n+                    try!(write!(w, \", \"));\n                 }\n-                if_ok!(write!(w, \"{}\", *param));\n+                try!(write!(w, \"{}\", *param));\n             }\n-            if_ok!(write!(w, \"&gt;\"));\n+            try!(write!(w, \"&gt;\"));\n             Ok(())\n         }\n         None => Ok(())\n@@ -306,12 +306,12 @@ impl fmt::Show for clean::Type {\n                 })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n-                if_ok!(resolved_path(f.buf, id, path, false));\n+                try!(resolved_path(f.buf, id, path, false));\n                 typarams(f.buf, tp)\n             }\n             clean::ExternalPath{path: ref path, typarams: ref tp,\n                                 fqn: ref fqn, kind, krate} => {\n-                if_ok!(external_path(f.buf, path, false, fqn.as_slice(), kind,\n+                try!(external_path(f.buf, path, false, fqn.as_slice(), kind,\n                                      krate))\n                 typarams(f.buf, tp)\n             }\n@@ -364,12 +364,12 @@ impl fmt::Show for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                if_ok!(f.buf.write(\"(\".as_bytes()));\n+                try!(f.buf.write(\"(\".as_bytes()));\n                 for (i, typ) in typs.iter().enumerate() {\n                     if i > 0 {\n-                        if_ok!(f.buf.write(\", \".as_bytes()))\n+                        try!(f.buf.write(\", \".as_bytes()))\n                     }\n-                    if_ok!(write!(f.buf, \"{}\", *typ));\n+                    try!(write!(f.buf, \"{}\", *typ));\n                 }\n                 f.buf.write(\")\".as_bytes())\n             }\n@@ -407,11 +407,11 @@ impl fmt::Show for clean::Type {\n impl fmt::Show for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n-            if i > 0 { if_ok!(write!(f.buf, \", \")); }\n+            if i > 0 { try!(write!(f.buf, \", \")); }\n             if input.name.len() > 0 {\n-                if_ok!(write!(f.buf, \"{}: \", input.name));\n+                try!(write!(f.buf, \"{}: \", input.name));\n             }\n-            if_ok!(write!(f.buf, \"{}\", input.type_));\n+            try!(write!(f.buf, \"{}\", input.type_));\n         }\n         Ok(())\n     }\n@@ -495,12 +495,12 @@ impl fmt::Show for clean::ViewPath {\n                 write!(f.buf, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                if_ok!(write!(f.buf, \"use {}::\\\\{\", *src));\n+                try!(write!(f.buf, \"use {}::\\\\{\", *src));\n                 for (i, n) in names.iter().enumerate() {\n                     if i > 0 {\n-                        if_ok!(write!(f.buf, \", \"));\n+                        try!(write!(f.buf, \", \"));\n                     }\n-                    if_ok!(write!(f.buf, \"{}\", *n));\n+                    try!(write!(f.buf, \"{}\", *n));\n                 }\n                 write!(f.buf, \"\\\\};\")\n             }\n@@ -518,9 +518,9 @@ impl fmt::Show for clean::ImportSource {\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n-                        if_ok!(write!(f.buf, \"::\"))\n+                        try!(write!(f.buf, \"::\"))\n                     }\n-                    if_ok!(write!(f.buf, \"{}\", seg.name));\n+                    try!(write!(f.buf, \"{}\", seg.name));\n                 }\n                 Ok(())\n             }"}, {"sha": "0f017a04da3d66fbeb2c893fba254af33b2ddb47", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 162, "deletions": 162, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -209,7 +209,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         },\n         include_sources: true,\n     };\n-    if_ok!(mkdir(&cx.dst));\n+    try!(mkdir(&cx.dst));\n \n     match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n@@ -254,55 +254,55 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n     // Add all the static files\n     let mut dst = cx.dst.join(krate.name.as_slice());\n-    if_ok!(mkdir(&dst));\n-    if_ok!(write(dst.join(\"jquery.js\"),\n+    try!(mkdir(&dst));\n+    try!(write(dst.join(\"jquery.js\"),\n                  include_str!(\"static/jquery-2.1.0.min.js\")));\n-    if_ok!(write(dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n-    if_ok!(write(dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n-    if_ok!(write(dst.join(\"normalize.css\"),\n+    try!(write(dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n+    try!(write(dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n+    try!(write(dst.join(\"normalize.css\"),\n                  include_str!(\"static/normalize.css\")));\n \n     // Publish the search index\n     {\n         dst.push(\"search-index.js\");\n         let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n         let w = &mut w as &mut Writer;\n-        if_ok!(write!(w, \"var searchIndex = [\"));\n+        try!(write!(w, \"var searchIndex = [\"));\n         for (i, item) in cache.search_index.iter().enumerate() {\n             if i > 0 {\n-                if_ok!(write!(w, \",\"));\n+                try!(write!(w, \",\"));\n             }\n-            if_ok!(write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n+            try!(write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n                           item.ty, item.name, item.path,\n                           item.desc.to_json().to_str()));\n             match item.parent {\n                 Some(id) => {\n-                    if_ok!(write!(w, \",parent:'{}'\", id));\n+                    try!(write!(w, \",parent:'{}'\", id));\n                 }\n                 None => {}\n             }\n-            if_ok!(write!(w, \"\\\\}\"));\n+            try!(write!(w, \"\\\\}\"));\n         }\n-        if_ok!(write!(w, \"];\"));\n-        if_ok!(write!(w, \"var allPaths = \\\\{\"));\n+        try!(write!(w, \"];\"));\n+        try!(write!(w, \"var allPaths = \\\\{\"));\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n             if i > 0 {\n-                if_ok!(write!(w, \",\"));\n+                try!(write!(w, \",\"));\n             }\n-            if_ok!(write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n+            try!(write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n                           id, short, *fqp.last().unwrap()));\n         }\n-        if_ok!(write!(w, \"\\\\};\"));\n-        if_ok!(w.flush());\n+        try!(write!(w, \"\\\\};\"));\n+        try!(w.flush());\n     }\n \n     // Render all source files (this may turn into a giant no-op)\n     {\n         info!(\"emitting source files\");\n         let dst = cx.dst.join(\"src\");\n-        if_ok!(mkdir(&dst));\n+        try!(mkdir(&dst));\n         let dst = dst.join(krate.name.as_slice());\n-        if_ok!(mkdir(&dst));\n+        try!(mkdir(&dst));\n         let mut folder = SourceCollector {\n             dst: dst,\n             seen: HashSet::new(),\n@@ -442,17 +442,17 @@ impl<'a> SourceCollector<'a> {\n         });\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n-        let mut w = BufferedWriter::new(if_ok!(File::create(&cur)));\n+        let mut w = BufferedWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.filename_display());\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n             root_path: root_path,\n         };\n-        if_ok!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n+        try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n                               &page, &(\"\"), &Source(contents.as_slice())));\n-        if_ok!(w.flush());\n+        try!(w.flush());\n         return Ok(());\n     }\n }\n@@ -714,7 +714,7 @@ impl Context {\n         let mut work = ~[(self, item)];\n         loop {\n             match work.pop() {\n-                Some((mut cx, item)) => if_ok!(cx.item(item, |cx, item| {\n+                Some((mut cx, item)) => try!(cx.item(item, |cx, item| {\n                     work.push((cx.clone(), item));\n                 })),\n                 None => break,\n@@ -753,7 +753,7 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            if_ok!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n+            try!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n                                   &Sidebar{ cx: cx, item: it },\n                                   &Item{ cx: cx, item: it }));\n             writer.flush()\n@@ -768,8 +768,8 @@ impl Context {\n                 self.recurse(name, |this| {\n                     let item = item.take_unwrap();\n                     let dst = this.dst.join(\"index.html\");\n-                    let dst = if_ok!(File::create(&dst));\n-                    if_ok!(render(dst, this, &item, false));\n+                    let dst = try!(File::create(&dst));\n+                    try!(render(dst, this, &item, false));\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -787,7 +787,7 @@ impl Context {\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.join(item_path(&item));\n-                let dst = if_ok!(File::create(&dst));\n+                let dst = try!(File::create(&dst));\n                 render(dst, self, &item, true)\n             }\n \n@@ -829,7 +829,7 @@ impl<'a> fmt::Show for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match attr::find_stability(self.item.attrs.iter()) {\n             Some(ref stability) => {\n-                if_ok!(write!(fmt.buf,\n+                try!(write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n@@ -850,7 +850,7 @@ impl<'a> fmt::Show for Item<'a> {\n             } else {\n                 format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n             };\n-            if_ok!(write!(fmt.buf,\n+            try!(write!(fmt.buf,\n                           \"<a class='source'\n                               href='{root}src/{krate}/{path}.html\\\\#{href}'>\\\n                               [src]</a>\",\n@@ -861,13 +861,13 @@ impl<'a> fmt::Show for Item<'a> {\n         }\n \n         // Write the breadcrumb trail header for the top\n-        if_ok!(write!(fmt.buf, \"<h1 class='fqn'>\"));\n+        try!(write!(fmt.buf, \"<h1 class='fqn'>\"));\n         match self.item.inner {\n-            clean::ModuleItem(..) => if_ok!(write!(fmt.buf, \"Module \")),\n-            clean::FunctionItem(..) => if_ok!(write!(fmt.buf, \"Function \")),\n-            clean::TraitItem(..) => if_ok!(write!(fmt.buf, \"Trait \")),\n-            clean::StructItem(..) => if_ok!(write!(fmt.buf, \"Struct \")),\n-            clean::EnumItem(..) => if_ok!(write!(fmt.buf, \"Enum \")),\n+            clean::ModuleItem(..) => try!(write!(fmt.buf, \"Module \")),\n+            clean::FunctionItem(..) => try!(write!(fmt.buf, \"Function \")),\n+            clean::TraitItem(..) => try!(write!(fmt.buf, \"Trait \")),\n+            clean::StructItem(..) => try!(write!(fmt.buf, \"Struct \")),\n+            clean::EnumItem(..) => try!(write!(fmt.buf, \"Enum \")),\n             _ => {}\n         }\n         let cur = self.cx.current.as_slice();\n@@ -877,10 +877,10 @@ impl<'a> fmt::Show for Item<'a> {\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n-            if_ok!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n+            try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n                           trail, component.as_slice()));\n         }\n-        if_ok!(write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n+        try!(write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n                       shortty(self.item), self.item.name.get_ref().as_slice()));\n \n         match self.item.inner {\n@@ -932,7 +932,7 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n     match item.doc_value() {\n         Some(s) => {\n-            if_ok!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n+            try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n         }\n         None => {}\n     }\n@@ -941,7 +941,7 @@ fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n \n fn item_module(w: &mut Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n-    if_ok!(document(w, item));\n+    try!(document(w, item));\n     debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n@@ -994,10 +994,10 @@ fn item_module(w: &mut Writer, cx: &Context,\n         let myty = shortty(myitem);\n         if myty != curty {\n             if curty != \"\" {\n-                if_ok!(write!(w, \"</table>\"));\n+                try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n-            if_ok!(write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n+            try!(write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n                 clean::ModuleItem(..)          => \"Modules\",\n                 clean::StructItem(..)          => \"Structs\",\n                 clean::EnumItem(..)            => \"Enums\",\n@@ -1024,15 +1024,15 @@ fn item_module(w: &mut Writer, cx: &Context,\n                     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                         let Initializer(s) = *self;\n                         if s.len() == 0 { return Ok(()); }\n-                        if_ok!(write!(f.buf, \"<code> = </code>\"));\n+                        try!(write!(f.buf, \"<code> = </code>\"));\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n-                        if_ok!(write!(f.buf, \"<{tag}>{}</{tag}>\",\n+                        try!(write!(f.buf, \"<{tag}>{}</{tag}>\",\n                                       s.as_slice(), tag=tag));\n                         Ok(())\n                     }\n                 }\n \n-                if_ok!(write!(w, \"\n+                try!(write!(w, \"\n                     <tr>\n                         <td><code>{}static {}: {}</code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n@@ -1048,19 +1048,19 @@ fn item_module(w: &mut Writer, cx: &Context,\n             clean::ViewItemItem(ref item) => {\n                 match item.inner {\n                     clean::ExternMod(ref name, ref src, _) => {\n-                        if_ok!(write!(w, \"<tr><td><code>extern crate {}\",\n+                        try!(write!(w, \"<tr><td><code>extern crate {}\",\n                                       name.as_slice()));\n                         match *src {\n-                            Some(ref src) => if_ok!(write!(w, \" = \\\"{}\\\"\",\n+                            Some(ref src) => try!(write!(w, \" = \\\"{}\\\"\",\n                                                            src.as_slice())),\n                             None => {}\n                         }\n-                        if_ok!(write!(w, \";</code></td></tr>\"));\n+                        try!(write!(w, \";</code></td></tr>\"));\n                     }\n \n                     clean::Import(ref imports) => {\n                         for import in imports.iter() {\n-                            if_ok!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                            try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n                                           VisSpace(myitem.visibility),\n                                           *import));\n                         }\n@@ -1071,7 +1071,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n             _ => {\n                 if myitem.name.is_none() { continue }\n-                if_ok!(write!(w, \"\n+                try!(write!(w, \"\n                     <tr>\n                         <td><a class='{class}' href='{href}'\n                                title='{title}'>{}</a></td>\n@@ -1091,7 +1091,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n fn item_function(w: &mut Writer, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n-    if_ok!(write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n+    try!(write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n            purity = PuritySpace(f.purity),\n            name = it.name.get_ref().as_slice(),\n@@ -1112,7 +1112,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     }\n \n     // Output the trait definition\n-    if_ok!(write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n+    try!(write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n@@ -1121,81 +1121,81 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     let provided = t.methods.iter().filter(|m| !m.is_req()).to_owned_vec();\n \n     if t.methods.len() == 0 {\n-        if_ok!(write!(w, \"\\\\{ \\\\}\"));\n+        try!(write!(w, \"\\\\{ \\\\}\"));\n     } else {\n-        if_ok!(write!(w, \"\\\\{\\n\"));\n+        try!(write!(w, \"\\\\{\\n\"));\n         for m in required.iter() {\n-            if_ok!(write!(w, \"    \"));\n-            if_ok!(render_method(w, m.item()));\n-            if_ok!(write!(w, \";\\n\"));\n+            try!(write!(w, \"    \"));\n+            try!(render_method(w, m.item()));\n+            try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n-            if_ok!(w.write(\"\\n\".as_bytes()));\n+            try!(w.write(\"\\n\".as_bytes()));\n         }\n         for m in provided.iter() {\n-            if_ok!(write!(w, \"    \"));\n-            if_ok!(render_method(w, m.item()));\n-            if_ok!(write!(w, \" \\\\{ ... \\\\}\\n\"));\n+            try!(write!(w, \"    \"));\n+            try!(render_method(w, m.item()));\n+            try!(write!(w, \" \\\\{ ... \\\\}\\n\"));\n         }\n-        if_ok!(write!(w, \"\\\\}\"));\n+        try!(write!(w, \"\\\\}\"));\n     }\n-    if_ok!(write!(w, \"</pre>\"));\n+    try!(write!(w, \"</pre>\"));\n \n     // Trait documentation\n-    if_ok!(document(w, it));\n+    try!(document(w, it));\n \n     fn meth(w: &mut Writer, m: &clean::TraitMethod) -> fmt::Result {\n-        if_ok!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n+        try!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n                       shortty(m.item()),\n                       *m.item().name.get_ref()));\n-        if_ok!(render_method(w, m.item()));\n-        if_ok!(write!(w, \"</code></h3>\"));\n-        if_ok!(document(w, m.item()));\n+        try!(render_method(w, m.item()));\n+        try!(write!(w, \"</code></h3>\"));\n+        try!(document(w, m.item()));\n         Ok(())\n     }\n \n     // Output the documentation for each function individually\n     if required.len() > 0 {\n-        if_ok!(write!(w, \"\n+        try!(write!(w, \"\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n         \"));\n         for m in required.iter() {\n-            if_ok!(meth(w, *m));\n+            try!(meth(w, *m));\n         }\n-        if_ok!(write!(w, \"</div>\"));\n+        try!(write!(w, \"</div>\"));\n     }\n     if provided.len() > 0 {\n-        if_ok!(write!(w, \"\n+        try!(write!(w, \"\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n         \"));\n         for m in provided.iter() {\n-            if_ok!(meth(w, *m));\n+            try!(meth(w, *m));\n         }\n-        if_ok!(write!(w, \"</div>\"));\n+        try!(write!(w, \"</div>\"));\n     }\n \n     local_data::get(cache_key, |cache| {\n         let cache = cache.unwrap().get();\n         match cache.implementors.find(&it.id) {\n             Some(implementors) => {\n-                if_ok!(write!(w, \"\n+                try!(write!(w, \"\n                     <h2 id='implementors'>Implementors</h2>\n                     <ul class='item-list'>\n                 \"));\n                 for i in implementors.iter() {\n                     match *i {\n                         PathType(ref ty) => {\n-                            if_ok!(write!(w, \"<li><code>{}</code></li>\", *ty));\n+                            try!(write!(w, \"<li><code>{}</code></li>\", *ty));\n                         }\n                         OtherType(ref generics, ref trait_, ref for_) => {\n-                            if_ok!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                            try!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n                                           *generics, *trait_, *for_));\n                         }\n                     }\n                 }\n-                if_ok!(write!(w, \"</ul>\"));\n+                try!(write!(w, \"</ul>\"));\n             }\n             None => {}\n         }\n@@ -1231,109 +1231,109 @@ fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n \n fn item_struct(w: &mut Writer, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n-    if_ok!(write!(w, \"<pre class='struct'>\"));\n-    if_ok!(render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n+    try!(write!(w, \"<pre class='struct'>\"));\n+    try!(render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n                          s.fields_stripped, \"\", true));\n-    if_ok!(write!(w, \"</pre>\"));\n+    try!(write!(w, \"</pre>\"));\n \n-    if_ok!(document(w, it));\n+    try!(document(w, it));\n     match s.struct_type {\n         doctree::Plain if s.fields.len() > 0 => {\n-            if_ok!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n+            try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in s.fields.iter() {\n-                if_ok!(write!(w, \"<tr><td id='structfield.{name}'>\\\n+                try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n                                   <code>{name}</code></td><td>\",\n                               name = field.name.get_ref().as_slice()));\n-                if_ok!(document(w, field));\n-                if_ok!(write!(w, \"</td></tr>\"));\n+                try!(document(w, field));\n+                try!(write!(w, \"</td></tr>\"));\n             }\n-            if_ok!(write!(w, \"</table>\"));\n+            try!(write!(w, \"</table>\"));\n         }\n         _ => {}\n     }\n     render_methods(w, it)\n }\n \n fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n-    if_ok!(write!(w, \"<pre class='enum'>{}enum {}{}\",\n+    try!(write!(w, \"<pre class='enum'>{}enum {}{}\",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n                   e.generics));\n     if e.variants.len() == 0 && !e.variants_stripped {\n-        if_ok!(write!(w, \" \\\\{\\\\}\"));\n+        try!(write!(w, \" \\\\{\\\\}\"));\n     } else {\n-        if_ok!(write!(w, \" \\\\{\\n\"));\n+        try!(write!(w, \" \\\\{\\n\"));\n         for v in e.variants.iter() {\n-            if_ok!(write!(w, \"    \"));\n+            try!(write!(w, \"    \"));\n             let name = v.name.get_ref().as_slice();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n-                        clean::CLikeVariant => if_ok!(write!(w, \"{}\", name)),\n+                        clean::CLikeVariant => try!(write!(w, \"{}\", name)),\n                         clean::TupleVariant(ref tys) => {\n-                            if_ok!(write!(w, \"{}(\", name));\n+                            try!(write!(w, \"{}(\", name));\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 {\n-                                    if_ok!(write!(w, \", \"))\n+                                    try!(write!(w, \", \"))\n                                 }\n-                                if_ok!(write!(w, \"{}\", *ty));\n+                                try!(write!(w, \"{}\", *ty));\n                             }\n-                            if_ok!(write!(w, \")\"));\n+                            try!(write!(w, \")\"));\n                         }\n                         clean::StructVariant(ref s) => {\n-                            if_ok!(render_struct(w, v, None, s.struct_type,\n+                            try!(render_struct(w, v, None, s.struct_type,\n                                                  s.fields, s.fields_stripped,\n                                                  \"    \", false));\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n-            if_ok!(write!(w, \",\\n\"));\n+            try!(write!(w, \",\\n\"));\n         }\n \n         if e.variants_stripped {\n-            if_ok!(write!(w, \"    // some variants omitted\\n\"));\n+            try!(write!(w, \"    // some variants omitted\\n\"));\n         }\n-        if_ok!(write!(w, \"\\\\}\"));\n+        try!(write!(w, \"\\\\}\"));\n     }\n-    if_ok!(write!(w, \"</pre>\"));\n+    try!(write!(w, \"</pre>\"));\n \n-    if_ok!(document(w, it));\n+    try!(document(w, it));\n     if e.variants.len() > 0 {\n-        if_ok!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n+        try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in e.variants.iter() {\n-            if_ok!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+            try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.get_ref().as_slice()));\n-            if_ok!(document(w, variant));\n+            try!(document(w, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n                         clean::StructVariant(ref s) => {\n-                            if_ok!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n+                            try!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n                                               <table>\"));\n                             for field in s.fields.iter() {\n-                                if_ok!(write!(w, \"<tr><td \\\n+                                try!(write!(w, \"<tr><td \\\n                                                   id='variant.{v}.field.{f}'>\\\n                                                   <code>{f}</code></td><td>\",\n                                               v = variant.name.get_ref().as_slice(),\n                                               f = field.name.get_ref().as_slice()));\n-                                if_ok!(document(w, field));\n-                                if_ok!(write!(w, \"</td></tr>\"));\n+                                try!(document(w, field));\n+                                try!(write!(w, \"</td></tr>\"));\n                             }\n-                            if_ok!(write!(w, \"</table>\"));\n+                            try!(write!(w, \"</table>\"));\n                         }\n                         _ => ()\n                     }\n                 }\n                 _ => ()\n             }\n-            if_ok!(write!(w, \"</td></tr>\"));\n+            try!(write!(w, \"</td></tr>\"));\n         }\n-        if_ok!(write!(w, \"</table>\"));\n+        try!(write!(w, \"</table>\"));\n \n     }\n-    if_ok!(render_methods(w, it));\n+    try!(render_methods(w, it));\n     Ok(())\n }\n \n@@ -1344,21 +1344,21 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n                  fields_stripped: bool,\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n-    if_ok!(write!(w, \"{}{}{}\",\n+    try!(write!(w, \"{}{}{}\",\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n                   it.name.get_ref().as_slice()));\n     match g {\n-        Some(g) => if_ok!(write!(w, \"{}\", *g)),\n+        Some(g) => try!(write!(w, \"{}\", *g)),\n         None => {}\n     }\n     match ty {\n         doctree::Plain => {\n-            if_ok!(write!(w, \" \\\\{\\n{}\", tab));\n+            try!(write!(w, \" \\\\{\\n{}\", tab));\n             for field in fields.iter() {\n                 match field.inner {\n                     clean::StructFieldItem(ref ty) => {\n-                        if_ok!(write!(w, \"    {}{}: {},\\n{}\",\n+                        try!(write!(w, \"    {}{}: {},\\n{}\",\n                                       VisSpace(field.visibility),\n                                       field.name.get_ref().as_slice(),\n                                       ty.type_,\n@@ -1369,27 +1369,27 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n             }\n \n             if fields_stripped {\n-                if_ok!(write!(w, \"    // some fields omitted\\n{}\", tab));\n+                try!(write!(w, \"    // some fields omitted\\n{}\", tab));\n             }\n-            if_ok!(write!(w, \"\\\\}\"));\n+            try!(write!(w, \"\\\\}\"));\n         }\n         doctree::Tuple | doctree::Newtype => {\n-            if_ok!(write!(w, \"(\"));\n+            try!(write!(w, \"(\"));\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n-                    if_ok!(write!(w, \", \"));\n+                    try!(write!(w, \", \"));\n                 }\n                 match field.inner {\n                     clean::StructFieldItem(ref field) => {\n-                        if_ok!(write!(w, \"{}\", field.type_));\n+                        try!(write!(w, \"{}\", field.type_));\n                     }\n                     _ => unreachable!()\n                 }\n             }\n-            if_ok!(write!(w, \");\"));\n+            try!(write!(w, \");\"));\n         }\n         doctree::Unit => {\n-            if_ok!(write!(w, \";\"));\n+            try!(write!(w, \";\"));\n         }\n     }\n     Ok(())\n@@ -1410,16 +1410,16 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n                 let traits = traits.to_owned_vec();\n \n                 if non_trait.len() > 0 {\n-                    if_ok!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+                    try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                     for &(ref i, ref dox) in non_trait.move_iter() {\n-                        if_ok!(render_impl(w, i, dox));\n+                        try!(render_impl(w, i, dox));\n                     }\n                 }\n                 if traits.len() > 0 {\n-                    if_ok!(write!(w, \"<h2 id='implementations'>Trait \\\n+                    try!(write!(w, \"<h2 id='implementations'>Trait \\\n                                       Implementations</h2>\"));\n                     for &(ref i, ref dox) in traits.move_iter() {\n-                        if_ok!(render_impl(w, i, dox));\n+                        try!(render_impl(w, i, dox));\n                     }\n                 }\n             }\n@@ -1431,43 +1431,43 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n \n fn render_impl(w: &mut Writer, i: &clean::Impl,\n                dox: &Option<~str>) -> fmt::Result {\n-    if_ok!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n+    try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n-            if_ok!(write!(w, \"{} for \", *ty));\n+            try!(write!(w, \"{} for \", *ty));\n             match *ty {\n                 clean::ResolvedPath { id, .. } => Some(id),\n                 _ => None,\n             }\n         }\n         None => None\n     };\n-    if_ok!(write!(w, \"{}</code></h3>\", i.for_));\n+    try!(write!(w, \"{}</code></h3>\", i.for_));\n     match *dox {\n         Some(ref dox) => {\n-            if_ok!(write!(w, \"<div class='docblock'>{}</div>\",\n+            try!(write!(w, \"<div class='docblock'>{}</div>\",\n                           Markdown(dox.as_slice())));\n         }\n         None => {}\n     }\n \n     fn docmeth(w: &mut Writer, item: &clean::Item) -> io::IoResult<bool> {\n-        if_ok!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n+        try!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                       *item.name.get_ref()));\n-        if_ok!(render_method(w, item));\n-        if_ok!(write!(w, \"</code></h4>\\n\"));\n+        try!(render_method(w, item));\n+        try!(write!(w, \"</code></h4>\\n\"));\n         match item.doc_value() {\n             Some(s) => {\n-                if_ok!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n+                try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n                 Ok(true)\n             }\n             None => Ok(false)\n         }\n     }\n \n-    if_ok!(write!(w, \"<div class='methods'>\"));\n+    try!(write!(w, \"<div class='methods'>\"));\n     for meth in i.methods.iter() {\n-        if if_ok!(docmeth(w, meth)) {\n+        if try!(docmeth(w, meth)) {\n             continue\n         }\n \n@@ -1476,7 +1476,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n             None => continue,\n             Some(id) => id,\n         };\n-        if_ok!(local_data::get(cache_key, |cache| {\n+        try!(local_data::get(cache_key, |cache| {\n             let cache = cache.unwrap().get();\n             match cache.traits.find(&trait_id) {\n                 Some(t) => {\n@@ -1485,7 +1485,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n                         Some(method) => {\n                             match method.item().doc_value() {\n                                 Some(s) => {\n-                                    if_ok!(write!(w,\n+                                    try!(write!(w,\n                                                   \"<div class='docblock'>{}</div>\",\n                                                   Markdown(s)));\n                                 }\n@@ -1506,7 +1506,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n     match trait_id {\n         None => {}\n         Some(id) => {\n-            if_ok!(local_data::get(cache_key, |cache| {\n+            try!(local_data::get(cache_key, |cache| {\n                 let cache = cache.unwrap().get();\n                 match cache.traits.find(&id) {\n                     Some(t) => {\n@@ -1517,7 +1517,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n                                 None => {}\n                             }\n \n-                            if_ok!(docmeth(w, method.item()));\n+                            try!(docmeth(w, method.item()));\n                         }\n                     }\n                     None => {}\n@@ -1526,13 +1526,13 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n             }))\n         }\n     }\n-    if_ok!(write!(w, \"</div>\"));\n+    try!(write!(w, \"</div>\"));\n     Ok(())\n }\n \n fn item_typedef(w: &mut Writer, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n-    if_ok!(write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n+    try!(write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n                   t.type_));\n@@ -1544,29 +1544,29 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n-        if_ok!(write!(fmt.buf, \"<p class='location'>\"));\n+        try!(write!(fmt.buf, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n             if i > 0 {\n-                if_ok!(write!(fmt.buf, \"&\\\\#8203;::\"));\n+                try!(write!(fmt.buf, \"&\\\\#8203;::\"));\n             }\n-            if_ok!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n+            try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n                           cx.root_path.slice_to((cx.current.len() - i - 1) * 3),\n                           *name));\n         }\n-        if_ok!(write!(fmt.buf, \"</p>\"));\n+        try!(write!(fmt.buf, \"</p>\"));\n \n         fn block(w: &mut Writer, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),\n                 None => return Ok(())\n             };\n-            if_ok!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n+            try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let class = if cur.name.get_ref() == item &&\n                                short == shortty(cur) { \"current\" } else { \"\" };\n-                if_ok!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n+                try!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n                                 mod{../}\n                                 other{}\n                            }{tysel, select,\n@@ -1579,15 +1579,15 @@ impl<'a> fmt::Show for Sidebar<'a> {\n                        curty = shortty(cur),\n                        name = item.as_slice()));\n             }\n-            if_ok!(write!(w, \"</div>\"));\n+            try!(write!(w, \"</div>\"));\n             Ok(())\n         }\n \n-        if_ok!(block(fmt.buf, \"mod\", \"Modules\", it, cx));\n-        if_ok!(block(fmt.buf, \"struct\", \"Structs\", it, cx));\n-        if_ok!(block(fmt.buf, \"enum\", \"Enums\", it, cx));\n-        if_ok!(block(fmt.buf, \"trait\", \"Traits\", it, cx));\n-        if_ok!(block(fmt.buf, \"fn\", \"Functions\", it, cx));\n+        try!(block(fmt.buf, \"mod\", \"Modules\", it, cx));\n+        try!(block(fmt.buf, \"struct\", \"Structs\", it, cx));\n+        try!(block(fmt.buf, \"enum\", \"Enums\", it, cx));\n+        try!(block(fmt.buf, \"trait\", \"Traits\", it, cx));\n+        try!(block(fmt.buf, \"fn\", \"Functions\", it, cx));\n         Ok(())\n     }\n }\n@@ -1620,20 +1620,20 @@ impl<'a> fmt::Show for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        if_ok!(write!(fmt.buf, \"<pre class='line-numbers'>\"));\n+        try!(write!(fmt.buf, \"<pre class='line-numbers'>\"));\n         for i in range(1, lines + 1) {\n-            if_ok!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n+            try!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n         }\n-        if_ok!(write!(fmt.buf, \"</pre>\"));\n-        if_ok!(write!(fmt.buf, \"<pre class='rust'>\"));\n-        if_ok!(write!(fmt.buf, \"{}\", Escape(s.as_slice())));\n-        if_ok!(write!(fmt.buf, \"</pre>\"));\n+        try!(write!(fmt.buf, \"</pre>\"));\n+        try!(write!(fmt.buf, \"<pre class='rust'>\"));\n+        try!(write!(fmt.buf, \"{}\", Escape(s.as_slice())));\n+        try!(write!(fmt.buf, \"</pre>\"));\n         Ok(())\n     }\n }\n \n fn item_macro(w: &mut Writer, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    if_ok!(write!(w, \"<pre class='macro'>{}</pre>\", t.source));\n+    try!(write!(w, \"<pre class='macro'>{}</pre>\", t.source));\n     document(w, it)\n }"}, {"sha": "6502ab1dce36d8d57165523ee60f95415a23e46a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -351,7 +351,7 @@ fn json_output(krate: clean::Crate, res: ~[plugins::PluginJson],\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let mut file = if_ok!(File::create(&dst));\n-    if_ok!(json::Object(json).to_writer(&mut file));\n+    let mut file = try!(File::create(&dst));\n+    try!(json::Object(json).to_writer(&mut file));\n     Ok(())\n }"}, {"sha": "d03d230d8bfd4cab8c4d5de680b3426e057016a4", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -99,19 +99,19 @@ pub struct Version {\n impl fmt::Show for Version {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"{}.{}.{}\", self.major, self.minor, self.patch))\n+        try!(write!(f.buf, \"{}.{}.{}\", self.major, self.minor, self.patch))\n         if !self.pre.is_empty() {\n-            if_ok!(write!(f.buf, \"-\"));\n+            try!(write!(f.buf, \"-\"));\n             for (i, x) in self.pre.iter().enumerate() {\n-                if i != 0 { if_ok!(write!(f.buf, \".\")) };\n-                if_ok!(x.fmt(f));\n+                if i != 0 { try!(write!(f.buf, \".\")) };\n+                try!(x.fmt(f));\n             }\n         }\n         if !self.build.is_empty() {\n-            if_ok!(write!(f.buf, \"+\"));\n+            try!(write!(f.buf, \"+\"));\n             for (i, x) in self.build.iter().enumerate() {\n-                if i != 0 { if_ok!(write!(f.buf, \".\")) };\n-                if_ok!(x.fmt(f));\n+                if i != 0 { try!(write!(f.buf, \".\")) };\n+                try!(x.fmt(f));\n             }\n         }\n         Ok(())"}, {"sha": "e65c21a6b5f8664e66eccaa9f450825f3f60147b", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -12,7 +12,7 @@\n \n use std::str;\n \n-macro_rules! if_ok( ($e:expr) => (\n+macro_rules! try( ($e:expr) => (\n     match $e { Ok(e) => e, Err(e) => { self.last_error = Err(e); return } }\n ) )\n \n@@ -665,18 +665,18 @@ pub mod writer {\n             write_vuint(self.writer, tag_id);\n \n             // Write a placeholder four-byte size.\n-            self.size_positions.push(if_ok!(self.writer.tell()) as uint);\n+            self.size_positions.push(try!(self.writer.tell()) as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            if_ok!(self.writer.write(zeroes));\n+            try!(self.writer.write(zeroes));\n         }\n \n         pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = if_ok!(self.writer.tell());\n-            if_ok!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n+            let cur_pos = try!(self.writer.tell());\n+            try!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n             let size = (cur_pos as uint - last_size_pos - 4);\n             write_sized_vuint(self.writer, size, 4u);\n-            if_ok!(self.writer.seek(cur_pos as i64, io::SeekSet));\n+            try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n \n             debug!(\"End tag (size = {})\", size);\n         }"}, {"sha": "9c70d34cc0f44969aa64312fc7057633807adbc8", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -702,7 +702,7 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n         curarg: args.iter(),\n     };\n     for piece in fmt.iter() {\n-        if_ok!(formatter.run(piece, None));\n+        try!(formatter.run(piece, None));\n     }\n     Ok(())\n }\n@@ -859,13 +859,13 @@ impl<'a> Formatter<'a> {\n                 for s in selectors.iter() {\n                     if s.selector == value {\n                         for piece in s.result.iter() {\n-                            if_ok!(self.run(piece, Some(value)));\n+                            try!(self.run(piece, Some(value)));\n                         }\n                         return Ok(());\n                     }\n                 }\n                 for piece in default.iter() {\n-                    if_ok!(self.run(piece, Some(value)));\n+                    try!(self.run(piece, Some(value)));\n                 }\n                 Ok(())\n             }\n@@ -876,7 +876,7 @@ impl<'a> Formatter<'a> {\n         ::uint::to_str_bytes(value, 10, |buf| {\n             let valuestr = str::from_utf8(buf).unwrap();\n             for piece in pieces.iter() {\n-                if_ok!(self.run(piece, Some(valuestr)));\n+                try!(self.run(piece, Some(valuestr)));\n             }\n             Ok(())\n         })\n@@ -917,12 +917,12 @@ impl<'a> Formatter<'a> {\n         let sign = |this: &mut Formatter| {\n             if !signprinted {\n                 if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                    if_ok!(this.buf.write(['+' as u8]));\n+                    try!(this.buf.write(['+' as u8]));\n                 } else if !positive {\n-                    if_ok!(this.buf.write(['-' as u8]));\n+                    try!(this.buf.write(['-' as u8]));\n                 }\n                 if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                    if_ok!(this.buf.write(alternate_prefix.as_bytes()));\n+                    try!(this.buf.write(alternate_prefix.as_bytes()));\n                 }\n                 signprinted = true;\n             }\n@@ -939,7 +939,7 @@ impl<'a> Formatter<'a> {\n             Some(min) => {\n                 if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n                     self.fill = '0';\n-                    if_ok!(sign(self));\n+                    try!(sign(self));\n                 }\n                 self.with_padding(min - actual_len, parse::AlignRight, |me| {\n                     emit(me)\n@@ -1011,15 +1011,15 @@ impl<'a> Formatter<'a> {\n             parse::AlignLeft | parse::AlignRight => self.align\n         };\n         if align == parse::AlignLeft {\n-            if_ok!(f(self));\n+            try!(f(self));\n         }\n         let mut fill = [0u8, ..4];\n         let len = self.fill.encode_utf8(fill);\n         for _ in range(0, padding) {\n-            if_ok!(self.buf.write(fill.slice_to(len)));\n+            try!(self.buf.write(fill.slice_to(len)));\n         }\n         if align == parse::AlignRight {\n-            if_ok!(f(self));\n+            try!(f(self));\n         }\n         Ok(())\n     }"}, {"sha": "5d4db10672844e0fbb22ed06e5df7af7de1e9b6f", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -599,15 +599,15 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n \n impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for HashMap<A, B> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, r\"\\{\"))\n+        try!(write!(f.buf, r\"\\{\"))\n         let mut first = true;\n         for (key, value) in self.iter() {\n             if first {\n                 first = false;\n             } else {\n-                if_ok!(write!(f.buf, \", \"));\n+                try!(write!(f.buf, \", \"));\n             }\n-            if_ok!(write!(f.buf, \"{}: {}\", *key, *value));\n+            try!(write!(f.buf, \"{}: {}\", *key, *value));\n         }\n         write!(f.buf, r\"\\}\")\n     }\n@@ -877,15 +877,15 @@ impl<T:Hash + Eq + Clone> Clone for HashSet<T> {\n \n impl<A: fmt::Show + Hash + Eq> fmt::Show for HashSet<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, r\"\\{\"))\n+        try!(write!(f.buf, r\"\\{\"))\n         let mut first = true;\n         for x in self.iter() {\n             if first {\n                 first = false;\n             } else {\n-                if_ok!(write!(f.buf, \", \"));\n+                try!(write!(f.buf, \", \"));\n             }\n-            if_ok!(write!(f.buf, \"{}\", *x));\n+            try!(write!(f.buf, \"{}\", *x));\n         }\n         write!(f.buf, r\"\\}\")\n     }"}, {"sha": "df2a800c2920db25f5c627a862a3c84168f4ca14", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -88,7 +88,7 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = if_ok!(self.inner.read(self.buf));\n+            self.cap = try!(self.inner.read(self.buf));\n             self.pos = 0;\n         }\n         Ok(self.buf.slice(self.pos, self.cap))\n@@ -103,7 +103,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let nread = {\n-            let available = if_ok!(self.fill());\n+            let available = try!(self.fill());\n             let nread = cmp::min(available.len(), buf.len());\n             vec::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n@@ -182,7 +182,7 @@ impl<W: Writer> BufferedWriter<W> {\n impl<W: Writer> Writer for BufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos + buf.len() > self.buf.len() {\n-            if_ok!(self.flush_buf());\n+            try!(self.flush_buf());\n         }\n \n         if buf.len() > self.buf.len() {\n@@ -233,9 +233,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == '\\n' as u8) {\n             Some(i) => {\n-                if_ok!(self.inner.write(buf.slice_to(i + 1)));\n-                if_ok!(self.inner.flush());\n-                if_ok!(self.inner.write(buf.slice_from(i + 1)));\n+                try!(self.inner.write(buf.slice_to(i + 1)));\n+                try!(self.inner.flush());\n+                try!(self.inner.write(buf.slice_from(i + 1)));\n                 Ok(())\n             }\n             None => self.inner.write(buf),"}, {"sha": "7f2af92b078122e7082a3a35b3033e0880f16417", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -339,8 +339,8 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n         })\n     }\n \n-    let mut reader = if_ok!(File::open(from));\n-    let mut writer = if_ok!(File::create(to));\n+    let mut reader = try!(File::open(from));\n+    let mut writer = try!(File::create(to));\n     let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n \n     loop {\n@@ -349,10 +349,10 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n             Err(e) => return Err(e)\n         };\n-        if_ok!(writer.write(buf.slice_to(amt)));\n+        try!(writer.write(buf.slice_to(amt)));\n     }\n \n-    chmod(to, if_ok!(from.stat()).perm)\n+    chmod(to, try!(from.stat()).perm)\n }\n \n /// Changes the permission mode bits found on a file or a directory. This\n@@ -460,10 +460,10 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// // one possible implementation of fs::walk_dir only visiting files\n /// fn visit_dirs(dir: &Path, cb: |&Path|) -> io::IoResult<()> {\n ///     if dir.is_dir() {\n-///         let contents = if_ok!(fs::readdir(dir));\n+///         let contents = try!(fs::readdir(dir));\n ///         for entry in contents.iter() {\n ///             if entry.is_dir() {\n-///                 if_ok!(visit_dirs(entry, |p| cb(p)));\n+///                 try!(visit_dirs(entry, |p| cb(p)));\n ///             } else {\n ///                 cb(entry);\n ///             }\n@@ -490,7 +490,7 @@ pub fn readdir(path: &Path) -> IoResult<~[Path]> {\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in a top-down order.\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n-    Ok(Directories { stack: if_ok!(readdir(path)) })\n+    Ok(Directories { stack: try!(readdir(path)) })\n }\n \n /// An iterator which walks over a directory\n@@ -529,7 +529,7 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n         return Ok(())\n     }\n     if path.filename().is_some() {\n-        if_ok!(mkdir_recursive(&path.dir_path(), mode));\n+        try!(mkdir_recursive(&path.dir_path(), mode));\n     }\n     mkdir(path, mode)\n }\n@@ -542,12 +542,12 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This function will return an `Err` value if an error happens. See\n /// `file::unlink` and `fs::readdir` for possible error conditions.\n pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n-    let children = if_ok!(readdir(path));\n+    let children = try!(readdir(path));\n     for child in children.iter() {\n         if child.is_dir() {\n-            if_ok!(rmdir_recursive(child));\n+            try!(rmdir_recursive(child));\n         } else {\n-            if_ok!(unlink(child));\n+            try!(unlink(child));\n         }\n     }\n     // Directory should now be empty"}, {"sha": "49c37b4520f4eb91eda1390df792050b4710ab3c", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -113,7 +113,7 @@ impl Writer for MemWriter {\n impl Seek for MemWriter {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n         Ok(())\n     }\n@@ -183,7 +183,7 @@ impl Reader for MemReader {\n impl Seek for MemReader {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n         Ok(())\n     }\n@@ -253,7 +253,7 @@ impl<'a> Writer for BufWriter<'a> {\n impl<'a> Seek for BufWriter<'a> {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n         Ok(())\n     }\n@@ -313,7 +313,7 @@ impl<'a> Reader for BufReader<'a> {\n impl<'a> Seek for BufReader<'a> {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n         Ok(())\n     }"}, {"sha": "db5ee09fa14c93cbf77b41df7f53a16318a7eb60", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -365,7 +365,7 @@ pub struct IoError {\n \n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(fmt.buf.write_str(self.desc));\n+        try!(fmt.buf.write_str(self.desc));\n         match self.detail {\n             Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n             None => Ok(())\n@@ -581,7 +581,7 @@ pub trait Reader {\n         let mut pos = 0;\n         let mut i = nbytes;\n         while i > 0 {\n-            val += (if_ok!(self.read_u8()) as u64) << pos;\n+            val += (try!(self.read_u8()) as u64) << pos;\n             pos += 8;\n             i -= 1;\n         }\n@@ -605,7 +605,7 @@ pub trait Reader {\n         let mut i = nbytes;\n         while i > 0 {\n             i -= 1;\n-            val += (if_ok!(self.read_u8()) as u64) << i * 8;\n+            val += (try!(self.read_u8()) as u64) << i * 8;\n         }\n         Ok(val)\n     }\n@@ -1191,15 +1191,15 @@ pub trait Buffer: Reader {\n     /// This function will also return error if the stream does not contain a\n     /// valid utf-8 encoded codepoint as the next few bytes in the stream.\n     fn read_char(&mut self) -> IoResult<char> {\n-        let first_byte = if_ok!(self.read_byte());\n+        let first_byte = try!(self.read_byte());\n         let width = str::utf8_char_width(first_byte);\n         if width == 1 { return Ok(first_byte as char) }\n         if width == 0 { return Err(standard_error(InvalidInput)) } // not utf8\n         let mut buf = [first_byte, 0, 0, 0];\n         {\n             let mut start = 1;\n             while start < width {\n-                match if_ok!(self.read(buf.mut_slice(start, width))) {\n+                match try!(self.read(buf.mut_slice(start, width))) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),"}, {"sha": "acaffd00665bf63a4797f832a02f855da6c763ee", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -189,7 +189,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        if_ok!(w.write(buf.slice_to(len)));\n+        try!(w.write(buf.slice_to(len)));\n     }\n }\n "}, {"sha": "3e8a4d24f3e9064966d3bf40d1df6f9f9ecfbc1e", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -355,6 +355,6 @@ macro_rules! local_data_key(\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n-macro_rules! if_ok(\n+macro_rules! try(\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n )"}, {"sha": "d367aaa6dc49e305e0fd5c6a16331fccb3d4db58", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -32,7 +32,7 @@ use vec::OwnedVector;\n use unstable::intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use unstable::raw;\n \n-macro_rules! if_ok( ($me:expr, $e:expr) => (\n+macro_rules! try( ($me:expr, $e:expr) => (\n     match $e {\n         Ok(()) => {},\n         Err(e) => { $me.last_err = Some(e); return false; }\n@@ -181,23 +181,23 @@ impl<'a> ReprVisitor<'a> {\n     #[inline]\n     pub fn write<T:Repr>(&mut self) -> bool {\n         self.get(|this, v:&T| {\n-            if_ok!(this, v.write_repr(this.writer));\n+            try!(this, v.write_repr(this.writer));\n             true\n         })\n     }\n \n     pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n-        if_ok!(self, self.writer.write(['\"' as u8]));\n+        try!(self, self.writer.write(['\"' as u8]));\n         for ch in slice.chars() {\n             if !self.write_escaped_char(ch, true) { return false }\n         }\n-        if_ok!(self, self.writer.write(['\"' as u8]));\n+        try!(self, self.writer.write(['\"' as u8]));\n         true\n     }\n \n     pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {\n         if mtbl == 0 {\n-            if_ok!(self, self.writer.write(\"mut \".as_bytes()));\n+            try!(self, self.writer.write(\"mut \".as_bytes()));\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n@@ -209,7 +209,7 @@ impl<'a> ReprVisitor<'a> {\n     pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n         let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        if_ok!(self, self.writer.write(['[' as u8]));\n+        try!(self, self.writer.write(['[' as u8]));\n         let mut first = true;\n         let mut left = len;\n         // unit structs have 0 size, and don't loop forever.\n@@ -218,13 +218,13 @@ impl<'a> ReprVisitor<'a> {\n             if first {\n                 first = false;\n             } else {\n-                if_ok!(self, self.writer.write(\", \".as_bytes()));\n+                try!(self, self.writer.write(\", \".as_bytes()));\n             }\n             self.visit_ptr_inner(p as *u8, inner);\n             p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n-        if_ok!(self, self.writer.write([']' as u8]));\n+        try!(self, self.writer.write([']' as u8]));\n         true\n     }\n \n@@ -233,7 +233,7 @@ impl<'a> ReprVisitor<'a> {\n     }\n \n     fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n-        if_ok!(self, match ch {\n+        try!(self, match ch {\n             '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n             '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n             '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n@@ -266,7 +266,7 @@ impl<'a> ReprVisitor<'a> {\n \n impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_bot(&mut self) -> bool {\n-        if_ok!(self, self.writer.write(\"!\".as_bytes()));\n+        try!(self, self.writer.write(\"!\".as_bytes()));\n         true\n     }\n     fn visit_nil(&mut self) -> bool { self.write::<()>() }\n@@ -288,9 +288,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_char(&mut self) -> bool {\n         self.get::<char>(|this, &ch| {\n-            if_ok!(this, this.writer.write(['\\'' as u8]));\n+            try!(this, this.writer.write(['\\'' as u8]));\n             if !this.write_escaped_char(ch, false) { return false }\n-            if_ok!(this, this.writer.write(['\\'' as u8]));\n+            try!(this, this.writer.write(['\\'' as u8]));\n             true\n         })\n     }\n@@ -301,7 +301,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_estr_uniq(&mut self) -> bool {\n         self.get::<~str>(|this, s| {\n-            if_ok!(this, this.writer.write(['~' as u8]));\n+            try!(this, this.writer.write(['~' as u8]));\n             this.write_escaped_slice(*s)\n         })\n     }\n@@ -315,7 +315,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                         _align: uint) -> bool { fail!(); }\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        if_ok!(self, self.writer.write(['@' as u8]));\n+        try!(self, self.writer.write(['@' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n             let p = &b.data as *() as *u8;\n@@ -324,23 +324,23 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        if_ok!(self, self.writer.write(['~' as u8]));\n+        try!(self, self.writer.write(['~' as u8]));\n         self.get::<*u8>(|this, b| {\n             this.visit_ptr_inner(*b, inner)\n         })\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n         self.get::<*u8>(|this, p| {\n-            if_ok!(this, write!(this.writer, \"({} as *\", *p));\n+            try!(this, write!(this.writer, \"({} as *\", *p));\n             this.write_mut_qualifier(mtbl);\n-            if_ok!(this, this.writer.write(\"())\".as_bytes()));\n+            try!(this, this.writer.write(\"())\".as_bytes()));\n             true\n         })\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        if_ok!(self, self.writer.write(['&' as u8]));\n+        try!(self, self.writer.write(['&' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<*u8>(|this, p| {\n             this.visit_ptr_inner(*p, inner)\n@@ -358,22 +358,22 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            if_ok!(this, this.writer.write(['@' as u8]));\n+            try!(this, this.writer.write(['@' as u8]));\n             this.write_mut_qualifier(mtbl);\n             this.write_unboxed_vec_repr(mtbl, &b.data, inner)\n         })\n     }\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Vec<()>>(|this, b| {\n-            if_ok!(this, this.writer.write(['~' as u8]));\n+            try!(this, this.writer.write(['~' as u8]));\n             this.write_unboxed_vec_repr(mtbl, *b, inner)\n         })\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n-            if_ok!(this, this.writer.write(['&' as u8]));\n+            try!(this, this.writer.write(['&' as u8]));\n             this.write_mut_qualifier(mtbl);\n             let size = unsafe {\n                 if (*inner).size == 0 { 1 } else { (*inner).size }\n@@ -392,36 +392,36 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        if_ok!(self, self.writer.write(['{' as u8]));\n+        try!(self, self.writer.write(['{' as u8]));\n         true\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            if_ok!(self, self.writer.write(\", \".as_bytes()));\n+            try!(self, self.writer.write(\", \".as_bytes()));\n         }\n         self.write_mut_qualifier(mtbl);\n-        if_ok!(self, self.writer.write(name.as_bytes()));\n-        if_ok!(self, self.writer.write(\": \".as_bytes()));\n+        try!(self, self.writer.write(name.as_bytes()));\n+        try!(self, self.writer.write(\": \".as_bytes()));\n         self.visit_inner(inner);\n         true\n     }\n \n     fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        if_ok!(self, self.writer.write(['}' as u8]));\n+        try!(self, self.writer.write(['}' as u8]));\n         true\n     }\n \n     fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          _sz: uint, _align: uint) -> bool {\n-        if_ok!(self, self.writer.write(name.as_bytes()));\n+        try!(self, self.writer.write(name.as_bytes()));\n         if n_fields != 0 {\n             if named_fields {\n-                if_ok!(self, self.writer.write(['{' as u8]));\n+                try!(self, self.writer.write(['{' as u8]));\n             } else {\n-                if_ok!(self, self.writer.write(['(' as u8]));\n+                try!(self, self.writer.write(['(' as u8]));\n             }\n         }\n         true\n@@ -430,11 +430,11 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n                          _mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            if_ok!(self, self.writer.write(\", \".as_bytes()));\n+            try!(self, self.writer.write(\", \".as_bytes()));\n         }\n         if named {\n-            if_ok!(self, self.writer.write(name.as_bytes()));\n-            if_ok!(self, self.writer.write(\": \".as_bytes()));\n+            try!(self, self.writer.write(name.as_bytes()));\n+            try!(self, self.writer.write(\": \".as_bytes()));\n         }\n         self.visit_inner(inner);\n         true\n@@ -444,23 +444,23 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                          _sz: uint, _align: uint) -> bool {\n         if n_fields != 0 {\n             if named_fields {\n-                if_ok!(self, self.writer.write(['}' as u8]));\n+                try!(self, self.writer.write(['}' as u8]));\n             } else {\n-                if_ok!(self, self.writer.write([')' as u8]));\n+                try!(self, self.writer.write([')' as u8]));\n             }\n         }\n         true\n     }\n \n     fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        if_ok!(self, self.writer.write(['(' as u8]));\n+        try!(self, self.writer.write(['(' as u8]));\n         true\n     }\n \n     fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            if_ok!(self, self.writer.write(\", \".as_bytes()));\n+            try!(self, self.writer.write(\", \".as_bytes()));\n         }\n         self.visit_inner(inner);\n         true\n@@ -469,9 +469,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         if _n_fields == 1 {\n-            if_ok!(self, self.writer.write([',' as u8]));\n+            try!(self, self.writer.write([',' as u8]));\n         }\n-        if_ok!(self, self.writer.write([')' as u8]));\n+        try!(self, self.writer.write([')' as u8]));\n         true\n     }\n \n@@ -507,9 +507,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         }\n \n         if write {\n-            if_ok!(self, self.writer.write(name.as_bytes()));\n+            try!(self, self.writer.write(name.as_bytes()));\n             if n_fields > 0 {\n-                if_ok!(self, self.writer.write(['(' as u8]));\n+                try!(self, self.writer.write(['(' as u8]));\n             }\n         }\n         true\n@@ -523,7 +523,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n-                    if_ok!(self, self.writer.write(\", \".as_bytes()));\n+                    try!(self, self.writer.write(\", \".as_bytes()));\n                 }\n                 if ! self.visit_inner(inner) {\n                     return false;\n@@ -541,7 +541,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n-                    if_ok!(self, self.writer.write([')' as u8]));\n+                    try!(self, self.writer.write([')' as u8]));\n                 }\n             }\n             _ => ()\n@@ -563,29 +563,29 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool {\n-        if_ok!(self, self.writer.write(\"fn(\".as_bytes()));\n+        try!(self, self.writer.write(\"fn(\".as_bytes()));\n         true\n     }\n \n     fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            if_ok!(self, self.writer.write(\", \".as_bytes()));\n+            try!(self, self.writer.write(\", \".as_bytes()));\n         }\n         let name = unsafe { (*inner).name };\n-        if_ok!(self, self.writer.write(name.as_bytes()));\n+        try!(self, self.writer.write(name.as_bytes()));\n         true\n     }\n \n     fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n                        inner: *TyDesc) -> bool {\n         if variadic {\n-            if_ok!(self, self.writer.write(\", ...\".as_bytes()));\n+            try!(self, self.writer.write(\", ...\".as_bytes()));\n         }\n-        if_ok!(self, self.writer.write(\")\".as_bytes()));\n+        try!(self, self.writer.write(\")\".as_bytes()));\n         let name = unsafe { (*inner).name };\n         if name != \"()\" {\n-            if_ok!(self, self.writer.write(\" -> \".as_bytes()));\n-            if_ok!(self, self.writer.write(name.as_bytes()));\n+            try!(self, self.writer.write(\" -> \".as_bytes()));\n+            try!(self, self.writer.write(name.as_bytes()));\n         }\n         true\n     }\n@@ -595,7 +595,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n \n     fn visit_trait(&mut self, name: &str) -> bool {\n-        if_ok!(self, self.writer.write(name.as_bytes()));\n+        try!(self, self.writer.write(name.as_bytes()));\n         true\n     }\n "}, {"sha": "b0d51cba103d4a07e569498e70de4524504c02fd", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -161,9 +161,9 @@ macro_rules! write_tuple {\n         write!($buf, \"({},)\", *$x)\n     );\n     ($buf:expr, $hd:expr, $($tl:expr),+) => ({\n-        if_ok!(write!($buf, \"(\"));\n-        if_ok!(write!($buf, \"{}\", *$hd));\n-        $(if_ok!(write!($buf, \", {}\", *$tl));)+\n+        try!(write!($buf, \"(\"));\n+        try!(write!($buf, \"{}\", *$hd));\n+        $(try!(write!($buf, \", {}\", *$tl));)+\n         write!($buf, \")\")\n     });\n }"}, {"sha": "5a42df0a38937f225ac176e6c1d6461cfb8b4a0c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -2645,15 +2645,15 @@ impl<A: DeepClone> DeepClone for ~[A] {\n \n impl<'a, T: fmt::Show> fmt::Show for &'a [T] {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"[\"));\n+        try!(write!(f.buf, \"[\"));\n         let mut is_first = true;\n         for x in self.iter() {\n             if is_first {\n                 is_first = false;\n             } else {\n-                if_ok!(write!(f.buf, \", \"));\n+                try!(write!(f.buf, \", \"));\n             }\n-            if_ok!(write!(f.buf, \"{}\", *x))\n+            try!(write!(f.buf, \"{}\", *x))\n         }\n         write!(f.buf, \"]\")\n     }"}, {"sha": "9455df063f117cfefc3ae675c173dd2b461b5140", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -192,9 +192,9 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) -> io::IoResult<()> {\n     }\n     fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str,\n                                c: term::attr::Attr) -> io::IoResult<()> {\n-        if_ok!(term.attr(c));\n-        if_ok!(term.write(s.as_bytes()));\n-        if_ok!(term.reset());\n+        try!(term.attr(c));\n+        try!(term.write(s.as_bytes()));\n+        try!(term.reset());\n         Ok(())\n     }\n \n@@ -230,12 +230,12 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) -> io::IoResult<()> {\n fn print_diagnostic(topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n     if !topic.is_empty() {\n         let mut stderr = io::stderr();\n-        if_ok!(write!(&mut stderr as &mut io::Writer, \"{} \", topic));\n+        try!(write!(&mut stderr as &mut io::Writer, \"{} \", topic));\n     }\n \n-    if_ok!(print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n+    try!(print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n                               term::attr::ForegroundColor(lvl.color())));\n-    if_ok!(print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold));\n+    try!(print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold));\n     Ok(())\n }\n \n@@ -276,11 +276,11 @@ fn emit(cm: &codemap::CodeMap, sp: Span,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_str(span_end);\n-        if_ok!(print_diagnostic(ses, lvl, msg));\n-        if_ok!(custom_highlight_lines(cm, sp, lvl, lines));\n+        try!(print_diagnostic(ses, lvl, msg));\n+        try!(custom_highlight_lines(cm, sp, lvl, lines));\n     } else {\n-        if_ok!(print_diagnostic(ss, lvl, msg));\n-        if_ok!(highlight_lines(cm, sp, lvl, lines));\n+        try!(print_diagnostic(ss, lvl, msg));\n+        try!(highlight_lines(cm, sp, lvl, lines));\n     }\n     print_macro_backtrace(cm, sp)\n }\n@@ -301,13 +301,13 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name, *line + 1,\n+        try!(write!(err, \"{}:{} {}\\n\", fm.name, *line + 1,\n                       fm.get_line(*line as int)));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        if_ok!(write!(err, \"{0:1$}...\\n\", \"\", s.len()));\n+        try!(write!(err, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n@@ -339,15 +339,15 @@ fn highlight_lines(cm: &codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        if_ok!(write!(err, \"{}\", s));\n+        try!(write!(err, \"{}\", s));\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) { s.push_char('~'); }\n         }\n-        if_ok!(print_maybe_styled(s + \"\\n\",\n+        try!(print_maybe_styled(s + \"\\n\",\n                                   term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n@@ -369,15 +369,15 @@ fn custom_highlight_lines(cm: &codemap::CodeMap,\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n-        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+        try!(write!(err, \"{}:{} {}\\n\", fm.name,\n                       lines[0] + 1, fm.get_line(lines[0] as int)));\n-        if_ok!(write!(err, \"...\\n\"));\n+        try!(write!(err, \"...\\n\"));\n         let last_line = lines[lines.len()-1];\n-        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+        try!(write!(err, \"{}:{} {}\\n\", fm.name,\n                       last_line + 1, fm.get_line(last_line as int)));\n     } else {\n         for line in lines.iter() {\n-            if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+            try!(write!(err, \"{}:{} {}\\n\", fm.name,\n                           *line + 1, fm.get_line(*line as int)));\n         }\n     }\n@@ -398,12 +398,12 @@ fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) -> io::IoResult<()> {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n         };\n-        if_ok!(print_diagnostic(ss, Note,\n+        try!(print_diagnostic(ss, Note,\n                                 format!(\"in expansion of {}{}{}\", pre,\n                                         ei.callee.name, post)));\n         let ss = cm.span_to_str(ei.call_site);\n-        if_ok!(print_diagnostic(ss, Note, \"expansion site\"));\n-        if_ok!(print_macro_backtrace(cm, ei.call_site));\n+        try!(print_diagnostic(ss, Note, \"expansion site\"));\n+        try!(print_macro_backtrace(cm, ei.call_site));\n     }\n     Ok(())\n }"}, {"sha": "14d8c662aae0ed368fdbaeceaf407ea7ff122556", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -299,7 +299,7 @@ impl Printer {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n                 let left = self.token[self.left].clone();\n-                if_ok!(self.advance_left(left, self.size[self.left]));\n+                try!(self.advance_left(left, self.size[self.left]));\n             }\n             self.indent(0);\n             Ok(())\n@@ -377,9 +377,9 @@ impl Printer {\n                 }\n             }\n             let left = self.token[self.left].clone();\n-            if_ok!(self.advance_left(left, self.size[self.left]));\n+            try!(self.advance_left(left, self.size[self.left]));\n             if self.left != self.right {\n-                if_ok!(self.check_stream());\n+                try!(self.check_stream());\n             }\n         }\n         Ok(())\n@@ -436,7 +436,7 @@ impl Printer {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n                 let left = self.token[self.left].clone();\n-                if_ok!(self.advance_left(left, self.size[self.left]));\n+                try!(self.advance_left(left, self.size[self.left]));\n             }\n             ret\n         } else {\n@@ -491,7 +491,7 @@ impl Printer {\n     }\n     pub fn print_str(&mut self, s: &str) -> io::IoResult<()> {\n         while self.pending_indentation > 0 {\n-            if_ok!(write!(self.out, \" \"));\n+            try!(write!(self.out, \" \"));\n             self.pending_indentation -= 1;\n         }\n         write!(self.out, \"{}\", s)"}, {"sha": "21e1998208c96b99e0a1b9cad35923354d3fcd3f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 708, "deletions": 708, "changes": 1416, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -147,9 +147,9 @@ pub fn print_crate(cm: @CodeMap,\n }\n \n pub fn print_crate_(s: &mut State, krate: &ast::Crate) -> io::IoResult<()> {\n-    if_ok!(print_mod(s, &krate.module, krate.attrs));\n-    if_ok!(print_remaining_comments(s));\n-    if_ok!(eof(&mut s.s));\n+    try!(print_mod(s, &krate.module, krate.attrs));\n+    try!(print_remaining_comments(s));\n+    try!(eof(&mut s.s));\n     Ok(())\n }\n \n@@ -254,12 +254,12 @@ pub fn rbox(s: &mut State, u: uint, b: pp::Breaks) -> io::IoResult<()> {\n pub fn nbsp(s: &mut State) -> io::IoResult<()> { word(&mut s.s, \" \") }\n \n pub fn word_nbsp(s: &mut State, w: &str) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, w));\n+    try!(word(&mut s.s, w));\n     nbsp(s)\n }\n \n pub fn word_space(s: &mut State, w: &str) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, w));\n+    try!(word(&mut s.s, w));\n     space(&mut s.s)\n }\n \n@@ -269,19 +269,19 @@ pub fn pclose(s: &mut State) -> io::IoResult<()> { word(&mut s.s, \")\") }\n \n pub fn head(s: &mut State, w: &str) -> io::IoResult<()> {\n     // outer-box is consistent\n-    if_ok!(cbox(s, indent_unit));\n+    try!(cbox(s, indent_unit));\n     // head-box is inconsistent\n-    if_ok!(ibox(s, w.len() + 1));\n+    try!(ibox(s, w.len() + 1));\n     // keyword that starts the head\n     if !w.is_empty() {\n-        if_ok!(word_nbsp(s, w));\n+        try!(word_nbsp(s, w));\n     }\n     Ok(())\n }\n \n pub fn bopen(s: &mut State) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, \"{\"));\n-    if_ok!(end(s)); // close the head-box\n+    try!(word(&mut s.s, \"{\"));\n+    try!(end(s)); // close the head-box\n     Ok(())\n }\n \n@@ -291,11 +291,11 @@ pub fn bclose_(s: &mut State, span: codemap::Span,\n }\n pub fn bclose_maybe_open (s: &mut State, span: codemap::Span,\n                           indented: uint, close_box: bool) -> io::IoResult<()> {\n-    if_ok!(maybe_print_comment(s, span.hi));\n-    if_ok!(break_offset_if_not_bol(s, 1u, -(indented as int)));\n-    if_ok!(word(&mut s.s, \"}\"));\n+    try!(maybe_print_comment(s, span.hi));\n+    try!(break_offset_if_not_bol(s, 1u, -(indented as int)));\n+    try!(word(&mut s.s, \"}\"));\n     if close_box {\n-        if_ok!(end(s)); // close the outer-box\n+        try!(end(s)); // close the outer-box\n     }\n     Ok(())\n }\n@@ -324,18 +324,18 @@ pub fn in_cbox(s: &mut State) -> bool {\n \n pub fn hardbreak_if_not_bol(s: &mut State) -> io::IoResult<()> {\n     if !is_bol(s) {\n-        if_ok!(hardbreak(&mut s.s))\n+        try!(hardbreak(&mut s.s))\n     }\n     Ok(())\n }\n pub fn space_if_not_bol(s: &mut State) -> io::IoResult<()> {\n-    if !is_bol(s) { if_ok!(space(&mut s.s)); }\n+    if !is_bol(s) { try!(space(&mut s.s)); }\n     Ok(())\n }\n pub fn break_offset_if_not_bol(s: &mut State, n: uint,\n                                off: int) -> io::IoResult<()> {\n     if !is_bol(s) {\n-        if_ok!(break_offset(&mut s.s, n, off));\n+        try!(break_offset(&mut s.s, n, off));\n     } else {\n         if off != 0 && s.s.last_token().is_hardbreak_tok() {\n             // We do something pretty sketchy here: tuck the nonzero\n@@ -350,23 +350,23 @@ pub fn break_offset_if_not_bol(s: &mut State, n: uint,\n // Synthesizes a comment that was not textually present in the original source\n // file.\n pub fn synth_comment(s: &mut State, text: ~str) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, \"/*\"));\n-    if_ok!(space(&mut s.s));\n-    if_ok!(word(&mut s.s, text));\n-    if_ok!(space(&mut s.s));\n-    if_ok!(word(&mut s.s, \"*/\"));\n+    try!(word(&mut s.s, \"/*\"));\n+    try!(space(&mut s.s));\n+    try!(word(&mut s.s, text));\n+    try!(space(&mut s.s));\n+    try!(word(&mut s.s, \"*/\"));\n     Ok(())\n }\n \n pub fn commasep<T>(s: &mut State, b: Breaks, elts: &[T],\n                    op: |&mut State, &T| -> io::IoResult<()>)\n     -> io::IoResult<()>\n {\n-    if_ok!(rbox(s, 0u, b));\n+    try!(rbox(s, 0u, b));\n     let mut first = true;\n     for elt in elts.iter() {\n-        if first { first = false; } else { if_ok!(word_space(s, \",\")); }\n-        if_ok!(op(s, elt));\n+        if first { first = false; } else { try!(word_space(s, \",\")); }\n+        try!(op(s, elt));\n     }\n     end(s)\n }\n@@ -378,18 +378,18 @@ pub fn commasep_cmnt<T>(\n                      elts: &[T],\n                      op: |&mut State, &T| -> io::IoResult<()>,\n                      get_span: |&T| -> codemap::Span) -> io::IoResult<()> {\n-    if_ok!(rbox(s, 0u, b));\n+    try!(rbox(s, 0u, b));\n     let len = elts.len();\n     let mut i = 0u;\n     for elt in elts.iter() {\n-        if_ok!(maybe_print_comment(s, get_span(elt).hi));\n-        if_ok!(op(s, elt));\n+        try!(maybe_print_comment(s, get_span(elt).hi));\n+        try!(op(s, elt));\n         i += 1u;\n         if i < len {\n-            if_ok!(word(&mut s.s, \",\"));\n-            if_ok!(maybe_print_trailing_comment(s, get_span(elt),\n+            try!(word(&mut s.s, \",\"));\n+            try!(maybe_print_trailing_comment(s, get_span(elt),\n                                                 Some(get_span(&elts[i]).hi)));\n-            if_ok!(space_if_not_bol(s));\n+            try!(space_if_not_bol(s));\n         }\n     }\n     end(s)\n@@ -402,79 +402,79 @@ pub fn commasep_exprs(s: &mut State, b: Breaks,\n \n pub fn print_mod(s: &mut State, _mod: &ast::Mod,\n                  attrs: &[ast::Attribute]) -> io::IoResult<()> {\n-    if_ok!(print_inner_attributes(s, attrs));\n+    try!(print_inner_attributes(s, attrs));\n     for vitem in _mod.view_items.iter() {\n-        if_ok!(print_view_item(s, vitem));\n+        try!(print_view_item(s, vitem));\n     }\n     for item in _mod.items.iter() {\n-        if_ok!(print_item(s, *item));\n+        try!(print_item(s, *item));\n     }\n     Ok(())\n }\n \n pub fn print_foreign_mod(s: &mut State, nmod: &ast::ForeignMod,\n                          attrs: &[ast::Attribute]) -> io::IoResult<()> {\n-    if_ok!(print_inner_attributes(s, attrs));\n+    try!(print_inner_attributes(s, attrs));\n     for vitem in nmod.view_items.iter() {\n-        if_ok!(print_view_item(s, vitem));\n+        try!(print_view_item(s, vitem));\n     }\n     for item in nmod.items.iter() {\n-        if_ok!(print_foreign_item(s, *item));\n+        try!(print_foreign_item(s, *item));\n     }\n     Ok(())\n }\n \n pub fn print_opt_lifetime(s: &mut State,\n                           lifetime: &Option<ast::Lifetime>) -> io::IoResult<()> {\n     for l in lifetime.iter() {\n-        if_ok!(print_lifetime(s, l));\n-        if_ok!(nbsp(s));\n+        try!(print_lifetime(s, l));\n+        try!(nbsp(s));\n     }\n     Ok(())\n }\n \n pub fn print_type(s: &mut State, ty: &ast::Ty) -> io::IoResult<()> {\n-    if_ok!(maybe_print_comment(s, ty.span.lo));\n-    if_ok!(ibox(s, 0u));\n+    try!(maybe_print_comment(s, ty.span.lo));\n+    try!(ibox(s, 0u));\n     match ty.node {\n-        ast::TyNil => if_ok!(word(&mut s.s, \"()\")),\n-        ast::TyBot => if_ok!(word(&mut s.s, \"!\")),\n+        ast::TyNil => try!(word(&mut s.s, \"()\")),\n+        ast::TyBot => try!(word(&mut s.s, \"!\")),\n         ast::TyBox(ty) => {\n-            if_ok!(word(&mut s.s, \"@\"));\n-            if_ok!(print_type(s, ty));\n+            try!(word(&mut s.s, \"@\"));\n+            try!(print_type(s, ty));\n         }\n         ast::TyUniq(ty) => {\n-            if_ok!(word(&mut s.s, \"~\"));\n-            if_ok!(print_type(s, ty));\n+            try!(word(&mut s.s, \"~\"));\n+            try!(print_type(s, ty));\n         }\n         ast::TyVec(ty) => {\n-            if_ok!(word(&mut s.s, \"[\"));\n-            if_ok!(print_type(s, ty));\n-            if_ok!(word(&mut s.s, \"]\"));\n+            try!(word(&mut s.s, \"[\"));\n+            try!(print_type(s, ty));\n+            try!(word(&mut s.s, \"]\"));\n         }\n         ast::TyPtr(ref mt) => {\n-            if_ok!(word(&mut s.s, \"*\"));\n-            if_ok!(print_mt(s, mt));\n+            try!(word(&mut s.s, \"*\"));\n+            try!(print_mt(s, mt));\n         }\n         ast::TyRptr(ref lifetime, ref mt) => {\n-            if_ok!(word(&mut s.s, \"&\"));\n-            if_ok!(print_opt_lifetime(s, lifetime));\n-            if_ok!(print_mt(s, mt));\n+            try!(word(&mut s.s, \"&\"));\n+            try!(print_opt_lifetime(s, lifetime));\n+            try!(print_mt(s, mt));\n         }\n         ast::TyTup(ref elts) => {\n-            if_ok!(popen(s));\n-            if_ok!(commasep(s, Inconsistent, *elts, print_type_ref));\n+            try!(popen(s));\n+            try!(commasep(s, Inconsistent, *elts, print_type_ref));\n             if elts.len() == 1 {\n-                if_ok!(word(&mut s.s, \",\"));\n+                try!(word(&mut s.s, \",\"));\n             }\n-            if_ok!(pclose(s));\n+            try!(pclose(s));\n         }\n         ast::TyBareFn(f) => {\n             let generics = ast::Generics {\n                 lifetimes: f.lifetimes.clone(),\n                 ty_params: opt_vec::Empty\n             };\n-            if_ok!(print_ty_fn(s, Some(f.abis), None, &None,\n+            try!(print_ty_fn(s, Some(f.abis), None, &None,\n                                f.purity, ast::Many, f.decl, None, &None,\n                                Some(&generics), None));\n         }\n@@ -483,24 +483,24 @@ pub fn print_type(s: &mut State, ty: &ast::Ty) -> io::IoResult<()> {\n                 lifetimes: f.lifetimes.clone(),\n                 ty_params: opt_vec::Empty\n             };\n-            if_ok!(print_ty_fn(s, None, Some(f.sigil), &f.region,\n+            try!(print_ty_fn(s, None, Some(f.sigil), &f.region,\n                                f.purity, f.onceness, f.decl, None, &f.bounds,\n                                Some(&generics), None));\n         }\n         ast::TyPath(ref path, ref bounds, _) => {\n-            if_ok!(print_bounded_path(s, path, bounds));\n+            try!(print_bounded_path(s, path, bounds));\n         }\n         ast::TyFixedLengthVec(ty, v) => {\n-            if_ok!(word(&mut s.s, \"[\"));\n-            if_ok!(print_type(s, ty));\n-            if_ok!(word(&mut s.s, \", ..\"));\n-            if_ok!(print_expr(s, v));\n-            if_ok!(word(&mut s.s, \"]\"));\n+            try!(word(&mut s.s, \"[\"));\n+            try!(print_type(s, ty));\n+            try!(word(&mut s.s, \", ..\"));\n+            try!(print_expr(s, v));\n+            try!(word(&mut s.s, \"]\"));\n         }\n         ast::TyTypeof(e) => {\n-            if_ok!(word(&mut s.s, \"typeof(\"));\n-            if_ok!(print_expr(s, e));\n-            if_ok!(word(&mut s.s, \")\"));\n+            try!(word(&mut s.s, \"typeof(\"));\n+            try!(print_expr(s, e));\n+            try!(word(&mut s.s, \")\"));\n         }\n         ast::TyInfer => {\n             fail!(\"print_type shouldn't see a ty_infer\");\n@@ -515,61 +515,61 @@ pub fn print_type_ref(s: &mut State, ty: &P<ast::Ty>) -> io::IoResult<()> {\n \n pub fn print_foreign_item(s: &mut State,\n                           item: &ast::ForeignItem) -> io::IoResult<()> {\n-    if_ok!(hardbreak_if_not_bol(s));\n-    if_ok!(maybe_print_comment(s, item.span.lo));\n-    if_ok!(print_outer_attributes(s, item.attrs));\n+    try!(hardbreak_if_not_bol(s));\n+    try!(maybe_print_comment(s, item.span.lo));\n+    try!(print_outer_attributes(s, item.attrs));\n     match item.node {\n         ast::ForeignItemFn(decl, ref generics) => {\n-            if_ok!(print_fn(s, decl, None, AbiSet::Rust(), item.ident, generics,\n+            try!(print_fn(s, decl, None, AbiSet::Rust(), item.ident, generics,\n             None, item.vis));\n-            if_ok!(end(s)); // end head-ibox\n-            if_ok!(word(&mut s.s, \";\"));\n-            if_ok!(end(s)); // end the outer fn box\n+            try!(end(s)); // end head-ibox\n+            try!(word(&mut s.s, \";\"));\n+            try!(end(s)); // end the outer fn box\n         }\n         ast::ForeignItemStatic(t, m) => {\n-            if_ok!(head(s, visibility_qualified(item.vis, \"static\")));\n+            try!(head(s, visibility_qualified(item.vis, \"static\")));\n             if m {\n-                if_ok!(word_space(s, \"mut\"));\n+                try!(word_space(s, \"mut\"));\n             }\n-            if_ok!(print_ident(s, item.ident));\n-            if_ok!(word_space(s, \":\"));\n-            if_ok!(print_type(s, t));\n-            if_ok!(word(&mut s.s, \";\"));\n-            if_ok!(end(s)); // end the head-ibox\n-            if_ok!(end(s)); // end the outer cbox\n+            try!(print_ident(s, item.ident));\n+            try!(word_space(s, \":\"));\n+            try!(print_type(s, t));\n+            try!(word(&mut s.s, \";\"));\n+            try!(end(s)); // end the head-ibox\n+            try!(end(s)); // end the outer cbox\n         }\n     }\n     Ok(())\n }\n \n pub fn print_item(s: &mut State, item: &ast::Item) -> io::IoResult<()> {\n-    if_ok!(hardbreak_if_not_bol(s));\n-    if_ok!(maybe_print_comment(s, item.span.lo));\n-    if_ok!(print_outer_attributes(s, item.attrs));\n+    try!(hardbreak_if_not_bol(s));\n+    try!(maybe_print_comment(s, item.span.lo));\n+    try!(print_outer_attributes(s, item.attrs));\n     {\n         let ann_node = NodeItem(s, item);\n-        if_ok!(s.ann.pre(ann_node));\n+        try!(s.ann.pre(ann_node));\n     }\n     match item.node {\n       ast::ItemStatic(ty, m, expr) => {\n-        if_ok!(head(s, visibility_qualified(item.vis, \"static\")));\n+        try!(head(s, visibility_qualified(item.vis, \"static\")));\n         if m == ast::MutMutable {\n-            if_ok!(word_space(s, \"mut\"));\n+            try!(word_space(s, \"mut\"));\n         }\n-        if_ok!(print_ident(s, item.ident));\n-        if_ok!(word_space(s, \":\"));\n-        if_ok!(print_type(s, ty));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(end(s)); // end the head-ibox\n+        try!(print_ident(s, item.ident));\n+        try!(word_space(s, \":\"));\n+        try!(print_type(s, ty));\n+        try!(space(&mut s.s));\n+        try!(end(s)); // end the head-ibox\n \n-        if_ok!(word_space(s, \"=\"));\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(word(&mut s.s, \";\"));\n-        if_ok!(end(s)); // end the outer cbox\n+        try!(word_space(s, \"=\"));\n+        try!(print_expr(s, expr));\n+        try!(word(&mut s.s, \";\"));\n+        try!(end(s)); // end the outer cbox\n \n       }\n       ast::ItemFn(decl, purity, abi, ref typarams, body) => {\n-        if_ok!(print_fn(\n+        try!(print_fn(\n             s,\n             decl,\n             Some(purity),\n@@ -579,40 +579,40 @@ pub fn print_item(s: &mut State, item: &ast::Item) -> io::IoResult<()> {\n             None,\n             item.vis\n         ));\n-        if_ok!(word(&mut s.s, \" \"));\n-        if_ok!(print_block_with_attrs(s, body, item.attrs));\n+        try!(word(&mut s.s, \" \"));\n+        try!(print_block_with_attrs(s, body, item.attrs));\n       }\n       ast::ItemMod(ref _mod) => {\n-        if_ok!(head(s, visibility_qualified(item.vis, \"mod\")));\n-        if_ok!(print_ident(s, item.ident));\n-        if_ok!(nbsp(s));\n-        if_ok!(bopen(s));\n-        if_ok!(print_mod(s, _mod, item.attrs));\n-        if_ok!(bclose(s, item.span));\n+        try!(head(s, visibility_qualified(item.vis, \"mod\")));\n+        try!(print_ident(s, item.ident));\n+        try!(nbsp(s));\n+        try!(bopen(s));\n+        try!(print_mod(s, _mod, item.attrs));\n+        try!(bclose(s, item.span));\n       }\n       ast::ItemForeignMod(ref nmod) => {\n-        if_ok!(head(s, \"extern\"));\n-        if_ok!(word_nbsp(s, nmod.abis.to_str()));\n-        if_ok!(bopen(s));\n-        if_ok!(print_foreign_mod(s, nmod, item.attrs));\n-        if_ok!(bclose(s, item.span));\n+        try!(head(s, \"extern\"));\n+        try!(word_nbsp(s, nmod.abis.to_str()));\n+        try!(bopen(s));\n+        try!(print_foreign_mod(s, nmod, item.attrs));\n+        try!(bclose(s, item.span));\n       }\n       ast::ItemTy(ty, ref params) => {\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(ibox(s, 0u));\n-        if_ok!(word_nbsp(s, visibility_qualified(item.vis, \"type\")));\n-        if_ok!(print_ident(s, item.ident));\n-        if_ok!(print_generics(s, params));\n-        if_ok!(end(s)); // end the inner ibox\n-\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word_space(s, \"=\"));\n-        if_ok!(print_type(s, ty));\n-        if_ok!(word(&mut s.s, \";\"));\n-        if_ok!(end(s)); // end the outer ibox\n+        try!(ibox(s, indent_unit));\n+        try!(ibox(s, 0u));\n+        try!(word_nbsp(s, visibility_qualified(item.vis, \"type\")));\n+        try!(print_ident(s, item.ident));\n+        try!(print_generics(s, params));\n+        try!(end(s)); // end the inner ibox\n+\n+        try!(space(&mut s.s));\n+        try!(word_space(s, \"=\"));\n+        try!(print_type(s, ty));\n+        try!(word(&mut s.s, \";\"));\n+        try!(end(s)); // end the outer ibox\n       }\n       ast::ItemEnum(ref enum_definition, ref params) => {\n-        if_ok!(print_enum_def(\n+        try!(print_enum_def(\n             s,\n             enum_definition,\n             params,\n@@ -622,74 +622,74 @@ pub fn print_item(s: &mut State, item: &ast::Item) -> io::IoResult<()> {\n         ));\n       }\n       ast::ItemStruct(struct_def, ref generics) => {\n-          if_ok!(head(s, visibility_qualified(item.vis, \"struct\")));\n-          if_ok!(print_struct(s, struct_def, generics, item.ident, item.span));\n+          try!(head(s, visibility_qualified(item.vis, \"struct\")));\n+          try!(print_struct(s, struct_def, generics, item.ident, item.span));\n       }\n \n       ast::ItemImpl(ref generics, ref opt_trait, ty, ref methods) => {\n-        if_ok!(head(s, visibility_qualified(item.vis, \"impl\")));\n+        try!(head(s, visibility_qualified(item.vis, \"impl\")));\n         if generics.is_parameterized() {\n-            if_ok!(print_generics(s, generics));\n-            if_ok!(space(&mut s.s));\n+            try!(print_generics(s, generics));\n+            try!(space(&mut s.s));\n         }\n \n         match opt_trait {\n             &Some(ref t) => {\n-                if_ok!(print_trait_ref(s, t));\n-                if_ok!(space(&mut s.s));\n-                if_ok!(word_space(s, \"for\"));\n+                try!(print_trait_ref(s, t));\n+                try!(space(&mut s.s));\n+                try!(word_space(s, \"for\"));\n             }\n             &None => ()\n         };\n \n-        if_ok!(print_type(s, ty));\n+        try!(print_type(s, ty));\n \n-        if_ok!(space(&mut s.s));\n-        if_ok!(bopen(s));\n-        if_ok!(print_inner_attributes(s, item.attrs));\n+        try!(space(&mut s.s));\n+        try!(bopen(s));\n+        try!(print_inner_attributes(s, item.attrs));\n         for meth in methods.iter() {\n-           if_ok!(print_method(s, *meth));\n+           try!(print_method(s, *meth));\n         }\n-        if_ok!(bclose(s, item.span));\n+        try!(bclose(s, item.span));\n       }\n       ast::ItemTrait(ref generics, ref traits, ref methods) => {\n-        if_ok!(head(s, visibility_qualified(item.vis, \"trait\")));\n-        if_ok!(print_ident(s, item.ident));\n-        if_ok!(print_generics(s, generics));\n+        try!(head(s, visibility_qualified(item.vis, \"trait\")));\n+        try!(print_ident(s, item.ident));\n+        try!(print_generics(s, generics));\n         if traits.len() != 0u {\n-            if_ok!(word(&mut s.s, \":\"));\n+            try!(word(&mut s.s, \":\"));\n             for (i, trait_) in traits.iter().enumerate() {\n-                if_ok!(nbsp(s));\n+                try!(nbsp(s));\n                 if i != 0 {\n-                    if_ok!(word_space(s, \"+\"));\n+                    try!(word_space(s, \"+\"));\n                 }\n-                if_ok!(print_path(s, &trait_.path, false));\n+                try!(print_path(s, &trait_.path, false));\n             }\n         }\n-        if_ok!(word(&mut s.s, \" \"));\n-        if_ok!(bopen(s));\n+        try!(word(&mut s.s, \" \"));\n+        try!(bopen(s));\n         for meth in methods.iter() {\n-            if_ok!(print_trait_method(s, meth));\n+            try!(print_trait_method(s, meth));\n         }\n-        if_ok!(bclose(s, item.span));\n+        try!(bclose(s, item.span));\n       }\n       // I think it's reasonable to hide the context here:\n       ast::ItemMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                    ..}) => {\n-        if_ok!(print_visibility(s, item.vis));\n-        if_ok!(print_path(s, pth, false));\n-        if_ok!(word(&mut s.s, \"! \"));\n-        if_ok!(print_ident(s, item.ident));\n-        if_ok!(cbox(s, indent_unit));\n-        if_ok!(popen(s));\n-        if_ok!(print_tts(s, &(tts.as_slice())));\n-        if_ok!(pclose(s));\n-        if_ok!(end(s));\n+        try!(print_visibility(s, item.vis));\n+        try!(print_path(s, pth, false));\n+        try!(word(&mut s.s, \"! \"));\n+        try!(print_ident(s, item.ident));\n+        try!(cbox(s, indent_unit));\n+        try!(popen(s));\n+        try!(print_tts(s, &(tts.as_slice())));\n+        try!(pclose(s));\n+        try!(end(s));\n       }\n     }\n     {\n         let ann_node = NodeItem(s, item);\n-        if_ok!(s.ann.post(ann_node));\n+        try!(s.ann.post(ann_node));\n     }\n     Ok(())\n }\n@@ -702,27 +702,27 @@ pub fn print_enum_def(s: &mut State, enum_definition: &ast::EnumDef,\n                       generics: &ast::Generics, ident: ast::Ident,\n                       span: codemap::Span,\n                       visibility: ast::Visibility) -> io::IoResult<()> {\n-    if_ok!(head(s, visibility_qualified(visibility, \"enum\")));\n-    if_ok!(print_ident(s, ident));\n-    if_ok!(print_generics(s, generics));\n-    if_ok!(space(&mut s.s));\n-    if_ok!(print_variants(s, enum_definition.variants, span));\n+    try!(head(s, visibility_qualified(visibility, \"enum\")));\n+    try!(print_ident(s, ident));\n+    try!(print_generics(s, generics));\n+    try!(space(&mut s.s));\n+    try!(print_variants(s, enum_definition.variants, span));\n     Ok(())\n }\n \n pub fn print_variants(s: &mut State,\n                       variants: &[P<ast::Variant>],\n                       span: codemap::Span) -> io::IoResult<()> {\n-    if_ok!(bopen(s));\n+    try!(bopen(s));\n     for &v in variants.iter() {\n-        if_ok!(space_if_not_bol(s));\n-        if_ok!(maybe_print_comment(s, v.span.lo));\n-        if_ok!(print_outer_attributes(s, v.node.attrs));\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(print_variant(s, v));\n-        if_ok!(word(&mut s.s, \",\"));\n-        if_ok!(end(s));\n-        if_ok!(maybe_print_trailing_comment(s, v.span, None));\n+        try!(space_if_not_bol(s));\n+        try!(maybe_print_comment(s, v.span.lo));\n+        try!(print_outer_attributes(s, v.node.attrs));\n+        try!(ibox(s, indent_unit));\n+        try!(print_variant(s, v));\n+        try!(word(&mut s.s, \",\"));\n+        try!(end(s));\n+        try!(maybe_print_trailing_comment(s, v.span, None));\n     }\n     bclose(s, span)\n }\n@@ -745,7 +745,7 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> ~str {\n pub fn print_visibility(s: &mut State, vis: ast::Visibility) -> io::IoResult<()> {\n     match vis {\n         ast::Private | ast::Public =>\n-            if_ok!(word_nbsp(s, visibility_to_str(vis))),\n+            try!(word_nbsp(s, visibility_to_str(vis))),\n         ast::Inherited => ()\n     }\n     Ok(())\n@@ -756,43 +756,43 @@ pub fn print_struct(s: &mut State,\n                     generics: &ast::Generics,\n                     ident: ast::Ident,\n                     span: codemap::Span) -> io::IoResult<()> {\n-    if_ok!(print_ident(s, ident));\n-    if_ok!(print_generics(s, generics));\n+    try!(print_ident(s, ident));\n+    try!(print_generics(s, generics));\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n         if !struct_def.fields.is_empty() {\n-            if_ok!(popen(s));\n-            if_ok!(commasep(s, Inconsistent, struct_def.fields, |s, field| {\n+            try!(popen(s));\n+            try!(commasep(s, Inconsistent, struct_def.fields, |s, field| {\n                 match field.node.kind {\n                     ast::NamedField(..) => fail!(\"unexpected named field\"),\n                     ast::UnnamedField => {\n-                        if_ok!(maybe_print_comment(s, field.span.lo));\n-                        if_ok!(print_type(s, field.node.ty));\n+                        try!(maybe_print_comment(s, field.span.lo));\n+                        try!(print_type(s, field.node.ty));\n                     }\n                 }\n                 Ok(())\n             }));\n-            if_ok!(pclose(s));\n+            try!(pclose(s));\n         }\n-        if_ok!(word(&mut s.s, \";\"));\n-        if_ok!(end(s));\n+        try!(word(&mut s.s, \";\"));\n+        try!(end(s));\n         end(s) // close the outer-box\n     } else {\n-        if_ok!(nbsp(s));\n-        if_ok!(bopen(s));\n-        if_ok!(hardbreak_if_not_bol(s));\n+        try!(nbsp(s));\n+        try!(bopen(s));\n+        try!(hardbreak_if_not_bol(s));\n \n         for field in struct_def.fields.iter() {\n             match field.node.kind {\n                 ast::UnnamedField => fail!(\"unexpected unnamed field\"),\n                 ast::NamedField(ident, visibility) => {\n-                    if_ok!(hardbreak_if_not_bol(s));\n-                    if_ok!(maybe_print_comment(s, field.span.lo));\n-                    if_ok!(print_outer_attributes(s, field.node.attrs));\n-                    if_ok!(print_visibility(s, visibility));\n-                    if_ok!(print_ident(s, ident));\n-                    if_ok!(word_nbsp(s, \":\"));\n-                    if_ok!(print_type(s, field.node.ty));\n-                    if_ok!(word(&mut s.s, \",\"));\n+                    try!(hardbreak_if_not_bol(s));\n+                    try!(maybe_print_comment(s, field.span.lo));\n+                    try!(print_outer_attributes(s, field.node.attrs));\n+                    try!(print_visibility(s, visibility));\n+                    try!(print_ident(s, ident));\n+                    try!(word_nbsp(s, \":\"));\n+                    try!(print_type(s, field.node.ty));\n+                    try!(word(&mut s.s, \",\"));\n                 }\n             }\n         }\n@@ -815,74 +815,74 @@ pub fn print_tt(s: &mut State, tt: &ast::TokenTree) -> io::IoResult<()> {\n             word(&mut s.s, parse::token::to_str(tk))\n         }\n         ast::TTSeq(_, ref tts, ref sep, zerok) => {\n-            if_ok!(word(&mut s.s, \"$(\"));\n+            try!(word(&mut s.s, \"$(\"));\n             for tt_elt in (*tts).iter() {\n-                if_ok!(print_tt(s, tt_elt));\n+                try!(print_tt(s, tt_elt));\n             }\n-            if_ok!(word(&mut s.s, \")\"));\n+            try!(word(&mut s.s, \")\"));\n             match *sep {\n                 Some(ref tk) => {\n-                    if_ok!(word(&mut s.s, parse::token::to_str(tk)));\n+                    try!(word(&mut s.s, parse::token::to_str(tk)));\n                 }\n                 None => ()\n             }\n             word(&mut s.s, if zerok { \"*\" } else { \"+\" })\n         }\n         ast::TTNonterminal(_, name) => {\n-            if_ok!(word(&mut s.s, \"$\"));\n+            try!(word(&mut s.s, \"$\"));\n             print_ident(s, name)\n         }\n     }\n }\n \n pub fn print_tts(s: &mut State, tts: & &[ast::TokenTree]) -> io::IoResult<()> {\n-    if_ok!(ibox(s, 0));\n+    try!(ibox(s, 0));\n     for (i, tt) in tts.iter().enumerate() {\n         if i != 0 {\n-            if_ok!(space(&mut s.s));\n+            try!(space(&mut s.s));\n         }\n-        if_ok!(print_tt(s, tt));\n+        try!(print_tt(s, tt));\n     }\n     end(s)\n }\n \n pub fn print_variant(s: &mut State, v: &ast::Variant) -> io::IoResult<()> {\n-    if_ok!(print_visibility(s, v.node.vis));\n+    try!(print_visibility(s, v.node.vis));\n     match v.node.kind {\n         ast::TupleVariantKind(ref args) => {\n-            if_ok!(print_ident(s, v.node.name));\n+            try!(print_ident(s, v.node.name));\n             if !args.is_empty() {\n-                if_ok!(popen(s));\n+                try!(popen(s));\n                 fn print_variant_arg(s: &mut State,\n                                      arg: &ast::VariantArg) -> io::IoResult<()> {\n                     print_type(s, arg.ty)\n                 }\n-                if_ok!(commasep(s, Consistent, *args, print_variant_arg));\n-                if_ok!(pclose(s));\n+                try!(commasep(s, Consistent, *args, print_variant_arg));\n+                try!(pclose(s));\n             }\n         }\n         ast::StructVariantKind(struct_def) => {\n-            if_ok!(head(s, \"\"));\n+            try!(head(s, \"\"));\n             let generics = ast_util::empty_generics();\n-            if_ok!(print_struct(s, struct_def, &generics, v.node.name, v.span));\n+            try!(print_struct(s, struct_def, &generics, v.node.name, v.span));\n         }\n     }\n     match v.node.disr_expr {\n       Some(d) => {\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word_space(s, \"=\"));\n-        if_ok!(print_expr(s, d));\n+        try!(space(&mut s.s));\n+        try!(word_space(s, \"=\"));\n+        try!(print_expr(s, d));\n       }\n       _ => ()\n     }\n     Ok(())\n }\n \n pub fn print_ty_method(s: &mut State, m: &ast::TypeMethod) -> io::IoResult<()> {\n-    if_ok!(hardbreak_if_not_bol(s));\n-    if_ok!(maybe_print_comment(s, m.span.lo));\n-    if_ok!(print_outer_attributes(s, m.attrs));\n-    if_ok!(print_ty_fn(s,\n+    try!(hardbreak_if_not_bol(s));\n+    try!(maybe_print_comment(s, m.span.lo));\n+    try!(print_outer_attributes(s, m.attrs));\n+    try!(print_ty_fn(s,\n                        None,\n                        None,\n                        &None,\n@@ -905,13 +905,13 @@ pub fn print_trait_method(s: &mut State,\n }\n \n pub fn print_method(s: &mut State, meth: &ast::Method) -> io::IoResult<()> {\n-    if_ok!(hardbreak_if_not_bol(s));\n-    if_ok!(maybe_print_comment(s, meth.span.lo));\n-    if_ok!(print_outer_attributes(s, meth.attrs));\n-    if_ok!(print_fn(s, meth.decl, Some(meth.purity), AbiSet::Rust(),\n+    try!(hardbreak_if_not_bol(s));\n+    try!(maybe_print_comment(s, meth.span.lo));\n+    try!(print_outer_attributes(s, meth.attrs));\n+    try!(print_fn(s, meth.decl, Some(meth.purity), AbiSet::Rust(),\n                     meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                     meth.vis));\n-    if_ok!(word(&mut s.s, \" \"));\n+    try!(word(&mut s.s, \" \"));\n     print_block_with_attrs(s, meth.body, meth.attrs)\n }\n \n@@ -921,14 +921,14 @@ pub fn print_outer_attributes(s: &mut State,\n     for attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrOuter => {\n-              if_ok!(print_attribute(s, attr));\n+              try!(print_attribute(s, attr));\n               count += 1;\n           }\n           _ => {/* fallthrough */ }\n         }\n     }\n     if count > 0 {\n-        if_ok!(hardbreak_if_not_bol(s));\n+        try!(hardbreak_if_not_bol(s));\n     }\n     Ok(())\n }\n@@ -939,61 +939,61 @@ pub fn print_inner_attributes(s: &mut State,\n     for attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrInner => {\n-            if_ok!(print_attribute(s, attr));\n+            try!(print_attribute(s, attr));\n             if !attr.node.is_sugared_doc {\n-                if_ok!(word(&mut s.s, \";\"));\n+                try!(word(&mut s.s, \";\"));\n             }\n             count += 1;\n           }\n           _ => {/* fallthrough */ }\n         }\n     }\n     if count > 0 {\n-        if_ok!(hardbreak_if_not_bol(s));\n+        try!(hardbreak_if_not_bol(s));\n     }\n     Ok(())\n }\n \n pub fn print_attribute(s: &mut State, attr: &ast::Attribute) -> io::IoResult<()> {\n-    if_ok!(hardbreak_if_not_bol(s));\n-    if_ok!(maybe_print_comment(s, attr.span.lo));\n+    try!(hardbreak_if_not_bol(s));\n+    try!(maybe_print_comment(s, attr.span.lo));\n     if attr.node.is_sugared_doc {\n         let comment = attr.value_str().unwrap();\n-        if_ok!(word(&mut s.s, comment.get()));\n+        try!(word(&mut s.s, comment.get()));\n     } else {\n-        if_ok!(word(&mut s.s, \"#[\"));\n-        if_ok!(print_meta_item(s, attr.meta()));\n-        if_ok!(word(&mut s.s, \"]\"));\n+        try!(word(&mut s.s, \"#[\"));\n+        try!(print_meta_item(s, attr.meta()));\n+        try!(word(&mut s.s, \"]\"));\n     }\n     Ok(())\n }\n \n \n pub fn print_stmt(s: &mut State, st: &ast::Stmt) -> io::IoResult<()> {\n-    if_ok!(maybe_print_comment(s, st.span.lo));\n+    try!(maybe_print_comment(s, st.span.lo));\n     match st.node {\n       ast::StmtDecl(decl, _) => {\n-        if_ok!(print_decl(s, decl));\n+        try!(print_decl(s, decl));\n       }\n       ast::StmtExpr(expr, _) => {\n-        if_ok!(space_if_not_bol(s));\n-        if_ok!(print_expr(s, expr));\n+        try!(space_if_not_bol(s));\n+        try!(print_expr(s, expr));\n       }\n       ast::StmtSemi(expr, _) => {\n-        if_ok!(space_if_not_bol(s));\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(word(&mut s.s, \";\"));\n+        try!(space_if_not_bol(s));\n+        try!(print_expr(s, expr));\n+        try!(word(&mut s.s, \";\"));\n       }\n       ast::StmtMac(ref mac, semi) => {\n-        if_ok!(space_if_not_bol(s));\n-        if_ok!(print_mac(s, mac));\n+        try!(space_if_not_bol(s));\n+        try!(print_mac(s, mac));\n         if semi {\n-            if_ok!(word(&mut s.s, \";\"));\n+            try!(word(&mut s.s, \";\"));\n         }\n       }\n     }\n     if parse::classify::stmt_ends_with_semi(st) {\n-        if_ok!(word(&mut s.s, \";\"));\n+        try!(word(&mut s.s, \";\"));\n     }\n     maybe_print_trailing_comment(s, st.span, None)\n }\n@@ -1039,70 +1039,70 @@ pub fn print_possibly_embedded_block_(s: &mut State,\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) -> io::IoResult<()> {\n     match blk.rules {\n-      ast::UnsafeBlock(..) => if_ok!(word_space(s, \"unsafe\")),\n+      ast::UnsafeBlock(..) => try!(word_space(s, \"unsafe\")),\n       ast::DefaultBlock => ()\n     }\n-    if_ok!(maybe_print_comment(s, blk.span.lo));\n+    try!(maybe_print_comment(s, blk.span.lo));\n     {\n         let ann_node = NodeBlock(s, blk);\n-        if_ok!(s.ann.pre(ann_node));\n+        try!(s.ann.pre(ann_node));\n     }\n-    if_ok!(match embedded {\n+    try!(match embedded {\n         BlockBlockFn => end(s),\n         BlockNormal => bopen(s)\n     });\n \n-    if_ok!(print_inner_attributes(s, attrs));\n+    try!(print_inner_attributes(s, attrs));\n \n     for vi in blk.view_items.iter() {\n-        if_ok!(print_view_item(s, vi));\n+        try!(print_view_item(s, vi));\n     }\n     for st in blk.stmts.iter() {\n-        if_ok!(print_stmt(s, *st));\n+        try!(print_stmt(s, *st));\n     }\n     match blk.expr {\n       Some(expr) => {\n-        if_ok!(space_if_not_bol(s));\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(maybe_print_trailing_comment(s, expr.span, Some(blk.span.hi)));\n+        try!(space_if_not_bol(s));\n+        try!(print_expr(s, expr));\n+        try!(maybe_print_trailing_comment(s, expr.span, Some(blk.span.hi)));\n       }\n       _ => ()\n     }\n-    if_ok!(bclose_maybe_open(s, blk.span, indented, close_box));\n+    try!(bclose_maybe_open(s, blk.span, indented, close_box));\n     {\n         let ann_node = NodeBlock(s, blk);\n-        if_ok!(s.ann.post(ann_node));\n+        try!(s.ann.post(ann_node));\n     }\n     Ok(())\n }\n \n pub fn print_if(s: &mut State, test: &ast::Expr, blk: &ast::Block,\n                 elseopt: Option<@ast::Expr>, chk: bool) -> io::IoResult<()> {\n-    if_ok!(head(s, \"if\"));\n-    if chk { if_ok!(word_nbsp(s, \"check\")); }\n-    if_ok!(print_expr(s, test));\n-    if_ok!(space(&mut s.s));\n-    if_ok!(print_block(s, blk));\n+    try!(head(s, \"if\"));\n+    if chk { try!(word_nbsp(s, \"check\")); }\n+    try!(print_expr(s, test));\n+    try!(space(&mut s.s));\n+    try!(print_block(s, blk));\n     fn do_else(s: &mut State, els: Option<@ast::Expr>) -> io::IoResult<()> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n                     ast::ExprIf(i, t, e) => {\n-                        if_ok!(cbox(s, indent_unit - 1u));\n-                        if_ok!(ibox(s, 0u));\n-                        if_ok!(word(&mut s.s, \" else if \"));\n-                        if_ok!(print_expr(s, i));\n-                        if_ok!(space(&mut s.s));\n-                        if_ok!(print_block(s, t));\n-                        if_ok!(do_else(s, e));\n+                        try!(cbox(s, indent_unit - 1u));\n+                        try!(ibox(s, 0u));\n+                        try!(word(&mut s.s, \" else if \"));\n+                        try!(print_expr(s, i));\n+                        try!(space(&mut s.s));\n+                        try!(print_block(s, t));\n+                        try!(do_else(s, e));\n                     }\n                     // \"final else\"\n                     ast::ExprBlock(b) => {\n-                        if_ok!(cbox(s, indent_unit - 1u));\n-                        if_ok!(ibox(s, 0u));\n-                        if_ok!(word(&mut s.s, \" else \"));\n-                        if_ok!(print_block(s, b));\n+                        try!(cbox(s, indent_unit - 1u));\n+                        try!(ibox(s, 0u));\n+                        try!(word(&mut s.s, \" else \"));\n+                        try!(print_block(s, b));\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1121,10 +1121,10 @@ pub fn print_mac(s: &mut State, m: &ast::Mac) -> io::IoResult<()> {\n     match m.node {\n       // I think it's reasonable to hide the ctxt here:\n       ast::MacInvocTT(ref pth, ref tts, _) => {\n-        if_ok!(print_path(s, pth, false));\n-        if_ok!(word(&mut s.s, \"!\"));\n-        if_ok!(popen(s));\n-        if_ok!(print_tts(s, &tts.as_slice()));\n+        try!(print_path(s, pth, false));\n+        try!(word(&mut s.s, \"!\"));\n+        try!(popen(s));\n+        try!(print_tts(s, &tts.as_slice()));\n         pclose(s)\n       }\n     }\n@@ -1135,210 +1135,210 @@ pub fn print_expr_vstore(s: &mut State, t: ast::ExprVstore) -> io::IoResult<()>\n       ast::ExprVstoreUniq => word(&mut s.s, \"~\"),\n       ast::ExprVstoreSlice => word(&mut s.s, \"&\"),\n       ast::ExprVstoreMutSlice => {\n-        if_ok!(word(&mut s.s, \"&\"));\n+        try!(word(&mut s.s, \"&\"));\n         word(&mut s.s, \"mut\")\n       }\n     }\n }\n \n fn print_call_post(s: &mut State, args: &[@ast::Expr]) -> io::IoResult<()> {\n-    if_ok!(popen(s));\n-    if_ok!(commasep_exprs(s, Inconsistent, args));\n-    if_ok!(pclose(s));\n+    try!(popen(s));\n+    try!(commasep_exprs(s, Inconsistent, args));\n+    try!(pclose(s));\n     Ok(())\n }\n \n pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n     fn print_field(s: &mut State, field: &ast::Field) -> io::IoResult<()> {\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(print_ident(s, field.ident.node));\n-        if_ok!(word_space(s, \":\"));\n-        if_ok!(print_expr(s, field.expr));\n-        if_ok!(end(s));\n+        try!(ibox(s, indent_unit));\n+        try!(print_ident(s, field.ident.node));\n+        try!(word_space(s, \":\"));\n+        try!(print_expr(s, field.expr));\n+        try!(end(s));\n         Ok(())\n     }\n     fn get_span(field: &ast::Field) -> codemap::Span { return field.span; }\n \n-    if_ok!(maybe_print_comment(s, expr.span.lo));\n-    if_ok!(ibox(s, indent_unit));\n+    try!(maybe_print_comment(s, expr.span.lo));\n+    try!(ibox(s, indent_unit));\n     {\n         let ann_node = NodeExpr(s, expr);\n-        if_ok!(s.ann.pre(ann_node));\n+        try!(s.ann.pre(ann_node));\n     }\n     match expr.node {\n         ast::ExprVstore(e, v) => {\n-            if_ok!(print_expr_vstore(s, v));\n-            if_ok!(print_expr(s, e));\n+            try!(print_expr_vstore(s, v));\n+            try!(print_expr(s, e));\n         },\n         ast::ExprBox(p, e) => {\n-            if_ok!(word(&mut s.s, \"box\"));\n-            if_ok!(word(&mut s.s, \"(\"));\n-            if_ok!(print_expr(s, p));\n-            if_ok!(word_space(s, \")\"));\n-            if_ok!(print_expr(s, e));\n+            try!(word(&mut s.s, \"box\"));\n+            try!(word(&mut s.s, \"(\"));\n+            try!(print_expr(s, p));\n+            try!(word_space(s, \")\"));\n+            try!(print_expr(s, e));\n         }\n       ast::ExprVec(ref exprs, mutbl) => {\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(word(&mut s.s, \"[\"));\n+        try!(ibox(s, indent_unit));\n+        try!(word(&mut s.s, \"[\"));\n         if mutbl == ast::MutMutable {\n-            if_ok!(word(&mut s.s, \"mut\"));\n-            if exprs.len() > 0u { if_ok!(nbsp(s)); }\n+            try!(word(&mut s.s, \"mut\"));\n+            if exprs.len() > 0u { try!(nbsp(s)); }\n         }\n-        if_ok!(commasep_exprs(s, Inconsistent, *exprs));\n-        if_ok!(word(&mut s.s, \"]\"));\n-        if_ok!(end(s));\n+        try!(commasep_exprs(s, Inconsistent, *exprs));\n+        try!(word(&mut s.s, \"]\"));\n+        try!(end(s));\n       }\n \n       ast::ExprRepeat(element, count, mutbl) => {\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(word(&mut s.s, \"[\"));\n+        try!(ibox(s, indent_unit));\n+        try!(word(&mut s.s, \"[\"));\n         if mutbl == ast::MutMutable {\n-            if_ok!(word(&mut s.s, \"mut\"));\n-            if_ok!(nbsp(s));\n+            try!(word(&mut s.s, \"mut\"));\n+            try!(nbsp(s));\n         }\n-        if_ok!(print_expr(s, element));\n-        if_ok!(word(&mut s.s, \",\"));\n-        if_ok!(word(&mut s.s, \"..\"));\n-        if_ok!(print_expr(s, count));\n-        if_ok!(word(&mut s.s, \"]\"));\n-        if_ok!(end(s));\n+        try!(print_expr(s, element));\n+        try!(word(&mut s.s, \",\"));\n+        try!(word(&mut s.s, \"..\"));\n+        try!(print_expr(s, count));\n+        try!(word(&mut s.s, \"]\"));\n+        try!(end(s));\n       }\n \n       ast::ExprStruct(ref path, ref fields, wth) => {\n-        if_ok!(print_path(s, path, true));\n-        if_ok!(word(&mut s.s, \"{\"));\n-        if_ok!(commasep_cmnt(s, Consistent, (*fields), print_field, get_span));\n+        try!(print_path(s, path, true));\n+        try!(word(&mut s.s, \"{\"));\n+        try!(commasep_cmnt(s, Consistent, (*fields), print_field, get_span));\n         match wth {\n             Some(expr) => {\n-                if_ok!(ibox(s, indent_unit));\n+                try!(ibox(s, indent_unit));\n                 if !fields.is_empty() {\n-                    if_ok!(word(&mut s.s, \",\"));\n-                    if_ok!(space(&mut s.s));\n+                    try!(word(&mut s.s, \",\"));\n+                    try!(space(&mut s.s));\n                 }\n-                if_ok!(word(&mut s.s, \"..\"));\n-                if_ok!(print_expr(s, expr));\n-                if_ok!(end(s));\n+                try!(word(&mut s.s, \"..\"));\n+                try!(print_expr(s, expr));\n+                try!(end(s));\n             }\n-            _ => if_ok!(word(&mut s.s, \",\"))\n+            _ => try!(word(&mut s.s, \",\"))\n         }\n-        if_ok!(word(&mut s.s, \"}\"));\n+        try!(word(&mut s.s, \"}\"));\n       }\n       ast::ExprTup(ref exprs) => {\n-        if_ok!(popen(s));\n-        if_ok!(commasep_exprs(s, Inconsistent, *exprs));\n+        try!(popen(s));\n+        try!(commasep_exprs(s, Inconsistent, *exprs));\n         if exprs.len() == 1 {\n-            if_ok!(word(&mut s.s, \",\"));\n+            try!(word(&mut s.s, \",\"));\n         }\n-        if_ok!(pclose(s));\n+        try!(pclose(s));\n       }\n       ast::ExprCall(func, ref args) => {\n-        if_ok!(print_expr(s, func));\n-        if_ok!(print_call_post(s, *args));\n+        try!(print_expr(s, func));\n+        try!(print_call_post(s, *args));\n       }\n       ast::ExprMethodCall(_, ident, ref tys, ref args) => {\n         let base_args = args.slice_from(1);\n-        if_ok!(print_expr(s, args[0]));\n-        if_ok!(word(&mut s.s, \".\"));\n-        if_ok!(print_ident(s, ident));\n+        try!(print_expr(s, args[0]));\n+        try!(word(&mut s.s, \".\"));\n+        try!(print_ident(s, ident));\n         if tys.len() > 0u {\n-            if_ok!(word(&mut s.s, \"::<\"));\n-            if_ok!(commasep(s, Inconsistent, *tys, print_type_ref));\n-            if_ok!(word(&mut s.s, \">\"));\n+            try!(word(&mut s.s, \"::<\"));\n+            try!(commasep(s, Inconsistent, *tys, print_type_ref));\n+            try!(word(&mut s.s, \">\"));\n         }\n-        if_ok!(print_call_post(s, base_args));\n+        try!(print_call_post(s, base_args));\n       }\n       ast::ExprBinary(_, op, lhs, rhs) => {\n-        if_ok!(print_expr(s, lhs));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word_space(s, ast_util::binop_to_str(op)));\n-        if_ok!(print_expr(s, rhs));\n+        try!(print_expr(s, lhs));\n+        try!(space(&mut s.s));\n+        try!(word_space(s, ast_util::binop_to_str(op)));\n+        try!(print_expr(s, rhs));\n       }\n       ast::ExprUnary(_, op, expr) => {\n-        if_ok!(word(&mut s.s, ast_util::unop_to_str(op)));\n-        if_ok!(print_expr(s, expr));\n+        try!(word(&mut s.s, ast_util::unop_to_str(op)));\n+        try!(print_expr(s, expr));\n       }\n       ast::ExprAddrOf(m, expr) => {\n-        if_ok!(word(&mut s.s, \"&\"));\n-        if_ok!(print_mutability(s, m));\n+        try!(word(&mut s.s, \"&\"));\n+        try!(print_mutability(s, m));\n         // Avoid `& &e` => `&&e`.\n         match (m, &expr.node) {\n-            (ast::MutImmutable, &ast::ExprAddrOf(..)) => if_ok!(space(&mut s.s)),\n+            (ast::MutImmutable, &ast::ExprAddrOf(..)) => try!(space(&mut s.s)),\n             _ => { }\n         }\n-        if_ok!(print_expr(s, expr));\n+        try!(print_expr(s, expr));\n       }\n-      ast::ExprLit(lit) => if_ok!(print_literal(s, lit)),\n+      ast::ExprLit(lit) => try!(print_literal(s, lit)),\n       ast::ExprCast(expr, ty) => {\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word_space(s, \"as\"));\n-        if_ok!(print_type(s, ty));\n+        try!(print_expr(s, expr));\n+        try!(space(&mut s.s));\n+        try!(word_space(s, \"as\"));\n+        try!(print_type(s, ty));\n       }\n       ast::ExprIf(test, blk, elseopt) => {\n-        if_ok!(print_if(s, test, blk, elseopt, false));\n+        try!(print_if(s, test, blk, elseopt, false));\n       }\n       ast::ExprWhile(test, blk) => {\n-        if_ok!(head(s, \"while\"));\n-        if_ok!(print_expr(s, test));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(print_block(s, blk));\n+        try!(head(s, \"while\"));\n+        try!(print_expr(s, test));\n+        try!(space(&mut s.s));\n+        try!(print_block(s, blk));\n       }\n       ast::ExprForLoop(pat, iter, blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n-            if_ok!(word(&mut s.s, \"'\"));\n-            if_ok!(print_ident(s, *ident));\n-            if_ok!(word_space(s, \":\"));\n-        }\n-        if_ok!(head(s, \"for\"));\n-        if_ok!(print_pat(s, pat));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word_space(s, \"in\"));\n-        if_ok!(print_expr(s, iter));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(print_block(s, blk));\n+            try!(word(&mut s.s, \"'\"));\n+            try!(print_ident(s, *ident));\n+            try!(word_space(s, \":\"));\n+        }\n+        try!(head(s, \"for\"));\n+        try!(print_pat(s, pat));\n+        try!(space(&mut s.s));\n+        try!(word_space(s, \"in\"));\n+        try!(print_expr(s, iter));\n+        try!(space(&mut s.s));\n+        try!(print_block(s, blk));\n       }\n       ast::ExprLoop(blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n-            if_ok!(word(&mut s.s, \"'\"));\n-            if_ok!(print_ident(s, *ident));\n-            if_ok!(word_space(s, \":\"));\n+            try!(word(&mut s.s, \"'\"));\n+            try!(print_ident(s, *ident));\n+            try!(word_space(s, \":\"));\n         }\n-        if_ok!(head(s, \"loop\"));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(print_block(s, blk));\n+        try!(head(s, \"loop\"));\n+        try!(space(&mut s.s));\n+        try!(print_block(s, blk));\n       }\n       ast::ExprMatch(expr, ref arms) => {\n-        if_ok!(cbox(s, indent_unit));\n-        if_ok!(ibox(s, 4));\n-        if_ok!(word_nbsp(s, \"match\"));\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(bopen(s));\n+        try!(cbox(s, indent_unit));\n+        try!(ibox(s, 4));\n+        try!(word_nbsp(s, \"match\"));\n+        try!(print_expr(s, expr));\n+        try!(space(&mut s.s));\n+        try!(bopen(s));\n         let len = arms.len();\n         for (i, arm) in arms.iter().enumerate() {\n-            if_ok!(space(&mut s.s));\n-            if_ok!(cbox(s, indent_unit));\n-            if_ok!(ibox(s, 0u));\n+            try!(space(&mut s.s));\n+            try!(cbox(s, indent_unit));\n+            try!(ibox(s, 0u));\n             let mut first = true;\n             for p in arm.pats.iter() {\n                 if first {\n                     first = false;\n                 } else {\n-                    if_ok!(space(&mut s.s));\n-                    if_ok!(word_space(s, \"|\"));\n+                    try!(space(&mut s.s));\n+                    try!(word_space(s, \"|\"));\n                 }\n-                if_ok!(print_pat(s, *p));\n+                try!(print_pat(s, *p));\n             }\n-            if_ok!(space(&mut s.s));\n+            try!(space(&mut s.s));\n             match arm.guard {\n               Some(e) => {\n-                if_ok!(word_space(s, \"if\"));\n-                if_ok!(print_expr(s, e));\n-                if_ok!(space(&mut s.s));\n+                try!(word_space(s, \"if\"));\n+                try!(print_expr(s, e));\n+                try!(space(&mut s.s));\n               }\n               None => ()\n             }\n-            if_ok!(word_space(s, \"=>\"));\n+            try!(word_space(s, \"=>\"));\n \n             // Extract the expression from the extra block the parser adds\n             // in the case of foo => expr\n@@ -1352,231 +1352,231 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n                         match expr.node {\n                             ast::ExprBlock(blk) => {\n                                 // the block will close the pattern's ibox\n-                                if_ok!(print_block_unclosed_indent(\n+                                try!(print_block_unclosed_indent(\n                                     s, blk, indent_unit));\n                             }\n                             _ => {\n-                                if_ok!(end(s)); // close the ibox for the pattern\n-                                if_ok!(print_expr(s, expr));\n+                                try!(end(s)); // close the ibox for the pattern\n+                                try!(print_expr(s, expr));\n                             }\n                         }\n                         if !expr_is_simple_block(expr)\n                             && i < len - 1 {\n-                            if_ok!(word(&mut s.s, \",\"));\n+                            try!(word(&mut s.s, \",\"));\n                         }\n-                        if_ok!(end(s)); // close enclosing cbox\n+                        try!(end(s)); // close enclosing cbox\n                     }\n                     None => fail!()\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n-                if_ok!(print_block_unclosed_indent(s, arm.body, indent_unit));\n+                try!(print_block_unclosed_indent(s, arm.body, indent_unit));\n             }\n         }\n-        if_ok!(bclose_(s, expr.span, indent_unit));\n+        try!(bclose_(s, expr.span, indent_unit));\n       }\n       ast::ExprFnBlock(decl, body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        if_ok!(print_fn_block_args(s, decl));\n-        if_ok!(space(&mut s.s));\n+        try!(print_fn_block_args(s, decl));\n+        try!(space(&mut s.s));\n         // }\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n         match body.expr.unwrap().node {\n             ast::ExprBlock(blk) => {\n-                if_ok!(print_block_unclosed(s, blk));\n+                try!(print_block_unclosed(s, blk));\n             }\n             _ => {\n                 // this is a bare expression\n-                if_ok!(print_expr(s, body.expr.unwrap()));\n-                if_ok!(end(s)); // need to close a box\n+                try!(print_expr(s, body.expr.unwrap()));\n+                try!(end(s)); // need to close a box\n             }\n         }\n         // a box will be closed by print_expr, but we didn't want an overall\n         // wrapper so we closed the corresponding opening. so create an\n         // empty box to satisfy the close.\n-        if_ok!(ibox(s, 0));\n+        try!(ibox(s, 0));\n       }\n       ast::ExprProc(decl, body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        if_ok!(print_proc_args(s, decl));\n-        if_ok!(space(&mut s.s));\n+        try!(print_proc_args(s, decl));\n+        try!(space(&mut s.s));\n         // }\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n         match body.expr.unwrap().node {\n             ast::ExprBlock(blk) => {\n-                if_ok!(print_block_unclosed(s, blk));\n+                try!(print_block_unclosed(s, blk));\n             }\n             _ => {\n                 // this is a bare expression\n-                if_ok!(print_expr(s, body.expr.unwrap()));\n-                if_ok!(end(s)); // need to close a box\n+                try!(print_expr(s, body.expr.unwrap()));\n+                try!(end(s)); // need to close a box\n             }\n         }\n         // a box will be closed by print_expr, but we didn't want an overall\n         // wrapper so we closed the corresponding opening. so create an\n         // empty box to satisfy the close.\n-        if_ok!(ibox(s, 0));\n+        try!(ibox(s, 0));\n       }\n       ast::ExprBlock(blk) => {\n         // containing cbox, will be closed by print-block at }\n-        if_ok!(cbox(s, indent_unit));\n+        try!(cbox(s, indent_unit));\n         // head-box, will be closed by print-block after {\n-        if_ok!(ibox(s, 0u));\n-        if_ok!(print_block(s, blk));\n+        try!(ibox(s, 0u));\n+        try!(print_block(s, blk));\n       }\n       ast::ExprAssign(lhs, rhs) => {\n-        if_ok!(print_expr(s, lhs));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word_space(s, \"=\"));\n-        if_ok!(print_expr(s, rhs));\n+        try!(print_expr(s, lhs));\n+        try!(space(&mut s.s));\n+        try!(word_space(s, \"=\"));\n+        try!(print_expr(s, rhs));\n       }\n       ast::ExprAssignOp(_, op, lhs, rhs) => {\n-        if_ok!(print_expr(s, lhs));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word(&mut s.s, ast_util::binop_to_str(op)));\n-        if_ok!(word_space(s, \"=\"));\n-        if_ok!(print_expr(s, rhs));\n+        try!(print_expr(s, lhs));\n+        try!(space(&mut s.s));\n+        try!(word(&mut s.s, ast_util::binop_to_str(op)));\n+        try!(word_space(s, \"=\"));\n+        try!(print_expr(s, rhs));\n       }\n       ast::ExprField(expr, id, ref tys) => {\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(word(&mut s.s, \".\"));\n-        if_ok!(print_ident(s, id));\n+        try!(print_expr(s, expr));\n+        try!(word(&mut s.s, \".\"));\n+        try!(print_ident(s, id));\n         if tys.len() > 0u {\n-            if_ok!(word(&mut s.s, \"::<\"));\n-            if_ok!(commasep(s, Inconsistent, *tys, print_type_ref));\n-            if_ok!(word(&mut s.s, \">\"));\n+            try!(word(&mut s.s, \"::<\"));\n+            try!(commasep(s, Inconsistent, *tys, print_type_ref));\n+            try!(word(&mut s.s, \">\"));\n         }\n       }\n       ast::ExprIndex(_, expr, index) => {\n-        if_ok!(print_expr(s, expr));\n-        if_ok!(word(&mut s.s, \"[\"));\n-        if_ok!(print_expr(s, index));\n-        if_ok!(word(&mut s.s, \"]\"));\n+        try!(print_expr(s, expr));\n+        try!(word(&mut s.s, \"[\"));\n+        try!(print_expr(s, index));\n+        try!(word(&mut s.s, \"]\"));\n       }\n-      ast::ExprPath(ref path) => if_ok!(print_path(s, path, true)),\n+      ast::ExprPath(ref path) => try!(print_path(s, path, true)),\n       ast::ExprBreak(opt_ident) => {\n-        if_ok!(word(&mut s.s, \"break\"));\n-        if_ok!(space(&mut s.s));\n+        try!(word(&mut s.s, \"break\"));\n+        try!(space(&mut s.s));\n         for ident in opt_ident.iter() {\n-            if_ok!(word(&mut s.s, \"'\"));\n-            if_ok!(print_name(s, *ident));\n-            if_ok!(space(&mut s.s));\n+            try!(word(&mut s.s, \"'\"));\n+            try!(print_name(s, *ident));\n+            try!(space(&mut s.s));\n         }\n       }\n       ast::ExprAgain(opt_ident) => {\n-        if_ok!(word(&mut s.s, \"continue\"));\n-        if_ok!(space(&mut s.s));\n+        try!(word(&mut s.s, \"continue\"));\n+        try!(space(&mut s.s));\n         for ident in opt_ident.iter() {\n-            if_ok!(word(&mut s.s, \"'\"));\n-            if_ok!(print_name(s, *ident));\n-            if_ok!(space(&mut s.s))\n+            try!(word(&mut s.s, \"'\"));\n+            try!(print_name(s, *ident));\n+            try!(space(&mut s.s))\n         }\n       }\n       ast::ExprRet(result) => {\n-        if_ok!(word(&mut s.s, \"return\"));\n+        try!(word(&mut s.s, \"return\"));\n         match result {\n           Some(expr) => {\n-              if_ok!(word(&mut s.s, \" \"));\n-              if_ok!(print_expr(s, expr));\n+              try!(word(&mut s.s, \" \"));\n+              try!(print_expr(s, expr));\n           }\n           _ => ()\n         }\n       }\n       ast::ExprLogLevel => {\n-        if_ok!(word(&mut s.s, \"__log_level\"));\n-        if_ok!(popen(s));\n-        if_ok!(pclose(s));\n+        try!(word(&mut s.s, \"__log_level\"));\n+        try!(popen(s));\n+        try!(pclose(s));\n       }\n       ast::ExprInlineAsm(ref a) => {\n         if a.volatile {\n-            if_ok!(word(&mut s.s, \"__volatile__ asm!\"));\n+            try!(word(&mut s.s, \"__volatile__ asm!\"));\n         } else {\n-            if_ok!(word(&mut s.s, \"asm!\"));\n+            try!(word(&mut s.s, \"asm!\"));\n         }\n-        if_ok!(popen(s));\n-        if_ok!(print_string(s, a.asm.get(), a.asm_str_style));\n-        if_ok!(word_space(s, \":\"));\n+        try!(popen(s));\n+        try!(print_string(s, a.asm.get(), a.asm_str_style));\n+        try!(word_space(s, \":\"));\n         for &(ref co, o) in a.outputs.iter() {\n-            if_ok!(print_string(s, co.get(), ast::CookedStr));\n-            if_ok!(popen(s));\n-            if_ok!(print_expr(s, o));\n-            if_ok!(pclose(s));\n-            if_ok!(word_space(s, \",\"));\n+            try!(print_string(s, co.get(), ast::CookedStr));\n+            try!(popen(s));\n+            try!(print_expr(s, o));\n+            try!(pclose(s));\n+            try!(word_space(s, \",\"));\n         }\n-        if_ok!(word_space(s, \":\"));\n+        try!(word_space(s, \":\"));\n         for &(ref co, o) in a.inputs.iter() {\n-            if_ok!(print_string(s, co.get(), ast::CookedStr));\n-            if_ok!(popen(s));\n-            if_ok!(print_expr(s, o));\n-            if_ok!(pclose(s));\n-            if_ok!(word_space(s, \",\"));\n+            try!(print_string(s, co.get(), ast::CookedStr));\n+            try!(popen(s));\n+            try!(print_expr(s, o));\n+            try!(pclose(s));\n+            try!(word_space(s, \",\"));\n         }\n-        if_ok!(word_space(s, \":\"));\n-        if_ok!(print_string(s, a.clobbers.get(), ast::CookedStr));\n-        if_ok!(pclose(s));\n+        try!(word_space(s, \":\"));\n+        try!(print_string(s, a.clobbers.get(), ast::CookedStr));\n+        try!(pclose(s));\n       }\n-      ast::ExprMac(ref m) => if_ok!(print_mac(s, m)),\n+      ast::ExprMac(ref m) => try!(print_mac(s, m)),\n       ast::ExprParen(e) => {\n-          if_ok!(popen(s));\n-          if_ok!(print_expr(s, e));\n-          if_ok!(pclose(s));\n+          try!(popen(s));\n+          try!(print_expr(s, e));\n+          try!(pclose(s));\n       }\n     }\n     {\n         let ann_node = NodeExpr(s, expr);\n-        if_ok!(s.ann.post(ann_node));\n+        try!(s.ann.post(ann_node));\n     }\n     end(s)\n }\n \n pub fn print_local_decl(s: &mut State, loc: &ast::Local) -> io::IoResult<()> {\n-    if_ok!(print_pat(s, loc.pat));\n+    try!(print_pat(s, loc.pat));\n     match loc.ty.node {\n         ast::TyInfer => {}\n         _ => {\n-            if_ok!(word_space(s, \":\"));\n-            if_ok!(print_type(s, loc.ty));\n+            try!(word_space(s, \":\"));\n+            try!(print_type(s, loc.ty));\n         }\n     }\n     Ok(())\n }\n \n pub fn print_decl(s: &mut State, decl: &ast::Decl) -> io::IoResult<()> {\n-    if_ok!(maybe_print_comment(s, decl.span.lo));\n+    try!(maybe_print_comment(s, decl.span.lo));\n     match decl.node {\n       ast::DeclLocal(ref loc) => {\n-        if_ok!(space_if_not_bol(s));\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(word_nbsp(s, \"let\"));\n+        try!(space_if_not_bol(s));\n+        try!(ibox(s, indent_unit));\n+        try!(word_nbsp(s, \"let\"));\n \n         fn print_local(s: &mut State, loc: &ast::Local) -> io::IoResult<()> {\n-            if_ok!(ibox(s, indent_unit));\n-            if_ok!(print_local_decl(s, loc));\n-            if_ok!(end(s));\n+            try!(ibox(s, indent_unit));\n+            try!(print_local_decl(s, loc));\n+            try!(end(s));\n             match loc.init {\n               Some(init) => {\n-                if_ok!(nbsp(s));\n-                if_ok!(word_space(s, \"=\"));\n-                if_ok!(print_expr(s, init));\n+                try!(nbsp(s));\n+                try!(word_space(s, \"=\"));\n+                try!(print_expr(s, init));\n               }\n               _ => ()\n             }\n             Ok(())\n         }\n \n-        if_ok!(print_local(s, *loc));\n+        try!(print_local(s, *loc));\n         end(s)\n       }\n       ast::DeclItem(item) => print_item(s, item)\n@@ -1593,9 +1593,9 @@ pub fn print_name(s: &mut State, name: ast::Name) -> io::IoResult<()> {\n \n pub fn print_for_decl(s: &mut State, loc: &ast::Local,\n                       coll: &ast::Expr) -> io::IoResult<()> {\n-    if_ok!(print_local_decl(s, loc));\n-    if_ok!(space(&mut s.s));\n-    if_ok!(word_space(s, \"in\"));\n+    try!(print_local_decl(s, loc));\n+    try!(space(&mut s.s));\n+    try!(word_space(s, \"in\"));\n     print_expr(s, coll)\n }\n \n@@ -1605,55 +1605,55 @@ fn print_path_(s: &mut State,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>)\n     -> io::IoResult<()>\n {\n-    if_ok!(maybe_print_comment(s, path.span.lo));\n+    try!(maybe_print_comment(s, path.span.lo));\n     if path.global {\n-        if_ok!(word(&mut s.s, \"::\"));\n+        try!(word(&mut s.s, \"::\"));\n     }\n \n     let mut first = true;\n     for (i, segment) in path.segments.iter().enumerate() {\n         if first {\n             first = false\n         } else {\n-            if_ok!(word(&mut s.s, \"::\"))\n+            try!(word(&mut s.s, \"::\"))\n         }\n \n-        if_ok!(print_ident(s, segment.identifier));\n+        try!(print_ident(s, segment.identifier));\n \n         // If this is the last segment, print the bounds.\n         if i == path.segments.len() - 1 {\n             match *opt_bounds {\n                 None => {}\n-                Some(ref bounds) => if_ok!(print_bounds(s, bounds, true)),\n+                Some(ref bounds) => try!(print_bounds(s, bounds, true)),\n             }\n         }\n \n         if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n             if colons_before_params {\n-                if_ok!(word(&mut s.s, \"::\"))\n+                try!(word(&mut s.s, \"::\"))\n             }\n-            if_ok!(word(&mut s.s, \"<\"));\n+            try!(word(&mut s.s, \"<\"));\n \n             let mut comma = false;\n             for lifetime in segment.lifetimes.iter() {\n                 if comma {\n-                    if_ok!(word_space(s, \",\"))\n+                    try!(word_space(s, \",\"))\n                 }\n-                if_ok!(print_lifetime(s, lifetime));\n+                try!(print_lifetime(s, lifetime));\n                 comma = true;\n             }\n \n             if !segment.types.is_empty() {\n                 if comma {\n-                    if_ok!(word_space(s, \",\"))\n+                    try!(word_space(s, \",\"))\n                 }\n-                if_ok!(commasep(s,\n+                try!(commasep(s,\n                                 Inconsistent,\n                                 segment.types.map_to_vec(|&t| t),\n                                 print_type_ref));\n             }\n \n-            if_ok!(word(&mut s.s, \">\"))\n+            try!(word(&mut s.s, \">\"))\n         }\n     }\n     Ok(())\n@@ -1671,115 +1671,115 @@ fn print_bounded_path(s: &mut State, path: &ast::Path,\n }\n \n pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n-    if_ok!(maybe_print_comment(s, pat.span.lo));\n+    try!(maybe_print_comment(s, pat.span.lo));\n     {\n         let ann_node = NodePat(s, pat);\n-        if_ok!(s.ann.pre(ann_node));\n+        try!(s.ann.pre(ann_node));\n     }\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n-      ast::PatWild => if_ok!(word(&mut s.s, \"_\")),\n-      ast::PatWildMulti => if_ok!(word(&mut s.s, \"..\")),\n+      ast::PatWild => try!(word(&mut s.s, \"_\")),\n+      ast::PatWildMulti => try!(word(&mut s.s, \"..\")),\n       ast::PatIdent(binding_mode, ref path, sub) => {\n           match binding_mode {\n               ast::BindByRef(mutbl) => {\n-                  if_ok!(word_nbsp(s, \"ref\"));\n-                  if_ok!(print_mutability(s, mutbl));\n+                  try!(word_nbsp(s, \"ref\"));\n+                  try!(print_mutability(s, mutbl));\n               }\n               ast::BindByValue(ast::MutImmutable) => {}\n               ast::BindByValue(ast::MutMutable) => {\n-                  if_ok!(word_nbsp(s, \"mut\"));\n+                  try!(word_nbsp(s, \"mut\"));\n               }\n           }\n-          if_ok!(print_path(s, path, true));\n+          try!(print_path(s, path, true));\n           match sub {\n               Some(p) => {\n-                  if_ok!(word(&mut s.s, \"@\"));\n-                  if_ok!(print_pat(s, p));\n+                  try!(word(&mut s.s, \"@\"));\n+                  try!(print_pat(s, p));\n               }\n               None => ()\n           }\n       }\n       ast::PatEnum(ref path, ref args_) => {\n-        if_ok!(print_path(s, path, true));\n+        try!(print_path(s, path, true));\n         match *args_ {\n-          None => if_ok!(word(&mut s.s, \"(..)\")),\n+          None => try!(word(&mut s.s, \"(..)\")),\n           Some(ref args) => {\n             if !args.is_empty() {\n-              if_ok!(popen(s));\n-              if_ok!(commasep(s, Inconsistent, *args,\n+              try!(popen(s));\n+              try!(commasep(s, Inconsistent, *args,\n                               |s, &p| print_pat(s, p)));\n-              if_ok!(pclose(s));\n+              try!(pclose(s));\n             } else { }\n           }\n         }\n       }\n       ast::PatStruct(ref path, ref fields, etc) => {\n-        if_ok!(print_path(s, path, true));\n-        if_ok!(word(&mut s.s, \"{\"));\n+        try!(print_path(s, path, true));\n+        try!(word(&mut s.s, \"{\"));\n         fn print_field(s: &mut State, f: &ast::FieldPat) -> io::IoResult<()> {\n-            if_ok!(cbox(s, indent_unit));\n-            if_ok!(print_ident(s, f.ident));\n-            if_ok!(word_space(s, \":\"));\n-            if_ok!(print_pat(s, f.pat));\n-            if_ok!(end(s));\n+            try!(cbox(s, indent_unit));\n+            try!(print_ident(s, f.ident));\n+            try!(word_space(s, \":\"));\n+            try!(print_pat(s, f.pat));\n+            try!(end(s));\n             Ok(())\n         }\n         fn get_span(f: &ast::FieldPat) -> codemap::Span { return f.pat.span; }\n-        if_ok!(commasep_cmnt(s, Consistent, *fields,\n+        try!(commasep_cmnt(s, Consistent, *fields,\n                              |s, f| print_field(s,f),\n                              get_span));\n         if etc {\n-            if fields.len() != 0u { if_ok!(word_space(s, \",\")); }\n-            if_ok!(word(&mut s.s, \"..\"));\n+            if fields.len() != 0u { try!(word_space(s, \",\")); }\n+            try!(word(&mut s.s, \"..\"));\n         }\n-        if_ok!(word(&mut s.s, \"}\"));\n+        try!(word(&mut s.s, \"}\"));\n       }\n       ast::PatTup(ref elts) => {\n-        if_ok!(popen(s));\n-        if_ok!(commasep(s, Inconsistent, *elts, |s, &p| print_pat(s, p)));\n+        try!(popen(s));\n+        try!(commasep(s, Inconsistent, *elts, |s, &p| print_pat(s, p)));\n         if elts.len() == 1 {\n-            if_ok!(word(&mut s.s, \",\"));\n+            try!(word(&mut s.s, \",\"));\n         }\n-        if_ok!(pclose(s));\n+        try!(pclose(s));\n       }\n       ast::PatUniq(inner) => {\n-          if_ok!(word(&mut s.s, \"~\"));\n-          if_ok!(print_pat(s, inner));\n+          try!(word(&mut s.s, \"~\"));\n+          try!(print_pat(s, inner));\n       }\n       ast::PatRegion(inner) => {\n-          if_ok!(word(&mut s.s, \"&\"));\n-          if_ok!(print_pat(s, inner));\n+          try!(word(&mut s.s, \"&\"));\n+          try!(print_pat(s, inner));\n       }\n-      ast::PatLit(e) => if_ok!(print_expr(s, e)),\n+      ast::PatLit(e) => try!(print_expr(s, e)),\n       ast::PatRange(begin, end) => {\n-        if_ok!(print_expr(s, begin));\n-        if_ok!(space(&mut s.s));\n-        if_ok!(word(&mut s.s, \"..\"));\n-        if_ok!(print_expr(s, end));\n+        try!(print_expr(s, begin));\n+        try!(space(&mut s.s));\n+        try!(word(&mut s.s, \"..\"));\n+        try!(print_expr(s, end));\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n-        if_ok!(word(&mut s.s, \"[\"));\n-        if_ok!(commasep(s, Inconsistent, *before, |s, &p| print_pat(s, p)));\n+        try!(word(&mut s.s, \"[\"));\n+        try!(commasep(s, Inconsistent, *before, |s, &p| print_pat(s, p)));\n         for &p in slice.iter() {\n-            if !before.is_empty() { if_ok!(word_space(s, \",\")); }\n+            if !before.is_empty() { try!(word_space(s, \",\")); }\n             match *p {\n                 ast::Pat { node: ast::PatWildMulti, .. } => {\n                     // this case is handled by print_pat\n                 }\n-                _ => if_ok!(word(&mut s.s, \"..\")),\n+                _ => try!(word(&mut s.s, \"..\")),\n             }\n-            if_ok!(print_pat(s, p));\n-            if !after.is_empty() { if_ok!(word_space(s, \",\")); }\n+            try!(print_pat(s, p));\n+            if !after.is_empty() { try!(word_space(s, \",\")); }\n         }\n-        if_ok!(commasep(s, Inconsistent, *after, |s, &p| print_pat(s, p)));\n-        if_ok!(word(&mut s.s, \"]\"));\n+        try!(commasep(s, Inconsistent, *after, |s, &p| print_pat(s, p)));\n+        try!(word(&mut s.s, \"]\"));\n       }\n     }\n     {\n         let ann_node = NodePat(s, pat);\n-        if_ok!(s.ann.post(ann_node));\n+        try!(s.ann.post(ann_node));\n     }\n     Ok(())\n }\n@@ -1794,20 +1794,20 @@ pub fn explicit_self_to_str(explicit_self: &ast::ExplicitSelf_) -> ~str {\n fn print_explicit_self(s: &mut State,\n                        explicit_self: ast::ExplicitSelf_,\n                        mutbl: ast::Mutability) -> io::IoResult<bool> {\n-    if_ok!(print_mutability(s, mutbl));\n+    try!(print_mutability(s, mutbl));\n     match explicit_self {\n         ast::SelfStatic => { return Ok(false); }\n         ast::SelfValue => {\n-            if_ok!(word(&mut s.s, \"self\"));\n+            try!(word(&mut s.s, \"self\"));\n         }\n         ast::SelfUniq => {\n-            if_ok!(word(&mut s.s, \"~self\"));\n+            try!(word(&mut s.s, \"~self\"));\n         }\n         ast::SelfRegion(ref lt, m) => {\n-            if_ok!(word(&mut s.s, \"&\"));\n-            if_ok!(print_opt_lifetime(s, lt));\n-            if_ok!(print_mutability(s, m));\n-            if_ok!(word(&mut s.s, \"self\"));\n+            try!(word(&mut s.s, \"&\"));\n+            try!(print_opt_lifetime(s, lt));\n+            try!(print_mutability(s, m));\n+            try!(word(&mut s.s, \"self\"));\n         }\n     }\n     return Ok(true);\n@@ -1821,13 +1821,13 @@ pub fn print_fn(s: &mut State,\n                 generics: &ast::Generics,\n                 opt_explicit_self: Option<ast::ExplicitSelf_>,\n                 vis: ast::Visibility) -> io::IoResult<()> {\n-    if_ok!(head(s, \"\"));\n-    if_ok!(print_fn_header_info(s, opt_explicit_self, purity, abis,\n+    try!(head(s, \"\"));\n+    try!(print_fn_header_info(s, opt_explicit_self, purity, abis,\n                                 ast::Many, None, vis));\n-    if_ok!(nbsp(s));\n-    if_ok!(print_ident(s, name));\n-    if_ok!(print_generics(s, generics));\n-    if_ok!(print_fn_args_and_ret(s, decl, opt_explicit_self));\n+    try!(nbsp(s));\n+    try!(print_ident(s, name));\n+    try!(print_generics(s, generics));\n+    try!(print_fn_args_and_ret(s, decl, opt_explicit_self));\n     Ok(())\n }\n \n@@ -1837,7 +1837,7 @@ pub fn print_fn_args(s: &mut State, decl: &ast::FnDecl,\n {\n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n-    if_ok!(rbox(s, 0u, Inconsistent));\n+    try!(rbox(s, 0u, Inconsistent));\n     let mut first = true;\n     for &explicit_self in opt_explicit_self.iter() {\n         let m = match explicit_self {\n@@ -1847,7 +1847,7 @@ pub fn print_fn_args(s: &mut State, decl: &ast::FnDecl,\n                 _ => ast::MutImmutable\n             }\n         };\n-        first = !if_ok!(print_explicit_self(s, explicit_self, m));\n+        first = !try!(print_explicit_self(s, explicit_self, m));\n     }\n \n     // HACK(eddyb) ignore the separately printed self argument.\n@@ -1858,8 +1858,8 @@ pub fn print_fn_args(s: &mut State, decl: &ast::FnDecl,\n     };\n \n     for arg in args.iter() {\n-        if first { first = false; } else { if_ok!(word_space(s, \",\")); }\n-        if_ok!(print_arg(s, arg));\n+        if first { first = false; } else { try!(word_space(s, \",\")); }\n+        try!(print_arg(s, arg));\n     }\n \n     end(s)\n@@ -1869,55 +1869,55 @@ pub fn print_fn_args_and_ret(s: &mut State, decl: &ast::FnDecl,\n                              opt_explicit_self: Option<ast::ExplicitSelf_>)\n     -> io::IoResult<()>\n {\n-    if_ok!(popen(s));\n-    if_ok!(print_fn_args(s, decl, opt_explicit_self));\n+    try!(popen(s));\n+    try!(print_fn_args(s, decl, opt_explicit_self));\n     if decl.variadic {\n-        if_ok!(word(&mut s.s, \", ...\"));\n+        try!(word(&mut s.s, \", ...\"));\n     }\n-    if_ok!(pclose(s));\n+    try!(pclose(s));\n \n-    if_ok!(maybe_print_comment(s, decl.output.span.lo));\n+    try!(maybe_print_comment(s, decl.output.span.lo));\n     match decl.output.node {\n         ast::TyNil => {}\n         _ => {\n-            if_ok!(space_if_not_bol(s));\n-            if_ok!(word_space(s, \"->\"));\n-            if_ok!(print_type(s, decl.output));\n+            try!(space_if_not_bol(s));\n+            try!(word_space(s, \"->\"));\n+            try!(print_type(s, decl.output));\n         }\n     }\n     Ok(())\n }\n \n pub fn print_fn_block_args(s: &mut State,\n                            decl: &ast::FnDecl) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, \"|\"));\n-    if_ok!(print_fn_args(s, decl, None));\n-    if_ok!(word(&mut s.s, \"|\"));\n+    try!(word(&mut s.s, \"|\"));\n+    try!(print_fn_args(s, decl, None));\n+    try!(word(&mut s.s, \"|\"));\n \n     match decl.output.node {\n         ast::TyInfer => {}\n         _ => {\n-            if_ok!(space_if_not_bol(s));\n-            if_ok!(word_space(s, \"->\"));\n-            if_ok!(print_type(s, decl.output));\n+            try!(space_if_not_bol(s));\n+            try!(word_space(s, \"->\"));\n+            try!(print_type(s, decl.output));\n         }\n     }\n \n     maybe_print_comment(s, decl.output.span.lo)\n }\n \n pub fn print_proc_args(s: &mut State, decl: &ast::FnDecl) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, \"proc\"));\n-    if_ok!(word(&mut s.s, \"(\"));\n-    if_ok!(print_fn_args(s, decl, None));\n-    if_ok!(word(&mut s.s, \")\"));\n+    try!(word(&mut s.s, \"proc\"));\n+    try!(word(&mut s.s, \"(\"));\n+    try!(print_fn_args(s, decl, None));\n+    try!(word(&mut s.s, \")\"));\n \n     match decl.output.node {\n         ast::TyInfer => {}\n         _ => {\n-            if_ok!(space_if_not_bol(s));\n-            if_ok!(word_space(s, \"->\"));\n-            if_ok!(print_type(s, decl.output));\n+            try!(space_if_not_bol(s));\n+            try!(word_space(s, \"->\"));\n+            try!(print_type(s, decl.output));\n         }\n     }\n \n@@ -1927,38 +1927,38 @@ pub fn print_proc_args(s: &mut State, decl: &ast::FnDecl) -> io::IoResult<()> {\n pub fn print_bounds(s: &mut State, bounds: &OptVec<ast::TyParamBound>,\n                     print_colon_anyway: bool) -> io::IoResult<()> {\n     if !bounds.is_empty() {\n-        if_ok!(word(&mut s.s, \":\"));\n+        try!(word(&mut s.s, \":\"));\n         let mut first = true;\n         for bound in bounds.iter() {\n-            if_ok!(nbsp(s));\n+            try!(nbsp(s));\n             if first {\n                 first = false;\n             } else {\n-                if_ok!(word_space(s, \"+\"));\n+                try!(word_space(s, \"+\"));\n             }\n \n-            if_ok!(match *bound {\n+            try!(match *bound {\n                 TraitTyParamBound(ref tref) => print_trait_ref(s, tref),\n                 RegionTyParamBound => word(&mut s.s, \"'static\"),\n             })\n         }\n     } else if print_colon_anyway {\n-        if_ok!(word(&mut s.s, \":\"));\n+        try!(word(&mut s.s, \":\"));\n     }\n     Ok(())\n }\n \n pub fn print_lifetime(s: &mut State,\n                       lifetime: &ast::Lifetime) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, \"'\"));\n+    try!(word(&mut s.s, \"'\"));\n     print_ident(s, lifetime.ident)\n }\n \n pub fn print_generics(s: &mut State,\n                       generics: &ast::Generics) -> io::IoResult<()> {\n     let total = generics.lifetimes.len() + generics.ty_params.len();\n     if total > 0 {\n-        if_ok!(word(&mut s.s, \"<\"));\n+        try!(word(&mut s.s, \"<\"));\n         fn print_item(s: &mut State, generics: &ast::Generics,\n                       idx: uint) -> io::IoResult<()> {\n             if idx < generics.lifetimes.len() {\n@@ -1967,13 +1967,13 @@ pub fn print_generics(s: &mut State,\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n-                if_ok!(print_ident(s, param.ident));\n-                if_ok!(print_bounds(s, &param.bounds, false));\n+                try!(print_ident(s, param.ident));\n+                try!(print_bounds(s, &param.bounds, false));\n                 match param.default {\n                     Some(default) => {\n-                        if_ok!(space(&mut s.s));\n-                        if_ok!(word_space(s, \"=\"));\n-                        if_ok!(print_type(s, default));\n+                        try!(space(&mut s.s));\n+                        try!(word_space(s, \"=\"));\n+                        try!(print_type(s, default));\n                     }\n                     _ => {}\n                 }\n@@ -1986,32 +1986,32 @@ pub fn print_generics(s: &mut State,\n             ints.push(i);\n         }\n \n-        if_ok!(commasep(s, Inconsistent, ints,\n+        try!(commasep(s, Inconsistent, ints,\n                         |s, &i| print_item(s, generics, i)));\n-        if_ok!(word(&mut s.s, \">\"));\n+        try!(word(&mut s.s, \">\"));\n     }\n     Ok(())\n }\n \n pub fn print_meta_item(s: &mut State, item: &ast::MetaItem) -> io::IoResult<()> {\n-    if_ok!(ibox(s, indent_unit));\n+    try!(ibox(s, indent_unit));\n     match item.node {\n         ast::MetaWord(ref name) => {\n-            if_ok!(word(&mut s.s, name.get()));\n+            try!(word(&mut s.s, name.get()));\n         }\n         ast::MetaNameValue(ref name, ref value) => {\n-            if_ok!(word_space(s, name.get()));\n-            if_ok!(word_space(s, \"=\"));\n-            if_ok!(print_literal(s, value));\n+            try!(word_space(s, name.get()));\n+            try!(word_space(s, \"=\"));\n+            try!(print_literal(s, value));\n         }\n         ast::MetaList(ref name, ref items) => {\n-            if_ok!(word(&mut s.s, name.get()));\n-            if_ok!(popen(s));\n-            if_ok!(commasep(s,\n+            try!(word(&mut s.s, name.get()));\n+            try!(popen(s));\n+            try!(commasep(s,\n                             Consistent,\n                             items.as_slice(),\n                             |p, &i| print_meta_item(p, i)));\n-            if_ok!(pclose(s));\n+            try!(pclose(s));\n         }\n     }\n     end(s)\n@@ -2022,26 +2022,26 @@ pub fn print_view_path(s: &mut State, vp: &ast::ViewPath) -> io::IoResult<()> {\n       ast::ViewPathSimple(ident, ref path, _) => {\n         // FIXME(#6993) can't compare identifiers directly here\n         if path.segments.last().unwrap().identifier.name != ident.name {\n-            if_ok!(print_ident(s, ident));\n-            if_ok!(space(&mut s.s));\n-            if_ok!(word_space(s, \"=\"));\n+            try!(print_ident(s, ident));\n+            try!(space(&mut s.s));\n+            try!(word_space(s, \"=\"));\n         }\n         print_path(s, path, false)\n       }\n \n       ast::ViewPathGlob(ref path, _) => {\n-        if_ok!(print_path(s, path, false));\n+        try!(print_path(s, path, false));\n         word(&mut s.s, \"::*\")\n       }\n \n       ast::ViewPathList(ref path, ref idents, _) => {\n         if path.segments.is_empty() {\n-            if_ok!(word(&mut s.s, \"{\"));\n+            try!(word(&mut s.s, \"{\"));\n         } else {\n-            if_ok!(print_path(s, path, false));\n-            if_ok!(word(&mut s.s, \"::{\"));\n+            try!(print_path(s, path, false));\n+            try!(word(&mut s.s, \"::{\"));\n         }\n-        if_ok!(commasep(s, Inconsistent, (*idents), |s, w| {\n+        try!(commasep(s, Inconsistent, (*idents), |s, w| {\n             print_ident(s, w.node.name)\n         }));\n         word(&mut s.s, \"}\")\n@@ -2055,30 +2055,30 @@ pub fn print_view_paths(s: &mut State,\n }\n \n pub fn print_view_item(s: &mut State, item: &ast::ViewItem) -> io::IoResult<()> {\n-    if_ok!(hardbreak_if_not_bol(s));\n-    if_ok!(maybe_print_comment(s, item.span.lo));\n-    if_ok!(print_outer_attributes(s, item.attrs));\n-    if_ok!(print_visibility(s, item.vis));\n+    try!(hardbreak_if_not_bol(s));\n+    try!(maybe_print_comment(s, item.span.lo));\n+    try!(print_outer_attributes(s, item.attrs));\n+    try!(print_visibility(s, item.vis));\n     match item.node {\n         ast::ViewItemExternMod(id, ref optional_path, _) => {\n-            if_ok!(head(s, \"extern crate\"));\n-            if_ok!(print_ident(s, id));\n+            try!(head(s, \"extern crate\"));\n+            try!(print_ident(s, id));\n             for &(ref p, style) in optional_path.iter() {\n-                if_ok!(space(&mut s.s));\n-                if_ok!(word(&mut s.s, \"=\"));\n-                if_ok!(space(&mut s.s));\n-                if_ok!(print_string(s, p.get(), style));\n+                try!(space(&mut s.s));\n+                try!(word(&mut s.s, \"=\"));\n+                try!(space(&mut s.s));\n+                try!(print_string(s, p.get(), style));\n             }\n         }\n \n         ast::ViewItemUse(ref vps) => {\n-            if_ok!(head(s, \"use\"));\n-            if_ok!(print_view_paths(s, *vps));\n+            try!(head(s, \"use\"));\n+            try!(print_view_paths(s, *vps));\n         }\n     }\n-    if_ok!(word(&mut s.s, \";\"));\n-    if_ok!(end(s)); // end inner head-block\n-    if_ok!(end(s)); // end outer head-block\n+    try!(word(&mut s.s, \";\"));\n+    try!(end(s)); // end inner head-block\n+    try!(end(s)); // end outer head-block\n     Ok(())\n }\n \n@@ -2091,14 +2091,14 @@ pub fn print_mutability(s: &mut State,\n }\n \n pub fn print_mt(s: &mut State, mt: &ast::MutTy) -> io::IoResult<()> {\n-    if_ok!(print_mutability(s, mt.mutbl));\n+    try!(print_mutability(s, mt.mutbl));\n     print_type(s, mt.ty)\n }\n \n pub fn print_arg(s: &mut State, input: &ast::Arg) -> io::IoResult<()> {\n-    if_ok!(ibox(s, indent_unit));\n+    try!(ibox(s, indent_unit));\n     match input.ty.node {\n-        ast::TyInfer => if_ok!(print_pat(s, input.pat)),\n+        ast::TyInfer => try!(print_pat(s, input.pat)),\n         _ => {\n             match input.pat.node {\n                 ast::PatIdent(_, ref path, _) if\n@@ -2108,12 +2108,12 @@ pub fn print_arg(s: &mut State, input: &ast::Arg) -> io::IoResult<()> {\n                     // Do nothing.\n                 }\n                 _ => {\n-                    if_ok!(print_pat(s, input.pat));\n-                    if_ok!(word(&mut s.s, \":\"));\n-                    if_ok!(space(&mut s.s));\n+                    try!(print_pat(s, input.pat));\n+                    try!(word(&mut s.s, \":\"));\n+                    try!(space(&mut s.s));\n                 }\n             }\n-            if_ok!(print_type(s, input.ty));\n+            try!(print_type(s, input.ty));\n         }\n     }\n     end(s)\n@@ -2132,32 +2132,32 @@ pub fn print_ty_fn(s: &mut State,\n                    opt_explicit_self: Option<ast::ExplicitSelf_>)\n     -> io::IoResult<()>\n {\n-    if_ok!(ibox(s, indent_unit));\n+    try!(ibox(s, indent_unit));\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n     // function prints the sigil in the wrong place.  That should be fixed.\n     if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n-        if_ok!(word(&mut s.s, \"proc\"));\n+        try!(word(&mut s.s, \"proc\"));\n     } else if opt_sigil == Some(ast::BorrowedSigil) {\n-        if_ok!(print_extern_opt_abis(s, opt_abis));\n+        try!(print_extern_opt_abis(s, opt_abis));\n         for lifetime in opt_region.iter() {\n-            if_ok!(print_lifetime(s, lifetime));\n+            try!(print_lifetime(s, lifetime));\n         }\n-        if_ok!(print_purity(s, purity));\n-        if_ok!(print_onceness(s, onceness));\n+        try!(print_purity(s, purity));\n+        try!(print_onceness(s, onceness));\n     } else {\n-        if_ok!(print_opt_abis_and_extern_if_nondefault(s, opt_abis));\n-        if_ok!(print_opt_sigil(s, opt_sigil));\n-        if_ok!(print_opt_lifetime(s, opt_region));\n-        if_ok!(print_purity(s, purity));\n-        if_ok!(print_onceness(s, onceness));\n-        if_ok!(word(&mut s.s, \"fn\"));\n+        try!(print_opt_abis_and_extern_if_nondefault(s, opt_abis));\n+        try!(print_opt_sigil(s, opt_sigil));\n+        try!(print_opt_lifetime(s, opt_region));\n+        try!(print_purity(s, purity));\n+        try!(print_onceness(s, onceness));\n+        try!(word(&mut s.s, \"fn\"));\n     }\n \n     match id {\n         Some(id) => {\n-            if_ok!(word(&mut s.s, \" \"));\n-            if_ok!(print_ident(s, id));\n+            try!(word(&mut s.s, \" \"));\n+            try!(print_ident(s, id));\n         }\n         _ => ()\n     }\n@@ -2166,42 +2166,42 @@ pub fn print_ty_fn(s: &mut State,\n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     }\n \n-    match generics { Some(g) => if_ok!(print_generics(s, g)), _ => () }\n-    if_ok!(zerobreak(&mut s.s));\n+    match generics { Some(g) => try!(print_generics(s, g)), _ => () }\n+    try!(zerobreak(&mut s.s));\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n-        if_ok!(word(&mut s.s, \"|\"));\n+        try!(word(&mut s.s, \"|\"));\n     } else {\n-        if_ok!(popen(s));\n+        try!(popen(s));\n     }\n \n-    if_ok!(print_fn_args(s, decl, opt_explicit_self));\n+    try!(print_fn_args(s, decl, opt_explicit_self));\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n-        if_ok!(word(&mut s.s, \"|\"));\n+        try!(word(&mut s.s, \"|\"));\n \n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     } else {\n         if decl.variadic {\n-            if_ok!(word(&mut s.s, \", ...\"));\n+            try!(word(&mut s.s, \", ...\"));\n         }\n-        if_ok!(pclose(s));\n+        try!(pclose(s));\n     }\n \n-    if_ok!(maybe_print_comment(s, decl.output.span.lo));\n+    try!(maybe_print_comment(s, decl.output.span.lo));\n \n     match decl.output.node {\n         ast::TyNil => {}\n         _ => {\n-            if_ok!(space_if_not_bol(s));\n-            if_ok!(ibox(s, indent_unit));\n-            if_ok!(word_space(s, \"->\"));\n+            try!(space_if_not_bol(s));\n+            try!(ibox(s, indent_unit));\n+            try!(word_space(s, \"->\"));\n             if decl.cf == ast::NoReturn {\n-                if_ok!(word_nbsp(s, \"!\"));\n+                try!(word_nbsp(s, \"!\"));\n             } else {\n-                if_ok!(print_type(s, decl.output));\n+                try!(print_type(s, decl.output));\n             }\n-            if_ok!(end(s));\n+            try!(end(s));\n         }\n     }\n \n@@ -2223,7 +2223,7 @@ pub fn maybe_print_trailing_comment(s: &mut State, span: codemap::Span,\n             match next_pos { None => (), Some(p) => next = p }\n             if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                 span_line.line == comment_line.line {\n-                    if_ok!(print_comment(s, cmnt));\n+                    try!(print_comment(s, cmnt));\n                     s.cur_cmnt_and_lit.cur_cmnt += 1u;\n                 }\n         }\n@@ -2236,12 +2236,12 @@ pub fn print_remaining_comments(s: &mut State) -> io::IoResult<()> {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n     if next_comment(s).is_none() {\n-        if_ok!(hardbreak(&mut s.s));\n+        try!(hardbreak(&mut s.s));\n     }\n     loop {\n         match next_comment(s) {\n             Some(ref cmnt) => {\n-                if_ok!(print_comment(s, cmnt));\n+                try!(print_comment(s, cmnt));\n                 s.cur_cmnt_and_lit.cur_cmnt += 1u;\n             }\n             _ => break\n@@ -2251,7 +2251,7 @@ pub fn print_remaining_comments(s: &mut State) -> io::IoResult<()> {\n }\n \n pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n-    if_ok!(maybe_print_comment(s, lit.span.lo));\n+    try!(maybe_print_comment(s, lit.span.lo));\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n         return word(&mut s.s, (*ltrl).lit);\n@@ -2299,12 +2299,12 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n         if val { word(&mut s.s, \"true\") } else { word(&mut s.s, \"false\") }\n       }\n       ast::LitBinary(ref arr) => {\n-        if_ok!(ibox(s, indent_unit));\n-        if_ok!(word(&mut s.s, \"[\"));\n-        if_ok!(commasep_cmnt(s, Inconsistent, *arr.borrow(),\n+        try!(ibox(s, indent_unit));\n+        try!(word(&mut s.s, \"[\"));\n+        try!(commasep_cmnt(s, Inconsistent, *arr.borrow(),\n                              |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                              |_| lit.span));\n-        if_ok!(word(&mut s.s, \"]\"));\n+        try!(word(&mut s.s, \"]\"));\n         end(s)\n       }\n     }\n@@ -2334,7 +2334,7 @@ pub fn maybe_print_comment(s: &mut State, pos: BytePos) -> io::IoResult<()> {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n             if (*cmnt).pos < pos {\n-                if_ok!(print_comment(s, cmnt));\n+                try!(print_comment(s, cmnt));\n                 s.cur_cmnt_and_lit.cur_cmnt += 1u;\n             } else { break; }\n           }\n@@ -2349,35 +2349,35 @@ pub fn print_comment(s: &mut State,\n     match cmnt.style {\n         comments::Mixed => {\n             assert_eq!(cmnt.lines.len(), 1u);\n-            if_ok!(zerobreak(&mut s.s));\n-            if_ok!(word(&mut s.s, cmnt.lines[0]));\n-            if_ok!(zerobreak(&mut s.s));\n+            try!(zerobreak(&mut s.s));\n+            try!(word(&mut s.s, cmnt.lines[0]));\n+            try!(zerobreak(&mut s.s));\n         }\n         comments::Isolated => {\n-            if_ok!(pprust::hardbreak_if_not_bol(s));\n+            try!(pprust::hardbreak_if_not_bol(s));\n             for line in cmnt.lines.iter() {\n                 // Don't print empty lines because they will end up as trailing\n                 // whitespace\n                 if !line.is_empty() {\n-                    if_ok!(word(&mut s.s, *line));\n+                    try!(word(&mut s.s, *line));\n                 }\n-                if_ok!(hardbreak(&mut s.s));\n+                try!(hardbreak(&mut s.s));\n             }\n         }\n         comments::Trailing => {\n-            if_ok!(word(&mut s.s, \" \"));\n+            try!(word(&mut s.s, \" \"));\n             if cmnt.lines.len() == 1u {\n-                if_ok!(word(&mut s.s, cmnt.lines[0]));\n-                if_ok!(hardbreak(&mut s.s));\n+                try!(word(&mut s.s, cmnt.lines[0]));\n+                try!(hardbreak(&mut s.s));\n             } else {\n-                if_ok!(ibox(s, 0u));\n+                try!(ibox(s, 0u));\n                 for line in cmnt.lines.iter() {\n                     if !line.is_empty() {\n-                        if_ok!(word(&mut s.s, *line));\n+                        try!(word(&mut s.s, *line));\n                     }\n-                    if_ok!(hardbreak(&mut s.s));\n+                    try!(hardbreak(&mut s.s));\n                 }\n-                if_ok!(end(s));\n+                try!(end(s));\n             }\n         }\n         comments::BlankLine => {\n@@ -2387,9 +2387,9 @@ pub fn print_comment(s: &mut State,\n                 _ => false\n             };\n             if is_semi || is_begin(s) || is_end(s) {\n-                if_ok!(hardbreak(&mut s.s));\n+                try!(hardbreak(&mut s.s));\n             }\n-            if_ok!(hardbreak(&mut s.s));\n+            try!(hardbreak(&mut s.s));\n         }\n     }\n     Ok(())\n@@ -2443,7 +2443,7 @@ pub fn print_opt_purity(s: &mut State,\n     match opt_purity {\n         Some(ast::ImpureFn) => { }\n         Some(purity) => {\n-            if_ok!(word_nbsp(s, purity_to_str(purity)));\n+            try!(word_nbsp(s, purity_to_str(purity)));\n         }\n         None => {}\n     }\n@@ -2456,8 +2456,8 @@ pub fn print_opt_abis_and_extern_if_nondefault(s: &mut State,\n {\n     match opt_abis {\n         Some(abis) if !abis.is_rust() => {\n-            if_ok!(word_nbsp(s, \"extern\"));\n-            if_ok!(word_nbsp(s, abis.to_str()));\n+            try!(word_nbsp(s, \"extern\"));\n+            try!(word_nbsp(s, abis.to_str()));\n         }\n         Some(_) | None => {}\n     };\n@@ -2468,8 +2468,8 @@ pub fn print_extern_opt_abis(s: &mut State,\n                              opt_abis: Option<AbiSet>) -> io::IoResult<()> {\n     match opt_abis {\n         Some(abis) => {\n-            if_ok!(word_nbsp(s, \"extern\"));\n-            if_ok!(word_nbsp(s, abis.to_str()));\n+            try!(word_nbsp(s, \"extern\"));\n+            try!(word_nbsp(s, abis.to_str()));\n         }\n         None => {}\n     }\n@@ -2493,22 +2493,22 @@ pub fn print_fn_header_info(s: &mut State,\n                             onceness: ast::Onceness,\n                             opt_sigil: Option<ast::Sigil>,\n                             vis: ast::Visibility) -> io::IoResult<()> {\n-    if_ok!(word(&mut s.s, visibility_qualified(vis, \"\")));\n+    try!(word(&mut s.s, visibility_qualified(vis, \"\")));\n \n     if abis != AbiSet::Rust() {\n-        if_ok!(word_nbsp(s, \"extern\"));\n-        if_ok!(word_nbsp(s, abis.to_str()));\n+        try!(word_nbsp(s, \"extern\"));\n+        try!(word_nbsp(s, abis.to_str()));\n \n         if opt_purity != Some(ast::ExternFn) {\n-            if_ok!(print_opt_purity(s, opt_purity));\n+            try!(print_opt_purity(s, opt_purity));\n         }\n     } else {\n-        if_ok!(print_opt_purity(s, opt_purity));\n+        try!(print_opt_purity(s, opt_purity));\n     }\n \n-    if_ok!(print_onceness(s, onceness));\n-    if_ok!(word(&mut s.s, \"fn\"));\n-    if_ok!(print_opt_sigil(s, opt_sigil));\n+    try!(print_onceness(s, onceness));\n+    try!(word(&mut s.s, \"fn\"));\n+    try!(print_opt_sigil(s, opt_sigil));\n     Ok(())\n }\n "}, {"sha": "1efbd461da86d4ee860b3569a7a6d0a8115469d8", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -30,10 +30,6 @@ use terminfo::searcher::open;\n use terminfo::parser::compiled::{parse, msys_terminfo};\n use terminfo::parm::{expand, Number, Variables};\n \n-macro_rules! if_ok (\n-    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-)\n-\n pub mod terminfo;\n \n // FIXME (#2807): Windows support.\n@@ -155,7 +151,7 @@ impl<T: Writer> Terminal<T> {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                if_ok!(self.out.write(s.unwrap()));\n+                try!(self.out.write(s.unwrap()));\n                 return Ok(true)\n             } else {\n                 warn!(\"{}\", s.unwrap_err());\n@@ -176,7 +172,7 @@ impl<T: Writer> Terminal<T> {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                if_ok!(self.out.write(s.unwrap()));\n+                try!(self.out.write(s.unwrap()));\n                 return Ok(true)\n             } else {\n                 warn!(\"{}\", s.unwrap_err());\n@@ -198,7 +194,7 @@ impl<T: Writer> Terminal<T> {\n                 if parm.is_some() {\n                     let s = expand(*parm.unwrap(), [], &mut Variables::new());\n                     if s.is_ok() {\n-                        if_ok!(self.out.write(s.unwrap()));\n+                        try!(self.out.write(s.unwrap()));\n                         return Ok(true)\n                     } else {\n                         warn!(\"{}\", s.unwrap_err());"}, {"sha": "b2d06d3b7d82368c99afff70f1900afc0141a0d4", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -162,7 +162,7 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader,\n              longnames: bool) -> Result<~TermInfo, ~str> {\n-    macro_rules! if_ok( ($e:expr) => (\n+    macro_rules! try( ($e:expr) => (\n         match $e { Ok(e) => e, Err(e) => return Err(format!(\"{}\", e)) }\n     ) )\n \n@@ -181,17 +181,17 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // Check magic number\n-    let magic = if_ok!(file.read_le_u16());\n+    let magic = try!(file.read_le_u16());\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n                            0x011A, magic as uint));\n     }\n \n-    let names_bytes          = if_ok!(file.read_le_i16()) as int;\n-    let bools_bytes          = if_ok!(file.read_le_i16()) as int;\n-    let numbers_count        = if_ok!(file.read_le_i16()) as int;\n-    let string_offsets_count = if_ok!(file.read_le_i16()) as int;\n-    let string_table_bytes   = if_ok!(file.read_le_i16()) as int;\n+    let names_bytes          = try!(file.read_le_i16()) as int;\n+    let bools_bytes          = try!(file.read_le_i16()) as int;\n+    let numbers_count        = try!(file.read_le_i16()) as int;\n+    let string_offsets_count = try!(file.read_le_i16()) as int;\n+    let string_table_bytes   = try!(file.read_le_i16()) as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -220,21 +220,21 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // don't read NUL\n-    let bytes = if_ok!(file.read_bytes(names_bytes as uint - 1));\n+    let bytes = try!(file.read_bytes(names_bytes as uint - 1));\n     let names_str = match str::from_utf8_owned(bytes) {\n         Some(s) => s, None => return Err(~\"input not utf-8\"),\n     };\n \n     let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n \n-    if_ok!(file.read_byte()); // consume NUL\n+    try!(file.read_byte()); // consume NUL\n \n     debug!(\"term names: {:?}\", term_names);\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n-            let b = if_ok!(file.read_byte());\n+            let b = try!(file.read_byte());\n             if b < 0 {\n                 error!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n@@ -249,13 +249,13 @@ pub fn parse(file: &mut io::Reader,\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n         debug!(\"adjusting for padding between bools and numbers\");\n-        if_ok!(file.read_byte()); // compensate for padding\n+        try!(file.read_byte()); // compensate for padding\n     }\n \n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in range(0, numbers_count) {\n-            let n = if_ok!(file.read_le_u16());\n+            let n = try!(file.read_le_u16());\n             if n != 0xFFFF {\n                 debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n@@ -270,12 +270,12 @@ pub fn parse(file: &mut io::Reader,\n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n-            string_offsets.push(if_ok!(file.read_le_u16()));\n+            string_offsets.push(try!(file.read_le_u16()));\n         }\n \n         debug!(\"offsets: {:?}\", string_offsets);\n \n-        let string_table = if_ok!(file.read_bytes(string_table_bytes as uint));\n+        let string_table = try!(file.read_bytes(string_table_bytes as uint));\n \n         if string_table.len() != string_table_bytes as uint {\n             error!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),"}, {"sha": "4a9575c78f465f24e0084253f3f844fd691b6802", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9bcc545631f2e0a5c248206ae25831242affdf/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7e9bcc545631f2e0a5c248206ae25831242affdf", "patch": "@@ -397,7 +397,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn new(opts: &TestOpts,\n                _: Option<T>) -> io::IoResult<ConsoleTestState<StdWriter>> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => Some(if_ok!(File::create(path))),\n+            Some(ref path) => Some(try!(File::create(path))),\n             None => None\n         };\n         let out = match term::Terminal::new(io::stdout()) {\n@@ -461,11 +461,11 @@ impl<T: Writer> ConsoleTestState<T> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n-                    if_ok!(term.fg(color));\n+                    try!(term.fg(color));\n                 }\n-                if_ok!(term.write(word.as_bytes()));\n+                try!(term.write(word.as_bytes()));\n                 if self.use_color {\n-                    if_ok!(term.reset());\n+                    try!(term.reset());\n                 }\n                 Ok(())\n             }\n@@ -493,16 +493,16 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n \n     pub fn write_result(&mut self, result: &TestResult) -> io::IoResult<()> {\n-        if_ok!(match *result {\n+        try!(match *result {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n-                if_ok!(self.write_metric());\n+                try!(self.write_metric());\n                 self.write_plain(format!(\": {}\", fmt_metrics(mm)))\n             }\n             TrBench(ref bs) => {\n-                if_ok!(self.write_bench());\n+                try!(self.write_bench());\n                 self.write_plain(format!(\": {}\", fmt_bench_samples(bs)))\n             }\n         });\n@@ -527,7 +527,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n \n     pub fn write_failures(&mut self) -> io::IoResult<()> {\n-        if_ok!(self.write_plain(\"\\nfailures:\\n\"));\n+        try!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = ~[];\n         let mut fail_out  = ~\"\";\n         for &(ref f, ref stdout) in self.failures.iter() {\n@@ -541,14 +541,14 @@ impl<T: Writer> ConsoleTestState<T> {\n             }\n         }\n         if fail_out.len() > 0 {\n-            if_ok!(self.write_plain(\"\\n\"));\n-            if_ok!(self.write_plain(fail_out));\n+            try!(self.write_plain(\"\\n\"));\n+            try!(self.write_plain(fail_out));\n         }\n \n-        if_ok!(self.write_plain(\"\\nfailures:\\n\"));\n+        try!(self.write_plain(\"\\nfailures:\\n\"));\n         failures.sort();\n         for name in failures.iter() {\n-            if_ok!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n+            try!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n         }\n         Ok(())\n     }\n@@ -565,37 +565,37 @@ impl<T: Writer> ConsoleTestState<T> {\n                 LikelyNoise => noise += 1,\n                 MetricAdded => {\n                     added += 1;\n-                    if_ok!(self.write_added());\n-                    if_ok!(self.write_plain(format!(\": {}\\n\", *k)));\n+                    try!(self.write_added());\n+                    try!(self.write_plain(format!(\": {}\\n\", *k)));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n-                    if_ok!(self.write_removed());\n-                    if_ok!(self.write_plain(format!(\": {}\\n\", *k)));\n+                    try!(self.write_removed());\n+                    try!(self.write_plain(format!(\": {}\\n\", *k)));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    if_ok!(self.write_plain(format!(\": {}\", *k)));\n-                    if_ok!(self.write_improved());\n-                    if_ok!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n+                    try!(self.write_plain(format!(\": {}\", *k)));\n+                    try!(self.write_improved());\n+                    try!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    if_ok!(self.write_plain(format!(\": {}\", *k)));\n-                    if_ok!(self.write_regressed());\n-                    if_ok!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n+                    try!(self.write_plain(format!(\": {}\", *k)));\n+                    try!(self.write_regressed());\n+                    try!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n                 }\n             }\n         }\n-        if_ok!(self.write_plain(format!(\"result of ratchet: {} metrics added, \\\n+        try!(self.write_plain(format!(\"result of ratchet: {} metrics added, \\\n                                         {} removed, {} improved, {} regressed, \\\n                                         {} noise\\n\",\n                                        added, removed, improved, regressed,\n                                        noise)));\n         if regressed == 0 {\n-            if_ok!(self.write_plain(\"updated ratchet file\\n\"));\n+            try!(self.write_plain(\"updated ratchet file\\n\"));\n         } else {\n-            if_ok!(self.write_plain(\"left ratchet file untouched\\n\"));\n+            try!(self.write_plain(\"left ratchet file untouched\\n\"));\n         }\n         Ok(())\n     }\n@@ -608,38 +608,38 @@ impl<T: Writer> ConsoleTestState<T> {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                if_ok!(self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\",\n+                try!(self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\",\n                                         pth.display())));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                        if_ok!(self.write_plain(format!(\"with noise-tolerance \\\n+                        try!(self.write_plain(format!(\"with noise-tolerance \\\n                                                          forced to: {}%\\n\",\n                                                         pct)))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n-                if_ok!(self.write_metric_diff(&diff));\n+                try!(self.write_metric_diff(&diff));\n                 ok\n             }\n         };\n \n         let test_success = self.failed == 0u;\n         if !test_success {\n-            if_ok!(self.write_failures());\n+            try!(self.write_failures());\n         }\n \n         let success = ratchet_success && test_success;\n \n-        if_ok!(self.write_plain(\"\\ntest result: \"));\n+        try!(self.write_plain(\"\\ntest result: \"));\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n-            if_ok!(self.write_ok());\n+            try!(self.write_ok());\n         } else {\n-            if_ok!(self.write_failed());\n+            try!(self.write_failed());\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                         self.passed, self.failed, self.ignored, self.measured);\n-        if_ok!(self.write_plain(s));\n+        try!(self.write_plain(s));\n         return Ok(success);\n     }\n }\n@@ -678,8 +678,8 @@ pub fn run_tests_console(opts: &TestOpts,\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result, stdout) => {\n-                if_ok!(st.write_log(&test, &result));\n-                if_ok!(st.write_result(&result));\n+                try!(st.write_log(&test, &result));\n+                try!(st.write_result(&result));\n                 match result {\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n@@ -707,7 +707,7 @@ pub fn run_tests_console(opts: &TestOpts,\n             }\n         }\n     }\n-    let mut st = if_ok!(ConsoleTestState::new(opts, None::<StdWriter>));\n+    let mut st = try!(ConsoleTestState::new(opts, None::<StdWriter>));\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n             PadNone => 0u,\n@@ -722,12 +722,12 @@ pub fn run_tests_console(opts: &TestOpts,\n         },\n         None => {}\n     }\n-    if_ok!(run_tests(opts, tests, |x| callback(&x, &mut st)));\n+    try!(run_tests(opts, tests, |x| callback(&x, &mut st)));\n     match opts.save_metrics {\n         None => (),\n         Some(ref pth) => {\n-            if_ok!(st.metrics.save(pth));\n-            if_ok!(st.write_plain(format!(\"\\nmetrics saved to: {}\",\n+            try!(st.metrics.save(pth));\n+            try!(st.write_plain(format!(\"\\nmetrics saved to: {}\",\n                                           pth.display())));\n         }\n     }\n@@ -793,7 +793,7 @@ fn run_tests(opts: &TestOpts,\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n \n-    if_ok!(callback(TeFiltered(filtered_descs)));\n+    try!(callback(TeFiltered(filtered_descs)));\n \n     let (filtered_tests, filtered_benchs_and_metrics) =\n         filtered_tests.partition(|e| {\n@@ -821,27 +821,27 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                if_ok!(callback(TeWait(test.desc.clone(), test.testfn.padding())));\n+                try!(callback(TeWait(test.desc.clone(), test.testfn.padding())));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result, stdout) = p.recv();\n         if concurrency != 1 {\n-            if_ok!(callback(TeWait(desc.clone(), PadNone)));\n+            try!(callback(TeWait(desc.clone(), PadNone)));\n         }\n-        if_ok!(callback(TeResult(desc, result, stdout)));\n+        try!(callback(TeResult(desc, result, stdout)));\n         pending -= 1;\n     }\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n     for b in filtered_benchs_and_metrics.move_iter() {\n-        if_ok!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n+        try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result, stdout) = p.recv();\n-        if_ok!(callback(TeResult(test, result, stdout)));\n+        try!(callback(TeResult(test, result, stdout)));\n     }\n     Ok(())\n }\n@@ -1026,7 +1026,7 @@ impl MetricMap {\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) -> io::IoResult<()> {\n-        let mut file = if_ok!(File::create(p));\n+        let mut file = try!(File::create(p));\n         let MetricMap(ref map) = *self;\n         map.to_json().to_pretty_writer(&mut file)\n     }"}]}