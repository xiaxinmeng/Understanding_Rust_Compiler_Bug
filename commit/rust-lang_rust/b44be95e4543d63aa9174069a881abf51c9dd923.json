{"sha": "b44be95e4543d63aa9174069a881abf51c9dd923", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NGJlOTVlNDU0M2Q2M2FhOTE3NDA2OWE4ODFhYmY1MWM5ZGQ5MjM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-24T02:32:37Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-24T02:39:14Z"}, "message": "Support basic, unsophisticated, somewhat wrong export-globs.", "tree": {"sha": "fadbd7e458ce25c75fce9eee40d8f075eb5b5633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fadbd7e458ce25c75fce9eee40d8f075eb5b5633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b44be95e4543d63aa9174069a881abf51c9dd923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b44be95e4543d63aa9174069a881abf51c9dd923", "html_url": "https://github.com/rust-lang/rust/commit/b44be95e4543d63aa9174069a881abf51c9dd923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b44be95e4543d63aa9174069a881abf51c9dd923/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f4dcb0fa4099b60ae85ee1b977a253843fff595", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f4dcb0fa4099b60ae85ee1b977a253843fff595", "html_url": "https://github.com/rust-lang/rust/commit/5f4dcb0fa4099b60ae85ee1b977a253843fff595"}], "stats": {"total": 197, "additions": 145, "deletions": 52}, "files": [{"sha": "a35de9997f9bba89bcc7d38ae5476ad99b68cad2", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 145, "deletions": 50, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b44be95e4543d63aa9174069a881abf51c9dd923/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44be95e4543d63aa9174069a881abf51c9dd923/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=b44be95e4543d63aa9174069a881abf51c9dd923", "patch": "@@ -13,7 +13,7 @@ import std::map::{new_int_hash, new_str_hash};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n-import std::list;\n+import std::{list, deque};\n import std::map::hashmap;\n import std::list::{list, nil, cons};\n import option::{is_none, is_some};\n@@ -107,6 +107,7 @@ type indexed_mod = {\n     m: option<ast::_mod>,\n     index: mod_index,\n     mutable glob_imports: [glob_imp_def],\n+    mutable globbed_exports: [ident],\n     glob_imported_names: hashmap<str, glob_import_state>,\n     path: str\n };\n@@ -203,9 +204,9 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n       sess: sess}\n }\n \n-fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n+fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     alt vi.node {\n-      ast::view_item_import(vps) {\n+      ast::view_item_export(vps) {\n         for vp in vps {\n             f(vp);\n         }\n@@ -214,9 +215,9 @@ fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     }\n }\n \n-fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n+fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     alt vi.node {\n-      ast::view_item_export(vps) {\n+      ast::view_item_import(vps) {\n         for vp in vps {\n             f(vp);\n         }\n@@ -225,18 +226,29 @@ fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     }\n }\n \n-fn iter_all_view_paths(vi: ast::view_item,\n-                       f: fn(vp: @ast::view_path)) {\n+fn iter_effective_import_paths(vi: ast::view_item,\n+                               f: fn(vp: @ast::view_path)) {\n     iter_import_paths(vi, f);\n-    iter_export_paths(vi, f);\n+    iter_export_paths(vi) {|vp|\n+        alt vp.node {\n+          ast::view_path_simple(_, _, _) { }\n+          // FIXME: support uniform ident-list exports eventually;\n+          // at the moment they have half a meaning as reaching into\n+          // tags.\n+          ast::view_path_list(_, _, _) {}\n+          ast::view_path_glob(_,_) {\n+            f(vp);\n+          }\n+        }\n+    }\n }\n \n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n fn map_crate(e: @env, c: @ast::crate) {\n \n     fn index_vi(e: @env, i: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n-        iter_import_paths(*i) { |vp|\n+        iter_effective_import_paths(*i) { |vp|\n             alt vp.node {\n               ast::view_path_simple(name, path, id) {\n                 e.imports.insert(id, todo(id, name, path, vp.span, sc));\n@@ -275,6 +287,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                              @{m: some(md),\n                                index: index_mod(md),\n                                mutable glob_imports: [],\n+                               mutable globbed_exports: [],\n                                glob_imported_names: new_str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n           }\n@@ -283,6 +296,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n                                mutable glob_imports: [],\n+                               mutable globbed_exports: [],\n                                glob_imported_names: new_str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n           }\n@@ -295,7 +309,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n     // So we wind up reusing the glob-import machinery when looking at\n     // glob exports. They just do re-exporting in a later step.\n     fn link_glob(e: @env, vi: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n-        iter_all_view_paths(*vi) { |vp|\n+        iter_effective_import_paths(*vi) { |vp|\n             alt vp.node {\n               ast::view_path_glob(path, _) {\n                 alt follow_import(*e, sc, *path, vp.span) {\n@@ -341,6 +355,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: [],\n+                       mutable globbed_exports: [],\n                        glob_imported_names: new_str_hash(),\n                        path: \"\"});\n \n@@ -721,7 +736,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n         fn lst(my_id: node_id, vis: [@view_item]) -> [node_id] {\n             let imports = [], found = false;\n             for vi in vis {\n-                iter_import_paths(*vi) {|vp|\n+                iter_effective_import_paths(*vi) {|vp|\n                     alt vp.node {\n                       view_path_simple(_, _, id)\n                       | view_path_glob(_, id) {\n@@ -1201,6 +1216,7 @@ fn lookup_in_class(parent_id: def_id,\n \n fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                    loc_pos: uint, ns: namespace) -> option<def> {\n+\n     let i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n@@ -1251,7 +1267,9 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                   _ {\n                     if str::eq(it.ident, name) {\n                         let found = found_def_item(it, ns);\n-                        if !is_none(found) { ret found; }\n+                        if !is_none(found) {\n+                            ret found;\n+                        }\n                     }\n                   }\n                 }\n@@ -1262,13 +1280,20 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n         }\n     }\n     for vi in b.view_items {\n+\n+        let is_import = false;\n         alt vi.node {\n+          ast::view_item_import(_) { is_import = true; }\n+          _ {}\n+        }\n \n-          ast::view_item_import(vps) {\n+        alt vi.node {\n+\n+          ast::view_item_import(vps) | ast::view_item_export(vps) {\n             for vp in vps {\n                 alt vp.node {\n                   ast::view_path_simple(ident, _, id) {\n-                    if name == ident {\n+                    if is_import && name == ident {\n                         ret lookup_import(e, local_def(id), ns);\n                     }\n                   }\n@@ -1287,7 +1312,9 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                       some(globs) {\n                         let found = lookup_in_globs(e, globs, sp, name,\n                                                     ns, inside);\n-                        if found != none { ret found; }\n+                        if found != none {\n+                            ret found;\n+                        }\n                       }\n                       _ {}\n                     }\n@@ -1427,30 +1454,32 @@ fn lookup_in_local_native_mod(e: env, node_id: node_id, sp: span, id: ident,\n     ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n }\n \n-fn is_exported(e: env, i: ident, m: _mod) -> bool {\n-    ast_util::is_exported(i, m) || e.resolve_unexported\n+fn is_exported(e: env, i: ident, m: @indexed_mod) -> bool {\n+\n+    alt m.m {\n+      some(_m) {\n+        if ast_util::is_exported(i, _m) { ret true; }\n+      }\n+      _ {}\n+    }\n+\n+    ret vec::contains(m.globbed_exports, i)\n+        || e.resolve_unexported;\n }\n \n fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n                        ns: namespace, dr: dir) -> option<def> {\n     let info = e.mod_map.get(node_id);\n-    if dr == outside && !is_exported(e, id, option::get(info.m)) {\n+    if dr == outside && !is_exported(e, id, info) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n         ret none; // name is not visible\n     }\n     alt info.index.find(id) {\n       none { }\n-      some(lst_) {\n-        let lst = lst_;\n-        while true {\n-            alt lst {\n-              nil { break; }\n-              cons(hd, tl) {\n-                let found = lookup_in_mie(e, hd, ns);\n-                if !is_none(found) { ret found; }\n-                lst = *tl;\n-              }\n-            }\n+      some(lst) {\n+        let found = list::find(lst, bind lookup_in_mie(e, _, ns));\n+        if !is_none(found) {\n+            ret found;\n         }\n       }\n     }\n@@ -1590,7 +1619,7 @@ fn index_view_items(view_items: [@ast::view_item],\n           _ {}\n         }\n \n-        iter_import_paths(*vi) {|vp|\n+        iter_effective_import_paths(*vi) {|vp|\n             alt vp.node {\n               ast::view_path_simple(ident, _, id) {\n                 add_to_index(index, ident, mie_import_ident(id, vp.span));\n@@ -1931,6 +1960,49 @@ fn ensure_unique<T>(e: env, sp: span, elts: [T], id: fn(T) -> ident,\n }\n \n fn check_exports(e: @env) {\n+\n+    fn iter_mod(e: env, m: def, sp: span, _dr: dir,\n+                f: fn(ident: ident, def: def)) {\n+        let defid = def_id_of_def(m);\n+\n+        if defid.crate != ast::local_crate {\n+            // FIXME: ought to support external export-globs eventually.\n+            e.sess.span_unimpl(sp, \"glob-export of items in external crate\");\n+        } else {\n+\n+            let mid = def_id_of_def(m);\n+            assert mid.crate == ast::local_crate;\n+            let ixm = e.mod_map.get(mid.node);\n+\n+            ixm.index.items() {|ident, mies|\n+                list::iter(mies) {|mie|\n+                    alt mie {\n+                      mie_item(item) {\n+                        let defs =\n+                            [ found_def_item(item, ns_val(value_or_enum)),\n+                             found_def_item(item, ns_type),\n+                             found_def_item(item, ns_module) ];\n+                        for d in defs {\n+                            alt d {\n+                              some(def) {\n+                                f(ident, def);\n+                              }\n+                              _ {}\n+                            }\n+                        }\n+                      }\n+                      _ {\n+                        let s = \"glob-export from mod with non-items\";\n+                        e.sess.span_unimpl(sp, s);\n+                      }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n     fn lookup_glob_any(e: @env, info: @indexed_mod, sp: span, path: str,\n                        ident: ident) -> bool {\n         let lookup =\n@@ -1957,13 +2029,13 @@ fn check_exports(e: @env) {\n         }\n     }\n \n-    fn check_export(e: @env, ident: str, val: @indexed_mod,\n+    fn check_export(e: @env, ident: str, _mod: @indexed_mod,\n                     vi: @view_item) {\n         let found_something = false;\n-        let full_path = val.path + ident;\n-        if val.index.contains_key(ident) {\n+        let full_path = _mod.path + ident;\n+        if _mod.index.contains_key(ident) {\n             found_something = true;\n-            let xs = val.index.get(ident);\n+            let xs = _mod.index.get(ident);\n             list::iter(xs) {|x|\n                 alt x {\n                   mie_import_ident(id, _) {\n@@ -1980,16 +2052,17 @@ fn check_exports(e: @env) {\n                 }\n             }\n         }\n-        found_something |= lookup_glob_any(e, val, vi.span, val.path, ident);\n+        found_something |= lookup_glob_any(e, _mod, vi.span,\n+                                           _mod.path, ident);\n         if !found_something {\n             e.sess.span_warn(vi.span,\n                              #fmt(\"exported item %s is not defined\", ident));\n         }\n     }\n \n-    fn check_enum_ok(e: @env, sp:span, id: ident, val: @indexed_mod)\n+    fn check_enum_ok(e: @env, sp:span, id: ident, _mod: @indexed_mod)\n         -> node_id {\n-        alt val.index.find(id) {\n+        alt _mod.index.find(id) {\n            none { e.sess.span_fatal(sp, #fmt(\"error: undefined id %s \\\n                          in an export\", id)); }\n            some(ms) {\n@@ -2013,15 +2086,15 @@ fn check_exports(e: @env) {\n       }\n     }\n \n-    fn check_export_enum_list(e: @env, val: @indexed_mod,\n+    fn check_export_enum_list(e: @env, _mod: @indexed_mod,\n                               span: codemap::span, id: ast::ident,\n                               ids: [ast::path_list_ident]) {\n         if vec::len(ids) == 0u {\n-            let _ = check_enum_ok(e, span, id, val);\n+            let _ = check_enum_ok(e, span, id, _mod);\n         } else {\n-            let parent_id = check_enum_ok(e, span, id, val);\n+            let parent_id = check_enum_ok(e, span, id, _mod);\n             for variant_id in ids {\n-                alt val.index.find(variant_id.node.name) {\n+                alt _mod.index.find(variant_id.node.name) {\n                   some(ms) {\n                     list::iter(ms) {|m|\n                         alt m {\n@@ -2052,14 +2125,16 @@ fn check_exports(e: @env) {\n         }\n     }\n \n-    e.mod_map.values {|val|\n-        alt val.m {\n+    e.mod_map.values {|_mod|\n+        alt _mod.m {\n           some(m) {\n+            let glob_is_re_exported = new_int_hash();\n+\n             for vi in m.view_items {\n                 iter_export_paths(*vi) { |vp|\n                     alt vp.node {\n                       ast::view_path_simple(ident, _, _) {\n-                        check_export(e, ident, val, vi);\n+                        check_export(e, ident, _mod, vi);\n                       }\n                       ast::view_path_list(path, ids, _) {\n                         let id = if vec::len(*path) == 1u {\n@@ -2068,10 +2143,29 @@ fn check_exports(e: @env) {\n                             e.sess.span_fatal(vp.span,\n                                             #fmt(\"bad export name-list\"))\n                         };\n-                        check_export_enum_list(e, val, vp.span, id, ids);\n+                        check_export_enum_list(e, _mod, vp.span, id, ids);\n                       }\n-                      _ {}\n+                      ast::view_path_glob(_, node_id) {\n+                        glob_is_re_exported.insert(node_id, ());\n+                      }\n+                    }\n+                }\n+            }\n+            // Now follow the export-glob links and fill in the\n+            // globbed_exports and exp_map lists.\n+            for glob in _mod.glob_imports {\n+                alt check glob.path.node {\n+                  ast::view_path_glob(path, node_id) {\n+                    if ! glob_is_re_exported.contains_key(node_id) {\n+                        cont;\n                     }\n+                  }\n+                }\n+                iter_mod(*e, glob.def,\n+                         glob.path.span, outside) {|ident, def|\n+                    let full_path = _mod.path + ident;\n+                    _mod.globbed_exports += [ident];\n+                    maybe_add_reexport(e, full_path, some(def));\n                 }\n             }\n           }\n@@ -2112,7 +2206,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n         }\n     }\n \n-    iter_import_paths(*vi) { |vp|\n+    iter_effective_import_paths(*vi) { |vp|\n         alt vp.node {\n           ast::view_path_simple(name, pt, id) {\n             let found = [];\n@@ -2157,7 +2251,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n \n fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                       name: option<ident>,\n-                      ck_exports: option<ast::_mod>) {\n+                      ck_exports: option<@indexed_mod>) {\n     alt i.node {\n       ast::item_impl(_, ifce, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n@@ -2188,14 +2282,15 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n         e.impl_cache.insert(defid, none);\n         cached = if defid.crate == ast::local_crate {\n             let tmp = [];\n-            let md = option::get(e.mod_map.get(defid.node).m);\n+            let mi = e.mod_map.get(defid.node);\n+            let md = option::get(mi.m);\n             for vi in md.view_items {\n                 find_impls_in_view_item(e, vi, tmp, none);\n             }\n             for i in md.items {\n                 find_impls_in_item(e, i, tmp, none, none);\n             }\n-            @vec::filter(tmp) {|i| is_exported(e, i.ident, md)}\n+            @vec::filter(tmp) {|i| is_exported(e, i.ident, mi)}\n         } else {\n             csearch::get_impls_for_mod(e.sess.cstore, defid, none)\n         };"}, {"sha": "20c117f5914b86d7877543696c02e3b1ef496d3e", "filename": "src/test/run-pass/export-glob.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44be95e4543d63aa9174069a881abf51c9dd923/src%2Ftest%2Frun-pass%2Fexport-glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44be95e4543d63aa9174069a881abf51c9dd923/src%2Ftest%2Frun-pass%2Fexport-glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-glob.rs?ref=b44be95e4543d63aa9174069a881abf51c9dd923", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-\n // Test that a glob-export functions as an explicit\n // named export when referenced from outside its scope.\n "}]}