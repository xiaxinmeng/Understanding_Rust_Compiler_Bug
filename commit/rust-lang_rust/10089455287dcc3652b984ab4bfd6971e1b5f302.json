{"sha": "10089455287dcc3652b984ab4bfd6971e1b5f302", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMDg5NDU1Mjg3ZGNjMzY1MmI5ODRhYjRiZmQ2OTcxZTFiNWYzMDI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-03T16:45:23Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-04T02:48:02Z"}, "message": "remove obsolete `foreach` keyword\n\nthis has been replaced by `for`", "tree": {"sha": "a9570eacf4ff89a1f14b7380c080af77918589f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9570eacf4ff89a1f14b7380c080af77918589f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10089455287dcc3652b984ab4bfd6971e1b5f302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10089455287dcc3652b984ab4bfd6971e1b5f302", "html_url": "https://github.com/rust-lang/rust/commit/10089455287dcc3652b984ab4bfd6971e1b5f302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10089455287dcc3652b984ab4bfd6971e1b5f302/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f74217d80290d1cb36afcaf68a566b4b4907d27", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f74217d80290d1cb36afcaf68a566b4b4907d27", "html_url": "https://github.com/rust-lang/rust/commit/9f74217d80290d1cb36afcaf68a566b4b4907d27"}], "stats": {"total": 3143, "additions": 1569, "deletions": 1574}, "files": [{"sha": "20ebb88c72434b053427a7d71d447ba995a6cc7a", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -1792,11 +1792,11 @@ msgstr \"\"\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n \"fn iter<T>(seq: &[T], f: &fn(T)) {\\n\"\n-\"    foreach elt in seq.iter() { f(elt); }\\n\"\n+\"    for elt in seq.iter() { f(elt); }\\n\"\n \"}\\n\"\n \"fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\\n\"\n \"    let mut acc = ~[];\\n\"\n-\"    foreach elt in seq.iter() { acc.push(f(elt)); }\\n\"\n+\"    for elt in seq.iter() { acc.push(f(elt)); }\\n\"\n \"    acc\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n@@ -4570,7 +4570,7 @@ msgstr \"\"\n #: doc/rust.md:2405\n #, no-wrap\n msgid \"\"\n-\"foreach e in v.iter() {\\n\"\n+\"for e in v.iter() {\\n\"\n \"    bar(*e);\\n\"\n \"}\\n\"\n \"~~~~\\n\""}, {"sha": "3435a51dbeff15a5d93247a3a3161f58b11b0a65", "filename": "doc/po/tutorial-container.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Ftutorial-container.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Ftutorial-container.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-container.md.pot?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -376,7 +376,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// print out all the elements in the vector\\n\"\n-\"foreach x in xs.iter() {\\n\"\n+\"for x in xs.iter() {\\n\"\n \"    println(x.to_str())\\n\"\n \"}\\n\"\n msgstr \"\"\n@@ -386,7 +386,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// print out all but the first 3 elements in the vector\\n\"\n-\"foreach x in xs.iter().skip(3) {\\n\"\n+\"for x in xs.iter().skip(3) {\\n\"\n \"    println(x.to_str())\\n\"\n \"}\\n\"\n \"~~~\\n\"\n@@ -418,7 +418,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// print out the pairs of elements up to (&3, &\\\"baz\\\")\\n\"\n-\"foreach (x, y) in it {\\n\"\n+\"for (x, y) in it {\\n\"\n \"    println(fmt!(\\\"%d %s\\\", *x, *y));\\n\"\n msgstr \"\"\n \n@@ -487,7 +487,7 @@ msgid \"\"\n \"    pub fn from_iterator(iterator: &mut T) -> ~[A] {\\n\"\n \"        let (lower, _) = iterator.size_hint();\\n\"\n \"        let mut xs = with_capacity(lower);\\n\"\n-\"        foreach x in iterator {\\n\"\n+\"        for x in iterator {\\n\"\n \"            xs.push(x);\\n\"\n \"        }\\n\"\n \"        xs\\n\"\n@@ -587,7 +587,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"// prints `5`, `4` and `3`\\n\"\n-\"foreach &x in it.invert() {\\n\"\n+\"for &x in it.invert() {\\n\"\n \"    println(fmt!(\\\"%?\\\", x))\\n\"\n \"}\\n\"\n \"~~~\\n\""}, {"sha": "ff1f25f83b32576f9c7f0621f872ec782e0bfa55", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -587,7 +587,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"    let mut final_res = 0f64;\\n\"\n-\"    foreach ft in futures.mut_iter()  {\\n\"\n+\"    for ft in futures.mut_iter()  {\\n\"\n \"        final_res += ft.get();\\n\"\n \"    }\\n\"\n \"    println(fmt!(\\\"^2/6 is not far from : %?\\\", final_res));\\n\""}, {"sha": "5d8a03343ae33ebcb4cb3a695557f3a2581cc533", "filename": "doc/po/tutorial.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Ftutorial.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Fpo%2Ftutorial.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial.md.pot?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -2501,7 +2501,7 @@ msgstr \"\"\n msgid \"\"\n \"// Iterate over a vector, obtaining a pointer to each element\\n\"\n \"// (`for` is explained in the next section)\\n\"\n-\"foreach crayon in crayons.iter() {\\n\"\n+\"for crayon in crayons.iter() {\\n\"\n \"    let delicious_crayon_wax = unwrap_crayon(*crayon);\\n\"\n \"    eat_crayon_wax(delicious_crayon_wax);\\n\"\n \"}\\n\"\n@@ -3101,7 +3101,7 @@ msgid \"\"\n \"~~~~\\n\"\n \"fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\\n\"\n \"    let mut accumulator = ~[];\\n\"\n-\"    foreach element in vector.iter() {\\n\"\n+\"    for element in vector.iter() {\\n\"\n \"        accumulator.push(function(element));\\n\"\n \"    }\\n\"\n \"    return accumulator;\\n\"\n@@ -3570,7 +3570,7 @@ msgid \"\"\n \"~~~~\\n\"\n \"# trait Printable { fn print(&self); }\\n\"\n \"fn print_all<T: Printable>(printable_things: ~[T]) {\\n\"\n-\"    foreach thing in printable_things.iter() {\\n\"\n+\"    for thing in printable_things.iter() {\\n\"\n \"        thing.print();\\n\"\n \"    }\\n\"\n \"}\\n\"\n@@ -3650,7 +3650,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"fn draw_all<T: Drawable>(shapes: ~[T]) {\\n\"\n-\"    foreach shape in shapes.iter() { shape.draw(); }\\n\"\n+\"    for shape in shapes.iter() { shape.draw(); }\\n\"\n \"}\\n\"\n \"# let c: Circle = new_circle();\\n\"\n \"# draw_all(~[c]);\\n\"\n@@ -3673,7 +3673,7 @@ msgid \"\"\n \"~~~~\\n\"\n \"# trait Drawable { fn draw(&self); }\\n\"\n \"fn draw_all(shapes: &[@Drawable]) {\\n\"\n-\"    foreach shape in shapes.iter() { shape.draw(); }\\n\"\n+\"    for shape in shapes.iter() { shape.draw(); }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\""}, {"sha": "2f5c310ec8328adec207bd7b0b87f2106e14c780", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -880,11 +880,11 @@ the function name.\n \n ~~~~ {.xfail-test}\n fn iter<T>(seq: &[T], f: &fn(T)) {\n-    foreach elt in seq.iter() { f(elt); }\n+    for elt in seq.iter() { f(elt); }\n }\n fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    foreach elt in seq.iter() { acc.push(f(elt)); }\n+    for elt in seq.iter() { acc.push(f(elt)); }\n     acc\n }\n ~~~~\n@@ -2378,7 +2378,7 @@ An example of a for loop over the contents of a vector:\n \n let v: &[foo] = &[a, b, c];\n \n-foreach e in v.iter() {\n+for e in v.iter() {\n     bar(*e);\n }\n ~~~~\n@@ -2387,7 +2387,7 @@ An example of a for loop over a series of integers:\n \n ~~~~\n # fn bar(b:uint) { }\n-foreach i in range(0u, 256) {\n+for i in range(0u, 256) {\n     bar(i);\n }\n ~~~~"}, {"sha": "b2ef624d1ac3e6b1c90cb17a3c9dbfecfafe7637", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -121,7 +121,7 @@ should interleave the output in vaguely random order.\n # use std::io::print;\n # use std::task::spawn;\n \n-foreach child_task_number in range(0, 20) {\n+for child_task_number in range(0, 20) {\n     do spawn {\n        print(fmt!(\"I am child number %d\\n\", child_task_number));\n     }\n@@ -240,7 +240,7 @@ Instead we can use a `SharedChan`, a type that allows a single\n let (port, chan) = stream();\n let chan = SharedChan::new(chan);\n \n-foreach init_val in range(0u, 3) {\n+for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n     let child_chan = chan.clone();\n     do spawn {\n@@ -314,7 +314,7 @@ be distributed on the available cores.\n # use std::vec;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n-    foreach num in range(start*100000, (start+1)*100000) {\n+    for num in range(start*100000, (start+1)*100000) {\n         local_sum += (num as f64 + 1.0).pow(&-2.0);\n     }\n     local_sum\n@@ -324,7 +324,7 @@ fn main() {\n     let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\n \n     let mut final_res = 0f64;\n-    foreach ft in futures.mut_iter()  {\n+    for ft in futures.mut_iter()  {\n         final_res += ft.get();\n     }\n     println(fmt!(\"\u03c0^2/6 is not far from : %?\", final_res));\n@@ -359,7 +359,7 @@ fn main() {\n \n     let numbers_arc = Arc::new(numbers);\n \n-    foreach num in range(1u, 10) {\n+    for num in range(1u, 10) {\n         let (port, chan)  = stream();\n         chan.send(numbers_arc.clone());\n "}, {"sha": "b01de242590d0e9e580343d6c39d391c2055c271", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -243,7 +243,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n            config.src_base.to_str());\n     let mut tests = ~[];\n     let dirs = os::list_dir_path(&config.src_base);\n-    foreach file in dirs.iter() {\n+    for file in dirs.iter() {\n         let file = file.clone();\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, &file) {\n@@ -271,11 +271,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n \n     let mut valid = false;\n \n-    foreach ext in valid_extensions.iter() {\n+    for ext in valid_extensions.iter() {\n         if name.ends_with(*ext) { valid = true; }\n     }\n \n-    foreach pre in invalid_prefixes.iter() {\n+    for pre in invalid_prefixes.iter() {\n         if name.starts_with(*pre) { valid = false; }\n     }\n "}, {"sha": "a5d308007b48a3db5dc8042e5de20b32b06396c7", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -56,7 +56,7 @@ pub fn run(lib_path: &str,\n         err_fd: None\n     });\n \n-    foreach input in input.iter() {\n+    for input in input.iter() {\n         proc.input().write_str(*input);\n     }\n     let output = proc.finish_with_output();"}, {"sha": "74b4a1de5e0d13aecca9d2a0ea4c8261d050d6d0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -282,7 +282,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        foreach line in ProcRes.stdout.line_iter() {\n+        for line in ProcRes.stdout.line_iter() {\n             if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -312,7 +312,7 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    foreach line in ProcRes.stderr.line_iter() {\n+    for line in ProcRes.stderr.line_iter() {\n         if line.contains(*next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n@@ -332,7 +332,7 @@ fn check_error_patterns(props: &TestProps,\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);\n     } else {\n-        foreach pattern in missing_patterns.iter() {\n+        for pattern in missing_patterns.iter() {\n             error(fmt!(\"error pattern '%s' not found!\", *pattern));\n         }\n         fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n@@ -385,9 +385,9 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    foreach line in ProcRes.stderr.line_iter() {\n+    for line in ProcRes.stderr.line_iter() {\n         let mut was_expected = false;\n-        foreach (i, ee) in expected_errors.iter().enumerate() {\n+        for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n@@ -413,7 +413,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n     }\n \n-    foreach i in range(0u, found_flags.len()) {\n+    for i in range(0u, found_flags.len()) {\n         if !found_flags[i] {\n             let ee = &expected_errors[i];\n             fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n@@ -558,7 +558,7 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\",\n                             aux_output_dir_name(config, testfile).to_str()];\n \n-    foreach rel_ab in props.aux_builds.iter() {\n+    for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n@@ -785,7 +785,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs.push(fmt!(\"%s\", config.adb_test_dir));\n     runargs.push(fmt!(\"%s\", prog_short));\n \n-    foreach tv in args.args.iter() {\n+    for tv in args.args.iter() {\n         runargs.push(tv.to_owned());\n     }\n \n@@ -802,7 +802,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n                      Some(~\"\"));\n \n     let mut exitcode : int = 0;\n-    foreach c in exitcode_out.iter() {\n+    for c in exitcode_out.iter() {\n         if !c.is_digit() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' .. '9' => c as int - ('0' as int),\n@@ -851,7 +851,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tstr = aux_output_dir_name(config, testfile).to_str();\n \n     let dirs = os::list_dir_path(&Path(tstr));\n-    foreach file in dirs.iter() {\n+    for file in dirs.iter() {\n \n         if (file.filetype() == Some(~\".so\")) {\n "}, {"sha": "3507e6ff788e1dd36fa75d196850dd4fba921e46", "filename": "src/etc/check-links.pl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fetc%2Fcheck-links.pl", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Fetc%2Fcheck-links.pl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-links.pl?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -7,15 +7,15 @@\n my $anchors = {};\n \n my $i = 0;\n-foreach $line (@lines) {\n+for $line (@lines) {\n     $i++;\n     if ($line =~ m/id=\"([^\"]+)\"/) {\n         $anchors->{$1} = $i;\n     }\n }\n \n $i = 0;\n-foreach $line (@lines) {\n+for $line (@lines) {\n     $i++;\n     while ($line =~ m/href=\"#([^\"]+)\"/g) {\n         if (! exists($anchors->{$1})) {"}, {"sha": "cb4468f48ecb1473b65c3805ff15e22a2581c69f", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -782,7 +782,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        foreach r in children.iter() {\n+        for r in children.iter() {\n             r.recv();\n         }\n \n@@ -848,7 +848,7 @@ mod tests {\n                 *state = 31337;\n                 // FIXME: #7372: hits type inference bug with iterators\n                 // send to other readers\n-                foreach i in range(0u, reader_convos.len()) {\n+                for i in range(0u, reader_convos.len()) {\n                     match reader_convos[i] {\n                         (ref rc, _) => rc.send(()),\n                     }\n@@ -858,7 +858,7 @@ mod tests {\n             do (&read_mode).read |state| {\n                 // FIXME: #7372: hits type inference bug with iterators\n                 // complete handshake with other readers\n-                foreach i in range(0u, reader_convos.len()) {\n+                for i in range(0u, reader_convos.len()) {\n                     match reader_convos[i] {\n                         (_, ref rp) => rp.recv(),\n                     }"}, {"sha": "47b64d76951683087cd3e91666c78e4b8821477d", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -277,7 +277,7 @@ impl Arena {\n #[test]\n fn test_arena_destructors() {\n     let arena = Arena();\n-    foreach i in range(0u, 10) {\n+    for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n         do arena.alloc { @i };\n@@ -293,7 +293,7 @@ fn test_arena_destructors() {\n fn test_arena_destructors_fail() {\n     let arena = Arena();\n     // Put some stuff in the arena.\n-    foreach i in range(0u, 10) {\n+    for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n         do arena.alloc { @i };"}, {"sha": "f2cbcf86935e7256c99a33cc095bbcaa16843cb6", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -206,7 +206,7 @@ impl<'self> FromBase64 for &'self [u8] {\n         let mut modulus = 0;\n \n         let mut it = self.iter();\n-        foreach &byte in it {\n+        for &byte in it {\n             let ch = byte as char;\n             let val = byte as u32;\n "}, {"sha": "bf618d7bd3a6ff1065f5e28c138beca29c7d0cde", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -145,7 +145,7 @@ impl BigBitv {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n-        foreach i in range(0, len) {\n+        for i in range(0, len) {\n             let mask = big_mask(nbits, i);\n             let w0 = self.storage[i] & mask;\n             let w1 = b.storage[i] & mask;\n@@ -401,7 +401,7 @@ impl Bitv {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n-          foreach i in self.iter() { if !i { return false; } }\n+          for i in self.iter() { if !i { return false; } }\n           true\n         }\n       }\n@@ -422,7 +422,7 @@ impl Bitv {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n-          foreach i in self.iter() { if i { return false; } }\n+          for i in self.iter() { if i { return false; } }\n           true\n         }\n       }\n@@ -486,7 +486,7 @@ impl Bitv {\n      */\n      pub fn to_str(&self) -> ~str {\n         let mut rs = ~\"\";\n-        foreach i in self.iter() {\n+        for i in self.iter() {\n             if i {\n                 rs.push_char('1');\n             } else {\n@@ -544,7 +544,7 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  */\n pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n-    foreach i in range(0u, len) {\n+    for i in range(0u, len) {\n         bitv.set(i, f(i));\n     }\n     bitv\n@@ -561,7 +561,7 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n-    foreach i in range(0u, uint::bits) {\n+    for i in range(0u, uint::bits) {\n         if bits & (1 << i) != 0 {\n             if !f(base + i) {\n                 return false;\n@@ -676,7 +676,7 @@ impl BitvSet {\n     fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n-            foreach _ in range(0u, uint::bits) {\n+            for _ in range(0u, uint::bits) {\n                 if w == 0 {\n                     break;\n                 }\n@@ -688,7 +688,7 @@ impl BitvSet {\n         if self.capacity() < other.capacity() {\n             self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n         }\n-        foreach (i, &w) in other.bitv.storage.iter().enumerate() {\n+        for (i, &w) in other.bitv.storage.iter().enumerate() {\n             let old = self.bitv.storage[i];\n             let new = f(old, w);\n             self.bitv.storage[i] = new;\n@@ -721,7 +721,7 @@ impl BitvSet {\n     }\n \n     pub fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        foreach (i, w1, w2) in self.common_iter(other) {\n+        for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return false\n             }\n@@ -734,7 +734,7 @@ impl BitvSet {\n \n     pub fn symmetric_difference(&self, other: &BitvSet,\n                             f: &fn(&uint) -> bool) -> bool {\n-        foreach (i, w1, w2) in self.common_iter(other) {\n+        for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return false\n             }\n@@ -747,7 +747,7 @@ impl BitvSet {\n     }\n \n     pub fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        foreach (i, w1, w2) in self.common_iter(other) {\n+        for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return false\n             }\n@@ -761,12 +761,12 @@ impl cmp::Eq for BitvSet {\n         if self.size != other.size {\n             return false;\n         }\n-        foreach (_, w1, w2) in self.common_iter(other) {\n+        for (_, w1, w2) in self.common_iter(other) {\n             if w1 != w2 {\n                 return false;\n             }\n         }\n-        foreach (_, _, w) in self.outlier_iter(other) {\n+        for (_, _, w) in self.outlier_iter(other) {\n             if w != 0 {\n                 return false;\n             }\n@@ -801,15 +801,15 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        foreach (_, w1, w2) in self.common_iter(other) {\n+        for (_, w1, w2) in self.common_iter(other) {\n             if w1 & w2 != w1 {\n                 return false;\n             }\n         }\n         /* If anything is not ours, then everything is not ours so we're\n            definitely a subset in that case. Otherwise if there's any stray\n            ones that 'other' doesn't have, we're not a subset. */\n-        foreach (mine, _, w) in self.outlier_iter(other) {\n+        for (mine, _, w) in self.outlier_iter(other) {\n             if !mine {\n                 return true;\n             } else if w != 0 {\n@@ -1285,12 +1285,12 @@ mod tests {\n     #[test]\n     fn test_equal_sneaky_big() {\n         let mut a = bitv::Bitv::new(100, false);\n-        foreach i in range(0u, 100) {\n+        for i in range(0u, 100) {\n             a.set(i, true);\n         }\n \n         let mut b = bitv::Bitv::new(100, true);\n-        foreach i in range(0u, 100) {\n+        for i in range(0u, 100) {\n             b.set(i, true);\n         }\n \n@@ -1333,7 +1333,7 @@ mod tests {\n         let bools = [true, false, true, true];\n         let bitv = from_bools(bools);\n \n-        foreach (act, &ex) in bitv.iter().zip(bools.iter()) {\n+        for (act, &ex) in bitv.iter().zip(bools.iter()) {\n             assert_eq!(ex, act);\n         }\n     }\n@@ -1639,7 +1639,7 @@ mod tests {\n         let bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n             let mut _sum = 0;\n-            foreach pres in bitv.iter() {\n+            for pres in bitv.iter() {\n                 _sum += pres as uint;\n             }\n         }\n@@ -1650,7 +1650,7 @@ mod tests {\n         let bitv = Bitv::new(BENCH_BITS, false);\n         do b.iter {\n             let mut _sum = 0;\n-            foreach pres in bitv.iter() {\n+            for pres in bitv.iter() {\n                 _sum += pres as uint;\n             }\n         }\n@@ -1662,7 +1662,7 @@ mod tests {\n                                               |idx| {idx % 3 == 0}));\n         do b.iter {\n             let mut _sum = 0;\n-            foreach idx in bitv.iter() {\n+            for idx in bitv.iter() {\n                 _sum += idx;\n             }\n         }"}, {"sha": "623a9d5f452358cb7930883470c6b942d00489dc", "filename": "src/libextra/container.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -53,7 +53,7 @@ mod bench {\n         let mut rng = rand::XorShiftRng::new();\n \n         map.clear();\n-        foreach _ in range(0, n) {\n+        for _ in range(0, n) {\n             map.insert(rng.gen::<uint>() % n, 1);\n         }\n \n@@ -70,7 +70,7 @@ mod bench {\n                                                  bh: &mut BenchHarness) {\n         // setup\n         map.clear();\n-        foreach i in range(0u, n) {\n+        for i in range(0u, n) {\n             map.insert(i*2, 1);\n         }\n \n@@ -90,7 +90,7 @@ mod bench {\n         let mut rng = rand::XorShiftRng::new();\n         let mut keys = vec::from_fn(n, |_| rng.gen::<uint>() % n);\n \n-        foreach k in keys.iter() {\n+        for k in keys.iter() {\n             map.insert(*k, 1);\n         }\n \n@@ -108,7 +108,7 @@ mod bench {\n                                                map: &mut M,\n                                                bh: &mut BenchHarness) {\n         // setup\n-        foreach i in range(0u, n) {\n+        for i in range(0u, n) {\n             map.insert(i, 1);\n         }\n "}, {"sha": "217f5b0a4175e2f903f8772504b3f68cef36489e", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -70,7 +70,7 @@ pub trait Digest {\n \n fn to_hex(rr: &[u8]) -> ~str {\n     let mut s = ~\"\";\n-    foreach b in rr.iter() {\n+    for b in rr.iter() {\n         let hex = uint::to_str_radix(*b as uint, 16u);\n         if hex.len() == 1 {\n             s.push_char('0');"}, {"sha": "aa52902c27d11ea28dc4ab2a8ed63f2fbca32b19", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -250,7 +250,7 @@ mod tests {\n         let mut out = [0u8, ..20];\n \n         let mut sh = ~Sha1::new();\n-        foreach t in tests.iter() {\n+        for t in tests.iter() {\n             (*sh).input_str(t.input);\n             sh.result(out);\n             assert!(t.output.as_slice() == out);\n@@ -264,7 +264,7 @@ mod tests {\n \n \n         // Test that it works when accepting the message in pieces\n-        foreach t in tests.iter() {\n+        for t in tests.iter() {\n             let len = t.input.len();\n             let mut left = len;\n             while left > 0u {"}, {"sha": "47535d5103ab113946adb4fd76df84da91373516", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -736,7 +736,7 @@ mod tests {\n \n     fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n         // Test that it works when accepting the message all at once\n-        foreach t in tests.iter() {\n+        for t in tests.iter() {\n             sh.input_str(t.input);\n \n             let out_str = sh.result_str();\n@@ -746,7 +746,7 @@ mod tests {\n         }\n \n         // Test that it works when accepting the message in pieces\n-        foreach t in tests.iter() {\n+        for t in tests.iter() {\n             let len = t.input.len();\n             let mut left = len;\n             while left > 0u {"}, {"sha": "4142bdadaf63e87b2f224909fd58b9d0af839e4c", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -548,7 +548,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for DList<A> {\n \n impl<A, T: Iterator<A>> Extendable<A, T> for DList<A> {\n     fn extend(&mut self, iterator: &mut T) {\n-        foreach elt in *iterator { self.push_back(elt); }\n+        for elt in *iterator { self.push_back(elt); }\n     }\n }\n \n@@ -687,7 +687,7 @@ mod tests {\n         check_links(&m);\n         let sum = v + u;\n         assert_eq!(sum.len(), m.len());\n-        foreach elt in sum.consume_iter() {\n+        for elt in sum.consume_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -711,7 +711,7 @@ mod tests {\n         check_links(&m);\n         let sum = u + v;\n         assert_eq!(sum.len(), m.len());\n-        foreach elt in sum.consume_iter() {\n+        for elt in sum.consume_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -742,7 +742,7 @@ mod tests {\n     #[test]\n     fn test_iterator() {\n         let m = generate_test();\n-        foreach (i, elt) in m.iter().enumerate() {\n+        for (i, elt) in m.iter().enumerate() {\n             assert_eq!(i as int, *elt);\n         }\n         let mut n = DList::new();\n@@ -790,7 +790,7 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let m = generate_test();\n-        foreach (i, elt) in m.rev_iter().enumerate() {\n+        for (i, elt) in m.rev_iter().enumerate() {\n             assert_eq!((6 - i) as int, *elt);\n         }\n         let mut n = DList::new();\n@@ -807,7 +807,7 @@ mod tests {\n     fn test_mut_iter() {\n         let mut m = generate_test();\n         let mut len = m.len();\n-        foreach (i, elt) in m.mut_iter().enumerate() {\n+        for (i, elt) in m.mut_iter().enumerate() {\n             assert_eq!(i as int, *elt);\n             len -= 1;\n         }\n@@ -899,7 +899,7 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n-        foreach (i, elt) in m.mut_rev_iter().enumerate() {\n+        for (i, elt) in m.mut_rev_iter().enumerate() {\n             assert_eq!((6-i) as int, *elt);\n         }\n         let mut n = DList::new();\n@@ -943,7 +943,7 @@ mod tests {\n     fn fuzz_test(sz: int) {\n         let mut m = DList::new::<int>();\n         let mut v = ~[];\n-        foreach i in range(0, sz) {\n+        for i in range(0, sz) {\n             check_links(&m);\n             let r: u8 = rand::random();\n             match r % 6 {\n@@ -969,7 +969,7 @@ mod tests {\n         check_links(&m);\n \n         let mut i = 0u;\n-        foreach (a, &b) in m.consume_iter().zip(v.iter()) {\n+        for (a, &b) in m.consume_iter().zip(v.iter()) {\n             i += 1;\n             assert_eq!(a, b);\n         }"}, {"sha": "a161989c3751623b1ddd5ea982130c7ae9c20f01", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -419,7 +419,7 @@ mod test {\n     fn make_file(path : &Path, contents: &[~str]) {\n         let file = io::file_writer(path, [io::Create, io::Truncate]).unwrap();\n \n-        foreach str in contents.iter() {\n+        for str in contents.iter() {\n             file.write_str(*str);\n             file.write_char('\\n');\n         }\n@@ -446,13 +446,13 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        foreach (i, filename) in filenames.iter().enumerate() {\n+        for (i, filename) in filenames.iter().enumerate() {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames.clone());\n \n-        foreach (line, c) in \"012\".iter().enumerate() {\n+        for (line, c) in \"012\".iter().enumerate() {\n             assert_eq!(fi.read_byte(), c as int);\n             assert_eq!(fi.state().line_num, line);\n             assert_eq!(fi.state().line_num_file, 0);\n@@ -476,7 +476,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        foreach (i, filename) in filenames.iter().enumerate() {\n+        for (i, filename) in filenames.iter().enumerate() {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -496,7 +496,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n \n-        foreach (i, filename) in filenames.iter().enumerate() {\n+        for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n             make_file(filename.get_ref(), contents);\n@@ -518,7 +518,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n \n-        foreach (i, filename) in filenames.iter().enumerate() {\n+        for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n@@ -587,7 +587,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n \n-        foreach (i, filename) in filenames.iter().enumerate() {\n+        for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n@@ -600,7 +600,7 @@ mod test {\n         input.next_file(); // skip the rest of 1\n \n         // read all lines from 1 (but don't read any from 2),\n-        foreach i in range(1u, 4) {\n+        for i in range(1u, 4) {\n             assert_eq!(input.read_line(), fmt!(\"1 %u\", i));\n         }\n         // 1 is finished, but 2 hasn't been started yet, so this will"}, {"sha": "74653828121e96516778c3363e8c0f4b7e06cbc3", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -29,12 +29,12 @@ This example sends boxed integers across tasks using serialization.\n let (port, chan) = serial::pipe_stream();\n \n do task::spawn || {\n-    foreach i in range(0, 10) {\n+    for i in range(0, 10) {\n         chan.send(@i)\n     }\n }\n \n-foreach i in range(0, 10) {\n+for i in range(0, 10) {\n     assert @i == port.recv()\n }\n ~~~\n@@ -664,12 +664,12 @@ mod test {\n         let (port, chan) = serial::pipe_stream();\n \n         do task::spawn || {\n-            foreach i in range(0, 10) {\n+            for i in range(0, 10) {\n                 chan.send(i)\n             }\n         }\n \n-        foreach i in range(0, 10) {\n+        for i in range(0, 10) {\n             assert!(i == port.recv())\n         }\n     }\n@@ -680,12 +680,12 @@ mod test {\n         let (port, chan) = serial::pipe_stream();\n \n         do task::spawn || {\n-            foreach i in range(0, 10) {\n+            for i in range(0, 10) {\n                 chan.send(@i)\n             }\n         }\n \n-        foreach i in range(0, 10) {\n+        for i in range(0, 10) {\n             assert!(@i == port.recv())\n         }\n     }\n@@ -711,12 +711,12 @@ mod test {\n         let (port, chan) = pod::pipe_stream();\n \n         do task::spawn || {\n-            foreach i in range(0, 10) {\n+            for i in range(0, 10) {\n                 chan.send(i)\n             }\n         }\n \n-        foreach i in range(0, 10) {\n+        for i in range(0, 10) {\n             assert!(i == port.recv())\n         }\n     }\n@@ -828,7 +828,7 @@ mod test {\n             // TcpSocketBuf is a Writer!\n             let chan = writer_chan(socket_buf);\n \n-            foreach i in range(0, 10) {\n+            for i in range(0, 10) {\n                 debug!(\"sending %?\", i);\n                 chan.send(i)\n             }\n@@ -851,7 +851,7 @@ mod test {\n             // TcpSocketBuf is a Reader!\n             let port = reader_port(socket_buf);\n \n-            foreach i in range(0, 10) {\n+            for i in range(0, 10) {\n                 let j = port.recv();\n                 debug!(\"received %?\", j);\n                 assert_eq!(i, j);"}, {"sha": "b9ee38317f3210356fd9549c71ef96b3d51ffcb5", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -307,7 +307,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 }\n             }\n             let mut name_pos = 0;\n-            foreach nm in names.iter() {\n+            for nm in names.iter() {\n                 name_pos += 1;\n                 let optid = match find_opt(opts, (*nm).clone()) {\n                   Some(id) => id,\n@@ -392,7 +392,7 @@ pub fn opt_count(mm: &Matches, nm: &str) -> uint {\n \n /// Returns true if any of several options were matched\n pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n-    foreach nm in names.iter() {\n+    for nm in names.iter() {\n         match find_opt(mm.opts, mkname(*nm)) {\n             Some(id) if !mm.vals[id].is_empty() => return true,\n             _ => (),\n@@ -422,7 +422,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n  * option took an argument\n  */\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n-    foreach nm in names.iter() {\n+    for nm in names.iter() {\n         match opt_val(mm, *nm) {\n           Some(Val(ref s)) => return (*s).clone(),\n           _ => ()\n@@ -441,7 +441,7 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     let r = opt_vals(mm, nm);\n-    foreach v in r.iter() {\n+    for v in r.iter() {\n         match *v { Val(ref s) => acc.push((*s).clone()), _ => () }\n     }\n     acc\n@@ -671,7 +671,7 @@ pub mod groups {\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n-            foreach word in desc.word_iter() {\n+            for word in desc.word_iter() {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }"}, {"sha": "7fd47fdbd3999a7f336e837e0c67e008381b15d4", "filename": "src/libextra/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -27,7 +27,7 @@ internal iterator by calling the `advance` method. For example:\n let xs = [0u, 1, 2, 3, 4, 5];\n let ys = [30, 40, 50, 60];\n let mut it = xs.iter().chain(ys.iter());\n-foreach &x: &uint in it {\n+for &x: &uint in it {\n     println(x.to_str());\n }\n ~~~"}, {"sha": "cd35cbdf30980faa2cd62e765835e0f69dddfe05", "filename": "src/libextra/json.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -57,7 +57,7 @@ pub struct Error {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    foreach c in s.iter() {\n+    for c in s.iter() {\n         match c {\n           '\"' => escaped.push_str(\"\\\\\\\"\"),\n           '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n@@ -923,7 +923,7 @@ impl serialize::Decoder for Decoder {\n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n         let s = self.read_str();\n-        foreach c in s.iter() { v.push(c) }\n+        for c in s.iter() { v.push(c) }\n         if v.len() != 1 { fail!(\"string must have one character\") }\n         v[0]\n     }\n@@ -949,7 +949,7 @@ impl serialize::Decoder for Decoder {\n         let name = match self.stack.pop() {\n             String(s) => s,\n             List(list) => {\n-                foreach v in list.consume_rev_iter() {\n+                for v in list.consume_rev_iter() {\n                     self.stack.push(v);\n                 }\n                 match self.stack.pop() {\n@@ -1067,7 +1067,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n-                foreach v in list.consume_rev_iter() {\n+                for v in list.consume_rev_iter() {\n                     self.stack.push(v);\n                 }\n                 len\n@@ -1087,7 +1087,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n-                foreach (key, value) in obj.consume_iter() {\n+                for (key, value) in obj.consume_iter() {\n                     self.stack.push(value);\n                     self.stack.push(String(key));\n                 }\n@@ -1157,12 +1157,12 @@ impl Ord for Json {\n                         let mut d1_flat = ~[];\n \n                         // FIXME #4430: this is horribly inefficient...\n-                        foreach (k, v) in d0.iter() {\n+                        for (k, v) in d0.iter() {\n                              d0_flat.push((@(*k).clone(), @(*v).clone()));\n                         }\n                         d0_flat.qsort();\n \n-                        foreach (k, v) in d1.iter() {\n+                        for (k, v) in d1.iter() {\n                             d1_flat.push((@(*k).clone(), @(*v).clone()));\n                         }\n                         d1_flat.qsort();\n@@ -1297,7 +1297,7 @@ impl<A:ToJson> ToJson for ~[A] {\n impl<A:ToJson> ToJson for TreeMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n-        foreach (key, value) in self.iter() {\n+        for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n@@ -1307,7 +1307,7 @@ impl<A:ToJson> ToJson for TreeMap<~str, A> {\n impl<A:ToJson> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n-        foreach (key, value) in self.iter() {\n+        for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n@@ -1364,7 +1364,7 @@ mod tests {\n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~TreeMap::new();\n \n-        foreach item in items.iter() {\n+        for item in items.iter() {\n             match *item {\n                 (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n             }"}, {"sha": "ab843fe65464bd599f6f812f713d25ef32ce747e", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -131,7 +131,7 @@ impl TotalOrd for BigUint {\n         if s_len < o_len { return Less; }\n         if s_len > o_len { return Greater;  }\n \n-        foreach (&self_i, &other_i) in self.data.rev_iter().zip(other.data.rev_iter()) {\n+        for (&self_i, &other_i) in self.data.rev_iter().zip(other.data.rev_iter()) {\n             cond!((self_i < other_i) { return Less; }\n                   (self_i > other_i) { return Greater; })\n         }\n@@ -420,7 +420,7 @@ impl Integer for BigUint {\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n-            foreach elt in an.rev_iter() {\n+            for elt in an.rev_iter() {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n@@ -524,7 +524,7 @@ impl ToStrRadix for BigUint {\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let mut s = str::with_capacity(v.len() * l);\n-            foreach n in v.rev_iter() {\n+            for n in v.rev_iter() {\n                 let ss = uint::to_str_radix(*n as uint, radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n@@ -651,7 +651,7 @@ impl BigUint {\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n-        foreach elem in self.data.rev_iter() {\n+        for elem in self.data.rev_iter() {\n             shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n             borrow = *elem << (BigDigit::bits - n_bits);\n         }\n@@ -1186,8 +1186,8 @@ mod biguint_tests {\n     fn test_cmp() {\n         let data: ~[BigUint] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n-        foreach (i, ni) in data.iter().enumerate() {\n-            foreach (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n+        for (i, ni) in data.iter().enumerate() {\n+            for (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n                 let j = j0 + i;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1360,7 +1360,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_add() {\n-        foreach elm in sum_triples.iter() {\n+        for elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1373,7 +1373,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_sub() {\n-        foreach elm in sum_triples.iter() {\n+        for elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1424,7 +1424,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_mul() {\n-        foreach elm in mul_triples.iter() {\n+        for elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1434,7 +1434,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        foreach elm in div_rem_quadruples.iter() {\n+        for elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1448,7 +1448,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_div_rem() {\n-        foreach elm in mul_triples.iter() {\n+        for elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1462,7 +1462,7 @@ mod biguint_tests {\n             }\n         }\n \n-        foreach elm in div_rem_quadruples.iter() {\n+        for elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1579,9 +1579,9 @@ mod biguint_tests {\n     #[test]\n     fn test_to_str_radix() {\n         let r = to_str_pairs();\n-        foreach num_pair in r.iter() {\n+        for num_pair in r.iter() {\n             let &(ref n, ref rs) = num_pair;\n-            foreach str_pair in rs.iter() {\n+            for str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n                 assert_eq!(&n.to_str_radix(*radix), str);\n             }\n@@ -1591,9 +1591,9 @@ mod biguint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         let r = to_str_pairs();\n-        foreach num_pair in r.iter() {\n+        for num_pair in r.iter() {\n             let &(ref n, ref rs) = num_pair;\n-            foreach str_pair in rs.iter() {\n+            for str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n                 assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).get());\n             }\n@@ -1608,7 +1608,7 @@ mod biguint_tests {\n     fn test_factor() {\n         fn factor(n: uint) -> BigUint {\n             let mut f= One::one::<BigUint>();\n-            foreach i in range(2, n + 1) {\n+            for i in range(2, n + 1) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // f *= BigUint::from_uint(i);\n                 f = f * BigUint::from_uint(i);\n@@ -1658,14 +1658,14 @@ mod bigint_tests {\n     fn test_cmp() {\n         let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n         let mut nums = ~[];\n-        foreach s in vs.rev_iter() {\n+        for s in vs.rev_iter() {\n             nums.push(BigInt::from_slice(Minus, *s));\n         }\n         nums.push(Zero::zero());\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n-        foreach (i, ni) in nums.iter().enumerate() {\n-            foreach (j0, nj) in nums.slice(i, nums.len()).iter().enumerate() {\n+        for (i, ni) in nums.iter().enumerate() {\n+            for (j0, nj) in nums.slice(i, nums.len()).iter().enumerate() {\n                 let j = i + j0;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1769,7 +1769,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_add() {\n-        foreach elm in sum_triples.iter() {\n+        for elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1788,7 +1788,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_sub() {\n-        foreach elm in sum_triples.iter() {\n+        for elm in sum_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1845,7 +1845,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_mul() {\n-        foreach elm in mul_triples.iter() {\n+        for elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1858,7 +1858,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        foreach elm in div_rem_quadruples.iter() {\n+        for elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1897,7 +1897,7 @@ mod bigint_tests {\n             }\n         }\n \n-        foreach elm in mul_triples.iter() {\n+        for elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1907,7 +1907,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        foreach elm in div_rem_quadruples.iter() {\n+        for elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1940,7 +1940,7 @@ mod bigint_tests {\n             check_sub(&a.neg(), b, &q.neg(), &r.neg());\n             check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n-        foreach elm in mul_triples.iter() {\n+        for elm in mul_triples.iter() {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1950,7 +1950,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        foreach elm in div_rem_quadruples.iter() {\n+        for elm in div_rem_quadruples.iter() {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);"}, {"sha": "669dc1c1b45fa43fdd078694f937f13917749435", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -239,14 +239,14 @@ mod test {\n     fn test_scale_unscale() {\n         assert_eq!(_05_05i.scale(2f), _1_1i);\n         assert_eq!(_1_1i.unscale(2f), _05_05i);\n-        foreach &c in all_consts.iter() {\n+        for &c in all_consts.iter() {\n             assert_eq!(c.scale(2f).unscale(2f), c);\n         }\n     }\n \n     #[test]\n     fn test_conj() {\n-        foreach &c in all_consts.iter() {\n+        for &c in all_consts.iter() {\n             assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n             assert_eq!(c.conj().conj(), c);\n         }\n@@ -283,7 +283,7 @@ mod test {\n             let (r, theta) = c.to_polar();\n             assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n         }\n-        foreach &c in all_consts.iter() { test(c); }\n+        for &c in all_consts.iter() { test(c); }\n     }\n \n     mod arith {\n@@ -296,7 +296,7 @@ mod test {\n             assert_eq!(_0_1i + _1_0i, _1_1i);\n             assert_eq!(_1_0i + _neg1_1i, _0_1i);\n \n-            foreach &c in all_consts.iter() {\n+            for &c in all_consts.iter() {\n                 assert_eq!(_0_0i + c, c);\n                 assert_eq!(c + _0_0i, c);\n             }\n@@ -308,7 +308,7 @@ mod test {\n             assert_eq!(_0_1i - _1_0i, _neg1_1i);\n             assert_eq!(_0_1i - _neg1_1i, _1_0i);\n \n-            foreach &c in all_consts.iter() {\n+            for &c in all_consts.iter() {\n                 assert_eq!(c - _0_0i, c);\n                 assert_eq!(c - c, _0_0i);\n             }\n@@ -323,15 +323,15 @@ mod test {\n             assert_eq!(_0_1i * _0_1i, -_1_0i);\n             assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n \n-            foreach &c in all_consts.iter() {\n+            for &c in all_consts.iter() {\n                 assert_eq!(c * _1_0i, c);\n                 assert_eq!(_1_0i * c, c);\n             }\n         }\n         #[test]\n         fn test_div() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n-            foreach &c in all_consts.iter() {\n+            for &c in all_consts.iter() {\n                 if c != Zero::zero() {\n                     assert_eq!(c / c, _1_0i);\n                 }\n@@ -341,7 +341,7 @@ mod test {\n         fn test_neg() {\n             assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n             assert_eq!((-_0_1i) * _0_1i, _1_0i);\n-            foreach &c in all_consts.iter() {\n+            for &c in all_consts.iter() {\n                 assert_eq!(-(-c), c);\n             }\n         }"}, {"sha": "60dd36a3b886e1c90688b423645e5bbfb3b7f1c0", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -500,7 +500,7 @@ mod test {\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n-        foreach &s in xs.iter() {\n+        for &s in xs.iter() {\n             test(s);\n         }\n     }\n@@ -540,7 +540,7 @@ mod test {\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];\n-        foreach &s in xs.iter() {\n+        for &s in xs.iter() {\n             test(s);\n         }\n     }"}, {"sha": "696ecc881b7230c551d7b889489fdbcbe7d71e52", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -206,7 +206,7 @@ impl<T: Ord, Iter: Iterator<T>> Extendable<T, Iter> for PriorityQueue<T> {\n         let len = self.capacity();\n         self.reserve_at_least(len + lower);\n \n-        foreach elem in *iter {\n+        for elem in *iter {\n             self.push(elem);\n         }\n     }\n@@ -223,7 +223,7 @@ mod tests {\n         let iterout = ~[9, 5, 3];\n         let pq = PriorityQueue::from_vec(data);\n         let mut i = 0;\n-        foreach el in pq.iter() {\n+        for el in pq.iter() {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }\n@@ -369,7 +369,7 @@ mod tests {\n \n         let mut q: PriorityQueue<uint> = xs.rev_iter().transform(|&x| x).collect();\n \n-        foreach &x in xs.iter() {\n+        for &x in xs.iter() {\n             assert_eq!(q.pop(), x);\n         }\n     }"}, {"sha": "89d23191a7634331bf95fa976995425d9b14a053", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -38,7 +38,7 @@ impl<T> Container for RingBuf<T> {\n impl<T> Mutable for RingBuf<T> {\n     /// Clear the RingBuf, removing all values.\n     fn clear(&mut self) {\n-        foreach x in self.elts.mut_iter() { *x = None }\n+        for x in self.elts.mut_iter() { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n     }\n@@ -277,7 +277,7 @@ fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     elts.reserve(newlen);\n \n     /* fill with None */\n-    foreach _ in range(elts.len(), elts.capacity()) {\n+    for _ in range(elts.len(), elts.capacity()) {\n         elts.push(None);\n     }\n \n@@ -292,11 +292,11 @@ fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n \n     assert!(newlen - nelts/2 >= nelts);\n     if lo <= (nelts - lo) { // A\n-        foreach i in range(0u, lo) {\n+        for i in range(0u, lo) {\n             elts.swap(i, nelts + i);\n         }\n     } else {                // B\n-        foreach i in range(lo, nelts) {\n+        for i in range(lo, nelts) {\n             elts.swap(i, newlen - nelts + i);\n         }\n         *loptr += newlen - nelts;\n@@ -333,7 +333,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for RingBuf<A> {\n \n impl<A, T: Iterator<A>> Extendable<A, T> for RingBuf<A> {\n     fn extend(&mut self, iterator: &mut T) {\n-        foreach elt in *iterator {\n+        for elt in *iterator {\n             self.push_back(elt);\n         }\n     }\n@@ -461,21 +461,21 @@ mod tests {\n     #[test]\n     fn test_push_front_grow() {\n         let mut deq = RingBuf::new();\n-        foreach i in range(0u, 66) {\n+        for i in range(0u, 66) {\n             deq.push_front(i);\n         }\n         assert_eq!(deq.len(), 66);\n \n-        foreach i in range(0u, 66) {\n+        for i in range(0u, 66) {\n             assert_eq!(*deq.get(i), 65 - i);\n         }\n \n         let mut deq = RingBuf::new();\n-        foreach i in range(0u, 66) {\n+        for i in range(0u, 66) {\n             deq.push_back(i);\n         }\n \n-        foreach i in range(0u, 66) {\n+        for i in range(0u, 66) {\n             assert_eq!(*deq.get(i), i);\n         }\n     }\n@@ -606,12 +606,12 @@ mod tests {\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n-        foreach i in range(0, 5) {\n+        for i in range(0, 5) {\n             d.push_back(i);\n         }\n         assert_eq!(d.iter().collect::<~[&int]>(), ~[&0,&1,&2,&3,&4]);\n \n-        foreach i in range(6, 9) {\n+        for i in range(6, 9) {\n             d.push_front(i);\n         }\n         assert_eq!(d.iter().collect::<~[&int]>(), ~[&8,&7,&6,&0,&1,&2,&3,&4]);\n@@ -631,12 +631,12 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert_eq!(d.rev_iter().next(), None);\n \n-        foreach i in range(0, 5) {\n+        for i in range(0, 5) {\n             d.push_back(i);\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0]);\n \n-        foreach i in range(6, 9) {\n+        for i in range(6, 9) {\n             d.push_front(i);\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n@@ -647,11 +647,11 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert!(d.mut_iter().next().is_none());\n \n-        foreach i in range(0u, 3) {\n+        for i in range(0u, 3) {\n             d.push_front(i);\n         }\n \n-        foreach (i, elt) in d.mut_iter().enumerate() {\n+        for (i, elt) in d.mut_iter().enumerate() {\n             assert_eq!(*elt, 2 - i);\n             *elt = i;\n         }\n@@ -670,11 +670,11 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert!(d.mut_rev_iter().next().is_none());\n \n-        foreach i in range(0u, 3) {\n+        for i in range(0u, 3) {\n             d.push_front(i);\n         }\n \n-        foreach (i, elt) in d.mut_rev_iter().enumerate() {\n+        for (i, elt) in d.mut_rev_iter().enumerate() {\n             assert_eq!(*elt, i);\n             *elt = i;\n         }\n@@ -698,7 +698,7 @@ mod tests {\n \n         let mut seq = iterator::Counter::new(0u, 2).take_(256);\n         let deq: RingBuf<uint> = seq.collect();\n-        foreach (i, &x) in deq.iter().enumerate() {\n+        for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n         assert_eq!(deq.len(), 256);"}, {"sha": "c44505694b13d497c9d20460a58a0b5f6f889979", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -443,7 +443,7 @@ impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @mut T {\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            foreach (i, e) in self.iter().enumerate() {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -453,7 +453,7 @@ impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            foreach (i, e) in self.iter().enumerate() {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -473,7 +473,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            foreach (i, e) in self.iter().enumerate() {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -667,7 +667,7 @@ impl<\n > Encodable<S> for DList<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            foreach (i, e) in self.iter().enumerate() {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }\n@@ -678,7 +678,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n     fn decode(d: &mut D) -> DList<T> {\n         let mut list = DList::new();\n         do d.read_seq |d, len| {\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n@@ -692,7 +692,7 @@ impl<\n > Encodable<S> for RingBuf<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            foreach (i, e) in self.iter().enumerate() {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }\n@@ -703,7 +703,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n     fn decode(d: &mut D) -> RingBuf<T> {\n         let mut deque = RingBuf::new();\n         do d.read_seq |d, len| {\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n@@ -719,7 +719,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            foreach (key, val) in self.iter() {\n+            for (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -736,7 +736,7 @@ impl<\n     fn decode(d: &mut D) -> HashMap<K, V> {\n         do d.read_map |d, len| {\n             let mut map = HashMap::with_capacity(len);\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n@@ -753,7 +753,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            foreach e in self.iter() {\n+            for e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n@@ -768,7 +768,7 @@ impl<\n     fn decode(d: &mut D) -> HashSet<T> {\n         do d.read_seq |d, len| {\n             let mut set = HashSet::with_capacity(len);\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n@@ -800,7 +800,7 @@ impl<\n     fn decode(d: &mut D) -> TrieMap<V> {\n         do d.read_map |d, len| {\n             let mut map = TrieMap::new();\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n@@ -827,7 +827,7 @@ impl<D: Decoder> Decodable<D> for TrieSet {\n     fn decode(d: &mut D) -> TrieSet {\n         do d.read_seq |d, len| {\n             let mut set = TrieSet::new();\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n@@ -843,7 +843,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            foreach (key, val) in self.iter() {\n+            for (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -860,7 +860,7 @@ impl<\n     fn decode(d: &mut D) -> TreeMap<K, V> {\n         do d.read_map |d, len| {\n             let mut map = TreeMap::new();\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n@@ -877,7 +877,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            foreach e in self.iter() {\n+            for e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n@@ -892,7 +892,7 @@ impl<\n     fn decode(d: &mut D) -> TreeSet<T> {\n         do d.read_seq |d, len| {\n             let mut set = TreeSet::new();\n-            foreach i in range(0u, len) {\n+            for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n@@ -912,7 +912,7 @@ pub trait EncoderHelpers {\n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n         do self.emit_seq(v.len()) |this| {\n-            foreach (i, e) in v.iter().enumerate() {\n+            for (i, e) in v.iter().enumerate() {\n                 do this.emit_seq_elt(i) |this| {\n                     f(this, e)\n                 }"}, {"sha": "39efe4eda4bf056707f30c81855cce23416655fc", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -30,7 +30,7 @@ impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n     fn len(&self) -> uint {\n         let mut sz = 0;\n-        foreach i in range(0u, self.v.len()) {\n+        for i in range(0u, self.v.len()) {\n             match self.v[i] {\n                 Some(_) => sz += 1,\n                 None => {}\n@@ -123,7 +123,7 @@ impl<V> SmallIntMap<V> {\n \n     /// Visit all key-value pairs in order\n     pub fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n-        foreach i in range(0u, self.v.len()) {\n+        for i in range(0u, self.v.len()) {\n             match self.v[i] {\n               Some(ref elt) => if !it(&i, elt) { return false; },\n               None => ()\n@@ -144,7 +144,7 @@ impl<V> SmallIntMap<V> {\n \n     /// Iterate over the map and mutate the contained values\n     pub fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n-        foreach i in range(0, self.v.len()) {\n+        for i in range(0, self.v.len()) {\n             match self.v[i] {\n               Some(ref mut elt) => if !it(&i, elt) { return false; },\n               None => ()\n@@ -446,7 +446,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        foreach (k, v) in m.mut_iter() {\n+        for (k, v) in m.mut_iter() {\n             *v += k as int;\n         }\n \n@@ -488,7 +488,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        foreach (k, v) in m.mut_rev_iter() {\n+        for (k, v) in m.mut_rev_iter() {\n             *v += k as int;\n         }\n \n@@ -506,7 +506,7 @@ mod test_map {\n         let mut m = SmallIntMap::new();\n         m.insert(1, ~2);\n         let mut called = false;\n-        foreach (k, v) in m.consume() {\n+        for (k, v) in m.consume() {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);"}, {"sha": "8090dd26ef20a88e79de83dc632eee747feae6b0", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -470,7 +470,7 @@ impl<T:Clone + Ord> MergeState<T> {\n         assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n         let mut tmp = ~[];\n-        foreach i in range(base1, base1+len1) {\n+        for i in range(base1, base1+len1) {\n             tmp.push(array[i].clone());\n         }\n \n@@ -580,7 +580,7 @@ impl<T:Clone + Ord> MergeState<T> {\n         assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n         let mut tmp = ~[];\n-        foreach i in range(base2, base2+len2) {\n+        for i in range(base2, base2+len2) {\n             tmp.push(array[i].clone());\n         }\n \n@@ -732,7 +732,7 @@ fn copy_vec<T:Clone>(dest: &mut [T],\n                     from: &[T]) {\n     assert!(s1+from.len() <= dest.len());\n \n-    foreach (i, v) in from.iter().enumerate() {\n+    for (i, v) in from.iter().enumerate() {\n         dest[s1+i] = (*v).clone();\n     }\n }\n@@ -842,7 +842,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n-        foreach p in pairs.iter() {\n+        for p in pairs.iter() {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n             assert_eq!(a, b);\n@@ -1054,7 +1054,7 @@ mod big_tests {\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n         fn isSorted<T:Ord>(arr: &[T]) {\n-            foreach i in range(0u, arr.len() - 1) {\n+            for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n                     fail!(\"Array not sorted\");\n                 }\n@@ -1063,7 +1063,7 @@ mod big_tests {\n \n         let mut rng = rand::rng();\n \n-        foreach i in range(lo, hi) {\n+        for i in range(lo, hi) {\n             let n = 1 << i;\n             let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n                 rng.gen()\n@@ -1125,7 +1125,7 @@ mod big_tests {\n \n     fn tabulate_managed(lo: uint, hi: uint) {\n         fn isSorted<T:Ord>(arr: &[@T]) {\n-            foreach i in range(0u, arr.len() - 1) {\n+            for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n                     fail!(\"Array not sorted\");\n                 }\n@@ -1134,7 +1134,7 @@ mod big_tests {\n \n         let mut rng = rand::rng();\n \n-        foreach i in range(lo, hi) {\n+        for i in range(lo, hi) {\n             let n = 1 << i;\n             let arr: ~[@float] = do vec::from_fn(n) |_i| {\n                 @rng.gen()"}, {"sha": "68d5af43688a241f9ff827ff6ebe31253f3a1976", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -167,7 +167,7 @@ impl<'self> Stats for &'self [f64] {\n         } else {\n             let mean = self.mean();\n             let mut v = 0.0;\n-            foreach s in self.iter() {\n+            for s in self.iter() {\n                 let x = *s - mean;\n                 v += x*x;\n             }\n@@ -254,7 +254,7 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n     sort::tim_sort(tmp);\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);\n-    foreach samp in samples.mut_iter() {\n+    for samp in samples.mut_iter() {\n         if *samp > hi {\n             *samp = hi\n         } else if *samp < lo {"}, {"sha": "63e371899a9bdbf8ed6c34ed4dbca5ec09eac33f", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -893,13 +893,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        foreach port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.iter() { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        foreach port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -991,7 +991,7 @@ mod tests {\n                     }\n                 }\n             }\n-            foreach p in sibling_convos.iter() {\n+            for p in sibling_convos.iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n@@ -1001,7 +1001,7 @@ mod tests {\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         let r = p.recv();\n-        foreach p in r.iter() { p.recv(); } // wait on all its siblings\n+        for p in r.iter() { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n@@ -1253,13 +1253,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        foreach port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.iter() { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        foreach port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "17588b93ec41e2036d6968f69a18106d304ae09c", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -35,7 +35,7 @@ pub struct TaskPool<T> {\n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n     fn drop(&self) {\n-        foreach channel in self.channels.iter() {\n+        for channel in self.channels.iter() {\n             channel.send(Quit);\n         }\n     }"}, {"sha": "cb1bde140568667078bbb4d98b08798ea26e1dd6", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,7 +19,7 @@ use std::rand;\n /// have the suffix `suffix`. If no directory can be created, None is returned.\n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let mut r = rand::rng();\n-    foreach _ in range(0u, 1000) {\n+    for _ in range(0u, 1000) {\n         let p = tmpdir.push(r.gen_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700\n             return Some(p);"}, {"sha": "b619e0f33b644663bb43ba781c3688411f3f1679", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -102,11 +102,11 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         Number(0), Number(0), Number(0), Number(0), Number(0),\n         Number(0), Number(0), Number(0), Number(0),\n     ];\n-    foreach (dst, src) in mparams.mut_iter().zip(params.iter()) {\n+    for (dst, src) in mparams.mut_iter().zip(params.iter()) {\n         *dst = (*src).clone();\n     }\n \n-    foreach c in cap.iter().transform(|&x| x) {\n+    for c in cap.iter().transform(|&x| x) {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {\n@@ -605,7 +605,7 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        foreach cap in caps.iter() {\n+        for cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n@@ -615,7 +615,7 @@ mod test {\n                     \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        foreach cap in caps.iter() {\n+        for cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n@@ -636,7 +636,7 @@ mod test {\n     #[test]\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n-        foreach &(op, bs) in v.iter() {\n+        for &(op, bs) in v.iter() {\n             let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());"}, {"sha": "426cacb62faad0eaf7731c39a3df36beb2cad8a5", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -222,7 +222,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n-        foreach i in range(0, bools_bytes) {\n+        for i in range(0, bools_bytes) {\n             let b = file.read_byte();\n             if b < 0 {\n                 error!(\"EOF reading bools after %? entries\", i);\n@@ -243,7 +243,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n-        foreach i in range(0, numbers_count) {\n+        for i in range(0, numbers_count) {\n             let n = file.read_le_u16();\n             if n != 0xFFFF {\n                 debug!(\"%s#%?\", nnames[i], n);\n@@ -258,7 +258,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n-        foreach _ in range(0, string_offsets_count) {\n+        for _ in range(0, string_offsets_count) {\n             string_offsets.push(file.read_le_u16());\n         }\n \n@@ -272,7 +272,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             return Err(~\"error: hit EOF before end of string table\");\n         }\n \n-        foreach (i, v) in string_offsets.iter().enumerate() {\n+        for (i, v) in string_offsets.iter().enumerate() {\n             let offset = *v;\n             if offset == 0xFFFF { // non-entry\n                 loop;"}, {"sha": "f7999050804c523ab6636efe2eb41871c345fc27", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -35,7 +35,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n                 dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => foreach i in dirs.split_iter(':') {\n+                Some(dirs) => for i in dirs.split_iter(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(path(\"/usr/share/terminfo\"));\n                     } else {\n@@ -54,7 +54,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n     };\n \n     // Look for the terminal in all of the search directories\n-    foreach p in dirs_to_search.iter() {\n+    for p in dirs_to_search.iter() {\n         let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);"}, {"sha": "02481693eb9713e0c34de059e9490e30838332c5", "filename": "src/libextra/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -429,11 +429,11 @@ impl ConsoleTestState {\n     pub fn write_failures(&self) {\n         self.out.write_line(\"\\nfailures:\");\n         let mut failures = ~[];\n-        foreach f in self.failures.iter() {\n+        for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         sort::tim_sort(failures);\n-        foreach name in failures.iter() {\n+        for name in failures.iter() {\n             self.out.write_line(fmt!(\"    %s\", name.to_str()));\n         }\n     }\n@@ -445,7 +445,7 @@ impl ConsoleTestState {\n         let mut added = 0;\n         let mut removed = 0;\n \n-        foreach (k, v) in diff.iter() {\n+        for (k, v) in diff.iter() {\n             match *v {\n                 LikelyNoise => noise += 1,\n                 MetricAdded => {\n@@ -565,7 +565,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n                         let tname = test.name.to_str();\n-                        foreach (k,v) in mm.iter() {\n+                        for (k,v) in mm.iter() {\n                             st.metrics.insert_metric(tname + \".\" + *k,\n                                                      v.value, v.noise);\n                         }\n@@ -699,7 +699,7 @@ fn run_tests(opts: &TestOpts,\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n-    foreach b in filtered_benchs_and_metrics.consume_iter() {\n+    for b in filtered_benchs_and_metrics.consume_iter() {\n         callback(TeWait(b.desc.clone()));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n@@ -887,7 +887,7 @@ impl MetricMap {\n     pub fn compare_to_old(&self, old: &MetricMap,\n                           noise_pct: Option<f64>) -> MetricDiff {\n         let mut diff : MetricDiff = TreeMap::new();\n-        foreach (k, vold) in old.iter() {\n+        for (k, vold) in old.iter() {\n             let r = match self.find(k) {\n                 None => MetricRemoved,\n                 Some(v) => {\n@@ -924,7 +924,7 @@ impl MetricMap {\n             };\n             diff.insert((*k).clone(), r);\n         }\n-        foreach (k, _) in self.iter() {\n+        for (k, _) in self.iter() {\n             if !diff.contains_key(k) {\n                 diff.insert((*k).clone(), MetricAdded);\n             }\n@@ -990,7 +990,7 @@ impl BenchHarness {\n     pub fn iter(&mut self, inner:&fn()) {\n         self.ns_start = precise_time_ns();\n         let k = self.iterations;\n-        foreach _ in range(0u64, k) {\n+        for _ in range(0u64, k) {\n             inner();\n         }\n         self.ns_end = precise_time_ns();\n@@ -1039,15 +1039,15 @@ impl BenchHarness {\n         loop {\n             let loop_start = precise_time_ns();\n \n-            foreach p in samples.mut_iter() {\n+            for p in samples.mut_iter() {\n                 self.bench_n(n as u64, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n             };\n \n             stats::winsorize(samples, 5.0);\n             let summ = stats::Summary::new(samples);\n \n-            foreach p in samples.mut_iter() {\n+            for p in samples.mut_iter() {\n                 self.bench_n(5 * n as u64, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n             };\n@@ -1287,7 +1287,7 @@ mod tests {\n         {\n             fn testfn() { }\n             let mut tests = ~[];\n-            foreach name in names.iter() {\n+            for name in names.iter() {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n                         name: DynTestName((*name).clone()),\n@@ -1313,7 +1313,7 @@ mod tests {\n \n         let pairs = vec::zip(expected, filtered);\n \n-        foreach p in pairs.iter() {\n+        for p in pairs.iter() {\n             match *p {\n                 (ref a, ref b) => {\n                     assert!(*a == b.desc.name.to_str());"}, {"sha": "efc3dc87adc00f02887a3980fb20c7931cae69f6", "filename": "src/libextra/time.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -257,7 +257,7 @@ impl Tm {\n priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        foreach ch in needle.byte_iter() {\n+        for ch in needle.byte_iter() {\n             if s[i] != ch {\n                 return false;\n             }\n@@ -1036,7 +1036,7 @@ mod tests {\n             ~\"Friday\",\n             ~\"Saturday\"\n         ];\n-        foreach day in days.iter() {\n+        for day in days.iter() {\n             assert!(test(*day, \"%A\"));\n         }\n \n@@ -1049,7 +1049,7 @@ mod tests {\n             ~\"Fri\",\n             ~\"Sat\"\n         ];\n-        foreach day in days.iter() {\n+        for day in days.iter() {\n             assert!(test(*day, \"%a\"));\n         }\n \n@@ -1067,7 +1067,7 @@ mod tests {\n             ~\"November\",\n             ~\"December\"\n         ];\n-        foreach day in months.iter() {\n+        for day in months.iter() {\n             assert!(test(*day, \"%B\"));\n         }\n \n@@ -1085,7 +1085,7 @@ mod tests {\n             ~\"Nov\",\n             ~\"Dec\"\n         ];\n-        foreach day in months.iter() {\n+        for day in months.iter() {\n             assert!(test(*day, \"%b\"));\n         }\n "}, {"sha": "ed777347fbabc834d9cf195717566e55450b369d", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -47,7 +47,7 @@ impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n         } else {\n             let mut x = self.iter();\n             let mut y = other.iter();\n-            foreach _ in range(0u, self.len()) {\n+            for _ in range(0u, self.len()) {\n                 if x.next().unwrap() != y.next().unwrap() {\n                     return false\n                 }\n@@ -65,7 +65,7 @@ fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n     let mut y = b.iter();\n \n     let (a_len, b_len) = (a.len(), b.len());\n-    foreach _ in range(0u, num::min(a_len, b_len)) {\n+    for _ in range(0u, num::min(a_len, b_len)) {\n         let (key_a, value_a) = x.next().unwrap();\n         let (key_b, value_b) = y.next().unwrap();\n         if *key_a < *key_b { return true; }\n@@ -674,7 +674,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n     fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                                  child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n-        foreach x in child.mut_iter() {\n+        for x in child.mut_iter() {\n             if x.right.is_some() {\n                 heir_swap(node, &mut x.right);\n             } else {\n@@ -729,18 +729,18 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                 save.level -= 1;\n \n                 if right_level > save.level {\n-                    foreach x in save.right.mut_iter() { x.level = save.level }\n+                    for x in save.right.mut_iter() { x.level = save.level }\n                 }\n \n                 skew(save);\n \n-                foreach right in save.right.mut_iter() {\n+                for right in save.right.mut_iter() {\n                     skew(right);\n-                    foreach x in right.right.mut_iter() { skew(x) }\n+                    for x in right.right.mut_iter() { skew(x) }\n                 }\n \n                 split(save);\n-                foreach x in save.right.mut_iter() { split(x) }\n+                for x in save.right.mut_iter() { split(x) }\n             }\n \n             return ret;\n@@ -763,7 +763,7 @@ impl<K: TotalOrd, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for TreeMap<K,\n impl<K: TotalOrd, V, T: Iterator<(K, V)>> Extendable<(K, V), T> for TreeMap<K, V> {\n     #[inline]\n     fn extend(&mut self, iter: &mut T) {\n-        foreach (k, v) in *iter {\n+        for (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n@@ -780,7 +780,7 @@ impl<T: TotalOrd, Iter: Iterator<T>> FromIterator<T, Iter> for TreeSet<T> {\n impl<T: TotalOrd, Iter: Iterator<T>> Extendable<T, Iter> for TreeSet<T> {\n     #[inline]\n     fn extend(&mut self, iter: &mut Iter) {\n-        foreach elem in *iter {\n+        for elem in *iter {\n             self.insert(elem);\n         }\n     }\n@@ -863,13 +863,13 @@ mod test_treemap {\n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n-        foreach x in ctrl.iter() {\n+        for x in ctrl.iter() {\n             let &(ref k, ref v) = x;\n             assert!(map.find(k).unwrap() == v)\n         }\n-        foreach (map_k, map_v) in map.iter() {\n+        for (map_k, map_v) in map.iter() {\n             let mut found = false;\n-            foreach x in ctrl.iter() {\n+            for x in ctrl.iter() {\n                 let &(ref ctrl_k, ref ctrl_v) = x;\n                 if *map_k == *ctrl_k {\n                     assert!(*map_v == *ctrl_v);\n@@ -983,7 +983,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        foreach (k, v) in m.iter() {\n+        for (k, v) in m.iter() {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n@@ -1091,7 +1091,7 @@ mod test_treemap {\n                         (&x5, &y5)];\n         let mut i = 0;\n \n-        foreach x in b {\n+        for x in b {\n             assert_eq!(expected[i], x);\n             i += 1;\n \n@@ -1100,7 +1100,7 @@ mod test_treemap {\n             }\n         }\n \n-        foreach x in b {\n+        for x in b {\n             assert_eq!(expected[i], x);\n             i += 1;\n         }\n@@ -1112,7 +1112,7 @@ mod test_treemap {\n \n         let map: TreeMap<int, int> = xs.iter().transform(|&x| x).collect();\n \n-        foreach &(k, v) in xs.iter() {\n+        for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n@@ -1260,7 +1260,7 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 0;\n-        foreach x in m.iter() {\n+        for x in m.iter() {\n             printfln!(x);\n             assert_eq!(*x, n);\n             n += 1\n@@ -1290,8 +1290,8 @@ mod test_set {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n \n-        foreach x in a.iter() { assert!(set_a.insert(*x)) }\n-        foreach y in b.iter() { assert!(set_b.insert(*y)) }\n+        for x in a.iter() { assert!(set_a.insert(*x)) }\n+        for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         do f(&set_a, &set_b) |x| {\n@@ -1413,7 +1413,7 @@ mod test_set {\n \n         let set: TreeSet<int> = xs.iter().transform(|&x| x).collect();\n \n-        foreach x in xs.iter() {\n+        for x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "523c3521f866519fa2c8e188fe5752f9b2bbebb1", "filename": "src/libextra/url.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -206,10 +206,10 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    foreach (key, values) in m.iter() {\n+    for (key, values) in m.iter() {\n         let key = encode_plus(*key);\n \n-        foreach value in values.iter() {\n+        for value in values.iter() {\n             if first {\n                 first = false;\n             } else {\n@@ -331,7 +331,7 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if !rawquery.is_empty() {\n-        foreach p in rawquery.split_iter('&') {\n+        for p in rawquery.split_iter('&') {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n         };\n@@ -341,7 +341,7 @@ fn query_from_str(rawquery: &str) -> Query {\n \n pub fn query_to_str(query: &Query) -> ~str {\n     let mut strvec = ~[];\n-    foreach kv in query.iter() {\n+    for kv in query.iter() {\n         match kv {\n             &(ref k, ref v) => {\n                 strvec.push(fmt!(\"%s=%s\",\n@@ -356,7 +356,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n \n // returns the scheme and the rest of the url, or a parsing error\n pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n-    foreach (i,c) in rawurl.iter().enumerate() {\n+    for (i,c) in rawurl.iter().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n           '0' .. '9' | '+' | '-' | '.' => {\n@@ -418,7 +418,7 @@ fn get_authority(rawurl: &str) ->\n     let mut begin = 2;\n     let mut end = len;\n \n-    foreach (i,c) in rawurl.iter().enumerate() {\n+    for (i,c) in rawurl.iter().enumerate() {\n         if i < 2 { loop; } // ignore the leading //\n \n         // deal with input class first\n@@ -563,7 +563,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n     let len = rawurl.len();\n     let mut end = len;\n-    foreach (i,c) in rawurl.iter().enumerate() {\n+    for (i,c) in rawurl.iter().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n           | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='"}, {"sha": "0256519abb7e835c257cd29943140cfdfa4aeb42", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -286,7 +286,7 @@ impl<'self> Prep<'self> {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        foreach (k, v) in map.iter() {\n+        for (k, v) in map.iter() {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }"}, {"sha": "1ac8146bb589aab17141eddb25a67090331fe0d4", "filename": "src/librust/rust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -215,7 +215,7 @@ fn usage() {\n         \\n\"\n     );\n \n-    foreach command in COMMANDS.iter() {\n+    for command in COMMANDS.iter() {\n         let padding = \" \".repeat(INDENT - command.cmd.len());\n         printfln!(\"    %s%s%s\", command.cmd, padding, command.usage_line);\n     }\n@@ -240,7 +240,7 @@ pub fn main() {\n \n     if !args.is_empty() {\n         let r = find_cmd(*args.head());\n-        foreach command in r.iter() {\n+        for command in r.iter() {\n             let result = do_command(command, args.tail());\n             match result {\n                 Valid(exit_code) => unsafe { exit(exit_code.to_i32()) },"}, {"sha": "f066ede65f976c8af7de89fa5f2122230b9561c6", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -141,7 +141,7 @@ pub mod jit {\n \n             let cstore = sess.cstore;\n             let r = cstore::get_used_crate_files(cstore);\n-            foreach cratepath in r.iter() {\n+            for cratepath in r.iter() {\n                 let path = cratepath.to_str();\n \n                 debug!(\"linking: %s\", path);\n@@ -507,7 +507,7 @@ pub fn build_link_meta(sess: Session,\n         let mut cmh_items = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        foreach meta in linkage_metas.iter() {\n+        for meta in linkage_metas.iter() {\n             match meta.name_str_pair() {\n                 Some((n, value)) if \"name\" == n => name = Some(value),\n                 Some((n, value)) if \"vers\" == n => vers = Some(value),\n@@ -547,19 +547,19 @@ pub fn build_link_meta(sess: Session,\n               }\n               ast::MetaList(name, ref mis) => {\n                 write_string(symbol_hasher, len_and_str(name));\n-                foreach m_ in mis.iter() {\n+                for m_ in mis.iter() {\n                     hash(symbol_hasher, m_);\n                 }\n               }\n             }\n         }\n \n         symbol_hasher.reset();\n-        foreach m in cmh_items.iter() {\n+        for m in cmh_items.iter() {\n             hash(symbol_hasher, m);\n         }\n \n-        foreach dh in dep_hashes.iter() {\n+        for dh in dep_hashes.iter() {\n             write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n@@ -665,7 +665,7 @@ pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    foreach c in s.iter() {\n+    for c in s.iter() {\n         match c {\n             // Escape these with $ sequences\n             '@' => result.push_str(\"$SP$\"),\n@@ -712,7 +712,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n-    foreach s in ss.iter() {\n+    for s in ss.iter() {\n         match *s {\n             path_name(s) | path_mod(s) => {\n                 let sani = sanitize(sess.str_of(s));\n@@ -905,7 +905,7 @@ pub fn link_args(sess: Session,\n \n     let cstore = sess.cstore;\n     let r = cstore::get_used_crate_files(cstore);\n-    foreach cratepath in r.iter() {\n+    for cratepath in r.iter() {\n         if cratepath.filetype() == Some(~\".rlib\") {\n             args.push(cratepath.to_str());\n             loop;\n@@ -917,12 +917,12 @@ pub fn link_args(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    foreach arg in ula.iter() { args.push(arg.to_owned()); }\n+    for arg in ula.iter() { args.push(arg.to_owned()); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n-        foreach link_arg in link_args.consume_iter() {\n+        for link_arg in link_args.consume_iter() {\n             args.push(link_arg);\n         }\n     }\n@@ -935,13 +935,13 @@ pub fn link_args(sess: Session,\n     // to be found at compile time so it is still entirely up to outside\n     // forces to make sure that library can be found at runtime.\n \n-    foreach path in sess.opts.addl_lib_search_paths.iter() {\n+    for path in sess.opts.addl_lib_search_paths.iter() {\n         args.push(~\"-L\" + path.to_str());\n     }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    foreach l in used_libs.iter() { args.push(~\"-l\" + *l); }\n+    for l in used_libs.iter() { args.push(~\"-l\" + *l); }\n \n     if *sess.building_library {\n         args.push(lib_cmd);"}, {"sha": "714e7d666ac38976025ebff0f36f1013c37f344a", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -164,7 +164,7 @@ pub fn create_standard_passes(level: OptLevel) -> ~[~str] {\n }\n \n pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n-    foreach nm in pass_list.iter() {\n+    for nm in pass_list.iter() {\n         match create_pass(*nm) {\n             Some(p) => pm.add_pass(p),\n             None    => sess.warn(fmt!(\"Unknown pass %s\", *nm))\n@@ -189,15 +189,15 @@ pub fn list_passes() {\n     io::println(\"\\nAvailable Passes:\");\n \n     io::println(\"\\nAnalysis Passes:\");\n-    foreach &(name, desc) in analysis_passes.iter() {\n+    for &(name, desc) in analysis_passes.iter() {\n         printfln!(\"    %-30s -- %s\", name, desc);\n     }\n     io::println(\"\\nTransformation Passes:\");\n-    foreach &(name, desc) in transform_passes.iter() {\n+    for &(name, desc) in transform_passes.iter() {\n         printfln!(\"    %-30s -- %s\", name, desc);\n     }\n     io::println(\"\\nUtility Passes:\");\n-    foreach &(name, desc) in utility_passes.iter() {\n+    for &(name, desc) in utility_passes.iter() {\n         printfln!(\"    %-30s -- %s\", name, desc);\n     }\n }\n@@ -315,23 +315,23 @@ static utility_passes : &'static [(&'static str, &'static str)] = &'static [\n fn passes_exist() {\n     let mut failed = ~[];\n     unsafe { llvm::LLVMInitializePasses(); }\n-    foreach &(name,_) in analysis_passes.iter() {\n+    for &(name,_) in analysis_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    foreach &(name,_) in transform_passes.iter() {\n+    for &(name,_) in transform_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    foreach &(name,_) in utility_passes.iter() {\n+    for &(name,_) in utility_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n@@ -342,7 +342,7 @@ fn passes_exist() {\n \n     if failed.len() > 0 {\n         io::println(\"Some passes don't exist:\");\n-        foreach &n in failed.iter() {\n+        for &n in failed.iter() {\n             printfln!(\"    %s\", n);\n         }\n         fail!();"}, {"sha": "571721ed40cee8357f94c34c9f8810263e2fcd73", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -63,7 +63,7 @@ fn get_rpaths(os: session::os,\n     debug!(\"sysroot: %s\", sysroot.to_str());\n     debug!(\"output: %s\", output.to_str());\n     debug!(\"libs:\");\n-    foreach libpath in libs.iter() {\n+    for libpath in libs.iter() {\n         debug!(\"    %s\", libpath.to_str());\n     }\n     debug!(\"target_triple: %s\", target_triple);\n@@ -82,7 +82,7 @@ fn get_rpaths(os: session::os,\n \n     fn log_rpaths(desc: &str, rpaths: &[Path]) {\n         debug!(\"%s rpaths:\", desc);\n-        foreach rpath in rpaths.iter() {\n+        for rpath in rpaths.iter() {\n             debug!(\"    %s\", rpath.to_str());\n         }\n     }\n@@ -149,7 +149,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     }\n \n     let mut path = ~[];\n-    foreach _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n+    for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n \n     path.push_all(split2.slice(start_idx, len2 - 1));\n \n@@ -182,7 +182,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut set = HashSet::new();\n     let mut minimized = ~[];\n-    foreach rpath in rpaths.iter() {\n+    for rpath in rpaths.iter() {\n         if set.insert(rpath.to_str()) {\n             minimized.push(rpath.clone());\n         }"}, {"sha": "1c983057dba0fea980ca8d745a5401104040f5ed", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -508,7 +508,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    foreach &(name, os) in os_names.iter() {\n+    for &(name, os) in os_names.iter() {\n         if triple.contains(name) { return Some(os) }\n     }\n     None\n@@ -522,7 +522,7 @@ static os_names : &'static [(&'static str, session::os)] = &'static [\n     (\"freebsd\", session::os_freebsd)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    foreach &(arch, abi) in architecture_abis.iter() {\n+    for &(arch, abi) in architecture_abis.iter() {\n         if triple.contains(arch) { return Some(abi) }\n     }\n     None\n@@ -611,7 +611,7 @@ pub fn build_session_options(binary: @str,\n                        lint::deny, lint::forbid];\n     let mut lint_opts = ~[];\n     let lint_dict = lint::get_lint_dict();\n-    foreach level in lint_levels.iter() {\n+    for level in lint_levels.iter() {\n         let level_name = lint::level_to_str(*level);\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n@@ -620,7 +620,7 @@ pub fn build_session_options(binary: @str,\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n-        foreach lint_name in flags.iter() {\n+        for lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n@@ -637,9 +637,9 @@ pub fn build_session_options(binary: @str,\n     let mut debugging_opts = 0u;\n     let debug_flags = getopts::opt_strs(matches, \"Z\");\n     let debug_map = session::debugging_opts_map();\n-    foreach debug_flag in debug_flags.iter() {\n+    for debug_flag in debug_flags.iter() {\n         let mut this_bit = 0u;\n-        foreach tuple in debug_map.iter() {\n+        for tuple in debug_map.iter() {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n             if name == debug_flag { this_bit = bit; break; }\n         }"}, {"sha": "8ca68251cb8910265e3b0fa7f22e271908188cc7", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -380,7 +380,7 @@ fn is_extra(cx: &TestCtxt) -> bool {\n fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    foreach test in cx.testfns.iter() {\n+    for test in cx.testfns.iter() {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n "}, {"sha": "d8f142288243508b1c03c4f08e2ae4f7ba5c4a97", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -65,7 +65,7 @@ struct cache_entry {\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n     debug!(\"resolved crates:\");\n-    foreach entry in crate_cache.iter() {\n+    for entry in crate_cache.iter() {\n         debug!(\"cnum: %?\", entry.cnum);\n         debug!(\"span: %?\", entry.span);\n         debug!(\"hash: %?\", entry.hash);\n@@ -97,7 +97,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n         if matches.len() != 1u {\n             diag.handler().warn(\n                 fmt!(\"using multiple versions of crate `%s`\", name));\n-            foreach match_ in matches.iter() {\n+            for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(@\"link\",\n@@ -125,7 +125,7 @@ struct Env {\n fn visit_crate(e: &Env, c: &ast::Crate) {\n     let cstore = e.cstore;\n \n-    foreach a in c.attrs.iter().filter(|m| \"link_args\" == m.name()) {\n+    for a in c.attrs.iter().filter(|m| \"link_args\" == m.name()) {\n         match a.value_str() {\n           Some(ref linkarg) => {\n             cstore::add_used_link_args(cstore, *linkarg);\n@@ -194,7 +194,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n             ast::anonymous => { /* do nothing */ }\n         }\n \n-        foreach m in link_args.iter() {\n+        for m in link_args.iter() {\n             match m.value_str() {\n                 Some(linkarg) => {\n                     cstore::add_used_link_args(cstore, linkarg);\n@@ -223,7 +223,7 @@ fn metas_with_ident(ident: @str, metas: ~[@ast::MetaItem])\n \n fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n                -> Option<int> {\n-    foreach c in e.crate_cache.iter() {\n+    for c in e.crate_cache.iter() {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n@@ -306,7 +306,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     // numbers\n     let mut cnum_map = HashMap::new();\n     let r = decoder::get_crate_deps(cdata);\n-    foreach dep in r.iter() {\n+    for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);"}, {"sha": "33623a40cfb2ac6a1f34b2b743b892dfb454444a", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -84,7 +84,7 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::CrateNum) -> bool {\n \n pub fn iter_crate_data(cstore: &CStore,\n                        i: &fn(ast::CrateNum, @crate_metadata)) {\n-    foreach (&k, &v) in cstore.metas.iter() {\n+    for (&k, &v) in cstore.metas.iter() {\n         i(k, v);\n     }\n }\n@@ -114,7 +114,7 @@ pub fn get_used_libraries<'a>(cstore: &'a CStore) -> &'a [@str] {\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    foreach s in args.split_iter(' ') {\n+    for s in args.split_iter(' ') {\n         cstore.used_link_args.push(s.to_managed());\n     }\n }\n@@ -148,7 +148,7 @@ struct crate_hash {\n pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n     let mut result = ~[];\n \n-    foreach (_, &cnum) in cstore.extern_mod_crate_map.iter() {\n+    for (_, &cnum) in cstore.extern_mod_crate_map.iter() {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);\n@@ -165,7 +165,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n     };\n \n     debug!(\"sorted:\");\n-    foreach x in sorted.iter() {\n+    for x in sorted.iter() {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n "}, {"sha": "c3097d1aa66577c85ff5d71324ccf208e85c4c6c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -761,7 +761,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n     let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    foreach did in variant_ids.iter() {\n+    for did in variant_ids.iter() {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::def_id { crate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n@@ -974,7 +974,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     };\n \n     let mut static_impl_methods = ~[];\n-    foreach impl_method_id in impl_method_ids.iter() {\n+    for impl_method_id in impl_method_ids.iter() {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n         let family = item_family(impl_method_doc);\n         match family {\n@@ -1171,7 +1171,7 @@ fn list_meta_items(intr: @ident_interner,\n                    meta_items: ebml::Doc,\n                    out: @io::Writer) {\n     let r = get_meta_items(meta_items);\n-    foreach mi in r.iter() {\n+    for mi in r.iter() {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n@@ -1181,7 +1181,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n     let r = get_attributes(md);\n-    foreach attr in r.iter() {\n+    for attr in r.iter() {\n         out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n@@ -1224,7 +1224,7 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n-    foreach dep in r.iter() {\n+    for dep in r.iter() {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n                  dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));"}, {"sha": "d847d8511265344aed7f2a593543663b6ea136d1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -120,7 +120,7 @@ fn encode_region_param(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    foreach rp in opt_rp.iter() {\n+    for rp in opt_rp.iter() {\n         ebml_w.start_tag(tag_region_param);\n         rp.encode(ebml_w);\n         ebml_w.end_tag();\n@@ -193,7 +193,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n         tcx: ecx.tcx,\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n     };\n-    foreach param in params.iter() {\n+    for param in params.iter() {\n         ebml_w.start_tag(tag);\n         tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n         ebml_w.end_tag();\n@@ -250,7 +250,7 @@ fn encode_type(ecx: &EncodeContext,\n fn encode_transformed_self_ty(ecx: &EncodeContext,\n                               ebml_w: &mut writer::Encoder,\n                               opt_typ: Option<ty::t>) {\n-    foreach &typ in opt_typ.iter() {\n+    for &typ in opt_typ.iter() {\n         ebml_w.start_tag(tag_item_method_transformed_self_ty);\n         write_type(ecx, ebml_w, typ);\n         ebml_w.end_tag();\n@@ -327,7 +327,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: LOCAL_CRATE, node: id });\n-    foreach variant in variants.iter() {\n+    for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n@@ -375,7 +375,7 @@ fn encode_path(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_path);\n     ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-    foreach pe in path.iter() {\n+    for pe in path.iter() {\n         encode_path_elt(ecx, ebml_w, *pe);\n     }\n     encode_path_elt(ecx, ebml_w, name);\n@@ -405,8 +405,8 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          -> bool {\n     match ecx.tcx.inherent_impls.find(&exp.def_id) {\n         Some(implementations) => {\n-            foreach &base_impl in implementations.iter() {\n-                foreach &m in base_impl.methods.iter() {\n+            for &base_impl in implementations.iter() {\n+                for &m in base_impl.methods.iter() {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n                                                         m.def_id, m.ident);\n@@ -426,7 +426,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n         Some(methods) => {\n-            foreach &m in methods.iter() {\n+            for &m in methods.iter() {\n                 if m.explicit_self == ast::sty_static {\n                     encode_reexported_static_method(ecx, ebml_w, exp,\n                                                     m.def_id, m.ident);\n@@ -486,7 +486,7 @@ fn each_auxiliary_node_id(item: @item, callback: &fn(NodeId) -> bool)\n     let mut continue = true;\n     match item.node {\n         item_enum(ref enum_def, _) => {\n-            foreach variant in enum_def.variants.iter() {\n+            for variant in enum_def.variants.iter() {\n                 continue = callback(variant.node.id);\n                 if !continue {\n                     break\n@@ -518,7 +518,7 @@ fn encode_reexports(ecx: &EncodeContext,\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            foreach exp in exports.iter() {\n+            for exp in exports.iter() {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n                        exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -553,7 +553,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n \n     // Encode info about all the module children.\n-    foreach item in md.items.iter() {\n+    for item in md.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n@@ -664,7 +664,7 @@ fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n \n fn encode_provided_source(ebml_w: &mut writer::Encoder,\n                           source_opt: Option<def_id>) {\n-    foreach source in source_opt.iter() {\n+    for source in source_opt.iter() {\n         ebml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_str(*source);\n         ebml_w.writer.write(s.as_bytes());\n@@ -685,7 +685,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    foreach field in fields.iter() {\n+    for field in fields.iter() {\n         let (nm, vis) = match field.node.kind {\n             named_field(nm, vis) => (nm, vis),\n             unnamed_field => (special_idents::unnamed_field, inherited)\n@@ -772,7 +772,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n \n-    foreach ast_method in ast_method_opt.iter() {\n+    for ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs.len();\n         if num_params > 0u || is_default_impl\n             || should_inline(ast_method.attrs) {\n@@ -882,7 +882,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n \n         // Encode all the items in this module.\n-        foreach foreign_item in fm.items.iter() {\n+        for foreign_item in fm.items.iter() {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n             ebml_w.end_tag();\n@@ -909,7 +909,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 't');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n-        foreach v in (*enum_definition).variants.iter() {\n+        for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n@@ -950,7 +950,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        foreach f in struct_def.fields.iter() {\n+        for f in struct_def.fields.iter() {\n             match f.node.kind {\n                 named_field(ident, vis) => {\n                    ebml_w.start_tag(tag_item_field);\n@@ -1010,13 +1010,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        foreach method in imp.methods.iter() {\n+        for method in imp.methods.iter() {\n             ebml_w.start_tag(tag_item_impl_method);\n             let s = def_to_str(method.def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n-        foreach ast_trait_ref in opt_trait.iter() {\n+        for ast_trait_ref in opt_trait.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n@@ -1035,7 +1035,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // appear first in the impl structure, in the same order they do\n         // in the ast. This is a little sketchy.\n         let num_implemented_methods = ast_methods.len();\n-        foreach (i, m) in imp.methods.iter().enumerate() {\n+        for (i, m) in imp.methods.iter().enumerate() {\n             let ast_method = if i < num_implemented_methods {\n                 Some(ast_methods[i])\n             } else { None };\n@@ -1063,7 +1063,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        foreach &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n+        for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n@@ -1073,15 +1073,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        foreach ast_trait_ref in super_traits.iter() {\n+        for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n         let r = ty::trait_method_def_ids(tcx, def_id);\n-        foreach (i, &method_def_id) in r.iter().enumerate() {\n+        for (i, &method_def_id) in r.iter().enumerate() {\n             assert_eq!(method_def_id.crate, ast::LOCAL_CRATE);\n \n             let method_ty = ty::method(tcx, method_def_id);\n@@ -1257,14 +1257,14 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n                 index: ~[entry<T>])\n                 -> ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n-    foreach _ in range(0u, 256u) { buckets.push(@mut ~[]); };\n-    foreach elt in index.iter() {\n+    for _ in range(0u, 256u) { buckets.push(@mut ~[]); };\n+    for elt in index.iter() {\n         let h = elt.val.hash() as uint;\n         buckets[h % 256].push((*elt).clone());\n     }\n \n     let mut buckets_frozen = ~[];\n-    foreach bucket in buckets.iter() {\n+    for bucket in buckets.iter() {\n         buckets_frozen.push(@/*bad*/(**bucket).clone());\n     }\n     return buckets_frozen;\n@@ -1278,10 +1278,10 @@ fn encode_index<T:'static>(\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n-    foreach bucket in buckets.iter() {\n+    for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        foreach elt in (**bucket).iter() {\n+        for elt in (**bucket).iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n@@ -1292,7 +1292,7 @@ fn encode_index<T:'static>(\n     }\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n-    foreach pos in bucket_locs.iter() {\n+    for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n@@ -1338,7 +1338,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n-        foreach inner_item in items.iter() {\n+        for inner_item in items.iter() {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n@@ -1348,7 +1348,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n \n fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n     ebml_w.start_tag(tag_attributes);\n-    foreach attr in attrs.iter() {\n+    for attr in attrs.iter() {\n         ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml_w.end_tag();\n@@ -1378,7 +1378,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n         let mut meta_items = ~[name_item, vers_item];\n \n-        foreach &mi in items.iter().filter(|mi| \"name\" != mi.name() && \"vers\" != mi.name()) {\n+        for &mi in items.iter().filter(|mi| \"name\" != mi.name() && \"vers\" != mi.name()) {\n             meta_items.push(mi);\n         }\n         let link_item = attr::mk_list_item(@\"link\", meta_items);\n@@ -1388,7 +1388,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n     let mut attrs = ~[];\n     let mut found_link_attr = false;\n-    foreach attr in crate.attrs.iter() {\n+    for attr in crate.attrs.iter() {\n         attrs.push(\n             if \"link\" != attr.name()  {\n                 *attr\n@@ -1430,7 +1430,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        foreach n in deps.iter() {\n+        for n in deps.iter() {\n             assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -1444,7 +1444,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(ecx, cstore);\n-    foreach dep in r.iter() {\n+    for dep in r.iter() {\n         encode_crate_dep(ecx, ebml_w, *dep);\n     }\n     ebml_w.end_tag();\n@@ -1454,7 +1454,7 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     do ecx.tcx.lang_items.each_item |def_id, i| {\n-        foreach id in def_id.iter() {\n+        for id in def_id.iter() {\n             if id.crate == LOCAL_CRATE {\n                 ebml_w.start_tag(tag_lang_items_item);\n \n@@ -1479,7 +1479,7 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n-    foreach link_arg in link_args.iter() {\n+    for link_arg in link_args.iter() {\n         ebml_w.start_tag(tag_link_args_arg);\n         ebml_w.writer.write_str(link_arg.to_str());\n         ebml_w.end_tag();\n@@ -1493,7 +1493,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_misc_info);\n     ebml_w.start_tag(tag_misc_info_crate_items);\n-    foreach &item in crate.module.items.iter() {\n+    for &item in crate.module.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n@@ -1630,7 +1630,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-        foreach e in wr.bytes.iter() {\n+        for e in wr.bytes.iter() {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }"}, {"sha": "2422be3960b44e7af38f90d20f90e7d3be1fd49c", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -91,7 +91,7 @@ pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n         let r = os::list_dir_path(lib_search_path);\n-        foreach path in r.iter() {\n+        for path in r.iter() {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(path);\n             if maybe_picked.is_some() {"}, {"sha": "9330cfc5c88b48fc4deade90b90c0298348955fd", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -128,7 +128,7 @@ fn find_library_crate_aux(\n             cx.diag.span_err(\n                     cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n                 cx.diag.handler().note(\"candidates:\");\n-                foreach pair in matches.iter() {\n+                for pair in matches.iter() {\n                     let ident = pair.first();\n                     let data = pair.second();\n                     cx.diag.handler().note(fmt!(\"path: %s\", ident));\n@@ -142,7 +142,7 @@ fn find_library_crate_aux(\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n-    foreach m in metas.iter() {\n+    for m in metas.iter() {\n         match m.name_str_pair() {\n             Some((name, s)) if \"name\" == name => { return s; }\n             _ => {}\n@@ -155,7 +155,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n                           attrs: ~[ast::Attribute]) {\n     let r = attr::find_linkage_metas(attrs);\n-    foreach mi in r.iter() {\n+    for mi in r.iter() {\n         diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }"}, {"sha": "ec50f564385c3a9d3f777d0f9073f2f785deef79", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -123,7 +123,7 @@ fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n-    foreach t in substs.tps.iter() { enc_ty(w, cx, *t); }\n+    for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     w.write_char(']');\n }\n \n@@ -134,7 +134,7 @@ fn enc_region_substs(w: @io::Writer, cx: @ctxt, substs: &ty::RegionSubsts) {\n         }\n         ty::NonerasedRegions(ref regions) => {\n             w.write_char('n');\n-            foreach &r in regions.iter() {\n+            for &r in regions.iter() {\n                 enc_region(w, cx, r);\n             }\n             w.write_char('.');\n@@ -288,7 +288,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       }\n       ty::ty_tup(ref ts) => {\n         w.write_str(&\"T[\");\n-        foreach t in ts.iter() { enc_ty(w, cx, *t); }\n+        for t in ts.iter() { enc_ty(w, cx, *t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -405,7 +405,7 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n \n fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    foreach ty in fsig.inputs.iter() {\n+    for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n     w.write_char(']');\n@@ -423,7 +423,7 @@ fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n         true\n     };\n \n-    foreach &tp in bs.trait_bounds.iter() {\n+    for &tp in bs.trait_bounds.iter() {\n         w.write_char('I');\n         enc_trait_ref(w, cx, tp);\n     }"}, {"sha": "34f4425a871ddbe7ed2503b9d2f896c617928b9a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -854,7 +854,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.def_map.find(&id);\n-        foreach def in r.iter() {\n+        for def in r.iter() {\n             do ebml_w.tag(c::tag_table_def) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -866,7 +866,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.node_types.find(&(id as uint));\n-        foreach &ty in r.iter() {\n+        for &ty in r.iter() {\n             do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -878,7 +878,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.node_type_substs.find(&id);\n-        foreach tys in r.iter() {\n+        for tys in r.iter() {\n             do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -890,7 +890,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.freevars.find(&id);\n-        foreach &fv in r.iter() {\n+        for &fv in r.iter() {\n             do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -905,7 +905,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     let lid = ast::def_id { crate: ast::LOCAL_CRATE, node: id };\n     {\n         let r = tcx.tcache.find(&lid);\n-        foreach &tpbt in r.iter() {\n+        for &tpbt in r.iter() {\n             do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -917,7 +917,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.ty_param_defs.find(&id);\n-        foreach &type_param_def in r.iter() {\n+        for &type_param_def in r.iter() {\n             do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -929,7 +929,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = maps.method_map.find(&id);\n-        foreach &mme in r.iter() {\n+        for &mme in r.iter() {\n             do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -941,7 +941,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = maps.vtable_map.find(&id);\n-        foreach &dr in r.iter() {\n+        for &dr in r.iter() {\n             do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -953,7 +953,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = tcx.adjustments.find(&id);\n-        foreach adj in r.iter() {\n+        for adj in r.iter() {\n             do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -965,7 +965,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     {\n         let r = maps.capture_map.find(&id);\n-        foreach &cap_vars in r.iter() {\n+        for &cap_vars in r.iter() {\n             do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n                 ebml_w.id(id);\n                 do ebml_w.tag(c::tag_table_val) |ebml_w| {\n@@ -1054,7 +1054,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n-            foreach i in range(doc.start, doc.end) {\n+            for i in range(doc.start, doc.end) {\n                 str.push_char(doc.data[i] as char);\n             }\n             str"}, {"sha": "646840f1e306361c535ac52145440b06b0d691fb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -116,7 +116,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         do self.each_in_scope_loan(scope_id) |loan| {\n             let mut ret = true;\n-            foreach restr in loan.restrictions.iter() {\n+            for restr in loan.restrictions.iter() {\n                 if restr.loan_path == loan_path {\n                     if !op(loan, restr) {\n                         ret = false;\n@@ -152,16 +152,16 @@ impl<'self> CheckLoanCtxt<'self> {\n         debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n         do self.each_issued_loan(scope_id) |issued_loan| {\n-            foreach &new_loan_index in new_loan_indices.iter() {\n+            for &new_loan_index in new_loan_indices.iter() {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n             true\n         };\n \n-        foreach i in range(0u, new_loan_indices.len()) {\n+        for i in range(0u, new_loan_indices.len()) {\n             let old_loan = &self.all_loans[new_loan_indices[i]];\n-            foreach j in range(i+1, new_loan_indices.len()) {\n+            for j in range(i+1, new_loan_indices.len()) {\n                 let new_loan = &self.all_loans[new_loan_indices[j]];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n@@ -211,7 +211,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         };\n         debug!(\"illegal_if=%?\", illegal_if);\n \n-        foreach restr in loan1.restrictions.iter() {\n+        for restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { loop; }\n             if restr.loan_path != loan2.loan_path { loop; }\n \n@@ -652,7 +652,7 @@ fn check_loans_in_fn<'a>(fk: &oldvisit::fn_kind,\n                                 closure_id: ast::NodeId,\n                                 span: span) {\n         let cap_vars = this.bccx.capture_map.get(&closure_id);\n-        foreach cap_var in cap_vars.iter() {\n+        for cap_var in cap_vars.iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n             this.check_if_path_is_moved(closure_id, span,\n@@ -713,7 +713,7 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n               let r = opt_loan_path(cmt);\n-              foreach &lp in r.iter() {\n+              for &lp in r.iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }"}, {"sha": "54a5c09a0e9792e38b35be8383e6e24fd4906103", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -70,7 +70,7 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n                        move_data: &mut MoveData,\n                        closure_expr: @ast::expr) {\n     let captured_vars = bccx.capture_map.get(&closure_expr.id);\n-    foreach captured_var in captured_vars.iter() {\n+    for captured_var in captured_vars.iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let fvar_id = ast_util::def_id_of_def(captured_var.def).node;"}, {"sha": "b970a6585f6cd0b09d957bc22f7af454327079bf", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -189,15 +189,15 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n     {\n         let r = ex.get_callee_id();\n-        foreach callee_id in r.iter() {\n+        for callee_id in r.iter() {\n             this.id_range.add(*callee_id);\n         }\n     }\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     {\n         let r = tcx.adjustments.find(&ex.id);\n-        foreach &adjustments in r.iter() {\n+        for &adjustments in r.iter() {\n             this.guarantee_adjustments(ex, *adjustments);\n         }\n     }\n@@ -240,8 +240,8 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n-        foreach arm in arms.iter() {\n-            foreach pat in arm.pats.iter() {\n+        for arm in arms.iter() {\n+            for pat in arm.pats.iter() {\n                 this.gather_pat(cmt, *pat, Some((arm.body.id, ex.id)));\n             }\n         }\n@@ -619,7 +619,7 @@ impl GatherLoanCtxt {\n          */\n \n         let mc_ctxt = self.bccx.mc_ctxt();\n-        foreach arg in decl.inputs.iter() {\n+        for arg in decl.inputs.iter() {\n             let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n \n             let arg_cmt = mc_ctxt.cat_rvalue("}, {"sha": "ad32eb0c805e4d4369f343e734257af37da0e15d", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -139,7 +139,7 @@ impl RestrictionsContext {\n                 // static errors. For example, if there is code like\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n-                //    foreach e in v.iter() {\n+                //    for e in v.iter() {\n                 //        v.push(e + 1);\n                 //    }\n                 //\n@@ -151,7 +151,7 @@ impl RestrictionsContext {\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n                 //    let w = v;\n-                //    foreach e in v.iter() {\n+                //    for e in v.iter() {\n                 //        w.push(e + 1);\n                 //    }\n                 //\n@@ -164,7 +164,7 @@ impl RestrictionsContext {\n                 //    }\n                 //    ...\n                 //    let v: &V = ...;\n-                //    foreach e in v.get_list().iter() {\n+                //    for e in v.get_list().iter() {\n                 //        v.get_list().push(e + 1);\n                 //    }\n                 match opt_loan_path(cmt_base) {"}, {"sha": "3db90ed5d74948981544249b1e153be66905128b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -139,7 +139,7 @@ fn borrowck_fn(fk: &oldvisit::fn_kind,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n-            foreach (loan_idx, loan) in all_loans.iter().enumerate() {\n+            for (loan_idx, loan) in all_loans.iter().enumerate() {\n                 loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n                 loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }"}, {"sha": "164139ad733bfdff7eda9c4ceb2da7a38afffd0e", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -372,22 +372,22 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        foreach (i, move) in self.moves.iter().enumerate() {\n+        for (i, move) in self.moves.iter().enumerate() {\n             dfcx_moves.add_gen(move.id, i);\n         }\n \n-        foreach (i, assignment) in self.var_assignments.iter().enumerate() {\n+        for (i, assignment) in self.var_assignments.iter().enumerate() {\n             dfcx_assign.add_gen(assignment.id, i);\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        foreach assignment in self.path_assignments.iter() {\n+        for assignment in self.path_assignments.iter() {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n-        foreach path in self.paths.iter() {\n+        for path in self.paths.iter() {\n             match *path.loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n@@ -399,7 +399,7 @@ impl MoveData {\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        foreach (assignment_index, assignment) in self.var_assignments.iter().enumerate() {\n+        for (assignment_index, assignment) in self.var_assignments.iter().enumerate() {\n             match *self.path(assignment.path).loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n@@ -559,7 +559,7 @@ impl FlowedMoveData {\n                     ret = false;\n                 }\n             } else {\n-                foreach &loan_path_index in opt_loan_path_index.iter() {\n+                for &loan_path_index in opt_loan_path_index.iter() {\n                     let cont = do self.move_data.each_base_path(moved_path) |p| {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`"}, {"sha": "f1d8502ff5fc4a9be81847e2f64d947059668851", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -53,7 +53,7 @@ pub fn construct(tcx: ty::ctxt,\n impl CFGBuilder {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n-        foreach &stmt in blk.stmts.iter() {\n+        for &stmt in blk.stmts.iter() {\n             stmts_exit = self.stmt(stmt, stmts_exit);\n         }\n \n@@ -151,7 +151,7 @@ impl CFGBuilder {\n             self.pat(pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node([]);\n-            foreach &pat in pats.iter() {\n+            for &pat in pats.iter() {\n                 let pat_exit = self.pat(pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n@@ -297,7 +297,7 @@ impl CFGBuilder {\n \n                 let expr_exit = self.add_node(expr.id, []);\n                 let mut guard_exit = discr_exit;\n-                foreach arm in arms.iter() {\n+                for arm in arms.iter() {\n                     guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n                     let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n                     let body_exit = self.block(&arm.body, pats_exit);    // 4\n@@ -460,7 +460,7 @@ impl CFGBuilder {\n         assert!(!self.exit_map.contains_key(&id));\n         let node = self.graph.add_node(CFGNodeData {id: id});\n         self.exit_map.insert(id, node);\n-        foreach &pred in preds.iter() {\n+        for &pred in preds.iter() {\n             self.add_contained_edge(pred, node);\n         }\n         node\n@@ -498,7 +498,7 @@ impl CFGBuilder {\n             Some(_) => {\n                 match self.tcx.def_map.find(&expr.id) {\n                     Some(&ast::def_label(loop_id)) => {\n-                        foreach l in self.loop_scopes.iter() {\n+                        for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n                                 return *l;\n                             }"}, {"sha": "f9ef6dabcd64cfc32eb97d514879a14b6e6342f0", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -47,8 +47,8 @@ pub fn check_item(sess: Session,\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n-        foreach var in (*enum_definition).variants.iter() {\n-            foreach ex in var.node.disr_expr.iter() {\n+        for var in (*enum_definition).variants.iter() {\n+            for ex in var.node.disr_expr.iter() {\n                 (v.visit_expr)(*ex, (true, v));\n             }\n         }"}, {"sha": "4de096428f26ff4f806047bafaa379fe2697ab4b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -57,7 +57,7 @@ pub fn check_expr(cx: @MatchCheckCtxt,\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n-        foreach arm in arms.iter() {\n+        for arm in arms.iter() {\n             check_legality_of_move_bindings(cx,\n                                             arm.guard.is_some(),\n                                             arm.pats);\n@@ -102,8 +102,8 @@ pub fn check_expr(cx: @MatchCheckCtxt,\n // Check for unreachable patterns\n pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n     let mut seen = ~[];\n-    foreach arm in arms.iter() {\n-        foreach pat in arm.pats.iter() {\n+    for arm in arms.iter() {\n+        for pat in arm.pats.iter() {\n \n             // Check that we do not match against a static NaN (#6804)\n             let pat_matches_nan: &fn(@pat) -> bool = |p| {\n@@ -246,7 +246,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n-                foreach va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n+                for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n@@ -264,7 +264,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                     _ => max_len\n                   }\n                 };\n-                foreach n in iterator::range(0u, max_len + 1) {\n+                for n in iterator::range(0u, max_len + 1) {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n                     ref u => return *u,\n@@ -368,24 +368,24 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_struct(*) => {\n-        foreach r in m.iter() {\n+        for r in m.iter() {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n-        foreach r in m.iter() {\n+        for r in m.iter() {\n             let r = pat_ctor_id(cx, r[0]);\n-            foreach id in r.iter() {\n+            for id in r.iter() {\n                 if !found.contains(id) {\n                     found.push(*id);\n                 }\n             }\n         }\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n-            foreach v in (*variants).iter() {\n+            for v in (*variants).iter() {\n                 if !found.iter().any(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n@@ -397,7 +397,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_bool => {\n         let mut true_found = false;\n         let mut false_found = false;\n-        foreach r in m.iter() {\n+        for r in m.iter() {\n             match pat_ctor_id(cx, r[0]) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n@@ -437,7 +437,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        foreach &(length, slice) in sorted_vec_lens.iter() {\n+        for &(length, slice) in sorted_vec_lens.iter() {\n             if length != next {\n                 missing = Some(next);\n                 break;\n@@ -783,7 +783,7 @@ pub fn check_fn(cx: &MatchCheckCtxt,\n                 (s, v): ((),\n                          oldvisit::vt<()>)) {\n     oldvisit::visit_fn(kind, decl, body, sp, id, (s, v));\n-    foreach input in decl.inputs.iter() {\n+    for input in decl.inputs.iter() {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n                                  \"refutable pattern in function argument\");\n@@ -836,7 +836,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let def_map = tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n-    foreach pat in pats.iter() {\n+    for pat in pats.iter() {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n                 bind_by_ref(_) => {\n@@ -873,7 +873,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     if !any_by_move { return; } // pointless micro-optimization\n-    foreach pat in pats.iter() {\n+    for pat in pats.iter() {\n         do walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {"}, {"sha": "330e44893f04a733d137714bc0819cef65396943", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -176,7 +176,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                             variant_def: ast::def_id)\n                        -> Option<@expr> {\n     fn variant_expr(variants: &[ast::variant], id: ast::NodeId) -> Option<@expr> {\n-        foreach variant in variants.iter() {\n+        for variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;\n             }"}, {"sha": "d2808b01e5b6d293ac27b18e8517dfbb1c04bf76", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -266,10 +266,10 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                 f: &fn(uint) -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n \n-        foreach (word_index, &word) in words.iter().enumerate() {\n+        for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n                 let base_index = word_index * uint::bits;\n-                foreach offset in range(0u, uint::bits) {\n+                for offset in range(0u, uint::bits) {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n@@ -391,7 +391,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n         self.merge_with_entry_set(blk.id, in_out);\n \n-        foreach &stmt in blk.stmts.iter() {\n+        for &stmt in blk.stmts.iter() {\n             self.walk_stmt(stmt, in_out, loop_scopes);\n         }\n \n@@ -512,7 +512,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                         loop_kind: ForLoop,\n                         break_bits: reslice(in_out).to_owned()\n                     });\n-                    foreach input in decl.inputs.iter() {\n+                    for input in decl.inputs.iter() {\n                         self.walk_pat(input.pat, func_bits, loop_scopes);\n                     }\n                     self.walk_block(body, func_bits, loop_scopes);\n@@ -631,7 +631,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 // together the bits from each arm:\n                 self.reset(in_out);\n \n-                foreach arm in arms.iter() {\n+                for arm in arms.iter() {\n                     // in_out reflects the discr and all guards to date\n                     self.walk_opt_expr(arm.guard, guards, loop_scopes);\n \n@@ -706,7 +706,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_struct(_, ref fields, with_expr) => {\n-                foreach field in fields.iter() {\n+                for field in fields.iter() {\n                     self.walk_expr(field.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n@@ -767,10 +767,10 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_inline_asm(ref inline_asm) => {\n-                foreach &(_, expr) in inline_asm.inputs.iter() {\n+                for &(_, expr) in inline_asm.inputs.iter() {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n-                foreach &(_, expr) in inline_asm.outputs.iter() {\n+                for &(_, expr) in inline_asm.outputs.iter() {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n             }\n@@ -838,7 +838,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   exprs: &[@ast::expr],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        foreach &expr in exprs.iter() {\n+        for &expr in exprs.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -847,7 +847,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                      opt_expr: Option<@ast::expr>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut ~[LoopScope]) {\n-        foreach &expr in opt_expr.iter() {\n+        for &expr in opt_expr.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -901,7 +901,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n         let initial_state = reslice(in_out).to_owned();\n-        foreach &pat in pats.iter() {\n+        for &pat in pats.iter() {\n             let mut temp = initial_state.clone();\n             self.walk_pat(pat, temp, loop_scopes);\n             join_bits(&self.dfcx.oper, temp, in_out);\n@@ -949,7 +949,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::max_value} else {0};\n-        foreach b in bits.mut_iter() { *b = e; }\n+        for b in bits.mut_iter() { *b = e; }\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n@@ -997,9 +997,9 @@ fn bits_to_str(words: &[uint]) -> ~str {\n \n     // Note: this is a little endian printout of bytes.\n \n-    foreach &word in words.iter() {\n+    for &word in words.iter() {\n         let mut v = word;\n-        foreach _ in range(0u, uint::bytes) {\n+        for _ in range(0u, uint::bytes) {\n             result.push_char(sep);\n             result.push_str(fmt!(\"%02x\", v & 0xFF));\n             v >>= 8;\n@@ -1026,7 +1026,7 @@ fn bitwise(out_vec: &mut [uint],\n            op: &fn(uint, uint) -> uint) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    foreach i in range(0u, out_vec.len()) {\n+    for i in range(0u, out_vec.len()) {\n         let old_val = out_vec[i];\n         let new_val = op(old_val, in_vec[i]);\n         out_vec[i] = new_val;"}, {"sha": "1bf5c944fabb00e0b8c5c34756d37f98ffb7b62a", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -138,7 +138,7 @@ fn configure_main(ctxt: @mut EntryContext) {\n                                    but you have one or more functions named 'main' that are not \\\n                                    defined at the crate level. Either move the definition or \\\n                                    attach the `#[main]` attribute to override this behavior.\");\n-                foreach &(_, span) in this.non_main_fns.iter() {\n+                for &(_, span) in this.non_main_fns.iter() {\n                     this.session.span_note(span, \"here is a function named 'main'\");\n                 }\n             }"}, {"sha": "28d24b169ca4ab187752b60505645de2dc7f3cfc", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -247,7 +247,7 @@ impl<N,E> Graph<N,E> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            foreach (i, edge) in self.edges.iter().enumerate() {\n+            for (i, edge) in self.edges.iter().enumerate() {\n                 changed |= op(iteration, EdgeIndex(i), edge);\n             }\n         }"}, {"sha": "3bdf0c0f6dcb84c32db21792a769cb9c923b17a4", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -238,7 +238,7 @@ fn check_fn(\n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n         let r = freevars::get_freevars(cx.tcx, fn_id);\n-        foreach fv in r.iter() {\n+        for fv in r.iter() {\n             chk(cx, *fv);\n         }\n     }\n@@ -256,7 +256,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, oldvisit::vt<Context>)) {\n     };\n     {\n         let r = cx.tcx.node_type_substs.find(&type_parameter_id);\n-        foreach ts in r.iter() {\n+        for ts in r.iter() {\n             let type_param_defs = match e.node {\n               expr_path(_) => {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n@@ -280,7 +280,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, oldvisit::vt<Context>)) {\n                       ts.repr(cx.tcx),\n                       type_param_defs.repr(cx.tcx));\n             }\n-            foreach (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n+            for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n                 check_typaram_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n             }\n         }\n@@ -318,11 +318,11 @@ fn check_ty(aty: &Ty, (cx, v): (Context, oldvisit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n-          foreach ts in r.iter() {\n+          for ts in r.iter() {\n               let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n               let type_param_defs =\n                   ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n-              foreach (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n+              for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n                   check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n               }\n           }"}, {"sha": "0dfad430f4d656389ecb175cf347e41c67f510ad", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -412,7 +412,7 @@ impl<'self> LanguageItemCollector<'self> {\n         let this: *mut LanguageItemCollector = &mut *self;\n         visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n-                foreach attribute in item.attrs.iter() {\n+                for attribute in item.attrs.iter() {\n                     unsafe {\n                         (*this).match_and_collect_meta_item(\n                             local_def(item.id),"}, {"sha": "bbcb40df77528f13b1deed76e89cdc6a29abc305", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -286,7 +286,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n  */\n pub fn get_lint_dict() -> LintDict {\n     let mut map = HashMap::new();\n-    foreach &(k, v) in lint_table.iter() {\n+    for &(k, v) in lint_table.iter() {\n         map.insert(k, v);\n     }\n     return map;\n@@ -354,7 +354,7 @@ impl Context {\n     }\n \n     fn lint_to_str(&self, lint: lint) -> &'static str {\n-        foreach (k, v) in self.dict.iter() {\n+        for (k, v) in self.dict.iter() {\n             if v.lint == lint {\n                 return *k;\n             }\n@@ -390,7 +390,7 @@ impl Context {\n             allow => fail!(),\n         }\n \n-        foreach &span in note.iter() {\n+        for &span in note.iter() {\n             self.tcx.sess.span_note(span, \"lint level defined here\");\n         }\n     }\n@@ -474,7 +474,7 @@ impl Context {\n         // pair instead of just one visitor.\n         match n {\n             Item(it) => {\n-                foreach visitor in self.visitors.iter() {\n+                for visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(orig, stopping) => {\n                             (orig.visit_item)(it, (self, stopping));\n@@ -486,7 +486,7 @@ impl Context {\n                 }\n             }\n             Crate(c) => {\n-                foreach visitor in self.visitors.iter() {\n+                for visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(_, stopping) => {\n                             oldvisit::visit_crate(c, (self, stopping))\n@@ -501,7 +501,7 @@ impl Context {\n             // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n-                foreach visitor in self.visitors.iter() {\n+                for visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(orig, stopping) => {\n                             let fk = oldvisit::fk_method(m.ident,\n@@ -536,9 +536,9 @@ pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::Attribute],\n                  f: &fn(@ast::MetaItem, level, @str) -> bool) -> bool {\n     let xs = [allow, warn, deny, forbid];\n-    foreach &level in xs.iter() {\n+    for &level in xs.iter() {\n         let level_name = level_to_str(level);\n-        foreach attr in attrs.iter().filter(|m| level_name == m.name()) {\n+        for attr in attrs.iter().filter(|m| level_name == m.name()) {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::MetaList(_, ref metas) => metas,\n@@ -547,7 +547,7 @@ pub fn each_lint(sess: session::Session,\n                     loop;\n                 }\n             };\n-            foreach meta in metas.iter() {\n+            for meta in metas.iter() {\n                 match meta.node {\n                     ast::MetaWord(lintname) => {\n                         if !f(*meta, level, lintname) {\n@@ -751,15 +751,15 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     }\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n-        foreach input in decl.inputs.iter() {\n+        for input in decl.inputs.iter() {\n             check_ty(cx, &input.ty);\n         }\n         check_ty(cx, &decl.output)\n     }\n \n     match it.node {\n       ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n-        foreach ni in nmod.items.iter() {\n+        for ni in nmod.items.iter() {\n             match ni.node {\n                 ast::foreign_item_fn(ref decl, _) => {\n                     check_foreign_fn(cx, decl);\n@@ -801,7 +801,7 @@ fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n \n fn check_type(cx: &Context, span: span, ty: ty::t) {\n     let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n-    foreach lint in xs.iter() {\n+    for lint in xs.iter() {\n         check_type_for_lint(cx, *lint, span, ty);\n     }\n }\n@@ -820,7 +820,7 @@ fn check_item_heap(cx: &Context, it: &ast::item) {\n     // If it's a struct, we also have to check the fields' types\n     match it.node {\n         ast::item_struct(struct_def, _) => {\n-            foreach struct_field in struct_def.fields.iter() {\n+            for struct_field in struct_def.fields.iter() {\n                 check_type(cx, struct_field.span,\n                            ty::node_id_to_type(cx.tcx,\n                                                struct_field.node.id));\n@@ -892,7 +892,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n         }\n         ast::item_enum(ref enum_definition, _) => {\n             check_case(cx, \"type\", it.ident, it.span);\n-            foreach variant in enum_definition.variants.iter() {\n+            for variant in enum_definition.variants.iter() {\n                 check_case(cx, \"variant\", variant.node.name, variant.span);\n             }\n         }\n@@ -955,7 +955,7 @@ fn lint_unused_mut() -> oldvisit::vt<@mut Context> {\n     }\n \n     fn visit_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n-        foreach arg in fd.inputs.iter() {\n+        for arg in fd.inputs.iter() {\n             if arg.is_mutbl {\n                 check_pat(cx, arg.pat);\n             }\n@@ -994,7 +994,7 @@ fn lint_session(cx: @mut Context) -> @visit::Visitor<()> {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n-                foreach (lint, span, msg) in l.consume_iter() {\n+                for (lint, span, msg) in l.consume_iter() {\n                     cx.span_lint(lint, span, msg)\n                 }\n             }\n@@ -1094,7 +1094,7 @@ fn lint_missing_doc() -> oldvisit::vt<@mut Context> {\n                 ast::item_struct(sdef, _) if it.vis == ast::public => {\n                     check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a struct\");\n-                    foreach field in sdef.fields.iter() {\n+                    for field in sdef.fields.iter() {\n                         match field.node.kind {\n                             ast::named_field(_, vis) if vis != ast::private => {\n                                 check_attrs(cx, field.node.attrs, field.span,\n@@ -1137,12 +1137,12 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n     };\n \n     // Install defaults.\n-    foreach (_, spec) in cx.dict.iter() {\n+    for (_, spec) in cx.dict.iter() {\n         cx.set_level(spec.lint, spec.default, Default);\n     }\n \n     // Install command-line options, overriding defaults.\n-    foreach &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n+    for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n \n@@ -1211,8 +1211,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    foreach (id, v) in tcx.sess.lints.iter() {\n-        foreach t in v.iter() {\n+    for (id, v) in tcx.sess.lints.iter() {\n+        for t in v.iter() {\n             match *t {\n                 (lint, span, ref msg) =>\n                     tcx.sess.span_bug(span, fmt!(\"unprocessed lint %? at %s: \\"}, {"sha": "f4a3c2d1f39af469ebbf39b38247b3aed23a3c6c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -360,7 +360,7 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n         debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n     }\n \n-    foreach arg in decl.inputs.iter() {\n+    for arg in decl.inputs.iter() {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n@@ -436,7 +436,7 @@ fn visit_local(local: @Local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n \n fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     let def_map = this.tcx.def_map;\n-    foreach pat in arm.pats.iter() {\n+    for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n             debug!(\"adding local variable %d from match with bm %?\",\n                    p_id, bm);\n@@ -475,7 +475,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         // construction site.\n         let cvs = this.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n-        foreach cv in cvs.iter() {\n+        for cv in cvs.iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n@@ -710,7 +710,7 @@ impl Liveness {\n \n     pub fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        foreach var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in range(0u, self.ir.num_vars) {\n             op(node_base_idx + var_idx)\n         }\n     }\n@@ -721,7 +721,7 @@ impl Liveness {\n                     op: &fn(uint, uint)) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n-        foreach var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in range(0u, self.ir.num_vars) {\n             op(node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n@@ -731,7 +731,7 @@ impl Liveness {\n                       ln: LiveNode,\n                       test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        foreach var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 wr.write_str(\" \");\n@@ -900,7 +900,7 @@ impl Liveness {\n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body %d (entry=%s)\",\n                {\n-                   foreach ln_idx in range(0u, self.ir.num_live_nodes) {\n+                   for ln_idx in range(0u, self.ir.num_live_nodes) {\n                        debug!(\"%s\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n@@ -1084,7 +1084,7 @@ impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            foreach arm in arms.iter() {\n+            for arm in arms.iter() {\n                 let body_succ =\n                     self.propagate_through_block(&arm.body, succ);\n                 let guard_succ =\n@@ -1461,12 +1461,12 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       }\n \n       expr_inline_asm(ref ia) => {\n-        foreach &(_, input) in ia.inputs.iter() {\n+        for &(_, input) in ia.inputs.iter() {\n           (vt.visit_expr)(input, (this, vt));\n         }\n \n         // Output operands must be lvalues\n-        foreach &(_, out) in ia.outputs.iter() {\n+        for &(_, out) in ia.outputs.iter() {\n           match out.node {\n             expr_addr_of(_, inner) => {\n               this.check_lvalue(inner, vt);\n@@ -1606,7 +1606,7 @@ impl Liveness {\n     }\n \n     pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n-        foreach arg in decl.inputs.iter() {\n+        for arg in decl.inputs.iter() {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n                 let var = self.variable(p_id, sp);\n@@ -1631,7 +1631,7 @@ impl Liveness {\n                              -> bool {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n-            foreach name in r.iter() {\n+            for name in r.iter() {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n                 // {ret}`, there is only one node, so asking about\n@@ -1664,7 +1664,7 @@ impl Liveness {\n                                   var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n-            foreach name in r.iter() {\n+            for name in r.iter() {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,\n                     fmt!(\"value assigned to `%s` is never read\", *name));\n             }"}, {"sha": "9e133972ada150bd93b24166dcb539568e87fc74", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -375,7 +375,7 @@ impl mem_categorization_ctxt {\n     pub fn cat_expr_autoderefd(&self, expr: @ast::expr, autoderefs: uint)\n                                -> cmt {\n         let mut cmt = self.cat_expr_unadjusted(expr);\n-        foreach deref in range(1u, autoderefs + 1) {\n+        for deref in range(1u, autoderefs + 1) {\n             cmt = self.cat_deref(expr, cmt, deref);\n         }\n         return cmt;\n@@ -906,7 +906,7 @@ impl mem_categorization_ctxt {\n                         }\n                     };\n \n-                    foreach (i, &subpat) in subpats.iter().enumerate() {\n+                    for (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n \n                         let subcmt =\n@@ -919,7 +919,7 @@ impl mem_categorization_ctxt {\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    foreach (i, &subpat) in subpats.iter().enumerate() {\n+                    for (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n                         let cmt_field =\n                             self.cat_imm_interior(\n@@ -929,7 +929,7 @@ impl mem_categorization_ctxt {\n                     }\n                 }\n                 Some(&ast::def_static(*)) => {\n-                    foreach &subpat in subpats.iter() {\n+                    for &subpat in subpats.iter() {\n                         self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n@@ -951,7 +951,7 @@ impl mem_categorization_ctxt {\n \n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            foreach fp in field_pats.iter() {\n+            for fp in field_pats.iter() {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n                 self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n@@ -960,7 +960,7 @@ impl mem_categorization_ctxt {\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            foreach (i, &subpat) in subpats.iter().enumerate() {\n+            for (i, &subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = self.pat_ty(subpat); // see (*)\n                 let subcmt =\n                     self.cat_imm_interior(\n@@ -979,15 +979,15 @@ impl mem_categorization_ctxt {\n \n           ast::pat_vec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n-              foreach &before_pat in before.iter() {\n+              for &before_pat in before.iter() {\n                   self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n               }\n-              foreach &slice_pat in slice.iter() {\n+              for &slice_pat in slice.iter() {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue_node(pat, slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n-              foreach &after_pat in after.iter() {\n+              for &after_pat in after.iter() {\n                   self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n               }\n           }\n@@ -1076,7 +1076,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n     match ty::get(base_ty).sty {\n       ty::ty_struct(did, _) => {\n         let r = ty::lookup_struct_fields(tcx, did);\n-        foreach fld in r.iter() {\n+        for fld in r.iter() {\n             if fld.ident == f_name {\n                 return Some(ast::m_imm);\n             }\n@@ -1086,7 +1086,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         match tcx.def_map.get_copy(&node_id) {\n           ast::def_variant(_, variant_id) => {\n             let r = ty::lookup_struct_fields(tcx, variant_id);\n-            foreach fld in r.iter() {\n+            for fld in r.iter() {\n                 if fld.ident == f_name {\n                     return Some(ast::m_imm);\n                 }"}, {"sha": "b151f313b961061c5cb1e1fbe1a315ed8cff5ba0", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -231,7 +231,7 @@ fn compute_modes_for_local<'a>(local: @Local,\n                                (cx, v): (VisitContext,\n                                          vt<VisitContext>)) {\n     cx.use_pat(local.pat);\n-    foreach &init in local.init.iter() {\n+    for &init in local.init.iter() {\n         cx.use_expr(init, Read, v);\n     }\n }\n@@ -243,7 +243,7 @@ fn compute_modes_for_fn(fk: &oldvisit::fn_kind,\n                         id: NodeId,\n                         (cx, v): (VisitContext,\n                                   vt<VisitContext>)) {\n-    foreach a in decl.inputs.iter() {\n+    for a in decl.inputs.iter() {\n         cx.use_pat(a.pat);\n     }\n     oldvisit::visit_fn(fk, decl, body, span, id, (cx, v));\n@@ -258,7 +258,7 @@ fn compute_modes_for_expr(expr: @expr,\n \n impl VisitContext {\n     pub fn consume_exprs(&self, exprs: &[@expr], visitor: vt<VisitContext>) {\n-        foreach expr in exprs.iter() {\n+        for expr in exprs.iter() {\n             self.consume_expr(*expr, visitor);\n         }\n     }\n@@ -289,11 +289,11 @@ impl VisitContext {\n \n         debug!(\"consume_block(blk.id=%?)\", blk.id);\n \n-        foreach stmt in blk.stmts.iter() {\n+        for stmt in blk.stmts.iter() {\n             (visitor.visit_stmt)(*stmt, (*self, visitor));\n         }\n \n-        foreach tail_expr in blk.expr.iter() {\n+        for tail_expr in blk.expr.iter() {\n             self.consume_expr(*tail_expr, visitor);\n         }\n     }\n@@ -329,7 +329,7 @@ impl VisitContext {\n                     Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n                         let r = moved_variable_node_id_from_def(def);\n-                        foreach &id in r.iter() {\n+                        for &id in r.iter() {\n                             self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n@@ -393,11 +393,11 @@ impl VisitContext {\n             }\n \n             expr_struct(_, ref fields, opt_with) => {\n-                foreach field in fields.iter() {\n+                for field in fields.iter() {\n                     self.consume_expr(field.expr, visitor);\n                 }\n \n-                foreach with_expr in opt_with.iter() {\n+                for with_expr in opt_with.iter() {\n                     // If there are any fields whose type is move-by-default,\n                     // then `with` is consumed, otherwise it is only read\n                     let with_ty = ty::expr_ty(self.tcx, *with_expr);\n@@ -436,15 +436,15 @@ impl VisitContext {\n             expr_if(cond_expr, ref then_blk, opt_else_expr) => {\n                 self.consume_expr(cond_expr, visitor);\n                 self.consume_block(then_blk, visitor);\n-                foreach else_expr in opt_else_expr.iter() {\n+                for else_expr in opt_else_expr.iter() {\n                     self.consume_expr(*else_expr, visitor);\n                 }\n             }\n \n             expr_match(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n-                foreach arm in arms.iter() {\n+                for arm in arms.iter() {\n                     self.consume_arm(arm, visitor);\n                 }\n \n@@ -511,7 +511,7 @@ impl VisitContext {\n             }\n \n             expr_ret(ref opt_expr) => {\n-                foreach expr in opt_expr.iter() {\n+                for expr in opt_expr.iter() {\n                     self.consume_expr(*expr, visitor);\n                 }\n             }\n@@ -547,7 +547,7 @@ impl VisitContext {\n             }\n \n             expr_fn_block(ref decl, ref body) => {\n-                foreach a in decl.inputs.iter() {\n+                for a in decl.inputs.iter() {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n@@ -581,19 +581,19 @@ impl VisitContext {\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n-        foreach arg_expr in arg_exprs.iter() {\n+        for arg_expr in arg_exprs.iter() {\n             self.use_expr(*arg_expr, Read, visitor);\n         }\n \n         return true;\n     }\n \n     pub fn consume_arm(&self, arm: &arm, visitor: vt<VisitContext>) {\n-        foreach pat in arm.pats.iter() {\n+        for pat in arm.pats.iter() {\n             self.use_pat(*pat);\n         }\n \n-        foreach guard in arm.guard.iter() {\n+        for guard in arm.guard.iter() {\n             self.consume_expr(*guard, visitor);\n         }\n \n@@ -640,7 +640,7 @@ impl VisitContext {\n                        arg_exprs: &[@expr],\n                        visitor: vt<VisitContext>) {\n         //! Uses the argument expressions.\n-        foreach arg_expr in arg_exprs.iter() {\n+        for arg_expr in arg_exprs.iter() {\n             self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n@@ -655,8 +655,8 @@ impl VisitContext {\n                                       arms: &[arm])\n                                       -> Option<@pat> {\n         let mut ret = None;\n-        foreach arm in arms.iter() {\n-            foreach &pat in arm.pats.iter() {\n+        for arm in arms.iter() {\n+            for &pat in arm.pats.iter() {\n                 let cont = do ast_util::walk_pat(pat) |p| {\n                     if moves_map.contains(&p.id) {\n                         ret = Some(p);"}, {"sha": "76d1d0b05ffbc62364479d2433f295f6f2710828", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -50,15 +50,15 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 *count += 1;\n             }\n             item_impl(_, _, _, ref methods) => {\n-                foreach method in methods.iter() {\n+                for method in methods.iter() {\n                     privileged_items.push(method.id);\n                     *count += 1;\n                 }\n                 privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_foreign_mod(ref foreign_mod) => {\n-                foreach foreign_item in foreign_mod.items.iter() {\n+                for foreign_item in foreign_mod.items.iter() {\n                     privileged_items.push(foreign_item.id);\n                     *count += 1;\n                 }\n@@ -70,7 +70,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     // Adds items that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n         let mut count = 0;\n-        foreach &item in items.iter() {\n+        for &item in items.iter() {\n             add_privileged_item(item, &mut count);\n         }\n         count\n@@ -206,7 +206,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n             |span, id, ident| {\n         let fields = ty::lookup_struct_fields(tcx, id);\n-        foreach field in fields.iter() {\n+        for field in fields.iter() {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n@@ -357,7 +357,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         visit_block: |block, (method_map, visitor)| {\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n-            foreach stmt in block.stmts.iter() {\n+            for stmt in block.stmts.iter() {\n                 match stmt.node {\n                     stmt_decl(decl, _) => {\n                         match decl.node {\n@@ -430,7 +430,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                foreach field in (*fields).iter() {\n+                                for field in (*fields).iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     check_field(expr.span, id, field.ident);\n@@ -442,7 +442,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n-                                        foreach field in (*fields).iter() {\n+                                        for field in (*fields).iter() {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n@@ -494,7 +494,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                foreach field in fields.iter() {\n+                                for field in fields.iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n                                     check_field(pattern.span, id, field.ident);\n@@ -506,7 +506,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     !privileged_items.iter().any(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n-                                        foreach field in fields.iter() {\n+                                        for field in fields.iter() {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");"}, {"sha": "33a8960baee5bb595212726b1b4d8b9ec7f6eb61", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -134,7 +134,7 @@ impl ReachableContext {\n                     }\n                     item_enum(ref enum_def, _) => {\n                         if privacy_context == PublicContext {\n-                            foreach variant in enum_def.variants.iter() {\n+                            for variant in enum_def.variants.iter() {\n                                 reachable_symbols.insert(variant.node.id);\n                             }\n                         }\n@@ -153,7 +153,7 @@ impl ReachableContext {\n                         };\n \n                         // Mark all public methods as reachable.\n-                        foreach &method in methods.iter() {\n+                        for &method in methods.iter() {\n                             if should_be_considered_public(method) {\n                                 reachable_symbols.insert(method.id);\n                             }\n@@ -162,15 +162,15 @@ impl ReachableContext {\n                         if generics_require_inlining(generics) {\n                             // If the impl itself has generics, add all public\n                             // symbols to the worklist.\n-                            foreach &method in methods.iter() {\n+                            for &method in methods.iter() {\n                                 if should_be_considered_public(method) {\n                                     worklist.push(method.id)\n                                 }\n                             }\n                         } else {\n                             // Otherwise, add only public methods that have\n                             // generics to the worklist.\n-                            foreach method in methods.iter() {\n+                            for method in methods.iter() {\n                                 let generics = &method.generics;\n                                 let attrs = &method.attrs;\n                                 if generics_require_inlining(generics) ||\n@@ -184,7 +184,7 @@ impl ReachableContext {\n                     item_trait(_, _, ref trait_methods) => {\n                         // Mark all provided methods as reachable.\n                         if privacy_context == PublicContext {\n-                            foreach trait_method in trait_methods.iter() {\n+                            for trait_method in trait_methods.iter() {\n                                 match *trait_method {\n                                     provided(method) => {\n                                         reachable_symbols.insert(method.id);\n@@ -390,7 +390,7 @@ impl ReachableContext {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&self) {\n-        foreach (_, destructor_def_id) in self.tcx.destructor_for_type.iter() {\n+        for (_, destructor_def_id) in self.tcx.destructor_for_type.iter() {\n             if destructor_def_id.crate == LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }"}, {"sha": "2d121209118f8dc28bb8ac69ec3eb6063035cce2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -198,7 +198,7 @@ impl RegionMaps {\n         while i < queue.len() {\n             match self.free_region_map.find(&queue[i]) {\n                 Some(parents) => {\n-                    foreach parent in parents.iter() {\n+                    for parent in parents.iter() {\n                         if *parent == sup {\n                             return true;\n                         }\n@@ -318,7 +318,7 @@ impl RegionMaps {\n fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n-    foreach parent_id in cx.parent.iter() {\n+    for parent_id in cx.parent.iter() {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n@@ -718,7 +718,7 @@ fn determine_rp_in_fn(fk: &oldvisit::fn_kind,\n                                       oldvisit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n-            foreach a in decl.inputs.iter() {\n+            for a in decl.inputs.iter() {\n                 (visitor.visit_ty)(&a.ty, (cx, visitor));\n             }\n         }\n@@ -830,7 +830,7 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n-            foreach tp in path.types.iter() {\n+            for tp in path.types.iter() {\n                 (visitor.visit_ty)(tp, (cx, visitor));\n             }\n         }\n@@ -843,7 +843,7 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                foreach a in decl.inputs.iter() {\n+                for a in decl.inputs.iter() {\n                     (visitor.visit_ty)(&a.ty, (cx, visitor));\n                 }\n             }\n@@ -923,7 +923,7 @@ pub fn determine_rp_in_crate(sess: Session,\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n-                foreach dep in deps.iter() {\n+                for dep in deps.iter() {\n                     let v = add_variance(dep.ambient_variance, c_variance);\n                     cx.add_rp(dep.id, v);\n                 }\n@@ -935,7 +935,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        foreach (&key, &value) in region_paramd_items.iter() {\n+        for (&key, &value) in region_paramd_items.iter() {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "60ecff39d8554baa1597e657794e9196272e248b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -1037,7 +1037,7 @@ impl Resolver {\n                              self.session.str_of(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n-                        foreach sp in r.iter() {\n+                        for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  fmt!(\"first definition of %s `%s` here\",\n                                       namespace_error_to_str(duplicate_type),\n@@ -1057,7 +1057,7 @@ impl Resolver {\n         }\n \n         // Check each statement.\n-        foreach statement in block.stmts.iter() {\n+        for statement in block.stmts.iter() {\n             match statement.node {\n                 stmt_decl(declaration, _) => {\n                     match declaration.node {\n@@ -1179,7 +1179,7 @@ impl Resolver {\n                 name_bindings.define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n-                foreach variant in (*enum_definition).variants.iter() {\n+                for variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n                         variant,\n                         local_def(item.id),\n@@ -1264,7 +1264,7 @@ impl Resolver {\n                         };\n \n                         // For each method...\n-                        foreach method in methods.iter() {\n+                        for method in methods.iter() {\n                             // Add the method to the module.\n                             let ident = method.ident;\n                             let (method_name_bindings, _) =\n@@ -1316,7 +1316,7 @@ impl Resolver {\n \n                 // Add the names of all the methods to the trait info.\n                 let mut method_names = HashMap::new();\n-                foreach method in methods.iter() {\n+                for method in methods.iter() {\n                     let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n@@ -1353,7 +1353,7 @@ impl Resolver {\n                 }\n \n                 let def_id = local_def(item.id);\n-                foreach (name, _) in method_names.iter() {\n+                for (name, _) in method_names.iter() {\n                     if !self.method_map.contains_key(name) {\n                         self.method_map.insert(*name, HashSet::new());\n                     }\n@@ -1422,7 +1422,7 @@ impl Resolver {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n-                foreach view_path in view_paths.iter() {\n+                for view_path in view_paths.iter() {\n                     // Extract and intern the module part of the path. For\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n@@ -1433,7 +1433,7 @@ impl Resolver {\n                             let path_len = full_path.idents.len();\n                             assert!(path_len != 0);\n \n-                            foreach (i, ident) in full_path.idents.iter().enumerate() {\n+                            for (i, ident) in full_path.idents.iter().enumerate() {\n                                 if i != path_len - 1 {\n                                     module_path.push(*ident);\n                                 }\n@@ -1442,7 +1442,7 @@ impl Resolver {\n \n                         view_path_glob(ref module_ident_path, _) |\n                         view_path_list(ref module_ident_path, _, _) => {\n-                            foreach ident in module_ident_path.idents.iter() {\n+                            for ident in module_ident_path.idents.iter() {\n                                 module_path.push(*ident);\n                             }\n                         }\n@@ -1463,7 +1463,7 @@ impl Resolver {\n                                                         id);\n                         }\n                         view_path_list(_, ref source_idents, _) => {\n-                            foreach source_ident in source_idents.iter() {\n+                            for source_ident in source_idents.iter() {\n                                 let name = source_ident.node.name;\n                                 let subclass = @SingleImport(name, name);\n                                 self.build_import_directive(\n@@ -1657,7 +1657,7 @@ impl Resolver {\n               let method_def_ids =\n                 get_trait_method_def_ids(self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n-              foreach &method_def_id in method_def_ids.iter() {\n+              for &method_def_id in method_def_ids.iter() {\n                   let (method_name, explicit_self) =\n                       get_method_name_and_explicit_self(self.session.cstore,\n                                                         method_def_id);\n@@ -1672,7 +1672,7 @@ impl Resolver {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n-              foreach name in interned_method_names.iter() {\n+              for name in interned_method_names.iter() {\n                   if !self.method_map.contains_key(name) {\n                       self.method_map.insert(*name, HashSet::new());\n                   }\n@@ -1741,7 +1741,7 @@ impl Resolver {\n             // need to.\n \n             let mut current_module = root;\n-            foreach ident_str in pieces.iter() {\n+            for ident_str in pieces.iter() {\n                 let ident = self.session.ident_of(*ident_str);\n                 // Create or reuse a graph node for the child.\n                 let (child_name_bindings, new_parent) =\n@@ -1861,7 +1861,7 @@ impl Resolver {\n                                     // Add each static method to the module.\n                                     let new_parent = ModuleReducedGraphParent(\n                                         type_module);\n-                                    foreach static_method_info in static_methods.iter() {\n+                                    for static_method_info in static_methods.iter() {\n                                         let ident = static_method_info.ident;\n                                         debug!(\"(building reduced graph for \\\n                                                  external crate) creating \\\n@@ -1993,7 +1993,7 @@ impl Resolver {\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n-        foreach (_, &child_node) in module_.children.iter() {\n+        for (_, &child_node) in module_.children.iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -2004,7 +2004,7 @@ impl Resolver {\n             }\n         }\n \n-        foreach (_, &child_module) in module_.anonymous_children.iter() {\n+        for (_, &child_module) in module_.anonymous_children.iter() {\n             self.resolve_imports_for_module_subtree(child_module);\n         }\n     }\n@@ -2048,7 +2048,7 @@ impl Resolver {\n     pub fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n-        foreach ident in idents.iter() {\n+        for ident in idents.iter() {\n             if first {\n                 first = false\n             } else {\n@@ -2447,7 +2447,7 @@ impl Resolver {\n         assert_eq!(containing_module.glob_count, 0);\n \n         // Add all resolved imports from the containing module.\n-        foreach (ident, target_import_resolution) in containing_module.import_resolutions.iter() {\n+        for (ident, target_import_resolution) in containing_module.import_resolutions.iter() {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n@@ -2531,12 +2531,12 @@ impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        foreach (&ident, name_bindings) in containing_module.children.iter() {\n+        for (&ident, name_bindings) in containing_module.children.iter() {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n-        foreach (&ident, module) in containing_module.external_module_children.iter() {\n+        for (&ident, module) in containing_module.external_module_children.iter() {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);\n@@ -3108,7 +3108,7 @@ impl Resolver {\n         }\n \n         // Descend into children and anonymous children.\n-        foreach (_, &child_node) in module_.children.iter() {\n+        for (_, &child_node) in module_.children.iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n@@ -3119,7 +3119,7 @@ impl Resolver {\n             }\n         }\n \n-        foreach (_, &module_) in module_.anonymous_children.iter() {\n+        for (_, &module_) in module_.anonymous_children.iter() {\n             self.report_unresolved_imports(module_);\n         }\n     }\n@@ -3167,7 +3167,7 @@ impl Resolver {\n \n         self.record_exports_for_module(module_);\n \n-        foreach (_, &child_name_bindings) in module_.children.iter() {\n+        for (_, &child_name_bindings) in module_.children.iter() {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -3178,7 +3178,7 @@ impl Resolver {\n             }\n         }\n \n-        foreach (_, &child_module) in module_.anonymous_children.iter() {\n+        for (_, &child_module) in module_.anonymous_children.iter() {\n             self.record_exports_for_module_subtree(child_module);\n         }\n     }\n@@ -3228,14 +3228,14 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        foreach (ident, importresolution) in module_.import_resolutions.iter() {\n+        for (ident, importresolution) in module_.import_resolutions.iter() {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        self.session.str_of(*ident));\n                 loop;\n             }\n             let xs = [TypeNS, ValueNS];\n-            foreach ns in xs.iter() {\n+            for ns in xs.iter() {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n@@ -3483,8 +3483,8 @@ impl Resolver {\n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n             item_enum(ref enum_def, ref generics) => {\n-                foreach variant in (*enum_def).variants.iter() {\n-                    foreach dis_expr in variant.node.disr_expr.iter() {\n+                for variant in (*enum_def).variants.iter() {\n+                    for dis_expr in variant.node.disr_expr.iter() {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|| {\n@@ -3541,11 +3541,11 @@ impl Resolver {\n                                                  visitor);\n \n                     // Resolve derived traits.\n-                    foreach trt in traits.iter() {\n+                    for trt in traits.iter() {\n                         self.resolve_trait_reference(item.id, trt, visitor, TraitDerivation);\n                     }\n \n-                    foreach method in (*methods).iter() {\n+                    for method in (*methods).iter() {\n                         // Create a new rib for the method-specific type\n                         // parameters.\n                         //\n@@ -3565,7 +3565,7 @@ impl Resolver {\n                                     &ty_m.generics.ty_params,\n                                     visitor);\n \n-                                foreach argument in ty_m.decl.inputs.iter() {\n+                                for argument in ty_m.decl.inputs.iter() {\n                                     self.resolve_type(&argument.ty, visitor);\n                                 }\n \n@@ -3602,7 +3602,7 @@ impl Resolver {\n \n             item_foreign_mod(ref foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n-                    foreach foreign_item in foreign_module.items.iter() {\n+                    for foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n                             foreign_item_fn(_, ref generics) => {\n                                 self.with_type_parameter_rib(\n@@ -3658,7 +3658,7 @@ impl Resolver {\n                 let function_type_rib = @Rib(rib_kind);\n                 self.type_ribs.push(function_type_rib);\n \n-                foreach (index, type_parameter) in generics.ty_params.iter().enumerate() {\n+                for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n@@ -3749,7 +3749,7 @@ impl Resolver {\n                     // Nothing to do.\n                 }\n                 Some(declaration) => {\n-                    foreach argument in declaration.inputs.iter() {\n+                    for argument in declaration.inputs.iter() {\n                         let binding_mode = ArgumentIrrefutableMode;\n                         let mutability =\n                             if argument.is_mutbl {Mutable} else {Immutable};\n@@ -3781,8 +3781,8 @@ impl Resolver {\n     pub fn resolve_type_parameters(@mut self,\n                                    type_parameters: &OptVec<TyParam>,\n                                    visitor: ResolveVisitor) {\n-        foreach type_parameter in type_parameters.iter() {\n-            foreach bound in type_parameter.bounds.iter() {\n+        for type_parameter in type_parameters.iter() {\n+            for bound in type_parameter.bounds.iter() {\n                 self.resolve_type_parameter_bound(type_parameter.id, bound, visitor);\n             }\n         }\n@@ -3831,7 +3831,7 @@ impl Resolver {\n                           fields: &[@struct_field],\n                           visitor: ResolveVisitor) {\n         let mut ident_map = HashMap::new::<ast::ident, @struct_field>();\n-        foreach &field in fields.iter() {\n+        for &field in fields.iter() {\n             match field.node.kind {\n                 named_field(ident, _) => {\n                     match ident_map.find(&ident) {\n@@ -3860,7 +3860,7 @@ impl Resolver {\n             self.resolve_type_parameters(&generics.ty_params, visitor);\n \n             // Resolve fields.\n-            foreach field in fields.iter() {\n+            for field in fields.iter() {\n                 self.resolve_type(&field.node.ty, visitor);\n             }\n         }\n@@ -3920,7 +3920,7 @@ impl Resolver {\n                     let mut new_trait_refs = ~[];\n                     {\n                         let r = self.def_map.find(&trait_reference.ref_id);\n-                        foreach &def in r.iter() {\n+                        for &def in r.iter() {\n                             new_trait_refs.push(def_id_of_def(*def));\n                         }\n                     }\n@@ -3936,7 +3936,7 @@ impl Resolver {\n             // Resolve the self type.\n             self.resolve_type(self_type, visitor);\n \n-            foreach method in methods.iter() {\n+            for method in methods.iter() {\n                 // We also need a new scope for the method-specific\n                 // type parameters.\n                 self.resolve_method(MethodRibKind(\n@@ -4016,10 +4016,10 @@ impl Resolver {\n     pub fn check_consistent_bindings(@mut self, arm: &arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n-        foreach (i, p) in arm.pats.iter().enumerate() {\n+        for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(*p);\n \n-            foreach (&key, &binding_0) in map_0.iter() {\n+            for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n@@ -4040,7 +4040,7 @@ impl Resolver {\n                 }\n             }\n \n-            foreach (&key, &binding) in map_i.iter() {\n+            for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n                     self.session.span_err(\n                         binding.span,\n@@ -4056,7 +4056,7 @@ impl Resolver {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n-        foreach pattern in arm.pats.iter() {\n+        for pattern in arm.pats.iter() {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n         }\n@@ -4162,15 +4162,15 @@ impl Resolver {\n                 }\n \n                 do bounds.map |bound_vec| {\n-                    foreach bound in bound_vec.iter() {\n+                    for bound in bound_vec.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n             }\n \n             ty_closure(c) => {\n                 do c.bounds.map |bounds| {\n-                    foreach bound in bounds.iter() {\n+                    for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n@@ -4317,7 +4317,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    foreach ty in path.types.iter() {\n+                    for ty in path.types.iter() {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4350,7 +4350,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    foreach ty in path.types.iter() {\n+                    for ty in path.types.iter() {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4379,7 +4379,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    foreach ty in path.types.iter() {\n+                    for ty in path.types.iter() {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4476,7 +4476,7 @@ impl Resolver {\n                         visitor: ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n-        foreach ty in path.types.iter() {\n+        for ty in path.types.iter() {\n             self.resolve_type(ty, visitor);\n         }\n \n@@ -4606,7 +4606,7 @@ impl Resolver {\n \n     pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n-        foreach (index, ident) in path.idents.iter().enumerate() {\n+        for (index, ident) in path.idents.iter().enumerate() {\n             if index == path.idents.len() - 1 {\n                 break;\n             }\n@@ -4837,14 +4837,14 @@ impl Resolver {\n         let mut j = this.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n-            foreach (&k, _) in this.value_ribs[j].bindings.iter() {\n+            for (&k, _) in this.value_ribs[j].bindings.iter() {\n                 maybes.push(this.session.str_of(k));\n                 values.push(uint::max_value);\n             }\n         }\n \n         let mut smallest = 0;\n-        foreach (i, &other) in maybes.iter().enumerate() {\n+        for (i, &other) in maybes.iter().enumerate() {\n             values[i] = name.lev_distance(other);\n \n             if values[i] <= values[smallest] {\n@@ -4873,11 +4873,11 @@ impl Resolver {\n           i -= 1;\n           match this.type_ribs[i].kind {\n             MethodRibKind(node_id, _) =>\n-              foreach item in this.crate.module.items.iter() {\n+              for item in this.crate.module.items.iter() {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n-                      foreach field in class_def.fields.iter() {\n+                      for field in class_def.fields.iter() {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _) => {\n@@ -5151,7 +5151,7 @@ impl Resolver {\n                 // Look for the current trait.\n                 match self.current_trait_refs {\n                     Some(ref trait_def_ids) => {\n-                        foreach trait_def_id in trait_def_ids.iter() {\n+                        for trait_def_id in trait_def_ids.iter() {\n                             if candidate_traits.contains(trait_def_id) {\n                                 self.add_trait_info(&mut found_traits,\n                                                     *trait_def_id,\n@@ -5165,7 +5165,7 @@ impl Resolver {\n                 }\n \n                 // Look for trait children.\n-                foreach (_, &child_name_bindings) in search_module.children.iter() {\n+                for (_, &child_name_bindings) in search_module.children.iter() {\n                     match child_name_bindings.def_for_namespace(TypeNS) {\n                         Some(def) => {\n                             match def {\n@@ -5188,7 +5188,7 @@ impl Resolver {\n                 }\n \n                 // Look for imports.\n-                foreach (_, &import_resolution) in search_module.import_resolutions.iter() {\n+                for (_, &import_resolution) in search_module.import_resolutions.iter() {\n                     match import_resolution.target_for_namespace(TypeNS) {\n                         None => {\n                             // Continue.\n@@ -5305,7 +5305,7 @@ impl Resolver {\n         match vi.node {\n             view_item_extern_mod(*) => {} // ignore\n             view_item_use(ref path) => {\n-                foreach p in path.iter() {\n+                for p in path.iter() {\n                     match p.node {\n                         view_path_simple(_, _, id) | view_path_glob(_, id) => {\n                             if !self.used_imports.contains(&id) {\n@@ -5316,7 +5316,7 @@ impl Resolver {\n                         }\n \n                         view_path_list(_, ref list, _) => {\n-                            foreach i in list.iter() {\n+                            for i in list.iter() {\n                                 if !self.used_imports.contains(&i.node.id) {\n                                     self.session.add_lint(unused_imports,\n                                                           i.node.id, i.span,\n@@ -5367,12 +5367,12 @@ impl Resolver {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n-        foreach (&name, _) in module_.children.iter() {\n+        for (&name, _) in module_.children.iter() {\n             debug!(\"* %s\", self.session.str_of(name));\n         }\n \n         debug!(\"Import resolutions:\");\n-        foreach (name, import_resolution) in module_.import_resolutions.iter() {\n+        for (name, import_resolution) in module_.import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "725beee6604e7d8e92a813fa18f7556e5f264e4c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -298,7 +298,7 @@ pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n-            foreach v in (*variants).iter() {\n+            for v in (*variants).iter() {\n                 if var_id == v.id {\n                     return var(v.disr_val,\n                                adt::represent_node(bcx, pat_id))\n@@ -367,7 +367,7 @@ pub fn matches_to_str(bcx: @mut Block, m: &[Match]) -> ~str {\n }\n \n pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n           _ => ()\n@@ -437,7 +437,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let mut result = ~[];\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         match e(br.pats[col]) {\n             Some(sub) => {\n                 let pats =\n@@ -589,7 +589,7 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n                     // unspecified fields with dummy.\n                     let mut reordered_patterns = ~[];\n                     let r = ty::lookup_struct_fields(tcx, struct_id);\n-                    foreach field in r.iter() {\n+                    for field in r.iter() {\n                             match field_pats.iter().find_(|p| p.ident == field.ident) {\n                                 None => reordered_patterns.push(dummy),\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n@@ -649,7 +649,7 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n         match p.node {\n             ast::pat_struct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n-                foreach fname in fields.iter() {\n+                for fname in fields.iter() {\n                     match fpats.iter().find_(|p| p.ident == *fname) {\n                         None => pats.push(dummy),\n                         Some(pat) => pats.push(pat.pat)\n@@ -809,7 +809,7 @@ pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     }\n \n     let mut found = ~[];\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         let cur = br.pats[col];\n         match cur.node {\n             ast::pat_lit(l) => {\n@@ -955,7 +955,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        col: uint)\n                                     -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n@@ -969,7 +969,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n     return fields;\n \n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n-        foreach field_pat in field_pats.iter() {\n+        for field_pat in field_pats.iter() {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any(|x| *x == field_ident) {\n                 idents.push(field_ident);\n@@ -994,7 +994,7 @@ pub fn root_pats_as_necessary(mut bcx: @mut Block,\n                               col: uint,\n                               val: ValueRef)\n                            -> @mut Block {\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n             let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n@@ -1063,14 +1063,14 @@ pub fn pick_col(m: &[Match]) -> uint {\n         }\n     }\n     let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         let mut i = 0u;\n-        foreach p in br.pats.iter() { scores[i] += score(*p); i += 1u; }\n+        for p in br.pats.iter() { scores[i] += score(*p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    foreach score in scores.iter() {\n+    for score in scores.iter() {\n         let score = *score;\n \n         // Irrefutable columns always go first, they'd only be duplicated in\n@@ -1148,7 +1148,7 @@ fn store_non_ref_bindings(bcx: @mut Block,\n      */\n \n     let mut bcx = bcx;\n-    foreach (_, &binding_info) in bindings_map.iter() {\n+    for (_, &binding_info) in bindings_map.iter() {\n         match binding_info.trmode {\n             TrByValue(lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n@@ -1182,7 +1182,7 @@ fn insert_lllocals(bcx: @mut Block,\n         BindArgument => bcx.fcx.llargs\n     };\n \n-    foreach (_, &binding_info) in bindings_map.iter() {\n+    for (_, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1236,7 +1236,7 @@ pub fn compile_guard(bcx: @mut Block,\n     let val = bool_to_i1(bcx, val);\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n-    foreach llval in temp_cleanups.iter() {\n+    for llval in temp_cleanups.iter() {\n         revoke_clean(bcx, *llval);\n     }\n \n@@ -1250,7 +1250,7 @@ pub fn compile_guard(bcx: @mut Block,\n \n     fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n         let mut bcx = bcx;\n-        foreach (_, &binding_info) in data.bindings_map.iter() {\n+        for (_, &binding_info) in data.bindings_map.iter() {\n             match binding_info.trmode {\n                 TrByValue(llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n@@ -1325,7 +1325,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();\n-    foreach br in m.iter() {\n+    for br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n@@ -1434,7 +1434,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             var(_, repr) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n                 kind = the_kind;\n-                foreach &tval in val_opt.iter() { test_val = tval; }\n+                for &tval in val_opt.iter() { test_val = tval; }\n             }\n             lit(_) => {\n                 let pty = node_id_type(bcx, pat_id);\n@@ -1457,7 +1457,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             }\n         }\n     }\n-    foreach o in opts.iter() {\n+    for o in opts.iter() {\n         match *o {\n             range(_, _) => { kind = compare; break }\n             _ => ()\n@@ -1479,7 +1479,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     let mut i = 0u;\n \n     // Compile subtrees for each option\n-    foreach opt in opts.iter() {\n+    for opt in opts.iter() {\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -1688,7 +1688,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n \n     let mut arm_datas = ~[];\n     let mut matches = ~[];\n-    foreach arm in arms.iter() {\n+    for arm in arms.iter() {\n         let body = scope_block(bcx, arm.body.info(), \"case_body\");\n         let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n         let arm_data = ArmData {\n@@ -1697,7 +1697,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n             bindings_map: @bindings_map\n         };\n         arm_datas.push(arm_data.clone());\n-        foreach p in arm.pats.iter() {\n+        for p in arm.pats.iter() {\n             matches.push(Match {\n                 pats: ~[*p],\n                 data: arm_data.clone(),\n@@ -1721,7 +1721,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n     compile_submatch(bcx, matches, [lldiscr], chk);\n \n     let mut arm_cxs = ~[];\n-    foreach arm_data in arm_datas.iter() {\n+    for arm_data in arm_datas.iter() {\n         let mut bcx = arm_data.bodycx;\n \n         // If this arm has a guard, then the various by-value bindings have\n@@ -1957,7 +1957,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                     });\n             }\n \n-            foreach &inner_pat in inner.iter() {\n+            for &inner_pat in inner.iter() {\n                 bcx = bind_irrefutable_pat(bcx, inner_pat, val, binding_mode);\n             }\n         }\n@@ -1972,8 +1972,8 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                                                     repr,\n                                                     vinfo.disr_val,\n                                                     val);\n-                    foreach sub_pat in sub_pats.iter() {\n-                        foreach (i, argval) in args.vals.iter().enumerate() {\n+                    for sub_pat in sub_pats.iter() {\n+                        for (i, argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n                                                        *argval, binding_mode);\n                         }\n@@ -1988,7 +1988,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                         Some(ref elems) => {\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n-                            foreach (i, elem) in elems.iter().enumerate() {\n+                            for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, *elem,\n@@ -2009,7 +2009,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-                foreach f in fields.iter() {\n+                for f in fields.iter() {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n@@ -2019,7 +2019,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n         }\n         ast::pat_tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n-            foreach (i, elem) in elems.iter().enumerate() {\n+            for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n             }"}, {"sha": "fad5b9ec73b0f40525ff083b519e457756f463d1", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -249,7 +249,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let mut most_aligned = None;\n             let mut largest_align = 0;\n             let mut largest_size = 0;\n-            foreach st in sts.iter() {\n+            for st in sts.iter() {\n                 if largest_size < st.size {\n                     largest_size = st.size;\n                 }\n@@ -545,7 +545,7 @@ fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n \n     let mut offset = 0;\n     let mut cfields = ~[];\n-    foreach (i, &ty) in st.fields.iter().enumerate() {\n+    for (i, &ty) in st.fields.iter().enumerate() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         let type_align = machine::llalign_of_min(ccx, llty)\n             /*bad*/as u64;"}, {"sha": "0b64defd78a9e02f1ffd8a9d1c87aac0ed71c07a", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -62,7 +62,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     };\n \n-    foreach c in cleanups.iter() {\n+    for c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n     }\n     cleanups.clear();\n@@ -83,7 +83,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     };\n \n-    foreach c in cleanups.iter() {\n+    for c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n     }\n \n@@ -133,7 +133,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         let op = PointerCast(bcx, aoutputs[0], val_ty(outputs[0]).ptr_to());\n         Store(bcx, r, op);\n     } else {\n-        foreach (i, o) in aoutputs.iter().enumerate() {\n+        for (i, o) in aoutputs.iter().enumerate() {\n             let v = ExtractValue(bcx, r, i);\n             let op = PointerCast(bcx, *o, val_ty(outputs[i]).ptr_to());\n             Store(bcx, v, op);"}, {"sha": "5070d678c9fabe841efcc05daa5aae31aa03e4ec", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -675,7 +675,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n-        foreach (i, &arg) in variant.args.iter().enumerate() {\n+        for (i, &arg) in variant.args.iter().enumerate() {\n             cx = f(cx,\n                    adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n                    ty::subst_tps(tcx, tps, None, arg));\n@@ -688,7 +688,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n-              foreach (i, field_ty) in field_tys.iter().enumerate() {\n+              for (i, field_ty) in field_tys.iter().enumerate() {\n                   let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n@@ -701,7 +701,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          foreach (i, arg) in args.iter().enumerate() {\n+          for (i, arg) in args.iter().enumerate() {\n               let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n@@ -729,7 +729,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n                                         n_variants);\n                   let next_cx = sub_block(cx, \"enum-iter-next\");\n \n-                  foreach variant in (*variants).iter() {\n+                  for variant in (*variants).iter() {\n                       let variant_cx =\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n                                     uint::to_str(variant.disr_val));\n@@ -863,7 +863,7 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n             debug!(\"invoking %x at %x\",\n                    ::std::cast::transmute(llfn),\n                    ::std::cast::transmute(bcx.llbb));\n-            foreach &llarg in llargs.iter() {\n+            for &llarg in llargs.iter() {\n                 debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n             }\n         }\n@@ -879,7 +879,7 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n             debug!(\"calling %x at %x\",\n                    ::std::cast::transmute(llfn),\n                    ::std::cast::transmute(bcx.llbb));\n-            foreach &llarg in llargs.iter() {\n+            for &llarg in llargs.iter() {\n                 debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n             }\n         }\n@@ -908,7 +908,7 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n-                foreach cleanup in inf.cleanups.iter() {\n+                for cleanup in inf.cleanups.iter() {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n@@ -1171,7 +1171,7 @@ pub fn new_block(cx: @mut FunctionContext,\n                                   opt_node_info,\n                                   cx);\n         bcx.scope = scope;\n-        foreach cx in parent.iter() {\n+        for cx in parent.iter() {\n             if cx.unreachable {\n                 Unreachable(bcx);\n                 break;\n@@ -1261,7 +1261,7 @@ pub fn trans_block_cleanups_(bcx: @mut Block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    foreach cu in cleanups.rev_iter() {\n+    for cu in cleanups.rev_iter() {\n         match *cu {\n             clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n@@ -1304,7 +1304,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n                         let mut dest = None;\n                         {\n                             let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n-                            foreach cp in r.iter() {\n+                            for cp in r.iter() {\n                                 if cp.size == inf.cleanups.len() {\n                                     Br(bcx, cp.dest);\n                                     return;\n@@ -1326,7 +1326,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n                     bcx = trans_block_cleanups_(sub_cx,\n                                                 inf_cleanups,\n                                                 is_lpad);\n-                    foreach &dest in dest.iter() {\n+                    for &dest in dest.iter() {\n                         Br(bcx, dest);\n                         return;\n                     }\n@@ -1449,7 +1449,7 @@ pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n }\n \n pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n-    foreach s in b.stmts.iter() {\n+    for s in b.stmts.iter() {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n@@ -1624,7 +1624,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         opt_node_info: Option<NodeInfo>,\n                         sp: Option<span>)\n                      -> @mut FunctionContext {\n-    foreach p in param_substs.iter() { p.validate(); }\n+    for p in param_substs.iter() { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, \\\n             param_substs=%s)\",\n@@ -1769,7 +1769,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         _ => {}\n     }\n \n-    foreach arg_n in range(0u, arg_tys.len()) {\n+    for arg_n in range(0u, arg_tys.len()) {\n         let arg_ty = arg_tys[arg_n];\n         let raw_llarg = raw_llargs[arg_n];\n \n@@ -1901,7 +1901,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     // Put return block after all other blocks.\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n-        foreach &llreturn in fcx.llreturn.iter() {\n+        for &llreturn in fcx.llreturn.iter() {\n             llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n         }\n     }\n@@ -1965,7 +1965,7 @@ fn insert_synthetic_type_entries(bcx: @mut Block,\n      */\n \n     let tcx = bcx.tcx();\n-    foreach i in range(0u, fn_args.len()) {\n+    for i in range(0u, fn_args.len()) {\n         debug!(\"setting type of argument %u (pat node %d) to %s\",\n                i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n \n@@ -2090,7 +2090,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let repr = adt::represent_type(ccx, result_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n-    foreach (i, fn_arg) in fn_args.iter().enumerate() {\n+    for (i, fn_arg) in fn_args.iter().enumerate() {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),\n@@ -2106,7 +2106,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n-    foreach variant in enum_definition.variants.iter() {\n+    for variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n@@ -2156,7 +2156,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n                      item.id,\n                      item.attrs);\n         } else {\n-            foreach stmt in body.stmts.iter() {\n+            for stmt in body.stmts.iter() {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n@@ -2189,7 +2189,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier because we need to get\n           // the value of the bool out of LLVM\n-          foreach attr in item.attrs.iter() {\n+          for attr in item.attrs.iter() {\n               if \"static_assert\" == attr.name() {\n                   if m == ast::m_mutbl {\n                       ccx.sess.span_fatal(expr.span,\n@@ -2237,7 +2237,7 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // and control visibility.\n pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n-    foreach item in m.items.iter() {\n+    for item in m.items.iter() {\n         trans_item(ccx, *item);\n     }\n }\n@@ -2625,7 +2625,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n                                                  node: it.id });\n         let mut i = 0;\n         let path = item_path(ccx, &it.id);\n-        foreach variant in (*enum_definition).variants.iter() {\n+        for variant in (*enum_definition).variants.iter() {\n             let p = vec::append(path.clone(), [\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n@@ -2801,11 +2801,11 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     // like the multiple borrows. At least, it doesn't\n     // like them on the current snapshot. (2013-06-14)\n     let mut keys = ~[];\n-    foreach (k, _) in ccx.module_data.iter() {\n+    for (k, _) in ccx.module_data.iter() {\n         keys.push(k.to_managed());\n     }\n \n-    foreach key in keys.iter() {\n+    for key in keys.iter() {\n         let val = *ccx.module_data.find_equiv(key).get();\n         let s_const = C_cstr(ccx, *key);\n         let s_ptr = p2i(ccx, s_const);\n@@ -3032,7 +3032,7 @@ pub fn trans_crate(sess: session::Session,\n         do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n         }\n-        foreach tuple in ccx.stats.fn_stats.iter() {\n+        for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {\n                     printfln!(\"%u insns, %u ms, %s\", insns, ms, *name);\n@@ -3041,7 +3041,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n     }\n     if ccx.sess.count_llvm_insns() {\n-        foreach (k, v) in ccx.stats.llvm_insns.iter() {\n+        for (k, v) in ccx.stats.llvm_insns.iter() {\n             printfln!(\"%-7u %s\", *v, *k);\n         }\n     }"}, {"sha": "d876b4d0b16737c039756f028cc3ec80189d4247", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -516,7 +516,7 @@ impl Builder {\n         // we care about.\n         if ixs.len() < 16 {\n             let mut small_vec = [ C_i32(0), ..16 ];\n-            foreach (small_vec_e, &ix) in small_vec.mut_iter().zip(ixs.iter()) {\n+            for (small_vec_e, &ix) in small_vec.mut_iter().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(ix as i32);\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))"}, {"sha": "3a6577e28b7cceb37c392667de0c107902b335d3", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -42,7 +42,7 @@ impl FnType {\n         let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);\n \n-        foreach (i, a) in self.attrs.iter().enumerate() {\n+        for (i, a) in self.attrs.iter().enumerate() {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {\n@@ -92,7 +92,7 @@ impl FnType {\n \n     pub fn build_shim_ret(&self, bcx: @mut Block, arg_tys: &[Type], ret_def: bool,\n                           llargbundle: ValueRef, llretval: ValueRef) {\n-        foreach (i, a) in self.attrs.iter().enumerate() {\n+        for (i, a) in self.attrs.iter().enumerate() {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {"}, {"sha": "7f1fc5978c4396d68517f5377a8aeac321a37d67", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -133,7 +133,7 @@ impl ABIInfo for ARM_ABIInfo {\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = ~[];\n         let mut attrs = ~[];\n-        foreach &aty in atys.iter() {\n+        for &aty in atys.iter() {\n             let (ty, attr) = classify_arg_ty(aty);\n             arg_tys.push(ty);\n             attrs.push(attr);"}, {"sha": "fe1c288d1773f3e3e7125a1055de9358d99ca7bb", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -190,7 +190,7 @@ impl ABIInfo for MIPS_ABIInfo {\n         let mut attrs = ~[];\n         let mut offset = if sret { 4 } else { 0 };\n \n-        foreach aty in atys.iter() {\n+        for aty in atys.iter() {\n             let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n             arg_tys.push(ty);\n             attrs.push(attr);"}, {"sha": "530e1ff8e5baa77a22b51e4eaaf4e9ce8cf6d4eb", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -145,7 +145,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n-        foreach i in range(0u, cls.len()) {\n+        for i in range(0u, cls.len()) {\n             cls[i] = Memory;\n         }\n     }\n@@ -179,7 +179,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                        cls: &mut [RegClass], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n-        foreach ty in tys.iter() {\n+        for ty in tys.iter() {\n             field_off = align(field_off, *ty);\n             classify(*ty, cls, i, field_off);\n             field_off += ty_size(*ty);\n@@ -294,7 +294,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n fn llreg_ty(cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n-        foreach c in cls.iter() {\n+        for c in cls.iter() {\n             if *c != SSEUp {\n                 break;\n             }\n@@ -355,7 +355,7 @@ fn x86_64_tys(atys: &[Type],\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n-    foreach t in atys.iter() {\n+    for t in atys.iter() {\n         let (ty, attr) = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n         attrs.push(attr);"}, {"sha": "577c4fa021bdcaea3d9414928ea4aaa05522ee13", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -619,7 +619,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         // the cleanup for the self argument\n         match callee.data {\n             Method(d) => {\n-                foreach &v in d.temp_cleanup.iter() {\n+                for &v in d.temp_cleanup.iter() {\n                     revoke_clean(bcx, v);\n                 }\n             }\n@@ -629,7 +629,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         // Uncomment this to debug calls.\n         /*\n         printfln!(\"calling: %s\", bcx.val_to_str(llfn));\n-        foreach llarg in llargs.iter() {\n+        for llarg in llargs.iter() {\n             printfln!(\"arg: %s\", bcx.val_to_str(*llarg));\n         }\n         io::println(\"---\");\n@@ -672,7 +672,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 {\n                     let r = bcx.fcx.loop_ret;\n-                    foreach &(flagptr, _) in r.iter() {\n+                    for &(flagptr, _) in r.iter() {\n                         Store(bcx, C_bool(true), flagptr);\n                         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n                     }\n@@ -729,7 +729,7 @@ pub fn trans_args(cx: @mut Block,\n     match args {\n       ArgExprs(arg_exprs) => {\n         let last = arg_exprs.len() - 1u;\n-        foreach (i, arg_expr) in arg_exprs.iter().enumerate() {\n+        for (i, arg_expr) in arg_exprs.iter().enumerate() {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_tys[i],\n@@ -750,7 +750,7 @@ pub fn trans_args(cx: @mut Block,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    foreach c in temp_cleanups.iter() {\n+    for c in temp_cleanups.iter() {\n         revoke_clean(bcx, *c)\n     }\n "}, {"sha": "ae3b773af0b63f8488669c1029346087d35f3c1f", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -228,7 +228,7 @@ pub fn store_environment(bcx: @mut Block,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    foreach (i, bv) in bound_values.iter().enumerate() {\n+    for (i, bv) in bound_values.iter().enumerate() {\n         debug!(\"Copy %s into closure\", bv.to_str(ccx));\n \n         if ccx.sess.asm_comments() {\n@@ -268,7 +268,7 @@ pub fn build_closure(bcx0: @mut Block,\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n-    foreach cap_var in cap_vars.iter() {\n+    for cap_var in cap_vars.iter() {\n         debug!(\"Building closure: captured variable %?\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n@@ -290,7 +290,7 @@ pub fn build_closure(bcx0: @mut Block,\n \n     // If this is a `for` loop body, add two special environment\n     // variables:\n-    foreach flagptr in include_ret_handle.iter() {\n+    for flagptr in include_ret_handle.iter() {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(),\n                                 mode: ByRef(ZeroMem)};\n@@ -337,7 +337,7 @@ pub fn load_environment(fcx: @mut FunctionContext,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    foreach cap_var in cap_vars.iter() {\n+    for cap_var in cap_vars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n         match sigil {\n             ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }"}, {"sha": "527706be6c1f75a3e3a4960e72543f26437f3c19", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -138,8 +138,8 @@ pub struct param_substs {\n \n impl param_substs {\n     pub fn validate(&self) {\n-        foreach t in self.tys.iter() { assert!(!ty::type_needs_infer(*t)); }\n-        foreach t in self.self_ty.iter() { assert!(!ty::type_needs_infer(*t)); }\n+        for t in self.tys.iter() { assert!(!ty::type_needs_infer(*t)); }\n+        for t in self.self_ty.iter() { assert!(!ty::type_needs_infer(*t)); }\n     }\n }\n \n@@ -437,7 +437,7 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false\n             });\n-        foreach i in cleanup_pos.iter() {\n+        for i in cleanup_pos.iter() {\n             scope_info.cleanups =\n                 vec::append(scope_info.cleanups.slice(0u, *i).to_owned(),\n                             scope_info.cleanups.slice(*i + 1u,\n@@ -943,7 +943,7 @@ pub fn align_to(cx: @mut Block, off: ValueRef, align: ValueRef) -> ValueRef {\n pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     let mut r = ~\"\";\n     let mut first = true;\n-    foreach e in p.iter() {\n+    for e in p.iter() {\n         match *e {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first {"}, {"sha": "4fa64b4130aa9901fc39ece115e5443667814dd7", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -36,7 +36,7 @@ use syntax::codemap::span;\n pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n-    foreach s in b.stmts.iter() {\n+    for s in b.stmts.iter() {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -144,7 +144,7 @@ pub fn trans_if(bcx: @mut Block,\n pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n-    foreach bcx in in_cxs.iter() {\n+    for bcx in in_cxs.iter() {\n         if !bcx.unreachable {\n             Br(*bcx, out.llbb);\n             reachable = true;\n@@ -223,7 +223,7 @@ pub fn trans_log(log_ex: &ast::expr,\n     let (modpath, modname) = {\n         let path = &mut bcx.fcx.path;\n         let mut modpath = ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))];\n-        foreach e in path.iter() {\n+        for e in path.iter() {\n             match *e {\n                 path_mod(_) => { modpath.push(*e) }\n                 _ => {}"}, {"sha": "8cdbd943af70dda44b6a9006dea77292757c7d7c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -1145,7 +1145,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = ~[];\n-                foreach (i, b) in need_base.iter().enumerate() {\n+                for (i, b) in need_base.iter().enumerate() {\n                     if *b {\n                         leftovers.push((i, field_tys[i].mt.ty))\n                     }\n@@ -1199,10 +1199,10 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            foreach &(_i, e) in fields.iter() {\n+            for &(_i, e) in fields.iter() {\n                 bcx = trans_into(bcx, e, Ignore);\n             }\n-            foreach sbi in optbase.iter() {\n+            for sbi in optbase.iter() {\n                 // FIXME #7261: this moves entire base, not just certain fields\n                 bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n@@ -1212,18 +1212,18 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n     };\n     let mut temp_cleanups = ~[];\n     adt::trans_start_init(bcx, repr, addr, discr);\n-    foreach &(i, e) in fields.iter() {\n+    for &(i, e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_into(bcx, e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n         temp_cleanups.push(dest);\n     }\n-    foreach base in optbase.iter() {\n+    for base in optbase.iter() {\n         // FIXME #6573: is it sound to use the destination's repr on the base?\n         // And, would it ever be reasonable to be here with discr != 0?\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n-        foreach &(i, t) in base.fields.iter() {\n+        for &(i, t) in base.fields.iter() {\n             let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n             };\n@@ -1232,7 +1232,7 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n         }\n     }\n \n-    foreach cleanup in temp_cleanups.iter() {\n+    for cleanup in temp_cleanups.iter() {\n         revoke_clean(bcx, *cleanup);\n     }\n     return bcx;"}, {"sha": "20c8e69129d74d1fce99d300e55c3a706062bbe1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -286,7 +286,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         Some(abi) => abi,\n     };\n \n-    foreach &foreign_item in foreign_mod.items.iter() {\n+    for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::foreign_item_fn(*) => {\n                 let id = foreign_item.id;\n@@ -498,7 +498,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n             let _icx = push_ctxt(\"foreign::wrap::build_args\");\n             let ccx = bcx.ccx();\n             let n = tys.llsig.llarg_tys.len();\n-            foreach i in range(0u, n) {\n+            for i in range(0u, n) {\n                 let arg_i = bcx.fcx.arg_pos(i);\n                 let mut llargval = get_param(llwrapfn, arg_i);\n \n@@ -512,7 +512,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                 store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n             }\n \n-            foreach &retptr in bcx.fcx.llretptr.iter() {\n+            for &retptr in bcx.fcx.llretptr.iter() {\n                 store_inbounds(bcx, retptr, llargbundle, [0u, n]);\n             }\n         }\n@@ -522,7 +522,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                      llargbundle: ValueRef) {\n             let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n             let arg_count = shim_types.fn_sig.inputs.len();\n-            foreach &retptr in bcx.fcx.llretptr.iter() {\n+            for &retptr in bcx.fcx.llretptr.iter() {\n                 let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n                 Store(bcx, Load(bcx, llretptr), retptr);\n             }\n@@ -543,7 +543,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         assert!(num_args <= 4);\n         let mut args = [0 as ValueRef, ..4];\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n-        foreach i in range(0u, num_args) {\n+        for i in range(0u, num_args) {\n             args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n         }\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);"}, {"sha": "659f56b355e790c1bf81a1bdbaed02989842506f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -426,7 +426,7 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n \n         // Drop the fields\n         let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-        foreach (i, fld) in field_tys.iter().enumerate() {\n+        for (i, fld) in field_tys.iter().enumerate() {\n             let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n             bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n         }\n@@ -461,7 +461,7 @@ pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n \n     // Drop the fields\n     let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-    foreach (i, fld) in field_tys.iter().enumerate() {\n+    for (i, fld) in field_tys.iter().enumerate() {\n         let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n         bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n     }\n@@ -736,7 +736,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n     ccx.finished_tydescs = true;\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n     let tyds = &mut ccx.tydescs;\n-    foreach (_, &val) in tyds.iter() {\n+    for (_, &val) in tyds.iter() {\n         let ti = val;\n \n         // Each of the glue functions needs to be cast to a generic type"}, {"sha": "3b1fd0ecb6952cf319bd148aeeddf41bb8fab40b", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -68,7 +68,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id)\n             ast::item_enum(_, _) => {\n               let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n               let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n-              foreach (here, there) in vs_here.iter().zip(vs_there.iter()) {\n+              for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   ccx.external.insert(there.id, Some(here.id.node));\n               }"}, {"sha": "ade41151f34108329c5b743c107a162df564bcbb", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -57,7 +57,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n \n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    foreach method in methods.iter() {\n+    for method in methods.iter() {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path.clone(),\n@@ -599,7 +599,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n         let _icx = push_ctxt(\"impl::make_vtable\");\n \n         let mut components = ~[ tydesc.tydesc ];\n-        foreach &ptr in ptrs.iter() {\n+        for &ptr in ptrs.iter() {\n             components.push(ptr)\n         }\n "}, {"sha": "6fd47436fd8849d25dabfd0e3b5c72258f853d8e", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -75,8 +75,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         self_vtables: self_vtables\n     };\n \n-    foreach s in real_substs.tps.iter() { assert!(!ty::type_has_params(*s)); }\n-    foreach s in psubsts.tys.iter() { assert!(!ty::type_has_params(*s)); }\n+    for s in real_substs.tps.iter() { assert!(!ty::type_has_params(*s)); }\n+    for s in psubsts.tys.iter() { assert!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, psubsts.tys.len());\n \n "}, {"sha": "e4259c80720e672401c7e586755b537820b253a0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -96,7 +96,7 @@ impl Reflector {\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", args.len());\n         let mut bcx = self.bcx;\n-        foreach (i, a) in args.iter().enumerate() {\n+        for (i, a) in args.iter().enumerate() {\n             debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n@@ -214,7 +214,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(\"tup\", extra) |this| {\n-                  foreach (i, t) in tys.iter().enumerate() {\n+                  for (i, t) in tys.iter().enumerate() {\n                       let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n                       this.visit(\"tup_field\", extra);\n                   }\n@@ -259,7 +259,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(fields.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(\"class\", extra) |this| {\n-                  foreach (i, field) in fields.iter().enumerate() {\n+                  for (i, field) in fields.iter().enumerate() {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(\n                                         bcx.ccx().sess.str_of(field.ident))]\n@@ -318,14 +318,14 @@ impl Reflector {\n             let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n             do self.bracketed(\"enum\", enum_args) |this| {\n-                foreach (i, v) in variants.iter().enumerate() {\n+                for (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          this.c_uint(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(\"enum_variant\", variant_args) |this| {\n-                        foreach (j, a) in v.args.iter().enumerate() {\n+                        for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n@@ -360,7 +360,7 @@ impl Reflector {\n     }\n \n     pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n-        foreach (i, arg) in sig.inputs.iter().enumerate() {\n+        for (i, arg) in sig.inputs.iter().enumerate() {\n             let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),"}, {"sha": "34404e49317b6d396ef0919f2df47ca2e51b6394", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -374,14 +374,14 @@ pub fn write_content(bcx: @mut Block,\n         ast::expr_vec(ref elements, _) => {\n             match dest {\n                 Ignore => {\n-                    foreach element in elements.iter() {\n+                    for element in elements.iter() {\n                         bcx = expr::trans_into(bcx, *element, Ignore);\n                     }\n                 }\n \n                 SaveIn(lldest) => {\n                     let mut temp_cleanups = ~[];\n-                    foreach (i, element) in elements.iter().enumerate() {\n+                    for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index %? with lleltptr=%?\",\n                                i, bcx.val_to_str(lleltptr));\n@@ -390,7 +390,7 @@ pub fn write_content(bcx: @mut Block,\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n                         temp_cleanups.push(lleltptr);\n                     }\n-                    foreach cleanup in temp_cleanups.iter() {\n+                    for cleanup in temp_cleanups.iter() {\n                         revoke_clean(bcx, *cleanup);\n                     }\n                 }"}, {"sha": "5a722e8e695528daa19ee7a83612d3220d42e901", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -93,7 +93,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     // We also mark all of the params as used if it is an extern thing\n     // that we haven't been able to inline yet.\n     if is_default || fn_id_loc.crate != LOCAL_CRATE {\n-        foreach n in range(0u, n_tps) { cx.uses[n] |= use_all; }\n+        for n in range(0u, n_tps) { cx.uses[n] |= use_all; }\n         return store_type_uses(cx, fn_id);\n     }\n \n@@ -117,13 +117,13 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n         // This will be a static trait method. For now, we just assume\n         // it fully depends on all of the type information. (Doing\n         // otherwise would require finding the actual implementation).\n-        foreach n in range(0u, n_tps) { cx.uses[n] |= use_all;}\n+        for n in range(0u, n_tps) { cx.uses[n] |= use_all;}\n         // We need to return early, before the arguments are processed,\n         // because of difficulties in the handling of Self.\n         return store_type_uses(cx, fn_id);\n       }\n       ast_map::node_variant(_, _, _) => {\n-        foreach n in range(0u, n_tps) { cx.uses[n] |= use_repr;}\n+        for n in range(0u, n_tps) { cx.uses[n] |= use_repr;}\n       }\n       ast_map::node_foreign_item(i@@foreign_item {\n             node: foreign_item_fn(*),\n@@ -172,13 +172,13 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                     _ => fail!(\"unknown intrinsic in type_use\")\n                 }\n             };\n-            foreach n in range(0u, n_tps) { cx.uses[n] |= flags;}\n+            for n in range(0u, n_tps) { cx.uses[n] |= flags;}\n         }\n       }\n       ast_map::node_struct_ctor(*) => {\n         // Similarly to node_variant, this monomorphized function just\n         // uses the representations of all of its type parameters.\n-        foreach n in range(0u, n_tps) { cx.uses[n] |= use_repr; }\n+        for n in range(0u, n_tps) { cx.uses[n] |= use_repr; }\n       }\n       _ => {\n         ccx.tcx.sess.bug(fmt!(\"unknown node type in type_use: %s\",\n@@ -193,7 +193,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-            foreach arg in sig.inputs.iter() {\n+            for arg in sig.inputs.iter() {\n                 type_needs(&cx, use_repr, *arg);\n             }\n         }\n@@ -209,7 +209,7 @@ pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {\n         let uses = &*cx.uses;\n         uses.len()\n     };\n-    foreach i in range(0u, len) {\n+    for i in range(0u, len) {\n         if cx.uses[i] & use_ != use_ {\n             type_needs_inner(cx, use_, ty, @Nil);\n             return;\n@@ -240,8 +240,8 @@ pub fn type_needs_inner(cx: &Context,\n                 if list::find(enums_seen, |id| *id == did).is_none() {\n                     let seen = @Cons(did, enums_seen);\n                     let r = ty::enum_variants(cx.ccx.tcx, did);\n-                    foreach v in r.iter() {\n-                        foreach aty in v.args.iter() {\n+                    for v in r.iter() {\n+                        for aty in v.args.iter() {\n                             let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }\n@@ -267,7 +267,7 @@ pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n     let mut opt_static_did = None;\n     {\n         let r = cx.ccx.maps.method_map.find(&e_id);\n-        foreach mth in r.iter() {\n+        for mth in r.iter() {\n             match mth.origin {\n               typeck::method_static(did) => {\n                   opt_static_did = Some(did);\n@@ -287,12 +287,12 @@ pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n     // above because the recursive call to `type_needs` can trigger\n     // inlining and hence can cause `method_map` and\n     // `node_type_substs` to be modified.\n-    foreach &did in opt_static_did.iter() {\n+    for &did in opt_static_did.iter() {\n         {\n             let r = cx.ccx.tcx.node_type_substs.find_copy(&callee_id);\n-            foreach ts in r.iter() {\n+            for ts in r.iter() {\n                 let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-                foreach (uses, subst) in type_uses.iter().zip(ts.iter()) {\n+                for (uses, subst) in type_uses.iter().zip(ts.iter()) {\n                     type_needs(cx, *uses, *subst)\n                 }\n             }\n@@ -328,10 +328,10 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n       }\n       expr_path(_) | expr_self => {\n         let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n-        foreach ts in opt_ts.iter() {\n+        for ts in opt_ts.iter() {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n-            foreach (uses, subst) in uses_for_ts.iter().zip(ts.iter()) {\n+            for (uses, subst) in uses_for_ts.iter().zip(ts.iter()) {\n                 type_needs(cx, *uses, *subst)\n             }\n         }\n@@ -340,7 +340,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n           match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n               ast::OwnedSigil => {}\n               ast::BorrowedSigil | ast::ManagedSigil => {\n-                  foreach fv in freevars::get_freevars(cx.ccx.tcx, e.id).iter() {\n+                  for fv in freevars::get_freevars(cx.ccx.tcx, e.id).iter() {\n                       let node_id = ast_util::def_id_of_def(fv.def).node;\n                       node_type_needs(cx, use_repr, node_id);\n                   }\n@@ -371,7 +371,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n       }\n       expr_call(f, _, _) => {\n           let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id));\n-          foreach a in r.iter() {\n+          for a in r.iter() {\n               type_needs(cx, use_repr, *a);\n           }\n       }\n@@ -380,17 +380,17 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n         let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, callee_id));\n-        foreach a in r.iter() {\n+        for a in r.iter() {\n             type_needs(cx, use_repr, *a);\n         }\n         mark_for_method_call(cx, e.id, callee_id);\n       }\n \n       expr_inline_asm(ref ia) => {\n-        foreach &(_, input) in ia.inputs.iter() {\n+        for &(_, input) in ia.inputs.iter() {\n           node_type_needs(cx, use_repr, input.id);\n         }\n-        foreach &(_, out) in ia.outputs.iter() {\n+        for &(_, out) in ia.outputs.iter() {\n           node_type_needs(cx, use_repr, out.id);\n         }\n       }\n@@ -422,7 +422,7 @@ pub fn handle_body(cx: &Context, body: &Block) {\n         },\n         visit_block: |b, (cx, v)| {\n             oldvisit::visit_block(b, (cx, v));\n-            foreach e in b.expr.iter() {\n+            for e in b.expr.iter() {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },"}, {"sha": "0e90452fdfa97a77b7e1bf9b64293d598117689d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -958,11 +958,11 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     }\n     fn sflags(substs: &substs) -> uint {\n         let mut f = 0u;\n-        foreach tt in substs.tps.iter() { f |= get(*tt).flags; }\n+        for tt in substs.tps.iter() { f |= get(*tt).flags; }\n         match substs.regions {\n             ErasedRegions => {}\n             NonerasedRegions(ref regions) => {\n-                foreach r in regions.iter() {\n+                for r in regions.iter() {\n                     f |= rflags(*r)\n                 }\n             }\n@@ -1004,16 +1004,16 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n         flags |= rflags(r);\n         flags |= get(m.ty).flags;\n       }\n-      &ty_tup(ref ts) => foreach tt in ts.iter() { flags |= get(*tt).flags; },\n+      &ty_tup(ref ts) => for tt in ts.iter() { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n-        foreach a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n+        for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n         flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n         flags |= rflags(f.region);\n-        foreach a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n+        for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n         flags &= !(has_ty_bot as uint);\n@@ -1268,15 +1268,15 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _, _, _) => {\n-        foreach subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n+        for subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n       }\n-      ty_tup(ref ts) => { foreach tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n+      ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n       ty_bare_fn(ref ft) => {\n-        foreach a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+        for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_closure(ref ft) => {\n-        foreach a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+        for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n     }\n@@ -1765,8 +1765,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, ref substs) => {\n-            foreach v in (*enum_variants(cx, did)).iter() {\n-                foreach aty in v.args.iter() {\n+            for v in (*enum_variants(cx, did)).iter() {\n+                for aty in v.args.iter() {\n                     let t = subst(cx, substs, *aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n@@ -2436,8 +2436,8 @@ pub fn type_structurally_contains(cx: ctxt,\n     if test(sty) { return true; }\n     match *sty {\n       ty_enum(did, ref substs) => {\n-        foreach variant in (*enum_variants(cx, did)).iter() {\n-            foreach aty in variant.args.iter() {\n+        for variant in (*enum_variants(cx, did)).iter() {\n+            for aty in variant.args.iter() {\n                 let sty = subst(cx, substs, *aty);\n                 if type_structurally_contains(cx, sty, |x| test(x)) { return true; }\n             }\n@@ -2446,15 +2446,15 @@ pub fn type_structurally_contains(cx: ctxt,\n       }\n       ty_struct(did, ref substs) => {\n         let r = lookup_struct_fields(cx, did);\n-        foreach field in r.iter() {\n+        for field in r.iter() {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n             if type_structurally_contains(cx, ft, |x| test(x)) { return true; }\n         }\n         return false;\n       }\n \n       ty_tup(ref ts) => {\n-        foreach tt in ts.iter() {\n+        for tt in ts.iter() {\n             if type_structurally_contains(cx, *tt, |x| test(x)) { return true; }\n         }\n         return false;\n@@ -2533,7 +2533,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-        foreach variant in (*variants).iter() {\n+        for variant in (*variants).iter() {\n             // XXX(pcwalton): This is an inefficient way to do this. Don't\n             // synthesize a tuple!\n             //\n@@ -2544,7 +2544,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         }\n       }\n       ty_tup(ref elts) => {\n-        foreach elt in elts.iter() { if !type_is_pod(cx, *elt) { result = false; } }\n+        for elt in elts.iter() { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n       ty_estr(vstore_fixed(_)) => result = true,\n       ty_evec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n@@ -2963,7 +2963,7 @@ pub fn adjust_ty(cx: ctxt,\n             let mut adjusted_ty = unadjusted_ty;\n \n             if (!ty::type_is_error(adjusted_ty)) {\n-                foreach i in range(0, adj.autoderefs) {\n+                for i in range(0, adj.autoderefs) {\n                     match ty::deref(cx, adjusted_ty, true) {\n                         Some(mt) => { adjusted_ty = mt.ty; }\n                         None => {\n@@ -3274,14 +3274,14 @@ pub fn stmt_node_id(s: &ast::stmt) -> ast::NodeId {\n \n pub fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n-    foreach f in fields.iter() { if f.ident == id { return Some(i); } i += 1u; }\n+    for f in fields.iter() { if f.ident == id { return Some(i); } i += 1u; }\n     return None;\n }\n \n pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n-    foreach f in fields.iter() { if f.ident == id { return i; } i += 1u; }\n+    for f in fields.iter() { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n         tcx.sess.str_of(id),\n@@ -4384,7 +4384,7 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::NodeId),\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &[@TraitRef],\n                                         f: &fn(@TraitRef) -> bool) -> bool {\n-    foreach &bound_trait_ref in bounds.iter() {\n+    for &bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];\n         let mut i = 0;\n@@ -4404,7 +4404,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n \n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n-            foreach &supertrait_ref in supertrait_refs.iter() {\n+            for &supertrait_ref in supertrait_refs.iter() {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n                        supertrait_ref.repr(tcx));\n \n@@ -4425,7 +4425,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n-    foreach type_param_def in type_param_defs.iter() {\n+    for type_param_def in type_param_defs.iter() {\n         do each_bound_trait_and_supertraits(\n             tcx, type_param_def.bounds.trait_bounds) |_| {\n             total += 1;"}, {"sha": "ebf9d0944c9fbb8335d9ccdbd43ff948555fdd0c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -768,7 +768,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n     match (ast_bounds, store) {\n         (&Some(ref bound_vec), _) => {\n             let mut builtin_bounds = ty::EmptyBuiltinBounds();\n-            foreach ast_bound in bound_vec.iter() {\n+            for ast_bound in bound_vec.iter() {\n                 match *ast_bound {\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {"}, {"sha": "842bbff41e065689914c5617b8b2bbeabc31c8d6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -35,13 +35,13 @@ pub fn check_match(fcx: @mut FnCtxt,\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n-    foreach arm in arms.iter() {\n+    for arm in arms.iter() {\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n         };\n \n-        foreach p in arm.pats.iter() { check_pat(&pcx, *p, discrim_ty);}\n+        for p in arm.pats.iter() { check_pat(&pcx, *p, discrim_ty);}\n     }\n \n     // The result of the match is the common supertype of all the\n@@ -55,7 +55,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n \n     // Now typecheck the blocks.\n     let mut saw_err = ty::type_is_error(discrim_ty);\n-    foreach arm in arms.iter() {\n+    for arm in arms.iter() {\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n@@ -239,8 +239,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n         }\n \n         if !error_happened {\n-            foreach pats in subpats.iter() {\n-                foreach (subpat, arg_ty) in pats.iter().zip(arg_types.iter()) {\n+            for pats in subpats.iter() {\n+                for (subpat, arg_ty) in pats.iter().zip(arg_types.iter()) {\n                     check_pat(pcx, *subpat, *arg_ty);\n                 }\n             }\n@@ -256,8 +256,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n     }\n \n     if error_happened {\n-        foreach pats in subpats.iter() {\n-            foreach pat in pats.iter() {\n+        for pats in subpats.iter() {\n+            for pat in pats.iter() {\n                 check_pat(pcx, *pat, ty::mk_err());\n             }\n         }\n@@ -283,13 +283,13 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Index the class fields.\n     let mut field_map = HashMap::new();\n-    foreach (i, class_field) in class_fields.iter().enumerate() {\n+    for (i, class_field) in class_fields.iter().enumerate() {\n         field_map.insert(class_field.ident, i);\n     }\n \n     // Typecheck each field.\n     let mut found_fields = HashSet::new();\n-    foreach field in fields.iter() {\n+    for field in fields.iter() {\n         match field_map.find(&field.ident) {\n             Some(&index) => {\n                 let class_field = class_fields[index];\n@@ -312,7 +312,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Report an error if not all the fields were specified.\n     if !etc {\n-        foreach (i, field) in class_fields.iter().enumerate() {\n+        for (i, field) in class_fields.iter().enumerate() {\n             if found_fields.contains(&i) {\n                 loop;\n             }\n@@ -518,13 +518,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         let e_count = elts.len();\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n-                foreach (i, elt) in elts.iter().enumerate() {\n+                for (i, elt) in elts.iter().enumerate() {\n                     check_pat(pcx, *elt, ex_elts[i]);\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }\n             _ => {\n-                foreach elt in elts.iter() {\n+                for elt in elts.iter() {\n                     check_pat(pcx, *elt, ty::mk_err());\n                 }\n                 // use terr_tuple_size if both types are tuples\n@@ -572,13 +572,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             (mt, default_region_var)\n           },\n           _ => {\n-              foreach &elt in before.iter() {\n+              for &elt in before.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n-              foreach &elt in slice.iter() {\n+              for &elt in slice.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n-              foreach &elt in after.iter() {\n+              for &elt in after.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n               fcx.infcx().type_error_message_str_with_expected(\n@@ -594,7 +594,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               return;\n           }\n         };\n-        foreach elt in before.iter() {\n+        for elt in before.iter() {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n         match slice {\n@@ -607,7 +607,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n             None => ()\n         }\n-        foreach elt in after.iter() {\n+        for elt in after.iter() {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n         fcx.write_ty(pat.id, expected);"}, {"sha": "209f636ddc238d588f867b3cb233306f8f61c319", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -313,12 +313,12 @@ impl<'self> LookupContext<'self> {\n         // candidates.\n         let trait_map: &mut resolve::TraitMap = &mut self.fcx.ccx.trait_map;\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n-        foreach applicable_traits in opt_applicable_traits.iter() {\n-            foreach trait_did in applicable_traits.iter() {\n+        for applicable_traits in opt_applicable_traits.iter() {\n+            for trait_did in applicable_traits.iter() {\n                 // Look for explicit implementations.\n                 let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n-                foreach impl_infos in opt_impl_infos.iter() {\n-                    foreach impl_info in impl_infos.iter() {\n+                for impl_infos in opt_impl_infos.iter() {\n+                    for impl_info in impl_infos.iter() {\n                         self.push_candidates_from_impl(\n                             self.extension_candidates, *impl_info);\n \n@@ -461,8 +461,8 @@ impl<'self> LookupContext<'self> {\n \n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n-        foreach impl_infos in opt_impl_infos.iter() {\n-            foreach impl_info in impl_infos.iter() {\n+        for impl_infos in opt_impl_infos.iter() {\n+            for impl_info in impl_infos.iter() {\n                 self.push_candidates_from_impl(\n                     self.inherent_candidates, *impl_info);\n             }\n@@ -708,7 +708,7 @@ impl<'self> LookupContext<'self> {\n         let region =\n             self.infcx().next_region_var(\n                 infer::Autoref(self.expr.span));\n-        foreach mutbl in mutbls.iter() {\n+        for mutbl in mutbls.iter() {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}\n@@ -772,7 +772,7 @@ impl<'self> LookupContext<'self> {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 \"multiple applicable methods in scope\");\n-            foreach idx in range(0u, relevant_candidates.len()) {\n+            for idx in range(0u, relevant_candidates.len()) {\n                 self.report_candidate(idx, &relevant_candidates[idx].origin);\n             }\n         }"}, {"sha": "4ab79ac1c8fe20fefb2d3d31137a6aff01adfdf6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -428,10 +428,10 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n       None => ()\n     }\n \n-    foreach self_info in opt_self_info.iter() {\n+    for self_info in opt_self_info.iter() {\n         fcx.write_ty(self_info.self_id, self_info.self_ty);\n     }\n-    foreach (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n+    for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n         fcx.write_ty(input.id, *arg);\n     }\n \n@@ -460,15 +460,15 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add the self parameter\n-        foreach self_info in opt_self_info.iter() {\n+        for self_info in opt_self_info.iter() {\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n-        foreach (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n+        for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n             do pat_util::pat_bindings(tcx.def_map, input.pat)\n                     |_bm, pat_id, _sp, _path| {\n@@ -570,7 +570,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::ident, span)]) {\n     let mut field_names = HashMap::new();\n \n-    foreach p in fields.iter() {\n+    for p in fields.iter() {\n         let (id, sp) = *p;\n         let orig_sp = field_names.find(&id).map_consume(|x| *x);\n         match orig_sp {\n@@ -619,13 +619,13 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n-        foreach m in ms.iter() {\n+        for m in ms.iter() {\n             check_method(ccx, *m);\n         }\n         vtable::resolve_impl(ccx, it);\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n-        foreach trait_method in (*trait_methods).iter() {\n+        for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n@@ -646,11 +646,11 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_foreign_mod(ref m) => {\n         if m.abis.is_intrinsic() {\n-            foreach item in m.items.iter() {\n+            for item in m.items.iter() {\n                 check_intrinsic_type(ccx, *item);\n             }\n         } else {\n-            foreach item in m.items.iter() {\n+            for item in m.items.iter() {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if tpt.generics.has_type_params() {\n                     ccx.tcx.sess.span_err(\n@@ -1261,7 +1261,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         let xs = [false, true];\n-        foreach check_blocks in xs.iter() {\n+        for check_blocks in xs.iter() {\n             let check_blocks = *check_blocks;\n             debug!(\"check_blocks=%b\", check_blocks);\n \n@@ -1272,7 +1272,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 vtable::early_resolve_expr(callee_expr, fcx, true);\n             }\n \n-            foreach (i, arg) in args.iter().enumerate() {\n+            for (i, arg) in args.iter().enumerate() {\n                 let is_block = match arg.node {\n                     ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n                     ast::expr_do_body(*) => true,\n@@ -1887,14 +1887,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let mut class_field_map = HashMap::new();\n         let mut fields_found = 0;\n-        foreach field in field_types.iter() {\n+        for field in field_types.iter() {\n             class_field_map.insert(field.ident, (field.id, false));\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n-        foreach field in ast_fields.iter() {\n+        for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n             let pair = class_field_map.find(&field.ident).\n@@ -1940,7 +1940,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n-                foreach class_field in field_types.iter() {\n+                for class_field in field_types.iter() {\n                     let name = class_field.ident;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n@@ -2262,7 +2262,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => mutability = mutbl\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            foreach e in args.iter() {\n+            for e in args.iter() {\n                 check_expr_has_type(fcx, *e, t);\n                 let arg_t = fcx.expr_ty(*e);\n                 if ty::type_is_error(arg_t) {\n@@ -2482,10 +2482,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n       }\n       ast::expr_inline_asm(ref ia) => {\n-          foreach &(_, input) in ia.inputs.iter() {\n+          for &(_, input) in ia.inputs.iter() {\n               check_expr(fcx, input);\n           }\n-          foreach &(_, out) in ia.outputs.iter() {\n+          for &(_, out) in ia.outputs.iter() {\n               check_expr(fcx, out);\n           }\n           fcx.write_nil(id);\n@@ -2750,7 +2750,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_vec(ref args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        foreach e in args.iter() {\n+        for e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n         }\n         let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n@@ -3008,7 +3008,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n         let mut last_was_bot = false;\n         let mut any_bot = false;\n         let mut any_err = false;\n-        foreach s in blk.stmts.iter() {\n+        for s in blk.stmts.iter() {\n             check_stmt(fcx, *s);\n             let s_id = ast_util::stmt_id(*s);\n             let s_ty = fcx.node_ty(s_id);\n@@ -3147,7 +3147,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n         let mut disr_vals: ~[uint] = ~[];\n         let mut prev_disr_val: Option<uint> = None;\n \n-        foreach v in vs.iter() {\n+        for v in vs.iter() {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -3475,7 +3475,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n             true\n         });\n \n-    foreach (i, b) in tps_used.iter().enumerate() {\n+    for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\","}, {"sha": "3da7066843498c1513226c9eb9606daa6c4cbd36", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -195,7 +195,7 @@ fn visit_block(b: &ast::Block, (rcx, v): (@mut Rcx, rvt)) {\n \n fn visit_arm(arm: &ast::arm, (rcx, v): (@mut Rcx, rvt)) {\n     // see above\n-    foreach &p in arm.pats.iter() {\n+    for &p in arm.pats.iter() {\n         constrain_bindings_in_pat(p, rcx);\n     }\n \n@@ -281,8 +281,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n         }\n         ast::expr_match(_, ref arms) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n-            foreach arm in arms.iter() {\n-                foreach guard in arm.guard.iter() {\n+            for arm in arms.iter() {\n+                for guard in arm.guard.iter() {\n                     tcx.region_maps.record_cleanup_scope(guard.id);\n                 }\n             }\n@@ -300,15 +300,15 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n     // Check any autoderefs or autorefs that appear.\n     {\n         let r = rcx.fcx.inh.adjustments.find(&expr.id);\n-        foreach &adjustment in r.iter() {\n+        for &adjustment in r.iter() {\n             debug!(\"adjustment=%?\", adjustment);\n             match *adjustment {\n                 @ty::AutoDerefRef(\n                     ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n                 {\n                     let expr_ty = rcx.resolve_node_type(expr.id);\n                     constrain_derefs(rcx, expr, autoderefs, expr_ty);\n-                    foreach autoref in opt_autoref.iter() {\n+                    for autoref in opt_autoref.iter() {\n                         guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n \n                         // Require that the resulting region encompasses\n@@ -556,7 +556,7 @@ fn constrain_call(rcx: @mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::re_scope(callee_scope);\n \n-    foreach &arg_expr in arg_exprs.iter() {\n+    for &arg_expr in arg_exprs.iter() {\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n@@ -573,7 +573,7 @@ fn constrain_call(rcx: @mut Rcx,\n     }\n \n     // as loop above, but for receiver\n-    foreach &r in receiver.iter() {\n+    for &r in receiver.iter() {\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n@@ -601,7 +601,7 @@ fn constrain_derefs(rcx: @mut Rcx,\n      */\n     let tcx = rcx.fcx.tcx();\n     let r_deref_expr = ty::re_scope(deref_expr.id);\n-    foreach i in range(0u, derefs) {\n+    for i in range(0u, derefs) {\n         debug!(\"constrain_derefs(deref_expr=?, derefd_ty=%s, derefs=%?/%?\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n@@ -669,7 +669,7 @@ fn constrain_free_variables(rcx: @mut Rcx,\n     let tcx = rcx.fcx.ccx.tcx;\n     debug!(\"constrain_free_variables(%s, %s)\",\n            region.repr(tcx), expr.repr(tcx));\n-    foreach freevar in get_freevars(tcx, expr.id).iter() {\n+    for freevar in get_freevars(tcx, expr.id).iter() {\n         debug!(\"freevar def is %?\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n@@ -834,8 +834,8 @@ pub mod guarantor {\n         debug!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n         debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n-        foreach arm in arms.iter() {\n-            foreach pat in arm.pats.iter() {\n+        for arm in arms.iter() {\n+            for pat in arm.pats.iter() {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n             }\n         }\n@@ -885,7 +885,7 @@ pub mod guarantor {\n             sub_region: ty::Region,\n             sup_region: Option<ty::Region>)\n         {\n-            foreach r in sup_region.iter() {\n+            for r in sup_region.iter() {\n                 rcx.fcx.mk_subr(true, infer::Reborrow(expr.span),\n                                 sub_region, *r);\n             }\n@@ -908,7 +908,7 @@ pub mod guarantor {\n         debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n                expr.id, callee_scope, expr_cat);\n         let minimum_lifetime = ty::re_scope(callee_scope);\n-        foreach guarantor in expr_cat.guarantor.iter() {\n+        for guarantor in expr_cat.guarantor.iter() {\n             mk_subregion_due_to_derefence(rcx, expr.span,\n                                           minimum_lifetime, *guarantor);\n         }\n@@ -1131,7 +1131,7 @@ pub mod guarantor {\n             return ct;\n         }\n \n-        foreach _ in range(0u, autoderefs) {\n+        for _ in range(0u, autoderefs) {\n             ct.cat.guarantor = guarantor_of_deref(&ct.cat);\n \n             match ty::deref(tcx, ct.ty, true) {\n@@ -1214,12 +1214,12 @@ pub mod guarantor {\n             ast::pat_ident(ast::bind_by_ref(_), _, opt_p) => {\n                 link(rcx, pat.span, pat.id, guarantor);\n \n-                foreach p in opt_p.iter() {\n+                for p in opt_p.iter() {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n             ast::pat_ident(_, _, opt_p) => {\n-                foreach p in opt_p.iter() {\n+                for p in opt_p.iter() {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n@@ -1228,7 +1228,7 @@ pub mod guarantor {\n                 link_ref_bindings_in_pats(rcx, pats, guarantor);\n             }\n             ast::pat_struct(_, ref fpats, _) => {\n-                foreach fpat in fpats.iter() {\n+                for fpat in fpats.iter() {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n                 }\n             }\n@@ -1258,7 +1258,7 @@ pub mod guarantor {\n                 };\n \n                 link_ref_bindings_in_pats(rcx, before, guarantor1);\n-                foreach &p in slice.iter() {\n+                for &p in slice.iter() {\n                     link_ref_bindings_in_pat(rcx, p, guarantor);\n                 }\n                 link_ref_bindings_in_pats(rcx, after, guarantor1);\n@@ -1269,7 +1269,7 @@ pub mod guarantor {\n     fn link_ref_bindings_in_pats(rcx: @mut Rcx,\n                                  pats: &~[@ast::pat],\n                                  guarantor: Option<ty::Region>) {\n-        foreach pat in pats.iter() {\n+        for pat in pats.iter() {\n             link_ref_bindings_in_pat(rcx, *pat, guarantor);\n         }\n     }"}, {"sha": "2685055bd84aa6083376511dd2c9098f780ef84a", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -32,11 +32,11 @@ pub fn replace_bound_regions_in_fn_sig(\n {\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n-    foreach &self_ty in opt_self_ty.iter() {\n+    for &self_ty in opt_self_ty.iter() {\n         all_tys.push(self_ty);\n     }\n \n-    foreach &t in opt_self_ty.iter() { all_tys.push(t) }\n+    for &t in opt_self_ty.iter() { all_tys.push(t) }\n \n     debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n             all_tys=%?)\",\n@@ -199,7 +199,7 @@ pub fn relate_nested_regions(\n      */\n \n     let mut the_stack = ~[];\n-    foreach &r in opt_region.iter() { the_stack.push(r); }\n+    for &r in opt_region.iter() { the_stack.push(r); }\n     walk_ty(tcx, &mut the_stack, ty, relate_op);\n \n     fn walk_ty(tcx: ty::ctxt,\n@@ -230,7 +230,7 @@ pub fn relate_nested_regions(\n               r_sub: ty::Region,\n               relate_op: &fn(ty::Region, ty::Region))\n     {\n-        foreach &r in the_stack.iter() {\n+        for &r in the_stack.iter() {\n             if !r.is_bound() && !r_sub.is_bound() {\n                 relate_op(r, r_sub);\n             }\n@@ -258,14 +258,14 @@ pub fn relate_free_regions(\n     debug!(\"relate_free_regions >>\");\n \n     let mut all_tys = ~[];\n-    foreach arg in fn_sig.inputs.iter() {\n+    for arg in fn_sig.inputs.iter() {\n         all_tys.push(*arg);\n     }\n-    foreach &t in self_ty.iter() {\n+    for &t in self_ty.iter() {\n         all_tys.push(t);\n     }\n \n-    foreach &t in all_tys.iter() {\n+    for &t in all_tys.iter() {\n         debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {"}, {"sha": "abb97f0d1c7b9d7ed10c1a8cc4b532fa4dacad51", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -327,7 +327,7 @@ fn search_for_vtable(vcx: &VtableContext,\n     let impls = tcx.trait_impls.find(&trait_ref.def_id)\n         .map_default(@mut ~[], |x| **x);\n     // impls is the list of all impls in scope for trait_ref.\n-    foreach im in impls.iter() {\n+    for im in impls.iter() {\n         // im is one specific impl of trait_ref.\n \n         // First, ensure we haven't processed this impl yet."}, {"sha": "e62f562d9b3c7553644ff5cfbd4a6f8504f209b6", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -66,7 +66,7 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n         Some(mme) => {\n             {\n                 let r = resolve_type_vars_in_type(fcx, sp, mme.self_ty);\n-                foreach t in r.iter() {\n+                for t in r.iter() {\n                     let method_map = fcx.ccx.method_map;\n                     let new_entry = method_map_entry { self_ty: *t, ..*mme };\n                     debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n@@ -181,7 +181,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::NodeId)\n         let mut ret = Some(t);\n         do fcx.opt_node_ty_substs(id) |substs| {\n           let mut new_tps = ~[];\n-          foreach subst in substs.tps.iter() {\n+          for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),\n                 None => { wbcx.success = false; ret = None; break }\n@@ -232,22 +232,22 @@ fn visit_expr(e: @ast::expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     {\n         let r = e.get_callee_id();\n-        foreach callee_id in r.iter() {\n+        for callee_id in r.iter() {\n             resolve_method_map_entry(wbcx.fcx, e.span, *callee_id);\n         }\n     }\n \n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n     {\n         let r = e.get_callee_id();\n-        foreach callee_id in r.iter() {\n+        for callee_id in r.iter() {\n             resolve_vtable_map_entry(wbcx.fcx, e.span, *callee_id);\n         }\n     }\n \n     match e.node {\n         ast::expr_fn_block(ref decl, _) => {\n-            foreach input in decl.inputs.iter() {\n+            for input in decl.inputs.iter() {\n                 let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n         }\n@@ -343,12 +343,12 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, (wbcx, visit));\n-    foreach self_info in self_info.iter() {\n+    for self_info in self_info.iter() {\n         resolve_type_vars_for_node(wbcx,\n                                    self_info.span,\n                                    self_info.self_id);\n     }\n-    foreach arg in decl.inputs.iter() {\n+    for arg in decl.inputs.iter() {\n         (visit.visit_pat)(arg.pat, (wbcx, visit));\n         // Privacy needs the type for the whole pattern, not just each binding\n         if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {"}, {"sha": "baf0f2f209ae12765f37a095febe41508e3c4d1d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -242,7 +242,7 @@ impl CoherenceChecker {\n \n         let implementation = self.create_impl_from_item(item);\n \n-        foreach associated_trait in associated_traits.iter() {\n+        for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 self.crate_context.tcx, associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n@@ -289,7 +289,7 @@ impl CoherenceChecker {\n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n \n         let provided = ty::provided_trait_methods(tcx, trait_ref.def_id);\n-        foreach trait_method in provided.iter() {\n+        for trait_method in provided.iter() {\n             // Synthesize an ID.\n             let new_id = parse::next_node_id(tcx.sess.parse_sess);\n             let new_did = local_def(new_id);\n@@ -409,7 +409,7 @@ impl CoherenceChecker {\n     pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n         match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n-                foreach &im in impls.iter() {\n+                for &im in impls.iter() {\n                     f(im);\n                 }\n             }\n@@ -551,12 +551,12 @@ impl CoherenceChecker {\n \n         let mut provided_names = HashSet::new();\n         // Implemented methods\n-        foreach i in range(0u, all_methods.len()) {\n+        for i in range(0u, all_methods.len()) {\n             provided_names.insert(all_methods[i].ident);\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);\n-        foreach method in r.iter() {\n+        for method in r.iter() {\n             debug!(\"checking for %s\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident) { loop; }\n \n@@ -612,11 +612,11 @@ impl CoherenceChecker {\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n-                foreach ast_method in ast_methods.iter() {\n+                for ast_method in ast_methods.iter() {\n                     methods.push(ty::method(tcx, local_def(ast_method.id)));\n                 }\n \n-                foreach trait_ref in trait_refs.iter() {\n+                for trait_ref in trait_refs.iter() {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n@@ -698,14 +698,14 @@ impl CoherenceChecker {\n         }\n \n         // Record all the trait methods.\n-        foreach trait_ref in associated_traits.iter() {\n+        for trait_ref in associated_traits.iter() {\n               self.add_trait_impl(trait_ref.def_id, implementation);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        foreach method in implementation.methods.iter() {\n-            foreach source in method.provided_source.iter() {\n+        for method in implementation.methods.iter() {\n+            for source in method.provided_source.iter() {\n                 tcx.provided_method_sources.insert(method.def_id, *source);\n             }\n         }\n@@ -768,7 +768,7 @@ impl CoherenceChecker {\n             Some(found_impls) => impls = found_impls\n         }\n \n-        foreach impl_info in impls.iter() {\n+        for impl_info in impls.iter() {\n             if impl_info.methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 loop;"}, {"sha": "2bef2c08bb22d983e3fa5ea398f981b44bfed85a", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -143,7 +143,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n-    foreach variant in variants.iter() {\n+    for variant in variants.iter() {\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n \n@@ -208,7 +208,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.methods` table:\n-            foreach m in ms.iter() {\n+            for m in ms.iter() {\n                 let ty_method = @match m {\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n@@ -395,7 +395,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n-    foreach ast_trait_ref in ast_trait_refs.iter() {\n+    for ast_trait_ref in ast_trait_refs.iter() {\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n \n@@ -494,7 +494,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         return;\n     }\n \n-    foreach (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n+    for (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n         // For each of the corresponding impl ty param's bounds...\n         let impl_param_def = &impl_m.generics.type_param_defs[i];\n \n@@ -558,10 +558,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // For both the trait and the impl, create an argument to\n     // represent the self argument (unless this is a static method).\n     // This argument will have the *transformed* self type.\n-    foreach &t in trait_m.transformed_self_ty.iter() {\n+    for &t in trait_m.transformed_self_ty.iter() {\n         trait_fn_args.push(t);\n     }\n-    foreach &t in impl_m.transformed_self_ty.iter() {\n+    for &t in impl_m.transformed_self_ty.iter() {\n         impl_fn_args.push(t);\n     }\n \n@@ -674,7 +674,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // Trait methods we don't implement must be default methods, but if not\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n-    foreach impl_m in impl_ms.iter() {\n+    for impl_m in impl_ms.iter() {\n         match trait_ms.iter().find_(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n@@ -805,7 +805,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n-    foreach ty_param in generics.ty_params.iter() {\n+    for ty_param in generics.ty_params.iter() {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n@@ -858,7 +858,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         let cms = convert_methods(ccx, it.id, *ms, selfty,\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n-        foreach t in opt_trait_ref.iter() {\n+        for t in opt_trait_ref.iter() {\n             check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n@@ -912,7 +912,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members\n-    foreach f in struct_def.fields.iter() {\n+    for f in struct_def.fields.iter() {\n        convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);\n     }\n     let (_, substs) = mk_item_substs(ccx, generics, rp, None);\n@@ -1203,7 +1203,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n             builtin_bounds: ty::EmptyBuiltinBounds(),\n             trait_bounds: ~[]\n         };\n-        foreach ast_bound in ast_bounds.iter() {\n+        for ast_bound in ast_bounds.iter() {\n             match *ast_bound {\n                 TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);"}, {"sha": "1b325dd8a4b99fec36cab5e3bfd65cd0a2aaac72", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -114,7 +114,7 @@ pub trait ErrorReporting {\n impl ErrorReporting for InferCtxt {\n     pub fn report_region_errors(@mut self,\n                                 errors: &OptVec<RegionResolutionError>) {\n-        foreach error in errors.iter() {\n+        for error in errors.iter() {\n             match *error {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup);"}, {"sha": "b9a62acd0bd879f21d7344b620b6262da850c7bf", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -219,7 +219,7 @@ impl Combine for Glb {\n             let mut a_r = None;\n             let mut b_r = None;\n             let mut only_new_vars = true;\n-            foreach r in tainted.iter() {\n+            for r in tainted.iter() {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n                         return fresh_bound_variable(this);"}, {"sha": "854ee835cc7dce534006f1787ea4eb07d52ce212", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -730,7 +730,7 @@ impl InferCtxt {\n                         fmt!(\"%s%s\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n                 }\n             }\n-            foreach err in err.iter() {\n+            for err in err.iter() {\n                 ty::note_and_explain_type_err(self.tcx, *err)\n             }\n         }"}, {"sha": "63503f3e6b6c6c94d0039003747647204fc360c7", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -374,7 +374,7 @@ impl RegionVarBindings {\n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n                                        -> ~[RegionVid] {\n         do vec::build |push| {\n-            foreach i in range(snapshot, self.undo_log.len()) {\n+            for i in range(snapshot, self.undo_log.len()) {\n                 match self.undo_log[i] {\n                     AddVar(vid) => push(vid),\n                     _ => ()\n@@ -916,7 +916,7 @@ impl RegionVarBindings {\n         &self,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n-        foreach (constraint, _) in self.constraints.iter() {\n+        for (constraint, _) in self.constraints.iter() {\n             let (sub, sup) = match *constraint {\n                 ConstrainVarSubVar(*) |\n                 ConstrainRegSubVar(*) |\n@@ -962,7 +962,7 @@ impl RegionVarBindings {\n \n         let mut opt_graph = None;\n \n-        foreach idx in range(0u, self.num_vars()) {\n+        for idx in range(0u, self.num_vars()) {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1027,12 +1027,12 @@ impl RegionVarBindings {\n         let mut graph = graph::Graph::with_capacity(num_vars + 1,\n                                                     num_edges);\n \n-        foreach _ in range(0u, num_vars) {\n+        for _ in range(0u, num_vars) {\n             graph.add_node(());\n         }\n         let dummy_idx = graph.add_node(());\n \n-        foreach (constraint, _) in self.constraints.iter() {\n+        for (constraint, _) in self.constraints.iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n                     graph.add_edge(NodeIndex(a_id.to_uint()),\n@@ -1080,8 +1080,8 @@ impl RegionVarBindings {\n             return;\n         }\n \n-        foreach lower_bound in lower_bounds.iter() {\n-            foreach upper_bound in upper_bounds.iter() {\n+        for lower_bound in lower_bounds.iter() {\n+            for upper_bound in upper_bounds.iter() {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n@@ -1122,8 +1122,8 @@ impl RegionVarBindings {\n             return;\n         }\n \n-        foreach upper_bound_1 in upper_bounds.iter() {\n-            foreach upper_bound_2 in upper_bounds.iter() {\n+        for upper_bound_1 in upper_bounds.iter() {\n+            for upper_bound_2 in upper_bounds.iter() {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n@@ -1243,7 +1243,7 @@ impl RegionVarBindings {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- %s Iteration #%u\", tag, iteration);\n-            foreach (constraint, _) in self.constraints.iter() {\n+            for (constraint, _) in self.constraints.iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint %s\","}, {"sha": "441e71d4722b8fdfb26715dc72d0fd7b0a4ed5d5", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -196,7 +196,7 @@ impl Combine for Sub {\n         do list::each(skol_isr) |pair| {\n             let (skol_br, skol) = *pair;\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n-            foreach tainted_region in tainted.iter() {\n+            for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {"}, {"sha": "3aeea2bcc3b969cf12b32bcd69c3ce7ab8ebb889", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -79,7 +79,7 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n \n impl Env {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n-        foreach child_rh in rh.sub.iter() {\n+        for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n             self.tcx.region_map.insert(child_rh.id, rh.id);\n         }\n@@ -109,7 +109,7 @@ impl Env {\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n             assert!(idx < names.len());\n-            foreach item in m.items.iter() {\n+            for item in m.items.iter() {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n                     return search(self, *item, idx+1, names);\n                 }\n@@ -227,7 +227,7 @@ impl Env {\n \n         self.infcx.resolve_regions();\n         if self.err_messages.len() != exp_count {\n-            foreach msg in self.err_messages.iter() {\n+            for msg in self.err_messages.iter() {\n                 debug!(\"Error encountered: %s\", *msg);\n             }\n             fmt!(\"Resolving regions encountered %u errors but expected %u!\","}, {"sha": "e2b25a67c3ddeb3d24d75df9570205d1534f8ec2", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -58,7 +58,7 @@ impl RegionParamNames {\n     }\n \n     fn has_ident(&self, ident: ast::ident) -> bool {\n-        foreach region_param_name in self.iter() {\n+        for region_param_name in self.iter() {\n             if *region_param_name == ident {\n                 return true;\n             }\n@@ -76,7 +76,7 @@ impl RegionParamNames {\n                             opt_vec::Vec(new_lifetimes.map(|lt| lt.ident)));\n                     }\n                     opt_vec::Vec(ref mut existing_lifetimes) => {\n-                        foreach new_lifetime in new_lifetimes.iter() {\n+                        for new_lifetime in new_lifetimes.iter() {\n                             existing_lifetimes.push(new_lifetime.ident);\n                         }\n                     }"}, {"sha": "c48b30e81416439ad86c9e9217e8bfb10f43ee5a", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -152,7 +152,7 @@ Available lint options:\n     lint_dict.qsort();\n \n     let mut max_key = 0;\n-    foreach &(_, name) in lint_dict.iter() {\n+    for &(_, name) in lint_dict.iter() {\n         max_key = num::max(name.len(), max_key);\n     }\n     fn padded(max: uint, s: &str) -> ~str {\n@@ -163,7 +163,7 @@ Available lint options:\n               padded(max_key, \"name\"), \"default\", \"meaning\");\n     printfln!(\"    %s  %7.7s  %s\\n\",\n               padded(max_key, \"----\"), \"-------\", \"-------\");\n-    foreach (spec, name) in lint_dict.consume_iter() {\n+    for (spec, name) in lint_dict.consume_iter() {\n         let name = name.replace(\"_\", \"-\");\n         printfln!(\"    %s  %7.7s  %s\",\n                   padded(max_key, name),\n@@ -176,7 +176,7 @@ Available lint options:\n pub fn describe_debug_flags() {\n     printfln!(\"\\nAvailable debug options:\\n\");\n     let r = session::debugging_opts_map();\n-    foreach tuple in r.iter() {\n+    for tuple in r.iter() {\n         match *tuple {\n             (ref name, ref desc, _) => {\n                 printfln!(\"    -Z %-20s -- %s\", *name, *desc);\n@@ -350,7 +350,7 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n                 ];\n-                foreach note in xs.iter() {\n+                for note in xs.iter() {\n                     diagnostic::emit(None, *note, diagnostic::note)\n                 }\n             }"}, {"sha": "8f0dd51457074c23bdd2e2a7cb219e4f8cd40301", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -398,7 +398,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    /*foreach def_id in ty::type_def_id(typ).iter() {\n+    /*for def_id in ty::type_def_id(typ).iter() {\n         // note that this typedef cannot have type parameters\n         return ast_map::path_to_str(ty::item_path(cx, *def_id),\n                                     cx.sess.intr());\n@@ -484,13 +484,13 @@ pub fn parameterized(cx: ctxt,\n     match *regions {\n         ty::ErasedRegions => { }\n         ty::NonerasedRegions(ref regions) => {\n-            foreach &r in regions.iter() {\n+            for &r in regions.iter() {\n                 strs.push(region_to_str(cx, \"\", false, r))\n             }\n         }\n     }\n \n-    foreach t in tps.iter() {\n+    for t in tps.iter() {\n         strs.push(ty_to_str(cx, *t))\n     }\n \n@@ -598,7 +598,7 @@ impl Repr for ty::ParamBounds {\n             });\n             true\n         };\n-        foreach t in self.trait_bounds.iter() {\n+        for t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n         res.connect(\"+\")\n@@ -848,7 +848,7 @@ impl UserString for ty::TraitRef {\n         let base = ast_map::path_to_str(path, tcx.sess.intr());\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n-            foreach &t in self.substs.self_ty.iter() { all_tps.push(t); }\n+            for &t in self.substs.self_ty.iter() { all_tps.push(t); }\n             parameterized(tcx, base, &self.substs.regions, all_tps)\n         } else {\n             parameterized(tcx, base, &self.substs.regions, self.substs.tps)"}, {"sha": "f287e17880bb333419cb4b69dd2c2f69e77e2fd9", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -73,7 +73,7 @@ pub fn usage() {\n     println(\"Usage: rustdoc [options] <cratefile>\\n\");\n     println(\"Options:\\n\");\n     let r = opts();\n-    foreach opt in r.iter() {\n+    for opt in r.iter() {\n         printfln!(\"    %s\", opt.second());\n     }\n     println(\"\");"}, {"sha": "f849cfade9bdafe89ac7553793abb528c14b9027", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -142,7 +142,7 @@ fn nmoddoc_from_mod(\n     module_: ast::foreign_mod\n ) -> doc::NmodDoc {\n     let mut fns = ~[];\n-    foreach item in module_.items.iter() {\n+    for item in module_.items.iter() {\n         let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n         match item.node {\n           ast::foreign_item_fn(*) => {"}, {"sha": "0dbd29df48b631814a328d0e71164f6e10f26a86", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -189,7 +189,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n             };\n             let self_ty = doc.self_ty.get_ref();\n             let mut trait_part = ~\"\";\n-            foreach (i, trait_type) in doc.trait_types.iter().enumerate() {\n+            for (i, trait_type) in doc.trait_types.iter().enumerate() {\n                 if i == 0 {\n                     trait_part.push_str(\" of \");\n                 } else {\n@@ -279,7 +279,7 @@ fn write_desc(\n }\n \n fn write_sections(ctxt: &Ctxt, sections: &[doc::Section]) {\n-    foreach section in sections.iter() {\n+    for section in sections.iter() {\n         write_section(ctxt, (*section).clone());\n     }\n }\n@@ -299,7 +299,7 @@ fn write_mod_contents(\n         write_index(ctxt, doc.index.get_ref());\n     }\n \n-    foreach itemTag in doc.items.iter() {\n+    for itemTag in doc.items.iter() {\n         write_item(ctxt, (*itemTag).clone());\n     }\n }\n@@ -349,7 +349,7 @@ fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n     ctxt.w.put_line(~\"<div class='index'>\");\n     ctxt.w.put_line(~\"\");\n \n-    foreach entry in index.entries.iter() {\n+    for entry in index.entries.iter() {\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link.clone();\n         if entry.brief.is_some() {\n@@ -370,7 +370,7 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n         write_index(ctxt, doc.index.get_ref());\n     }\n \n-    foreach FnDoc in doc.fns.iter() {\n+    for FnDoc in doc.fns.iter() {\n         write_item_header(ctxt, doc::FnTag((*FnDoc).clone()));\n         write_fn(ctxt, (*FnDoc).clone());\n     }\n@@ -435,7 +435,7 @@ fn write_variants(\n \n     write_header_(ctxt, H4, ~\"Variants\");\n \n-    foreach variant in docs.iter() {\n+    for variant in docs.iter() {\n         write_variant(ctxt, (*variant).clone());\n     }\n \n@@ -474,7 +474,7 @@ fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n }\n \n fn write_methods(ctxt: &Ctxt, docs: &[doc::MethodDoc]) {\n-    foreach doc in docs.iter() {\n+    for doc in docs.iter() {\n         write_method(ctxt, (*doc).clone());\n     }\n }"}, {"sha": "4cd442bb95147db53f6951fa2e74f8fe45ae9b39", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -106,7 +106,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     let mut current_section: Option<doc::Section> = None;\n     let mut sections = ~[];\n \n-    foreach line in desc.get_ref().any_line_iter() {\n+    for line in desc.get_ref().any_line_iter() {\n         match parse_header(line) {\n           Some(header) => {\n             if current_section.is_some() {"}, {"sha": "d8a640bc19cf9f5bb82fea42cf4b019d0e52f199", "filename": "src/librusti/program.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -98,7 +98,7 @@ impl Program {\n \n         code.push_str(\"fn main() {\\n\");\n         // It's easy to initialize things if we don't run things...\n-        foreach (name, var) in self.local_vars.iter() {\n+        for (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n             code.push_str(fmt!(\"let%s %s: %s = fail!();\\n\", mt, *name, var.ty));\n             var.alter(*name, &mut code);\n@@ -114,7 +114,7 @@ impl Program {\n             None => {}\n         }\n \n-        foreach p in new_locals.iter() {\n+        for p in new_locals.iter() {\n             code.push_str(fmt!(\"assert_encodable(&%s);\\n\", *p.first_ref()));\n         }\n         code.push_str(\"};}\");\n@@ -146,7 +146,7 @@ impl Program {\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n-        foreach (name, var) in self.local_vars.iter() {\n+        for (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n             code.push_str(fmt!(\"let%s %s: %s = {\n                 let data = __tls_map.get_copy(&~\\\"%s\\\");\n@@ -167,13 +167,13 @@ impl Program {\n         }\n \n         let newvars = util::replace(&mut self.newvars, HashMap::new());\n-        foreach (name, var) in newvars.consume() {\n+        for (name, var) in newvars.consume() {\n             self.local_vars.insert(name, var);\n         }\n \n         // After the input code is run, we can re-serialize everything back out\n         // into tls map (to be read later on by this task)\n-        foreach (name, var) in self.local_vars.iter() {\n+        for (name, var) in self.local_vars.iter() {\n             code.push_str(fmt!(\"{\n                 let local: %s = %s;\n                 let bytes = do ::std::io::with_bytes_writer |io| {\n@@ -202,13 +202,13 @@ impl Program {\n             use extra::serialize::*;\n             %s // view items\n         \", self.externs, self.view_items);\n-        foreach (_, s) in self.structs.iter() {\n+        for (_, s) in self.structs.iter() {\n             // The structs aren't really useful unless they're encodable\n             code.push_str(\"#[deriving(Encodable, Decodable)]\");\n             code.push_str(*s);\n             code.push_str(\"\\n\");\n         }\n-        foreach (_, s) in self.items.iter() {\n+        for (_, s) in self.items.iter() {\n             code.push_str(*s);\n             code.push_str(\"\\n\");\n         }\n@@ -221,7 +221,7 @@ impl Program {\n     /// program starts\n     pub fn set_cache(&self) {\n         let map = @mut HashMap::new();\n-        foreach (name, value) in self.local_vars.iter() {\n+        for (name, value) in self.local_vars.iter() {\n             map.insert((*name).clone(), @(value.data).clone());\n         }\n         local_data::set(tls_key, map);\n@@ -233,7 +233,7 @@ impl Program {\n     pub fn consume_cache(&mut self) {\n         let map = local_data::pop(tls_key).expect(\"tls is empty\");\n         let cons_map = util::replace(map, HashMap::new());\n-        foreach (name, value) in cons_map.consume() {\n+        for (name, value) in cons_map.consume() {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = (*value).clone(); }\n                 None => { fail!(\"unknown variable %s\", name) }\n@@ -345,14 +345,14 @@ impl Program {\n \n         // I'm not an @ pointer, so this has to be done outside.\n         let cons_newvars = util::replace(newvars, HashMap::new());\n-        foreach (k, v) in cons_newvars.consume() {\n+        for (k, v) in cons_newvars.consume() {\n             self.newvars.insert(k, v);\n         }\n \n         // helper functions to perform ast iteration\n         fn each_user_local(blk: &ast::Block, f: &fn(@ast::Local)) {\n             do find_user_block(blk) |blk| {\n-                foreach stmt in blk.stmts.iter() {\n+                for stmt in blk.stmts.iter() {\n                     match stmt.node {\n                         ast::stmt_decl(d, _) => {\n                             match d.node {\n@@ -367,7 +367,7 @@ impl Program {\n         }\n \n         fn find_user_block(blk: &ast::Block, f: &fn(&ast::Block)) {\n-            foreach stmt in blk.stmts.iter() {\n+            for stmt in blk.stmts.iter() {\n                 match stmt.node {\n                     ast::stmt_semi(e, _) => {\n                         match e.node {"}, {"sha": "568a691290c88d34fbff024759c3b872af705abc", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -149,7 +149,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     do find_main(crate, sess) |blk| {\n         // Fish out all the view items, be sure to record 'extern mod' items\n         // differently beause they must appear before all 'use' statements\n-        foreach vi in blk.view_items.iter() {\n+        for vi in blk.view_items.iter() {\n             let s = do with_pp(intr) |pp, _| {\n                 pprust::print_view_item(pp, vi);\n             };\n@@ -163,7 +163,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n         // Iterate through all of the block's statements, inserting them into\n         // the correct portions of the program\n-        foreach stmt in blk.stmts.iter() {\n+        for stmt in blk.stmts.iter() {\n             let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n             match stmt.node {\n                 ast::stmt_decl(d, _) => {\n@@ -276,7 +276,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n     fn find_main(crate: @ast::Crate, sess: session::Session,\n                  f: &fn(&ast::Block)) {\n-        foreach item in crate.module.items.iter() {\n+        for item in crate.module.items.iter() {\n             match item.node {\n                 ast::item_fn(_, _, _, _, ref blk) => {\n                     if item.ident == sess.ident_of(\"main\") {\n@@ -396,7 +396,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n         }\n         ~\"load\" => {\n             let mut loaded_crates: ~[~str] = ~[];\n-            foreach arg in args.iter() {\n+            for arg in args.iter() {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n                     (arg.slice_to(arg.len() - 3).to_owned(), (*arg).clone())\n@@ -408,7 +408,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                     None => { }\n                 }\n             }\n-            foreach crate in loaded_crates.iter() {\n+            for crate in loaded_crates.iter() {\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n                 repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n@@ -571,7 +571,7 @@ mod tests {\n     #[cfg(thiswillneverbeacfgflag)]\n     fn run_program(prog: &str) {\n         let mut r = repl();\n-        foreach cmd in prog.split_iter('\\n') {\n+        for cmd in prog.split_iter('\\n') {\n             assert!(run_line(&mut r, io::stdin(), io::stdout(),\n                              cmd.to_owned(), false),\n                     \"the command '%s' failed\", cmd);"}, {"sha": "cec64f36947e024d58bcb641348e40ccdec00907", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -15,16 +15,16 @@ use std::os;\n \n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n-    foreach p in workspaces.iter() {\n+    for p in workspaces.iter() {\n         let binfiles = os::list_dir(&p.push(\"bin\"));\n-        foreach exec in binfiles.iter() {\n+        for exec in binfiles.iter() {\n             let exec_path = Path(*exec).filestem();\n             do exec_path.iter().advance |s| {\n                 f(&PkgId::new(*s, p))\n             };\n         }\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n-        foreach lib in libfiles.iter() {\n+        for lib in libfiles.iter() {\n             debug!(\"Full name: %s\", *lib);\n             let lib_path = Path(*lib).filestem();\n             do lib_path.iter().advance |s| {"}, {"sha": "bbe35ee5004f6235aa5b90e9652376e2b4be1eb3", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -135,7 +135,7 @@ impl PkgSrc {\n             return true;\n         }\n         else {\n-            foreach pth in self_id.iter() {\n+            for pth in self_id.iter() {\n                 if pth.starts_with(\"rust_\") // because p is already normalized\n                     && match p.filestem() {\n                            Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n@@ -149,7 +149,7 @@ impl PkgSrc {\n     fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n         assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n-        foreach c in p.components.slice(prefix, p.components.len()).iter() {\n+        for c in p.components.slice(prefix, p.components.len()).iter() {\n             sub = sub.push(*c);\n         }\n         debug!(\"found crate %s\", sub.to_str());\n@@ -207,7 +207,7 @@ impl PkgSrc {\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n-        foreach crate in crates.iter() {\n+        for crate in crates.iter() {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));"}, {"sha": "fdfa29b2f832b5077373358f31d9899e57d63aab", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -61,7 +61,7 @@ pub fn rust_path() -> ~[Path] {\n     // Avoid adding duplicates\n     // could still add dups if someone puts one of these in the RUST_PATH\n     // manually, though...\n-    foreach hdir in h.iter() {\n+    for hdir in h.iter() {\n         if !(cwd.is_ancestor_of(hdir) || hdir.is_ancestor_of(&cwd)) {\n             push_if_exists(&mut env_rust_path, hdir);\n         }\n@@ -100,7 +100,7 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n     let dirs = os::list_dir(&src_dir);\n-    foreach p in dirs.iter() {\n+    for p in dirs.iter() {\n         let p = Path((*p).clone());\n         debug!(\"=> p = %s\", p.to_str());\n         if !os::path_is_dir(&src_dir.push_rel(&p)) {\n@@ -113,7 +113,7 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n         }\n         else {\n             let pf = p.filename();\n-            foreach pf in pf.iter() {\n+            for pf in pf.iter() {\n                 let f_ = (*pf).clone();\n                 let g = f_.to_str();\n                 match split_version_general(g, '-') {\n@@ -150,7 +150,7 @@ pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n /// Returns a src for pkgid that does exist -- None if none of them do\n pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let rs = pkgid_src_in_workspace(pkgid, workspace);\n-    foreach p in rs.iter() {\n+    for p in rs.iter() {\n         if os::path_exists(p) {\n             return Some((*p).clone());\n         }\n@@ -246,7 +246,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n \n     let mut result_filename = None;\n-    foreach p in dir_contents.iter() {\n+    for p in dir_contents.iter() {\n         let mut which = 0;\n         let mut hash = None;\n         let p_path = Path((*p).clone());\n@@ -261,7 +261,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n         let f_name = match p_path.filename() {\n             Some(s) => s, None => loop\n         };\n-        foreach piece in f_name.split_iter('-') {\n+        for piece in f_name.split_iter('-') {\n             debug!(\"a piece = %s\", piece);\n             if which == 0 && piece != lib_prefix {\n                 break;"}, {"sha": "4d6033de54de4bb2c3be9f9ad3dc70e409a650a2", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -434,14 +434,14 @@ impl CtxMethods for Ctx {\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n-        foreach exec in maybe_executable.iter() {\n+        for exec in maybe_executable.iter() {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !(os::mkdir_recursive(&target_exec.dir_path(), U_RWX) &&\n                  os::copy_file(exec, &target_exec)) {\n                 cond.raise(((*exec).clone(), target_exec.clone()));\n             }\n         }\n-        foreach lib in maybe_library.iter() {\n+        for lib in maybe_library.iter() {\n             let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());"}, {"sha": "828be5dce12788c0495e010b1d784f15f5127ed0", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -356,7 +356,7 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let mut result = ~[];\n     let p_output = command_line_test(args, &os::getcwd());\n     let test_output = str::from_bytes(p_output.output);\n-    foreach s in test_output.split_iter('\\n') {\n+    for s in test_output.split_iter('\\n') {\n         result.push(s.to_owned());\n     }\n     result\n@@ -366,7 +366,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     let mut result = ~[];\n     let p_output = command_line_test_with_env(args, &os::getcwd(), Some(env));\n     let test_output = str::from_bytes(p_output.output);\n-    foreach s in test_output.split_iter('\\n') {\n+    for s in test_output.split_iter('\\n') {\n         result.push(s.to_owned());\n     }\n     result\n@@ -391,7 +391,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n     let contents = os::list_dir_path(&pkg_src_dir);\n-    foreach p in contents.iter() {\n+    for p in contents.iter() {\n         if p.filetype() == Some(~\".rs\") {\n             // should be able to do this w/o a process\n             if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n@@ -408,7 +408,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n     let contents = os::list_dir_path(&pkg_src_dir);\n     let mut maybe_p = None;\n-    foreach p in contents.iter() {\n+    for p in contents.iter() {\n         if p.filetype() == Some(~\".rs\") {\n             maybe_p = Some(p);\n             break;\n@@ -811,7 +811,7 @@ fn rust_path_contents() {\n         assert!(p.contains(&cwd));\n         assert!(p.contains(&parent));\n         assert!(p.contains(&grandparent));\n-        foreach a_path in p.iter() {\n+        for a_path in p.iter() {\n             assert!(!a_path.components.is_empty());\n         }\n     });"}, {"sha": "361981289d3cef4c84be40d7304b17977d8e9d0b", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -104,12 +104,12 @@ fn fold_item(ctx: @mut ReadyCtx,\n     let mut cmds = ~[];\n     let mut had_pkg_do = false;\n \n-    foreach attr in item.attrs.iter() {\n+    for attr in item.attrs.iter() {\n         if \"pkg_do\" == attr.name() {\n             had_pkg_do = true;\n             match attr.node.value.node {\n                 ast::MetaList(_, ref mis) => {\n-                    foreach mi in mis.iter() {\n+                    for mi in mis.iter() {\n                         match mi.node {\n                             ast::MetaWord(cmd) => cmds.push(cmd.to_owned()),\n                             _ => {}\n@@ -210,7 +210,7 @@ pub fn compile_input(ctxt: &Ctx,\n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n-    foreach p in addl_lib_search_paths.iter() {\n+    for p in addl_lib_search_paths.iter() {\n         assert!(os::path_is_dir(p));\n     }\n \n@@ -274,7 +274,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n \n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     debug!(\"additional libraries:\");\n-    foreach lib in sess.opts.addl_lib_search_paths.iter() {\n+    for lib in sess.opts.addl_lib_search_paths.iter() {\n         debug!(\"an additional library: %s\", lib.to_str());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, crate);\n@@ -303,7 +303,7 @@ pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n                      what: OutputType) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n-    foreach fl in flags.iter() {\n+    for fl in flags.iter() {\n         debug!(\"+++ %s\", *fl);\n     }\n     compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)"}, {"sha": "8839185089116ee78f30fc44d5c1a5b3ac1a0d19", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -108,7 +108,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n \n     let mut output = None;\n     let output_text = str::from_bytes(outp.output);\n-    foreach l in output_text.line_iter() {\n+    for l in output_text.line_iter() {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n@@ -142,7 +142,7 @@ pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_bytes(outp.output);\n             debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n-            foreach l in output_text.line_iter() {\n+            for l in output_text.line_iter() {\n                 debug!(\"A line of output: %s\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n@@ -172,7 +172,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: %s\", s);\n     let mut parse_state = Start;\n-    foreach c in s.iter() {\n+    for c in s.iter() {\n         if char::is_digit(c) {\n             parse_state = SawDigit;\n         }\n@@ -204,7 +204,7 @@ pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n \n pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {\n     // reject strings with multiple '#'s\n-    foreach st in s.split_iter(sep) {\n+    for st in s.split_iter(sep) {\n         debug!(\"whole = %s part = %s\", s, st);\n     }\n     if s.split_iter(sep).len_() > 2 {"}, {"sha": "d877b4ff489cf9d7075fa0aa1d7fb10896770cc9", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -26,7 +26,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n                    pkgid.remote_path.to_str(),\n                    rust_path().to_str());\n     }\n-    foreach ws in workspaces.iter() {\n+    for ws in workspaces.iter() {\n         if action(ws) {\n             break;\n         }"}, {"sha": "4ece53d0e7f529423827d4d13ec653696c32a82f", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -91,10 +91,10 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n #[inline]\n pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        foreach x in lhs.iter() {\n+        for x in lhs.iter() {\n             push((*x).clone());\n         }\n-        foreach i in range(0u, rhs.len()) {\n+        for i in range(0u, rhs.len()) {\n             push(rhs[i].clone());\n         }\n     }\n@@ -104,7 +104,7 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n-        foreach elem in v.iter() {\n+        for elem in v.iter() {\n             push(f(elem));\n         }\n     }\n@@ -147,7 +147,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n     let mut av = @[];\n     unsafe {\n         raw::reserve(&mut av, v.len());\n-        foreach x in v.consume_iter() {\n+        for x in v.consume_iter() {\n             raw::push(&mut av, x);\n         }\n         av\n@@ -329,7 +329,7 @@ mod test {\n         // Some code that could use that, then:\n         fn seq_range(lo: uint, hi: uint) -> @[uint] {\n             do build |push| {\n-                foreach i in range(lo, hi) {\n+                for i in range(lo, hi) {\n                     push(i);\n                 }\n             }"}, {"sha": "43a632562b2b71b5db5697bf28a051c62df185e5", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -238,7 +238,7 @@ mod test {\n         }\n \n         let xs = [Less, Equal, Greater];\n-        foreach &o in xs.iter() {\n+        for &o in xs.iter() {\n             t(Less, o, Less);\n             t(Equal, o, o);\n             t(Greater, o, Greater);"}, {"sha": "6bdc45d72042a7d9a589530b25458e679eee531d", "filename": "src/libstd/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -47,7 +47,7 @@ pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n /// Extracts from a vector of either all the left values\n pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     do vec::build_sized(eithers.len()) |push| {\n-        foreach elt in eithers.iter() {\n+        for elt in eithers.iter() {\n             match *elt {\n                 Left(ref l) => { push((*l).clone()); }\n                 _ => { /* fallthrough */ }\n@@ -59,7 +59,7 @@ pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n /// Extracts from a vector of either all the right values\n pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n     do vec::build_sized(eithers.len()) |push| {\n-        foreach elt in eithers.iter() {\n+        for elt in eithers.iter() {\n             match *elt {\n                 Right(ref r) => { push((*r).clone()); }\n                 _ => { /* fallthrough */ }\n@@ -75,7 +75,7 @@ pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n-    foreach elt in eithers.consume_iter() {\n+    for elt in eithers.consume_iter() {\n         match elt {\n             Left(l) => lefts.push(l),\n             Right(r) => rights.push(r)"}, {"sha": "c9d031ed1b1b05be141fa00d1694e21cf48c8b4f", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -385,7 +385,7 @@ impl Streaming for SipState {\n     fn result_str(&mut self) -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n-        foreach b in r.iter() {\n+        for b in r.iter() {\n             s.push_str(uint::to_str_radix(*b as uint, 16u));\n         }\n         s\n@@ -487,7 +487,7 @@ mod tests {\n \n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n-            foreach b in r.iter() {\n+            for b in r.iter() {\n                 s.push_str(uint::to_str_radix(*b as uint, 16u));\n             }\n             s"}, {"sha": "c24661bf9384fd3ad95156d2eb196544442046be", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -159,7 +159,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n         self.size = 0;\n         // consume_rev_iter is more efficient\n-        foreach bucket in old_buckets.consume_rev_iter() {\n+        for bucket in old_buckets.consume_rev_iter() {\n             self.insert_opt_bucket(bucket);\n         }\n     }\n@@ -264,7 +264,7 @@ impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n-        foreach idx in range(0u, self.buckets.len()) {\n+        for idx in range(0u, self.buckets.len()) {\n             self.buckets[idx] = None;\n         }\n         self.size = 0;\n@@ -513,7 +513,7 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n     fn clone(&self) -> HashMap<K,V> {\n         let mut new_map = HashMap::with_capacity(self.len());\n-        foreach (key, value) in self.iter() {\n+        for (key, value) in self.iter() {\n             new_map.insert((*key).clone(), (*value).clone());\n         }\n         new_map\n@@ -550,7 +550,7 @@ pub struct HashSetConsumeIterator<K> {\n impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self K, &'self V)> {\n-        foreach elt in self.iter {\n+        for elt in self.iter {\n             match elt {\n                 &Some(ref bucket) => return Some((&bucket.key, &bucket.value)),\n                 &None => {},\n@@ -563,7 +563,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V\n impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'self, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self K, &'self mut V)> {\n-        foreach elt in self.iter {\n+        for elt in self.iter {\n             match elt {\n                 &Some(ref mut bucket) => return Some((&bucket.key, &mut bucket.value)),\n                 &None => {},\n@@ -576,7 +576,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'sel\n impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n-        foreach elt in self.iter {\n+        for elt in self.iter {\n             match elt {\n                 Some(Bucket {key, value, _}) => return Some((key, value)),\n                 None => {},\n@@ -589,7 +589,7 @@ impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self K> {\n-        foreach elt in self.iter {\n+        for elt in self.iter {\n             match elt {\n                 &Some(ref bucket) => return Some(&bucket.key),\n                 &None => {},\n@@ -602,7 +602,7 @@ impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n impl<K> Iterator<K> for HashSetConsumeIterator<K> {\n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        foreach elt in self.iter {\n+        for elt in self.iter {\n             match elt {\n                 Some(bucket) => return Some(bucket.key),\n                 None => {},\n@@ -623,7 +623,7 @@ impl<K: Eq + Hash, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for HashMap<K\n \n impl<K: Eq + Hash, V, T: Iterator<(K, V)>> Extendable<(K, V), T> for HashMap<K, V> {\n     fn extend(&mut self, iter: &mut T) {\n-        foreach (k, v) in *iter {\n+        for (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n@@ -758,7 +758,7 @@ impl<K: Eq + Hash, T: Iterator<K>> FromIterator<K, T> for HashSet<K> {\n \n impl<K: Eq + Hash, T: Iterator<K>> Extendable<K, T> for HashSet<K> {\n     fn extend(&mut self, iter: &mut T) {\n-        foreach k in *iter {\n+        for k in *iter {\n             self.insert(k);\n         }\n     }\n@@ -926,11 +926,11 @@ mod test_map {\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n-        foreach i in range(0u, 32) {\n+        for i in range(0u, 32) {\n             assert!(m.insert(i, i*2));\n         }\n         let mut observed = 0;\n-        foreach (k, v) in m.iter() {\n+        for (k, v) in m.iter() {\n             assert_eq!(*v, *k * 2);\n             observed |= (1 << *k);\n         }\n@@ -1007,7 +1007,7 @@ mod test_map {\n \n         let map: HashMap<int, int> = xs.iter().transform(|&x| x).collect();\n \n-        foreach &(k, v) in xs.iter() {\n+        for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n@@ -1074,11 +1074,11 @@ mod test_set {\n     #[test]\n     fn test_iterate() {\n         let mut a = HashSet::new();\n-        foreach i in range(0u, 32) {\n+        for i in range(0u, 32) {\n             assert!(a.insert(i));\n         }\n         let mut observed = 0;\n-        foreach k in a.iter() {\n+        for k in a.iter() {\n             observed |= (1 << *k);\n         }\n         assert_eq!(observed, 0xFFFF_FFFF);\n@@ -1107,7 +1107,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        foreach x in a.intersection_iter(&b) {\n+        for x in a.intersection_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1130,7 +1130,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [1, 5, 11];\n-        foreach x in a.difference_iter(&b) {\n+        for x in a.difference_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1156,7 +1156,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [-2, 1, 5, 11, 14, 22];\n-        foreach x in a.symmetric_difference_iter(&b) {\n+        for x in a.symmetric_difference_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1186,7 +1186,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        foreach x in a.union_iter(&b) {\n+        for x in a.union_iter(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1199,7 +1199,7 @@ mod test_set {\n \n         let set: HashSet<int> = xs.iter().transform(|&x| x).collect();\n \n-        foreach x in xs.iter() {\n+        for x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "f750f3f3195e7157901ea67316de27da945b8352", "filename": "src/libstd/io.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -1281,7 +1281,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-    foreach f in flags.iter() {\n+    for f in flags.iter() {\n         match *f {\n           Append => fflags |= O_APPEND as c_int,\n           Create => fflags |= O_CREAT as c_int,\n@@ -1940,7 +1940,7 @@ mod tests {\n                 if len <= ivals.len() {\n                     assert_eq!(res.len(), len);\n                 }\n-                foreach (iv, c) in ivals.iter().zip(res.iter()) {\n+                for (iv, c) in ivals.iter().zip(res.iter()) {\n                     assert!(*iv == *c as int)\n                 }\n             }\n@@ -2054,15 +2054,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).unwrap();\n-            foreach i in uints.iter() {\n+            for i in uints.iter() {\n                 file.write_le_u64(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).unwrap();\n-            foreach i in uints.iter() {\n+            for i in uints.iter() {\n                 assert_eq!(file.read_le_u64(), *i);\n             }\n         }\n@@ -2076,15 +2076,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).unwrap();\n-            foreach i in uints.iter() {\n+            for i in uints.iter() {\n                 file.write_be_u64(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).unwrap();\n-            foreach i in uints.iter() {\n+            for i in uints.iter() {\n                 assert_eq!(file.read_be_u64(), *i);\n             }\n         }\n@@ -2098,15 +2098,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).unwrap();\n-            foreach i in ints.iter() {\n+            for i in ints.iter() {\n                 file.write_be_i32(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).unwrap();\n-            foreach i in ints.iter() {\n+            for i in ints.iter() {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n                 assert_eq!(file.read_be_int_n(4), *i as i64);"}, {"sha": "0769aa6a7646478303936748307dc2ab682038fe", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -295,7 +295,7 @@ pub trait IteratorUtil<A> {\n     /// let mut it = xs.iter().flat_map_(|&x| Counter::new(0u, 1).take_(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// let mut i = 0;\n-    /// foreach x: uint in it {\n+    /// for x: uint in it {\n     ///     assert_eq!(x, ys[i]);\n     ///     i += 1;\n     /// }\n@@ -330,7 +330,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// use std::iterator::Counter;\n     ///\n-    /// foreach i in Counter::new(0, 10) {\n+    /// for i in Counter::new(0, 10) {\n     ///     printfln!(\"%d\", i);\n     /// }\n     /// ~~~\n@@ -577,7 +577,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn last_(&mut self) -> Option<A> {\n         let mut last = None;\n-        foreach x in *self { last = Some(x); }\n+        for x in *self { last = Some(x); }\n         last\n     }\n \n@@ -600,20 +600,20 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     #[inline]\n     fn all(&mut self, f: &fn(A) -> bool) -> bool {\n-        foreach x in *self { if !f(x) { return false; } }\n+        for x in *self { if !f(x) { return false; } }\n         true\n     }\n \n     #[inline]\n     fn any(&mut self, f: &fn(A) -> bool) -> bool {\n-        foreach x in *self { if f(x) { return true; } }\n+        for x in *self { if f(x) { return true; } }\n         false\n     }\n \n     /// Return the first element satisfying the specified predicate\n     #[inline]\n     fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n-        foreach x in *self {\n+        for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n         None\n@@ -623,7 +623,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n         let mut i = 0;\n-        foreach x in *self {\n+        for x in *self {\n             if predicate(x) {\n                 return Some(i);\n             }\n@@ -635,7 +635,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n         let mut i = 0;\n-        foreach x in *self {\n+        for x in *self {\n             if predicate(x) { i += 1 }\n         }\n         i\n@@ -1024,7 +1024,7 @@ pub struct Filter<'self, A, T> {\n impl<'self, A, T: Iterator<A>> Iterator<A> for Filter<'self, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        foreach x in self.iter {\n+        for x in self.iter {\n             if (self.predicate)(&x) {\n                 return Some(x);\n             } else {\n@@ -1068,7 +1068,7 @@ pub struct FilterMap<'self, A, B, T> {\n impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'self, A, B, T> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        foreach x in self.iter {\n+        for x in self.iter {\n             match (self.f)(x) {\n                 Some(y) => return Some(y),\n                 None => ()\n@@ -1373,8 +1373,8 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n-            foreach inner in self.frontiter.mut_iter() {\n-                foreach x in *inner {\n+            for inner in self.frontiter.mut_iter() {\n+                for x in *inner {\n                     return Some(x)\n                 }\n             }\n@@ -1403,7 +1403,7 @@ impl<'self,\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n-            foreach inner in self.backiter.mut_iter() {\n+            for inner in self.backiter.mut_iter() {\n                 match inner.next_back() {\n                     None => (),\n                     y => return y\n@@ -1577,7 +1577,7 @@ mod tests {\n         let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n         let mut it = xs.iter().chain_(ys.iter());\n         let mut i = 0;\n-        foreach &x in it {\n+        for &x in it {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n@@ -1586,7 +1586,7 @@ mod tests {\n         let ys = Counter::new(30u, 10).take_(4);\n         let mut it = xs.iter().transform(|&x| x).chain_(ys);\n         let mut i = 0;\n-        foreach x in it {\n+        for x in it {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n@@ -1604,7 +1604,7 @@ mod tests {\n     fn test_iterator_enumerate() {\n         let xs = [0u, 1, 2, 3, 4, 5];\n         let mut it = xs.iter().enumerate();\n-        foreach (i, &x) in it {\n+        for (i, &x) in it {\n             assert_eq!(i, x);\n         }\n     }\n@@ -1615,7 +1615,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 5, 13];\n         let mut it = xs.iter().take_while(|&x| *x < 15u);\n         let mut i = 0;\n-        foreach &x in it {\n+        for &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1628,7 +1628,7 @@ mod tests {\n         let ys = [15, 16, 17, 19];\n         let mut it = xs.iter().skip_while(|&x| *x < 15u);\n         let mut i = 0;\n-        foreach &x in it {\n+        for &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1641,7 +1641,7 @@ mod tests {\n         let ys = [13, 15, 16, 17, 19, 20, 30];\n         let mut it = xs.iter().skip(5);\n         let mut i = 0;\n-        foreach &x in it {\n+        for &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1654,7 +1654,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 5];\n         let mut it = xs.iter().take_(5);\n         let mut i = 0;\n-        foreach &x in it {\n+        for &x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1673,7 +1673,7 @@ mod tests {\n \n         let mut it = xs.iter().scan(0, add);\n         let mut i = 0;\n-        foreach x in it {\n+        for x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1686,7 +1686,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n         let mut it = xs.iter().flat_map_(|&x| Counter::new(x, 1).take_(3));\n         let mut i = 0;\n-        foreach x in it {\n+        for x in it {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -1721,7 +1721,7 @@ mod tests {\n \n         let mut it = Unfoldr::new(0, count);\n         let mut i = 0;\n-        foreach counted in it {\n+        for counted in it {\n             assert_eq!(counted, i);\n             i += 1;\n         }\n@@ -1733,7 +1733,7 @@ mod tests {\n         let cycle_len = 3;\n         let it = Counter::new(0u, 1).take_(cycle_len).cycle();\n         assert_eq!(it.size_hint(), (uint::max_value, None));\n-        foreach (i, x) in it.take_(100).enumerate() {\n+        for (i, x) in it.take_(100).enumerate() {\n             assert_eq!(i % cycle_len, x);\n         }\n \n@@ -1745,7 +1745,7 @@ mod tests {\n     #[test]\n     fn test_iterator_nth() {\n         let v = &[0, 1, 2, 3, 4];\n-        foreach i in range(0u, v.len()) {\n+        for i in range(0u, v.len()) {\n             assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n         }\n     }\n@@ -1959,7 +1959,7 @@ mod tests {\n         let mut b = a.clone();\n         assert_eq!(len, b.indexable());\n         let mut n = 0;\n-        foreach (i, elt) in a.enumerate() {\n+        for (i, elt) in a.enumerate() {\n             assert_eq!(Some(elt), b.idx(i));\n             n += 1;\n         }\n@@ -2049,7 +2049,7 @@ mod tests {\n         // test .transform and .peek_ that don't implement Clone\n         let it = xs.iter().peek_(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n-        foreach (i, elt) in xs.iter().enumerate() {\n+        for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n         }\n \n@@ -2062,7 +2062,7 @@ mod tests {\n         // test .transform and .peek_ that don't implement Clone\n         let it = xs.iter().transform(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n-        foreach (i, elt) in xs.iter().enumerate() {\n+        for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(*elt), it.idx(i));\n         }\n     }"}, {"sha": "417251d3740e6575016d0ae9934eca1d69553ca1", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -502,7 +502,7 @@ mod tests {\n         let x = Some(());\n         let mut y = Some(5);\n         let mut y2 = 0;\n-        foreach _x in x.iter() {\n+        for _x in x.iter() {\n             y2 = y.take_unwrap();\n         }\n         assert_eq!(y2, 5);"}, {"sha": "2d0b7d4f849d7be254a0ece13fc60100ef12a548", "filename": "src/libstd/os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -219,7 +219,7 @@ pub fn env() -> ~[(~str,~str)] {\n \n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n-            foreach p in input.iter() {\n+            for p in input.iter() {\n                 let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n@@ -1119,7 +1119,7 @@ pub fn set_exit_status(code: int) {\n \n unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     let mut args = ~[];\n-    foreach i in range(0u, argc as uint) {\n+    for i in range(0u, argc as uint) {\n         args.push(str::raw::from_c_str(*argv.offset(i as int)));\n     }\n     args\n@@ -1168,7 +1168,7 @@ pub fn real_args() -> ~[~str] {\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n     let mut args = ~[];\n-    foreach i in range(0u, nArgs as uint) {\n+    for i in range(0u, nArgs as uint) {\n         unsafe {\n             // Determine the length of this argument.\n             let ptr = *szArgList.offset(i as int);\n@@ -1425,7 +1425,7 @@ impl MemoryMap {\n         let mut offset: off_t = 0;\n         let len = round_up(min_len, page_size()) as size_t;\n \n-        foreach &o in options.iter() {\n+        for &o in options.iter() {\n             match o {\n                 MapReadable => { prot |= libc::PROT_READ; },\n                 MapWritable => { prot |= libc::PROT_WRITE; },\n@@ -1498,7 +1498,7 @@ impl MemoryMap {\n         let mut offset: uint = 0;\n         let len = round_up(min_len, page_size()) as SIZE_T;\n \n-        foreach &o in options.iter() {\n+        for &o in options.iter() {\n             match o {\n                 MapReadable => { readable = true; },\n                 MapWritable => { writable = true; },\n@@ -1794,7 +1794,7 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert!(e.len() > 0u);\n-        foreach p in e.iter() {\n+        for p in e.iter() {\n             let (n, v) = (*p).clone();\n             debug!(n.clone());\n             let v2 = getenv(n);\n@@ -1838,7 +1838,7 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        foreach s in oldhome.iter() { setenv(\"HOME\", *s) }\n+        for s in oldhome.iter() { setenv(\"HOME\", *s) }\n     }\n \n     #[test]\n@@ -1886,7 +1886,7 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert!(dirs.len() > 0u);\n \n-        foreach dir in dirs.iter() {\n+        for dir in dirs.iter() {\n             debug!((*dir).clone());\n         }\n     }"}, {"sha": "76001ae41887a8b19a53218b01a9d7de351d8808", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -647,8 +647,8 @@ impl GenericPath for PosixPath {\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n         let mut v = self.components.clone();\n-        foreach e in cs.iter() {\n-            foreach s in e.as_slice().split_iter(posix::is_sep) {\n+        for e in cs.iter() {\n+            for s in e.as_slice().split_iter(posix::is_sep) {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n                 }\n@@ -662,7 +662,7 @@ impl GenericPath for PosixPath {\n \n     fn push(&self, s: &str) -> PosixPath {\n         let mut v = self.components.clone();\n-        foreach s in s.split_iter(posix::is_sep) {\n+        for s in s.split_iter(posix::is_sep) {\n             if !s.is_empty() {\n                 v.push(s.to_owned())\n             }\n@@ -922,8 +922,8 @@ impl GenericPath for WindowsPath {\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n         let mut v = self.components.clone();\n-        foreach e in cs.iter() {\n-            foreach s in e.as_slice().split_iter(windows::is_sep) {\n+        for e in cs.iter() {\n+            for s in e.as_slice().split_iter(windows::is_sep) {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n                 }\n@@ -940,7 +940,7 @@ impl GenericPath for WindowsPath {\n \n     fn push(&self, s: &str) -> WindowsPath {\n         let mut v = self.components.clone();\n-        foreach s in s.split_iter(windows::is_sep) {\n+        for s in s.split_iter(windows::is_sep) {\n             if !s.is_empty() {\n                 v.push(s.to_owned())\n             }\n@@ -989,7 +989,7 @@ impl GenericPath for WindowsPath {\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    foreach c in components.iter() {\n+    for c in components.iter() {\n         if *c == ~\".\" && components.len() > 1 { loop; }\n         if *c == ~\"\" { loop; }\n         if *c == ~\"..\" && cs.len() != 0 {"}, {"sha": "1fd534825a5449b62fa37a002d350c8694b06d74", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -598,7 +598,7 @@ pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n \n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n-    foreach (i, p) in pkts.mut_iter().enumerate() {\n+    for (i, p) in pkts.mut_iter().enumerate() {\n         unsafe {\n             let p = &mut *p.header();\n             let old = p.mark_blocked(this);\n@@ -620,7 +620,7 @@ pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n         let event = wait_event(this) as *PacketHeader;\n \n         let mut pos = None;\n-        foreach (i, p) in pkts.mut_iter().enumerate() {\n+        for (i, p) in pkts.mut_iter().enumerate() {\n             if p.header() == event {\n                 pos = Some(i);\n                 break;\n@@ -638,7 +638,7 @@ pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n \n     debug!(\"%?\", &mut pkts[ready_packet]);\n \n-    foreach p in pkts.mut_iter() {\n+    for p in pkts.mut_iter() {\n         unsafe {\n             (*p.header()).unblock()\n         }\n@@ -849,7 +849,7 @@ pub fn select<T:Send,Tb:Send>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n                                     Option<T>,\n                                     ~[RecvPacketBuffered<T, Tb>]) {\n     let mut endpoint_headers = ~[];\n-    foreach endpoint in endpoints.mut_iter() {\n+    for endpoint in endpoints.mut_iter() {\n         endpoint_headers.push(endpoint.header());\n     }\n "}, {"sha": "b7d72c11ff7a888a564376f09df1f3473c1e2ba7", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -495,7 +495,7 @@ impl<R: Rng> RngUtil for R {\n     fn gen_char_from(&mut self, chars: &str) -> char {\n         assert!(!chars.is_empty());\n         let mut cs = ~[];\n-        foreach c in chars.iter() { cs.push(c) }\n+        for c in chars.iter() { cs.push(c) }\n         self.choose(cs)\n     }\n \n@@ -559,15 +559,15 @@ impl<R: Rng> RngUtil for R {\n     fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n                                        -> Option<T> {\n         let mut total = 0u;\n-        foreach item in v.iter() {\n+        for item in v.iter() {\n             total += item.weight;\n         }\n         if total == 0u {\n             return None;\n         }\n         let chosen = self.gen_uint_range(0u, total);\n         let mut so_far = 0u;\n-        foreach item in v.iter() {\n+        for item in v.iter() {\n             so_far += item.weight;\n             if so_far > chosen {\n                 return Some(item.item.clone());\n@@ -582,8 +582,8 @@ impl<R: Rng> RngUtil for R {\n      */\n     fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n-        foreach item in v.iter() {\n-            foreach _ in range(0u, item.weight) {\n+        for item in v.iter() {\n+            for _ in range(0u, item.weight) {\n                 r.push(item.item.clone());\n             }\n         }\n@@ -765,7 +765,7 @@ impl IsaacRng {\n         );\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        foreach &(mr_offset, m2_offset) in r.iter() {\n+        for &(mr_offset, m2_offset) in r.iter() {\n             do uint::range_step(0, MIDPOINT, 4) |base| {\n                 rngstep!(0, 13);\n                 rngstep!(1, -6);"}, {"sha": "a53e3e796a790db7090bd0cc930c0223bcea53f4", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -176,7 +176,7 @@ impl ReprVisitor {\n \n     pub fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n-        foreach ch in slice.iter() {\n+        for ch in slice.iter() {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');"}, {"sha": "7a578465841bba26920f521dcd805320cd054450", "filename": "src/libstd/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -263,7 +263,7 @@ impl<T, E: Clone> Result<T, E> {\n pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n                       -> Result<~[V],U> {\n     let mut vs: ~[V] = vec::with_capacity(ts.len());\n-    foreach t in ts.iter() {\n+    for t in ts.iter() {\n         match op(t) {\n           Ok(v) => vs.push(v),\n           Err(u) => return Err(u)"}, {"sha": "6f26e3bd9efe8d76c934b06e32a8db27772176f3", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -112,7 +112,7 @@ mod imp {\n     // Copied from `os`.\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n         let mut args = ~[];\n-        foreach i in range(0u, argc as uint) {\n+        for i in range(0u, argc as uint) {\n             args.push(str::raw::from_c_str(*(argv as **libc::c_char).offset(i as int)));\n         }\n         args"}, {"sha": "dcfcc3a9fc67a401341ea845979201f8182cf22c", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -83,7 +83,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n         Some(borrow_list) => { // recording borrows\n             let mut msg = ~\"borrowed\";\n             let mut sep = \" at \";\n-            foreach entry in borrow_list.rev_iter() {\n+            for entry in borrow_list.rev_iter() {\n                 if entry.box == box {\n                     msg.push_str(sep);\n                     let filename = str::raw::from_c_str(entry.file);"}, {"sha": "780aa9cb75c56c13eb0523dc143c3e36b5936216", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -421,7 +421,7 @@ mod test {\n \n             do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n-                foreach i in range(0, MAX) {\n+                for i in range(0, MAX) {\n                     let stream = Cell::new(listener.accept());\n                     rtdebug!(\"accepted\");\n                     // Start another task to handle the connection\n@@ -460,7 +460,7 @@ mod test {\n \n             do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n-                foreach i in range(0, MAX) {\n+                for i in range(0, MAX) {\n                     let stream = Cell::new(listener.accept());\n                     rtdebug!(\"accepted\");\n                     // Start another task to handle the connection\n@@ -499,7 +499,7 @@ mod test {\n \n             do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n-                foreach _ in range(0, MAX) {\n+                for _ in range(0, MAX) {\n                     let stream = Cell::new(listener.accept());\n                     rtdebug!(\"accepted\");\n                     // Start another task to handle the connection\n@@ -537,7 +537,7 @@ mod test {\n \n             do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n-                foreach _ in range(0, MAX) {\n+                for _ in range(0, MAX) {\n                     let stream = Cell::new(listener.accept());\n                     rtdebug!(\"accepted\");\n                     // Start another task to handle the connection"}, {"sha": "4cfe0efacfefe88b8969fa8db7cf75fe908d65b3", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -303,7 +303,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     let on_exit: ~fn(bool) = |exit_success| {\n \n         let mut handles = handles.take();\n-        foreach handle in handles.mut_iter() {\n+        for handle in handles.mut_iter() {\n             handle.send(Shutdown);\n         }\n \n@@ -379,7 +379,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     rtdebug!(\"waiting for threads\");\n \n     // Wait for schedulers\n-    foreach thread in threads.consume_iter() {\n+    for thread in threads.consume_iter() {\n         thread.join();\n     }\n "}, {"sha": "18cfeade157db96de1221f94aeb04db7ac2ab3c3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -761,7 +761,7 @@ mod test {\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n         do run_in_newsched_task || {\n-            foreach _ in range(0u, total) {\n+            for _ in range(0u, total) {\n                 do spawntask || {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1};\n                 }\n@@ -960,7 +960,7 @@ mod test {\n     #[test]\n     fn test_stress_schedule_task_states() {\n         let n = stress_factor() * 120;\n-        foreach _ in range(0, n as int) {\n+        for _ in range(0, n as int) {\n             test_schedule_home_states();\n         }\n     }"}, {"sha": "006b777b71b1486168ae54c36a002adbefa4c61f", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -37,7 +37,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n         fail!(\"can't select on an empty list\");\n     }\n \n-    foreach (index, port) in ports.mut_iter().enumerate() {\n+    for (index, port) in ports.mut_iter().enumerate() {\n         if port.optimistic_check() {\n             return index;\n         }\n@@ -53,7 +53,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     do sched.deschedule_running_task_and_then |sched, task| {\n         let task_handles = task.make_selectable(ports.len());\n \n-        foreach (index, (port, task_handle)) in\n+        for (index, (port, task_handle)) in\n                 ports.mut_iter().zip(task_handles.consume_iter()).enumerate() {\n             // If one of the ports has data by now, it will wake the handle.\n             if port.block_on(sched, task_handle) {\n@@ -66,7 +66,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n     // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    foreach (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n+    for (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n         if port.unblock_from() {\n             ready_index = index;\n         }\n@@ -128,7 +128,7 @@ mod test {\n         let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n-        foreach (i, chan) in chans.consume_iter().enumerate() {\n+        for (i, chan) in chans.consume_iter().enumerate() {\n             if send_on_chans.contains(&i) {\n                 chan.send(());\n             } else {\n@@ -145,7 +145,7 @@ mod test {\n         let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n-        foreach (i, chan) in chans.consume_iter().enumerate() {\n+        for (i, chan) in chans.consume_iter().enumerate() {\n             if send_on_chans.contains(&i) {\n                 chan.send(());\n             } else {\n@@ -192,7 +192,7 @@ mod test {\n             let mut ports = ports;\n             let mut port = Some(port);\n             let order = [5u,0,4,3,2,6,9,8,7,1];\n-            foreach &index in order.iter() {\n+            for &index in order.iter() {\n                 // put the port in the vector at any index\n                 util::swap(port.get_mut_ref(), &mut ports[index]);\n                 assert!(select(ports) == index);\n@@ -272,7 +272,7 @@ mod test {\n                     let send_on_chans = send_on_chans.clone();\n                     do task::spawn {\n                         let mut ports = ~[];\n-                        foreach i in range(0u, NUM_CHANS) {\n+                        for i in range(0u, NUM_CHANS) {\n                             let (p,c) = oneshot();\n                             ports.push(p);\n                             if send_on_chans.contains(&i) {"}, {"sha": "2d45b1cd13938845a677a5cb799b9fbcda8c009a", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -169,7 +169,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         let mut handles = ~[];\n         let mut scheds = ~[];\n \n-        foreach _ in range(0u, nthreads) {\n+        for _ in range(0u, nthreads) {\n             let loop_ = ~UvEventLoop::new();\n             let mut sched = ~Scheduler::new(loop_,\n                                             work_queue.clone(),\n@@ -184,7 +184,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         let on_exit: ~fn(bool) = |exit_status| {\n             let mut handles = handles.take();\n             // Tell schedulers to exit\n-            foreach handle in handles.mut_iter() {\n+            for handle in handles.mut_iter() {\n                 handle.send(Shutdown);\n             }\n \n@@ -223,7 +223,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         // Wait for schedulers\n-        foreach thread in threads.consume_iter() {\n+        for thread in threads.consume_iter() {\n             thread.join();\n         }\n     }\n@@ -346,7 +346,7 @@ fn base_port() -> uint {\n \n     let mut final_base = base;\n \n-    foreach &(dir, base) in bases.iter() {\n+    for &(dir, base) in bases.iter() {\n         if path.contains(dir) {\n             final_base = base;\n             break;"}, {"sha": "247893f75de0096c2dc89806b0a444b184ad0028", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -166,7 +166,7 @@ mod test {\n                 sched.enqueue_blocked_task(task);\n             }\n \n-            foreach i in range(0, MAX) {\n+            for i in range(0, MAX) {\n                 let j = tube.recv();\n                 assert!(j == i);\n             }"}, {"sha": "5ac9f52f335b237b2660da6561d690ed2d4394a6", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -701,7 +701,7 @@ mod test {\n                     if status.is_none() {\n                         rtdebug!(\"got %d bytes\", nread);\n                         let buf = buf.unwrap();\n-                        foreach byte in buf.slice(0, nread as uint).iter() {\n+                        for byte in buf.slice(0, nread as uint).iter() {\n                             assert!(*byte == count as u8);\n                             rtdebug!(\"%u\", *byte as uint);\n                             count += 1;\n@@ -777,7 +777,7 @@ mod test {\n                         rtdebug!(\"got %d bytes\", nread);\n                         let buf = buf.unwrap();\n                         let r = buf.slice(0, nread as uint);\n-                        foreach byte in r.iter() {\n+                        for byte in r.iter() {\n                             assert!(*byte == count as u8);\n                             rtdebug!(\"%u\", *byte as uint);\n                             count += 1;\n@@ -848,7 +848,7 @@ mod test {\n                 rtdebug!(\"got %d bytes\", nread);\n \n                 let buf = buf.unwrap();\n-                foreach &byte in buf.slice(0, nread as uint).iter() {\n+                for &byte in buf.slice(0, nread as uint).iter() {\n                     assert!(byte == count as u8);\n                     rtdebug!(\"%u\", byte as uint);\n                     count += 1;\n@@ -908,7 +908,7 @@ mod test {\n                 rtdebug!(\"got %d bytes\", nread);\n \n                 let buf = buf.unwrap();\n-                foreach &byte in buf.slice(0, nread as uint).iter() {\n+                for &byte in buf.slice(0, nread as uint).iter() {\n                     assert!(byte == count as u8);\n                     rtdebug!(\"%u\", byte as uint);\n                     count += 1;"}, {"sha": "5c17aea934143e6e252c23ad42abb16e1ab4ca31", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -843,7 +843,7 @@ fn test_simple_tcp_server_and_client() {\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n-                foreach i in range(0u, nread) {\n+                for i in range(0u, nread) {\n                     rtdebug!(\"%u\", buf[i] as uint);\n                     assert_eq!(buf[i], i as u8);\n                 }\n@@ -873,7 +873,7 @@ fn test_simple_udp_server_and_client() {\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n                 assert_eq!(nread, 8);\n-                foreach i in range(0u, nread) {\n+                for i in range(0u, nread) {\n                     rtdebug!(\"%u\", buf[i] as uint);\n                     assert_eq!(buf[i], i as u8);\n                 }\n@@ -908,7 +908,7 @@ fn test_read_and_block() {\n \n             while current < expected {\n                 let nread = stream.read(buf).unwrap();\n-                foreach i in range(0u, nread) {\n+                for i in range(0u, nread) {\n                     let val = buf[i] as uint;\n                     assert_eq!(val, current % 8);\n                     current += 1;\n@@ -973,7 +973,7 @@ fn test_read_read_read() {\n                     let nread = stream.read(buf).unwrap();\n                     rtdebug!(\"read %u bytes\", nread as uint);\n                     total_bytes_read += nread;\n-                    foreach i in range(0u, nread) {\n+                    for i in range(0u, nread) {\n                         assert_eq!(buf[i], 1);\n                     }\n                 }\n@@ -1065,7 +1065,7 @@ fn test_udp_many_read() {\n                     let (nread, src) = res.unwrap();\n                     assert_eq!(src, server_out_addr);\n                     total_bytes_recv += nread;\n-                    foreach i in range(0u, nread) {\n+                    for i in range(0u, nread) {\n                         assert_eq!(buf[i], 1);\n                     }\n                 }"}, {"sha": "ef3d881c5fead58be610146747508263d37b2472", "filename": "src/libstd/run.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -174,9 +174,9 @@ impl Process {\n                                    in_fd, out_fd, err_fd);\n \n         unsafe {\n-            foreach pipe in in_pipe.iter() { libc::close(pipe.input); }\n-            foreach pipe in out_pipe.iter() { libc::close(pipe.out); }\n-            foreach pipe in err_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n+            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n         }\n \n         Process {\n@@ -321,7 +321,7 @@ impl Process {\n      * If the child has already been finished then the exit code is returned.\n      */\n     pub fn finish(&mut self) -> int {\n-        foreach &code in self.exit_code.iter() {\n+        for &code in self.exit_code.iter() {\n             return code;\n         }\n         self.close_input();\n@@ -520,7 +520,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdOutput);\n         CloseHandle(si.hStdError);\n \n-        foreach msg in create_err.iter() {\n+        for msg in create_err.iter() {\n             fail!(\"failure in CreateProcess: %s\", *msg);\n         }\n \n@@ -576,7 +576,7 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     let mut cmd = ~\"\";\n     append_arg(&mut cmd, prog);\n-    foreach arg in args.iter() {\n+    for arg in args.iter() {\n         cmd.push_char(' ');\n         append_arg(&mut cmd, *arg);\n     }\n@@ -587,7 +587,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n         if quote {\n             cmd.push_char('\"');\n         }\n-        foreach i in range(0u, arg.len()) {\n+        for i in range(0u, arg.len()) {\n             append_char_at(cmd, arg, i);\n         }\n         if quote {\n@@ -694,7 +694,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = ~[prog.as_c_str(|b| b)];\n     let mut tmps = ~[];\n-    foreach arg in args.iter() {\n+    for arg in args.iter() {\n         let t = @(*arg).clone();\n         tmps.push(t);\n         argptrs.push(t.as_c_str(|b| b));\n@@ -712,7 +712,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        foreach pair in es.iter() {\n+        for pair in es.iter() {\n             // Use of match here is just to workaround limitations\n             // in the stage0 irrefutable pattern impl.\n             match pair {\n@@ -741,7 +741,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     match env {\n       Some(es) => {\n         let mut blk = ~[];\n-        foreach pair in es.iter() {\n+        for pair in es.iter() {\n             let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n             blk.push_all(kv.to_bytes_with_null());\n         }\n@@ -1297,7 +1297,7 @@ mod tests {\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n         let r = os::env();\n-        foreach &(ref k, ref v) in r.iter() {\n+        for &(ref k, ref v) in r.iter() {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", *k, *v)));\n         }\n@@ -1311,7 +1311,7 @@ mod tests {\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n         let r = os::env();\n-        foreach &(k, v) in r.iter() {\n+        for &(k, v) in r.iter() {\n             // don't check android RANDOM variables\n             if k != ~\"RANDOM\" {\n                 assert!(output.contains(fmt!(\"%s=%s\", k, v)) ||"}, {"sha": "3db0f203d810aa060656612f503328134985fa23", "filename": "src/libstd/str.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -149,7 +149,7 @@ pub fn from_char(ch: char) -> ~str {\n pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     buf.reserve(chs.len());\n-    foreach ch in chs.iter() {\n+    for ch in chs.iter() {\n         buf.push_char(*ch)\n     }\n     buf\n@@ -178,7 +178,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         unsafe {\n             do s.as_mut_buf |buf, _| {\n                 let mut buf = buf;\n-                foreach ss in self.iter() {\n+                for ss in self.iter() {\n                     do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n@@ -211,7 +211,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n                 do sep.as_imm_buf |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = cast::transmute_mut_unsafe(buf);\n-                    foreach ss in self.iter() {\n+                    for ss in self.iter() {\n                         do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n@@ -486,7 +486,7 @@ impl<'self> Iterator<&'self str> for StrSplitIterator<'self> {\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\";\n     let mut last_end = 0;\n-    foreach (start, end) in s.matches_index_iter(from) {\n+    for (start, end) in s.matches_index_iter(from) {\n         result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n         result.push_str(to);\n         last_end = end;\n@@ -556,7 +556,7 @@ Section: Searching\n // Utility used by various searching functions\n fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n-    foreach c in needle.byte_iter() { if haystack[i] != c { return false; } i += 1u; }\n+    for c in needle.byte_iter() { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n }\n \n@@ -887,7 +887,7 @@ pub mod raw {\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n         let new_len = s.len() + bytes.len();\n         s.reserve_at_least(new_len);\n-        foreach byte in bytes.iter() { push_byte(&mut *s, *byte); }\n+        for byte in bytes.iter() { push_byte(&mut *s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n@@ -953,7 +953,7 @@ pub mod traits {\n     impl<'self> TotalOrd for &'self str {\n         #[inline]\n         fn cmp(&self, other: & &'self str) -> Ordering {\n-            foreach (s_b, o_b) in self.byte_iter().zip(other.byte_iter()) {\n+            for (s_b, o_b) in self.byte_iter().zip(other.byte_iter()) {\n                 match s_b.cmp(&o_b) {\n                     Greater => return Greater,\n                     Less => return Less,\n@@ -1467,7 +1467,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn escape_default(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n-        foreach c in self.iter() {\n+        for c in self.iter() {\n             do c.escape_default |c| {\n                 out.push_char(c);\n             }\n@@ -1479,7 +1479,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn escape_unicode(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n-        foreach c in self.iter() {\n+        for c in self.iter() {\n             do c.escape_unicode |c| {\n                 out.push_char(c);\n             }\n@@ -1581,7 +1581,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     pub fn replace(&self, from: &str, to: &str) -> ~str {\n         let mut result = ~\"\";\n         let mut last_end = 0;\n-        foreach (start, end) in self.matches_index_iter(from) {\n+        for (start, end) in self.matches_index_iter(from) {\n             result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n             result.push_str(to);\n             last_end = end;\n@@ -1619,7 +1619,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n-        foreach ch in self.iter() {\n+        for ch in self.iter() {\n             // Arithmetic with u32 literals is easier on the eyes than chars.\n             let mut ch = ch as u32;\n \n@@ -1772,12 +1772,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// or `None` if there is no match\n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            foreach (i, b) in self.byte_iter().enumerate() {\n+            for (i, b) in self.byte_iter().enumerate() {\n                 if search.matches(b as char) { return Some(i) }\n             }\n         } else {\n             let mut index = 0;\n-            foreach c in self.iter() {\n+            for c in self.iter() {\n                 if search.matches(c) { return Some(index); }\n                 index += c.len_utf8_bytes();\n             }\n@@ -1795,12 +1795,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         let mut index = self.len();\n         if search.only_ascii() {\n-            foreach b in self.byte_rev_iter() {\n+            for b in self.byte_rev_iter() {\n                 index -= 1;\n                 if search.matches(b as char) { return Some(index); }\n             }\n         } else {\n-            foreach c in self.rev_iter() {\n+            for c in self.rev_iter() {\n                 index -= c.len_utf8_bytes();\n                 if search.matches(c) { return Some(index); }\n             }\n@@ -1869,7 +1869,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Apply a function to each character.\n     fn map_chars(&self, ff: &fn(char) -> char) -> ~str {\n         let mut result = with_capacity(self.len());\n-        foreach cc in self.iter() {\n+        for cc in self.iter() {\n             result.push_char(ff(cc));\n         }\n         result\n@@ -1885,12 +1885,12 @@ impl<'self> StrSlice<'self> for &'self str {\n \n         let mut dcol = vec::from_fn(tlen + 1, |x| x);\n \n-        foreach (i, sc) in self.iter().enumerate() {\n+        for (i, sc) in self.iter().enumerate() {\n \n             let mut current = i;\n             dcol[0] = current + 1;\n \n-            foreach (j, tc) in t.iter().enumerate() {\n+            for (j, tc) in t.iter().enumerate() {\n \n                 let next = dcol[j + 1];\n \n@@ -1917,7 +1917,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~ {.rust}\n     /// let string = \"a\\nb\\nc\";\n     /// let mut lines = ~[];\n-    /// foreach line in string.line_iter() { lines.push(line) }\n+    /// for line in string.line_iter() { lines.push(line) }\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n@@ -2252,7 +2252,7 @@ impl<T: Iterator<char>> Extendable<char, T> for ~str {\n         let (lower, _) = iterator.size_hint();\n         let reserve = lower + self.len();\n         self.reserve_at_least(reserve);\n-        foreach ch in *iterator {\n+        for ch in *iterator {\n             self.push_char(ch)\n         }\n     }\n@@ -3068,7 +3068,7 @@ mod tests {\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n-        foreach line in string.line_iter() { lines.push(line) }\n+        for line in string.line_iter() { lines.push(line) }\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -3172,7 +3172,7 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]) ];\n \n-        foreach p in pairs.iter() {\n+        for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n             assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n@@ -3186,7 +3186,7 @@ mod tests {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n-        foreach ch in v.iter() {\n+        for ch in v.iter() {\n             assert!(s.char_at(pos) == *ch);\n             pos += from_char(*ch).len();\n         }\n@@ -3197,7 +3197,7 @@ mod tests {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n-        foreach ch in v.rev_iter() {\n+        for ch in v.rev_iter() {\n             assert!(s.char_at_reverse(pos) == *ch);\n             pos -= from_char(*ch).len();\n         }\n@@ -3289,7 +3289,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.iter();\n \n-        foreach c in it {\n+        for c in it {\n             assert_eq!(c, v[pos]);\n             pos += 1;\n         }\n@@ -3305,7 +3305,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.rev_iter();\n \n-        foreach c in it {\n+        for c in it {\n             assert_eq!(c, v[pos]);\n             pos += 1;\n         }\n@@ -3322,7 +3322,7 @@ mod tests {\n         ];\n         let mut pos = 0;\n \n-        foreach b in s.byte_iter() {\n+        for b in s.byte_iter() {\n             assert_eq!(b, v[pos]);\n             pos += 1;\n         }\n@@ -3338,7 +3338,7 @@ mod tests {\n         ];\n         let mut pos = v.len();\n \n-        foreach b in s.byte_rev_iter() {\n+        for b in s.byte_rev_iter() {\n             pos -= 1;\n             assert_eq!(b, v[pos]);\n         }\n@@ -3354,7 +3354,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.char_offset_iter();\n \n-        foreach c in it {\n+        for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n             pos += 1;\n         }\n@@ -3372,7 +3372,7 @@ mod tests {\n         let mut pos = 0;\n         let mut it = s.char_offset_rev_iter();\n \n-        foreach c in it {\n+        for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n             pos += 1;\n         }"}, {"sha": "dd730f2068973d67534586d69d03c4bacb99446e", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -94,7 +94,7 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n \n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        foreach b in self.iter() {\n+        for b in self.iter() {\n             if !b.is_ascii() { return false; }\n         }\n         true"}, {"sha": "95d3cbaf89b10185de74ca9fda0c27a8f6244c8d", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -167,7 +167,7 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n     let map = get_local_map(handle);\n     let key_value = key_to_key_value(key);\n \n-    foreach entry in map.mut_iter() {\n+    for entry in map.mut_iter() {\n         match *entry {\n             Some((k, _, loan)) if k == key_value => {\n                 if loan != NoLoan {"}, {"sha": "3bf2f255f57511ab2bca818ec0a4edfe7f2086ad", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -299,7 +299,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                         // safe to skip it. This will leave our TaskHandle\n                         // hanging around in the group even after it's freed,\n                         // but that's ok because, by virtue of the group being\n-                        // dead, nobody will ever kill-all (foreach) over it.)\n+                        // dead, nobody will ever kill-all (for) over it.)\n                         if nobe_is_dead { true } else { forward_blk(tg_opt) }\n                     };\n                 /*##########################################################*\n@@ -357,7 +357,7 @@ impl Drop for Taskgroup {\n             // If we are failing, the whole taskgroup needs to die.\n             do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n                 if failing {\n-                    foreach x in this.notifier.mut_iter() {\n+                    for x in this.notifier.mut_iter() {\n                         x.failed = true;\n                     }\n                     // Take everybody down with us.\n@@ -387,7 +387,7 @@ pub fn Taskgroup(tasks: TaskGroupArc,\n        ancestors: AncestorList,\n        is_main: bool,\n        mut notifier: Option<AutoNotify>) -> Taskgroup {\n-    foreach x in notifier.mut_iter() {\n+    for x in notifier.mut_iter() {\n         x.failed = false;\n     }\n \n@@ -465,13 +465,13 @@ fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n         if newstate.is_some() {\n             let TaskGroupData { members: members, descendants: descendants } =\n                 newstate.unwrap();\n-            foreach sibling in members.consume() {\n+            for sibling in members.consume() {\n                 // Skip self - killing ourself won't do much good.\n                 if &sibling != me {\n                     RuntimeGlue::kill_task(sibling);\n                 }\n             }\n-            foreach child in descendants.consume() {\n+            for child in descendants.consume() {\n                 assert!(&child != me);\n                 RuntimeGlue::kill_task(child);\n             }"}, {"sha": "4649aac08b9e0aabc940e4b87720c201147d4d86", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -56,7 +56,7 @@ impl<A:ToStr+Hash+Eq, B:ToStr> ToStr for HashMap<A, B> {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"{\";\n         let mut first = true;\n-        foreach (key, value) in self.iter() {\n+        for (key, value) in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -77,7 +77,7 @@ impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"{\";\n         let mut first = true;\n-        foreach element in self.iter() {\n+        for element in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -126,7 +126,7 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";\n         let mut first = true;\n-        foreach elt in self.iter() {\n+        for elt in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -145,7 +145,7 @@ impl<A:ToStr> ToStr for ~[A] {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";\n         let mut first = true;\n-        foreach elt in self.iter() {\n+        for elt in self.iter() {\n             if first {\n                 first = false;\n             }\n@@ -164,7 +164,7 @@ impl<A:ToStr> ToStr for @[A] {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";\n         let mut first = true;\n-        foreach elt in self.iter() {\n+        for elt in self.iter() {\n             if first {\n                 first = false;\n             }"}, {"sha": "962704172b404add8fd13342ef6ae6f3ced5e9a7", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -164,7 +164,7 @@ impl<T, Iter: Iterator<(uint, T)>> FromIterator<(uint, T), Iter> for TrieMap<T>\n \n impl<T, Iter: Iterator<(uint, T)>> Extendable<(uint, T), Iter> for TrieMap<T> {\n     fn extend(&mut self, iter: &mut Iter) {\n-        foreach (k, v) in *iter {\n+        for (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n@@ -235,7 +235,7 @@ impl<Iter: Iterator<uint>> FromIterator<uint, Iter> for TrieSet {\n \n impl<Iter: Iterator<uint>> Extendable<uint, Iter> for TrieSet {\n     fn extend(&mut self, iter: &mut Iter) {\n-        foreach elem in *iter {\n+        for elem in *iter {\n             self.insert(elem);\n         }\n     }\n@@ -261,7 +261,7 @@ impl<T> TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        foreach idx in range(0u, self.children.len()) {\n+        for idx in range(0u, self.children.len()) {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n@@ -282,7 +282,7 @@ impl<T> TrieNode<T> {\n     }\n \n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n-        foreach child in self.children.mut_iter() {\n+        for child in self.children.mut_iter() {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {\n                     return false\n@@ -378,7 +378,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n \n     let mut sum = 0;\n \n-    foreach x in trie.children.iter() {\n+    for x in trie.children.iter() {\n         match *x {\n           Nothing => (),\n           Internal(ref y) => {\n@@ -430,7 +430,7 @@ mod test_map {\n             true\n         };\n \n-        foreach x in range(0u, n) {\n+        for x in range(0u, n) {\n             assert!(trie.contains_key(&x));\n             assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n@@ -555,7 +555,7 @@ mod test_map {\n \n         let map: TrieMap<int> = xs.iter().transform(|&x| x).collect();\n \n-        foreach &(k, v) in xs.iter() {\n+        for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n@@ -596,7 +596,7 @@ mod test_set {\n \n         let set: TrieSet = xs.iter().transform(|&x| x).collect();\n \n-        foreach x in xs.iter() {\n+        for x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "7b05515f74acb29bcf1f1a3d14ec66b33ce157d6", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -615,7 +615,7 @@ pub mod rt {\n         let headsize = match head { Some(_) => 1, _ => 0 };\n         let uwidth : uint = match cv.width {\n             CountImplied => {\n-                foreach &c in head.iter() {\n+                for &c in head.iter() {\n                     buf.push_char(c);\n                 }\n                 return buf.push_str(s);\n@@ -624,15 +624,15 @@ pub mod rt {\n         };\n         let strlen = s.char_len() + headsize;\n         if uwidth <= strlen {\n-            foreach &c in head.iter() {\n+            for &c in head.iter() {\n                 buf.push_char(c);\n             }\n             return buf.push_str(s);\n         }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n-            foreach &c in head.iter() {\n+            for &c in head.iter() {\n                 buf.push_char(c);\n             }\n             buf.push_str(s);\n@@ -666,7 +666,7 @@ pub mod rt {\n         // instead.\n \n         if signed && zero_padding {\n-            foreach &head in head.iter() {\n+            for &head in head.iter() {\n                 if head == '+' || head == '-' || head == ' ' {\n                     buf.push_char(head);\n                     buf.push_str(padstr);\n@@ -676,7 +676,7 @@ pub mod rt {\n             }\n         }\n         buf.push_str(padstr);\n-        foreach &c in head.iter() {\n+        for &c in head.iter() {\n             buf.push_char(c);\n         }\n         buf.push_str(s);"}, {"sha": "225ac5c92adcf8bfa32fc12aeebe5326ab998056", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -456,13 +456,13 @@ mod tests {\n \n             let total = Exclusive::new(~0);\n \n-            foreach _ in range(0u, num_tasks) {\n+            for _ in range(0u, num_tasks) {\n                 let total = total.clone();\n                 let (port, chan) = comm::stream();\n                 futures.push(port);\n \n                 do task::spawn || {\n-                    foreach _ in range(0u, count) {\n+                    for _ in range(0u, count) {\n                         do total.with |count| {\n                             **count += 1;\n                         }\n@@ -471,7 +471,7 @@ mod tests {\n                 }\n             };\n \n-            foreach f in futures.iter() { f.recv() }\n+            for f in futures.iter() { f.recv() }\n \n             do total.with |total| {\n                 assert!(**total == num_tasks * count)"}, {"sha": "f037aa2b7e789299758d38064fc52a2e2cde4cab", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -295,7 +295,7 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  */\n pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    foreach elem in v.iter() { result.push_all_move(f(elem)); }\n+    for elem in v.iter() { result.push_all_move(f(elem)); }\n     result\n }\n \n@@ -329,7 +329,7 @@ impl<'self, T:Clone> VectorVector<T> for &'self [~[T]] {\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        foreach inner in self.iter() {\n+        for inner in self.iter() {\n             if first { first = false; } else { r.push((*sep).clone()); }\n             r.push_all((*inner).clone());\n         }\n@@ -347,7 +347,7 @@ impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        foreach &inner in self.iter() {\n+        for &inner in self.iter() {\n             if first { first = false; } else { r.push((*sep).clone()); }\n             r.push_all(inner);\n         }\n@@ -365,7 +365,7 @@ impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    foreach p in v.iter() {\n+    for p in v.iter() {\n         let (t, u) = (*p).clone();\n         ts.push(t);\n         us.push(u);\n@@ -384,7 +384,7 @@ pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    foreach p in v.consume_iter() {\n+    for p in v.consume_iter() {\n         let (t, u) = p;\n         ts.push(t);\n         us.push(u);\n@@ -473,7 +473,7 @@ pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n         indices.swap(k, l);\n         indices.mut_slice(k+1, length).reverse();\n         // fixup permutation based on indices\n-        foreach i in range(k, length) {\n+        for i in range(k, length) {\n             permutation[i] = values[indices[i]].clone();\n         }\n     }\n@@ -589,7 +589,7 @@ pub mod traits {\n \n     impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n         fn cmp(&self, other: & &'self [T]) -> Ordering {\n-            foreach (s,o) in self.iter().zip(other.iter()) {\n+            for (s,o) in self.iter().zip(other.iter()) {\n                 match s.cmp(o) {\n                     Equal => {},\n                     non_eq => { return non_eq; }\n@@ -611,7 +611,7 @@ pub mod traits {\n \n     impl<'self,T:Ord> Ord for &'self [T] {\n         fn lt(&self, other: & &'self [T]) -> bool {\n-            foreach (s,o) in self.iter().zip(other.iter()) {\n+            for (s,o) in self.iter().zip(other.iter()) {\n                 if *s < *o { return true; }\n                 if *s > *o { return false; }\n             }\n@@ -725,7 +725,7 @@ impl<'self,T:Clone> CopyableVector<T> for &'self [T] {\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let mut result = with_capacity(self.len());\n-        foreach e in self.iter() {\n+        for e in self.iter() {\n             result.push((*e).clone());\n         }\n         result\n@@ -880,7 +880,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *\n      * ~~~ {.rust}\n      * let v = &[1,2,3,4];\n-     * foreach win in v.window_iter() {\n+     * for win in v.window_iter() {\n      *     printfln!(win);\n      * }\n      * ~~~\n@@ -909,7 +909,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *\n      * ~~~ {.rust}\n      * let v = &[1,2,3,4,5];\n-     * foreach win in v.chunk_iter() {\n+     * for win in v.chunk_iter() {\n      *     printfln!(win);\n      * }\n      * ~~~\n@@ -975,7 +975,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      */\n     #[inline]\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n-        foreach (i, t) in self.rev_iter().enumerate() {\n+        for (i, t) in self.rev_iter().enumerate() {\n             if f(t) { return Some(self.len() - i - 1); }\n         }\n         None\n@@ -1075,7 +1075,7 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n \n     /// Return true if a vector contains an element with the given value\n     fn contains(&self, x: &T) -> bool {\n-        foreach elt in self.iter() { if *x == *elt { return true; } }\n+        for elt in self.iter() { if *x == *elt { return true; } }\n         false\n     }\n }\n@@ -1113,7 +1113,7 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        foreach elt in self.iter() {\n+        for elt in self.iter() {\n             if f(elt) {\n                 lefts.push((*elt).clone());\n             } else {\n@@ -1170,7 +1170,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     ///\n     /// ~~~ {.rust}\n     /// let v = ~[~\"a\", ~\"b\"];\n-    /// foreach s in v.consume_iter() {\n+    /// for s in v.consume_iter() {\n     ///   // s has type ~str, not &~str\n     ///   println(s);\n     /// }\n@@ -1461,7 +1461,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             assert!(newlen <= oldlen);\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n-                foreach i in range(newlen, oldlen) {\n+                for i in range(newlen, oldlen) {\n                     ptr::read_and_zero_ptr(ptr::mut_offset(p, i as int));\n                 }\n             }\n@@ -1477,7 +1477,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let len = self.len();\n         let mut deleted: uint = 0;\n \n-        foreach i in range(0u, len) {\n+        for i in range(0u, len) {\n             if !f(&self[i]) {\n                 deleted += 1;\n             } else if deleted > 0 {\n@@ -1499,7 +1499,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        foreach elt in self.consume_iter() {\n+        for elt in self.consume_iter() {\n             if f(&elt) {\n                 lefts.push(elt);\n             } else {\n@@ -1561,7 +1561,7 @@ impl<T:Clone> OwnedCopyableVector<T> for ~[T] {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n \n-        foreach i in range(0u, rhs.len()) {\n+        for i in range(0u, rhs.len()) {\n             self.push(unsafe { raw::get(rhs, i) })\n         }\n     }\n@@ -1832,7 +1832,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n-        foreach (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n+        for (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n             util::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -1867,7 +1867,7 @@ pub trait MutableCloneableVector<T> {\n impl<'self, T:Clone> MutableCloneableVector<T> for &'self mut [T] {\n     #[inline]\n     fn copy_from(self, src: &[T]) -> uint {\n-        foreach (a, b) in self.mut_iter().zip(src.iter()) {\n+        for (a, b) in self.mut_iter().zip(src.iter()) {\n             *a = b.clone();\n         }\n         cmp::min(self.len(), src.len())\n@@ -2276,7 +2276,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let mut xs = with_capacity(lower);\n-        foreach x in *iterator {\n+        for x in *iterator {\n             xs.push(x);\n         }\n         xs\n@@ -2288,7 +2288,7 @@ impl<A, T: Iterator<A>> Extendable<A, T> for ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let len = self.len();\n         self.reserve(len + lower);\n-        foreach x in *iterator {\n+        for x in *iterator {\n             self.push(x);\n         }\n     }\n@@ -3246,7 +3246,7 @@ mod tests {\n     fn test_mut_iterator() {\n         use iterator::*;\n         let mut xs = [1, 2, 3, 4, 5];\n-        foreach x in xs.mut_iter() {\n+        for x in xs.mut_iter() {\n             *x += 1;\n         }\n         assert_eq!(xs, [2, 3, 4, 5, 6])\n@@ -3259,7 +3259,7 @@ mod tests {\n         let xs = [1, 2, 5, 10, 11];\n         let ys = [11, 10, 5, 2, 1];\n         let mut i = 0;\n-        foreach &x in xs.rev_iter() {\n+        for &x in xs.rev_iter() {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -3270,7 +3270,7 @@ mod tests {\n     fn test_mut_rev_iterator() {\n         use iterator::*;\n         let mut xs = [1u, 2, 3, 4, 5];\n-        foreach (i,x) in xs.mut_rev_iter().enumerate() {\n+        for (i,x) in xs.mut_rev_iter().enumerate() {\n             *x += i;\n         }\n         assert_eq!(xs, [5, 5, 5, 5, 5])\n@@ -3514,12 +3514,12 @@ mod tests {\n         {\n             let (left, right) = values.mut_split(2);\n             assert_eq!(left.slice(0, left.len()), [1, 2]);\n-            foreach p in left.mut_iter() {\n+            for p in left.mut_iter() {\n                 *p += 1;\n             }\n \n             assert_eq!(right.slice(0, right.len()), [3, 4, 5]);\n-            foreach p in right.mut_iter() {\n+            for p in right.mut_iter() {\n                 *p += 2;\n             }\n         }\n@@ -3536,25 +3536,25 @@ mod tests {\n         assert_eq!(v.len(), 3);\n         let mut cnt = 0;\n \n-        foreach f in v.iter() {\n+        for f in v.iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 3);\n \n-        foreach f in v.slice(1, 3).iter() {\n+        for f in v.slice(1, 3).iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 5);\n \n-        foreach f in v.mut_iter() {\n+        for f in v.mut_iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 8);\n \n-        foreach f in v.consume_iter() {\n+        for f in v.consume_iter() {\n             assert!(f == Foo);\n             cnt += 1;\n         }\n@@ -3566,7 +3566,7 @@ mod tests {\n         let xs: [Foo, ..3] = [Foo, Foo, Foo];\n         assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()), ~\"~[{}, {}]\");\n         cnt = 0;\n-        foreach f in xs.iter() {\n+        for f in xs.iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n@@ -3588,7 +3588,7 @@ mod bench {\n \n         do bh.iter {\n             let mut sum = 0;\n-            foreach x in v.iter() {\n+            for x in v.iter() {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n@@ -3602,7 +3602,7 @@ mod bench {\n \n         do bh.iter {\n             let mut i = 0;\n-            foreach x in v.mut_iter() {\n+            for x in v.mut_iter() {\n                 *x = i;\n                 i += 1;\n             }"}, {"sha": "e6bbd45dae770b9e8e6aa4842d06647de3b105e1", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -217,9 +217,9 @@ impl AbiSet {\n         let mut abis = ~[];\n         do self.each |abi| { abis.push(abi); true };\n \n-        foreach (i, abi) in abis.iter().enumerate() {\n+        for (i, abi) in abis.iter().enumerate() {\n             let data = abi.data();\n-            foreach other_abi in abis.slice(0, i).iter() {\n+            for other_abi in abis.slice(0, i).iter() {\n                 let other_data = other_abi.data();\n                 debug!(\"abis=(%?,%?) datas=(%?,%?)\",\n                        abi, data.abi_arch,\n@@ -381,7 +381,7 @@ fn abi_to_str_rust() {\n \n #[test]\n fn indices_are_correct() {\n-    foreach (i, abi_data) in AbiDatas.iter().enumerate() {\n+    for (i, abi_data) in AbiDatas.iter().enumerate() {\n         assert!(i == abi_data.abi.index());\n     }\n \n@@ -396,7 +396,7 @@ fn indices_are_correct() {\n #[cfg(test)]\n fn check_arch(abis: &[Abi], arch: Architecture, expect: Option<Abi>) {\n     let mut set = AbiSet::empty();\n-    foreach &abi in abis.iter() {\n+    for &abi in abis.iter() {\n         set.add(abi);\n     }\n     let r = set.for_arch(arch);"}, {"sha": "5cba22a8e2375a69426df537a04133e23d1e645d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -136,7 +136,7 @@ impl Ctx {\n         // Expressions which are or might be calls:\n         {\n             let r = ex.get_callee_id();\n-            foreach callee_id in r.iter() {\n+            for callee_id in r.iter() {\n                 self.map.insert(*callee_id, node_callee_scope(ex));\n             }\n         }\n@@ -150,7 +150,7 @@ impl Ctx {\n               body: &Block,\n               sp: codemap::span,\n               id: NodeId) {\n-        foreach a in decl.inputs.iter() {\n+        for a in decl.inputs.iter() {\n             self.map.insert(a.id, node_arg);\n         }\n         visit::visit_fn(self as @Visitor<()>, fk, decl, body, sp, id, ());\n@@ -189,12 +189,12 @@ impl Visitor<()> for Ctx {\n         match i.node {\n             item_impl(_, _, _, ref ms) => {\n                 let impl_did = ast_util::local_def(i.id);\n-                foreach m in ms.iter() {\n+                for m in ms.iter() {\n                     self.map_method(impl_did, self.extend(i.ident), *m, false)\n                 }\n             }\n             item_enum(ref enum_definition, _) => {\n-                foreach v in (*enum_definition).variants.iter() {\n+                for v in (*enum_definition).variants.iter() {\n                     // FIXME #2543: bad clone\n                     self.map.insert(v.node.id,\n                                     node_variant((*v).clone(),\n@@ -203,7 +203,7 @@ impl Visitor<()> for Ctx {\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n-                foreach nitem in nm.items.iter() {\n+                for nitem in nm.items.iter() {\n                     // Compute the visibility for this native item.\n                     let visibility = match nitem.vis {\n                         public => public,\n@@ -233,10 +233,10 @@ impl Visitor<()> for Ctx {\n                                     i.ident)\n             }\n             item_trait(_, ref traits, ref methods) => {\n-                foreach p in traits.iter() {\n+                for p in traits.iter() {\n                     self.map.insert(p.ref_id, node_item(i, item_path));\n                 }\n-                foreach tm in methods.iter() {\n+                for tm in methods.iter() {\n                     let id = ast_util::trait_method_to_ty_method(tm).id;\n                     let d_id = ast_util::local_def(i.id);\n                     self.map.insert(id,"}, {"sha": "11d3740be3f519bfc41850984367323e1e6483e3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -279,7 +279,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     -> (~[TypeMethod], ~[@method]) {\n     let mut reqd = ~[];\n     let mut provd = ~[];\n-    foreach trt_method in trait_methods.iter() {\n+    for trt_method in trait_methods.iter() {\n         match *trt_method {\n           required(ref tm) => reqd.push((*tm).clone()),\n           provided(m) => provd.push(m)\n@@ -398,10 +398,10 @@ struct IdVisitor {\n \n impl IdVisitor {\n     fn visit_generics_helper(@mut self, generics: &Generics) {\n-        foreach type_parameter in generics.ty_params.iter() {\n+        for type_parameter in generics.ty_params.iter() {\n             (self.visit_callback)(type_parameter.id)\n         }\n-        foreach lifetime in generics.lifetimes.iter() {\n+        for lifetime in generics.lifetimes.iter() {\n             (self.visit_callback)(lifetime.id)\n         }\n     }\n@@ -423,15 +423,15 @@ impl Visitor<()> for IdVisitor {\n                 (self.visit_callback)(node_id)\n             }\n             view_item_use(ref view_paths) => {\n-                foreach view_path in view_paths.iter() {\n+                for view_path in view_paths.iter() {\n                     match view_path.node {\n                         view_path_simple(_, _, node_id) |\n                         view_path_glob(_, node_id) => {\n                             (self.visit_callback)(node_id)\n                         }\n                         view_path_list(_, ref paths, node_id) => {\n                             (self.visit_callback)(node_id);\n-                            foreach path in paths.iter() {\n+                            for path in paths.iter() {\n                                 (self.visit_callback)(path.node.id)\n                             }\n                         }\n@@ -459,7 +459,7 @@ impl Visitor<()> for IdVisitor {\n         (self.visit_callback)(item.id);\n         match item.node {\n             item_enum(ref enum_definition, _) => {\n-                foreach variant in enum_definition.variants.iter() {\n+                for variant in enum_definition.variants.iter() {\n                     (self.visit_callback)(variant.node.id)\n                 }\n             }\n@@ -504,7 +504,7 @@ impl Visitor<()> for IdVisitor {\n     fn visit_expr(@mut self, expression: @expr, env: ()) {\n         {\n             let optional_callee_id = expression.get_callee_id();\n-            foreach callee_id in optional_callee_id.iter() {\n+            for callee_id in optional_callee_id.iter() {\n                 (self.visit_callback)(*callee_id)\n             }\n         }\n@@ -559,7 +559,7 @@ impl Visitor<()> for IdVisitor {\n             visit::fk_anon(_) | visit::fk_fn_block => {}\n         }\n \n-        foreach argument in function_declaration.inputs.iter() {\n+        for argument in function_declaration.inputs.iter() {\n             (self.visit_callback)(argument.id)\n         }\n "}, {"sha": "d1ddebfc347af259d797786a605358876f5ac7c3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -228,7 +228,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n  */\n pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n     let mut result = ~[];\n-    foreach attr in attrs.iter().filter(|at| \"link\" == at.name()) {\n+    for attr in attrs.iter().filter(|at| \"link\" == at.name()) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(*items),\n             _ => ()\n@@ -316,7 +316,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n pub fn require_unique_names(diagnostic: @span_handler,\n                             metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n-    foreach meta in metas.iter() {\n+    for meta in metas.iter() {\n         let name = meta.name();\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)"}, {"sha": "0da424ce54cddb2b75e7b11578cbef7f570add25", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -363,7 +363,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = ~[];\n-        foreach i in range(lo.line - 1u, hi.line as uint) {\n+        for i in range(lo.line - 1u, hi.line as uint) {\n             lines.push(i);\n         };\n         return @FileLines {file: lo.file, lines: lines};\n@@ -378,7 +378,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> @FileMap {\n-        foreach fm in self.files.iter() { if filename == fm.name { return *fm; } }\n+        for fm in self.files.iter() { if filename == fm.name { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n         fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n@@ -464,7 +464,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        foreach mbc in map.multibyte_chars.iter() {\n+        for mbc in map.multibyte_chars.iter() {\n             debug!(\"codemap: %?-byte char at %?\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 total_extra_bytes += mbc.bytes;"}, {"sha": "8b5014366413527ef93381f22b4b7f02e6c98880", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -267,7 +267,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         elided = true;\n     }\n     // Print the offending lines\n-    foreach line in display_lines.iter() {\n+    for line in display_lines.iter() {\n         io::stderr().write_str(fmt!(\"%s:%u \", fm.name, *line + 1u));\n         let s = fm.get_line(*line as int) + \"\\n\";\n         io::stderr().write_str(s);\n@@ -305,7 +305,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n             s.push_char(' ');\n         }\n         let orig = fm.get_line(lines.lines[0] as int);\n-        foreach pos in range(0u, left-skip) {\n+        for pos in range(0u, left-skip) {\n             let curChar = (orig[pos] as char);\n             // Whenever a tab occurs on the previous line, we insert one on\n             // the error-point-squiggly-line as well (instead of a space).\n@@ -331,7 +331,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n }\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n-    foreach ei in sp.expn_info.iter() {\n+    for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.map_default(~\"\", |span| cm.span_to_str(*span));\n         print_diagnostic(ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callee.name));"}, {"sha": "8d2d24327365eabf0a0e89f87008c7d1fe51f544", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -21,13 +21,13 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n     let mut bytes = ~[];\n \n-    foreach expr in exprs.iter() {\n+    for expr in exprs.iter() {\n         match expr.node {\n             // expression is a literal\n             ast::expr_lit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n-                    foreach byte in s.byte_iter() {\n+                    for byte in s.byte_iter() {\n                         bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }"}, {"sha": "edb5c634d5698b78d175bab9f779d59dc20570df", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -18,7 +18,7 @@ use parse::token::{str_to_ident};\n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n-    foreach (i, e) in tts.iter().enumerate() {\n+    for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n                 ast::tt_tok(_, token::COMMA) => (),"}, {"sha": "59b7da16c2bcbb684c70ca475449a27fdff2bbdf", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -83,7 +83,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                         cx.expr_ident(span, substr.type_ident)\n                     } else {\n                         let mut fields = vec::with_capacity(n);\n-                        foreach i in range(0, n) {\n+                        for i in range(0, n) {\n                             fields.push(getarg(fmt!(\"_field%u\", i).to_managed(), i));\n                         }\n                         cx.expr_call_ident(span, substr.type_ident, fields)\n@@ -109,7 +109,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n             let mut variants = ~[];\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n-            foreach (i, f) in fields.iter().enumerate() {\n+            for (i, f) in fields.iter().enumerate() {\n                 let (name, parts) = match *f { (i, ref p) => (i, p) };\n                 variants.push(cx.expr_str(span, cx.str_of(name)));\n \n@@ -125,7 +125,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                             cx.expr_ident(span, name)\n                         } else {\n                             let mut fields = vec::with_capacity(n);\n-                            foreach i in range(0u, n) {\n+                            for i in range(0u, n) {\n                                 fields.push(getarg(i));\n                             }\n                             cx.expr_call_ident(span, name, fields)"}, {"sha": "f16fea7bb0614b96051202ed429e09f417adfd74", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -122,7 +122,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            foreach (i, f) in fields.iter().enumerate() {\n+            for (i, f) in fields.iter().enumerate() {\n                 let (name, val) = match *f {\n                     (Some(id), e, _) => (cx.str_of(id), e),\n                     (None, e, _) => (fmt!(\"_field%u\", i).to_managed(), e)\n@@ -153,7 +153,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n             let encoder = cx.expr_ident(span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = ~[];\n-            foreach (i, f) in fields.iter().enumerate() {\n+            for (i, f) in fields.iter().enumerate() {\n                 let val = match *f { (_, e, _) => e };\n                 let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);"}, {"sha": "f5eb57c94b76f104cda5a7393e12b726c6ddeb76", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -283,7 +283,7 @@ impl<'self> TraitDef<'self> {\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n-        foreach item in in_items.iter() {\n+        for item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n                 ast::item_struct(struct_def, ref generics) => {\n@@ -321,11 +321,11 @@ impl<'self> TraitDef<'self> {\n \n         let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n         // Copy the lifetimes\n-        foreach l in generics.lifetimes.iter() {\n+        for l in generics.lifetimes.iter() {\n             trait_generics.lifetimes.push(*l)\n         };\n         // Create the type parameters.\n-        foreach ty_param in generics.ty_params.iter() {\n+        for ty_param in generics.ty_params.iter() {\n             // I don't think this can be moved out of the loop, since\n             // a TyParamBound requires an ast id\n             let mut bounds = opt_vec::from(\n@@ -485,7 +485,7 @@ impl<'self> MethodDef<'self> {\n             None => respan(span, ast::sty_static),\n         };\n \n-        foreach (i, ty) in self.args.iter().enumerate() {\n+        for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n             let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n             arg_tys.push((ident, ast_ty));\n@@ -579,7 +579,7 @@ impl<'self> MethodDef<'self> {\n         let mut raw_fields = ~[]; // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = ~[];\n-        foreach i in range(0u, self_args.len()) {\n+        for i in range(0u, self_args.len()) {\n             let (pat, ident_expr) = create_struct_pattern(cx, span,\n                                                           type_ident, struct_def,\n                                                           fmt!(\"__self_%u\", i), ast::m_imm);\n@@ -614,7 +614,7 @@ impl<'self> MethodDef<'self> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n-        foreach (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n+        for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n             body = cx.expr_match(span, arg_expr,\n                                  ~[ cx.arm(span, ~[pat], body) ])\n         }\n@@ -738,10 +738,10 @@ impl<'self> MethodDef<'self> {\n \n                     let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n \n-                    foreach triple in matches_so_far.tail().iter() {\n+                    for triple in matches_so_far.tail().iter() {\n                         match triple {\n                             &(_, _, ref other_fields) => {\n-                                foreach (i, pair) in other_fields.iter().enumerate() {\n+                                for (i, pair) in other_fields.iter().enumerate() {\n                                     enum_matching_fields[i].push(pair.second());\n                                 }\n                             }\n@@ -814,7 +814,7 @@ impl<'self> MethodDef<'self> {\n                 }\n             } else {\n                 // create an arm matching on each variant\n-                foreach (index, variant) in enum_def.variants.iter().enumerate() {\n+                for (index, variant) in enum_def.variants.iter().enumerate() {\n                     let (pattern, idents) = create_enum_variant_pattern(cx, span,\n                                                                        variant,\n                                                                        current_match_str,\n@@ -877,7 +877,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n                     struct_def: &struct_def) -> Either<uint, ~[ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n-    foreach field in struct_def.fields.iter() {\n+    for field in struct_def.fields.iter() {\n         match field.node.kind {\n             ast::named_field(ident, _) => named_idents.push(ident),\n             ast::unnamed_field => unnamed_count += 1,\n@@ -931,7 +931,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     let mut ident_expr = ~[];\n     let mut struct_type = Unknown;\n \n-    foreach (i, struct_field) in struct_def.fields.iter().enumerate() {\n+    for (i, struct_field) in struct_def.fields.iter().enumerate() {\n         let opt_id = match struct_field.node.kind {\n             ast::named_field(ident, _) if (struct_type == Unknown ||\n                                            struct_type == Record) => {\n@@ -959,7 +959,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     // must be nonempty to reach here\n     let pattern = if struct_type == Record {\n         let field_pats = do vec::build |push| {\n-            foreach (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n+            for (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n                 // id is guaranteed to be Some\n                 push(ast::field_pat { ident: id.get(), pat: pat })\n             }\n@@ -991,7 +991,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n \n             let mut paths = ~[];\n             let mut ident_expr = ~[];\n-            foreach i in range(0u, variant_args.len()) {\n+            for i in range(0u, variant_args.len()) {\n                 let path = cx.path_ident(span,\n                                          cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n "}, {"sha": "b0f442ee638054552eb6793dcd114f75e6c1b6b4", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -81,7 +81,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    foreach &(_, field, _) in fields.iter() {\n+    for &(_, field, _) in fields.iter() {\n         exprs.push(call_iterbytes(field));\n     }\n "}, {"sha": "3425352ff0c5a48fb6a0c525cb916b1ce76fb0a4", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -64,7 +64,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: span,\n                 stmts.push(cx.stmt_expr(call));\n             };\n \n-            foreach (i, &(name, e, _)) in fields.iter().enumerate() {\n+            for (i, &(name, e, _)) in fields.iter().enumerate() {\n                 if i > 0 {\n                     push(cx.expr_str(span, @\", \"));\n                 }"}, {"sha": "a6c5526b5a9b4968624db792fa6f17bc06c2f1db", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -102,7 +102,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         }\n \n         // Desugar expr_for_loop\n-        // From: `foreach <src_pat> in <src_expr> <src_loop_block>`\n+        // From: `for <src_pat> in <src_expr> <src_loop_block>`\n         ast::expr_for_loop(src_pat, src_expr, ref src_loop_block) => {\n             let src_pat = src_pat.clone();\n             let src_expr = src_expr.clone();\n@@ -543,7 +543,7 @@ impl Visitor<()> for NewNameFinderContext {\n                     _ => ()\n                 }\n                 // visit optional subpattern of pat_ident:\n-                foreach subpat in inner.iter() {\n+                for subpat in inner.iter() {\n                     self.visit_pat(*subpat, ())\n                 }\n             }"}, {"sha": "2dbf6887a214e4b156a8f7f0cb44625cf38e1980", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -67,7 +67,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     fn make_rt_conv_expr(cx: @ExtCtxt, sp: span, cnv: &Conv) -> @ast::expr {\n         fn make_flags(cx: @ExtCtxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n-            foreach f in flags.iter() {\n+            for f in flags.iter() {\n                 let fstr = match *f {\n                   FlagLeftJustify => \"flag_left_justify\",\n                   FlagLeftZeroPad => \"flag_left_zero_pad\",\n@@ -153,7 +153,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n           option::None => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        foreach f in cnv.flags.iter() {\n+        for f in cnv.flags.iter() {\n             match *f {\n               FlagLeftJustify => (),\n               FlagSignAlways => {\n@@ -203,7 +203,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n         }\n-        foreach f in c.flags.iter() {\n+        for f in c.flags.iter() {\n             match *f {\n               FlagLeftJustify => debug!(\"flag: left justify\"),\n               FlagLeftZeroPad => debug!(\"flag: left zero pad\"),\n@@ -269,7 +269,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n        corresponding function in std::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n     let npieces = pieces.len();\n-    foreach (i, pc) in pieces.consume_iter().enumerate() {\n+    for (i, pc) in pieces.consume_iter().enumerate() {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {"}, {"sha": "d218be5e47637467013de96f0e260e4dbbb68aa5", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -632,7 +632,7 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n-    foreach tt in tts.iter() {\n+    for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n     }\n     ss"}, {"sha": "5a1317034b2211aba47e95ea2f1d5df984392bb2", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -137,7 +137,7 @@ pub fn count_names(ms: &[matcher]) -> uint {\n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n-    foreach elt in ms.iter() {\n+    for elt in ms.iter() {\n         match elt.node {\n           match_tok(_) => (),\n           match_seq(_,_,_,_,hi) => {\n@@ -194,7 +194,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n         match *m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n-            foreach next_m in more_ms.iter() {\n+            for next_m in more_ms.iter() {\n                 n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n@@ -210,7 +210,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    foreach m in ms.iter() { n_rec(p_s, m, res, &mut ret_val) }\n+    for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val) }\n     ret_val\n }\n \n@@ -279,7 +279,7 @@ pub fn parse(\n                         // most of the time.\n \n                         // Only touch the binders we have actually bound\n-                        foreach idx in range(ei.match_lo, ei.match_hi) {\n+                        for idx in range(ei.match_lo, ei.match_hi) {\n                             let sub = ei.matches[idx].clone();\n                             new_pos.matches[idx]\n                                 .push(@matched_seq(sub,\n@@ -320,7 +320,7 @@ pub fn parse(\n                         let mut new_ei = ei.clone();\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n-                        foreach idx in range(match_idx_lo, match_idx_hi) {\n+                        for idx in range(match_idx_lo, match_idx_hi) {\n                             new_ei.matches[idx].push(@matched_seq(~[], sp));\n                         }\n \n@@ -355,7 +355,7 @@ pub fn parse(\n         if tok == EOF {\n             if eof_eis.len() == 1u {\n                 let mut v = ~[];\n-                foreach dv in eof_eis[0u].matches.mut_iter() {\n+                for dv in eof_eis[0u].matches.mut_iter() {\n                     v.push(dv.pop());\n                 }\n                 return success(nameize(sess, ms, v));"}, {"sha": "10735dad32f00e9b93b46d37e9dbf6df7dbefd43", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -93,7 +93,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n         let s_d = cx.parse_sess().span_diagnostic;\n \n-        foreach (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n+        for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating"}, {"sha": "000f9c7379780b33816dbff76a04903fd1799ab9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -379,7 +379,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n     let view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let mut stmts = ~[];\n-    foreach stmt in b.stmts.iter() {\n+    for stmt in b.stmts.iter() {\n         match fld.fold_stmt(*stmt) {\n             None => {}\n             Some(stmt) => stmts.push(stmt)"}, {"sha": "d5296e60dd34571b3414f4c675ebdd0acfe79c92", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -126,10 +126,10 @@ pub fn visit_mod<E:Clone>(m: &_mod,\n                           _sp: span,\n                           _id: NodeId,\n                           (e, v): (E, vt<E>)) {\n-    foreach vi in m.view_items.iter() {\n+    for vi in m.view_items.iter() {\n         (v.visit_view_item)(vi, (e.clone(), v));\n     }\n-    foreach i in m.items.iter() {\n+    for i in m.items.iter() {\n         (v.visit_item)(*i, (e.clone(), v));\n     }\n }\n@@ -173,10 +173,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            foreach vi in nm.view_items.iter() {\n+            for vi in nm.view_items.iter() {\n                 (v.visit_view_item)(vi, (e.clone(), v));\n             }\n-            foreach ni in nm.items.iter() {\n+            for ni in nm.items.iter() {\n                 (v.visit_foreign_item)(*ni, (e.clone(), v));\n             }\n         }\n@@ -194,11 +194,11 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_impl(ref tps, ref traits, ref ty, ref methods) => {\n             (v.visit_generics)(tps, (e.clone(), v));\n-            foreach p in traits.iter() {\n+            for p in traits.iter() {\n                 visit_trait_ref(p, (e.clone(), v));\n             }\n             (v.visit_ty)(ty, (e.clone(), v));\n-            foreach m in methods.iter() {\n+            for m in methods.iter() {\n                 visit_method_helper(*m, (e.clone(), v))\n             }\n         }\n@@ -208,10 +208,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (e.clone(), v));\n-            foreach p in traits.iter() {\n+            for p in traits.iter() {\n                 visit_path(&p.path, (e.clone(), v));\n             }\n-            foreach m in methods.iter() {\n+            for m in methods.iter() {\n                 (v.visit_trait_method)(m, (e.clone(), v));\n             }\n         }\n@@ -222,10 +222,10 @@ pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                (e, v): (E, vt<E>)) {\n-    foreach vr in enum_definition.variants.iter() {\n+    for vr in enum_definition.variants.iter() {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                foreach va in variant_args.iter() {\n+                for va in variant_args.iter() {\n                     (v.visit_ty)(&va.ty, (e.clone(), v));\n                 }\n             }\n@@ -235,7 +235,7 @@ pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n             }\n         }\n         // Visit the disr expr if it exists\n-        foreach ex in vr.node.disr_expr.iter() {\n+        for ex in vr.node.disr_expr.iter() {\n             (v.visit_expr)(*ex, (e.clone(), v))\n         }\n     }\n@@ -250,12 +250,12 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n-            foreach tt in ts.iter() {\n+            for tt in ts.iter() {\n                 (v.visit_ty)(tt, (e.clone(), v));\n             }\n         },\n         ty_closure(ref f) => {\n-            foreach a in f.decl.inputs.iter() {\n+            for a in f.decl.inputs.iter() {\n                 (v.visit_ty)(&a.ty, (e.clone(), v));\n             }\n             (v.visit_ty)(&f.decl.output, (e.clone(), v));\n@@ -264,7 +264,7 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            foreach a in f.decl.inputs.iter() {\n+            for a in f.decl.inputs.iter() {\n                 (v.visit_ty)(&a.ty, (e.clone(), v));\n             }\n             (v.visit_ty)(&f.decl.output, (e, v));\n@@ -284,27 +284,27 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n-    foreach tp in p.types.iter() { (v.visit_ty)(tp, (e.clone(), v)); }\n+    for tp in p.types.iter() { (v.visit_ty)(tp, (e.clone(), v)); }\n }\n \n pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(ref path, ref children) => {\n             visit_path(path, (e.clone(), v));\n-            foreach children in children.iter() {\n-                foreach child in children.iter() {\n+            for children in children.iter() {\n+                for child in children.iter() {\n                     (v.visit_pat)(*child, (e.clone(), v));\n                 }\n             }\n         }\n         pat_struct(ref path, ref fields, _) => {\n             visit_path(path, (e.clone(), v));\n-            foreach f in fields.iter() {\n+            for f in fields.iter() {\n                 (v.visit_pat)(f.pat, (e.clone(), v));\n             }\n         }\n         pat_tup(ref elts) => {\n-            foreach elt in elts.iter() {\n+            for elt in elts.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v))\n             }\n         },\n@@ -313,7 +313,7 @@ pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n         },\n         pat_ident(_, ref path, ref inner) => {\n             visit_path(path, (e.clone(), v));\n-            foreach subpat in inner.iter() {\n+            for subpat in inner.iter() {\n                 (v.visit_pat)(*subpat, (e.clone(), v))\n             }\n         }\n@@ -324,13 +324,13 @@ pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n-            foreach elt in before.iter() {\n+            for elt in before.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n-            foreach elt in slice.iter() {\n+            for elt in slice.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n-            foreach tail in after.iter() {\n+            for tail in after.iter() {\n                 (v.visit_pat)(*tail, (e.clone(), v));\n             }\n         }\n@@ -351,7 +351,7 @@ pub fn visit_foreign_item<E:Clone>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n \n pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n-    foreach bound in bounds.iter() {\n+    for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref ty) => visit_trait_ref(ty, (e.clone(), v)),\n             RegionTyParamBound => {}\n@@ -360,13 +360,13 @@ pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n }\n \n pub fn visit_generics<E:Clone>(generics: &Generics, (e, v): (E, vt<E>)) {\n-    foreach tp in generics.ty_params.iter() {\n+    for tp in generics.ty_params.iter() {\n         visit_ty_param_bounds(&tp.bounds, (e.clone(), v));\n     }\n }\n \n pub fn visit_fn_decl<E:Clone>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n-    foreach a in fd.inputs.iter() {\n+    for a in fd.inputs.iter() {\n         (v.visit_pat)(a.pat, (e.clone(), v));\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n@@ -399,7 +399,7 @@ pub fn visit_fn<E:Clone>(fk: &fn_kind,\n }\n \n pub fn visit_ty_method<E:Clone>(m: &TypeMethod, (e, v): (E, vt<E>)) {\n-    foreach a in m.decl.inputs.iter() {\n+    for a in m.decl.inputs.iter() {\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n     (v.visit_generics)(&m.generics, (e.clone(), v));\n@@ -420,7 +420,7 @@ pub fn visit_struct_def<E:Clone>(\n     _id: NodeId,\n     (e, v): (E, vt<E>)\n ) {\n-    foreach f in sd.fields.iter() {\n+    for f in sd.fields.iter() {\n         (v.visit_struct_field)(*f, (e.clone(), v));\n     }\n }\n@@ -430,10 +430,10 @@ pub fn visit_struct_field<E:Clone>(sf: &struct_field, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_block<E:Clone>(b: &Block, (e, v): (E, vt<E>)) {\n-    foreach vi in b.view_items.iter() {\n+    for vi in b.view_items.iter() {\n         (v.visit_view_item)(vi, (e.clone(), v));\n     }\n-    foreach s in b.stmts.iter() {\n+    for s in b.stmts.iter() {\n         (v.visit_stmt)(*s, (e.clone(), v));\n     }\n     visit_expr_opt(b.expr, (e, v));\n@@ -460,7 +460,7 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_exprs<E:Clone>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    foreach ex in exprs.iter() { (v.visit_expr)(*ex, (e.clone(), v)); }\n+    for ex in exprs.iter() { (v.visit_expr)(*ex, (e.clone(), v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n@@ -477,21 +477,21 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_struct(ref p, ref flds, base) => {\n             visit_path(p, (e.clone(), v));\n-            foreach f in flds.iter() {\n+            for f in flds.iter() {\n                 (v.visit_expr)(f.expr, (e.clone(), v));\n             }\n             visit_expr_opt(base, (e.clone(), v));\n         }\n         expr_tup(ref elts) => {\n-            foreach el in elts.iter() { (v.visit_expr)(*el, (e.clone(), v)) }\n+            for el in elts.iter() { (v.visit_expr)(*el, (e.clone(), v)) }\n         }\n         expr_call(callee, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n             (v.visit_expr)(callee, (e.clone(), v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n-            foreach tp in tys.iter() {\n+            for tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n             (v.visit_expr)(callee, (e.clone(), v));\n@@ -524,7 +524,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_loop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n         expr_match(x, ref arms) => {\n             (v.visit_expr)(x, (e.clone(), v));\n-            foreach a in arms.iter() { (v.visit_arm)(a, (e.clone(), v)); }\n+            for a in arms.iter() { (v.visit_arm)(a, (e.clone(), v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -547,7 +547,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (e.clone(), v));\n-            foreach tp in tys.iter() {\n+            for tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n         }\n@@ -567,10 +567,10 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_mac(ref mac) => visit_mac(mac, (e.clone(), v)),\n         expr_paren(x) => (v.visit_expr)(x, (e.clone(), v)),\n         expr_inline_asm(ref a) => {\n-            foreach &(_, input) in a.inputs.iter() {\n+            for &(_, input) in a.inputs.iter() {\n                 (v.visit_expr)(input, (e.clone(), v));\n             }\n-            foreach &(_, out) in a.outputs.iter() {\n+            for &(_, out) in a.outputs.iter() {\n                 (v.visit_expr)(out, (e.clone(), v));\n             }\n         }\n@@ -579,7 +579,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n-    foreach p in a.pats.iter() { (v.visit_pat)(*p, (e.clone(), v)); }\n+    for p in a.pats.iter() { (v.visit_pat)(*p, (e.clone(), v)); }\n     visit_expr_opt(a.guard, (e.clone(), v));\n     (v.visit_block)(&a.body, (e.clone(), v));\n }"}, {"sha": "41379e6599c6e8b47e3835f9d5c9b4aa5c31379e", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -73,8 +73,8 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let mut i = uint::max_value;\n         let mut can_trim = true;\n         let mut first = true;\n-        foreach line in lines.iter() {\n-            foreach (j, c) in line.iter().enumerate() {\n+        for line in lines.iter() {\n+            for (j, c) in line.iter().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n                     break;"}, {"sha": "49deafeda40bb55c2a38f8a2e8f42fb7506d0e9e", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -837,7 +837,7 @@ mod test {\n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n     fn check_tokenization (env: Env, expected: ~[token::Token]) {\n-        foreach expected_tok in expected.iter() {\n+        for expected_tok in expected.iter() {\n             let TokenAndSpan {tok:actual_tok, sp: _} =\n                 env.string_reader.next_token();\n             assert_eq!(&actual_tok,expected_tok);"}, {"sha": "afa2e7a5e42f5da00dd09ac0bf08a06f26b8a1ce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -1623,8 +1623,6 @@ impl Parser {\n             hi = self.span.hi;\n         } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n-        } else if self.eat_keyword(keywords::ForEach) {\n-            return self.parse_for_expr();\n         } else if self.eat_keyword(keywords::For) {\n             return self.parse_for_expr();\n         } else if self.eat_keyword(keywords::Do) {\n@@ -3150,7 +3148,7 @@ impl Parser {\n         } = self.parse_items_and_view_items(first_item_attrs,\n                                             false, false);\n \n-        foreach item in items.iter() {\n+        for item in items.iter() {\n             let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n             stmts.push(@spanned(item.span.lo, item.span.hi,\n                                 stmt_decl(decl, self.get_id())));\n@@ -3755,7 +3753,7 @@ impl Parser {\n             fields = ~[];\n             while *self.token != token::RBRACE {\n                 let r = self.parse_struct_decl_field();\n-                foreach struct_field in r.iter() {\n+                for struct_field in r.iter() {\n                     fields.push(*struct_field)\n                 }\n             }\n@@ -4038,7 +4036,7 @@ impl Parser {\n             Some(i) => {\n                 let stack = &self.sess.included_mod_stack;\n                 let mut err = ~\"circular modules: \";\n-                foreach p in stack.slice(i, stack.len()).iter() {\n+                for p in stack.slice(i, stack.len()).iter() {\n                     err.push_str(p.to_str());\n                     err.push_str(\" -> \");\n                 }\n@@ -4252,7 +4250,7 @@ impl Parser {\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n             let r = self.parse_struct_decl_field();\n-            foreach struct_field in r.iter() {\n+            for struct_field in r.iter() {\n                 fields.push(*struct_field);\n             }\n         }\n@@ -4292,7 +4290,7 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                foreach ty in arg_tys.consume_iter() {\n+                for ty in arg_tys.consume_iter() {\n                     args.push(ast::variant_arg {\n                         ty: ty,\n                         id: self.get_id(),\n@@ -4401,7 +4399,7 @@ impl Parser {\n                 self.bump();\n                 let the_string = ident_to_str(&s);\n                 let mut abis = AbiSet::empty();\n-                foreach word in the_string.word_iter() {\n+                for word in the_string.word_iter() {\n                     match abi::lookup(word) {\n                         Some(abi) => {\n                             if abis.contains(abi) {"}, {"sha": "39668e5c8b29b22613e30ab034fd5fcbd5b7e198", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -471,10 +471,9 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n         \"use\",                // 61\n         \"while\",              // 62\n         \"in\",                 // 63\n-        \"foreach\",            // 64\n \n-        \"be\",                 // 65\n-        \"pure\",               // 66\n+        \"be\",                 // 64\n+        \"pure\",               // 65\n     ];\n \n     @ident_interner {\n@@ -571,7 +570,6 @@ pub mod keywords {\n         False,\n         Fn,\n         For,\n-        ForEach,\n         If,\n         Impl,\n         In,\n@@ -615,7 +613,6 @@ pub mod keywords {\n                 False => ident { name: 39, ctxt: 0 },\n                 Fn => ident { name: 40, ctxt: 0 },\n                 For => ident { name: 41, ctxt: 0 },\n-                ForEach => ident { name: 64, ctxt: 0 },\n                 If => ident { name: 42, ctxt: 0 },\n                 Impl => ident { name: 43, ctxt: 0 },\n                 In => ident { name: 63, ctxt: 0 },\n@@ -628,7 +625,7 @@ pub mod keywords {\n                 Once => ident { name: 50, ctxt: 0 },\n                 Priv => ident { name: 51, ctxt: 0 },\n                 Pub => ident { name: 52, ctxt: 0 },\n-                Pure => ident { name: 66, ctxt: 0 },\n+                Pure => ident { name: 65, ctxt: 0 },\n                 Ref => ident { name: 53, ctxt: 0 },\n                 Return => ident { name: 54, ctxt: 0 },\n                 Static => ident { name: 27, ctxt: 0 },\n@@ -641,7 +638,7 @@ pub mod keywords {\n                 Unsafe => ident { name: 60, ctxt: 0 },\n                 Use => ident { name: 61, ctxt: 0 },\n                 While => ident { name: 62, ctxt: 0 },\n-                Be => ident { name: 65, ctxt: 0 },\n+                Be => ident { name: 64, ctxt: 0 },\n             }\n         }\n     }\n@@ -657,7 +654,7 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 27 | 32 .. 66 => true,\n+            8 | 27 | 32 .. 65 => true,\n             _ => false,\n         },\n         _ => false\n@@ -667,7 +664,7 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 27 | 32 .. 64 => true,\n+            8 | 27 | 32 .. 63 => true,\n             _ => false,\n         },\n         _ => false,\n@@ -677,7 +674,7 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            65 .. 66 => true,\n+            64 .. 65 => true,\n             _ => false,\n         },\n         _ => false,"}, {"sha": "c3fcacdf7b031c82079f22f86cb626ba98dec6ea", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -320,7 +320,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n     box(s, 0u, b);\n     let mut first = true;\n-    foreach elt in elts.iter() {\n+    for elt in elts.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n@@ -333,7 +333,7 @@ pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n-    foreach elt in elts.iter() {\n+    for elt in elts.iter() {\n         maybe_print_comment(s, get_span(elt).hi);\n         op(s, elt);\n         i += 1u;\n@@ -353,23 +353,23 @@ pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n \n pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n-    foreach vitem in _mod.view_items.iter() {\n+    for vitem in _mod.view_items.iter() {\n         print_view_item(s, vitem);\n     }\n-    foreach item in _mod.items.iter() { print_item(s, *item); }\n+    for item in _mod.items.iter() { print_item(s, *item); }\n }\n \n pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n-    foreach vitem in nmod.view_items.iter() {\n+    for vitem in nmod.view_items.iter() {\n         print_view_item(s, vitem);\n     }\n-    foreach item in nmod.items.iter() { print_foreign_item(s, *item); }\n+    for item in nmod.items.iter() { print_foreign_item(s, *item); }\n }\n \n pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n-    foreach l in lifetime.iter() {\n+    for l in lifetime.iter() {\n         print_lifetime(s, l);\n         nbsp(s);\n     }\n@@ -589,7 +589,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n             word(s.s, \";\");\n         } else {\n             bopen(s);\n-            foreach meth in methods.iter() {\n+            for meth in methods.iter() {\n                print_method(s, *meth);\n             }\n             bclose(s, item.span);\n@@ -601,7 +601,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_generics(s, generics);\n         if traits.len() != 0u {\n             word(s.s, \":\");\n-            foreach (i, trait_) in traits.iter().enumerate() {\n+            for (i, trait_) in traits.iter().enumerate() {\n                 nbsp(s);\n                 if i != 0 {\n                     word_space(s, \"+\");\n@@ -611,7 +611,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         }\n         word(s.s, \" \");\n         bopen(s);\n-        foreach meth in methods.iter() {\n+        for meth in methods.iter() {\n             print_trait_method(s, meth);\n         }\n         bclose(s, item.span);\n@@ -650,7 +650,7 @@ pub fn print_variants(s: @ps,\n                       variants: &[ast::variant],\n                       span: codemap::span) {\n     bopen(s);\n-    foreach v in variants.iter() {\n+    for v in variants.iter() {\n         space_if_not_bol(s);\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n@@ -715,7 +715,7 @@ pub fn print_struct(s: @ps,\n         bopen(s);\n         hardbreak_if_not_bol(s);\n \n-        foreach field in struct_def.fields.iter() {\n+        for field in struct_def.fields.iter() {\n             match field.node.kind {\n                 ast::unnamed_field => fail!(\"unexpected unnamed field\"),\n                 ast::named_field(ident, visibility) => {\n@@ -750,7 +750,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, \"$(\");\n-        foreach tt_elt in (*tts).iter() { print_tt(s, tt_elt); }\n+        for tt_elt in (*tts).iter() { print_tt(s, tt_elt); }\n         word(s.s, \")\");\n         match (*sep) {\n           Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n@@ -767,7 +767,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n \n pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n-    foreach (i, tt) in tts.iter().enumerate() {\n+    for (i, tt) in tts.iter().enumerate() {\n         if i != 0 {\n             space(s.s);\n         }\n@@ -844,7 +844,7 @@ pub fn print_method(s: @ps, meth: &ast::method) {\n \n pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n-    foreach attr in attrs.iter() {\n+    for attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrOuter => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n@@ -855,7 +855,7 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n \n pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n-    foreach attr in attrs.iter() {\n+    for attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrInner => {\n             print_attribute(s, attr);\n@@ -960,8 +960,8 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     print_inner_attributes(s, attrs);\n \n-    foreach vi in blk.view_items.iter() { print_view_item(s, vi); }\n-    foreach st in blk.stmts.iter() {\n+    for vi in blk.view_items.iter() { print_view_item(s, vi); }\n+    for st in blk.stmts.iter() {\n         print_stmt(s, *st);\n     }\n     match blk.expr {\n@@ -1228,7 +1228,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_for_loop(pat, iter, ref blk) => {\n-        head(s, \"foreach\");\n+        head(s, \"for\");\n         print_pat(s, pat);\n         space(s.s);\n         word_space(s, \"in\");\n@@ -1237,7 +1237,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n-        foreach ident in opt_ident.iter() {\n+        for ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n@@ -1254,12 +1254,12 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         space(s.s);\n         bopen(s);\n         let len = arms.len();\n-        foreach (i, arm) in arms.iter().enumerate() {\n+        for (i, arm) in arms.iter().enumerate() {\n             space(s.s);\n             cbox(s, indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n-            foreach p in arm.pats.iter() {\n+            for p in arm.pats.iter() {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n@@ -1385,7 +1385,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n       ast::expr_break(opt_ident) => {\n         word(s.s, \"break\");\n         space(s.s);\n-        foreach ident in opt_ident.iter() {\n+        for ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s);\n@@ -1394,7 +1394,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n       ast::expr_again(opt_ident) => {\n         word(s.s, \"loop\");\n         space(s.s);\n-        foreach ident in opt_ident.iter() {\n+        for ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s)\n@@ -1425,15 +1425,15 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         popen(s);\n         print_string(s, a.asm);\n         word_space(s, \":\");\n-        foreach &(co, o) in a.outputs.iter() {\n+        for &(co, o) in a.outputs.iter() {\n             print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n-        foreach &(co, o) in a.inputs.iter() {\n+        for &(co, o) in a.inputs.iter() {\n             print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n@@ -1512,7 +1512,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n-    foreach id in path.idents.iter() {\n+    for id in path.idents.iter() {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n@@ -1525,7 +1525,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n         if path.rp.is_some() || !path.types.is_empty() {\n             word(s.s, \"<\");\n \n-            foreach r in path.rp.iter() {\n+            for r in path.rp.iter() {\n                 print_lifetime(s, r);\n                 if !path.types.is_empty() {\n                     word_space(s, \",\");\n@@ -1639,7 +1639,7 @@ pub fn print_pat(s: @ps, pat: &ast::pat) {\n         do commasep(s, inconsistent, *before) |s, &p| {\n             print_pat(s, p);\n         }\n-        foreach &p in slice.iter() {\n+        for &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n             word(s.s, \"..\");\n             print_pat(s, p);\n@@ -1699,11 +1699,11 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    foreach explicit_self in opt_explicit_self.iter() {\n+    for explicit_self in opt_explicit_self.iter() {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n \n-    foreach arg in decl.inputs.iter() {\n+    for arg in decl.inputs.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, arg);\n     }\n@@ -1750,7 +1750,7 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n     if !bounds.is_empty() {\n         word(s.s, \":\");\n         let mut first = true;\n-        foreach bound in bounds.iter() {\n+        for bound in bounds.iter() {\n             nbsp(s);\n             if first {\n                 first = false;\n@@ -1790,7 +1790,7 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n         }\n \n         let mut ints = ~[];\n-        foreach i in range(0u, total) {\n+        for i in range(0u, total) {\n             ints.push(i);\n         }\n \n@@ -1949,10 +1949,10 @@ pub fn print_ty_fn(s: @ps,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    foreach explicit_self in opt_explicit_self.iter() {\n+    for explicit_self in opt_explicit_self.iter() {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n-    foreach arg in decl.inputs.iter() {\n+    for arg in decl.inputs.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, arg);\n     }\n@@ -2108,7 +2108,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n       }\n       comments::isolated => {\n         pprust::hardbreak_if_not_bol(s);\n-        foreach line in cmnt.lines.iter() {\n+        for line in cmnt.lines.iter() {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n             if !line.is_empty() { word(s.s, *line); }\n@@ -2122,7 +2122,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            foreach line in cmnt.lines.iter() {\n+            for line in cmnt.lines.iter() {\n                 if !line.is_empty() { word(s.s, *line); }\n                 hardbreak(s.s);\n             }"}, {"sha": "46676ce1093fba81e917b8a8aebcc535d2bfb5b9", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -31,7 +31,7 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        foreach v in init.iter() {\n+        for v in init.iter() {\n             rv.intern((*v).clone());\n         }\n         rv\n@@ -93,7 +93,7 @@ impl StrInterner {\n \n     pub fn prefill(init: &[&str]) -> StrInterner {\n         let rv = StrInterner::new();\n-        foreach &v in init.iter() { rv.intern(v); }\n+        for &v in init.iter() { rv.intern(v); }\n         rv\n     }\n "}, {"sha": "15864fab258c0225864cb7aa6f35ce35495a420c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -93,10 +93,10 @@ pub fn visit_crate<E:Clone>(visitor: @Visitor<E>, crate: &Crate, env: E) {\n }\n \n pub fn visit_mod<E:Clone>(visitor: @Visitor<E>, module: &_mod, env: E) {\n-    foreach view_item in module.view_items.iter() {\n+    for view_item in module.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n-    foreach item in module.items.iter() {\n+    for item in module.items.iter() {\n         visitor.visit_item(*item, env.clone())\n     }\n }\n@@ -138,10 +138,10 @@ pub fn visit_item<E:Clone>(visitor: @Visitor<E>, item: &item, env: E) {\n             visitor.visit_mod(module, item.span, item.id, env)\n         }\n         item_foreign_mod(ref foreign_module) => {\n-            foreach view_item in foreign_module.view_items.iter() {\n+            for view_item in foreign_module.view_items.iter() {\n                 visitor.visit_view_item(view_item, env.clone())\n             }\n-            foreach foreign_item in foreign_module.items.iter() {\n+            for foreign_item in foreign_module.items.iter() {\n                 visitor.visit_foreign_item(*foreign_item, env.clone())\n             }\n         }\n@@ -158,11 +158,11 @@ pub fn visit_item<E:Clone>(visitor: @Visitor<E>, item: &item, env: E) {\n                   ref typ,\n                   ref methods) => {\n             visitor.visit_generics(type_parameters, env.clone());\n-            foreach trait_reference in trait_references.iter() {\n+            for trait_reference in trait_references.iter() {\n                 visit_trait_ref(visitor, trait_reference, env.clone())\n             }\n             visitor.visit_ty(typ, env.clone());\n-            foreach method in methods.iter() {\n+            for method in methods.iter() {\n                 visit_method_helper(visitor, *method, env.clone())\n             }\n         }\n@@ -176,10 +176,10 @@ pub fn visit_item<E:Clone>(visitor: @Visitor<E>, item: &item, env: E) {\n         }\n         item_trait(ref generics, ref trait_paths, ref methods) => {\n             visitor.visit_generics(generics, env.clone());\n-            foreach trait_path in trait_paths.iter() {\n+            for trait_path in trait_paths.iter() {\n                 visit_path(visitor, &trait_path.path, env.clone())\n             }\n-            foreach method in methods.iter() {\n+            for method in methods.iter() {\n                 visitor.visit_trait_method(method, env.clone())\n             }\n         }\n@@ -191,10 +191,10 @@ pub fn visit_enum_def<E:Clone>(visitor: @Visitor<E>,\n                                enum_definition: &ast::enum_def,\n                                generics: &Generics,\n                                env: E) {\n-    foreach variant in enum_definition.variants.iter() {\n+    for variant in enum_definition.variants.iter() {\n         match variant.node.kind {\n             tuple_variant_kind(ref variant_arguments) => {\n-                foreach variant_argument in variant_arguments.iter() {\n+                for variant_argument in variant_arguments.iter() {\n                     visitor.visit_ty(&variant_argument.ty, env.clone())\n                 }\n             }\n@@ -221,28 +221,28 @@ pub fn visit_ty<E:Clone>(visitor: @Visitor<E>, typ: &Ty, env: E) {\n             visitor.visit_ty(mutable_type.ty, env)\n         }\n         ty_tup(ref tuple_element_types) => {\n-            foreach tuple_element_type in tuple_element_types.iter() {\n+            for tuple_element_type in tuple_element_types.iter() {\n                 visitor.visit_ty(tuple_element_type, env.clone())\n             }\n         }\n         ty_closure(ref function_declaration) => {\n-             foreach argument in function_declaration.decl.inputs.iter() {\n+             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&argument.ty, env.clone())\n              }\n              visitor.visit_ty(&function_declaration.decl.output, env.clone());\n-             foreach bounds in function_declaration.bounds.iter() {\n+             for bounds in function_declaration.bounds.iter() {\n                 visit_ty_param_bounds(visitor, bounds, env.clone())\n              }\n         }\n         ty_bare_fn(ref function_declaration) => {\n-            foreach argument in function_declaration.decl.inputs.iter() {\n+            for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&argument.ty, env.clone())\n             }\n             visitor.visit_ty(&function_declaration.decl.output, env.clone())\n         }\n         ty_path(ref path, ref bounds, _) => {\n             visit_path(visitor, path, env.clone());\n-            foreach bounds in bounds.iter() {\n+            for bounds in bounds.iter() {\n                 visit_ty_param_bounds(visitor, bounds, env.clone())\n             }\n         }\n@@ -255,7 +255,7 @@ pub fn visit_ty<E:Clone>(visitor: @Visitor<E>, typ: &Ty, env: E) {\n }\n \n pub fn visit_path<E:Clone>(visitor: @Visitor<E>, path: &Path, env: E) {\n-    foreach typ in path.types.iter() {\n+    for typ in path.types.iter() {\n         visitor.visit_ty(typ, env.clone())\n     }\n }\n@@ -264,20 +264,20 @@ pub fn visit_pat<E:Clone>(visitor: @Visitor<E>, pattern: &pat, env: E) {\n     match pattern.node {\n         pat_enum(ref path, ref children) => {\n             visit_path(visitor, path, env.clone());\n-            foreach children in children.iter() {\n-                foreach child in children.iter() {\n+            for children in children.iter() {\n+                for child in children.iter() {\n                     visitor.visit_pat(*child, env.clone())\n                 }\n             }\n         }\n         pat_struct(ref path, ref fields, _) => {\n             visit_path(visitor, path, env.clone());\n-            foreach field in fields.iter() {\n+            for field in fields.iter() {\n                 visitor.visit_pat(field.pat, env.clone())\n             }\n         }\n         pat_tup(ref tuple_elements) => {\n-            foreach tuple_element in tuple_elements.iter() {\n+            for tuple_element in tuple_elements.iter() {\n                 visitor.visit_pat(*tuple_element, env.clone())\n             }\n         }\n@@ -300,13 +300,13 @@ pub fn visit_pat<E:Clone>(visitor: @Visitor<E>, pattern: &pat, env: E) {\n         }\n         pat_wild => (),\n         pat_vec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n-            foreach prepattern in prepattern.iter() {\n+            for prepattern in prepattern.iter() {\n                 visitor.visit_pat(*prepattern, env.clone())\n             }\n-            foreach slice_pattern in slice_pattern.iter() {\n+            for slice_pattern in slice_pattern.iter() {\n                 visitor.visit_pat(*slice_pattern, env.clone())\n             }\n-            foreach postpattern in postpatterns.iter() {\n+            for postpattern in postpatterns.iter() {\n                 visitor.visit_pat(*postpattern, env.clone())\n             }\n         }\n@@ -328,7 +328,7 @@ pub fn visit_foreign_item<E:Clone>(visitor: @Visitor<E>,\n pub fn visit_ty_param_bounds<E:Clone>(visitor: @Visitor<E>,\n                                       bounds: &OptVec<TyParamBound>,\n                                       env: E) {\n-    foreach bound in bounds.iter() {\n+    for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n                 visit_trait_ref(visitor, typ, env.clone())\n@@ -341,15 +341,15 @@ pub fn visit_ty_param_bounds<E:Clone>(visitor: @Visitor<E>,\n pub fn visit_generics<E:Clone>(visitor: @Visitor<E>,\n                                generics: &Generics,\n                                env: E) {\n-    foreach type_parameter in generics.ty_params.iter() {\n+    for type_parameter in generics.ty_params.iter() {\n         visit_ty_param_bounds(visitor, &type_parameter.bounds, env.clone())\n     }\n }\n \n pub fn visit_fn_decl<E:Clone>(visitor: @Visitor<E>,\n                               function_declaration: &fn_decl,\n                               env: E) {\n-    foreach argument in function_declaration.inputs.iter() {\n+    for argument in function_declaration.inputs.iter() {\n         visitor.visit_pat(argument.pat, env.clone());\n         visitor.visit_ty(&argument.ty, env.clone())\n     }\n@@ -387,7 +387,7 @@ pub fn visit_fn<E:Clone>(visitor: @Visitor<E>,\n pub fn visit_ty_method<E:Clone>(visitor: @Visitor<E>,\n                                 method_type: &TypeMethod,\n                                 env: E) {\n-    foreach argument_type in method_type.decl.inputs.iter() {\n+    for argument_type in method_type.decl.inputs.iter() {\n         visitor.visit_ty(&argument_type.ty, env.clone())\n     }\n     visitor.visit_generics(&method_type.generics, env.clone());\n@@ -411,7 +411,7 @@ pub fn visit_struct_def<E:Clone>(visitor: @Visitor<E>,\n                                  _: &Generics,\n                                  _: NodeId,\n                                  env: E) {\n-    foreach field in struct_definition.fields.iter() {\n+    for field in struct_definition.fields.iter() {\n         visitor.visit_struct_field(*field, env.clone())\n     }\n }\n@@ -423,10 +423,10 @@ pub fn visit_struct_field<E:Clone>(visitor: @Visitor<E>,\n }\n \n pub fn visit_block<E:Clone>(visitor: @Visitor<E>, block: &Block, env: E) {\n-    foreach view_item in block.view_items.iter() {\n+    for view_item in block.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n-    foreach statement in block.stmts.iter() {\n+    for statement in block.stmts.iter() {\n         visitor.visit_stmt(*statement, env.clone())\n     }\n     visit_expr_opt(visitor, block.expr, env)\n@@ -461,7 +461,7 @@ pub fn visit_expr_opt<E>(visitor: @Visitor<E>,\n pub fn visit_exprs<E:Clone>(visitor: @Visitor<E>,\n                             expressions: &[@expr],\n                             env: E) {\n-    foreach expression in expressions.iter() {\n+    for expression in expressions.iter() {\n         visitor.visit_expr(*expression, env.clone())\n     }\n }\n@@ -484,25 +484,25 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n         }\n         expr_struct(ref path, ref fields, optional_base) => {\n             visit_path(visitor, path, env.clone());\n-            foreach field in fields.iter() {\n+            for field in fields.iter() {\n                 visitor.visit_expr(field.expr, env.clone())\n             }\n             visit_expr_opt(visitor, optional_base, env.clone())\n         }\n         expr_tup(ref subexpressions) => {\n-            foreach subexpression in subexpressions.iter() {\n+            for subexpression in subexpressions.iter() {\n                 visitor.visit_expr(*subexpression, env.clone())\n             }\n         }\n         expr_call(callee_expression, ref arguments, _) => {\n-            foreach argument in arguments.iter() {\n+            for argument in arguments.iter() {\n                 visitor.visit_expr(*argument, env.clone())\n             }\n             visitor.visit_expr(callee_expression, env.clone())\n         }\n         expr_method_call(_, callee, _, ref types, ref arguments, _) => {\n             visit_exprs(visitor, *arguments, env.clone());\n-            foreach typ in types.iter() {\n+            for typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }\n             visitor.visit_expr(callee, env.clone())\n@@ -539,7 +539,7 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n         expr_loop(ref block, _) => visitor.visit_block(block, env.clone()),\n         expr_match(subexpression, ref arms) => {\n             visitor.visit_expr(subexpression, env.clone());\n-            foreach arm in arms.iter() {\n+            for arm in arms.iter() {\n                 visitor.visit_arm(arm, env.clone())\n             }\n         }\n@@ -562,7 +562,7 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n         }\n         expr_field(subexpression, _, ref types) => {\n             visitor.visit_expr(subexpression, env.clone());\n-            foreach typ in types.iter() {\n+            for typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }\n         }\n@@ -584,10 +584,10 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n             visitor.visit_expr(subexpression, env.clone())\n         }\n         expr_inline_asm(ref assembler) => {\n-            foreach &(_, input) in assembler.inputs.iter() {\n+            for &(_, input) in assembler.inputs.iter() {\n                 visitor.visit_expr(input, env.clone())\n             }\n-            foreach &(_, output) in assembler.outputs.iter() {\n+            for &(_, output) in assembler.outputs.iter() {\n                 visitor.visit_expr(output, env.clone())\n             }\n         }\n@@ -597,7 +597,7 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n }\n \n pub fn visit_arm<E:Clone>(visitor: @Visitor<E>, arm: &arm, env: E) {\n-    foreach pattern in arm.pats.iter() {\n+    for pattern in arm.pats.iter() {\n         visitor.visit_pat(*pattern, env.clone())\n     }\n     visit_expr_opt(visitor, arm.guard, env.clone());"}, {"sha": "c9809438d94622020cd6798cdab3c2f50b3559c2", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -28,7 +28,7 @@ pub fn alist_get<A:Clone + 'static,\n                  k: A)\n                  -> B {\n     let eq_fn = lst.eq_fn;\n-    foreach entry in lst.data.iter() {\n+    for entry in lst.data.iter() {\n         if eq_fn(entry.key.clone(), k.clone()) {\n             return entry.value.clone();\n         }"}, {"sha": "da1c3596ff6c94030711fc4ae3fe7ff663048d55", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -31,19 +31,19 @@ fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     io::println(\" Ascending integers:\");\n \n     do timed(\"insert\") {\n-        foreach i in range(0u, n_keys) {\n+        for i in range(0u, n_keys) {\n             map.insert(i, i + 1);\n         }\n     }\n \n     do timed(\"search\") {\n-        foreach i in range(0u, n_keys) {\n+        for i in range(0u, n_keys) {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     }\n \n     do timed(\"remove\") {\n-        foreach i in range(0, n_keys) {\n+        for i in range(0, n_keys) {\n             assert!(map.remove(&i));\n         }\n     }\n@@ -77,19 +77,19 @@ fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n fn vector<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n     do timed(\"insert\") {\n-        foreach i in range(0u, n_keys) {\n+        for i in range(0u, n_keys) {\n             map.insert(dist[i], i + 1);\n         }\n     }\n \n     do timed(\"search\") {\n-        foreach i in range(0u, n_keys) {\n+        for i in range(0u, n_keys) {\n             assert_eq!(map.find(&dist[i]).unwrap(), &(i + 1));\n         }\n     }\n \n     do timed(\"remove\") {\n-        foreach i in range(0u, n_keys) {\n+        for i in range(0u, n_keys) {\n             assert!(map.remove(&dist[i]));\n         }\n     }"}, {"sha": "2c412e2eecd807fe52ec9f4bd9c1a8bf0a3c3305", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -46,11 +46,11 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_ints) {\n-                foreach i in range(0u, num_keys) {\n+                for i in range(0u, num_keys) {\n                     set.insert(i);\n                 }\n \n-                foreach i in range(0u, num_keys) {\n+                for i in range(0u, num_keys) {\n                     assert!(set.contains(&i));\n                 }\n             }\n@@ -67,12 +67,12 @@ impl Results {\n \n         {\n             let mut set = f();\n-            foreach i in range(0u, num_keys) {\n+            for i in range(0u, num_keys) {\n                 set.insert(i);\n             }\n \n             do timed(&mut self.delete_ints) {\n-                foreach i in range(0u, num_keys) {\n+                for i in range(0u, num_keys) {\n                     assert!(set.remove(&i));\n                 }\n             }\n@@ -88,12 +88,12 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {\n-                foreach i in range(0u, num_keys) {\n+                for i in range(0u, num_keys) {\n                     let s = uint::to_str(i);\n                     set.insert(s);\n                 }\n \n-                foreach i in range(0u, num_keys) {\n+                for i in range(0u, num_keys) {\n                     let s = uint::to_str(i);\n                     assert!(set.contains(&s));\n                 }\n@@ -112,11 +112,11 @@ impl Results {\n \n         {\n             let mut set = f();\n-            foreach i in range(0u, num_keys) {\n+            for i in range(0u, num_keys) {\n                 set.insert(uint::to_str(i));\n             }\n             do timed(&mut self.delete_strings) {\n-                foreach i in range(0u, num_keys) {\n+                for i in range(0u, num_keys) {\n                     assert!(set.remove(&uint::to_str(i)));\n                 }\n             }"}, {"sha": "a0ceb654b526908b1a386fc3c72eb94e9cf5874a", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -74,7 +74,7 @@ fn read_line() {\n     let path = Path(env!(\"CFG_SRC_DIR\"))\n         .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n \n-    foreach _ in range(0, 3) {\n+    for _ in range(0, 3) {\n         let reader = io::file_reader(&path).unwrap();\n         while !reader.eof() {\n             reader.read_line();\n@@ -119,7 +119,7 @@ fn vec_push_all() {\n     let mut r = rand::rng();\n \n     let mut v = ~[];\n-    foreach i in range(0u, 1500) {\n+    for i in range(0u, 1500) {\n         let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n@@ -133,7 +133,7 @@ fn vec_push_all() {\n \n fn is_utf8_ascii() {\n     let mut v : ~[u8] = ~[];\n-    foreach _ in range(0u, 20000) {\n+    for _ in range(0u, 20000) {\n         v.push('b' as u8);\n         if !str::is_utf8(v) {\n             fail!(\"is_utf8 failed\");\n@@ -144,7 +144,7 @@ fn is_utf8_ascii() {\n fn is_utf8_multibyte() {\n     let s = \"b\u00a2\u20ac\ud852\udf62\";\n     let mut v : ~[u8]= ~[];\n-    foreach _ in range(0u, 5000) {\n+    for _ in range(0u, 5000) {\n         v.push_all(s.as_bytes());\n         if !str::is_utf8(v) {\n             fail!(\"is_utf8 failed\");"}, {"sha": "8924a9beb6e5ee8c9f449f8612342e123bb65eda", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -23,7 +23,7 @@ fn main() {\n \n     let n = uint::from_str(args[1]).get();\n \n-    foreach i in range(0u, n) {\n+    for i in range(0u, n) {\n         let x = uint::to_str(i);\n         info!(x);\n     }"}, {"sha": "2557680f7b507853abac8a06fe0e1e5fa88c7218", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -87,7 +87,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         HashSet::new()\n     };\n \n-    foreach e in edges.iter() {\n+    for e in edges.iter() {\n         match *e {\n             (i, j) => {\n                 graph[i].insert(j);\n@@ -98,7 +98,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n \n     do graph.consume_iter().transform |v| {\n         let mut vec = ~[];\n-        foreach i in v.consume() {\n+        for i in v.consume() {\n             vec.push(i);\n         }\n         vec\n@@ -119,7 +119,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n         }\n     }\n     let mut vec = ~[];\n-    foreach i in keys.consume() {\n+    for i in keys.consume() {\n         vec.push(i);\n     }\n     return vec;\n@@ -435,7 +435,7 @@ fn main() {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0;\n-    foreach edges in graph.iter() { total_edges += edges.len(); }\n+    for edges in graph.iter() { total_edges += edges.len(); }\n \n     io::stdout().write_line(fmt!(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2,"}, {"sha": "186923da43b8ccad194fbfb1d3c4ab47b1d6e8b0", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -64,12 +64,12 @@ fn run(args: &[~str]) {\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];\n-    foreach _ in range(0u, workers) {\n+    for _ in range(0u, workers) {\n         let to_child = to_child.clone();\n         let mut builder = task::task();\n         builder.future_result(|r| worker_results.push(r));\n         do builder.spawn {\n-            foreach _ in range(0u, size / workers) {\n+            for _ in range(0u, size / workers) {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n@@ -80,7 +80,7 @@ fn run(args: &[~str]) {\n         server(&from_parent, &to_parent);\n     }\n \n-    foreach r in worker_results.iter() {\n+    for r in worker_results.iter() {\n         r.recv();\n     }\n "}, {"sha": "05ace5fd8e6c75b75ed10c069ca0ca82d03a626f", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -58,12 +58,12 @@ fn run(args: &[~str]) {\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];\n-    foreach _ in range(0u, workers) {\n+    for _ in range(0u, workers) {\n         let to_child = to_child.clone();\n         let mut builder = task::task();\n         builder.future_result(|r| worker_results.push(r));\n         do builder.spawn {\n-            foreach _ in range(0u, size / workers) {\n+            for _ in range(0u, size / workers) {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n@@ -74,7 +74,7 @@ fn run(args: &[~str]) {\n         server(&from_parent, &to_parent);\n     }\n \n-    foreach r in worker_results.iter() {\n+    for r in worker_results.iter() {\n         r.recv();\n     }\n "}, {"sha": "649d029e60e8b7a3c20441da9a5f1e5262e85185", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -57,7 +57,7 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     let mut num_chan = Some(num_chan);\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n-    foreach j in range(0u, count) {\n+    for j in range(0u, count) {\n         //error!(\"task %?, iter %?\", i, j);\n         let num_chan2 = num_chan.take_unwrap();\n         let num_port2 = num_port.take_unwrap();\n@@ -90,7 +90,7 @@ fn main() {\n     // create the ring\n     let mut futures = ~[];\n \n-    foreach i in range(1u, num_tasks) {\n+    for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n         let num_chan2 = Cell::new(num_chan.take());\n@@ -108,7 +108,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    foreach f in futures.mut_iter() {\n+    for f in futures.mut_iter() {\n         f.get()\n     }\n "}, {"sha": "7f9d7aa588906b9837105a76dab73050abf64ab1", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -53,7 +53,7 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     let mut num_chan = Some(num_chan);\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n-    foreach j in range(0u, count) {\n+    for j in range(0u, count) {\n         //error!(\"task %?, iter %?\", i, j);\n         let num_chan2 = num_chan.take_unwrap();\n         let num_port2 = num_port.take_unwrap();\n@@ -86,7 +86,7 @@ fn main() {\n     // create the ring\n     let mut futures = ~[];\n \n-    foreach i in range(1u, num_tasks) {\n+    for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n         let num_chan2 = Cell::new(num_chan.take());\n@@ -104,7 +104,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    foreach f in futures.mut_iter() {\n+    for f in futures.mut_iter() {\n         let _ = f.get();\n     }\n "}, {"sha": "19380feea6df4beca237cfa16e6033ea27cecb39", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -38,11 +38,11 @@ impl Noise2DContext {\n     pub fn new() -> Noise2DContext {\n         let mut r = rand::rng();\n         let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n-        foreach i in range(0, 256) {\n+        for i in range(0, 256) {\n             rgradients[i] = random_gradient(&mut r);\n         }\n         let mut permutations = [ 0, ..256 ];\n-        foreach i in range(0, 256) {\n+        for i in range(0, 256) {\n             permutations[i] = i;\n         }\n         r.shuffle_mut(permutations);\n@@ -106,8 +106,8 @@ fn main() {\n     let mut pixels = [0f32, ..256*256];\n     let n2d = ~Noise2DContext::new();\n     do 100.times {\n-        foreach y in range(0, 256) {\n-            foreach x in range(0, 256) {\n+        for y in range(0, 256) {\n+            for x in range(0, 256) {\n                 let v = n2d.get(\n                     x as f32 * 0.1f32,\n                     y as f32 * 0.1f32\n@@ -117,8 +117,8 @@ fn main() {\n         };\n     };\n \n-    foreach y in range(0, 256) {\n-        foreach x in range(0, 256) {\n+    for y in range(0, 256) {\n+        for x in range(0, 256) {\n             print(symbols[(pixels[y*256+x] / 0.2f32) as int]);\n         }\n         println(\"\");"}, {"sha": "f48c15329463e890b854c5dd6185c49ff716a998", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -22,8 +22,8 @@ use std::uint;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n-    foreach aa in all.iter() {\n-        foreach bb in all.iter() {\n+    for aa in all.iter() {\n+        for bb in all.iter() {\n             println(show_color(*aa) + \" + \" + show_color(*bb) +\n                     \" -> \" + show_color(transform(*aa, *bb)));\n         }\n@@ -47,7 +47,7 @@ fn show_color(cc: color) -> ~str {\n \n fn show_color_list(set: ~[color]) -> ~str {\n     let mut out = ~\"\";\n-    foreach col in set.iter() {\n+    for col in set.iter() {\n         out.push_char(' ');\n         out.push_str(show_color(*col));\n     }\n@@ -180,21 +180,21 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     }\n \n     // tell each creature to stop\n-    foreach to_one in to_creature.iter() {\n+    for to_one in to_creature.iter() {\n         to_one.send(None);\n     }\n \n     // save each creature's meeting stats\n     let mut report = ~[];\n-    foreach _to_one in to_creature.iter() {\n+    for _to_one in to_creature.iter() {\n         report.push(from_creatures_log.recv());\n     }\n \n     // print each color in the set\n     io::println(show_color_list(set));\n \n     // print each creature's stats\n-    foreach rep in report.iter() {\n+    for rep in report.iter() {\n         io::println(*rep);\n     }\n "}, {"sha": "bf942cf61a38c1bd2ebc1f52061c9540e12f612c", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -28,7 +28,7 @@ fn fannkuch_redux(n: i32) -> i32 {\n                 r -= 1;\n             }\n \n-            foreach (perm_i, perm1_i) in perm.mut_iter().zip(perm1.iter()) {\n+            for (perm_i, perm1_i) in perm.mut_iter().zip(perm1.iter()) {\n                 *perm_i = *perm1_i;\n             }\n \n@@ -41,7 +41,7 @@ fn fannkuch_redux(n: i32) -> i32 {\n                 }\n \n                 let k2 = (k+1) >> 1;\n-                foreach i in range(0i32, k2) {\n+                for i in range(0i32, k2) {\n                     let (perm_i, perm_k_i) = {\n                         (perm.unsafe_get(i as uint),\n                             perm.unsafe_get((k-i) as uint))"}, {"sha": "af96170c79c8701318f62111146b95c91d8a9e71", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -58,7 +58,7 @@ static HOMO_SAPIENS: [AminoAcid, ..4] = [\n fn sum_and_scale(a: &'static [AminoAcid]) -> ~[AminoAcid] {\n     let mut result = ~[];\n     let mut p = 0f32;\n-    foreach a_i in a.iter() {\n+    for a_i in a.iter() {\n         let mut a_i = *a_i;\n         p += a_i.p;\n         a_i.p = p * LOOKUP_SCALE;\n@@ -134,7 +134,7 @@ impl RandomFasta {\n     fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n         let mut lookup = [ NULL_AMINO_ACID, ..LOOKUP_SIZE ];\n         let mut j = 0;\n-        foreach (i, slot) in lookup.mut_iter().enumerate() {\n+        for (i, slot) in lookup.mut_iter().enumerate() {\n             while a[j].p < (i as f32) {\n                 j += 1;\n             }\n@@ -150,7 +150,7 @@ impl RandomFasta {\n \n     fn nextc(&mut self) -> u8 {\n         let r = self.rng(1.0);\n-        foreach a in self.lookup.iter() {\n+        for a in self.lookup.iter() {\n             if a.p >= r {\n                 return a.c;\n             }\n@@ -165,7 +165,7 @@ impl RandomFasta {\n             let mut buf = [0, ..LINE_LEN + 1];\n \n             do lines.times {\n-                foreach i in range(0u, LINE_LEN) {\n+                for i in range(0u, LINE_LEN) {\n                     buf[i] = self.nextc();\n                 }\n                 buf[LINE_LEN] = '\\n' as u8;\n@@ -174,7 +174,7 @@ impl RandomFasta {\n                        1,\n                        self.stdout);\n             }\n-            foreach i in range(0u, chars_left) {\n+            for i in range(0u, chars_left) {\n                 buf[i] = self.nextc();\n             }\n             fwrite(transmute(&buf[0]), chars_left as size_t, 1, self.stdout);"}, {"sha": "3a90c6647e08e5d732b9f8ad0ae7deee053fff51", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -46,7 +46,7 @@ struct AminoAcids {\n fn make_cumulative(aa: ~[AminoAcids]) -> ~[AminoAcids] {\n     let mut cp: u32 = 0u32;\n     let mut ans: ~[AminoAcids] = ~[];\n-    foreach a in aa.iter() {\n+    for a in aa.iter() {\n         cp += a.prob;\n         ans.push(AminoAcids {ch: a.ch, prob: cp});\n     }\n@@ -81,7 +81,7 @@ fn make_random_fasta(wr: @io::Writer,\n         last: rng.next()\n     };\n     let mut op: ~str = ~\"\";\n-    foreach _ in range(0u, n as uint) {\n+    for _ in range(0u, n as uint) {\n         op.push_char(select_random(myrandom_next(rng, 100u32),\n                                    genelist.clone()));\n         if op.len() >= LINE_LENGTH {\n@@ -96,7 +96,7 @@ fn make_repeat_fasta(wr: @io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n     wr.write_line(~\">\" + id + \" \" + desc);\n     let mut op = str::with_capacity( LINE_LENGTH );\n     let sl = s.len();\n-    foreach i in range(0u, n as uint) {\n+    for i in range(0u, n as uint) {\n         if (op.len() >= LINE_LENGTH) {\n             wr.write_line( op );\n             op = str::with_capacity( LINE_LENGTH );"}, {"sha": "8c4e9092ce0a6f1d9640ebc9759079cdf3f53fc0", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -62,15 +62,15 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   foreach (key, &val) in mm.iter() {\n+   for (key, &val) in mm.iter() {\n       pairs.push(((*key).clone(), pct(val, total)));\n    }\n \n    let pairs_sorted = sortKV(pairs);\n \n    let mut buffer = ~\"\";\n \n-   foreach kv in pairs_sorted.iter() {\n+   for kv in pairs_sorted.iter() {\n        let (k,v) = (*kv).clone();\n        unsafe {\n            let b = str::raw::from_bytes(k);\n@@ -215,7 +215,7 @@ fn main() {\n          (_, true) => {\n             let line_bytes = line.as_bytes();\n \n-           foreach (ii, _sz) in sizes.iter().enumerate() {\n+           for (ii, _sz) in sizes.iter().enumerate() {\n                let lb = line_bytes.to_owned();\n                to_child[ii].send(lb);\n             }\n@@ -227,12 +227,12 @@ fn main() {\n    }\n \n    // finish...\n-    foreach (ii, _sz) in sizes.iter().enumerate() {\n+    for (ii, _sz) in sizes.iter().enumerate() {\n       to_child[ii].send(~[]);\n    }\n \n    // now fetch and print result messages\n-    foreach (ii, _sz) in sizes.iter().enumerate() {\n+    for (ii, _sz) in sizes.iter().enumerate() {\n       io::println(from_child[ii].recv());\n    }\n }"}, {"sha": "96fd4d7e604e7888c803b6b0a1285b1757fa8026", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -44,7 +44,7 @@ impl Code {\n \n     fn pack(string: &str) -> Code {\n         let mut code = Code(0u64);\n-        foreach i in range(0u, string.len()) {\n+        for i in range(0u, string.len()) {\n             code = code.push_char(string[i]);\n         }\n         code"}, {"sha": "16936f6ed722d3fad5be3024ed7a75a8b33983fc", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,17 +19,17 @@ fn main() {\n         let mode = \"w\";\n         let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n \n-        foreach y in range(0i32, h) {\n+        for y in range(0i32, h) {\n             let y = y as f64;\n-            foreach x in range(0i32, w) {\n+            for x in range(0i32, w) {\n                 let mut Zr = 0f64;\n                 let mut Zi = 0f64;\n                 let mut Tr = 0f64;\n                 let mut Ti = 0f64;\n                 let Cr = 2.0 * (x as f64) / (w as f64) - 1.5;\n                 let Ci = 2.0 * (y as f64) / (h as f64) - 1.0;\n \n-                foreach _ in range(0i32, ITER as i32) {\n+                for _ in range(0i32, ITER as i32) {\n                     if Tr + Ti > LIMIT * LIMIT {\n                         break;\n                     }"}, {"sha": "99bd7c0f7867273873363141d474cfa6598b718a", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -80,8 +80,8 @@ struct Planet {\n fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n     let mut d = [ 0.0, ..3 ];\n     do (steps as uint).times {\n-        foreach i in range(0u, N_BODIES) {\n-            foreach j in range(i + 1, N_BODIES) {\n+        for i in range(0u, N_BODIES) {\n+            for j in range(i + 1, N_BODIES) {\n                 d[0] = bodies[i].x[0] - bodies[j].x[0];\n                 d[1] = bodies[i].x[1] - bodies[j].x[1];\n                 d[2] = bodies[i].x[2] - bodies[j].x[2];\n@@ -101,7 +101,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n             }\n         }\n \n-        foreach a in bodies.mut_iter() {\n+        for a in bodies.mut_iter() {\n             a.x[0] += dt * a.v[0];\n             a.x[1] += dt * a.v[1];\n             a.x[2] += dt * a.v[2];\n@@ -112,13 +112,13 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n     let mut e = 0.0;\n     let mut d = [ 0.0, ..3 ];\n-    foreach i in range(0u, N_BODIES) {\n-        foreach k in range(0u, 3) {\n+    for i in range(0u, N_BODIES) {\n+        for k in range(0u, 3) {\n             e += bodies[i].mass * bodies[i].v[k] * bodies[i].v[k] / 2.0;\n         }\n \n-        foreach j in range(i + 1, N_BODIES) {\n-            foreach k in range(0u, 3) {\n+        for j in range(i + 1, N_BODIES) {\n+            for k in range(0u, 3) {\n                 d[k] = bodies[i].x[k] - bodies[j].x[k];\n             }\n             let dist = (d[0]*d[0] + d[1]*d[1] + d[2]*d[2]).sqrt();\n@@ -129,8 +129,8 @@ fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n }\n \n fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n-    foreach i in range(0u, N_BODIES) {\n-        foreach k in range(0u, 3) {\n+    for i in range(0u, N_BODIES) {\n+        for k in range(0u, 3) {\n             bodies[0].v[k] -= bodies[i].v[k] * bodies[i].mass / SOLAR_MASS;\n         }\n     }"}, {"sha": "663ebcac3340acaeeb7b3f8909e6cdb47b0fe8ab", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -83,14 +83,14 @@ fn stress_task(id: int) {\n \n fn stress(num_tasks: int) {\n     let mut results = ~[];\n-    foreach i in range(0, num_tasks) {\n+    for i in range(0, num_tasks) {\n         let mut builder = task::task();\n         builder.future_result(|r| results.push(r));\n         do builder.spawn {\n             stress_task(i);\n         }\n     }\n-    foreach r in results.iter() {\n+    for r in results.iter() {\n         r.recv();\n     }\n }\n@@ -116,8 +116,8 @@ fn main() {\n \n         let out = io::stdout();\n \n-        foreach n in range(1, max + 1) {\n-            foreach _ in range(0, num_trials) {\n+        for n in range(1, max + 1) {\n+            for _ in range(0, num_trials) {\n                 let start = time::precise_time_ns();\n                 let fibn = fib(n);\n                 let stop = time::precise_time_ns();"}, {"sha": "e3c3c19c33bb38abc247d728db1e30b2c8655871", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,26 +19,26 @@ fn A(i: i32, j: i32) -> i32 {\n \n fn dot(v: &[f64], u: &[f64]) -> f64 {\n     let mut sum = 0.0;\n-    foreach (i, &v_i) in v.iter().enumerate() {\n+    for (i, &v_i) in v.iter().enumerate() {\n         sum += v_i * u[i];\n     }\n     sum\n }\n \n fn mult_Av(v: &mut [f64], out: &mut [f64]) {\n-    foreach (i, out_i) in out.mut_iter().enumerate() {\n+    for (i, out_i) in out.mut_iter().enumerate() {\n         let mut sum = 0.0;\n-        foreach (j, &v_j) in v.mut_iter().enumerate() {\n+        for (j, &v_j) in v.mut_iter().enumerate() {\n             sum += v_j / (A(i as i32, j as i32) as f64);\n         }\n         *out_i = sum;\n     }\n }\n \n fn mult_Atv(v: &mut [f64], out: &mut [f64]) {\n-    foreach (i, out_i) in out.mut_iter().enumerate() {\n+    for (i, out_i) in out.mut_iter().enumerate() {\n         let mut sum = 0.0;\n-        foreach (j, &v_j) in v.mut_iter().enumerate() {\n+        for (j, &v_j) in v.mut_iter().enumerate() {\n             sum += v_j / (A(j as i32, i as i32) as f64);\n         }\n         *out_i = sum;"}, {"sha": "2c2073eafea6275732530164561f4a74aaef705e", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,13 +19,13 @@ use std::os;\n use std::uint;\n \n fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n-    foreach i in range(min, max) {\n+    for i in range(min, max) {\n         map.insert(i, i + 22u);\n     }\n }\n \n fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n-    foreach i in range(min, max) {\n+    for i in range(min, max) {\n         assert_eq!(*map.get(&i), i + 22u);\n     }\n }\n@@ -45,7 +45,7 @@ fn main() {\n     let mut checkf = 0.0;\n     let mut appendf = 0.0;\n \n-    foreach _ in range(0u, rep) {\n+    for _ in range(0u, rep) {\n         let mut map = SmallIntMap::new();\n         let start = extra::time::precise_time_s();\n         append_sequential(0u, max, &mut map);"}, {"sha": "49b2c32ed686717de8985ee9d8a96c56fd8fea25", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -56,8 +56,8 @@ impl Sudoku {\n     }\n \n     pub fn equal(&self, other: &Sudoku) -> bool {\n-        foreach row in range(0u8, 9u8) {\n-            foreach col in range(0u8, 9u8) {\n+        for row in range(0u8, 9u8) {\n+            for col in range(0u8, 9u8) {\n                 if self.grid[row][col] != other.grid[row][col] {\n                     return false;\n                 }\n@@ -87,9 +87,9 @@ impl Sudoku {\n     }\n \n     pub fn write(&self, writer: @io::Writer) {\n-        foreach row in range(0u8, 9u8) {\n+        for row in range(0u8, 9u8) {\n             writer.write_str(fmt!(\"%u\", self.grid[row][0] as uint));\n-            foreach col in range(1u8, 9u8) {\n+            for col in range(1u8, 9u8) {\n                 writer.write_str(fmt!(\" %u\", self.grid[row][col] as uint));\n             }\n             writer.write_char('\\n');\n@@ -99,8 +99,8 @@ impl Sudoku {\n     // solve sudoku grid\n     pub fn solve(&mut self) {\n         let mut work: ~[(u8, u8)] = ~[]; /* queue of uncolored fields */\n-        foreach row in range(0u8, 9u8) {\n-            foreach col in range(0u8, 9u8) {\n+        for row in range(0u8, 9u8) {\n+            for col in range(0u8, 9u8) {\n                 let color = self.grid[row][col];\n                 if color == 0u8 {\n                     work.push((row, col));\n@@ -143,16 +143,16 @@ impl Sudoku {\n \n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n-        foreach idx in range(0u8, 9u8) {\n+        for idx in range(0u8, 9u8) {\n             avail.remove(self.grid[idx][col]); /* check same column fields */\n             avail.remove(self.grid[row][idx]); /* check same row fields */\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n-        foreach alt_row in range(row0, row0 + 3u8) {\n-            foreach alt_col in range(col0, col0 + 3u8) {\n+        for alt_row in range(row0, row0 + 3u8) {\n+            for alt_col in range(col0, col0 + 3u8) {\n                 avail.remove(self.grid[alt_row][alt_col]);\n             }\n         }"}, {"sha": "e507f0e9e5b92c01dc2ef6ab8d7c3b1be74a7edf", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -16,7 +16,7 @@ struct Foo {\n \n impl Foo {\n     pub fn foo(&mut self, fun: &fn(&int)) {\n-        foreach f in self.n.iter() {\n+        for f in self.n.iter() {\n             fun(f);\n         }\n     }"}, {"sha": "1a8fa50c76eee715be75bb0bb23bbc89c799fde6", "filename": "src/test/compile-fail/borrowck-mut-boxed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let v = @mut [ 1, 2, 3 ];\n-    foreach _x in v.iter() {\n+    for _x in v.iter() {\n         v[1] = 4; //~ ERROR cannot assign\n     }\n }"}, {"sha": "dcb85d86706327cfb8fc1b7bf4348ca522e36e7c", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -15,7 +15,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(A) -> ~[B]) {\n         let mut r = fail!();\n-        foreach elt in self.iter() { r = r + f(*elt); }\n+        for elt in self.iter() { r = r + f(*elt); }\n         //~^ WARNING unreachable expression\n         //~^^ ERROR the type of this value must be known\n    }"}, {"sha": "64344ab4277939605bdaea6b4c13063dab6fa0fd", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -14,7 +14,7 @@\n fn fail_len(v: ~[int]) -> uint {\n     let mut i = 3;\n     fail!();\n-    foreach x in v.iter() { i += 1u; }\n+    for x in v.iter() { i += 1u; }\n     //~^ ERROR: unreachable statement\n     return i;\n }"}, {"sha": "1ef67f784e386ed5edf1ce29ea50c01422072e9a", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -37,7 +37,7 @@ fn main() {\n              ('c', 'd'),\n              ('e', 'f')];\n \n-    foreach &(x,y) in v.iter() {} // should be OK\n+    for &(x,y) in v.iter() {} // should be OK\n \n     // Make sure none of the errors above were fatal\n     let x: char = true; //~ ERROR expected `char` but found `bool`"}, {"sha": "19c786b553f602fe86dc2f4814bba930176358f4", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let mut xs = ~[1, 2, 3, 4];\n \n-    foreach x in xs.mut_iter() {\n+    for x in xs.mut_iter() {\n         xs.push(1) //~ ERROR cannot borrow `xs` as mutable\n     }\n }"}, {"sha": "805aca129e9997bc2f8b6109587fb71b0c6ac9a8", "filename": "src/test/pretty/block-comment-wchar.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -108,7 +108,7 @@\n          '\\xA0', '\\u1680', '\\u180E', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n-    foreach c in chars.iter() {\n+    for c in chars.iter() {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\" , c , ws));\n     }"}, {"sha": "f09a7c1428c95fb0336e739787af8f5b4f1d1c33", "filename": "src/test/pretty/block-comment-wchar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -102,7 +102,7 @@ fn main() {\n          '\\xA0', '\\u1680', '\\u180E', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n-    foreach c in chars.iter() {\n+    for c in chars.iter() {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\", c , ws));\n     }"}, {"sha": "6b4e6a30d87f447ff4a61b6868146ec65a516e37", "filename": "src/test/pretty/for-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fpretty%2Ffor-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Fpretty%2Ffor-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffor-comment.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -12,7 +12,7 @@\n \n fn f(v: &[int]) {\n     let mut n = 0;\n-    foreach e in v.iter() {\n+    for e in v.iter() {\n         n = *e; // This comment once triggered pretty printer bug\n     }\n }"}, {"sha": "3c9397fc07ff34e6ac06b26ba208c1ec251f329b", "filename": "src/test/run-fail/for-each-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,4 +11,4 @@\n // error-pattern:moop\n extern mod extra;\n \n-fn main() { foreach _ in range(0u, 10u) { fail!(\"moop\"); } }\n+fn main() { for _ in range(0u, 10u) { fail!(\"moop\"); } }"}, {"sha": "336c2d3c8ea70ce548f3067b709ecdaa72899f62", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let count = @mut 0u;\n     let mut map = std::hashmap::HashMap::new();\n     let mut arr = ~[];\n-    foreach i in range(0u, 10u) {\n+    for i in range(0u, 10u) {\n         arr.push(@~\"key stuff\");\n         map.insert(arr.clone(), arr + &[@~\"value stuff\"]);\n         if arr.len() == 5 {"}, {"sha": "33aee55b8c7387a6c461af49ecc9a04b3ec7d6e7", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,7 +11,7 @@\n pub fn main() {\n     let mut sum = 0;\n     let xs = ~[1, 2, 3, 4, 5];\n-    foreach x in xs.iter() {\n+    for x in xs.iter() {\n         sum += *x;\n     }\n     assert_eq!(sum, 15);"}, {"sha": "7b74d1d314b40c5d1c4f95dca84a02041e731407", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Statement form does not require parentheses:\n-    foreach i in v.iter() {\n+    for i in v.iter() {\n         info!(\"%?\", *i);\n     }\n "}, {"sha": "790757463c64790a52cfe86d4391321bb5a11924", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: &fn(&T)) { foreach x in v.iter() { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for x in v.iter() { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "29b693ec376955dbdd0b048c096188b31fd79ade", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: &fn(&T)) { foreach x in v.iter() { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for x in v.iter() { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "8ec1b590fdfca90e250f57bafc789acf8abd8af7", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -10,7 +10,7 @@\n \n fn sum_slice(x: &[int]) -> int {\n     let mut sum = 0;\n-    foreach i in x.iter() { sum += *i; }\n+    for i in x.iter() { sum += *i; }\n     return sum;\n }\n "}, {"sha": "1ca94d6a2219ef7685839acb50568def94ad22ff", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -10,7 +10,7 @@\n \n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    foreach i in v.iter() { sum += *i; }\n+    for i in v.iter() { sum += *i; }\n     sum\n }\n "}, {"sha": "dcf497e81f743deea5c3ec870aa34ff8af0e0381", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -4,7 +4,7 @@ struct Wizard {\n \n impl Wizard {\n     pub fn cast(&mut self) {\n-        foreach &spell in self.spells.iter() {\n+        for &spell in self.spells.iter() {\n             println(spell);\n         }\n     }"}, {"sha": "aff4b7bd26e0533b4fb4cc51bfdb4de5d4265b4a", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     loop { i += 1; if i == 20 { break; } }\n     assert_eq!(i, 20);\n     let xs = [1, 2, 3, 4, 5, 6];\n-    foreach x in xs.iter() {\n+    for x in xs.iter() {\n         if *x == 3 { break; } assert!((*x <= 3));\n     }\n     i = 0;\n@@ -28,7 +28,7 @@ pub fn main() {\n         if i >= 10 { break; }\n     }\n     let ys = ~[1, 2, 3, 4, 5, 6];\n-    foreach x in ys.iter() {\n+    for x in ys.iter() {\n         if *x % 2 == 0 { loop; }\n         assert!((*x % 2 != 0));\n     }"}, {"sha": "a5d7ba2c1aaa1bd1fee0783770f9d71d09bbc1e1", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -83,7 +83,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n fn annoy_neighbors(critter: @noisy) {\n-    foreach i in range(0u, 10) { critter.speak(); }\n+    for i in range(0u, 10) { critter.speak(); }\n }\n \n pub fn main() {"}, {"sha": "93e9eac1dd9dfb621bf1e76df52a5769d403ac30", "filename": "src/test/run-pass/class-impl-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -75,7 +75,7 @@ class cat : map<int, bool> {\n \n pub fn main() {\n   let nyan : cat = cat(0, 2, \"nyan\");\n-  foreach _ in range(1u, 5u) { nyan.speak(); }\n+  for _ in range(1u, 5u) { nyan.speak(); }\n   // cat returns true if uint input is greater than\n   // the number of meows so far\n   assert!((nyan.get(1)));"}, {"sha": "d42c57c3b81a0ed1f2b7d9cfa83494dfa53736b7", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -117,11 +117,11 @@ impl<T> cat<T> {\n \n pub fn main() {\n     let mut nyan: cat<~str> = cat::new(0, 2, ~\"nyan\");\n-    foreach _ in range(1u, 5) { nyan.speak(); }\n+    for _ in range(1u, 5) { nyan.speak(); }\n     assert!(*nyan.find(&1).unwrap() == ~\"nyan\");\n     assert_eq!(nyan.find(&10), None);\n     let mut spotty: cat<cat_type> = cat::new(2, 57, tuxedo);\n-    foreach _ in range(0u, 6) { spotty.speak(); }\n+    for _ in range(0u, 6) { spotty.speak(); }\n     assert_eq!(spotty.len(), 8);\n     assert!((spotty.contains_key(&2)));\n     assert_eq!(spotty.get(&3), &tuxedo);"}, {"sha": "d4e1d438c94428e59ee13d1af9d842eba796be8b", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -63,6 +63,6 @@ pub fn main() {\n   let mut nyan = cat(0u, 2, ~\"nyan\");\n   nyan.eat();\n   assert!((!nyan.eat()));\n-  foreach _ in range(1u, 10u) { nyan.speak(); };\n+  for _ in range(1u, 10u) { nyan.speak(); };\n   assert!((nyan.eat()));\n }"}, {"sha": "a064ce6769b823043e766342e11ad549b8ccb68c", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -68,7 +68,7 @@ pub fn main() {\n     let mut nyan = cat(0u, 2, ~\"nyan\");\n     nyan.eat();\n     assert!((!nyan.eat()));\n-    foreach _ in range(1u, 10u) {\n+    for _ in range(1u, 10u) {\n         make_speak(nyan.clone());\n     }\n }"}, {"sha": "4fccc45a75335cea0e23c96e9959cef68ecdf634", "filename": "src/test/run-pass/class-implements-multiple-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -95,7 +95,7 @@ class cat : noisy, scratchy, bitey {\n }\n \n fn annoy_neighbors<T:noisy>(critter: T) {\n-  foreach i in range(0u, 10u) {\n+  for i in range(0u, 10u) {\n       let what = critter.speak();\n       info!(\"%u %d\", i, what);\n   }"}, {"sha": "e7848f3b960e42bfee3a42d64f362ed1fa63a259", "filename": "src/test/run-pass/classes-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,6 +19,6 @@ pub fn main() {\n     let mut nyan = cat(0u, 2, ~\"nyan\");\n     nyan.eat();\n     assert!((!nyan.eat()));\n-    foreach _ in range(1u, 10u) { nyan.speak(); };\n+    for _ in range(1u, 10u) { nyan.speak(); };\n     assert!((nyan.eat()));\n }"}, {"sha": "e5220b15520a7c95c1e351cd16006db7ecb209d4", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -52,6 +52,6 @@ pub fn main() {\n   let mut nyan = cat(0u, 2, ~\"nyan\");\n   nyan.eat();\n   assert!((!nyan.eat()));\n-  foreach _ in range(1u, 10u) { nyan.speak(); };\n+  for _ in range(1u, 10u) { nyan.speak(); };\n   assert!((nyan.eat()));\n }"}, {"sha": "7fb01006844af5a7ee43b7e0c33b4865da993c51", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -1,6 +1,6 @@\n fn sum(x: &[int]) -> int {\n     let mut sum = 0;\n-    foreach y in x.iter() { sum += *y; }\n+    for y in x.iter() { sum += *y; }\n     return sum;\n }\n "}, {"sha": "6117ea962afac84b2a34d895c6c7f114b6d8013c", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -24,6 +24,6 @@ struct S<'self>(&'self fn());\n static closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {\n-    foreach &bare_fn in bare_fns.iter() { bare_fn() }\n-    foreach &closure in closures.iter() { (*closure)() }\n+    for &bare_fn in bare_fns.iter() { bare_fn() }\n+    for &closure in closures.iter() { (*closure)() }\n }"}, {"sha": "094d17c100ebd8b56e1baca12c3c5babdfbeeee0", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -25,8 +25,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let es = [e0, e11, e12, e21, e22];\n \n-    foreach (i, e1) in es.iter().enumerate() {\n-        foreach (j, e2) in es.iter().enumerate() {\n+    for (i, e1) in es.iter().enumerate() {\n+        for (j, e2) in es.iter().enumerate() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "d04bdee34e611f84e9e241afcba8fb2ed020cc61", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -21,8 +21,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let ss = [s1, s2];\n \n-    foreach (i, s1) in ss.iter().enumerate() {\n-        foreach (j, s2) in ss.iter().enumerate() {\n+    for (i, s1) in ss.iter().enumerate() {\n+        for (j, s2) in ss.iter().enumerate() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "5d4cf7c745769c62ca60eaa31cbca5f58913c192", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,8 +19,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let tss = [ts1, ts2];\n \n-    foreach (i, ts1) in tss.iter().enumerate() {\n-        foreach (j, ts2) in tss.iter().enumerate() {\n+    for (i, ts1) in tss.iter().enumerate() {\n+        for (j, ts2) in tss.iter().enumerate() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "ce662bafd4957004a8fbf2a0f704d228a4d05c47", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -16,10 +16,10 @@ struct Box {\n \n impl Box {\n     pub fn set_many(&mut self, xs: &[uint]) {\n-        foreach x in xs.iter() { self.x = *x; }\n+        for x in xs.iter() { self.x = *x; }\n     }\n     pub fn set_many2(@mut self, xs: &[uint]) {\n-        foreach x in xs.iter() { self.x = *x; }\n+        for x in xs.iter() { self.x = *x; }\n     }\n }\n "}, {"sha": "8102673586b4461b7561c44a43f6ca736a85baf6", "filename": "src/test/run-pass/fn-pattern-expected-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v : &[(int,int)] = &[ (1, 2), (3, 4), (5, 6) ];\n-    foreach &(x, y) in v.iter() {\n+    for &(x, y) in v.iter() {\n         println(y.to_str());\n         println(x.to_str());\n     }"}, {"sha": "ff718500340c8ebb1136eaf84d51ff199a0a49e4", "filename": "src/test/run-pass/for-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let x: ~[int] = ~[]; foreach _ in x.iter() { fail!(\"moop\"); } }\n+pub fn main() { let x: ~[int] = ~[]; for _ in x.iter() { fail!(\"moop\"); } }"}, {"sha": "f5e7d91c22520898488cbfa50fcc32a10d12d4f4", "filename": "src/test/run-pass/foreach-external-iterators-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-break.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let x = [1,..100];\n     let mut y = 0;\n-    foreach i in x.iter() {\n+    for i in x.iter() {\n         if y > 10 {\n             break;\n         }"}, {"sha": "17c5bb5c0e253e84e290b2a4e55dd1470764c523", "filename": "src/test/run-pass/foreach-external-iterators-hashmap-break-restart.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -17,21 +17,21 @@ use std::hashmap::HashMap;\n fn main() {\n     let mut h = HashMap::new();\n     let kvs = [(1, 10), (2, 20), (3, 30)];\n-    foreach &(k,v) in kvs.iter() {\n+    for &(k,v) in kvs.iter() {\n         h.insert(k,v);\n     }\n     let mut x = 0;\n     let mut y = 0;\n \n     let mut i = h.iter();\n \n-    foreach (&k,&v) in i {\n+    for (&k,&v) in i {\n         x += k;\n         y += v;\n         break;\n     }\n \n-    foreach (&k,&v) in i {\n+    for (&k,&v) in i {\n         x += k;\n         y += v;\n     }"}, {"sha": "908adc0d7620d3478949b5ce38a868fc232a4140", "filename": "src/test/run-pass/foreach-external-iterators-hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -13,12 +13,12 @@ use std::hashmap::HashMap;\n fn main() {\n     let mut h = HashMap::new();\n     let kvs = [(1, 10), (2, 20), (3, 30)];\n-    foreach &(k,v) in kvs.iter() {\n+    for &(k,v) in kvs.iter() {\n         h.insert(k,v);\n     }\n     let mut x = 0;\n     let mut y = 0;\n-    foreach (&k,&v) in h.iter() {\n+    for (&k,&v) in h.iter() {\n         x += k;\n         y += v;\n     }"}, {"sha": "c999d810ec6ba54eb26e54ef41e1533825d640b2", "filename": "src/test/run-pass/foreach-external-iterators-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-loop.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let x = [1,..100];\n     let mut y = 0;\n-    foreach (n,i) in x.iter().enumerate() {\n+    for (n,i) in x.iter().enumerate() {\n         if n < 10 {\n             loop;\n         }"}, {"sha": "904c90dc815d1ef7465d01a2e8c8b89769acb303", "filename": "src/test/run-pass/foreach-external-iterators-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-nested.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -13,8 +13,8 @@ fn main() {\n     let y = [2,..100];\n     let mut p = 0;\n     let mut q = 0;\n-    foreach i in x.iter() {\n-        foreach j in y.iter() {\n+    for i in x.iter() {\n+        for j in y.iter() {\n             p += *j;\n         }\n         q += *i + p;"}, {"sha": "c6f903821dd0ef9b3bedbeedc73df2ce8cde74ea", "filename": "src/test/run-pass/foreach-external-iterators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fforeach-external-iterators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let x = [1,..100];\n     let mut y = 0;\n-    foreach i in x.iter() {\n+    for i in x.iter() {\n         y += *i\n     }\n     assert!(y == 100);"}, {"sha": "4945a25967a0945f927fd816e4a368aaf94eec1e", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -15,7 +15,7 @@ trait vec_utils<T> {\n impl<T> vec_utils<T> for ~[T] {\n     fn map_<U>(x: &~[T], f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        foreach elt in x.iter() {\n+        for elt in x.iter() {\n             r.push(f(elt));\n         }\n         r"}, {"sha": "a7b376f4aea351afc05cb427ac3a174df157b5a5", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -31,7 +31,7 @@ mod map_reduce {\n     enum ctrl_proto { find_reducer(~[u8], Chan<int>), mapper_done, }\n \n     fn start_mappers(ctrl: SharedChan<ctrl_proto>, inputs: ~[~str]) {\n-        foreach i in inputs.iter() {\n+        for i in inputs.iter() {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n             task::spawn(|| map_task(ctrl.clone(), i.clone()) );"}, {"sha": "3f86114796347ab752327cae3689f5ed692a77e8", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -67,14 +67,14 @@ fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n     let mut grid = ~[];\n     do input.each_line |line| {\n         let mut row = ~[];\n-        foreach c in line.iter() {\n+        for c in line.iter() {\n             row.push(square_from_char(c))\n         }\n         grid.push(row);\n         true\n     };\n     let width = grid[0].len();\n-    foreach row in grid.iter() { assert!(row.len() == width) }\n+    for row in grid.iter() { assert!(row.len() == width) }\n     grid\n }\n "}, {"sha": "f2ecd0413bd1c614955d88b76f7dc1281dbc63b6", "filename": "src/test/run-pass/issue-2989.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2989.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -40,7 +40,7 @@ pub fn main() {\n     let bools = ~[false, false, true, false, false, true, true, false];\n     let bools2 = to_bools(Storage{storage: ~[0b01100100]});\n \n-    foreach i in range(0u, 8) {\n+    for i in range(0u, 8) {\n         printfln!(\"%u => %u vs %u\", i, bools[i] as uint, bools2[i] as uint);\n     }\n "}, {"sha": "5bb88df4662ba515c6e1f1ef86f2183b87016121", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -14,7 +14,7 @@ struct trie_node {\n }\n \n fn print_str_vector(vector: ~[~str]) {\n-    foreach string in vector.iter() {\n+    for string in vector.iter() {\n         println(*string);\n     }\n }"}, {"sha": "e688b95f873486177d30465bc74045dc929be1f2", "filename": "src/test/run-pass/issue-3563-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,7 +11,7 @@\n trait Canvas {\n     fn add_point(&self, point: &int);\n     fn add_points(&self, shapes: &[int]) {\n-        foreach pt in shapes.iter() {\n+        for pt in shapes.iter() {\n             self.add_point(pt)\n         }\n     }"}, {"sha": "69cc7851cd9e0d93e0d530934a5f823008ee0bf3", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -120,7 +120,7 @@ trait Canvas {\n     // Unlike interfaces traits support default implementations.\n     // Got an ICE as soon as I added this method.\n     fn add_points(&mut self, shapes: &[Point]) {\n-        foreach pt in shapes.iter() {self.add_point(*pt)};\n+        for pt in shapes.iter() {self.add_point(*pt)};\n     }\n }\n \n@@ -134,13 +134,13 @@ impl Canvas for AsciiArt {\n \n     fn add_rect(&mut self, shape: Rect) {\n         // Add the top and bottom lines.\n-        foreach x in range(shape.top_left.x, shape.top_left.x + shape.size.width) {\n+        for x in range(shape.top_left.x, shape.top_left.x + shape.size.width) {\n             self.add_pt(x, shape.top_left.y);\n             self.add_pt(x, shape.top_left.y + shape.size.height - 1);\n         }\n \n         // Add the left and right lines.\n-        foreach y in range(shape.top_left.y, shape.top_left.y + shape.size.height) {\n+        for y in range(shape.top_left.y, shape.top_left.y + shape.size.height) {\n             self.add_pt(shape.top_left.x, y);\n             self.add_pt(shape.top_left.x + shape.size.width - 1, y);\n         }"}, {"sha": "49f70b28e9a83d219072f9d65e96c542f4423f6d", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -17,7 +17,7 @@ fn foo(name: ~str, samples_chan: Chan<Msg>) {\n         let callback: SamplesFn =\n             |buffer|\n             {\n-                foreach i in range(0u, buffer.len()) {\n+                for i in range(0u, buffer.len()) {\n                     error!(\"%?: %f\", i, buffer[i])\n                 }\n             };"}, {"sha": "e0f216c667cbc07e52e7b74505b5b116b5adb767", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -102,7 +102,7 @@ priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n   let mut res = ~\"*\";\n   res.push_str(cmd.len().to_str());\n   res.push_str(\"\\r\\n\");\n-    foreach s in cmd.iter() {\n+    for s in cmd.iter() {\n     res.push_str([~\"$\", s.len().to_str(), ~\"\\r\\n\",\n                   (*s).clone(), ~\"\\r\\n\"].concat() );\n     }"}, {"sha": "f12aa6c3356cac5c9e0beb4402d5ef4edbe15efb", "filename": "src/test/run-pass/issue-4542.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-4542.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fissue-4542.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4542.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -12,7 +12,7 @@ use std::os;\n \n pub fn main() {\n     let x = os::args();\n-    foreach arg in x.iter() {\n+    for arg in x.iter() {\n         match arg.clone() {\n             s => { }\n         }"}, {"sha": "01ee4e2063855866c9deacc48074e6e72aa7fd31", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,12 +11,12 @@\n pub fn main() {\n     let x = ~[1, 2, 3];\n     let mut y = 0;\n-    foreach i in x.iter() { info!(*i); y += *i; }\n+    for i in x.iter() { info!(*i); y += *i; }\n     info!(y);\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";\n     let mut i: int = 0;\n-    foreach c in s.byte_iter() {\n+    for c in s.byte_iter() {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "436bdf256ca422b7928cc3d584fb895bfef86404", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -11,6 +11,6 @@\n pub fn main() {\n     let x = ~[10, 20, 30];\n     let mut sum = 0;\n-    foreach x in x.iter() { sum += *x; }\n+    for x in x.iter() { sum += *x; }\n     assert_eq!(sum, 60);\n }"}, {"sha": "cec0a7a756c9fee8bfc77db20ba8a9cd3369fbab", "filename": "src/test/run-pass/lots-a-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flots-a-fail.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -22,7 +22,7 @@ fn iloop() {\n }\n \n pub fn main() {\n-    foreach _ in range(0u, 100u) {\n+    for _ in range(0u, 100u) {\n         task::spawn_unlinked(|| iloop() );\n     }\n }"}, {"sha": "eeac89f49669a3eff1c5f50b1b691415297822ca", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -19,7 +19,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(&A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n-        foreach elt in self.iter() {\n+        for elt in self.iter() {\n             r.push_all_move(f(elt));\n         }\n         r"}, {"sha": "45473193de93ee0ae851798edb83398a826d1758", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -67,7 +67,7 @@ pub fn main() {\n         calllink10\n     ];\n     let mut rng = rand::rng();\n-    foreach f in fns.iter() {\n+    for f in fns.iter() {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;"}, {"sha": "46308e02e78585fe5a11a33b148087d139b1d13c", "filename": "src/test/run-pass/move-3-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -26,7 +26,7 @@ fn test(x: bool, foo: ~Triple) -> int {\n \n pub fn main() {\n     let x = ~Triple{x: 1, y: 2, z: 3};\n-    foreach _ in range(0u, 10000u) {\n+    for _ in range(0u, 10000u) {\n         assert_eq!(test(true, x.clone()), 2);\n     }\n     assert_eq!(test(false, x), 5);"}, {"sha": "dbc7886adc99359fb6dadf474beaaa95173796c5", "filename": "src/test/run-pass/move-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmove-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmove-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -21,7 +21,7 @@ fn test(x: bool, foo: @Triple) -> int {\n \n pub fn main() {\n     let x = @Triple{x: 1, y: 2, z: 3};\n-    foreach i in range(0u, 10000u) {\n+    for i in range(0u, 10000u) {\n         assert_eq!(test(true, x), 2);\n     }\n     assert_eq!(test(false, x), 5);"}, {"sha": "855c77e92cf515d60c3753ebeeeb0d62b1acd2fd", "filename": "src/test/run-pass/mutability-inherits-through-fixed-length-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -16,8 +16,8 @@ fn test1() {\n \n fn test2() {\n     let mut ints = [0, ..32];\n-    foreach i in ints.mut_iter() { *i += 22; }\n-    foreach i in ints.iter() { assert!(*i == 22); }\n+    for i in ints.mut_iter() { *i += 22; }\n+    for i in ints.iter() { assert!(*i == 22); }\n }\n \n pub fn main() {"}, {"sha": "0f83a8e730e8590273c2272765b5d0a6d7115f92", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -31,7 +31,7 @@ impl<K,V> AssociationList<K,V> {\n \n impl<K:Eq,V:Clone> Index<K,V> for AssociationList<K,V> {\n     fn index(&self, index: &K) -> V {\n-        foreach pair in self.pairs.iter() {\n+        for pair in self.pairs.iter() {\n             if pair.key == *index {\n                 return pair.value.clone();\n             }"}, {"sha": "c9d0fde6d3c2f83d698c75c5750908981cfa339d", "filename": "src/test/run-pass/owned-trait-objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fowned-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fowned-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fowned-trait-objects.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -29,7 +29,7 @@ pub fn main() {\n         ~BarStruct{ x: 2 } as ~FooTrait\n     ];\n \n-    foreach i in range(0u, foos.len()) {\n+    for i in range(0u, foos.len()) {\n         assert_eq!(i, foos[i].foo());\n     }\n }"}, {"sha": "930ef17dbf5f4f2934c3dea4f3be26cd77bf846d", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -22,11 +22,11 @@ fn main() {\n \n     assert_eq!(sys::size_of::<[Foo, .. 10]>(), 90);\n \n-    foreach i in range(0u, 10) {\n+    for i in range(0u, 10) {\n         assert_eq!(foos[i], Foo { bar: 1, baz: 2});\n     }\n \n-    foreach &foo in foos.iter() {\n+    for &foo in foos.iter() {\n         assert_eq!(foo, Foo { bar: 1, baz: 2 });\n     }\n }"}, {"sha": "d3ae339acf27986ea6ff4a19b6b7f75de405e81a", "filename": "src/test/run-pass/pattern-bound-var-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -16,7 +16,7 @@ fn foo(src: uint) {\n \n     match Some(src) {\n       Some(src_id) => {\n-        foreach i in range(0u, 10u) {\n+        for i in range(0u, 10u) {\n             let yyy = src_id;\n             assert_eq!(yyy, 0u);\n         }"}, {"sha": "8b2b5bfa00bfd2da61c2aad19a1e51194e1057ca", "filename": "src/test/run-pass/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -22,7 +22,7 @@ impl cat {\n }\n \n impl cat {\n-    fn nap(&mut self) { foreach _ in range(1u, 10u) { } }\n+    fn nap(&mut self) { for _ in range(1u, 10u) { } }\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "2a91d1fc8b5ca96523474eabe9787a064265cc53", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -666,7 +666,7 @@ pub fn main() {\n         visit_tydesc(td, v);\n \n         let r = u.vals.clone();\n-        foreach s in r.iter() {\n+        for s in r.iter() {\n             printfln!(\"val: %s\", *s);\n         }\n         error!(\"%?\", u.vals.clone());"}, {"sha": "3ea597e0d59e37defe96a079d009f53e4313a960", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -170,7 +170,7 @@ pub fn main() {\n     visit_ty::<i16>(vv);\n     visit_ty::<~[int]>(vv);\n \n-    foreach s in v.types.iter() {\n+    for s in v.types.iter() {\n         printfln!(\"type: %s\", (*s).clone());\n     }\n     assert_eq!((*v.types).clone(), ~[~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"]);"}, {"sha": "6284130de177c633dfe1b66b0672f89bde1f4fe9", "filename": "src/test/run-pass/regions-infer-borrow-scope-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -13,7 +13,7 @@ use std::util;\n pub fn main() {\n     let mut x = 4;\n \n-    foreach i in range(0u, 3) {\n+    for i in range(0u, 3) {\n         // ensure that the borrow in this alt\n         // does not inferfere with the swap\n         // below.  note that it would it you"}, {"sha": "e27f35d1851d52c743dab38ba5d78240113a62fb", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -33,7 +33,7 @@ fn iloop() {\n }\n \n pub fn main() {\n-    foreach _ in range(0u, 16u) {\n+    for _ in range(0u, 16u) {\n         task::spawn_unlinked(|| iloop() );\n     }\n }"}, {"sha": "5109f3c92f1f2af5b9aa40ec4e7ad54a1691616d", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -16,7 +16,7 @@ fn foo(c: ~[int]) {\n \n     match none::<int> {\n         some::<int>(_) => {\n-            foreach i in c.iter() {\n+            for i in c.iter() {\n                 info!(a);\n                 let a = 17;\n                 b.push(a);"}, {"sha": "057bc57269d19bea8e54668d67dc5571aeb6ad93", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -26,7 +26,7 @@ pub fn main() {\n         match io::file_writer(&path, [io::Create, io::Truncate]) {\n             Err(ref e) => fail!(e.clone()),\n             Ok(f) => {\n-                foreach _ in range(0u, 1000) {\n+                for _ in range(0u, 1000) {\n                     f.write_u8(0);\n                 }\n             }"}, {"sha": "457c5a3352d124aef89396c8739c51bc277f4993", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -48,10 +48,10 @@ trait vec_utils<T> {\n \n impl<T> vec_utils<T> for ~[T] {\n     fn length_(&self) -> uint { self.len() }\n-    fn iter_(&self, f: &fn(&T)) { foreach x in self.iter() { f(x); } }\n+    fn iter_(&self, f: &fn(&T)) { for x in self.iter() { f(x); } }\n     fn map_<U>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        foreach elt in self.iter() {\n+        for elt in self.iter() {\n             r.push(f(elt));\n         }\n         r"}, {"sha": "b9083f289725d266de6333d6576dd3084064ac5d", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -55,7 +55,7 @@ fn test00() {\n \n     // Read from spawned tasks...\n     let mut sum = 0;\n-    foreach r in results.iter() {\n+    for r in results.iter() {\n         i = 0;\n         while i < number_of_messages {\n             let value = po.recv();\n@@ -65,7 +65,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    foreach r in results.iter() { r.recv(); }\n+    for r in results.iter() { r.recv(); }\n \n     info!(\"Completed: Final number is: \");\n     error!(sum);"}, {"sha": "1360b76653c5d01794ab38773d901ecbdec5ed46", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -84,20 +84,20 @@ fn main() {\n \n fn check_legs(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n     let mut legs = 0;\n-    foreach pet in arc.get().iter() {\n+    for pet in arc.get().iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n fn check_names(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n-    foreach pet in arc.get().iter() {\n+    for pet in arc.get().iter() {\n         do pet.name |name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         }\n     }\n }\n fn check_pedigree(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n-    foreach pet in arc.get().iter() {\n+    for pet in arc.get().iter() {\n         assert!(pet.of_good_pedigree());\n     }\n }"}, {"sha": "47d9665217c2100044f0c8f2371745ea79655776", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -32,7 +32,7 @@ impl<T> map<T> for ~[T] {\n     fn map<U>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n         // FIXME: #7355 generates bad code with VecIterator\n-        foreach i in range(0u, self.len()) {\n+        for i in range(0u, self.len()) {\n             r.push(f(&self[i]));\n         }\n         r"}, {"sha": "2471aee3c21ebd41f80f50a5843f67a8ce79f3b9", "filename": "src/test/run-pass/unfoldr-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -26,7 +26,7 @@ fn main() {\n \n     let mut it = Unfoldr::new(0, count);\n     let mut i = 0;\n-    foreach counted in it {\n+    for counted in it {\n         assert_eq!(counted, i);\n         i += 1;\n     }"}, {"sha": "9face041eb24030f35d4a52511835317bc1b8ef8", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -20,14 +20,14 @@ pub fn main() {\n     let ch = SharedChan::new(ch);\n     let n = 100u;\n     let mut expected = 0u;\n-    foreach i in range(0u, n) {\n+    for i in range(0u, n) {\n         let ch = ch.clone();\n         task::spawn(|| child(&ch, i) );\n         expected += i;\n     }\n \n     let mut actual = 0u;\n-    foreach _ in range(0u, n) {\n+    for _ in range(0u, n) {\n         let j = p.recv();\n         actual += *j;\n     }"}, {"sha": "0eb3fd75dc3dab6430959cdd382ea2a6895a1393", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10089455287dcc3652b984ab4bfd6971e1b5f302/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=10089455287dcc3652b984ab4bfd6971e1b5f302", "patch": "@@ -41,7 +41,7 @@ pub fn main() {\n \n     fn check_str_eq(a: ~str, b: ~str) {\n         let mut i: int = 0;\n-        foreach ab in a.byte_iter() {\n+        for ab in a.byte_iter() {\n             info!(i);\n             info!(ab);\n             let bb: u8 = b[i];"}]}