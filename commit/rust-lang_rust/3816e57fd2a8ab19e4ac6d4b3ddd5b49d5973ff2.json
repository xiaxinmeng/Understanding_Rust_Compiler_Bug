{"sha": "3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MTZlNTdmZDJhOGFiMTllNGFjNmQ0YjNkZGQ1YjQ5ZDU5NzNmZjI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T15:24:54Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T19:30:44Z"}, "message": "Downcase std modules again, move to :: for module dereferencing\n\nThis should be a snapshot transition.", "tree": {"sha": "508982ed2f789aedd89eebd529343d9dc88b8e01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/508982ed2f789aedd89eebd529343d9dc88b8e01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "html_url": "https://github.com/rust-lang/rust/commit/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1d3364487eb647f2d7fcb412a260c960e38c73e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d3364487eb647f2d7fcb412a260c960e38c73e", "html_url": "https://github.com/rust-lang/rust/commit/b1d3364487eb647f2d7fcb412a260c960e38c73e"}], "stats": {"total": 15339, "additions": 7687, "deletions": 7652}, "files": [{"sha": "50b07915b604ad00a3d30f3638864cb03ab56cbe", "filename": "src/comp/back/Link.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2FLink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2FLink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2FLink.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,16 +1,16 @@\n-import driver.session;\n-import lib.llvm.llvm;\n-import middle.trans;\n-import std.Str;\n-import std.FS;\n-\n-import lib.llvm.llvm.ModuleRef;\n-import lib.llvm.llvm.ValueRef;\n-import lib.llvm.mk_pass_manager;\n-import lib.llvm.mk_target_data;\n-import lib.llvm.mk_type_names;\n-import lib.llvm.False;\n-import lib.llvm.True;\n+import driver::session;\n+import lib::llvm::llvm;\n+import middle::trans;\n+import std::_str;\n+import std::fs;\n+\n+import lib::llvm::llvm::ModuleRef;\n+import lib::llvm::llvm::ValueRef;\n+import lib::llvm::mk_pass_manager;\n+import lib::llvm::mk_target_data;\n+import lib::llvm::mk_type_names;\n+import lib::llvm::False;\n+import lib::llvm::True;\n \n tag output_type {\n     output_type_none;\n@@ -19,32 +19,32 @@ tag output_type {\n     output_type_object;\n }\n \n-fn llvm_err(session.session sess, str msg) {\n-    auto buf = llvm.LLVMRustGetLastError();\n+fn llvm_err(session::session sess, str msg) {\n+    auto buf = llvm::LLVMRustGetLastError();\n     if ((buf as uint) == 0u) {\n         sess.err(msg);\n     } else {\n-        sess.err(msg + \": \" + Str.str_from_cstr(buf));\n+        sess.err(msg + \": \" + _str::str_from_cstr(buf));\n     }\n     fail;\n }\n \n-fn link_intrinsics(session.session sess, ModuleRef llmod) {\n-    auto path = FS.connect(sess.get_opts().sysroot, \"intrinsics.bc\");\n+fn link_intrinsics(session::session sess, ModuleRef llmod) {\n+    auto path = fs::connect(sess.get_opts().sysroot, \"intrinsics.bc\");\n     auto membuf =\n-        llvm.LLVMRustCreateMemoryBufferWithContentsOfFile(Str.buf(path));\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(_str::buf(path));\n     if ((membuf as uint) == 0u) {\n         llvm_err(sess, \"installation problem: couldn't open intrinstics.bc\");\n         fail;\n     }\n \n-    auto llintrinsicsmod = llvm.LLVMRustParseBitcode(membuf);\n+    auto llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n     if ((llintrinsicsmod as uint) == 0u) {\n         llvm_err(sess, \"installation problem: couldn't parse intrinstics.bc\");\n         fail;\n     }\n \n-    if (llvm.LLVMLinkModules(llmod, llintrinsicsmod) == False) {\n+    if (llvm::LLVMLinkModules(llmod, llintrinsicsmod) == False) {\n         llvm_err(sess, \"couldn't link the module with the intrinsics\");\n         fail;\n     }\n@@ -64,29 +64,29 @@ mod Write {\n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n     fn mk_intermediate_name(str output_path, str extension) -> str {\n-        auto dot_pos = Str.index(output_path, '.' as u8);\n+        auto dot_pos = _str::index(output_path, '.' as u8);\n         auto stem;\n         if (dot_pos < 0) {\n             stem = output_path;\n         } else {\n-            stem = Str.substr(output_path, 0u, dot_pos as uint);\n+            stem = _str::substr(output_path, 0u, dot_pos as uint);\n         }\n         ret stem + \".\" + extension;\n     }\n \n-    fn run_passes(session.session sess, ModuleRef llmod, str output) {\n+    fn run_passes(session::session sess, ModuleRef llmod, str output) {\n \n         auto opts = sess.get_opts();\n \n         if (opts.time_llvm_passes) {\n-          llvm.LLVMRustEnableTimePasses();\n+          llvm::LLVMRustEnableTimePasses();\n         }\n \n         link_intrinsics(sess, llmod);\n \n         auto pm = mk_pass_manager();\n-        auto td = mk_target_data(x86.get_data_layout());\n-        llvm.LLVMAddTargetData(td.lltd, pm.llpm);\n+        auto td = mk_target_data(x86::get_data_layout());\n+        llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n \n         // TODO: run the linter here also, once there are llvm-c bindings for\n         // it.\n@@ -99,13 +99,13 @@ mod Write {\n                     if (opts.optimize) {\n                         auto filename = mk_intermediate_name(output,\n                                                              \"no-opt.bc\");\n-                        llvm.LLVMWriteBitcodeToFile(llmod,\n-                                                    Str.buf(filename));\n+                        llvm::LLVMWriteBitcodeToFile(llmod,\n+                                                    _str::buf(filename));\n                     }\n                 }\n                 case (_) {\n                     auto filename = mk_intermediate_name(output, \"bc\");\n-                    llvm.LLVMWriteBitcodeToFile(llmod, Str.buf(filename));\n+                    llvm::LLVMWriteBitcodeToFile(llmod, _str::buf(filename));\n                 }\n             }\n         }\n@@ -118,13 +118,13 @@ mod Write {\n         // tool?\n         if (opts.optimize) {\n             auto fpm = mk_pass_manager();\n-            llvm.LLVMAddTargetData(td.lltd, fpm.llpm);\n-            llvm.LLVMAddStandardFunctionPasses(fpm.llpm, 2u);\n-            llvm.LLVMRunPassManager(fpm.llpm, llmod);\n+            llvm::LLVMAddTargetData(td.lltd, fpm.llpm);\n+            llvm::LLVMAddStandardFunctionPasses(fpm.llpm, 2u);\n+            llvm::LLVMRunPassManager(fpm.llpm, llmod);\n \n             // TODO: On -O3, use 275 instead of 225 for the inlining\n             // threshold.\n-            llvm.LLVMAddStandardModulePasses(pm.llpm,\n+            llvm::LLVMAddStandardModulePasses(pm.llpm,\n                                              2u,    // optimization level\n                                              False, // optimize for size\n                                              True,  // unit-at-a-time\n@@ -135,7 +135,7 @@ mod Write {\n         }\n \n         if (opts.verify) {\n-            llvm.LLVMAddVerifierPass(pm.llpm);\n+            llvm::LLVMAddVerifierPass(pm.llpm);\n         }\n \n         // TODO: Write .s if -c was specified and -save-temps was on.\n@@ -157,32 +157,32 @@ mod Write {\n                     case (_) {\n                         auto filename = mk_intermediate_name(output,\n                                                              \"opt.bc\");\n-                        llvm.LLVMRunPassManager(pm.llpm, llmod);\n-                        llvm.LLVMWriteBitcodeToFile(llmod,\n-                                                    Str.buf(filename));\n+                        llvm::LLVMRunPassManager(pm.llpm, llmod);\n+                        llvm::LLVMWriteBitcodeToFile(llmod,\n+                                                    _str::buf(filename));\n                         pm = mk_pass_manager();\n                     }\n                 }\n             }\n \n-            llvm.LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                         Str.buf(x86.get_target_triple()),\n-                                         Str.buf(output),\n+            llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n+                                         _str::buf(x86::get_target_triple()),\n+                                         _str::buf(output),\n                                          FileType);\n-            llvm.LLVMDisposeModule(llmod);\n+            llvm::LLVMDisposeModule(llmod);\n             if (opts.time_llvm_passes) {\n-              llvm.LLVMRustPrintPassTimings();\n+              llvm::LLVMRustPrintPassTimings();\n             }\n             ret;\n         }\n \n-        llvm.LLVMRunPassManager(pm.llpm, llmod);\n+        llvm::LLVMRunPassManager(pm.llpm, llmod);\n \n-        llvm.LLVMWriteBitcodeToFile(llmod, Str.buf(output));\n-        llvm.LLVMDisposeModule(llmod);\n+        llvm::LLVMWriteBitcodeToFile(llmod, _str::buf(output));\n+        llvm::LLVMDisposeModule(llmod);\n \n         if (opts.time_llvm_passes) {\n-          llvm.LLVMRustPrintPassTimings();\n+          llvm::LLVMRustPrintPassTimings();\n         }\n     }\n }"}, {"sha": "078c1f3dc5841678c445ac3f4db9f84ffcec6dd5", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@\n \n const int rc_base_field_refcnt = 0;\n \n-// FIXME: import from std.dbg when imported consts work.\n+// FIXME: import from std::dbg when imported consts work.\n const uint const_refcount = 0x7bad_face_u;\n \n const int task_field_refcnt = 0;\n@@ -97,7 +97,7 @@ fn native_glue_name(int n, native_glue_type ngt) -> str {\n         case (ngt_pure_rust)    { prefix = \"rust_native_pure_rust_\"; }\n         case (ngt_cdecl)        { prefix = \"rust_native_cdecl_\"; }\n     }\n-    ret prefix + util.common.istr(n);\n+    ret prefix + util::common::istr(n);\n }\n \n fn activate_glue_name() -> str {"}, {"sha": "c4abeec176e451f52173e9a37ff8801151f766fc", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,27 +1,27 @@\n-import middle.trans;\n+import middle::trans;\n \n-import trans.decl_cdecl_fn;\n-import trans.type_names;\n-import trans.ModuleRef;\n-import trans.TypeRef;\n-import trans.ValueRef;\n+import trans::decl_cdecl_fn;\n+import trans::type_names;\n+import trans::ModuleRef;\n+import trans::TypeRef;\n+import trans::ValueRef;\n \n-import trans.T_crate;\n-import trans.T_f32;\n-import trans.T_f64;\n-import trans.T_fn;\n-import trans.T_i8;\n-import trans.T_i32;\n-import trans.T_int;\n-import trans.T_opaque_chan_ptr;\n-import trans.T_opaque_port_ptr;\n-import trans.T_opaque_vec_ptr;\n-import trans.T_ptr;\n-import trans.T_size_t;\n-import trans.T_str;\n-import trans.T_taskptr;\n-import trans.T_tydesc;\n-import trans.T_void;\n+import trans::T_crate;\n+import trans::T_f32;\n+import trans::T_f64;\n+import trans::T_fn;\n+import trans::T_i8;\n+import trans::T_i32;\n+import trans::T_int;\n+import trans::T_opaque_chan_ptr;\n+import trans::T_opaque_port_ptr;\n+import trans::T_opaque_vec_ptr;\n+import trans::T_ptr;\n+import trans::T_size_t;\n+import trans::T_str;\n+import trans::T_taskptr;\n+import trans::T_tydesc;\n+import trans::T_void;\n \n type upcalls = rec(\n     ValueRef grow_task,\n@@ -66,13 +66,13 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n         let vec[TypeRef] arg_tys = vec(T_taskptr(tn));\n         for (TypeRef t in tys) { arg_tys += vec(t); }\n         auto fn_ty = T_fn(arg_tys, rv);\n-        ret trans.decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n+        ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n \n     auto dv = bind decl(tn, llmod, _, _, T_void());\n     auto d = bind decl(tn, llmod, _, _, _);\n \n-    // FIXME: Sigh... remove this when I fix the typechecker pushdown.\n+    // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n     let vec[TypeRef] empty_vec = vec();\n "}, {"sha": "7d578c2f8d58cf1db2e46433b4ec9b725944aa5a", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,9 +1,9 @@\n-import lib.llvm.llvm;\n-import lib.llvm.llvm.ModuleRef;\n-import std.Str;\n-import std.Vec;\n-import std.OS.target_os;\n-import util.common.istr;\n+import lib::llvm::llvm;\n+import lib::llvm::llvm::ModuleRef;\n+import std::_str;\n+import std::_vec;\n+import std::os::target_os;\n+import util::common::istr;\n \n const int wordsz = 4;\n \n@@ -55,35 +55,35 @@ fn restore_callee_saves() -> vec[str] {\n }\n \n fn load_esp_from_rust_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi.task_field_rust_sp) + \"(%ecx), %esp\");\n+    ret vec(\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%ecx), %esp\");\n }\n \n fn load_esp_from_runtime_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi.task_field_runtime_sp) + \"(%ecx), %esp\");\n+    ret vec(\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%ecx), %esp\");\n }\n \n fn store_esp_to_rust_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi.task_field_rust_sp) + \"(%ecx)\");\n+    ret vec(\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\");\n }\n \n fn store_esp_to_runtime_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%ecx)\");\n+    ret vec(\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%ecx)\");\n }\n \n fn load_esp_from_rust_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi.task_field_rust_sp) + \"(%edx), %esp\");\n+    ret vec(\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%edx), %esp\");\n }\n \n fn load_esp_from_runtime_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi.task_field_runtime_sp) + \"(%edx), %esp\");\n+    ret vec(\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%edx), %esp\");\n }\n \n fn store_esp_to_rust_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi.task_field_rust_sp) + \"(%edx)\");\n+    ret vec(\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%edx)\");\n }\n \n fn store_esp_to_runtime_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%edx)\");\n+    ret vec(\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%edx)\");\n }\n \n \n@@ -157,7 +157,7 @@ fn rust_activate_glue() -> vec[str] {\n          *      will be a no-op. Esp won't move, and the task's stack won't\n          *      grow.\n          */\n-        + vec(\"addl  $20, \" + wstr(abi.task_field_rust_sp) + \"(%ecx)\")\n+        + vec(\"addl  $20, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\")\n \n \n         /*\n@@ -209,13 +209,13 @@ fn rust_yield_glue() -> vec[str] {\n         + vec(\"ret\");\n }\n \n-fn native_glue(int n_args, abi.native_glue_type ngt) -> vec[str] {\n+fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n \n     let bool pass_task;\n     alt (ngt) {\n-        case (abi.ngt_rust)         { pass_task = true; }\n-        case (abi.ngt_pure_rust)    { pass_task = true; }\n-        case (abi.ngt_cdecl)        { pass_task = false; }\n+        case (abi::ngt_rust)         { pass_task = true; }\n+        case (abi::ngt_pure_rust)    { pass_task = true; }\n+        case (abi::ngt_cdecl)        { pass_task = false; }\n     }\n \n     /*\n@@ -241,7 +241,7 @@ fn native_glue(int n_args, abi.native_glue_type ngt) -> vec[str] {\n         }\n         auto m = vec(\"movl  \" + src_off + \"(%ebp),%eax\",\n                      \"movl  %eax,\" + dst_off + \"(%esp)\");\n-        ret Str.connect(m, \"\\n\\t\");\n+        ret _str::connect(m, \"\\n\\t\");\n     }\n \n     auto carg = bind copy_arg(pass_task, _);\n@@ -259,7 +259,7 @@ fn native_glue(int n_args, abi.native_glue_type ngt) -> vec[str] {\n         + vec(\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n               \"andl  $~0xf, %esp    # align esp down\")\n \n-        + Vec.init_fn[str](carg, (n_args) as uint)\n+        + _vec::init_fn[str](carg, (n_args) as uint)\n \n         +  vec(\"movl  %edx, %edi     # save task from edx to edi\",\n                \"call  *%ecx          # call *%ecx\",\n@@ -278,21 +278,21 @@ fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n     ret \"\\t.globl \" + sym + \"\\n\" +\n         \"\\t.balign \" + istr(align) + \"\\n\" +\n         sym + \":\\n\" +\n-        \"\\t\" + Str.connect(insns, \"\\n\\t\");\n+        \"\\t\" + _str::connect(insns, \"\\n\\t\");\n }\n \n \n-fn decl_native_glue(int align, str prefix, abi.native_glue_type ngt, uint n)\n+fn decl_native_glue(int align, str prefix, abi::native_glue_type ngt, uint n)\n         -> str {\n     let int i = n as int;\n     ret decl_glue(align, prefix,\n-                  abi.native_glue_name(i, ngt),\n+                  abi::native_glue_name(i, ngt),\n                   native_glue(i, ngt));\n }\n \n fn get_symbol_prefix() -> str {\n-    if (Str.eq(target_os(), \"macos\") ||\n-        Str.eq(target_os(), \"win32\")) {\n+    if (_str::eq(target_os(), \"macos\") ||\n+        _str::eq(target_os(), \"win32\")) {\n         ret \"_\";\n     } else {\n         ret \"\";\n@@ -306,51 +306,51 @@ fn get_module_asm() -> str {\n \n     auto glues =\n         vec(decl_glue(align, prefix,\n-                      abi.activate_glue_name(),\n+                      abi::activate_glue_name(),\n                       rust_activate_glue()),\n \n             decl_glue(align, prefix,\n-                      abi.yield_glue_name(),\n+                      abi::yield_glue_name(),\n                       rust_yield_glue()))\n \n-        + Vec.init_fn[str](bind decl_native_glue(align, prefix,\n-            abi.ngt_rust, _), (abi.n_native_glues + 1) as uint)\n-        + Vec.init_fn[str](bind decl_native_glue(align, prefix,\n-            abi.ngt_pure_rust, _), (abi.n_native_glues + 1) as uint)\n-        + Vec.init_fn[str](bind decl_native_glue(align, prefix,\n-            abi.ngt_cdecl, _), (abi.n_native_glues + 1) as uint);\n+        + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n+            abi::ngt_rust, _), (abi::n_native_glues + 1) as uint)\n+        + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n+            abi::ngt_pure_rust, _), (abi::n_native_glues + 1) as uint)\n+        + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n+            abi::ngt_cdecl, _), (abi::n_native_glues + 1) as uint);\n \n \n-    ret Str.connect(glues, \"\\n\\n\");\n+    ret _str::connect(glues, \"\\n\\n\");\n }\n \n fn get_meta_sect_name() -> str {\n-    if (Str.eq(target_os(), \"macos\")) {\n+    if (_str::eq(target_os(), \"macos\")) {\n         ret \"__DATA,__note.rustc\";\n     }\n-    if (Str.eq(target_os(), \"win32\")) {\n+    if (_str::eq(target_os(), \"win32\")) {\n         ret \".note.rustc\";\n     }\n     ret \".note.rustc\";\n }\n \n fn get_data_layout() -> str {\n-    if (Str.eq(target_os(), \"macos\")) {\n+    if (_str::eq(target_os(), \"macos\")) {\n       ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64\" +\n         \"-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128\" +\n         \"-n8:16:32\";\n     }\n-    if (Str.eq(target_os(), \"win32\")) {\n+    if (_str::eq(target_os(), \"win32\")) {\n       ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n     ret \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n fn get_target_triple() -> str {\n-    if (Str.eq(target_os(), \"macos\")) {\n+    if (_str::eq(target_os(), \"macos\")) {\n         ret \"i686-apple-darwin\";\n     }\n-    if (Str.eq(target_os(), \"win32\")) {\n+    if (_str::eq(target_os(), \"win32\")) {\n         ret \"i686-pc-mingw32\";\n     }\n     ret \"i686-unknown-linux-gnu\";"}, {"sha": "23ca2615d81f91192b0497986a12eb6255638ad2", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 130, "deletions": 130, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,69 +1,68 @@\n // -*- rust -*-\n \n-import front.creader;\n-import front.parser;\n-import front.token;\n-import front.eval;\n-import front.ast;\n-import middle.trans;\n-import middle.resolve;\n-import middle.capture;\n-import middle.ty;\n-import middle.typeck;\n-import middle.typestate_check;\n-import back.Link;\n-import lib.llvm;\n-import util.common;\n-\n-import std.FS;\n-import std.Map.mk_hashmap;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-import std.Str;\n-import std.Vec;\n-import std.IO;\n-import std.Time;\n-\n-import std.GetOpts;\n-import std.GetOpts.optopt;\n-import std.GetOpts.optmulti;\n-import std.GetOpts.optflag;\n-import std.GetOpts.opt_present;\n-\n-import back.Link.output_type;\n-\n-fn default_environment(session.session sess,\n+import front::creader;\n+import front::parser;\n+import front::token;\n+import front::eval;\n+import front::ast;\n+import middle::trans;\n+import middle::resolve;\n+import middle::capture;\n+import middle::ty;\n+import middle::typeck;\n+import middle::typestate_check;\n+import back::Link;\n+import lib::llvm;\n+import util::common;\n+\n+import std::fs;\n+import std::map::mk_hashmap;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import std::_str;\n+import std::_vec;\n+import std::io;\n+\n+import std::getopts;\n+import std::getopts::optopt;\n+import std::getopts::optmulti;\n+import std::getopts::optflag;\n+import std::getopts::opt_present;\n+\n+import back::Link::output_type;\n+\n+fn default_environment(session::session sess,\n                        str argv0,\n-                       str input) -> eval.env {\n+                       str input) -> eval::env {\n \n-    auto libc = \"libc.so\";\n+    auto libc = \"libc::so\";\n     alt (sess.get_targ_cfg().os) {\n-        case (session.os_win32) { libc = \"msvcrt.dll\"; }\n-        case (session.os_macos) { libc = \"libc.dylib\"; }\n-        case (session.os_linux) { libc = \"libc.so.6\"; }\n+        case (session::os_win32) { libc = \"msvcrt.dll\"; }\n+        case (session::os_macos) { libc = \"libc::dylib\"; }\n+        case (session::os_linux) { libc = \"libc::so.6\"; }\n     }\n \n     ret\n         vec(\n             // Target bindings.\n-            tup(\"target_os\", eval.val_str(std.OS.target_os())),\n-            tup(\"target_arch\", eval.val_str(\"x86\")),\n-            tup(\"target_libc\", eval.val_str(libc)),\n+            tup(\"target_os\", eval::val_str(std::os::target_os())),\n+            tup(\"target_arch\", eval::val_str(\"x86\")),\n+            tup(\"target_libc\", eval::val_str(libc)),\n \n             // Build bindings.\n-            tup(\"build_compiler\", eval.val_str(argv0)),\n-            tup(\"build_input\", eval.val_str(input))\n+            tup(\"build_compiler\", eval::val_str(argv0)),\n+            tup(\"build_input\", eval::val_str(input))\n             );\n }\n \n-fn parse_input(session.session sess,\n-                      parser.parser p,\n-                      str input) -> @ast.crate {\n-    if (Str.ends_with(input, \".rc\")) {\n-        ret parser.parse_crate_from_crate_file(p);\n-    } else if (Str.ends_with(input, \".rs\")) {\n-        ret parser.parse_crate_from_source_file(p);\n+fn parse_input(session::session sess,\n+                      parser::parser p,\n+                      str input) -> @ast::crate {\n+    if (_str::ends_with(input, \".rc\")) {\n+        ret parser::parse_crate_from_crate_file(p);\n+    } else if (_str::ends_with(input, \".rs\")) {\n+        ret parser::parse_crate_from_source_file(p);\n     }\n     sess.err(\"unknown input file type: \" + input);\n     fail;\n@@ -72,73 +71,74 @@ fn parse_input(session.session sess,\n fn time[T](bool do_it, str what, fn()->T thunk) -> T {\n     if (!do_it) { ret thunk(); }\n \n-    auto start = Time.get_time();\n+    auto start = std::time::get_time();\n     auto rv = thunk();\n-    auto end = Time.get_time();\n+    auto end = std::time::get_time();\n \n     // FIXME: Actually do timeval math.\n     log_err #fmt(\"time: %s took %u s\", what, (end.sec - start.sec) as uint);\n     ret rv;\n }\n \n-fn compile_input(session.session sess,\n-                 eval.env env,\n+fn compile_input(session::session sess,\n+                 eval::env env,\n                  str input, str output) {\n     auto time_passes = sess.get_opts().time_passes;\n-    auto def = tup(ast.local_crate, 0);\n-    auto p = parser.new_parser(sess, env, def, input, 0u, 0u);\n+    auto def = tup(ast::local_crate, 0);\n+    auto p = parser::new_parser(sess, env, def, input, 0u, 0u);\n     auto crate = time(time_passes, \"parsing\",\n                       bind parse_input(sess, p, input));\n-    if (sess.get_opts().output_type == Link.output_type_none) {ret;}\n+    if (sess.get_opts().output_type == Link::output_type_none) {ret;}\n \n     crate = time(time_passes, \"external crate reading\",\n-                 bind creader.read_crates(sess, crate));\n+                 bind creader::read_crates(sess, crate));\n     auto res = time(time_passes, \"resolution\",\n-                    bind resolve.resolve_crate(sess, crate));\n+                    bind resolve::resolve_crate(sess, crate));\n     crate = res._0;\n     auto def_map = res._1;\n     time[()](time_passes, \"capture checking\",\n-             bind capture.check_for_captures(sess, crate, def_map));\n+             bind capture::check_for_captures(sess, crate, def_map));\n \n-    auto ty_cx = ty.mk_ctxt(sess, def_map);\n+    auto ty_cx = ty::mk_ctxt(sess, def_map);\n     auto typeck_result =\n-        time[typeck.typecheck_result](time_passes, \"typechecking\",\n-                                      bind typeck.check_crate(ty_cx, crate));\n+        time[typeck::typecheck_result](time_passes, \"typechecking\",\n+                                      bind typeck::check_crate(ty_cx, crate));\n     crate = typeck_result._0;\n     auto type_cache = typeck_result._1;\n \n     if (sess.get_opts().run_typestate) {\n         crate = time(time_passes, \"typestate checking\",\n-                     bind typestate_check.check_crate(crate, def_map));\n+                     bind typestate_check::check_crate(crate, def_map));\n     }\n \n-    auto llmod = time[llvm.ModuleRef](time_passes, \"translation\",\n-        bind trans.trans_crate(sess, crate, ty_cx, type_cache, output));\n+    auto llmod = time[llvm::ModuleRef](time_passes, \"translation\",\n+        bind trans::trans_crate(sess, crate, ty_cx, type_cache, output));\n \n     time[()](time_passes, \"LLVM passes\",\n-             bind Link.Write.run_passes(sess, llmod, output));\n+             bind Link::Write::run_passes(sess, llmod, output));\n }\n \n-fn pretty_print_input(session.session sess,\n-                             eval.env env,\n+fn pretty_print_input(session::session sess,\n+                             eval::env env,\n                              str input) {\n-    auto def = tup(ast.local_crate, 0);\n-    auto p = front.parser.new_parser(sess, env, def, input, 0u, 0u);\n-    auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_file(sess, crate.node.module, input, std.IO.stdout());\n+    auto def = tup(ast::local_crate, 0);\n+    auto p = front::parser::new_parser(sess, env, def, input, 0u, 0u);\n+    auto crate = front::parser::parse_crate_from_source_file(p);\n+    pretty::pprust::print_file(sess, crate.node.module, input,\n+                               std::io::stdout());\n }\n \n fn version(str argv0) {\n     auto vers = \"unknown version\";\n     auto env_vers = #env(\"CFG_VERSION\");\n-    if (Str.byte_len(env_vers) != 0u) {\n+    if (_str::byte_len(env_vers) != 0u) {\n         vers = env_vers;\n     }\n-    IO.stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n+    io::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n }\n \n fn usage(str argv0) {\n-    IO.stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) + \"\n+    io::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) + \"\n options:\n \n     -h --help          display this message\n@@ -164,46 +164,46 @@ options:\n     --no-typestate     don't run the typestate pass (unsafe!)\\n\\n\");\n }\n \n-fn get_os(str triple) -> session.os {\n-    if (Str.find(triple, \"win32\") > 0 ||\n-        Str.find(triple, \"mingw32\") > 0 ) {\n-        ret session.os_win32;\n-    } else if (Str.find(triple, \"darwin\") > 0) { ret session.os_macos; }\n-    else if (Str.find(triple, \"linux\") > 0) { ret session.os_linux; }\n+fn get_os(str triple) -> session::os {\n+    if (_str::find(triple, \"win32\") > 0 ||\n+        _str::find(triple, \"mingw32\") > 0 ) {\n+        ret session::os_win32;\n+    } else if (_str::find(triple, \"darwin\") > 0) { ret session::os_macos; }\n+    else if (_str::find(triple, \"linux\") > 0) { ret session::os_linux; }\n }\n \n-fn get_arch(str triple) -> session.arch {\n-    if (Str.find(triple, \"i386\") > 0 ||\n-        Str.find(triple, \"i486\") > 0 ||\n-        Str.find(triple, \"i586\") > 0 ||\n-        Str.find(triple, \"i686\") > 0 ||\n-        Str.find(triple, \"i786\") > 0 ) {\n-        ret session.arch_x86;\n-    } else if (Str.find(triple, \"x86_64\") > 0) {\n-        ret session.arch_x64;\n-    } else if (Str.find(triple, \"arm\") > 0 ||\n-        Str.find(triple, \"xscale\") > 0 ) {\n-        ret session.arch_arm;\n+fn get_arch(str triple) -> session::arch {\n+    if (_str::find(triple, \"i386\") > 0 ||\n+        _str::find(triple, \"i486\") > 0 ||\n+        _str::find(triple, \"i586\") > 0 ||\n+        _str::find(triple, \"i686\") > 0 ||\n+        _str::find(triple, \"i786\") > 0 ) {\n+        ret session::arch_x86;\n+    } else if (_str::find(triple, \"x86_64\") > 0) {\n+        ret session::arch_x64;\n+    } else if (_str::find(triple, \"arm\") > 0 ||\n+        _str::find(triple, \"xscale\") > 0 ) {\n+        ret session::arch_arm;\n     }\n }\n \n fn get_default_sysroot(str binary) -> str {\n-    auto dirname = FS.dirname(binary);\n-    if (Str.eq(dirname, binary)) { ret \".\"; }\n+    auto dirname = fs::dirname(binary);\n+    if (_str::eq(dirname, binary)) { ret \".\"; }\n     ret dirname;\n }\n \n fn main(vec[str] args) {\n \n     let str triple =\n-        std.Str.rustrt.str_from_cstr(llvm.llvm.LLVMRustGetHostTriple());\n+        std::_str::rustrt::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n \n-    let @session.config target_cfg =\n+    let @session::config target_cfg =\n         @rec(os = get_os(triple),\n              arch = get_arch(triple),\n-             int_type = common.ty_i32,\n-             uint_type = common.ty_u32,\n-             float_type = common.ty_f64);\n+             int_type = common::ty_i32,\n+             uint_type = common::ty_u32,\n+             float_type = common::ty_f64);\n \n     auto opts = vec(optflag(\"h\"), optflag(\"help\"),\n                     optflag(\"v\"), optflag(\"version\"),\n@@ -214,14 +214,14 @@ fn main(vec[str] args) {\n                     optflag(\"save-temps\"), optopt(\"sysroot\"),\n                     optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n                     optflag(\"no-typestate\"), optflag(\"noverify\"));\n-    auto binary = Vec.shift[str](args);\n+    auto binary = _vec::shift[str](args);\n     auto match;\n-    alt (GetOpts.getopts(args, opts)) {\n-        case (GetOpts.failure(?f)) {\n-            log_err #fmt(\"error: %s\", GetOpts.fail_str(f));\n+    alt (getopts::getopts(args, opts)) {\n+        case (getopts::failure(?f)) {\n+            log_err #fmt(\"error: %s\", getopts::fail_str(f));\n             fail;\n         }\n-        case (GetOpts.success(?m)) { match = m; }\n+        case (getopts::success(?m)) { match = m; }\n     }\n     if (opt_present(match, \"h\") ||\n         opt_present(match, \"help\")) {\n@@ -239,16 +239,16 @@ fn main(vec[str] args) {\n     auto ls = opt_present(match, \"ls\");\n     auto glue = opt_present(match, \"glue\");\n     auto shared = opt_present(match, \"shared\");\n-    auto output_file = GetOpts.opt_maybe_str(match, \"o\");\n-    auto library_search_paths = GetOpts.opt_strs(match, \"L\");\n+    auto output_file = getopts::opt_maybe_str(match, \"o\");\n+    auto library_search_paths = getopts::opt_strs(match, \"L\");\n \n-    auto output_type = Link.output_type_bitcode;\n+    auto output_type = Link::output_type_bitcode;\n     if (opt_present(match, \"parse-only\")) {\n-        output_type = Link.output_type_none;\n+        output_type = Link::output_type_none;\n     } else if (opt_present(match, \"S\")) {\n-        output_type = Link.output_type_assembly;\n+        output_type = Link::output_type_assembly;\n     } else if (opt_present(match, \"c\")) {\n-        output_type = Link.output_type_object;\n+        output_type = Link::output_type_object;\n     }\n \n     auto verify = !opt_present(match, \"noverify\");\n@@ -259,15 +259,15 @@ fn main(vec[str] args) {\n     auto time_passes = opt_present(match, \"time-passes\");\n     auto time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n     auto run_typestate = !opt_present(match, \"no-typestate\");\n-    auto sysroot_opt = GetOpts.opt_maybe_str(match, \"sysroot\");\n+    auto sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n \n     auto sysroot;\n     alt (sysroot_opt) {\n         case (none[str]) { sysroot = get_default_sysroot(binary); }\n         case (some[str](?s)) { sysroot = s; }\n     }\n \n-    let @session.options sopts =\n+    let @session::options sopts =\n         @rec(shared = shared,\n              optimize = optimize,\n              debuginfo = debuginfo,\n@@ -280,21 +280,21 @@ fn main(vec[str] args) {\n              library_search_paths = library_search_paths,\n              sysroot = sysroot);\n \n-    auto crate_cache = common.new_int_hash[session.crate_metadata]();\n+    auto crate_cache = common::new_int_hash[session::crate_metadata]();\n     auto target_crate_num = 0;\n-    let vec[@ast.meta_item] md = vec();\n+    let vec[@ast::meta_item] md = vec();\n     auto sess =\n-        session.session(target_crate_num, target_cfg, sopts,\n-                        crate_cache, md, front.codemap.new_codemap());\n+        session::session(target_crate_num, target_cfg, sopts,\n+                        crate_cache, md, front::codemap::new_codemap());\n \n-    auto n_inputs = Vec.len[str](match.free);\n+    auto n_inputs = _vec::len[str](match.free);\n \n     if (glue) {\n         if (n_inputs > 0u) {\n             sess.err(\"No input files allowed with --glue.\");\n         }\n-        auto out = Option.from_maybe[str](\"glue.bc\", output_file);\n-        middle.trans.make_common_glue(sess, out);\n+        auto out = option::from_maybe[str](\"glue.bc\", output_file);\n+        middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n \n@@ -309,19 +309,19 @@ fn main(vec[str] args) {\n     if (pretty) {\n         pretty_print_input(sess, env, ifile);\n     } else if (ls) {\n-        front.creader.list_file_metadata(ifile, std.IO.stdout());\n+        front::creader::list_file_metadata(ifile, std::io::stdout());\n     } else {\n         alt (output_file) {\n             case (none[str]) {\n-                let vec[str] parts = Str.split(ifile, '.' as u8);\n-                Vec.pop[str](parts);\n+                let vec[str] parts = _str::split(ifile, '.' as u8);\n+                _vec::pop[str](parts);\n                 alt (output_type) {\n-                    case (Link.output_type_none) { parts += vec(\"pp\"); }\n-                    case (Link.output_type_bitcode) { parts += vec(\"bc\"); }\n-                    case (Link.output_type_assembly) { parts += vec(\"s\"); }\n-                    case (Link.output_type_object) { parts += vec(\"o\"); }\n+                    case (Link::output_type_none) { parts += vec(\"pp\"); }\n+                    case (Link::output_type_bitcode) { parts += vec(\"bc\"); }\n+                    case (Link::output_type_assembly) { parts += vec(\"s\"); }\n+                    case (Link::output_type_object) { parts += vec(\"o\"); }\n                 }\n-                auto ofile = Str.connect(parts, \".\");\n+                auto ofile = _str::connect(parts, \".\");\n                 compile_input(sess, env, ifile, ofile);\n             }\n             case (some[str](?ofile)) {"}, {"sha": "78b14899069b08287368befe3a00a0afddf1552d", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,11 +1,11 @@\n-import front.ast;\n-import front.codemap;\n-import util.common.span;\n-import util.common.ty_mach;\n-import std.UInt;\n-import std.Term;\n-import std.IO;\n-import std.Map;\n+import front::ast;\n+import front::codemap;\n+import util::common::span;\n+import util::common::ty_mach;\n+import std::_uint;\n+import std::term;\n+import std::io;\n+import std::map;\n \n tag os {\n     os_win32;\n@@ -33,37 +33,38 @@ type options = rec(bool shared,\n                    bool save_temps,\n                    bool time_passes,\n                    bool time_llvm_passes,\n-                   back.Link.output_type output_type,\n+                   back::Link::output_type output_type,\n                    vec[str] library_search_paths,\n                    str sysroot);\n \n type crate_metadata = rec(str name,\n                           vec[u8] data);\n \n-fn emit_diagnostic(span sp, str msg, str kind, u8 color, codemap.codemap cm) {\n-    auto lo = codemap.lookup_pos(cm, sp.lo);\n-    auto hi = codemap.lookup_pos(cm, sp.hi);\n-    IO.stdout().write_str(#fmt(\"%s:%u:%u:%u:%u: \", lo.filename, lo.line,\n+fn emit_diagnostic(span sp, str msg, str kind, u8 color,\n+                   codemap::codemap cm) {\n+    auto lo = codemap::lookup_pos(cm, sp.lo);\n+    auto hi = codemap::lookup_pos(cm, sp.hi);\n+    io::stdout().write_str(#fmt(\"%s:%u:%u:%u:%u: \", lo.filename, lo.line,\n                                lo.col, hi.line, hi.col));\n \n-    if (Term.color_supported()) {\n-        Term.fg(IO.stdout().get_buf_writer(), color);\n+    if (term::color_supported()) {\n+        term::fg(io::stdout().get_buf_writer(), color);\n     }\n \n-    IO.stdout().write_str(#fmt(\"%s:\", kind));\n+    io::stdout().write_str(#fmt(\"%s:\", kind));\n \n-    if (Term.color_supported()) {\n-        Term.reset(IO.stdout().get_buf_writer());\n+    if (term::color_supported()) {\n+        term::reset(io::stdout().get_buf_writer());\n     }\n \n-    IO.stdout().write_str(#fmt(\" %s\\n\", msg));\n+    io::stdout().write_str(#fmt(\" %s\\n\", msg));\n }\n \n-state obj session(ast.crate_num cnum,\n+state obj session(ast::crate_num cnum,\n                   @config targ_cfg, @options opts,\n-                  Map.hashmap[int, crate_metadata] crates,\n-                  mutable vec[@ast.meta_item] metadata,\n-                  codemap.codemap cm) {\n+                  map::hashmap[int, crate_metadata] crates,\n+                  mutable vec[@ast::meta_item] metadata,\n+                  codemap::codemap cm) {\n \n     fn get_targ_cfg() -> @config {\n         ret targ_cfg;\n@@ -73,7 +74,7 @@ state obj session(ast.crate_num cnum,\n         ret opts;\n     }\n \n-    fn get_targ_crate_num() -> ast.crate_num {\n+    fn get_targ_crate_num() -> ast::crate_num {\n         ret cnum;\n     }\n \n@@ -88,10 +89,10 @@ state obj session(ast.crate_num cnum,\n         fail;\n     }\n \n-    fn add_metadata(vec[@ast.meta_item] data) {\n+    fn add_metadata(vec[@ast::meta_item] data) {\n         metadata = metadata + data;\n     }\n-    fn get_metadata() -> vec[@ast.meta_item] {\n+    fn get_metadata() -> vec[@ast::meta_item] {\n         ret metadata;\n     }\n \n@@ -129,12 +130,12 @@ state obj session(ast.crate_num cnum,\n         ret crates.contains_key(num);\n     }\n \n-    fn get_codemap() -> codemap.codemap {\n+    fn get_codemap() -> codemap::codemap {\n         ret cm;\n     }\n \n-    fn lookup_pos(uint pos) -> codemap.loc {\n-        ret codemap.lookup_pos(cm, pos);\n+    fn lookup_pos(uint pos) -> codemap::loc {\n+        ret codemap::lookup_pos(cm, pos);\n     }\n }\n "}, {"sha": "c107e7c8f03179b8a4f1d7b3ea525f171c3742d2", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,13 +1,13 @@\n \n-import std.Map.hashmap;\n-import std.Option;\n-import std.Str;\n-import std.Vec;\n-import util.common.span;\n-import util.common.spanned;\n-import util.common.ty_mach;\n-import util.common.filename;\n-import util.typestate_ann.ts_ann;\n+import std::map::hashmap;\n+import std::option;\n+import std::_str;\n+import std::_vec;\n+import util::common::span;\n+import util::common::spanned;\n+import util::common::ty_mach;\n+import util::common::filename;\n+import util::typestate_ann::ts_ann;\n \n type ident = str;\n \n@@ -25,9 +25,9 @@ type ty_param = ident;\n tag ann {\n     ann_none(uint);\n     ann_type(uint,\n-             middle.ty.t,\n-             Option.t[vec[middle.ty.t]], /* ty param substs */\n-             Option.t[@ts_ann]); /* pre- and postcondition for typestate */\n+             middle::ty::t,\n+             option::t[vec[middle::ty::t]], /* ty param substs */\n+             option::t[@ts_ann]); /* pre- and postcondition for typestate */\n }\n \n fn ann_tag(&ann a) -> uint {\n@@ -96,8 +96,8 @@ tag crate_directive_ {\n     // and redirected to the use of const stmt_decls inside\n     // crate directive blocks.\n     cdir_let(ident, @expr, vec[@crate_directive]);\n-    cdir_src_mod(ident, Option.t[filename]);\n-    cdir_dir_mod(ident, Option.t[filename], vec[@crate_directive]);\n+    cdir_src_mod(ident, option::t[filename]);\n+    cdir_dir_mod(ident, option::t[filename], vec[@crate_directive]);\n     cdir_view_item(@view_item);\n     cdir_meta(vec[@meta_item]);\n     cdir_syntax(path);\n@@ -111,7 +111,7 @@ type meta_item_ = rec(ident name, str value);\n \n type block = spanned[block_];\n type block_ = rec(vec[@stmt] stmts,\n-                  Option.t[@expr] expr,\n+                  option::t[@expr] expr,\n                   ann a); /* ann is only meaningful for the ts_ann field */\n \n type pat = spanned[pat_];\n@@ -234,10 +234,10 @@ tag init_op {\n type initializer = rec(init_op op,\n                        @expr expr);\n \n-type local = rec(Option.t[@ty] ty,\n+type local = rec(option::t[@ty] ty,\n                  bool infer,\n                  ident ident,\n-                 Option.t[initializer] init,\n+                 option::t[initializer] init,\n                  def_id id,\n                  ann ann);\n \n@@ -261,16 +261,16 @@ type expr = spanned[expr_];\n tag expr_ {\n     expr_vec(vec[@expr], mutability, ann);\n     expr_tup(vec[elt], ann);\n-    expr_rec(vec[field], Option.t[@expr], ann);\n+    expr_rec(vec[field], option::t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n     expr_self_method(ident, ann);\n-    expr_bind(@expr, vec[Option.t[@expr]], ann);\n-    expr_spawn(spawn_dom, Option.t[str], @expr, vec[@expr], ann);\n+    expr_bind(@expr, vec[option::t[@expr]], ann);\n+    expr_spawn(spawn_dom, option::t[str], @expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);\n     expr_unary(unop, @expr, ann);\n     expr_lit(@lit, ann);\n     expr_cast(@expr, @ty, ann);\n-    expr_if(@expr, block, Option.t[@expr], ann);\n+    expr_if(@expr, block, option::t[@expr], ann);\n     expr_while(@expr, block, ann);\n     expr_for(@decl, @expr, block, ann);\n     expr_for_each(@decl, @expr, block, ann);\n@@ -284,12 +284,12 @@ tag expr_ {\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n     expr_path(path, ann);\n-    expr_ext(path, vec[@expr], Option.t[str], @expr, ann);\n+    expr_ext(path, vec[@expr], option::t[str], @expr, ann);\n     expr_fail(ann);\n     expr_break(ann);\n     expr_cont(ann);\n-    expr_ret(Option.t[@expr], ann);\n-    expr_put(Option.t[@expr], ann);\n+    expr_ret(option::t[@expr], ann);\n+    expr_put(option::t[@expr], ann);\n     expr_be(@expr, ann);\n     expr_log(int, @expr, ann);\n /* just an assert, no significance to typestate */\n@@ -328,7 +328,7 @@ tag ty_ {\n     ty_int;\n     ty_uint;\n     ty_float;\n-    ty_machine(util.common.ty_mach);\n+    ty_machine(util::common::ty_mach);\n     ty_char;\n     ty_str;\n     ty_box(mt);\n@@ -365,14 +365,13 @@ type _fn = rec(fn_decl decl,\n                proto proto,\n                block body);\n \n-\n type method_ = rec(ident ident, _fn meth, def_id id, ann ann);\n type method = spanned[method_];\n \n type obj_field = rec(@ty ty, ident ident, def_id id, ann ann);\n type _obj = rec(vec[obj_field] fields,\n                 vec[@method] methods,\n-                Option.t[@method] dtor);\n+                option::t[@method] dtor);\n \n type _mod = rec(vec[@view_item] view_items,\n                 vec[@item] items);\n@@ -395,7 +394,7 @@ type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n tag view_item_ {\n-    view_item_use(ident, vec[@meta_item], def_id, Option.t[int]);\n+    view_item_use(ident, vec[@meta_item], def_id, option::t[int]);\n     view_item_import(ident, vec[ident], def_id);\n     view_item_export(ident);\n }\n@@ -428,16 +427,16 @@ fn item_ident(@item it) -> ident {\n type native_item = spanned[native_item_];\n tag native_item_ {\n     native_item_ty(ident, def_id);\n-    native_item_fn(ident, Option.t[str],\n+    native_item_fn(ident, option::t[str],\n                    fn_decl, vec[ty_param], def_id, ann);\n }\n \n fn is_exported(ident i, _mod m) -> bool {\n     auto count = 0;\n-    for (@ast.view_item vi in m.view_items) {\n+    for (@ast::view_item vi in m.view_items) {\n         alt (vi.node) {\n-            case (ast.view_item_export(?id)) {\n-                if (Str.eq(i, id)) {\n+            case (ast::view_item_export(?id)) {\n+                if (_str::eq(i, id)) {\n                     ret true;\n                 }\n                 count += 1;"}, {"sha": "c474fa07fb672a9f2a25fdb941df28077fa8152b", "filename": "src/comp/front/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcodemap.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-import std.Vec;\n+import std::_vec;\n \n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n@@ -24,18 +24,18 @@ fn new_filemap(str filename, uint start_pos) -> filemap {\n }\n \n fn next_line(filemap file, uint pos) {\n-    Vec.push[uint](file.lines, pos);\n+    _vec::push[uint](file.lines, pos);\n }\n \n fn lookup_pos(codemap map, uint pos) -> loc {\n-    auto a = 0u; auto b = Vec.len[filemap](map.files);\n+    auto a = 0u; auto b = _vec::len[filemap](map.files);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (map.files.(m).start_pos > pos) { b = m; }\n         else { a = m; }\n     }\n     auto f = map.files.(a);\n-    a = 0u; b = Vec.len[uint](f.lines);\n+    a = 0u; b = _vec::len[uint](f.lines);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (f.lines.(m) > pos) { b = m; }"}, {"sha": "03b5cb1ee329302572b3b125984a743cb2acb2c6", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 232, "deletions": 230, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,56 +1,56 @@\n // -*- rust -*-\n \n-import driver.session;\n-import front.ast;\n-import lib.llvm.False;\n-import lib.llvm.llvm;\n-import lib.llvm.mk_object_file;\n-import lib.llvm.mk_section_iter;\n-import middle.fold;\n-import middle.metadata;\n-import middle.trans;\n-import middle.ty;\n-import back.x86;\n-import util.common;\n-import util.common.span;\n-\n-import std.Str;\n-import std.UInt;\n-import std.Vec;\n-import std.EBML;\n-import std.FS;\n-import std.IO;\n-import std.Option;\n-import std.Option.none;\n-import std.Option.some;\n-import std.OS;\n-import std.Map.hashmap;\n+import driver::session;\n+import front::ast;\n+import lib::llvm::False;\n+import lib::llvm::llvm;\n+import lib::llvm::mk_object_file;\n+import lib::llvm::mk_section_iter;\n+import middle::fold;\n+import middle::metadata;\n+import middle::trans;\n+import middle::ty;\n+import back::x86;\n+import util::common;\n+import util::common::span;\n+\n+import std::_str;\n+import std::_uint;\n+import std::_vec;\n+import std::ebml;\n+import std::fs;\n+import std::io;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+import std::os;\n+import std::map::hashmap;\n \n // TODO: map to a real type here.\n type env = @rec(\n-    session.session sess,\n+    session::session sess,\n     @hashmap[str, int] crate_cache,\n     vec[str] library_search_paths,\n     mutable int next_crate_num\n );\n \n tag resolve_result {\n-    rr_ok(ast.def_id);\n-    rr_not_found(ast.ident);\n+    rr_ok(ast::def_id);\n+    rr_not_found(ast::ident);\n }\n \n // Type decoding\n \n-// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// Compact string representation for ty::t values. API ty_str & parse_from_str\n // (The second has to be authed pure.) Extra parameters are for converting\n // to/from def_ids in the data buffer. Whatever format you choose should not\n // contain pipe characters.\n \n-// Callback to translate defs to strs or back.\n-type str_def = fn(str) -> ast.def_id;\n+// Callback to translate defs to strs or back:\n+type str_def = fn(str) -> ast::def_id;\n \n type pstate = rec(vec[u8] data, int crate,\n-                  mutable uint pos, uint len, ty.ctxt tcx);\n+                  mutable uint pos, uint len, ty::ctxt tcx);\n \n fn peek(@pstate st) -> u8 {\n     ret st.data.(st.pos);\n@@ -62,105 +62,105 @@ fn next(@pstate st) -> u8 {\n }\n \n fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len,\n-                 str_def sd, ty.ctxt tcx) -> ty.t {\n+                 str_def sd, ty::ctxt tcx) -> ty::t {\n     auto st = @rec(data=data, crate=crate_num,\n                    mutable pos=pos, len=len, tcx=tcx);\n     auto result = parse_ty(st, sd);\n     ret result;\n }\n \n-fn parse_ty(@pstate st, str_def sd) -> ty.t {\n+fn parse_ty(@pstate st, str_def sd) -> ty::t {\n     alt (next(st) as char) {\n-        case ('n') { ret ty.mk_nil(st.tcx); }\n-        case ('b') { ret ty.mk_bool(st.tcx); }\n-        case ('i') { ret ty.mk_int(st.tcx); }\n-        case ('u') { ret ty.mk_uint(st.tcx); }\n-        case ('l') { ret ty.mk_float(st.tcx); }\n+        case ('n') { ret ty::mk_nil(st.tcx); }\n+        case ('b') { ret ty::mk_bool(st.tcx); }\n+        case ('i') { ret ty::mk_int(st.tcx); }\n+        case ('u') { ret ty::mk_uint(st.tcx); }\n+        case ('l') { ret ty::mk_float(st.tcx); }\n         case ('M') {\n             alt (next(st) as char) {\n-                case ('b') { ret ty.mk_mach(st.tcx, common.ty_u8); }\n-                case ('w') { ret ty.mk_mach(st.tcx, common.ty_u16); }\n-                case ('l') { ret ty.mk_mach(st.tcx, common.ty_u32); }\n-                case ('d') { ret ty.mk_mach(st.tcx, common.ty_u64); }\n-                case ('B') { ret ty.mk_mach(st.tcx, common.ty_i8); }\n-                case ('W') { ret ty.mk_mach(st.tcx, common.ty_i16); }\n-                case ('L') { ret ty.mk_mach(st.tcx, common.ty_i32); }\n-                case ('D') { ret ty.mk_mach(st.tcx, common.ty_i64); }\n-                case ('f') { ret ty.mk_mach(st.tcx, common.ty_f32); }\n-                case ('F') { ret ty.mk_mach(st.tcx, common.ty_f64); }\n+                case ('b') { ret ty::mk_mach(st.tcx, common::ty_u8); }\n+                case ('w') { ret ty::mk_mach(st.tcx, common::ty_u16); }\n+                case ('l') { ret ty::mk_mach(st.tcx, common::ty_u32); }\n+                case ('d') { ret ty::mk_mach(st.tcx, common::ty_u64); }\n+                case ('B') { ret ty::mk_mach(st.tcx, common::ty_i8); }\n+                case ('W') { ret ty::mk_mach(st.tcx, common::ty_i16); }\n+                case ('L') { ret ty::mk_mach(st.tcx, common::ty_i32); }\n+                case ('D') { ret ty::mk_mach(st.tcx, common::ty_i64); }\n+                case ('f') { ret ty::mk_mach(st.tcx, common::ty_f32); }\n+                case ('F') { ret ty::mk_mach(st.tcx, common::ty_f64); }\n             }\n         }\n-        case ('c') { ret ty.mk_char(st.tcx); }\n-        case ('s') { ret ty.mk_str(st.tcx); }\n+        case ('c') { ret ty::mk_char(st.tcx); }\n+        case ('s') { ret ty::mk_str(st.tcx); }\n         case ('t') {\n             assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n-            let vec[ty.t] params = vec();\n+            let vec[ty::t] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_ty(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_tag(st.tcx, def, params);\n+            ret ty::mk_tag(st.tcx, def, params);\n         }\n-        case ('p') { ret ty.mk_param(st.tcx, parse_int(st) as uint); }\n-        case ('@') { ret ty.mk_box(st.tcx, parse_mt(st, sd)); }\n-        case ('V') { ret ty.mk_vec(st.tcx, parse_mt(st, sd)); }\n-        case ('P') { ret ty.mk_port(st.tcx, parse_ty(st, sd)); }\n-        case ('C') { ret ty.mk_chan(st.tcx, parse_ty(st, sd)); }\n+        case ('p') { ret ty::mk_param(st.tcx, parse_int(st) as uint); }\n+        case ('@') { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n+        case ('V') { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n+        case ('P') { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n+        case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n         case ('T') {\n             assert (next(st) as char == '[');\n-            let vec[ty.mt] params = vec();\n+            let vec[ty::mt] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_mt(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_tup(st.tcx, params);\n+            ret ty::mk_tup(st.tcx, params);\n         }\n         case ('R') {\n             assert (next(st) as char == '[');\n-            let vec[ty.field] fields = vec();\n+            let vec[ty::field] fields = vec();\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n                 while (peek(st) as char != '=') {\n-                    name += Str.unsafe_from_byte(next(st));\n+                    name += _str::unsafe_from_byte(next(st));\n                 }\n                 st.pos = st.pos + 1u;\n                 fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_rec(st.tcx, fields);\n+            ret ty::mk_rec(st.tcx, fields);\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_fn(st.tcx, ast.proto_fn, func._0, func._1);\n+            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_fn(st.tcx, ast.proto_iter, func._0, func._1);\n+            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1);\n         }\n         case ('N') {\n             auto abi;\n             alt (next(st) as char) {\n-                case ('r') { abi = ast.native_abi_rust; }\n-                case ('i') { abi = ast.native_abi_rust_intrinsic; }\n-                case ('c') { abi = ast.native_abi_cdecl; }\n-                case ('l') { abi = ast.native_abi_llvm; }\n+                case ('r') { abi = ast::native_abi_rust; }\n+                case ('i') { abi = ast::native_abi_rust_intrinsic; }\n+                case ('c') { abi = ast::native_abi_cdecl; }\n+                case ('l') { abi = ast::native_abi_llvm; }\n             }\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_native_fn(st.tcx,abi,func._0,func._1);\n+            ret ty::mk_native_fn(st.tcx,abi,func._0,func._1);\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n-            let vec[ty.method] methods = vec();\n+            let vec[ty::method] methods = vec();\n             while (peek(st) as char != ']') {\n                 auto proto;\n                 alt (next(st) as char) {\n-                    case ('W') {proto = ast.proto_iter;}\n-                    case ('F') {proto = ast.proto_fn;}\n+                    case ('W') {proto = ast::proto_iter;}\n+                    case ('F') {proto = ast::proto_fn;}\n                 }\n                 auto name = \"\";\n                 while (peek(st) as char != '[') {\n-                    name += Str.unsafe_from_byte(next(st));\n+                    name += _str::unsafe_from_byte(next(st));\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods += vec(rec(proto=proto,\n@@ -169,19 +169,19 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n                                    output=func._1));\n             }\n             st.pos += 1u;\n-            ret ty.mk_obj(st.tcx, methods);\n+            ret ty::mk_obj(st.tcx, methods);\n         }\n-        case ('X') { ret ty.mk_var(st.tcx, parse_int(st)); }\n-        case ('E') { ret ty.mk_native(st.tcx); }\n-        case ('Y') { ret ty.mk_type(st.tcx); }\n+        case ('X') { ret ty::mk_var(st.tcx, parse_int(st)); }\n+        case ('E') { ret ty::mk_native(st.tcx); }\n+        case ('Y') { ret ty::mk_type(st.tcx); }\n         case ('#') {\n             auto pos = parse_hex(st);\n             assert (next(st) as char == ':');\n             auto len = parse_hex(st);\n             assert (next(st) as char == '#');\n             alt (st.tcx.rcache.find(tup(st.crate,pos,len))) {\n-                case (some[ty.t](?tt)) { ret tt; }\n-                case (none[ty.t]) {\n+                case (some[ty::t](?tt)) { ret tt; }\n+                case (none[ty::t]) {\n                     auto ps = @rec(pos=pos, len=len with *st);\n                     auto tt = parse_ty(ps, sd);\n                     st.tcx.rcache.insert(tup(st.crate,pos,len), tt);\n@@ -197,20 +197,20 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n     }\n }\n \n-fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n+fn parse_mt(@pstate st, str_def sd) -> ty::mt {\n     auto mut;\n     alt (peek(st) as char) {\n-        case ('m') {next(st); mut = ast.mut;}\n-        case ('?') {next(st); mut = ast.maybe_mut;}\n-        case (_)   {mut=ast.imm;}\n+        case ('m') {next(st); mut = ast::mut;}\n+        case ('?') {next(st); mut = ast::maybe_mut;}\n+        case (_)   {mut=ast::imm;}\n     }\n     ret rec(ty=parse_ty(st, sd), mut=mut);\n }\n \n-fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n+fn parse_def(@pstate st, str_def sd) -> ast::def_id {\n     auto def = \"\";\n     while (peek(st) as char != '|') {\n-        def += Str.unsafe_from_byte(next(st));\n+        def += _str::unsafe_from_byte(next(st));\n     }\n     st.pos = st.pos + 1u;\n     ret sd(def);\n@@ -245,13 +245,13 @@ fn parse_hex(@pstate st) -> uint {\n     ret n;\n }\n \n-fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n+fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t) {\n     assert (next(st) as char == '[');\n-    let vec[ty.arg] inputs = vec();\n+    let vec[ty::arg] inputs = vec();\n     while (peek(st) as char != ']') {\n-        auto mode = ty.mo_val;\n+        auto mode = ty::mo_val;\n         if (peek(st) as char == '&') {\n-            mode = ty.mo_alias;\n+            mode = ty::mo_alias;\n             st.pos = st.pos + 1u;\n         }\n         inputs += vec(rec(mode=mode, ty=parse_ty(st, sd)));\n@@ -263,9 +263,9 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n \n // Rust metadata parsing\n \n-fn parse_def_id(vec[u8] buf) -> ast.def_id {\n+fn parse_def_id(vec[u8] buf) -> ast::def_id {\n     auto colon_idx = 0u;\n-    auto len = Vec.len[u8](buf);\n+    auto len = _vec::len[u8](buf);\n     while (colon_idx < len && buf.(colon_idx) != (':' as u8)) {\n         colon_idx += 1u;\n     }\n@@ -274,30 +274,31 @@ fn parse_def_id(vec[u8] buf) -> ast.def_id {\n         fail;\n     }\n \n-    auto crate_part = Vec.slice[u8](buf, 0u, colon_idx);\n-    auto def_part = Vec.slice[u8](buf, colon_idx + 1u, len);\n-    auto crate_num = UInt.parse_buf(crate_part, 10u) as int;\n-    auto def_num = UInt.parse_buf(def_part, 10u) as int;\n+    auto crate_part = _vec::slice[u8](buf, 0u, colon_idx);\n+    auto def_part = _vec::slice[u8](buf, colon_idx + 1u, len);\n+    auto crate_num = _uint::parse_buf(crate_part, 10u) as int;\n+    auto def_num = _uint::parse_buf(def_part, 10u) as int;\n     ret tup(crate_num, def_num);\n }\n \n-fn lookup_hash(&EBML.doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n-    -> Option.t[EBML.doc] {\n-    auto index = EBML.get_doc(d, metadata.tag_index);\n-    auto table = EBML.get_doc(index, metadata.tag_index_table);\n+fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n+    -> option::t[ebml::doc] {\n+    auto index = ebml::get_doc(d, metadata::tag_index);\n+    auto table = ebml::get_doc(index, metadata::tag_index_table);\n \n     auto hash_pos = table.start + (hash % 256u) * 4u;\n-    auto pos = EBML.be_uint_from_bytes(d.data, hash_pos, 4u);\n-    auto bucket = EBML.doc_at(d.data, pos);\n+    auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n+    auto bucket = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n-    auto result = Option.none[EBML.doc];\n-    auto belt = metadata.tag_index_buckets_bucket_elt;\n-    for each (EBML.doc elt in EBML.tagged_docs(bucket, belt)) {\n+    auto result = option::none[ebml::doc];\n+    auto belt = metadata::tag_index_buckets_bucket_elt;\n+    for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n         alt (result) {\n-            case (Option.none[EBML.doc]) {\n-                auto pos = EBML.be_uint_from_bytes(elt.data, elt.start, 4u);\n-                if (eq_fn(Vec.slice[u8](elt.data, elt.start+4u, elt.end))) {\n-                    result = Option.some[EBML.doc](EBML.doc_at(d.data, pos));\n+            case (option::none[ebml::doc]) {\n+                auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n+                if (eq_fn(_vec::slice[u8](elt.data, elt.start+4u, elt.end))) {\n+                    result = option::some[ebml::doc]\n+                        (ebml::doc_at(d.data, pos));\n                 }\n             }\n             case (_) {}\n@@ -308,127 +309,127 @@ fn lookup_hash(&EBML.doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n+fn resolve_path(vec[ast::ident] path, vec[u8] data) -> resolve_result {\n     fn eq_item(vec[u8] data, str s) -> bool {\n-        ret Str.eq(Str.unsafe_from_bytes(data), s);\n+        ret _str::eq(_str::unsafe_from_bytes(data), s);\n     }\n-    auto s = Str.connect(path, \"::\");\n-    auto md = EBML.new_doc(data);\n-    auto paths = EBML.get_doc(md, metadata.tag_paths);\n+    auto s = _str::connect(path, \"::\");\n+    auto md = ebml::new_doc(data);\n+    auto paths = ebml::get_doc(md, metadata::tag_paths);\n     auto eqer = bind eq_item(_, s);\n-    alt (lookup_hash(paths, eqer, metadata.hash_path(s))) {\n-        case (Option.some[EBML.doc](?d)) {\n-            auto did_doc = EBML.get_doc(d, metadata.tag_def_id);\n-            ret rr_ok(parse_def_id(EBML.doc_data(did_doc)));\n+    alt (lookup_hash(paths, eqer, metadata::hash_path(s))) {\n+        case (option::some[ebml::doc](?d)) {\n+            auto did_doc = ebml::get_doc(d, metadata::tag_def_id);\n+            ret rr_ok(parse_def_id(ebml::doc_data(did_doc)));\n         }\n-        case (Option.none[EBML.doc]) {\n+        case (option::none[ebml::doc]) {\n             ret rr_not_found(s);\n         }\n     }\n }\n \n-fn maybe_find_item(int item_id, &EBML.doc items) -> Option.t[EBML.doc] {\n+fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n     fn eq_item(vec[u8] bytes, int item_id) -> bool {\n-        ret EBML.be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n+        ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     auto eqer = bind eq_item(_, item_id);\n-    ret lookup_hash(items, eqer, metadata.hash_def_num(item_id));\n+    ret lookup_hash(items, eqer, metadata::hash_def_num(item_id));\n }\n \n-fn find_item(int item_id, &EBML.doc items) -> EBML.doc {\n+fn find_item(int item_id, &ebml::doc items) -> ebml::doc {\n     alt (maybe_find_item(item_id, items)) {\n-        case (Option.some[EBML.doc](?d)) {ret d;}\n+        case (option::some[ebml::doc](?d)) {ret d;}\n     }\n }\n \n-// Looks up an item in the given metadata and returns an EBML doc pointing\n+// Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(int item_id, vec[u8] data) -> EBML.doc {\n-    auto items = EBML.get_doc(EBML.new_doc(data), metadata.tag_items);\n+fn lookup_item(int item_id, vec[u8] data) -> ebml::doc {\n+    auto items = ebml::get_doc(ebml::new_doc(data), metadata::tag_items);\n     ret find_item(item_id, items);\n }\n \n-fn item_kind(&EBML.doc item) -> u8 {\n-    auto kind = EBML.get_doc(item, metadata.tag_items_data_item_kind);\n-    ret EBML.doc_as_uint(kind) as u8;\n+fn item_kind(&ebml::doc item) -> u8 {\n+    auto kind = ebml::get_doc(item, metadata::tag_items_data_item_kind);\n+    ret ebml::doc_as_uint(kind) as u8;\n }\n \n-fn item_symbol(&EBML.doc item) -> str {\n-    auto sym = EBML.get_doc(item, metadata.tag_items_data_item_symbol);\n-    ret Str.unsafe_from_bytes(EBML.doc_data(sym));\n+fn item_symbol(&ebml::doc item) -> str {\n+    auto sym = ebml::get_doc(item, metadata::tag_items_data_item_symbol);\n+    ret _str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n-fn variant_tag_id(&EBML.doc d) -> ast.def_id {\n-    auto tagdoc = EBML.get_doc(d, metadata.tag_items_data_item_tag_id);\n-    ret parse_def_id(EBML.doc_data(tagdoc));\n+fn variant_tag_id(&ebml::doc d) -> ast::def_id {\n+    auto tagdoc = ebml::get_doc(d, metadata::tag_items_data_item_tag_id);\n+    ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n-fn item_type(&EBML.doc item, int this_cnum, ty.ctxt tcx) -> ty.t {\n-    fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n+fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n+    fn parse_external_def_id(int this_cnum, str s) -> ast::def_id {\n         // FIXME: This is completely wrong when linking against a crate\n         // that, in turn, links against another crate. We need a mapping\n         // from crate ID to crate \"meta\" attributes as part of the crate\n-        // metadata.\n-        auto buf = Str.bytes(s);\n+        // metadata:\n+        auto buf = _str::bytes(s);\n         auto external_def_id = parse_def_id(buf);\n         ret tup(this_cnum, external_def_id._1);\n     }\n \n-    auto tp = EBML.get_doc(item, metadata.tag_items_data_item_type);\n-    auto s = Str.unsafe_from_bytes(EBML.doc_data(tp));\n+    auto tp = ebml::get_doc(item, metadata::tag_items_data_item_type);\n+    auto s = _str::unsafe_from_bytes(ebml::doc_data(tp));\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       bind parse_external_def_id(this_cnum, _), tcx);\n }\n \n-fn item_ty_param_count(&EBML.doc item, int this_cnum) -> uint {\n+fn item_ty_param_count(&ebml::doc item, int this_cnum) -> uint {\n     let uint ty_param_count = 0u;\n-    auto tp = metadata.tag_items_data_item_ty_param_count;\n-    for each (EBML.doc p in EBML.tagged_docs(item, tp)) {\n-        ty_param_count = EBML.vint_at(EBML.doc_data(p), 0u)._0;\n+    auto tp = metadata::tag_items_data_item_ty_param_count;\n+    for each (ebml::doc p in ebml::tagged_docs(item, tp)) {\n+        ty_param_count = ebml::vint_at(ebml::doc_data(p), 0u)._0;\n     }\n     ret ty_param_count;\n }\n \n-fn tag_variant_ids(&EBML.doc item, int this_cnum) -> vec[ast.def_id] {\n-    let vec[ast.def_id] ids = vec();\n-    auto v = metadata.tag_items_data_item_variant;\n-    for each (EBML.doc p in EBML.tagged_docs(item, v)) {\n-        auto ext = parse_def_id(EBML.doc_data(p));\n-        Vec.push[ast.def_id](ids, tup(this_cnum, ext._1));\n+fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n+    let vec[ast::def_id] ids = vec();\n+    auto v = metadata::tag_items_data_item_variant;\n+    for each (ebml::doc p in ebml::tagged_docs(item, v)) {\n+        auto ext = parse_def_id(ebml::doc_data(p));\n+        _vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n     }\n     ret ids;\n }\n \n-fn get_metadata_section(str filename) -> Option.t[vec[u8]] {\n-    auto mb = llvm.LLVMRustCreateMemoryBufferWithContentsOfFile\n-        (Str.buf(filename));\n-    if (mb as int == 0) {ret Option.none[vec[u8]];}\n+fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n+    auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile\n+        (_str::buf(filename));\n+    if (mb as int == 0) {ret option::none[vec[u8]];}\n     auto of = mk_object_file(mb);\n     auto si = mk_section_iter(of.llof);\n-    while (llvm.LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n-        auto name_buf = llvm.LLVMGetSectionName(si.llsi);\n-        auto name = Str.str_from_cstr(name_buf);\n-        if (Str.eq(name, x86.get_meta_sect_name())) {\n-            auto cbuf = llvm.LLVMGetSectionContents(si.llsi);\n-            auto csz = llvm.LLVMGetSectionSize(si.llsi);\n-            auto cvbuf = cbuf as Vec.vbuf;\n-            ret Option.some[vec[u8]](Vec.vec_from_vbuf[u8](cvbuf, csz));\n+    while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n+        auto name_buf = llvm::LLVMGetSectionName(si.llsi);\n+        auto name = _str::str_from_cstr(name_buf);\n+        if (_str::eq(name, x86::get_meta_sect_name())) {\n+            auto cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+            auto csz = llvm::LLVMGetSectionSize(si.llsi);\n+            auto cvbuf = cbuf as _vec::vbuf;\n+            ret option::some[vec[u8]](_vec::vec_from_vbuf[u8](cvbuf, csz));\n         }\n-        llvm.LLVMMoveToNextSection(si.llsi);\n+        llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    ret Option.none[vec[u8]];\n+    ret option::none[vec[u8]];\n }\n \n \n-fn load_crate(session.session sess,\n+fn load_crate(session::session sess,\n               int cnum,\n-              ast.ident ident,\n+              ast::ident ident,\n               vec[str] library_search_paths) {\n-    auto filename = parser.default_native_name(sess, ident);\n+    auto filename = parser::default_native_name(sess, ident);\n     for (str library_search_path in library_search_paths) {\n-        auto path = FS.connect(library_search_path, filename);\n+        auto path = fs::connect(library_search_path, filename);\n         alt (get_metadata_section(path)) {\n-            case (Option.some[vec[u8]](?cvec)) {\n+            case (option::some[vec[u8]](?cvec)) {\n                 sess.set_external_crate(cnum, rec(name=ident, data=cvec));\n                 ret;\n             }\n@@ -441,10 +442,10 @@ fn load_crate(session.session sess,\n     fail;\n }\n \n-fn fold_view_item_use(&env e, &span sp, &ast.ident ident,\n-                      &vec[@ast.meta_item] meta_items,\n-                      &ast.def_id id, &Option.t[int] cnum_opt)\n-    -> @ast.view_item {\n+fn fold_view_item_use(&env e, &span sp, &ast::ident ident,\n+                      &vec[@ast::meta_item] meta_items,\n+                      &ast::def_id id, &option::t[int] cnum_opt)\n+    -> @ast::view_item {\n     auto cnum;\n     if (!e.crate_cache.contains_key(ident)) {\n         cnum = e.next_crate_num;\n@@ -455,23 +456,24 @@ fn fold_view_item_use(&env e, &span sp, &ast.ident ident,\n         cnum = e.crate_cache.get(ident);\n     }\n \n-    auto viu = ast.view_item_use(ident, meta_items, id, some[int](cnum));\n-    ret @fold.respan[ast.view_item_](sp, viu);\n+    auto viu = ast::view_item_use(ident, meta_items, id, some[int](cnum));\n+    ret @fold::respan[ast::view_item_](sp, viu);\n }\n \n // Reads external crates referenced by \"use\" directives.\n-fn read_crates(session.session sess,\n-               @ast.crate crate) -> @ast.crate {\n+fn read_crates(session::session sess,\n+               @ast::crate crate) -> @ast::crate {\n     auto e = @rec(\n         sess=sess,\n-        crate_cache=@common.new_str_hash[int](),\n+        crate_cache=@common::new_str_hash[int](),\n         library_search_paths=sess.get_opts().library_search_paths,\n         mutable next_crate_num=1\n     );\n \n     auto f = fold_view_item_use;\n-    auto fld = @rec(fold_view_item_use=f with *fold.new_identity_fold[env]());\n-    ret fold.fold_crate[env](e, fld, crate);\n+    auto fld = @rec(fold_view_item_use=f\n+                    with *fold::new_identity_fold[env]());\n+    ret fold::fold_crate[env](e, fld, crate);\n }\n \n \n@@ -497,15 +499,15 @@ fn kind_has_type_params(u8 kind_ch) -> bool {\n \n // Crate metadata queries\n \n-fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n-        -> Option.t[ast.def] {\n+fn lookup_def(session::session sess, int cnum, vec[ast::ident] path)\n+        -> option::t[ast::def] {\n     auto data = sess.get_external_crate(cnum).data;\n \n     auto did;\n     alt (resolve_path(path, data)) {\n         case (rr_ok(?di)) { did = di; }\n         case (rr_not_found(?name)) {\n-            ret none[ast.def];\n+            ret none[ast::def];\n         }\n     }\n \n@@ -516,31 +518,31 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n \n     // FIXME: It'd be great if we had u8 char literals.\n     auto def;\n-    if (kind_ch == ('c' as u8))         { def = ast.def_const(did);      }\n-    else if (kind_ch == ('f' as u8))    { def = ast.def_fn(did);         }\n-    else if (kind_ch == ('F' as u8))    { def = ast.def_native_fn(did);  }\n-    else if (kind_ch == ('y' as u8))    { def = ast.def_ty(did);         }\n-    else if (kind_ch == ('o' as u8))    { def = ast.def_obj(did);        }\n-    else if (kind_ch == ('T' as u8))    { def = ast.def_native_ty(did);  }\n+    if (kind_ch == ('c' as u8))         { def = ast::def_const(did);      }\n+    else if (kind_ch == ('f' as u8))    { def = ast::def_fn(did);         }\n+    else if (kind_ch == ('F' as u8))    { def = ast::def_native_fn(did);  }\n+    else if (kind_ch == ('y' as u8))    { def = ast::def_ty(did);         }\n+    else if (kind_ch == ('o' as u8))    { def = ast::def_obj(did);        }\n+    else if (kind_ch == ('T' as u8))    { def = ast::def_native_ty(did);  }\n     else if (kind_ch == ('t' as u8)) {\n         // We treat references to tags as references to types.\n-        def = ast.def_ty(did);\n-    } else if (kind_ch == ('m' as u8))  { def = ast.def_mod(did);        }\n-    else if (kind_ch == ('n' as u8))    { def = ast.def_native_mod(did); }\n+        def = ast::def_ty(did);\n+    } else if (kind_ch == ('m' as u8))  { def = ast::def_mod(did);        }\n+    else if (kind_ch == ('n' as u8))    { def = ast::def_native_mod(did); }\n     else if (kind_ch == ('v' as u8)) {\n         auto tid = variant_tag_id(item);\n         tid = tup(cnum, tid._1);\n-        def = ast.def_variant(tid, did);\n+        def = ast::def_variant(tid, did);\n     } else {\n         log_err #fmt(\"lookup_def(): unknown kind char: %d\", kind_ch as int);\n         fail;\n     }\n \n-    ret some[ast.def](def);\n+    ret some[ast::def](def);\n }\n \n-fn get_type(session.session sess, ty.ctxt tcx, ast.def_id def)\n-        -> ty.ty_param_count_and_ty {\n+fn get_type(session::session sess, ty::ctxt tcx, ast::def_id def)\n+        -> ty::ty_param_count_and_ty {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n     auto item = lookup_item(def._1, data);\n@@ -558,29 +560,29 @@ fn get_type(session.session sess, ty.ctxt tcx, ast.def_id def)\n     ret tup(tp_count, t);\n }\n \n-fn get_symbol(session.session sess, ast.def_id def) -> str {\n+fn get_symbol(session::session sess, ast::def_id def) -> str {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n     auto item = lookup_item(def._1, data);\n     ret item_symbol(item);\n }\n \n-fn get_tag_variants(session.session sess, ty.ctxt tcx, ast.def_id def)\n-        -> vec[trans.variant_info] {\n+fn get_tag_variants(session::session sess, ty::ctxt tcx, ast::def_id def)\n+        -> vec[trans::variant_info] {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n-    auto items = EBML.get_doc(EBML.new_doc(data), metadata.tag_items);\n+    auto items = ebml::get_doc(ebml::new_doc(data), metadata::tag_items);\n     auto item = find_item(def._1, items);\n \n-    let vec[trans.variant_info] infos = vec();\n+    let vec[trans::variant_info] infos = vec();\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n-    for (ast.def_id did in variant_ids) {\n+    for (ast::def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tcx);\n-        let vec[ty.t] arg_tys = vec();\n-        alt (ty.struct(tcx, ctor_ty)) {\n-            case (ty.ty_fn(_, ?args, _)) {\n-                for (ty.arg a in args) {\n+        let vec[ty::t] arg_tys = vec();\n+        alt (ty::struct(tcx, ctor_ty)) {\n+            case (ty::ty_fn(_, ?args, _)) {\n+                for (ty::arg a in args) {\n                     arg_tys += vec(a.ty);\n                 }\n             }\n@@ -594,46 +596,46 @@ fn get_tag_variants(session.session sess, ty.ctxt tcx, ast.def_id def)\n     ret infos;\n }\n \n-fn list_file_metadata(str path, IO.writer out) {\n+fn list_file_metadata(str path, io::writer out) {\n     alt (get_metadata_section(path)) {\n-        case (Option.some[vec[u8]](?bytes)) {\n+        case (option::some[vec[u8]](?bytes)) {\n             list_crate_metadata(bytes, out);\n         }\n-        case (Option.none[vec[u8]]) {\n+        case (option::none[vec[u8]]) {\n             out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n         }\n     }\n }\n \n-fn read_path(&EBML.doc d) -> tup(str, uint) {\n-    auto desc = EBML.doc_data(d);\n-    auto pos = EBML.be_uint_from_bytes(desc, 0u, 4u);\n-    auto pathbytes = Vec.slice[u8](desc, 4u, Vec.len[u8](desc));\n-    auto path = Str.unsafe_from_bytes(pathbytes);\n+fn read_path(&ebml::doc d) -> tup(str, uint) {\n+    auto desc = ebml::doc_data(d);\n+    auto pos = ebml::be_uint_from_bytes(desc, 0u, 4u);\n+    auto pathbytes = _vec::slice[u8](desc, 4u, _vec::len[u8](desc));\n+    auto path = _str::unsafe_from_bytes(pathbytes);\n     ret tup(path, pos);\n }\n \n-fn list_crate_metadata(vec[u8] bytes, IO.writer out) {\n-    auto md = EBML.new_doc(bytes);\n-    auto paths = EBML.get_doc(md, metadata.tag_paths);\n-    auto items = EBML.get_doc(md, metadata.tag_items);\n-    auto index = EBML.get_doc(paths, metadata.tag_index);\n-    auto bs = EBML.get_doc(index, metadata.tag_index_buckets);\n-    for each (EBML.doc bucket in\n-              EBML.tagged_docs(bs, metadata.tag_index_buckets_bucket)) {\n-        auto et = metadata.tag_index_buckets_bucket_elt;\n-        for each (EBML.doc elt in EBML.tagged_docs(bucket, et)) {\n+fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n+    auto md = ebml::new_doc(bytes);\n+    auto paths = ebml::get_doc(md, metadata::tag_paths);\n+    auto items = ebml::get_doc(md, metadata::tag_items);\n+    auto index = ebml::get_doc(paths, metadata::tag_index);\n+    auto bs = ebml::get_doc(index, metadata::tag_index_buckets);\n+    for each (ebml::doc bucket in\n+              ebml::tagged_docs(bs, metadata::tag_index_buckets_bucket)) {\n+        auto et = metadata::tag_index_buckets_bucket_elt;\n+        for each (ebml::doc elt in ebml::tagged_docs(bucket, et)) {\n             auto data = read_path(elt);\n-            auto def = EBML.doc_at(bytes, data._1);\n-            auto did_doc = EBML.get_doc(def, metadata.tag_def_id);\n-            auto did = parse_def_id(EBML.doc_data(did_doc));\n+            auto def = ebml::doc_at(bytes, data._1);\n+            auto did_doc = ebml::get_doc(def, metadata::tag_def_id);\n+            auto did = parse_def_id(ebml::doc_data(did_doc));\n             out.write_str(#fmt(\"%s (%s)\\n\", data._0,\n                                describe_def(items, did)));\n         }\n     }\n }\n \n-fn describe_def(&EBML.doc items, ast.def_id id) -> str {\n+fn describe_def(&ebml::doc items, ast::def_id id) -> str {\n     if (id._0 != 0) {ret \"external\";}\n     auto item = find_item(id._1, items);\n     ret item_kind_to_str(item_kind(item));"}, {"sha": "0416611c8f391d7019af1c12215c6147e47b3604", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,20 +1,20 @@\n-import std.Vec;\n-import std.Str;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-import std.Map.hashmap;\n-\n-import driver.session;\n-import ast.ident;\n-import front.parser.parser;\n-import front.parser.spanned;\n-import front.parser.new_parser;\n-import front.parser.parse_mod_items;\n-import util.common;\n-import util.common.filename;\n-import util.common.span;\n-import util.common.new_str_hash;\n+import std::_vec;\n+import std::_str;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import std::map::hashmap;\n+\n+import driver::session;\n+import ast::ident;\n+import front::parser::parser;\n+import front::parser::spanned;\n+import front::parser::new_parser;\n+import front::parser::parse_mod_items;\n+import util::common;\n+import util::common::filename;\n+import util::common::span;\n+import util::common::new_str_hash;\n \n \n // Simple dynamic-typed value type for eval_expr.\n@@ -33,7 +33,7 @@ type env = vec[tup(ident, val)];\n type ctx = @rec(parser p,\n                 eval_mode mode,\n                 mutable vec[str] deps,\n-                session.session sess,\n+                session::session sess,\n                 mutable uint chpos,\n                 mutable uint next_ann);\n \n@@ -90,46 +90,46 @@ fn val_as_str(val v) -> str {\n     fail;\n }\n \n-fn lookup(session.session sess, env e, span sp, ident i) -> val {\n+fn lookup(session::session sess, env e, span sp, ident i) -> val {\n     for (tup(ident, val) pair in e) {\n-        if (Str.eq(i, pair._0)) {\n+        if (_str::eq(i, pair._0)) {\n             ret pair._1;\n         }\n     }\n     sess.span_err(sp, \"unknown variable: \" + i);\n     fail;\n }\n \n-fn eval_lit(ctx cx, span sp, @ast.lit lit) -> val {\n+fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n     alt (lit.node) {\n-        case (ast.lit_bool(?b)) { ret val_bool(b); }\n-        case (ast.lit_int(?i)) { ret val_int(i); }\n-        case (ast.lit_str(?s)) { ret val_str(s); }\n+        case (ast::lit_bool(?b)) { ret val_bool(b); }\n+        case (ast::lit_int(?i)) { ret val_int(i); }\n+        case (ast::lit_str(?s)) { ret val_str(s); }\n         case (_) {\n             cx.sess.span_err(sp, \"evaluating unsupported literal\");\n         }\n     }\n     fail;\n }\n \n-fn eval_expr(ctx cx, env e, @ast.expr x) -> val {\n+fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n     alt (x.node) {\n-        case (ast.expr_path(?pth, _)) {\n-            if (Vec.len[ident](pth.node.idents) == 1u &&\n-                Vec.len[@ast.ty](pth.node.types) == 0u) {\n+        case (ast::expr_path(?pth, _)) {\n+            if (_vec::len[ident](pth.node.idents) == 1u &&\n+                _vec::len[@ast::ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n             cx.sess.span_err(x.span, \"evaluating structured path-name\");\n         }\n \n-        case (ast.expr_lit(?lit, _)) {\n+        case (ast::expr_lit(?lit, _)) {\n             ret eval_lit(cx, x.span, lit);\n         }\n \n-        case (ast.expr_unary(?op, ?a, _)) {\n+        case (ast::expr_unary(?op, ?a, _)) {\n             auto av = eval_expr(cx, e, a);\n             alt (op) {\n-                case (ast.not) {\n+                case (ast::not) {\n                     if (val_is_bool(av)) {\n                         ret val_bool(!val_as_bool(av));\n                     }\n@@ -141,11 +141,11 @@ fn eval_expr(ctx cx, env e, @ast.expr x) -> val {\n             }\n         }\n \n-        case (ast.expr_binary(?op, ?a, ?b, _)) {\n+        case (ast::expr_binary(?op, ?a, ?b, _)) {\n             auto av = eval_expr(cx, e, a);\n             auto bv = eval_expr(cx, e, b);\n             alt (op) {\n-                case (ast.add) {\n+                case (ast::add) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) + val_as_int(bv));\n                     }\n@@ -155,53 +155,53 @@ fn eval_expr(ctx cx, env e, @ast.expr x) -> val {\n                     cx.sess.span_err(x.span, \"bad types in '+' expression\");\n                 }\n \n-                case (ast.sub) {\n+                case (ast::sub) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) - val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '-' expression\");\n                 }\n \n-                case (ast.mul) {\n+                case (ast::mul) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) * val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '*' expression\");\n                 }\n \n-                case (ast.div) {\n+                case (ast::div) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) / val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '/' expression\");\n                 }\n \n-                case (ast.rem) {\n+                case (ast::rem) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) % val_as_int(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '%' expression\");\n                 }\n \n-                case (ast.and) {\n+                case (ast::and) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) && val_as_bool(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '&&' expression\");\n                 }\n \n-                case (ast.or) {\n+                case (ast::or) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) || val_as_bool(bv));\n                     }\n                     cx.sess.span_err(x.span, \"bad types in '||' expression\");\n                 }\n \n-                case (ast.eq) {\n+                case (ast::eq) {\n                     ret val_bool(val_eq(cx.sess, x.span, av, bv));\n                 }\n \n-                case (ast.ne) {\n+                case (ast::ne) {\n                     ret val_bool(! val_eq(cx.sess, x.span, av, bv));\n                 }\n \n@@ -217,15 +217,15 @@ fn eval_expr(ctx cx, env e, @ast.expr x) -> val {\n     fail;\n }\n \n-fn val_eq(session.session sess, span sp, val av, val bv) -> bool {\n+fn val_eq(session::session sess, span sp, val av, val bv) -> bool {\n     if (val_is_bool(av) && val_is_bool(bv)) {\n         ret val_as_bool(av) == val_as_bool(bv);\n     }\n     if (val_is_int(av) && val_is_int(bv)) {\n         ret val_as_int(av) == val_as_int(bv);\n     }\n     if (val_is_str(av) && val_is_str(bv)) {\n-        ret Str.eq(val_as_str(av),\n+        ret _str::eq(val_as_str(av),\n                     val_as_str(bv));\n     }\n     sess.span_err(sp, \"bad types in comparison\");\n@@ -234,23 +234,23 @@ fn val_eq(session.session sess, span sp, val av, val bv) -> bool {\n \n fn eval_crate_directives(ctx cx,\n                                 env e,\n-                                vec[@ast.crate_directive] cdirs,\n+                                vec[@ast::crate_directive] cdirs,\n                                 str prefix,\n-                                &mutable vec[@ast.view_item] view_items,\n-                                &mutable vec[@ast.item] items) {\n+                                &mutable vec[@ast::view_item] view_items,\n+                                &mutable vec[@ast::item] items) {\n \n-    for (@ast.crate_directive sub_cdir in cdirs) {\n+    for (@ast::crate_directive sub_cdir in cdirs) {\n         eval_crate_directive(cx, e, sub_cdir, prefix,\n                              view_items, items);\n     }\n }\n \n \n fn eval_crate_directives_to_mod(ctx cx, env e,\n-                                       vec[@ast.crate_directive] cdirs,\n-                                       str prefix) -> ast._mod {\n-    let vec[@ast.view_item] view_items = vec();\n-    let vec[@ast.item] items = vec();\n+                                       vec[@ast::crate_directive] cdirs,\n+                                       str prefix) -> ast::_mod {\n+    let vec[@ast::view_item] view_items = vec();\n+    let vec[@ast::item] items = vec();\n \n     eval_crate_directives(cx, e, cdirs, prefix,\n                           view_items, items);\n@@ -261,14 +261,14 @@ fn eval_crate_directives_to_mod(ctx cx, env e,\n \n fn eval_crate_directive_block(ctx cx,\n                                      env e,\n-                                     &ast.block blk,\n+                                     &ast::block blk,\n                                      str prefix,\n-                                     &mutable vec[@ast.view_item] view_items,\n-                                     &mutable vec[@ast.item] items) {\n+                                     &mutable vec[@ast::view_item] view_items,\n+                                     &mutable vec[@ast::item] items) {\n \n-    for (@ast.stmt s in blk.node.stmts) {\n+    for (@ast::stmt s in blk.node.stmts) {\n         alt (s.node) {\n-            case (ast.stmt_crate_directive(?cdir)) {\n+            case (ast::stmt_crate_directive(?cdir)) {\n                 eval_crate_directive(cx, e, cdir, prefix,\n                                      view_items, items);\n             }\n@@ -282,13 +282,13 @@ fn eval_crate_directive_block(ctx cx,\n \n fn eval_crate_directive_expr(ctx cx,\n                                     env e,\n-                                    @ast.expr x,\n+                                    @ast::expr x,\n                                     str prefix,\n-                                    &mutable vec[@ast.view_item] view_items,\n-                                    &mutable vec[@ast.item] items) {\n+                                    &mutable vec[@ast::view_item] view_items,\n+                                    &mutable vec[@ast::item] items) {\n     alt (x.node) {\n \n-        case (ast.expr_if(?cond, ?thn, ?elopt, _)) {\n+        case (ast::expr_if(?cond, ?thn, ?elopt, _)) {\n             auto cv = eval_expr(cx, e, cond);\n             if (!val_is_bool(cv)) {\n                 cx.sess.span_err(x.span, \"bad cond type in 'if'\");\n@@ -300,7 +300,7 @@ fn eval_crate_directive_expr(ctx cx,\n             }\n \n             alt (elopt) {\n-                case (some[@ast.expr](?els)) {\n+                case (some[@ast::expr](?els)) {\n                     ret eval_crate_directive_expr(cx, e, els, prefix,\n                                                   view_items, items);\n                 }\n@@ -310,18 +310,18 @@ fn eval_crate_directive_expr(ctx cx,\n             }\n         }\n \n-        case (ast.expr_alt(?v, ?arms, _)) {\n+        case (ast::expr_alt(?v, ?arms, _)) {\n             auto vv = eval_expr(cx, e, v);\n-            for (ast.arm arm in arms) {\n+            for (ast::arm arm in arms) {\n                 alt (arm.pat.node) {\n-                    case (ast.pat_lit(?lit, _)) {\n+                    case (ast::pat_lit(?lit, _)) {\n                         auto pv = eval_lit(cx, arm.pat.span, lit);\n                         if (val_eq(cx.sess, arm.pat.span, vv, pv)) {\n                             ret eval_crate_directive_block\n                                 (cx, e, arm.block, prefix, view_items, items);\n                         }\n                     }\n-                    case (ast.pat_wild(_)) {\n+                    case (ast::pat_wild(_)) {\n                         ret eval_crate_directive_block\n                             (cx, e, arm.block, prefix,\n                              view_items, items);\n@@ -335,7 +335,7 @@ fn eval_crate_directive_expr(ctx cx,\n             cx.sess.span_err(x.span, \"no cases matched in 'alt'\");\n         }\n \n-        case (ast.expr_block(?block, _)) {\n+        case (ast::expr_block(?block, _)) {\n             ret eval_crate_directive_block(cx, e, block, prefix,\n                                            view_items, items);\n         }\n@@ -348,25 +348,25 @@ fn eval_crate_directive_expr(ctx cx,\n \n fn eval_crate_directive(ctx cx,\n                                env e,\n-                               @ast.crate_directive cdir,\n+                               @ast::crate_directive cdir,\n                                str prefix,\n-                               &mutable vec[@ast.view_item] view_items,\n-                               &mutable vec[@ast.item] items) {\n+                               &mutable vec[@ast::view_item] view_items,\n+                               &mutable vec[@ast::item] items) {\n     alt (cdir.node) {\n \n-        case (ast.cdir_let(?id, ?x, ?cdirs)) {\n+        case (ast::cdir_let(?id, ?x, ?cdirs)) {\n             auto v = eval_expr(cx, e, x);\n             auto e0 = vec(tup(id, v)) + e;\n             eval_crate_directives(cx, e0, cdirs, prefix,\n                                   view_items, items);\n         }\n \n-        case (ast.cdir_expr(?x)) {\n+        case (ast::cdir_expr(?x)) {\n             eval_crate_directive_expr(cx, e, x, prefix,\n                                       view_items, items);\n         }\n \n-        case (ast.cdir_src_mod(?id, ?file_opt)) {\n+        case (ast::cdir_src_mod(?id, ?file_opt)) {\n \n             auto file_path = id + \".rs\";\n             alt (file_opt) {\n@@ -376,7 +376,7 @@ fn eval_crate_directive(ctx cx,\n                 case (none[filename]) {}\n             }\n \n-            auto full_path = prefix + std.FS.path_sep() + file_path;\n+            auto full_path = prefix + std::fs::path_sep() + file_path;\n \n             if (cx.mode == mode_depend) {\n                 cx.deps += vec(full_path);\n@@ -386,18 +386,18 @@ fn eval_crate_directive(ctx cx,\n             auto start_id = cx.p.next_def_id();\n             auto p0 = new_parser(cx.sess, e, start_id, full_path, cx.chpos,\n                                  cx.next_ann);\n-            auto m0 = parse_mod_items(p0, token.EOF);\n+            auto m0 = parse_mod_items(p0, token::EOF);\n             auto next_id = p0.next_def_id();\n             // Thread defids and chpos through the parsers\n             cx.p.set_def(next_id._1);\n             cx.chpos = p0.get_chpos();\n             cx.next_ann = p0.next_ann_num();\n-            auto im = ast.item_mod(id, m0, next_id);\n+            auto im = ast::item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n-            Vec.push[@ast.item](items, i);\n+            _vec::push[@ast::item](items, i);\n         }\n \n-        case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n+        case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n \n             auto path = id;\n             alt (dir_opt) {\n@@ -407,23 +407,23 @@ fn eval_crate_directive(ctx cx,\n                 case (none[filename]) {}\n             }\n \n-            auto full_path = prefix + std.FS.path_sep() + path;\n+            auto full_path = prefix + std::fs::path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n-            auto im = ast.item_mod(id, m0, cx.p.next_def_id());\n+            auto im = ast::item_mod(id, m0, cx.p.next_def_id());\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n-            Vec.push[@ast.item](items, i);\n+            _vec::push[@ast::item](items, i);\n         }\n \n-        case (ast.cdir_view_item(?vi)) {\n-            Vec.push[@ast.view_item](view_items, vi);\n+        case (ast::cdir_view_item(?vi)) {\n+            _vec::push[@ast::view_item](view_items, vi);\n         }\n \n-        case (ast.cdir_meta(?mi)) {\n+        case (ast::cdir_meta(?mi)) {\n             cx.sess.add_metadata(mi);\n         }\n \n-        case (ast.cdir_syntax(?pth)) {}\n-        case (ast.cdir_auth(?pth, ?eff)) {}\n+        case (ast::cdir_syntax(?pth)) {}\n+        case (ast::cdir_auth(?pth, ?eff)) {}\n     }\n }\n "}, {"sha": "f9ac6a52085daae69efaadf111ff08b5ea81bad1", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,47 +4,47 @@\n  * interface.\n  */\n \n-import util.common;\n+import util::common;\n \n-import std.Str;\n-import std.Vec;\n-import std.Option;\n-import std.GenericOS;\n+import std::_str;\n+import std::_vec;\n+import std::option;\n+import std::generic_os;\n \n export expand_syntax_ext;\n \n // FIXME: Need to thread parser through here to handle errors correctly\n-fn expand_syntax_ext(parser.parser p,\n-                     common.span sp,\n-                     vec[@ast.expr] args,\n-                     Option.t[str] body) -> @ast.expr {\n+fn expand_syntax_ext(parser::parser p,\n+                     common::span sp,\n+                     vec[@ast::expr] args,\n+                     option::t[str] body) -> @ast::expr {\n \n-    if (Vec.len[@ast.expr](args) != 1u) {\n+    if (_vec::len[@ast::expr](args) != 1u) {\n         p.err(\"malformed #env call\");\n     }\n \n     // FIXME: if this was more thorough it would manufacture an\n-    // Option.t[str] rather than just an maybe-empty string.\n+    // option::t[str] rather than just an maybe-empty string.\n \n     auto var = expr_to_str(p, args.(0));\n-    alt (GenericOS.getenv(var)) {\n-        case (Option.none[str]) {\n+    alt (generic_os::getenv(var)) {\n+        case (option::none[str]) {\n             ret make_new_str(p, sp, \"\");\n         }\n-        case (Option.some[str](?s)) {\n+        case (option::some[str](?s)) {\n             ret make_new_str(p, sp, s);\n         }\n     }\n }\n \n-// FIXME: duplicate code copied from extfmt.\n+// FIXME: duplicate code copied from extfmt:\n \n-fn expr_to_str(parser.parser p,\n-               @ast.expr expr) -> str {\n+fn expr_to_str(parser::parser p,\n+               @ast::expr expr) -> str {\n     alt (expr.node) {\n-        case (ast.expr_lit(?l, _)) {\n+        case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n-                case (ast.lit_str(?s)) {\n+                case (ast::lit_str(?s)) {\n                     ret s;\n                 }\n             }\n@@ -54,14 +54,15 @@ fn expr_to_str(parser.parser p,\n     fail;\n }\n \n-fn make_new_lit(parser.parser p, common.span sp, ast.lit_ lit) -> @ast.expr {\n+fn make_new_lit(parser::parser p, common::span sp, ast::lit_ lit)\n+    -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n-    auto expr = ast.expr_lit(sp_lit, p.get_ann());\n+    auto expr = ast::expr_lit(sp_lit, p.get_ann());\n     ret @rec(node=expr, span=sp);\n }\n \n-fn make_new_str(parser.parser p, common.span sp, str s) -> @ast.expr {\n-    auto lit = ast.lit_str(s);\n+fn make_new_str(parser::parser p, common::span sp, str s) -> @ast::expr {\n+    auto lit = ast::lit_str(s);\n     ret make_new_lit(p, sp, lit);\n }\n "}, {"sha": "085e5d98bf77efc6e8bdadfa1f10175b872991fa", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,56 +1,56 @@\n /*\n  * The compiler code necessary to support the #fmt extension.  Eventually this\n- * should all get sucked into either the standard library ExtFmt module or the\n+ * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n \n-import front.parser.parser;\n-import util.common;\n-\n-import std.Str;\n-import std.Vec;\n-import std.Option;\n-import std.Option.none;\n-import std.Option.some;\n-\n-import std.ExtFmt.CT.signedness;\n-import std.ExtFmt.CT.signed;\n-import std.ExtFmt.CT.unsigned;\n-import std.ExtFmt.CT.caseness;\n-import std.ExtFmt.CT.case_upper;\n-import std.ExtFmt.CT.case_lower;\n-import std.ExtFmt.CT.ty;\n-import std.ExtFmt.CT.ty_bool;\n-import std.ExtFmt.CT.ty_str;\n-import std.ExtFmt.CT.ty_char;\n-import std.ExtFmt.CT.ty_int;\n-import std.ExtFmt.CT.ty_bits;\n-import std.ExtFmt.CT.ty_hex;\n-import std.ExtFmt.CT.ty_octal;\n-import std.ExtFmt.CT.flag;\n-import std.ExtFmt.CT.flag_left_justify;\n-import std.ExtFmt.CT.flag_left_zero_pad;\n-import std.ExtFmt.CT.flag_space_for_sign;\n-import std.ExtFmt.CT.flag_sign_always;\n-import std.ExtFmt.CT.flag_alternate;\n-import std.ExtFmt.CT.count;\n-import std.ExtFmt.CT.count_is;\n-import std.ExtFmt.CT.count_is_param;\n-import std.ExtFmt.CT.count_is_next_param;\n-import std.ExtFmt.CT.count_implied;\n-import std.ExtFmt.CT.conv;\n-import std.ExtFmt.CT.piece;\n-import std.ExtFmt.CT.piece_string;\n-import std.ExtFmt.CT.piece_conv;\n-import std.ExtFmt.CT.parse_fmt_string;\n+import front::parser::parser;\n+import util::common;\n+\n+import std::_str;\n+import std::_vec;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+\n+import std::extfmt::CT::signedness;\n+import std::extfmt::CT::signed;\n+import std::extfmt::CT::unsigned;\n+import std::extfmt::CT::caseness;\n+import std::extfmt::CT::case_upper;\n+import std::extfmt::CT::case_lower;\n+import std::extfmt::CT::ty;\n+import std::extfmt::CT::ty_bool;\n+import std::extfmt::CT::ty_str;\n+import std::extfmt::CT::ty_char;\n+import std::extfmt::CT::ty_int;\n+import std::extfmt::CT::ty_bits;\n+import std::extfmt::CT::ty_hex;\n+import std::extfmt::CT::ty_octal;\n+import std::extfmt::CT::flag;\n+import std::extfmt::CT::flag_left_justify;\n+import std::extfmt::CT::flag_left_zero_pad;\n+import std::extfmt::CT::flag_space_for_sign;\n+import std::extfmt::CT::flag_sign_always;\n+import std::extfmt::CT::flag_alternate;\n+import std::extfmt::CT::count;\n+import std::extfmt::CT::count_is;\n+import std::extfmt::CT::count_is_param;\n+import std::extfmt::CT::count_is_next_param;\n+import std::extfmt::CT::count_implied;\n+import std::extfmt::CT::conv;\n+import std::extfmt::CT::piece;\n+import std::extfmt::CT::piece_string;\n+import std::extfmt::CT::piece_conv;\n+import std::extfmt::CT::parse_fmt_string;\n \n export expand_syntax_ext;\n \n fn expand_syntax_ext(parser p,\n-                     vec[@ast.expr] args,\n-                     Option.t[str] body) -> @ast.expr {\n+                     vec[@ast::expr] args,\n+                     option::t[str] body) -> @ast::expr {\n \n-    if (Vec.len[@ast.expr](args) == 0u) {\n+    if (_vec::len[@ast::expr](args) == 0u) {\n         // FIXME: Handle error correctly.\n         log_err \"malformed #fmt call\";\n         fail;\n@@ -62,16 +62,16 @@ fn expand_syntax_ext(parser p,\n     // log fmt;\n \n     auto pieces = parse_fmt_string(fmt);\n-    auto args_len = Vec.len[@ast.expr](args);\n-    auto fmt_args = Vec.slice[@ast.expr](args, 1u, args_len - 1u);\n+    auto args_len = _vec::len[@ast::expr](args);\n+    auto fmt_args = _vec::slice[@ast::expr](args, 1u, args_len - 1u);\n     ret pieces_to_expr(p, pieces, args);\n }\n \n-fn expr_to_str(@ast.expr expr) -> str {\n+fn expr_to_str(@ast::expr expr) -> str {\n     alt (expr.node) {\n-        case (ast.expr_lit(?l, _)) {\n+        case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n-                case (ast.lit_str(?s)) {\n+                case (ast::lit_str(?s)) {\n                     ret s;\n                 }\n             }\n@@ -86,75 +86,75 @@ fn expr_to_str(@ast.expr expr) -> str {\n // be factored out in common with other code that builds expressions.\n // FIXME: Probably should be using the parser's span functions\n // FIXME: Cleanup the naming of these functions\n-fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n-        -> @ast.expr {\n+fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n+        -> @ast::expr {\n \n-    fn make_new_lit(parser p, common.span sp, ast.lit_ lit) -> @ast.expr {\n+    fn make_new_lit(parser p, common::span sp, ast::lit_ lit) -> @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n-        auto expr = ast.expr_lit(sp_lit, p.get_ann());\n+        auto expr = ast::expr_lit(sp_lit, p.get_ann());\n         ret @rec(node=expr, span=sp);\n     }\n \n-    fn make_new_str(parser p, common.span sp, str s) -> @ast.expr {\n-        auto lit = ast.lit_str(s);\n+    fn make_new_str(parser p, common::span sp, str s) -> @ast::expr {\n+        auto lit = ast::lit_str(s);\n         ret make_new_lit(p, sp, lit);\n     }\n \n-    fn make_new_int(parser p, common.span sp, int i) -> @ast.expr {\n-        auto lit = ast.lit_int(i);\n+    fn make_new_int(parser p, common::span sp, int i) -> @ast::expr {\n+        auto lit = ast::lit_int(i);\n         ret make_new_lit(p, sp, lit);\n     }\n \n-    fn make_new_uint(parser p, common.span sp, uint u) -> @ast.expr {\n-        auto lit = ast.lit_uint(u);\n+    fn make_new_uint(parser p, common::span sp, uint u) -> @ast::expr {\n+        auto lit = ast::lit_uint(u);\n         ret make_new_lit(p, sp, lit);\n     }\n \n-    fn make_add_expr(parser p, common.span sp,\n-                     @ast.expr lhs, @ast.expr rhs) -> @ast.expr {\n-        auto binexpr = ast.expr_binary(ast.add, lhs, rhs, p.get_ann());\n+    fn make_add_expr(parser p, common::span sp,\n+                     @ast::expr lhs, @ast::expr rhs) -> @ast::expr {\n+        auto binexpr = ast::expr_binary(ast::add, lhs, rhs, p.get_ann());\n         ret @rec(node=binexpr, span=sp);\n     }\n \n-    fn make_path_expr(parser p, common.span sp, vec[ast.ident] idents)\n-            -> @ast.expr {\n-        let vec[@ast.ty] types = vec();\n+    fn make_path_expr(parser p, common::span sp, vec[ast::ident] idents)\n+            -> @ast::expr {\n+        let vec[@ast::ty] types = vec();\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n-        auto pathexpr = ast.expr_path(sp_path, p.get_ann());\n+        auto pathexpr = ast::expr_path(sp_path, p.get_ann());\n         auto sp_pathexpr = @rec(node=pathexpr, span=sp);\n         ret sp_pathexpr;\n     }\n \n-    fn make_vec_expr(parser p, common.span sp, vec[@ast.expr] exprs)\n-            -> @ast.expr {\n-        auto vecexpr = ast.expr_vec(exprs, ast.imm, p.get_ann());\n+    fn make_vec_expr(parser p, common::span sp, vec[@ast::expr] exprs)\n+            -> @ast::expr {\n+        auto vecexpr = ast::expr_vec(exprs, ast::imm, p.get_ann());\n         auto sp_vecexpr = @rec(node=vecexpr, span=sp);\n         ret sp_vecexpr;\n     }\n \n-    fn make_call(parser p, common.span sp, vec[ast.ident] fn_path,\n-                 vec[@ast.expr] args) -> @ast.expr {\n+    fn make_call(parser p, common::span sp, vec[ast::ident] fn_path,\n+                 vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(p, sp, fn_path);\n-        auto callexpr = ast.expr_call(pathexpr, args, p.get_ann());\n+        auto callexpr = ast::expr_call(pathexpr, args, p.get_ann());\n         auto sp_callexpr = @rec(node=callexpr, span=sp);\n         ret sp_callexpr;\n     }\n \n-    fn make_rec_expr(parser p, common.span sp,\n-                     vec[tup(ast.ident, @ast.expr)] fields) -> @ast.expr {\n-        let vec[ast.field] astfields = vec();\n-        for (tup(ast.ident, @ast.expr) field in fields) {\n+    fn make_rec_expr(parser p, common::span sp,\n+                     vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n+        let vec[ast::field] astfields = vec();\n+        for (tup(ast::ident, @ast::expr) field in fields) {\n             auto ident = field._0;\n             auto val = field._1;\n-            auto astfield = rec(mut = ast.imm,\n+            auto astfield = rec(mut = ast::imm,\n                                 ident = ident,\n                                 expr = val);\n             astfields += vec(astfield);\n         }\n \n-        auto recexpr = ast.expr_rec(astfields,\n-                                    Option.none[@ast.expr],\n+        auto recexpr = ast::expr_rec(astfields,\n+                                    option::none[@ast::expr],\n                                     p.get_ann());\n         auto sp_recexpr = @rec(node=recexpr, span=sp);\n         ret sp_recexpr;\n@@ -166,18 +166,18 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n         ret vec(\"std\", \"extfmt\", \"RT\", ident);\n     }\n \n-    fn make_rt_path_expr(parser p, common.span sp, str ident) -> @ast.expr {\n+    fn make_rt_path_expr(parser p, common::span sp, str ident) -> @ast::expr {\n         auto path = make_path_vec(ident);\n         ret make_path_expr(p, sp, path);\n     }\n \n-    // Produces an AST expression that represents a RT.conv record,\n-    // which tells the RT.conv* functions how to perform the conversion\n-    fn make_rt_conv_expr(parser p, common.span sp, &conv cnv) -> @ast.expr {\n+    // Produces an AST expression that represents a RT::conv record,\n+    // which tells the RT::conv* functions how to perform the conversion\n+    fn make_rt_conv_expr(parser p, common::span sp, &conv cnv) -> @ast::expr {\n \n-        fn make_flags(parser p, common.span sp, vec[flag] flags)\n-                -> @ast.expr {\n-            let vec[@ast.expr] flagexprs = vec();\n+        fn make_flags(parser p, common::span sp, vec[flag] flags)\n+                -> @ast::expr {\n+            let vec[@ast::expr] flagexprs = vec();\n             for (flag f in flags) {\n                 auto fstr;\n                 alt (f) {\n@@ -203,14 +203,14 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n-            if (Vec.len[@ast.expr](flagexprs) == 0u) {\n+            if (_vec::len[@ast::expr](flagexprs) == 0u) {\n                 flagexprs += vec(make_rt_path_expr(p, sp, \"flag_none\"));\n             }\n \n             ret make_vec_expr(p, sp, flagexprs);\n         }\n \n-        fn make_count(parser p, common.span sp, &count cnt) -> @ast.expr {\n+        fn make_count(parser p, common::span sp, &count cnt) -> @ast::expr {\n             alt (cnt) {\n                 case (count_implied) {\n                     ret make_rt_path_expr(p, sp, \"count_implied\");\n@@ -228,7 +228,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n             }\n         }\n \n-        fn make_ty(parser p, common.span sp, &ty t) -> @ast.expr {\n+        fn make_ty(parser p, common::span sp, &ty t) -> @ast::expr {\n             auto rt_type;\n             alt (t) {\n                 case (ty_hex(?c)) {\n@@ -256,11 +256,11 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n         }\n \n         fn make_conv_rec(parser p,\n-                         common.span sp,\n-                         @ast.expr flags_expr,\n-                         @ast.expr width_expr,\n-                         @ast.expr precision_expr,\n-                         @ast.expr ty_expr) -> @ast.expr {\n+                         common::span sp,\n+                         @ast::expr flags_expr,\n+                         @ast::expr width_expr,\n+                         @ast::expr precision_expr,\n+                         @ast::expr ty_expr) -> @ast::expr {\n             ret make_rec_expr(p, sp, vec(tup(\"flags\", flags_expr),\n                                          tup(\"width\", width_expr),\n                                          tup(\"precision\", precision_expr),\n@@ -279,18 +279,18 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n                           rt_conv_ty);\n     }\n \n-    fn make_conv_call(parser p, common.span sp, str conv_type,\n-                      &conv cnv, @ast.expr arg) -> @ast.expr {\n+    fn make_conv_call(parser p, common::span sp, str conv_type,\n+                      &conv cnv, @ast::expr arg) -> @ast::expr {\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n         auto cnv_expr = make_rt_conv_expr(p, sp, cnv);\n         auto args = vec(cnv_expr, arg);\n         ret make_call(p, arg.span, path, args);\n     }\n \n-    fn make_new_conv(parser p, conv cnv, @ast.expr arg) -> @ast.expr {\n+    fn make_new_conv(parser p, conv cnv, @ast::expr arg) -> @ast::expr {\n \n-        // FIXME: Extract all this validation into ExtFmt.CT\n+        // FIXME: Extract all this validation into extfmt::CT\n         fn is_signed_type(conv cnv) -> bool {\n             alt (cnv.ty) {\n                 case (ty_int(?s)) {\n@@ -312,7 +312,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n         auto unsupported = \"conversion not supported in #fmt string\";\n \n         alt (cnv.param) {\n-            case (Option.none[int]) {\n+            case (option::none[int]) {\n             }\n             case (_) {\n                 log_err unsupported;\n@@ -407,7 +407,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n     fn log_conv(conv c) {\n         alt (c.param) {\n             case (some[int](?p)) {\n-                log \"param: \" + std.Int.to_str(p, 10u);\n+                log \"param: \" + std::_int::to_str(p, 10u);\n             }\n             case (_) {\n                 log \"param: none\";\n@@ -434,10 +434,10 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n         }\n         alt (c.width) {\n             case (count_is(?i)) {\n-                log \"width: count is \" + std.Int.to_str(i, 10u);\n+                log \"width: count is \" + std::_int::to_str(i, 10u);\n             }\n             case (count_is_param(?i)) {\n-                log \"width: count is param \" + std.Int.to_str(i, 10u);\n+                log \"width: count is param \" + std::_int::to_str(i, 10u);\n             }\n             case (count_is_next_param) {\n                 log \"width: count is next param\";\n@@ -448,10 +448,10 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n         }\n         alt (c.precision) {\n             case (count_is(?i)) {\n-                log \"prec: count is \" + std.Int.to_str(i, 10u);\n+                log \"prec: count is \" + std::_int::to_str(i, 10u);\n             }\n             case (count_is_param(?i)) {\n-                log \"prec: count is param \" + std.Int.to_str(i, 10u);\n+                log \"prec: count is param \" + std::_int::to_str(i, 10u);\n             }\n             case (count_is_next_param) {\n                 log \"prec: count is next param\";\n@@ -507,7 +507,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n                 tmp_expr = make_add_expr(p, sp, tmp_expr, s_expr);\n             }\n             case (piece_conv(?conv)) {\n-                if (n >= Vec.len[@ast.expr](args)) {\n+                if (n >= _vec::len[@ast::expr](args)) {\n                     log_err \"too many conversions in #fmt string\";\n                     fail;\n                 }\n@@ -526,7 +526,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n \n     // TODO: Remove this debug logging\n     // log \"dumping expanded ast:\";\n-    // log pretty.print_expr(tmp_expr);\n+    // log pretty::print_expr(tmp_expr);\n     ret tmp_expr;\n }\n "}, {"sha": "f01d782ab9645705c09c52feff05d04af4efcca3", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 198, "deletions": 198, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,15 +1,15 @@\n-import std.IO;\n-import std.Str;\n-import std.Vec;\n-import std.Int;\n-import std.Map;\n-import std.Map.hashmap;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-import driver.session.session;\n-import util.common;\n-import util.common.new_str_hash;\n+import std::io;\n+import std::_str;\n+import std::_vec;\n+import std::_int;\n+import std::map;\n+import std::map::hashmap;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import driver::session::session;\n+import util::common;\n+import util::common::new_str_hash;\n \n state type reader = state obj {\n     fn is_eof() -> bool;\n@@ -19,17 +19,17 @@ state type reader = state obj {\n     fn bump();\n     fn mark();\n     fn get_mark_chpos() -> uint;\n-    fn add_str(str) -> token.str_num;\n-    fn get_str(token.str_num) -> str;\n+    fn add_str(str) -> token::str_num;\n+    fn get_str(token::str_num) -> str;\n     fn get_chpos() -> uint;\n-    fn get_keywords() -> hashmap[str,token.token];\n+    fn get_keywords() -> hashmap[str,token::token];\n     fn get_reserved() -> hashmap[str,()];\n-    fn get_filemap() -> codemap.filemap;\n+    fn get_filemap() -> codemap::filemap;\n     fn err(str m);\n };\n \n-fn new_reader(session sess, IO.reader rdr,\n-              codemap.filemap filemap) -> reader {\n+fn new_reader(session sess, io::reader rdr,\n+              codemap::filemap filemap) -> reader {\n \n     state obj reader(session sess,\n                      str file,\n@@ -39,9 +39,9 @@ fn new_reader(session sess, IO.reader rdr,\n                      mutable uint mark_chpos,\n                      mutable uint chpos,\n                      mutable vec[str] strs,\n-                     hashmap[str,token.token] keywords,\n+                     hashmap[str,token::token] keywords,\n                      hashmap[str,()] reserved,\n-                     codemap.filemap fm) {\n+                     codemap::filemap fm) {\n \n         fn is_eof() -> bool {\n             ret ch == -1 as char;\n@@ -56,13 +56,13 @@ fn new_reader(session sess, IO.reader rdr,\n         }\n \n         fn next() -> char {\n-            if (pos < len) {ret Str.char_at(file, pos);}\n+            if (pos < len) {ret _str::char_at(file, pos);}\n             else {ret -1 as char;}\n         }\n \n         fn init() {\n             if (pos < len) {\n-                auto next = Str.char_range_at(file, pos);\n+                auto next = _str::char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             }\n@@ -72,44 +72,44 @@ fn new_reader(session sess, IO.reader rdr,\n             if (pos < len) {\n                 chpos += 1u;\n                 if (ch == '\\n') {\n-                    codemap.next_line(fm, chpos);\n+                    codemap::next_line(fm, chpos);\n                 }\n-                auto next = Str.char_range_at(file, pos);\n+                auto next = _str::char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             } else {\n                 ch = -1 as char;\n             }\n         }\n \n-        fn get_keywords() -> hashmap[str,token.token] {\n+        fn get_keywords() -> hashmap[str,token::token] {\n             ret keywords;\n         }\n \n-        fn add_str(str s) -> token.str_num {\n+        fn add_str(str s) -> token::str_num {\n             strs += vec(s);\n-            ret Vec.len[str](strs) - 1u;\n+            ret _vec::len[str](strs) - 1u;\n         }\n \n-        fn get_str(token.str_num i) -> str {\n+        fn get_str(token::str_num i) -> str {\n             ret strs.(i);\n         }\n \n         fn get_reserved() -> hashmap[str,()] {\n             ret reserved;\n         }\n \n-        fn get_filemap() -> codemap.filemap {\n+        fn get_filemap() -> codemap::filemap {\n             ret fm;\n         }\n \n         fn err(str m) {\n             sess.span_err(rec(lo=chpos, hi=chpos), m);\n         }\n     }\n-    auto file = Str.unsafe_from_bytes(rdr.read_whole_stream());\n+    auto file = _str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = vec();\n-    auto rd = reader(sess, file, Str.byte_len(file), 0u, -1 as char,\n+    auto rd = reader(sess, file, _str::byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n                      strs, keyword_table(),\n                      reserved_word_table(),\n@@ -118,115 +118,115 @@ fn new_reader(session sess, IO.reader rdr,\n     ret rd;\n }\n \n-fn keyword_table() -> std.Map.hashmap[str, token.token] {\n-    auto keywords = new_str_hash[token.token]();\n+fn keyword_table() -> std::map::hashmap[str, token::token] {\n+    auto keywords = new_str_hash[token::token]();\n \n-    keywords.insert(\"mod\", token.MOD);\n-    keywords.insert(\"use\", token.USE);\n-    keywords.insert(\"meta\", token.META);\n-    keywords.insert(\"auth\", token.AUTH);\n+    keywords.insert(\"mod\", token::MOD);\n+    keywords.insert(\"use\", token::USE);\n+    keywords.insert(\"meta\", token::META);\n+    keywords.insert(\"auth\", token::AUTH);\n \n-    keywords.insert(\"syntax\", token.SYNTAX);\n+    keywords.insert(\"syntax\", token::SYNTAX);\n \n-    keywords.insert(\"if\", token.IF);\n-    keywords.insert(\"else\", token.ELSE);\n-    keywords.insert(\"while\", token.WHILE);\n-    keywords.insert(\"do\", token.DO);\n-    keywords.insert(\"alt\", token.ALT);\n-    keywords.insert(\"case\", token.CASE);\n+    keywords.insert(\"if\", token::IF);\n+    keywords.insert(\"else\", token::ELSE);\n+    keywords.insert(\"while\", token::WHILE);\n+    keywords.insert(\"do\", token::DO);\n+    keywords.insert(\"alt\", token::ALT);\n+    keywords.insert(\"case\", token::CASE);\n \n-    keywords.insert(\"for\", token.FOR);\n-    keywords.insert(\"each\", token.EACH);\n-    keywords.insert(\"break\", token.BREAK);\n-    keywords.insert(\"cont\", token.CONT);\n-    keywords.insert(\"put\", token.PUT);\n-    keywords.insert(\"ret\", token.RET);\n-    keywords.insert(\"be\", token.BE);\n+    keywords.insert(\"for\", token::FOR);\n+    keywords.insert(\"each\", token::EACH);\n+    keywords.insert(\"break\", token::BREAK);\n+    keywords.insert(\"cont\", token::CONT);\n+    keywords.insert(\"put\", token::PUT);\n+    keywords.insert(\"ret\", token::RET);\n+    keywords.insert(\"be\", token::BE);\n \n-    keywords.insert(\"fail\", token.FAIL);\n-    keywords.insert(\"drop\", token.DROP);\n+    keywords.insert(\"fail\", token::FAIL);\n+    keywords.insert(\"drop\", token::DROP);\n \n-    keywords.insert(\"type\", token.TYPE);\n-    keywords.insert(\"check\", token.CHECK);\n-    keywords.insert(\"assert\", token.ASSERT);\n-    keywords.insert(\"claim\", token.CLAIM);\n-    keywords.insert(\"prove\", token.PROVE);\n+    keywords.insert(\"type\", token::TYPE);\n+    keywords.insert(\"check\", token::CHECK);\n+    keywords.insert(\"assert\", token::ASSERT);\n+    keywords.insert(\"claim\", token::CLAIM);\n+    keywords.insert(\"prove\", token::PROVE);\n \n-    keywords.insert(\"state\", token.STATE);\n-    keywords.insert(\"gc\", token.GC);\n+    keywords.insert(\"state\", token::STATE);\n+    keywords.insert(\"gc\", token::GC);\n \n-    keywords.insert(\"unsafe\", token.UNSAFE);\n+    keywords.insert(\"unsafe\", token::UNSAFE);\n \n-    keywords.insert(\"native\", token.NATIVE);\n-    keywords.insert(\"mutable\", token.MUTABLE);\n-    keywords.insert(\"auto\", token.AUTO);\n+    keywords.insert(\"native\", token::NATIVE);\n+    keywords.insert(\"mutable\", token::MUTABLE);\n+    keywords.insert(\"auto\", token::AUTO);\n \n-    keywords.insert(\"fn\", token.FN);\n-    keywords.insert(\"pred\", token.PRED);\n-    keywords.insert(\"iter\", token.ITER);\n+    keywords.insert(\"fn\", token::FN);\n+    keywords.insert(\"pred\", token::PRED);\n+    keywords.insert(\"iter\", token::ITER);\n \n-    keywords.insert(\"import\", token.IMPORT);\n-    keywords.insert(\"export\", token.EXPORT);\n+    keywords.insert(\"import\", token::IMPORT);\n+    keywords.insert(\"export\", token::EXPORT);\n \n-    keywords.insert(\"let\", token.LET);\n-    keywords.insert(\"const\", token.CONST);\n+    keywords.insert(\"let\", token::LET);\n+    keywords.insert(\"const\", token::CONST);\n \n-    keywords.insert(\"log\", token.LOG);\n-    keywords.insert(\"log_err\", token.LOG_ERR);\n-    keywords.insert(\"spawn\", token.SPAWN);\n-    keywords.insert(\"thread\", token.THREAD);\n-    keywords.insert(\"yield\", token.YIELD);\n-    keywords.insert(\"join\", token.JOIN);\n+    keywords.insert(\"log\", token::LOG);\n+    keywords.insert(\"log_err\", token::LOG_ERR);\n+    keywords.insert(\"spawn\", token::SPAWN);\n+    keywords.insert(\"thread\", token::THREAD);\n+    keywords.insert(\"yield\", token::YIELD);\n+    keywords.insert(\"join\", token::JOIN);\n \n-    keywords.insert(\"bool\", token.BOOL);\n+    keywords.insert(\"bool\", token::BOOL);\n \n-    keywords.insert(\"int\", token.INT);\n-    keywords.insert(\"uint\", token.UINT);\n-    keywords.insert(\"float\", token.FLOAT);\n+    keywords.insert(\"int\", token::INT);\n+    keywords.insert(\"uint\", token::UINT);\n+    keywords.insert(\"float\", token::FLOAT);\n \n-    keywords.insert(\"char\", token.CHAR);\n-    keywords.insert(\"str\", token.STR);\n+    keywords.insert(\"char\", token::CHAR);\n+    keywords.insert(\"str\", token::STR);\n \n \n-    keywords.insert(\"rec\", token.REC);\n-    keywords.insert(\"tup\", token.TUP);\n-    keywords.insert(\"tag\", token.TAG);\n-    keywords.insert(\"vec\", token.VEC);\n-    keywords.insert(\"any\", token.ANY);\n+    keywords.insert(\"rec\", token::REC);\n+    keywords.insert(\"tup\", token::TUP);\n+    keywords.insert(\"tag\", token::TAG);\n+    keywords.insert(\"vec\", token::VEC);\n+    keywords.insert(\"any\", token::ANY);\n \n-    keywords.insert(\"obj\", token.OBJ);\n-    keywords.insert(\"self\", token.SELF);\n+    keywords.insert(\"obj\", token::OBJ);\n+    keywords.insert(\"self\", token::SELF);\n \n-    keywords.insert(\"port\", token.PORT);\n-    keywords.insert(\"chan\", token.CHAN);\n+    keywords.insert(\"port\", token::PORT);\n+    keywords.insert(\"chan\", token::CHAN);\n \n-    keywords.insert(\"task\", token.TASK);\n+    keywords.insert(\"task\", token::TASK);\n \n-    keywords.insert(\"true\", token.LIT_BOOL(true));\n-    keywords.insert(\"false\", token.LIT_BOOL(false));\n+    keywords.insert(\"true\", token::LIT_BOOL(true));\n+    keywords.insert(\"false\", token::LIT_BOOL(false));\n \n-    keywords.insert(\"in\", token.IN);\n+    keywords.insert(\"in\", token::IN);\n \n-    keywords.insert(\"as\", token.AS);\n-    keywords.insert(\"with\", token.WITH);\n+    keywords.insert(\"as\", token::AS);\n+    keywords.insert(\"with\", token::WITH);\n \n-    keywords.insert(\"bind\", token.BIND);\n+    keywords.insert(\"bind\", token::BIND);\n \n-    keywords.insert(\"u8\", token.MACH(common.ty_u8));\n-    keywords.insert(\"u16\", token.MACH(common.ty_u16));\n-    keywords.insert(\"u32\", token.MACH(common.ty_u32));\n-    keywords.insert(\"u64\", token.MACH(common.ty_u64));\n-    keywords.insert(\"i8\", token.MACH(common.ty_i8));\n-    keywords.insert(\"i16\", token.MACH(common.ty_i16));\n-    keywords.insert(\"i32\", token.MACH(common.ty_i32));\n-    keywords.insert(\"i64\", token.MACH(common.ty_i64));\n-    keywords.insert(\"f32\", token.MACH(common.ty_f32));\n-    keywords.insert(\"f64\", token.MACH(common.ty_f64));\n+    keywords.insert(\"u8\", token::MACH(common::ty_u8));\n+    keywords.insert(\"u16\", token::MACH(common::ty_u16));\n+    keywords.insert(\"u32\", token::MACH(common::ty_u32));\n+    keywords.insert(\"u64\", token::MACH(common::ty_u64));\n+    keywords.insert(\"i8\", token::MACH(common::ty_i8));\n+    keywords.insert(\"i16\", token::MACH(common::ty_i16));\n+    keywords.insert(\"i32\", token::MACH(common::ty_i32));\n+    keywords.insert(\"i64\", token::MACH(common::ty_i64));\n+    keywords.insert(\"f32\", token::MACH(common::ty_f32));\n+    keywords.insert(\"f64\", token::MACH(common::ty_f64));\n \n     ret keywords;\n }\n \n-fn reserved_word_table() -> std.Map.hashmap[str, ()] {\n+fn reserved_word_table() -> std::map::hashmap[str, ()] {\n     auto reserved = new_str_hash[()]();\n     reserved.insert(\"f16\", ());  // IEEE 754-2008 'binary16' interchange fmt\n     reserved.insert(\"f80\", ());  // IEEE 754-1985 'extended'\n@@ -362,20 +362,20 @@ fn digits_to_string(str s) -> int {\n     ret accum_int;\n }\n \n-fn scan_exponent(reader rdr) -> Option.t[str] {\n+fn scan_exponent(reader rdr) -> option::t[str] {\n     auto c = rdr.curr();\n     auto res = \"\";\n \n     if (c == 'e' || c == 'E') {\n-        res += Str.from_bytes(vec(c as u8));\n+        res += _str::from_bytes(vec(c as u8));\n         rdr.bump();\n         c = rdr.curr();\n         if (c == '-' || c == '+') {\n-            res += Str.from_bytes(vec(c as u8));\n+            res += _str::from_bytes(vec(c as u8));\n             rdr.bump();\n         }\n         auto exponent = scan_dec_digits(rdr);\n-        if (Str.byte_len(exponent) > 0u) {\n+        if (_str::byte_len(exponent) > 0u) {\n             ret(some(res + exponent));\n         }\n         else {\n@@ -395,7 +395,7 @@ fn scan_dec_digits(reader rdr) -> str {\n \n     while (is_dec_digit (c) || c == '_') {\n         if (c != '_') {\n-            res += Str.from_bytes(vec(c as u8));\n+            res += _str::from_bytes(vec(c as u8));\n         }\n         rdr.bump();\n         c = rdr.curr();\n@@ -404,7 +404,7 @@ fn scan_dec_digits(reader rdr) -> str {\n     ret res;\n }\n \n-fn scan_number(char c, reader rdr) -> token.token {\n+fn scan_number(char c, reader rdr) -> token::token {\n     auto accum_int = 0;\n     let str dec_str = \"\";\n     let bool is_dec_integer = false;\n@@ -453,9 +453,9 @@ fn scan_number(char c, reader rdr) -> token.token {\n         if (c == '8') {\n             rdr.bump();\n             if (signed) {\n-                ret token.LIT_MACH_INT(common.ty_i8, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_i8, accum_int);\n             } else {\n-                ret token.LIT_MACH_INT(common.ty_u8, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_u8, accum_int);\n             }\n         }\n \n@@ -464,36 +464,36 @@ fn scan_number(char c, reader rdr) -> token.token {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n-                ret token.LIT_MACH_INT(common.ty_i16, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_i16, accum_int);\n             } else {\n-                ret token.LIT_MACH_INT(common.ty_u16, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_u16, accum_int);\n             }\n         }\n         if (c == '3' && n == '2') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n-                ret token.LIT_MACH_INT(common.ty_i32, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_i32, accum_int);\n             } else {\n-                ret token.LIT_MACH_INT(common.ty_u32, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_u32, accum_int);\n             }\n         }\n \n         if (c == '6' && n == '4') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n-                ret token.LIT_MACH_INT(common.ty_i64, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_i64, accum_int);\n             } else {\n-                ret token.LIT_MACH_INT(common.ty_u64, accum_int);\n+                ret token::LIT_MACH_INT(common::ty_u64, accum_int);\n             }\n         }\n \n         if (signed) {\n-            ret token.LIT_INT(accum_int);\n+            ret token::LIT_INT(accum_int);\n         } else {\n             // FIXME: should cast in the target bit-width.\n-            ret token.LIT_UINT(accum_int as uint);\n+            ret token::LIT_UINT(accum_int as uint);\n         }\n     }\n     c = rdr.curr();\n@@ -520,29 +520,29 @@ fn scan_number(char c, reader rdr) -> token.token {\n             n = rdr.next();\n             if (c == '3' && n == '2') {\n                 rdr.bump(); rdr.bump();\n-                ret token.LIT_MACH_FLOAT(util.common.ty_f32,\n+                ret token::LIT_MACH_FLOAT(util::common::ty_f32,\n                                          rdr.add_str(float_str));\n             }\n             else if (c == '6' && n == '4') {\n                 rdr.bump(); rdr.bump();\n-                ret token.LIT_MACH_FLOAT(util.common.ty_f64,\n+                ret token::LIT_MACH_FLOAT(util::common::ty_f64,\n                                          rdr.add_str(float_str));\n                 /* FIXME: if this is out of range for either a 32-bit or\n                    64-bit float, it won't be noticed till the back-end */\n             }\n         }\n         else {\n-            ret token.LIT_FLOAT(rdr.add_str(float_str));\n+            ret token::LIT_FLOAT(rdr.add_str(float_str));\n         }\n     }\n \n     auto maybe_exponent = scan_exponent(rdr);\n     alt(maybe_exponent) {\n         case(some[str](?s)) {\n-            ret token.LIT_FLOAT(rdr.add_str(dec_str + s));\n+            ret token::LIT_FLOAT(rdr.add_str(dec_str + s));\n         }\n         case(none[str]) {\n-                ret token.LIT_INT(accum_int);\n+                ret token::LIT_INT(accum_int);\n         }\n     }\n }\n@@ -583,25 +583,25 @@ fn scan_numeric_escape(reader rdr) -> char {\n }\n \n \n-fn next_token(reader rdr) -> token.token {\n+fn next_token(reader rdr) -> token::token {\n     auto accum_str = \"\";\n \n     consume_any_whitespace(rdr);\n \n-    if (rdr.is_eof()) { ret token.EOF; }\n+    if (rdr.is_eof()) { ret token::EOF; }\n \n     rdr.mark();\n     auto c = rdr.curr();\n \n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n-            Str.push_char(accum_str, c);\n+            _str::push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n \n-        if (Str.eq(accum_str, \"_\")) {\n-            ret token.UNDERSCORE;\n+        if (_str::eq(accum_str, \"_\")) {\n+            ret token::UNDERSCORE;\n         }\n \n         auto kwds = rdr.get_keywords();\n@@ -615,46 +615,46 @@ fn next_token(reader rdr) -> token.token {\n             fail;\n         }\n \n-        ret token.IDENT(rdr.add_str(accum_str));\n+        ret token::IDENT(rdr.add_str(accum_str));\n     }\n \n     if (is_dec_digit(c)) {\n         ret scan_number(c, rdr);\n     }\n \n-    fn binop(reader rdr, token.binop op) -> token.token {\n+    fn binop(reader rdr, token::binop op) -> token::token {\n         rdr.bump();\n         if (rdr.curr() == '=') {\n             rdr.bump();\n-            ret token.BINOPEQ(op);\n+            ret token::BINOPEQ(op);\n         } else {\n-            ret token.BINOP(op);\n+            ret token::BINOP(op);\n         }\n     }\n \n     alt (c) {\n         // One-byte tokens.\n-        case ('?') { rdr.bump(); ret token.QUES; }\n-        case (';') { rdr.bump(); ret token.SEMI; }\n-        case (',') { rdr.bump(); ret token.COMMA; }\n-        case ('.') { rdr.bump(); ret token.DOT; }\n-        case ('(') { rdr.bump(); ret token.LPAREN; }\n-        case (')') { rdr.bump(); ret token.RPAREN; }\n-        case ('{') { rdr.bump(); ret token.LBRACE; }\n-        case ('}') { rdr.bump(); ret token.RBRACE; }\n-        case ('[') { rdr.bump(); ret token.LBRACKET; }\n-        case (']') { rdr.bump(); ret token.RBRACKET; }\n-        case ('@') { rdr.bump(); ret token.AT; }\n-        case ('#') { rdr.bump(); ret token.POUND; }\n-        case ('~') { rdr.bump(); ret token.TILDE; }\n+        case ('?') { rdr.bump(); ret token::QUES; }\n+        case (';') { rdr.bump(); ret token::SEMI; }\n+        case (',') { rdr.bump(); ret token::COMMA; }\n+        case ('.') { rdr.bump(); ret token::DOT; }\n+        case ('(') { rdr.bump(); ret token::LPAREN; }\n+        case (')') { rdr.bump(); ret token::RPAREN; }\n+        case ('{') { rdr.bump(); ret token::LBRACE; }\n+        case ('}') { rdr.bump(); ret token::RBRACE; }\n+        case ('[') { rdr.bump(); ret token::LBRACKET; }\n+        case (']') { rdr.bump(); ret token::RBRACKET; }\n+        case ('@') { rdr.bump(); ret token::AT; }\n+        case ('#') { rdr.bump(); ret token::POUND; }\n+        case ('~') { rdr.bump(); ret token::TILDE; }\n         case (':') {\n             rdr.bump();\n             if (rdr.curr() == ':') {\n                 rdr.bump();\n-                ret token.MOD_SEP;\n+                ret token::MOD_SEP;\n             }\n             else {\n-                ret token.COLON;\n+                ret token::COLON;\n             };\n         }\n \n@@ -663,19 +663,19 @@ fn next_token(reader rdr) -> token.token {\n             rdr.bump();\n             if (rdr.curr() == '=') {\n                 rdr.bump();\n-                ret token.EQEQ;\n+                ret token::EQEQ;\n             } else {\n-                ret token.EQ;\n+                ret token::EQ;\n             }\n         }\n \n         case ('!') {\n             rdr.bump();\n             if (rdr.curr() == '=') {\n                 rdr.bump();\n-                ret token.NE;\n+                ret token::NE;\n             } else {\n-                ret token.NOT;\n+                ret token::NOT;\n             }\n         }\n \n@@ -684,21 +684,21 @@ fn next_token(reader rdr) -> token.token {\n             alt (rdr.curr()) {\n                 case ('=') {\n                     rdr.bump();\n-                    ret token.LE;\n+                    ret token::LE;\n                 }\n                 case ('<') {\n-                    ret binop(rdr, token.LSL);\n+                    ret binop(rdr, token::LSL);\n                 }\n                 case ('-') {\n                     rdr.bump();\n-                    ret token.LARROW;\n+                    ret token::LARROW;\n                 }\n                 case ('|') {\n                     rdr.bump();\n-                    ret token.SEND;\n+                    ret token::SEND;\n                 }\n                 case (_) {\n-                    ret token.LT;\n+                    ret token::LT;\n                 }\n             }\n         }\n@@ -708,20 +708,20 @@ fn next_token(reader rdr) -> token.token {\n             alt (rdr.curr()) {\n                 case ('=') {\n                     rdr.bump();\n-                    ret token.GE;\n+                    ret token::GE;\n                 }\n \n                 case ('>') {\n                     if (rdr.next() == '>') {\n                         rdr.bump();\n-                        ret binop(rdr, token.ASR);\n+                        ret binop(rdr, token::ASR);\n                     } else {\n-                        ret binop(rdr, token.LSR);\n+                        ret binop(rdr, token::LSR);\n                     }\n                 }\n \n                 case (_) {\n-                    ret token.GT;\n+                    ret token::GT;\n                 }\n             }\n         }\n@@ -756,7 +756,7 @@ fn next_token(reader rdr) -> token.token {\n             }\n             rdr.bump(); // advance curr to closing '\n             rdr.bump(); // advance curr past token\n-            ret token.LIT_CHAR(c2);\n+            ret token::LIT_CHAR(c2);\n         }\n \n         case ('\"') {\n@@ -767,37 +767,37 @@ fn next_token(reader rdr) -> token.token {\n                         alt (rdr.next()) {\n                             case ('n') {\n                                 rdr.bump();\n-                                Str.push_byte(accum_str, '\\n' as u8);\n+                                _str::push_byte(accum_str, '\\n' as u8);\n                             }\n                             case ('r') {\n                                 rdr.bump();\n-                                Str.push_byte(accum_str, '\\r' as u8);\n+                                _str::push_byte(accum_str, '\\r' as u8);\n                             }\n                             case ('t') {\n                                 rdr.bump();\n-                                Str.push_byte(accum_str, '\\t' as u8);\n+                                _str::push_byte(accum_str, '\\t' as u8);\n                             }\n                             case ('\\\\') {\n                                 rdr.bump();\n-                                Str.push_byte(accum_str, '\\\\' as u8);\n+                                _str::push_byte(accum_str, '\\\\' as u8);\n                             }\n                             case ('\"') {\n                                 rdr.bump();\n-                                Str.push_byte(accum_str, '\"' as u8);\n+                                _str::push_byte(accum_str, '\"' as u8);\n                             }\n \n                             case ('x') {\n-                                Str.push_char(accum_str,\n+                                _str::push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n                             case ('u') {\n-                                Str.push_char(accum_str,\n+                                _str::push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n                             case ('U') {\n-                                Str.push_char(accum_str,\n+                                _str::push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n@@ -809,63 +809,63 @@ fn next_token(reader rdr) -> token.token {\n                         }\n                     }\n                     case (_) {\n-                        Str.push_char(accum_str, rdr.curr());\n+                        _str::push_char(accum_str, rdr.curr());\n                     }\n                 }\n                 rdr.bump();\n             }\n             rdr.bump();\n-            ret token.LIT_STR(rdr.add_str(accum_str));\n+            ret token::LIT_STR(rdr.add_str(accum_str));\n         }\n \n         case ('-') {\n             if (rdr.next() == '>') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token.RARROW;\n+                ret token::RARROW;\n             } else {\n-                ret binop(rdr, token.MINUS);\n+                ret binop(rdr, token::MINUS);\n             }\n         }\n \n         case ('&') {\n             if (rdr.next() == '&') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token.ANDAND;\n+                ret token::ANDAND;\n             } else {\n-                ret binop(rdr, token.AND);\n+                ret binop(rdr, token::AND);\n             }\n         }\n \n         case ('|') {\n             if (rdr.next() == '|') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token.OROR;\n+                ret token::OROR;\n             } else {\n-                ret binop(rdr, token.OR);\n+                ret binop(rdr, token::OR);\n             }\n         }\n \n         case ('+') {\n-            ret binop(rdr, token.PLUS);\n+            ret binop(rdr, token::PLUS);\n         }\n \n         case ('*') {\n-            ret binop(rdr, token.STAR);\n+            ret binop(rdr, token::STAR);\n         }\n \n         case ('/') {\n-            ret binop(rdr, token.SLASH);\n+            ret binop(rdr, token::SLASH);\n         }\n \n         case ('^') {\n-            ret binop(rdr, token.CARET);\n+            ret binop(rdr, token::CARET);\n         }\n \n         case ('%') {\n-            ret binop(rdr, token.PERCENT);\n+            ret binop(rdr, token::PERCENT);\n         }\n \n         case (?c) {\n@@ -899,7 +899,7 @@ fn read_line_comment(reader rdr) -> cmnt {\n     while (rdr.curr() == ' ') {rdr.bump();}\n     auto val = \"\";\n     while (rdr.curr() != '\\n' && !rdr.is_eof()) {\n-        Str.push_char(val, rdr.curr());\n+        _str::push_char(val, rdr.curr());\n         rdr.bump();\n     }\n     ret rec(val=cmnt_line(val),\n@@ -916,21 +916,21 @@ fn read_block_comment(reader rdr) -> cmnt {\n     auto level = 1;\n     while (true) {\n         if (rdr.curr() == '\\n') {\n-            Vec.push[str](lines, val);\n+            _vec::push[str](lines, val);\n             val = \"\";\n             consume_whitespace(rdr);\n         } else {\n             if (rdr.curr() == '*' && rdr.next() == '/') {\n                 level -= 1;\n                 if (level == 0) {\n                     rdr.bump(); rdr.bump();\n-                    Vec.push[str](lines, val);\n+                    _vec::push[str](lines, val);\n                     break;\n                 }\n             } else if (rdr.curr() == '/' && rdr.next() == '*') {\n                 level += 1;\n             }\n-            Str.push_char(val, rdr.curr());\n+            _str::push_char(val, rdr.curr());\n             rdr.bump();\n         }\n         if (rdr.is_eof()) {\n@@ -944,16 +944,16 @@ fn read_block_comment(reader rdr) -> cmnt {\n }\n \n fn gather_comments(session sess, str path) -> vec[cmnt] {\n-    auto srdr = IO.file_reader(path);\n-    auto rdr = new_reader(sess, srdr, codemap.new_filemap(path, 0u));\n+    auto srdr = io::file_reader(path);\n+    auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u));\n     let vec[cmnt] comments = vec();\n     while (!rdr.is_eof()) {\n         while (true) {\n             consume_whitespace(rdr);\n             if (rdr.curr() == '/' && rdr.next() == '/') {\n-                Vec.push[cmnt](comments, read_line_comment(rdr));\n+                _vec::push[cmnt](comments, read_line_comment(rdr));\n             } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-                Vec.push[cmnt](comments, read_block_comment(rdr));\n+                _vec::push[cmnt](comments, read_block_comment(rdr));\n             } else { break; }\n         }\n         next_token(rdr);"}, {"sha": "5292c49c22dafe4490b40ea2dd371a29d2a2214b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 808, "deletions": 807, "changes": 1615, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2"}, {"sha": "60091afc11272e224f58508e8ea21077fb66a598", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,9 +1,9 @@\n-import util.common.ty_mach;\n-import util.common.ty_mach_to_str;\n-import util.common.new_str_hash;\n-import std.Int;\n-import std.UInt;\n-import std.Str;\n+import util::common::ty_mach;\n+import util::common::ty_mach_to_str;\n+import util::common::new_str_hash;\n+import std::_int;\n+import std::_uint;\n+import std::_str;\n \n type str_num = uint;\n \n@@ -191,7 +191,7 @@ fn binop_to_str(binop o) -> str {\n     }\n }\n \n-fn to_str(lexer.reader r, token t) -> str {\n+fn to_str(lexer::reader r, token t) -> str {\n     alt (t) {\n \n         case (EQ) { ret \"=\"; }\n@@ -299,10 +299,10 @@ fn to_str(lexer.reader r, token t) -> str {\n         case (JOIN) { ret \"join\"; }\n \n         /* Literals */\n-        case (LIT_INT(?i)) { ret Int.to_str(i, 10u); }\n-        case (LIT_UINT(?u)) { ret UInt.to_str(u, 10u); }\n+        case (LIT_INT(?i)) { ret _int::to_str(i, 10u); }\n+        case (LIT_UINT(?u)) { ret _uint::to_str(u, 10u); }\n         case (LIT_MACH_INT(?tm, ?i)) {\n-            ret  Int.to_str(i, 10u)\n+            ret  _int::to_str(i, 10u)\n                 + \"_\" + ty_mach_to_str(tm);\n         }\n         case (LIT_MACH_FLOAT(?tm, ?s)) {\n@@ -317,8 +317,8 @@ fn to_str(lexer.reader r, token t) -> str {\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape.\n             auto tmp = \"'\";\n-            Str.push_char(tmp, c);\n-            Str.push_byte(tmp, '\\'' as u8);\n+            _str::push_char(tmp, c);\n+            _str::push_byte(tmp, '\\'' as u8);\n             ret tmp;\n         }\n \n@@ -332,7 +332,7 @@ fn to_str(lexer.reader r, token t) -> str {\n             si += r.get_str(s);\n             ret si;\n         }\n-        case (IDX(?i)) { ret \"_\" + Int.to_str(i, 10u); }\n+        case (IDX(?i)) { ret \"_\" + _int::to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n \n         /* Reserved type names */"}, {"sha": "ba607d3e046dc588751deab69e81c33cf7930d65", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 187, "deletions": 184, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,29 +1,29 @@\n-import std.Vec;\n-import std.Str;\n-import std.Str.rustrt.sbuf;\n-import std.Vec.rustrt.vbuf;\n-\n-import llvm.ModuleRef;\n-import llvm.ContextRef;\n-import llvm.TypeRef;\n-import llvm.TypeHandleRef;\n-import llvm.ValueRef;\n-import llvm.BasicBlockRef;\n-import llvm.BuilderRef;\n-import llvm.ModuleProviderRef;\n-import llvm.MemoryBufferRef;\n-import llvm.PassManagerRef;\n-import llvm.UseRef;\n-import llvm.TargetDataRef;\n-import llvm.Linkage;\n-import llvm.Attribute;\n-import llvm.Visibility;\n-import llvm.CallConv;\n-import llvm.IntPredicate;\n-import llvm.RealPredicate;\n-import llvm.Opcode;\n-import llvm.ObjectFileRef;\n-import llvm.SectionIteratorRef;\n+import std::_vec;\n+import std::_str;\n+import std::_str::rustrt::sbuf;\n+import std::_vec::rustrt::vbuf;\n+\n+import llvm::ModuleRef;\n+import llvm::ContextRef;\n+import llvm::TypeRef;\n+import llvm::TypeHandleRef;\n+import llvm::ValueRef;\n+import llvm::BasicBlockRef;\n+import llvm::BuilderRef;\n+import llvm::ModuleProviderRef;\n+import llvm::MemoryBufferRef;\n+import llvm::PassManagerRef;\n+import llvm::UseRef;\n+import llvm::TargetDataRef;\n+import llvm::Linkage;\n+import llvm::Attribute;\n+import llvm::Visibility;\n+import llvm::CallConv;\n+import llvm::IntPredicate;\n+import llvm::RealPredicate;\n+import llvm::Opcode;\n+import llvm::ObjectFileRef;\n+import llvm::SectionIteratorRef;\n \n type ULongLong = u64;\n type LongLong = i64;\n@@ -717,7 +717,7 @@ native mod llvm = llvm_lib {\n     fn LLVMBuildSelect(BuilderRef B, ValueRef If,\n                        ValueRef Then, ValueRef Else,\n                        sbuf Name) -> ValueRef;\n-    fn LLVMBuildVAArg(BuilderRef B, ValueRef List, TypeRef Ty,\n+    fn LLVMBuildVAArg(BuilderRef B, ValueRef list, TypeRef Ty,\n                       sbuf Name) -> ValueRef;\n     fn LLVMBuildExtractElement(BuilderRef B, ValueRef VecVal,\n                                ValueRef Index, sbuf Name) -> ValueRef;\n@@ -835,7 +835,7 @@ native mod llvm = llvm_lib {\n     /** Destroys a section iterator. */\n     fn LLVMDisposeSectionIterator(SectionIteratorRef SI);\n     /** Returns true if the section iterator is at the end of the section\n-        List. */\n+        list: */\n     fn LLVMIsSectionIteratorAtEnd(ObjectFileRef ObjectFile,\n                                   SectionIteratorRef SI) -> Bool;\n     /** Moves the section iterator to point to the next section. */\n@@ -868,7 +868,7 @@ native mod llvm = llvm_lib {\n     /** Parses the bitcode in the given memory buffer. */\n     fn LLVMRustParseBitcode(MemoryBufferRef MemBuf) -> ModuleRef;\n \n-    /** FiXME: Hacky adaptor for lack of ULongLong in FFI. */\n+    /** FiXME: Hacky adaptor for lack of ULongLong in FFI: */\n     fn LLVMRustConstSmallInt(TypeRef IntTy, uint N,\n                              Bool SignExtend) -> ValueRef;\n \n@@ -895,46 +895,46 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     fn RetVoid()  -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildRetVoid(B);\n+        ret llvm::LLVMBuildRetVoid(B);\n     }\n \n     fn Ret(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildRet(B, V);\n+        ret llvm::LLVMBuildRet(B, V);\n     }\n \n     fn AggregateRet(vec[ValueRef] RetVals) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildAggregateRet(B,\n-                                       Vec.buf[ValueRef](RetVals),\n-                                       Vec.len[ValueRef](RetVals));\n+        ret llvm::LLVMBuildAggregateRet(B,\n+                                       _vec::buf[ValueRef](RetVals),\n+                                       _vec::len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildBr(B, Dest);\n+        ret llvm::LLVMBuildBr(B, Dest);\n     }\n \n     fn CondBr(ValueRef If, BasicBlockRef Then,\n               BasicBlockRef Else) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildCondBr(B, If, Then, Else);\n+        ret llvm::LLVMBuildCondBr(B, If, Then, Else);\n     }\n \n     fn Switch(ValueRef V, BasicBlockRef Else, uint NumCases) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildSwitch(B, V, Else, NumCases);\n+        ret llvm::LLVMBuildSwitch(B, V, Else, NumCases);\n     }\n \n     fn IndirectBr(ValueRef Addr, uint NumDests) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildIndirectBr(B, Addr, NumDests);\n+        ret llvm::LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n \n     fn Invoke(ValueRef Fn,\n@@ -943,484 +943,486 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n               BasicBlockRef Catch) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildInvoke(B, Fn,\n-                                 Vec.buf[ValueRef](Args),\n-                                 Vec.len[ValueRef](Args),\n+        ret llvm::LLVMBuildInvoke(B, Fn,\n+                                 _vec::buf[ValueRef](Args),\n+                                 _vec::len[ValueRef](Args),\n                                  Then, Catch,\n-                                 Str.buf(\"\"));\n+                                 _str::buf(\"\"));\n     }\n \n     fn Unwind() -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildUnwind(B);\n+        ret llvm::LLVMBuildUnwind(B);\n     }\n \n     fn Unreachable() -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm.LLVMBuildUnreachable(B);\n+        ret llvm::LLVMBuildUnreachable(B);\n     }\n \n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAdd(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildAdd(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNSWAdd(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNUWAdd(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFAdd(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFAdd(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSub(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSub(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWSub(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNSWSub(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWSub(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNUWSub(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFSub(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFSub(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildMul(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildMul(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWMul(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNSWMul(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWMul(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNUWMul(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFMul(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFMul(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildUDiv(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildUDiv(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSDiv(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSDiv(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildExactSDiv(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFDiv(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFDiv(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildURem(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildURem(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSRem(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSRem(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFRem(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFRem(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildShl(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildShl(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildLShr(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildLShr(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAShr(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildAShr(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAnd(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildAnd(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildOr(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildOr(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildXor(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildXor(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildBinOp(B, Op, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNeg(B, V, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNeg(B, V, _str::buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWNeg(B, V, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNSWNeg(B, V, _str::buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWNeg(B, V, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNUWNeg(B, V, _str::buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFNeg(B, V, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFNeg(B, V, _str::buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNot(B, V, Str.buf(\"\"));\n+        ret llvm::LLVMBuildNot(B, V, _str::buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildMalloc(B, Ty, Str.buf(\"\"));\n+        ret llvm::LLVMBuildMalloc(B, Ty, _str::buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, Str.buf(\"\"));\n+        ret llvm::LLVMBuildArrayMalloc(B, Ty, Val, _str::buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAlloca(B, Ty, Str.buf(\"\"));\n+        ret llvm::LLVMBuildAlloca(B, Ty, _str::buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, Str.buf(\"\"));\n+        ret llvm::LLVMBuildArrayAlloca(B, Ty, Val, _str::buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFree(B, PointerVal);\n+        ret llvm::LLVMBuildFree(B, PointerVal);\n     }\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildLoad(B, PointerVal, Str.buf(\"\"));\n+        ret llvm::LLVMBuildLoad(B, PointerVal, _str::buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildStore(B, Val, Ptr);\n+        ret llvm::LLVMBuildStore(B, Val, Ptr);\n     }\n \n     fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildGEP(B, Pointer,\n-                              Vec.buf[ValueRef](Indices),\n-                              Vec.len[ValueRef](Indices),\n-                              Str.buf(\"\"));\n+        ret llvm::LLVMBuildGEP(B, Pointer,\n+                              _vec::buf[ValueRef](Indices),\n+                              _vec::len[ValueRef](Indices),\n+                              _str::buf(\"\"));\n     }\n \n     fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildInBoundsGEP(B, Pointer,\n-                                      Vec.buf[ValueRef](Indices),\n-                                      Vec.len[ValueRef](Indices),\n-                                      Str.buf(\"\"));\n+        ret llvm::LLVMBuildInBoundsGEP(B, Pointer,\n+                                      _vec::buf[ValueRef](Indices),\n+                                      _vec::len[ValueRef](Indices),\n+                                      _str::buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, Str.buf(\"\"));\n+        ret llvm::LLVMBuildStructGEP(B, Pointer, Idx, _str::buf(\"\"));\n     }\n \n     fn GlobalString(sbuf _Str) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildGlobalString(B, _Str, Str.buf(\"\"));\n+        ret llvm::LLVMBuildGlobalString(B, _Str, _str::buf(\"\"));\n     }\n \n     fn GlobalStringPtr(sbuf _Str) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildGlobalStringPtr(B, _Str, Str.buf(\"\"));\n+        ret llvm::LLVMBuildGlobalStringPtr(B, _Str, _str::buf(\"\"));\n     }\n \n     /* Casts */\n     fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildTrunc(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildTrunc(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildZExt(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildZExt(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSExt(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSExt(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPToUI(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFPToUI(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPToSI(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFPToSI(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildUIToFP(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildUIToFP(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSIToFP(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSIToFP(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFPTrunc(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPExt(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFPExt(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildPtrToInt(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildIntToPtr(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildBitCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildBitCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildCast(B, Op, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildCast(B, Op, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildPointerCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildPointerCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIntCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildIntCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n     fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPCast(B, Val, DestTy, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFPCast(B, Val, DestTy, _str::buf(\"\"));\n     }\n \n \n     /* Comparisons */\n     fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildICmp(B, Op, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildFCmp(B, Op, LHS, RHS, _str::buf(\"\"));\n     }\n \n \n     /* Miscellaneous instructions */\n     fn Phi(TypeRef Ty, vec[ValueRef] vals,\n            vec[BasicBlockRef] bbs) -> ValueRef {\n         assert (!*terminated);\n-        auto phi = llvm.LLVMBuildPhi(B, Ty, Str.buf(\"\"));\n-        assert (Vec.len[ValueRef](vals) == Vec.len[BasicBlockRef](bbs));\n-        llvm.LLVMAddIncoming(phi,\n-                             Vec.buf[ValueRef](vals),\n-                             Vec.buf[BasicBlockRef](bbs),\n-                             Vec.len[ValueRef](vals));\n+        auto phi = llvm::LLVMBuildPhi(B, Ty, _str::buf(\"\"));\n+        assert (_vec::len[ValueRef](vals) == _vec::len[BasicBlockRef](bbs));\n+        llvm::LLVMAddIncoming(phi,\n+                             _vec::buf[ValueRef](vals),\n+                             _vec::buf[BasicBlockRef](bbs),\n+                             _vec::len[ValueRef](vals));\n         ret phi;\n     }\n \n     fn AddIncomingToPhi(ValueRef phi,\n                         vec[ValueRef] vals,\n                         vec[BasicBlockRef] bbs) {\n-        assert (Vec.len[ValueRef](vals) == Vec.len[BasicBlockRef](bbs));\n-        llvm.LLVMAddIncoming(phi,\n-                             Vec.buf[ValueRef](vals),\n-                             Vec.buf[BasicBlockRef](bbs),\n-                             Vec.len[ValueRef](vals));\n+        assert (_vec::len[ValueRef](vals) == _vec::len[BasicBlockRef](bbs));\n+        llvm::LLVMAddIncoming(phi,\n+                             _vec::buf[ValueRef](vals),\n+                             _vec::buf[BasicBlockRef](bbs),\n+                             _vec::len[ValueRef](vals));\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildCall(B, Fn,\n-                               Vec.buf[ValueRef](Args),\n-                               Vec.len[ValueRef](Args),\n-                               Str.buf(\"\"));\n+        ret llvm::LLVMBuildCall(B, Fn,\n+                               _vec::buf[ValueRef](Args),\n+                               _vec::len[ValueRef](Args),\n+                               _str::buf(\"\"));\n     }\n \n     fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         assert (!*terminated);\n-        auto v = llvm.LLVMBuildCall(B, Fn,\n-                                    Vec.buf[ValueRef](Args),\n-                                    Vec.len[ValueRef](Args),\n-                                    Str.buf(\"\"));\n-        llvm.LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n+        auto v = llvm::LLVMBuildCall(B, Fn,\n+                                    _vec::buf[ValueRef](Args),\n+                                    _vec::len[ValueRef](Args),\n+                                    _str::buf(\"\"));\n+        llvm::LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n         ret v;\n     }\n \n     fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSelect(B, If, Then, Else, Str.buf(\"\"));\n+        ret llvm::LLVMBuildSelect(B, If, Then, Else, _str::buf(\"\"));\n     }\n \n-    fn VAArg(ValueRef List, TypeRef Ty) -> ValueRef {\n+    fn VAArg(ValueRef list, TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildVAArg(B, List, Ty, Str.buf(\"\"));\n+        ret llvm::LLVMBuildVAArg(B, list, Ty, _str::buf(\"\"));\n     }\n \n     fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildExtractElement(B, VecVal, Index, Str.buf(\"\"));\n+        ret llvm::LLVMBuildExtractElement(B, VecVal, Index, _str::buf(\"\"));\n     }\n \n     fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n                      ValueRef Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n-                                        Str.buf(\"\"));\n+        ret llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n+                                        _str::buf(\"\"));\n     }\n \n     fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, Str.buf(\"\"));\n+        ret llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, _str::buf(\"\"));\n     }\n \n     fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildExtractValue(B, AggVal, Index, Str.buf(\"\"));\n+        ret llvm::LLVMBuildExtractValue(B, AggVal, Index, _str::buf(\"\"));\n     }\n \n     fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n                    uint Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, Str.buf(\"\"));\n+        ret llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index,\n+                                       _str::buf(\"\"));\n     }\n \n     fn IsNull(ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIsNull(B, Val, Str.buf(\"\"));\n+        ret llvm::LLVMBuildIsNull(B, Val, _str::buf(\"\"));\n     }\n \n     fn IsNotNull(ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIsNotNull(B, Val, Str.buf(\"\"));\n+        ret llvm::LLVMBuildIsNotNull(B, Val, _str::buf(\"\"));\n     }\n \n     fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, Str.buf(\"\"));\n+        ret llvm::LLVMBuildPtrDiff(B, LHS, RHS, _str::buf(\"\"));\n     }\n \n     fn Trap() -> ValueRef {\n         assert (!*terminated);\n-        let BasicBlockRef BB = llvm.LLVMGetInsertBlock(B);\n-        let ValueRef FN = llvm.LLVMGetBasicBlockParent(BB);\n-        let ModuleRef M = llvm.LLVMGetGlobalParent(FN);\n-        let ValueRef T = llvm.LLVMGetNamedFunction(M, Str.buf(\"llvm.trap\"));\n+        let BasicBlockRef BB = llvm::LLVMGetInsertBlock(B);\n+        let ValueRef FN = llvm::LLVMGetBasicBlockParent(BB);\n+        let ModuleRef M = llvm::LLVMGetGlobalParent(FN);\n+        let ValueRef T = llvm::LLVMGetNamedFunction(M,\n+                                                    _str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n         let vec[ValueRef] Args = vec();\n-        ret llvm.LLVMBuildCall(B, T,\n-                               Vec.buf[ValueRef](Args),\n-                               Vec.len[ValueRef](Args),\n-                               Str.buf(\"\"));\n+        ret llvm::LLVMBuildCall(B, T,\n+                               _vec::buf[ValueRef](Args),\n+                               _vec::len[ValueRef](Args),\n+                               _str::buf(\"\"));\n     }\n \n     drop {\n-        llvm.LLVMDisposeBuilder(B);\n+        llvm::LLVMDisposeBuilder(B);\n     }\n }\n \n /* Memory-managed object interface to type handles. */\n \n obj type_handle_dtor(TypeHandleRef TH) {\n-    drop { llvm.LLVMDisposeTypeHandle(TH); }\n+    drop { llvm::LLVMDisposeTypeHandle(TH); }\n }\n \n type type_handle = rec(TypeHandleRef llth, type_handle_dtor dtor);\n \n fn mk_type_handle() -> type_handle {\n-    auto th = llvm.LLVMCreateTypeHandle(llvm.LLVMOpaqueType());\n+    auto th = llvm::LLVMCreateTypeHandle(llvm::LLVMOpaqueType());\n     ret rec(llth=th, dtor=type_handle_dtor(th));\n }\n \n \n-state obj type_names(std.Map.hashmap[TypeRef, str] type_names,\n-                    std.Map.hashmap[str, TypeRef] named_types) {\n+state obj type_names(std::map::hashmap[TypeRef, str] type_names,\n+                    std::map::hashmap[str, TypeRef] named_types) {\n \n     fn associate(str s, TypeRef t) {\n         assert (!named_types.contains_key(s));\n@@ -1447,7 +1449,7 @@ state obj type_names(std.Map.hashmap[TypeRef, str] type_names,\n }\n \n fn mk_type_names() -> type_names {\n-    auto nt = util.common.new_str_hash[TypeRef]();\n+    auto nt = util::common::new_str_hash[TypeRef]();\n \n     fn hash(&TypeRef t) -> uint {\n         ret t as uint;\n@@ -1457,9 +1459,9 @@ fn mk_type_names() -> type_names {\n         ret (a as uint) == (b as uint);\n     }\n \n-    let std.Map.hashfn[TypeRef] hasher = hash;\n-    let std.Map.eqfn[TypeRef] eqer = eq;\n-    auto tn = std.Map.mk_hashmap[TypeRef,str](hasher, eqer);\n+    let std::map::hashfn[TypeRef] hasher = hash;\n+    let std::map::eqfn[TypeRef] eqer = eq;\n+    auto tn = std::map::mk_hashmap[TypeRef,str](hasher, eqer);\n \n     ret type_names(tn, nt);\n }\n@@ -1478,7 +1480,7 @@ fn type_to_str_inner(type_names names,\n \n     auto outer = outer0 + vec(ty);\n \n-    let int kind = llvm.LLVMGetTypeKind(ty);\n+    let int kind = llvm::LLVMGetTypeKind(ty);\n \n     fn tys_str(type_names names,\n                vec[TypeRef] outer, vec[TypeRef] tys) -> str {\n@@ -1497,7 +1499,7 @@ fn type_to_str_inner(type_names names,\n \n     alt (kind) {\n \n-        // FIXME: more enum-as-int constants determined from Core.h;\n+        // FIXME: more enum-as-int constants determined from Core::h;\n         // horrible, horrible. Complete as needed.\n \n         case (0) { ret \"Void\"; }\n@@ -1509,16 +1511,17 @@ fn type_to_str_inner(type_names names,\n         case (6) { ret \"Label\"; }\n \n         case (7) {\n-            ret \"i\" + util.common.istr(llvm.LLVMGetIntTypeWidth(ty) as int);\n+            ret \"i\" + util::common::istr(llvm::LLVMGetIntTypeWidth(ty)\n+                                         as int);\n         }\n \n         case (8) {\n             auto s = \"fn(\";\n-            let TypeRef out_ty = llvm.LLVMGetReturnType(ty);\n-            let uint n_args = llvm.LLVMCountParamTypes(ty);\n+            let TypeRef out_ty = llvm::LLVMGetReturnType(ty);\n+            let uint n_args = llvm::LLVMCountParamTypes(ty);\n             let vec[TypeRef] args =\n-                Vec.init_elt[TypeRef](0 as TypeRef, n_args);\n-            llvm.LLVMGetParamTypes(ty, Vec.buf[TypeRef](args));\n+                _vec::init_elt[TypeRef](0 as TypeRef, n_args);\n+            llvm::LLVMGetParamTypes(ty, _vec::buf[TypeRef](args));\n             s += tys_str(names, outer, args);\n             s += \") -> \";\n             s += type_to_str_inner(names, outer, out_ty);\n@@ -1527,10 +1530,10 @@ fn type_to_str_inner(type_names names,\n \n         case (9) {\n             let str s = \"{\";\n-            let uint n_elts = llvm.LLVMCountStructElementTypes(ty);\n+            let uint n_elts = llvm::LLVMCountStructElementTypes(ty);\n             let vec[TypeRef] elts =\n-                Vec.init_elt[TypeRef](0 as TypeRef, n_elts);\n-            llvm.LLVMGetStructElementTypes(ty, Vec.buf[TypeRef](elts));\n+                _vec::init_elt[TypeRef](0 as TypeRef, n_elts);\n+            llvm::LLVMGetStructElementTypes(ty, _vec::buf[TypeRef](elts));\n             s += tys_str(names, outer, elts);\n             s += \"}\";\n             ret s;\n@@ -1543,12 +1546,12 @@ fn type_to_str_inner(type_names names,\n             for (TypeRef tout in outer0) {\n                 i += 1u;\n                 if (tout as int == ty as int) {\n-                    let uint n = Vec.len[TypeRef](outer0) - i;\n-                    ret \"*\\\\\" + util.common.istr(n as int);\n+                    let uint n = _vec::len[TypeRef](outer0) - i;\n+                    ret \"*\\\\\" + util::common::istr(n as int);\n                 }\n             }\n             ret \"*\" + type_to_str_inner(names, outer,\n-                                        llvm.LLVMGetElementType(ty));\n+                                        llvm::LLVMGetElementType(ty));\n         }\n \n         case (12) { ret \"Opaque\"; }\n@@ -1564,52 +1567,52 @@ fn type_to_str_inner(type_names names,\n /* Memory-managed interface to target data. */\n \n obj target_data_dtor(TargetDataRef TD) {\n-    drop { llvm.LLVMDisposeTargetData(TD); }\n+    drop { llvm::LLVMDisposeTargetData(TD); }\n }\n \n type target_data = rec(TargetDataRef lltd, target_data_dtor dtor);\n \n fn mk_target_data(str string_rep) -> target_data {\n-    auto lltd = llvm.LLVMCreateTargetData(Str.buf(string_rep));\n+    auto lltd = llvm::LLVMCreateTargetData(_str::buf(string_rep));\n     ret rec(lltd=lltd, dtor=target_data_dtor(lltd));\n }\n \n /* Memory-managed interface to pass managers. */\n \n obj pass_manager_dtor(PassManagerRef PM) {\n-    drop { llvm.LLVMDisposePassManager(PM); }\n+    drop { llvm::LLVMDisposePassManager(PM); }\n }\n \n type pass_manager = rec(PassManagerRef llpm, pass_manager_dtor dtor);\n \n fn mk_pass_manager() -> pass_manager {\n-    auto llpm = llvm.LLVMCreatePassManager();\n+    auto llpm = llvm::LLVMCreatePassManager();\n     ret rec(llpm=llpm, dtor=pass_manager_dtor(llpm));\n }\n \n /* Memory-managed interface to object files. */\n \n obj object_file_dtor(ObjectFileRef ObjectFile) {\n-    drop { llvm.LLVMDisposeObjectFile(ObjectFile); }\n+    drop { llvm::LLVMDisposeObjectFile(ObjectFile); }\n }\n \n type object_file = rec(ObjectFileRef llof, object_file_dtor dtor);\n \n fn mk_object_file(MemoryBufferRef llmb) -> object_file {\n-    auto llof = llvm.LLVMCreateObjectFile(llmb);\n+    auto llof = llvm::LLVMCreateObjectFile(llmb);\n     ret rec(llof=llof, dtor=object_file_dtor(llof));\n }\n \n /* Memory-managed interface to section iterators. */\n \n obj section_iter_dtor(SectionIteratorRef SI) {\n-    drop { llvm.LLVMDisposeSectionIterator(SI); }\n+    drop { llvm::LLVMDisposeSectionIterator(SI); }\n }\n \n type section_iter = rec(SectionIteratorRef llsi, section_iter_dtor dtor);\n \n fn mk_section_iter(ObjectFileRef llof) -> section_iter {\n-    auto llsi = llvm.LLVMGetSections(llof);\n+    auto llsi = llvm::LLVMGetSections(llof);\n     ret rec(llsi=llsi, dtor=section_iter_dtor(llsi));\n }\n "}, {"sha": "7124554a7c4b64a5b994e96cb172c1599ea04029", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,73 +1,73 @@\n-import driver.session;\n-import front.ast;\n-import std.Map.hashmap;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-import std.Int;\n-import std.Vec;\n-import util.common;\n-import resolve.def_map;\n+import driver::session;\n+import front::ast;\n+import std::map::hashmap;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import std::_int;\n+import std::_vec;\n+import util::common;\n+import resolve::def_map;\n \n-type fn_id_of_local = std.Map.hashmap[ast.def_id, ast.def_id];\n-type env = rec(mutable vec[ast.def_id] current_context, // fn or obj\n+type fn_id_of_local = std::map::hashmap[ast::def_id, ast::def_id];\n+type env = rec(mutable vec[ast::def_id] current_context, // fn or obj\n                def_map def_map,\n                fn_id_of_local idmap,\n-               session.session sess);\n+               session::session sess);\n \n-fn current_context(&env e) -> ast.def_id {\n-    ret e.current_context.(Vec.len(e.current_context) - 1u);\n+fn current_context(&env e) -> ast::def_id {\n+    ret e.current_context.(_vec::len(e.current_context) - 1u);\n }\n \n-fn enter_item(@env e, &@ast.item i) {\n+fn enter_item(@env e, &@ast::item i) {\n     alt (i.node) {\n-        case (ast.item_fn(?name, _, _, ?id, _)) {\n-            Vec.push(e.current_context, id);\n+        case (ast::item_fn(?name, _, _, ?id, _)) {\n+            _vec::push(e.current_context, id);\n         }\n-        case (ast.item_obj(?name, _, _, ?ids, _)) {\n-            Vec.push(e.current_context, ids.ty);\n+        case (ast::item_obj(?name, _, _, ?ids, _)) {\n+            _vec::push(e.current_context, ids.ty);\n         }\n         case (_) {}\n     }\n }\n \n-fn leave_item(@env e, &@ast.item i) {\n+fn leave_item(@env e, &@ast::item i) {\n     alt (i.node) {\n-        case (ast.item_fn(?name, _, _, ?id, _)) {\n-            Vec.pop(e.current_context);\n+        case (ast::item_fn(?name, _, _, ?id, _)) {\n+            _vec::pop(e.current_context);\n         }\n-        case (ast.item_obj(_, _, _, ?ids, _)) {\n-            Vec.pop(e.current_context);\n+        case (ast::item_obj(_, _, _, ?ids, _)) {\n+            _vec::pop(e.current_context);\n         }\n         case (_) {}\n     }\n }\n \n-fn walk_expr(@env e, &@ast.expr x) {\n+fn walk_expr(@env e, &@ast::expr x) {\n     alt (x.node) {\n-        case (ast.expr_for(?d, _, _, _)) {\n+        case (ast::expr_for(?d, _, _, _)) {\n             alt (d.node) {\n-                case (ast.decl_local(?local)) {\n+                case (ast::decl_local(?local)) {\n                     e.idmap.insert(local.id, current_context(*e));\n                 }\n                 case (_) { }\n             }\n         }\n-        case (ast.expr_for_each(?d, _, _, _)) {\n+        case (ast::expr_for_each(?d, _, _, _)) {\n             alt (d.node) {\n-                case (ast.decl_local(?local)) {\n+                case (ast::decl_local(?local)) {\n                     e.idmap.insert(local.id, current_context(*e));\n                 }\n                 case (_) { }\n             }\n         }\n-        case (ast.expr_path(?pt, ?ann)) {\n+        case (ast::expr_path(?pt, ?ann)) {\n             auto local_id;\n-            alt (e.def_map.get(ast.ann_tag(ann))) {\n-                case (ast.def_local(?id)) { local_id = id; }\n+            alt (e.def_map.get(ast::ann_tag(ann))) {\n+                case (ast::def_local(?id)) { local_id = id; }\n                 case (_) { ret; }\n             }\n-            auto df = ast.def_id_of_def(e.def_map.get(ast.ann_tag(ann)));\n+            auto df = ast::def_id_of_def(e.def_map.get(ast::ann_tag(ann)));\n             auto def_context = e.idmap.get(df);\n \n             if (current_context(*e) != def_context) {\n@@ -79,12 +79,12 @@ fn walk_expr(@env e, &@ast.expr x) {\n     }\n }\n \n-fn walk_block(@env e, &ast.block b) {\n-    for (@ast.stmt st in b.node.stmts) {\n+fn walk_block(@env e, &ast::block b) {\n+    for (@ast::stmt st in b.node.stmts) {\n         alt (st.node) {\n-            case (ast.stmt_decl(?d,_)) {\n+            case (ast::stmt_decl(?d,_)) {\n                 alt (d.node) {\n-                    case (ast.decl_local(?loc)) {\n+                    case (ast::decl_local(?loc)) {\n                         e.idmap.insert(loc.id, current_context(*e));\n                     }\n                     case (_) { }\n@@ -95,18 +95,18 @@ fn walk_block(@env e, &ast.block b) {\n     }\n }\n \n-fn check_for_captures(session.session sess, @ast.crate crate, def_map dm) {\n-    let vec[ast.def_id] curctx = vec();\n+fn check_for_captures(session::session sess, @ast::crate crate, def_map dm) {\n+    let vec[ast::def_id] curctx = vec();\n     auto env = @rec(mutable current_context = curctx,\n                     def_map = dm,\n-                    idmap = common.new_def_hash[ast.def_id](),\n+                    idmap = common::new_def_hash[ast::def_id](),\n                     sess = sess);\n     auto visitor = rec(visit_item_pre = bind enter_item(env, _),\n                        visit_item_post = bind leave_item(env, _),\n                        visit_block_pre = bind walk_block(env, _),\n                        visit_expr_pre = bind walk_expr(env, _)\n-                       with walk.default_visitor());\n-    walk.walk_crate(visitor, *crate);\n+                       with walk::default_visitor());\n+    walk::walk_crate(visitor, *crate);\n }\n \n // Local Variables:"}, {"sha": "5af85f14cbbc3f0322cea968874a4e8edd107165", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 375, "deletions": 374, "changes": 749, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,45 +1,45 @@\n-import std.Map.hashmap;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-\n-import util.common.new_str_hash;\n-import util.common.spanned;\n-import util.common.span;\n-import util.common.ty_mach;\n-import util.typestate_ann.ts_ann;\n-\n-import front.ast;\n-import front.ast.fn_decl;\n-import front.ast.ident;\n-import front.ast.path;\n-import front.ast.mutability;\n-import front.ast.ty;\n-import front.ast.expr;\n-import front.ast.stmt;\n-import front.ast.block;\n-import front.ast.item;\n-import front.ast.view_item;\n-import front.ast.meta_item;\n-import front.ast.native_item;\n-import front.ast.arg;\n-import front.ast.pat;\n-import front.ast.decl;\n-import front.ast.arm;\n-import front.ast.def;\n-import front.ast.def_id;\n-import front.ast.ann;\n-import front.ast.mt;\n-import front.ast.purity;\n-\n-import std.UInt;\n-import std.Vec;\n+import std::map::hashmap;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+\n+import util::common::new_str_hash;\n+import util::common::spanned;\n+import util::common::span;\n+import util::common::ty_mach;\n+import util::typestate_ann::ts_ann;\n+\n+import front::ast;\n+import front::ast::fn_decl;\n+import front::ast::ident;\n+import front::ast::path;\n+import front::ast::mutability;\n+import front::ast::ty;\n+import front::ast::expr;\n+import front::ast::stmt;\n+import front::ast::block;\n+import front::ast::item;\n+import front::ast::view_item;\n+import front::ast::meta_item;\n+import front::ast::native_item;\n+import front::ast::arg;\n+import front::ast::pat;\n+import front::ast::decl;\n+import front::ast::arm;\n+import front::ast::def;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::mt;\n+import front::ast::purity;\n+\n+import std::_uint;\n+import std::_vec;\n \n type ast_fold[ENV] =\n     @rec\n     (\n-     // Path fold.\n-     (fn(&ENV e, &span sp, &ast.path_ p) -> path) fold_path,\n+     // Path fold:\n+     (fn(&ENV e, &span sp, &ast::path_ p) -> path) fold_path,\n \n      // Type folds.\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_nil,\n@@ -56,33 +56,33 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, &vec[mt] elts) -> @ty) fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n-         &vec[ast.ty_field] elts) -> @ty)         fold_ty_rec,\n+         &vec[ast::ty_field] elts) -> @ty)         fold_ty_rec,\n \n      (fn(&ENV e, &span sp,\n-         &vec[ast.ty_method] meths) -> @ty)       fold_ty_obj,\n+         &vec[ast::ty_method] meths) -> @ty)       fold_ty_obj,\n \n      (fn(&ENV e, &span sp,\n-         ast.proto proto,\n-         &vec[rec(ast.mode mode, @ty ty)] inputs,\n+         ast::proto proto,\n+         &vec[rec(ast::mode mode, @ty ty)] inputs,\n          &@ty output) -> @ty)                     fold_ty_fn,\n \n-     (fn(&ENV e, &span sp, &ast.path p,\n+     (fn(&ENV e, &span sp, &ast::path p,\n          &ann a) -> @ty)                          fold_ty_path,\n \n      (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_chan,\n      (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_port,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         &vec[@expr] es, ast.mutability mut,\n+         &vec[@expr] es, ast::mutability mut,\n          &ann a) -> @expr)                        fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n-         &vec[ast.elt] es, &ann a) -> @expr)      fold_expr_tup,\n+         &vec[ast::elt] es, &ann a) -> @expr)      fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n-         &vec[ast.field] fields,\n-         &Option.t[@expr] base, &ann a) -> @expr) fold_expr_rec,\n+         &vec[ast::field] fields,\n+         &option::t[@expr] base, &ann a) -> @expr) fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n          &@expr f, &vec[@expr] args,\n@@ -92,33 +92,33 @@ type ast_fold[ENV] =\n          &ident id, &ann a) -> @expr)             fold_expr_self_method,\n \n      (fn(&ENV e, &span sp,\n-         &@expr f, &vec[Option.t[@expr]] args,\n+         &@expr f, &vec[option::t[@expr]] args,\n          &ann a) -> @expr)                        fold_expr_bind,\n \n      (fn(&ENV e, &span sp,\n-         ast.spawn_dom dom, &Option.t[str] name,\n+         ast::spawn_dom dom, &option::t[str] name,\n          &@expr f, &vec[@expr] args,\n          &ann a) -> @expr)                        fold_expr_spawn,\n \n      (fn(&ENV e, &span sp,\n-         ast.binop,\n+         ast::binop,\n          &@expr lhs, &@expr rhs,\n          &ann a) -> @expr)                        fold_expr_binary,\n \n      (fn(&ENV e, &span sp,\n-         ast.unop, &@expr e,\n+         ast::unop, &@expr e,\n          &ann a) -> @expr)                        fold_expr_unary,\n \n      (fn(&ENV e, &span sp,\n-         &@ast.lit, &ann a) -> @expr)             fold_expr_lit,\n+         &@ast::lit, &ann a) -> @expr)             fold_expr_lit,\n \n      (fn(&ENV e, &span sp,\n-         &@ast.expr e, &@ast.ty ty,\n+         &@ast::expr e, &@ast::ty ty,\n          &ann a) -> @expr)                        fold_expr_cast,\n \n      (fn(&ENV e, &span sp,\n          &@expr cond, &block thn,\n-         &Option.t[@expr] els,\n+         &option::t[@expr] els,\n          &ann a) -> @expr)                        fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n@@ -149,7 +149,7 @@ type ast_fold[ENV] =\n          &ann a) -> @expr)                        fold_expr_assign,\n \n      (fn(&ENV e, &span sp,\n-         ast.binop,\n+         ast::binop,\n          &@expr lhs, &@expr rhs,\n          &ann a) -> @expr)                        fold_expr_assign_op,\n \n@@ -175,7 +175,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          &path p, &vec[@expr] args,\n-         &Option.t[str] body,\n+         &option::t[str] body,\n          &@expr expanded,\n          &ann a) -> @expr)                        fold_expr_ext,\n \n@@ -186,10 +186,10 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_cont,\n \n      (fn(&ENV e, &span sp,\n-         &Option.t[@expr] rv, &ann a) -> @expr)   fold_expr_ret,\n+         &option::t[@expr] rv, &ann a) -> @expr)   fold_expr_ret,\n \n      (fn(&ENV e, &span sp,\n-         &Option.t[@expr] rv, &ann a) -> @expr)   fold_expr_put,\n+         &option::t[@expr] rv, &ann a) -> @expr)   fold_expr_put,\n \n      (fn(&ENV e, &span sp,\n          &@expr e, &ann a) -> @expr)              fold_expr_be,\n@@ -212,7 +212,7 @@ type ast_fold[ENV] =\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n-         &@ast.local local) -> @decl)             fold_decl_local,\n+         &@ast::local local) -> @decl)             fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n          &@item item) -> @decl)                   fold_decl_item,\n@@ -223,7 +223,7 @@ type ast_fold[ENV] =\n          &ann a) -> @pat)                         fold_pat_wild,\n \n      (fn(&ENV e, &span sp,\n-         &@ast.lit lit, &ann a) -> @pat)          fold_pat_lit,\n+         &@ast::lit lit, &ann a) -> @pat)          fold_pat_lit,\n \n      (fn(&ENV e, &span sp,\n          &ident i, &def_id did, &ann a) -> @pat)  fold_pat_bind,\n@@ -248,44 +248,44 @@ type ast_fold[ENV] =\n          &def_id id, &ann a) -> @item)            fold_item_const,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &ast._fn f,\n-         &vec[ast.ty_param] ty_params,\n+         &ast::_fn f,\n+         &vec[ast::ty_param] ty_params,\n          &def_id id, &ann a) -> @item)            fold_item_fn,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &Option.t[str] link_name,\n-         &ast.fn_decl decl,\n-         &vec[ast.ty_param] ty_params,\n+         &option::t[str] link_name,\n+         &ast::fn_decl decl,\n+         &vec[ast::ty_param] ty_params,\n          &def_id id, &ann a) -> @native_item)     fold_native_item_fn,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &ast._mod m, &def_id id) -> @item)       fold_item_mod,\n+         &ast::_mod m, &def_id id) -> @item)       fold_item_mod,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &ast.native_mod m, &def_id id) -> @item) fold_item_native_mod,\n+         &ast::native_mod m, &def_id id) -> @item) fold_item_native_mod,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &@ty t, &vec[ast.ty_param] ty_params,\n+         &@ty t, &vec[ast::ty_param] ty_params,\n          &def_id id, &ann a) -> @item)            fold_item_ty,\n \n      (fn(&ENV e, &span sp, &ident ident,\n          &def_id id) -> @native_item)             fold_native_item_ty,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &vec[ast.variant] variants,\n-         &vec[ast.ty_param] ty_params,\n+         &vec[ast::variant] variants,\n+         &vec[ast::ty_param] ty_params,\n          &def_id id, &ann a) -> @item)            fold_item_tag,\n \n      (fn(&ENV e, &span sp, &ident ident,\n-         &ast._obj ob,\n-         &vec[ast.ty_param] ty_params,\n-         &ast.obj_def_ids odid, &ann a) -> @item) fold_item_obj,\n+         &ast::_obj ob,\n+         &vec[ast::ty_param] ty_params,\n+         &ast::obj_def_ids odid, &ann a) -> @item) fold_item_obj,\n \n      // View Item folds.\n      (fn(&ENV e, &span sp, &ident ident,\n          &vec[@meta_item] meta_items,\n          &def_id id,\n-         &Option.t[int]) -> @view_item)           fold_view_item_use,\n+         &option::t[int]) -> @view_item)           fold_view_item_use,\n \n      (fn(&ENV e, &span sp, &ident i,\n          &vec[ident] idents,\n@@ -300,30 +300,30 @@ type ast_fold[ENV] =\n      // Additional nodes.\n \n      (fn(&ENV e, &fn_decl decl,\n-         ast.proto proto,\n-         &block body) -> ast._fn)                 fold_fn,\n+         ast::proto proto,\n+         &block body) -> ast::_fn)                 fold_fn,\n \n      (fn(&ENV e,\n          &vec[arg] inputs,\n          &@ty output,\n-         &purity p) -> ast.fn_decl)               fold_fn_decl,\n+         &purity p) -> ast::fn_decl)               fold_fn_decl,\n \n-     (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n+     (fn(&ENV e, &ast::_mod m) -> ast::_mod)        fold_mod,\n \n-     (fn(&ENV e, &ast.native_mod m) -> ast.native_mod) fold_native_mod,\n+     (fn(&ENV e, &ast::native_mod m) -> ast::native_mod) fold_native_mod,\n \n      (fn(&ENV e, &span sp,\n-         &vec[@ast.crate_directive] cdirs,\n-         &ast._mod m) -> @ast.crate)              fold_crate,\n+         &vec[@ast::crate_directive] cdirs,\n+         &ast::_mod m) -> @ast::crate)              fold_crate,\n \n      (fn(&ENV e,\n-         &vec[ast.obj_field] fields,\n-         &vec[@ast.method] methods,\n-         &Option.t[@ast.method] dtor)\n-      -> ast._obj)                                fold_obj,\n+         &vec[ast::obj_field] fields,\n+         &vec[@ast::method] methods,\n+         &option::t[@ast::method] dtor)\n+      -> ast::_obj)                                fold_obj,\n \n      // Env updates.\n-     (fn(&ENV e, &@ast.crate c) -> ENV) update_env_for_crate,\n+     (fn(&ENV e, &@ast::crate c) -> ENV) update_env_for_crate,\n      (fn(&ENV e, &@item i) -> ENV) update_env_for_item,\n      (fn(&ENV e, &@native_item i) -> ENV) update_env_for_native_item,\n      (fn(&ENV e, &@view_item i) -> ENV) update_env_for_view_item,\n@@ -343,11 +343,11 @@ type ast_fold[ENV] =\n //// Fold drivers.\n \n fn fold_path[ENV](&ENV env, &ast_fold[ENV] fld, &path p) -> path {\n-    let vec[@ast.ty] tys_ = vec();\n-    for (@ast.ty t in p.node.types) {\n-        Vec.push[@ast.ty](tys_, fold_ty(env, fld, t));\n+    let vec[@ast::ty] tys_ = vec();\n+    for (@ast::ty t in p.node.types) {\n+        _vec::push[@ast::ty](tys_, fold_ty(env, fld, t));\n     }\n-    let ast.path_ p_ = rec(idents=p.node.idents, types=tys_);\n+    let ast::path_ p_ = rec(idents=p.node.idents, types=tys_);\n     ret fld.fold_path(env, p.span, p_);\n }\n \n@@ -359,56 +359,56 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n     }\n \n     alt (t.node) {\n-        case (ast.ty_nil) { ret fld.fold_ty_nil(env_, t.span); }\n-        case (ast.ty_bool) { ret fld.fold_ty_bool(env_, t.span); }\n-        case (ast.ty_int) { ret fld.fold_ty_int(env_, t.span); }\n-        case (ast.ty_uint) { ret fld.fold_ty_uint(env_, t.span); }\n-        case (ast.ty_float) { ret fld.fold_ty_float(env_, t.span); }\n+        case (ast::ty_nil) { ret fld.fold_ty_nil(env_, t.span); }\n+        case (ast::ty_bool) { ret fld.fold_ty_bool(env_, t.span); }\n+        case (ast::ty_int) { ret fld.fold_ty_int(env_, t.span); }\n+        case (ast::ty_uint) { ret fld.fold_ty_uint(env_, t.span); }\n+        case (ast::ty_float) { ret fld.fold_ty_float(env_, t.span); }\n \n-        case (ast.ty_machine(?m)) {\n+        case (ast::ty_machine(?m)) {\n             ret fld.fold_ty_machine(env_, t.span, m);\n         }\n \n-        case (ast.ty_char) { ret fld.fold_ty_char(env_, t.span); }\n-        case (ast.ty_str) { ret fld.fold_ty_str(env_, t.span); }\n+        case (ast::ty_char) { ret fld.fold_ty_char(env_, t.span); }\n+        case (ast::ty_str) { ret fld.fold_ty_str(env_, t.span); }\n \n-        case (ast.ty_box(?tm)) {\n+        case (ast::ty_box(?tm)) {\n             auto ty_ = fold_ty(env, fld, tm.ty);\n             ret fld.fold_ty_box(env_, t.span, rec(ty=ty_, mut=tm.mut));\n         }\n \n-        case (ast.ty_vec(?tm)) {\n+        case (ast::ty_vec(?tm)) {\n             auto ty_ = fold_ty(env, fld, tm.ty);\n             ret fld.fold_ty_vec(env_, t.span, rec(ty=ty_, mut=tm.mut));\n         }\n \n-        case (ast.ty_tup(?elts)) {\n+        case (ast::ty_tup(?elts)) {\n             let vec[mt] elts_ = vec();\n             for (mt elt in elts) {\n                 auto ty_ = fold_ty(env, fld, elt.ty);\n-                Vec.push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n+                _vec::push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n \n-        case (ast.ty_rec(?flds)) {\n-            let vec[ast.ty_field] flds_ = vec();\n-            for (ast.ty_field f in flds) {\n+        case (ast::ty_rec(?flds)) {\n+            let vec[ast::ty_field] flds_ = vec();\n+            for (ast::ty_field f in flds) {\n                 auto ty_ = fold_ty(env, fld, f.mt.ty);\n-                Vec.push[ast.ty_field]\n+                _vec::push[ast::ty_field]\n                     (flds_, rec(mt=rec(ty=ty_, mut=f.mt.mut) with f));\n             }\n             ret fld.fold_ty_rec(env_, t.span, flds_);\n         }\n \n-        case (ast.ty_obj(?meths)) {\n-            let vec[ast.ty_method] meths_ = vec();\n-            for (ast.ty_method m in meths) {\n+        case (ast::ty_obj(?meths)) {\n+            let vec[ast::ty_method] meths_ = vec();\n+            for (ast::ty_method m in meths) {\n                 auto tfn = fold_ty_fn(env_, fld, t.span, m.proto,\n                                       m.inputs, m.output);\n                 alt (tfn.node) {\n-                    case (ast.ty_fn(?p, ?ins, ?out)) {\n-                        Vec.push[ast.ty_method]\n+                    case (ast::ty_fn(?p, ?ins, ?out)) {\n+                        _vec::push[ast::ty_method]\n                             (meths_, rec(proto=p, inputs=ins,\n                                          output=out with m));\n                     }\n@@ -417,34 +417,34 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n             ret fld.fold_ty_obj(env_, t.span, meths_);\n         }\n \n-        case (ast.ty_path(?pth, ?ann)) {\n+        case (ast::ty_path(?pth, ?ann)) {\n             auto pth_ = fold_path(env, fld, pth);\n             ret fld.fold_ty_path(env_, t.span, pth_, ann);\n         }\n \n-        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n+        case (ast::ty_fn(?proto, ?inputs, ?output)) {\n             ret fold_ty_fn(env_, fld, t.span, proto, inputs, output);\n         }\n \n-        case (ast.ty_chan(?ty)) {\n+        case (ast::ty_chan(?ty)) {\n             auto ty_ = fold_ty(env, fld, ty);\n             ret fld.fold_ty_chan(env_, t.span, ty_);\n         }\n \n-        case (ast.ty_port(?ty)) {\n+        case (ast::ty_port(?ty)) {\n             auto ty_ = fold_ty(env, fld, ty);\n             ret fld.fold_ty_port(env_, t.span, ty_);\n         }\n     }\n }\n \n fn fold_ty_fn[ENV](&ENV env, &ast_fold[ENV] fld, &span sp,\n-                   ast.proto proto,\n-                   &vec[rec(ast.mode mode, @ty ty)] inputs,\n+                   ast::proto proto,\n+                   &vec[rec(ast::mode mode, @ty ty)] inputs,\n                    &@ty output) -> @ty {\n     auto output_ = fold_ty(env, fld, output);\n-    let vec[rec(ast.mode mode, @ty ty)] inputs_ = vec();\n-    for (rec(ast.mode mode, @ty ty) input in inputs) {\n+    let vec[rec(ast::mode mode, @ty ty)] inputs_ = vec();\n+    for (rec(ast::mode mode, @ty ty) input in inputs) {\n         auto ty_ = fold_ty(env, fld, input.ty);\n         auto input_ = rec(ty=ty_ with input);\n         inputs_ += vec(input_);\n@@ -460,29 +460,29 @@ fn fold_decl[ENV](&ENV env, &ast_fold[ENV] fld, &@decl d) -> @decl {\n     }\n \n     alt (d.node) {\n-        case (ast.decl_local(?local)) {\n-            auto ty_ = none[@ast.ty];\n-            auto init_ = none[ast.initializer];\n+        case (ast::decl_local(?local)) {\n+            auto ty_ = none[@ast::ty];\n+            auto init_ = none[ast::initializer];\n             alt (local.ty) {\n-                case (some[@ast.ty](?t)) {\n-                    ty_ = some[@ast.ty](fold_ty(env, fld, t));\n+                case (some[@ast::ty](?t)) {\n+                    ty_ = some[@ast::ty](fold_ty(env, fld, t));\n                 }\n                 case (_) { /* fall through */  }\n             }\n             alt (local.init) {\n-                case (some[ast.initializer](?init)) {\n+                case (some[ast::initializer](?init)) {\n                     auto e =  fold_expr(env, fld, init.expr);\n-                    init_ = some[ast.initializer](rec(expr = e with init));\n+                    init_ = some[ast::initializer](rec(expr = e with init));\n                 }\n                 case (_) { /* fall through */  }\n             }\n             auto ann_ = fld.fold_ann(env_, local.ann);\n-            let @ast.local local_ =\n+            let @ast::local local_ =\n                 @rec(ty=ty_, init=init_, ann=ann_ with *local);\n             ret fld.fold_decl_local(env_, d.span, local_);\n         }\n \n-        case (ast.decl_item(?item)) {\n+        case (ast::decl_item(?item)) {\n             auto item_ = fold_item(env_, fld, item);\n             ret fld.fold_decl_item(env_, d.span, item_);\n         }\n@@ -491,26 +491,26 @@ fn fold_decl[ENV](&ENV env, &ast_fold[ENV] fld, &@decl d) -> @decl {\n     fail;\n }\n \n-fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast.pat p) -> @ast.pat {\n+fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast::pat p) -> @ast::pat {\n     let ENV env_ = fld.update_env_for_pat(env, p);\n \n     if (!fld.keep_going(env_)) {\n         ret p;\n     }\n \n     alt (p.node) {\n-        case (ast.pat_wild(?t)) { ret fld.fold_pat_wild(env_, p.span, t); }\n-        case (ast.pat_lit(?lt, ?t)) {\n+        case (ast::pat_wild(?t)) { ret fld.fold_pat_wild(env_, p.span, t); }\n+        case (ast::pat_lit(?lt, ?t)) {\n             ret fld.fold_pat_lit(env_, p.span, lt, t);\n         }\n-        case (ast.pat_bind(?id, ?did, ?t)) {\n+        case (ast::pat_bind(?id, ?did, ?t)) {\n             ret fld.fold_pat_bind(env_, p.span, id, did, t);\n         }\n-        case (ast.pat_tag(?path, ?pats, ?t)) {\n+        case (ast::pat_tag(?path, ?pats, ?t)) {\n             auto ppath = fold_path(env, fld, path);\n \n-            let vec[@ast.pat] ppats = vec();\n-            for (@ast.pat pat in pats) {\n+            let vec[@ast::pat] ppats = vec();\n+            for (@ast::pat pat in pats) {\n                 ppats += vec(fold_pat(env_, fld, pat));\n             }\n \n@@ -523,17 +523,17 @@ fn fold_exprs[ENV](&ENV env, &ast_fold[ENV] fld,\n                    &vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = vec();\n     for (@expr e in es) {\n-        Vec.push[@expr](exprs, fold_expr(env, fld, e));\n+        _vec::push[@expr](exprs, fold_expr(env, fld, e));\n     }\n     ret exprs;\n }\n \n-fn fold_tup_elt[ENV](&ENV env, &ast_fold[ENV] fld, &ast.elt e) -> ast.elt {\n+fn fold_tup_elt[ENV](&ENV env, &ast_fold[ENV] fld, &ast::elt e) -> ast::elt {\n     ret rec(expr=fold_expr(env, fld, e.expr) with e);\n }\n \n-fn fold_rec_field[ENV](&ENV env, &ast_fold[ENV] fld, &ast.field f)\n-    -> ast.field {\n+fn fold_rec_field[ENV](&ENV env, &ast_fold[ENV] fld, &ast::field f)\n+    -> ast::field {\n     ret rec(expr=fold_expr(env, fld, f.expr) with f);\n }\n \n@@ -546,100 +546,100 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n     }\n \n     alt (e.node) {\n-        case (ast.expr_vec(?es, ?mut, ?t)) {\n+        case (ast::expr_vec(?es, ?mut, ?t)) {\n             auto ees = fold_exprs(env_, fld, es);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_vec(env_, e.span, ees, mut, t2);\n         }\n \n-        case (ast.expr_tup(?es, ?t)) {\n-            let vec[ast.elt] elts = vec();\n-            for (ast.elt e in es) {\n+        case (ast::expr_tup(?es, ?t)) {\n+            let vec[ast::elt] elts = vec();\n+            for (ast::elt e in es) {\n                 elts += vec(fold_tup_elt[ENV](env, fld, e));\n             }\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_tup(env_, e.span, elts, t2);\n         }\n \n-        case (ast.expr_rec(?fs, ?base, ?t)) {\n-            let vec[ast.field] fields = vec();\n-            let Option.t[@expr] b = none[@expr];\n-            for (ast.field f in fs) {\n+        case (ast::expr_rec(?fs, ?base, ?t)) {\n+            let vec[ast::field] fields = vec();\n+            let option::t[@expr] b = none[@expr];\n+            for (ast::field f in fs) {\n                 fields += vec(fold_rec_field(env, fld, f));\n             }\n             alt (base) {\n-                case (none[@ast.expr]) { }\n-                case (some[@ast.expr](?eb)) {\n+                case (none[@ast::expr]) { }\n+                case (some[@ast::expr](?eb)) {\n                     b = some[@expr](fold_expr(env_, fld, eb));\n                 }\n             }\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_rec(env_, e.span, fields, b, t2);\n         }\n \n-        case (ast.expr_call(?f, ?args, ?t)) {\n+        case (ast::expr_call(?f, ?args, ?t)) {\n             auto ff = fold_expr(env_, fld, f);\n             auto aargs = fold_exprs(env_, fld, args);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_call(env_, e.span, ff, aargs, t2);\n         }\n \n-        case (ast.expr_self_method(?ident, ?t)) {\n+        case (ast::expr_self_method(?ident, ?t)) {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_self_method(env_, e.span, ident, t2);\n         }\n \n-        case (ast.expr_bind(?f, ?args_opt, ?t)) {\n+        case (ast::expr_bind(?f, ?args_opt, ?t)) {\n             auto ff = fold_expr(env_, fld, f);\n-            let vec[Option.t[@ast.expr]] aargs_opt = vec();\n-            for (Option.t[@ast.expr] t_opt in args_opt) {\n+            let vec[option::t[@ast::expr]] aargs_opt = vec();\n+            for (option::t[@ast::expr] t_opt in args_opt) {\n                 alt (t_opt) {\n-                    case (none[@ast.expr]) {\n-                        aargs_opt += vec(none[@ast.expr]);\n+                    case (none[@ast::expr]) {\n+                        aargs_opt += vec(none[@ast::expr]);\n                     }\n-                    case (some[@ast.expr](?e)) {\n+                    case (some[@ast::expr](?e)) {\n                         aargs_opt += vec(some(fold_expr(env_, fld, e)));\n                     }\n-                    case (none[@ast.expr]) { /* empty */ }\n+                    case (none[@ast::expr]) { /* empty */ }\n                 }\n             }\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_bind(env_, e.span, ff, aargs_opt, t2);\n         }\n \n-        case (ast.expr_spawn(?dom, ?name, ?f, ?args, ?t)) {\n+        case (ast::expr_spawn(?dom, ?name, ?f, ?args, ?t)) {\n             auto ff = fold_expr(env_, fld, f);\n             auto aargs = fold_exprs(env_, fld, args);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_spawn(env_, e.span, dom, name, ff, aargs, t2);\n         }\n \n-        case (ast.expr_binary(?op, ?a, ?b, ?t)) {\n+        case (ast::expr_binary(?op, ?a, ?b, ?t)) {\n             auto aa = fold_expr(env_, fld, a);\n             auto bb = fold_expr(env_, fld, b);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_binary(env_, e.span, op, aa, bb, t2);\n         }\n \n-        case (ast.expr_unary(?op, ?a, ?t)) {\n+        case (ast::expr_unary(?op, ?a, ?t)) {\n             auto aa = fold_expr(env_, fld, a);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_unary(env_, e.span, op, aa, t2);\n         }\n \n-        case (ast.expr_lit(?lit, ?t)) {\n+        case (ast::expr_lit(?lit, ?t)) {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_lit(env_, e.span, lit, t2);\n         }\n \n-        case (ast.expr_cast(?e, ?t, ?at)) {\n+        case (ast::expr_cast(?e, ?t, ?at)) {\n             auto ee = fold_expr(env_, fld, e);\n             auto tt = fold_ty(env, fld, t);\n             auto at2 = fld.fold_ann(env_, at);\n             ret fld.fold_expr_cast(env_, e.span, ee, tt, at2);\n         }\n \n-        case (ast.expr_if(?cnd, ?thn, ?els, ?t)) {\n+        case (ast::expr_if(?cnd, ?thn, ?els, ?t)) {\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto tthn = fold_block(env_, fld, thn);\n             auto eels = none[@expr];\n@@ -653,100 +653,100 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t2);\n         }\n \n-        case (ast.expr_for(?decl, ?seq, ?body, ?t)) {\n+        case (ast::expr_for(?decl, ?seq, ?body, ?t)) {\n             auto ddecl = fold_decl(env_, fld, decl);\n             auto sseq = fold_expr(env_, fld, seq);\n             auto bbody = fold_block(env_, fld, body);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_for(env_, e.span, ddecl, sseq, bbody, t2);\n         }\n \n-        case (ast.expr_for_each(?decl, ?seq, ?body, ?t)) {\n+        case (ast::expr_for_each(?decl, ?seq, ?body, ?t)) {\n             auto ddecl = fold_decl(env_, fld, decl);\n             auto sseq = fold_expr(env_, fld, seq);\n             auto bbody = fold_block(env_, fld, body);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_for_each(env_, e.span, ddecl, sseq, bbody, t2);\n         }\n \n-        case (ast.expr_while(?cnd, ?body, ?t)) {\n+        case (ast::expr_while(?cnd, ?body, ?t)) {\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto bbody = fold_block(env_, fld, body);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_while(env_, e.span, ccnd, bbody, t2);\n         }\n \n-        case (ast.expr_do_while(?body, ?cnd, ?t)) {\n+        case (ast::expr_do_while(?body, ?cnd, ?t)) {\n             auto bbody = fold_block(env_, fld, body);\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_do_while(env_, e.span, bbody, ccnd, t2);\n         }\n \n-        case (ast.expr_alt(?expr, ?arms, ?t)) {\n+        case (ast::expr_alt(?expr, ?arms, ?t)) {\n             auto eexpr = fold_expr(env_, fld, expr);\n-            let vec[ast.arm] aarms = vec();\n-            for (ast.arm a in arms) {\n+            let vec[ast::arm] aarms = vec();\n+            for (ast::arm a in arms) {\n                 aarms += vec(fold_arm(env_, fld, a));\n             }\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_alt(env_, e.span, eexpr, aarms, t2);\n         }\n \n-        case (ast.expr_block(?b, ?t)) {\n+        case (ast::expr_block(?b, ?t)) {\n             auto bb = fold_block(env_, fld, b);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_block(env_, e.span, bb, t2);\n         }\n \n-        case (ast.expr_assign(?lhs, ?rhs, ?t)) {\n+        case (ast::expr_assign(?lhs, ?rhs, ?t)) {\n             auto llhs = fold_expr(env_, fld, lhs);\n             auto rrhs = fold_expr(env_, fld, rhs);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_assign(env_, e.span, llhs, rrhs, t2);\n         }\n \n-        case (ast.expr_assign_op(?op, ?lhs, ?rhs, ?t)) {\n+        case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?t)) {\n             auto llhs = fold_expr(env_, fld, lhs);\n             auto rrhs = fold_expr(env_, fld, rhs);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_assign_op(env_, e.span, op, llhs, rrhs, t2);\n         }\n \n-        case (ast.expr_send(?lhs, ?rhs, ?t)) {\n+        case (ast::expr_send(?lhs, ?rhs, ?t)) {\n             auto llhs = fold_expr(env_, fld, lhs);\n             auto rrhs = fold_expr(env_, fld, rhs);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_send(env_, e.span, llhs, rrhs, t2);\n         }\n \n-        case (ast.expr_recv(?lhs, ?rhs, ?t)) {\n+        case (ast::expr_recv(?lhs, ?rhs, ?t)) {\n             auto llhs = fold_expr(env_, fld, lhs);\n             auto rrhs = fold_expr(env_, fld, rhs);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_recv(env_, e.span, llhs, rrhs, t2);\n         }\n \n-        case (ast.expr_field(?e, ?i, ?t)) {\n+        case (ast::expr_field(?e, ?i, ?t)) {\n             auto ee = fold_expr(env_, fld, e);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_field(env_, e.span, ee, i, t2);\n         }\n \n-        case (ast.expr_index(?e, ?ix, ?t)) {\n+        case (ast::expr_index(?e, ?ix, ?t)) {\n             auto ee = fold_expr(env_, fld, e);\n             auto iix = fold_expr(env_, fld, ix);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_index(env_, e.span, ee, iix, t2);\n         }\n \n-        case (ast.expr_path(?p, ?t)) {\n+        case (ast::expr_path(?p, ?t)) {\n             auto p_ = fold_path(env_, fld, p);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_path(env_, e.span, p_, t2);\n         }\n \n-        case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?t)) {\n+        case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?t)) {\n             // Only fold the expanded expression, not the\n             // expressions involved in syntax extension\n             auto exp = fold_expr(env_, fld, expanded);\n@@ -755,22 +755,22 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n                                   exp, t2);\n         }\n \n-        case (ast.expr_fail(?t)) {\n+        case (ast::expr_fail(?t)) {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_fail(env_, e.span, t2);\n         }\n \n-        case (ast.expr_break(?t)) {\n+        case (ast::expr_break(?t)) {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_break(env_, e.span, t2);\n         }\n \n-        case (ast.expr_cont(?t)) {\n+        case (ast::expr_cont(?t)) {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_cont(env_, e.span, t2);\n         }\n \n-        case (ast.expr_ret(?oe, ?t)) {\n+        case (ast::expr_ret(?oe, ?t)) {\n             auto oee = none[@expr];\n             alt (oe) {\n                 case (some[@expr](?x)) {\n@@ -782,7 +782,7 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_ret(env_, e.span, oee, t2);\n         }\n \n-        case (ast.expr_put(?oe, ?t)) {\n+        case (ast::expr_put(?oe, ?t)) {\n             auto oee = none[@expr];\n             alt (oe) {\n                 case (some[@expr](?x)) {\n@@ -794,36 +794,36 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_put(env_, e.span, oee, t2);\n         }\n \n-        case (ast.expr_be(?x, ?t)) {\n+        case (ast::expr_be(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_be(env_, e.span, ee, t2);\n         }\n \n-        case (ast.expr_log(?l, ?x, ?t)) {\n+        case (ast::expr_log(?l, ?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_log(env_, e.span, l, ee, t2);\n         }\n \n-        case (ast.expr_check(?x, ?t)) {\n+        case (ast::expr_check(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_check(env_, e.span, ee, t2);\n         }\n \n-        case (ast.expr_assert(?x, ?t)) {\n+        case (ast::expr_assert(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_assert(env_, e.span, ee, t2);\n         }\n \n-        case (ast.expr_port(?t)) {\n+        case (ast::expr_port(?t)) {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_port(env_, e.span, t2);\n         }\n \n-        case (ast.expr_chan(?x, ?t)) {\n+        case (ast::expr_chan(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_chan(env_, e.span, ee, t2);\n@@ -843,13 +843,13 @@ fn fold_stmt[ENV](&ENV env, &ast_fold[ENV] fld, &@stmt s) -> @stmt {\n     }\n \n     alt (s.node) {\n-        case (ast.stmt_decl(?d, ?a)) {\n+        case (ast::stmt_decl(?d, ?a)) {\n             auto dd = fold_decl(env_, fld, d);\n             auto aa = fld.fold_ann(env_, a);\n             ret fld.fold_stmt_decl(env_, s.span, dd, aa);\n         }\n \n-        case (ast.stmt_expr(?e, ?a)) {\n+        case (ast::stmt_expr(?e, ?a)) {\n             auto ee = fold_expr(env_, fld, e);\n             auto aa = fld.fold_ann(env_, a);\n             ret fld.fold_stmt_expr(env_, s.span, ee, aa);\n@@ -866,18 +866,18 @@ fn fold_block[ENV](&ENV env, &ast_fold[ENV] fld, &block blk) -> block {\n         ret blk;\n     }\n \n-    let vec[@ast.stmt] stmts = vec();\n-    for (@ast.stmt s in blk.node.stmts) {\n+    let vec[@ast::stmt] stmts = vec();\n+    for (@ast::stmt s in blk.node.stmts) {\n         auto new_stmt = fold_stmt[ENV](env_, fld, s);\n-        Vec.push[@ast.stmt](stmts, new_stmt);\n+        _vec::push[@ast::stmt](stmts, new_stmt);\n     }\n \n-    auto expr = none[@ast.expr];\n+    auto expr = none[@ast::expr];\n     alt (blk.node.expr) {\n-        case (some[@ast.expr](?e)) {\n-            expr = some[@ast.expr](fold_expr[ENV](env_, fld, e));\n+        case (some[@ast::expr](?e)) {\n+            expr = some[@ast::expr](fold_expr[ENV](env_, fld, e));\n         }\n-        case (none[@ast.expr]) {\n+        case (none[@ast::expr]) {\n             // empty\n         }\n     }\n@@ -899,16 +899,16 @@ fn fold_arg[ENV](&ENV env, &ast_fold[ENV] fld, &arg a) -> arg {\n }\n \n fn fold_fn_decl[ENV](&ENV env, &ast_fold[ENV] fld,\n-                     &ast.fn_decl decl) -> ast.fn_decl {\n-    let vec[ast.arg] inputs = vec();\n-    for (ast.arg a in decl.inputs) {\n+                     &ast::fn_decl decl) -> ast::fn_decl {\n+    let vec[ast::arg] inputs = vec();\n+    for (ast::arg a in decl.inputs) {\n         inputs += vec(fold_arg(env, fld, a));\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n     ret fld.fold_fn_decl(env, inputs, output, decl.purity);\n }\n \n-fn fold_fn[ENV](&ENV env, &ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n+fn fold_fn[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_fn f) -> ast::_fn {\n     auto decl = fold_fn_decl(env, fld, f.decl);\n \n     auto body = fold_block[ENV](env, fld, f.body);\n@@ -918,46 +918,46 @@ fn fold_fn[ENV](&ENV env, &ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n \n \n fn fold_obj_field[ENV](&ENV env, &ast_fold[ENV] fld,\n-                       &ast.obj_field f) -> ast.obj_field {\n+                       &ast::obj_field f) -> ast::obj_field {\n     auto ty = fold_ty(env, fld, f.ty);\n     ret rec(ty=ty with f);\n }\n \n \n fn fold_method[ENV](&ENV env, &ast_fold[ENV] fld,\n-                    &@ast.method m) -> @ast.method {\n+                    &@ast::method m) -> @ast::method {\n     auto meth = fold_fn(env, fld, m.node.meth);\n     ret @rec(node=rec(meth=meth with m.node) with *m);\n }\n \n \n-fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n+fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n \n-    let vec[ast.obj_field] fields = vec();\n-    let vec[@ast.method] meths = vec();\n-    for (ast.obj_field f in ob.fields) {\n+    let vec[ast::obj_field] fields = vec();\n+    let vec[@ast::method] meths = vec();\n+    for (ast::obj_field f in ob.fields) {\n         fields += vec(fold_obj_field(env, fld, f));\n     }\n-    let Option.t[@ast.method] dtor = none[@ast.method];\n+    let option::t[@ast::method] dtor = none[@ast::method];\n     alt (ob.dtor) {\n-        case (none[@ast.method]) { }\n-        case (some[@ast.method](?m)) {\n-            dtor = some[@ast.method](fold_method[ENV](env, fld, m));\n+        case (none[@ast::method]) { }\n+        case (some[@ast::method](?m)) {\n+            dtor = some[@ast::method](fold_method[ENV](env, fld, m));\n         }\n     }\n-    let vec[ast.ty_param] tp = vec();\n-    for (@ast.method m in ob.methods) {\n-        // Fake-up an ast.item for this method.\n+    let vec[ast::ty_param] tp = vec();\n+    for (@ast::method m in ob.methods) {\n+        // Fake-up an ast::item for this method.\n         // FIXME: this is kinda awful. Maybe we should reformulate\n         // the way we store methods in the AST?\n-        let @ast.item i = @rec(node=ast.item_fn(m.node.ident,\n+        let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n                                                 m.node.meth,\n                                                 tp,\n                                                 m.node.id,\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        Vec.push[@ast.method](meths, fold_method(_env, fld, m));\n+        _vec::push[@ast::method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n@@ -972,16 +972,16 @@ fn fold_view_item[ENV](&ENV env, &ast_fold[ENV] fld, &@view_item vi)\n     }\n \n     alt (vi.node) {\n-        case (ast.view_item_use(?ident, ?meta_items, ?def_id, ?cnum)) {\n+        case (ast::view_item_use(?ident, ?meta_items, ?def_id, ?cnum)) {\n             ret fld.fold_view_item_use(env_, vi.span, ident, meta_items,\n                                        def_id, cnum);\n         }\n-        case (ast.view_item_import(?def_ident, ?idents, ?def_id)) {\n+        case (ast::view_item_import(?def_ident, ?idents, ?def_id)) {\n             ret fld.fold_view_item_import(env_, vi.span, def_ident, idents,\n                                           def_id);\n         }\n \n-        case (ast.view_item_export(?def_ident)) {\n+        case (ast::view_item_export(?def_ident)) {\n             ret fld.fold_view_item_export(env_, vi.span, def_ident);\n         }\n     }\n@@ -999,50 +999,50 @@ fn fold_item[ENV](&ENV env, &ast_fold[ENV] fld, &@item i) -> @item {\n \n     alt (i.node) {\n \n-        case (ast.item_const(?ident, ?t, ?e, ?id, ?ann)) {\n-            let @ast.ty t_ = fold_ty[ENV](env_, fld, t);\n-            let @ast.expr e_ = fold_expr(env_, fld, e);\n+        case (ast::item_const(?ident, ?t, ?e, ?id, ?ann)) {\n+            let @ast::ty t_ = fold_ty[ENV](env_, fld, t);\n+            let @ast::expr e_ = fold_expr(env_, fld, e);\n             ret fld.fold_item_const(env_, i.span, ident, t_, e_, id, ann);\n         }\n \n-        case (ast.item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n-            let ast._fn ff_ = fold_fn[ENV](env_, fld, ff);\n+        case (ast::item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n+            let ast::_fn ff_ = fold_fn[ENV](env_, fld, ff);\n             ret fld.fold_item_fn(env_, i.span, ident, ff_, tps, id, ann);\n         }\n \n-        case (ast.item_mod(?ident, ?mm, ?id)) {\n-            let ast._mod mm_ = fold_mod[ENV](env_, fld, mm);\n+        case (ast::item_mod(?ident, ?mm, ?id)) {\n+            let ast::_mod mm_ = fold_mod[ENV](env_, fld, mm);\n             ret fld.fold_item_mod(env_, i.span, ident, mm_, id);\n         }\n \n-        case (ast.item_native_mod(?ident, ?mm, ?id)) {\n-            let ast.native_mod mm_ = fold_native_mod[ENV](env_, fld, mm);\n+        case (ast::item_native_mod(?ident, ?mm, ?id)) {\n+            let ast::native_mod mm_ = fold_native_mod[ENV](env_, fld, mm);\n             ret fld.fold_item_native_mod(env_, i.span, ident, mm_, id);\n         }\n \n-        case (ast.item_ty(?ident, ?ty, ?params, ?id, ?ann)) {\n-            let @ast.ty ty_ = fold_ty[ENV](env_, fld, ty);\n+        case (ast::item_ty(?ident, ?ty, ?params, ?id, ?ann)) {\n+            let @ast::ty ty_ = fold_ty[ENV](env_, fld, ty);\n             ret fld.fold_item_ty(env_, i.span, ident, ty_, params, id, ann);\n         }\n \n-        case (ast.item_tag(?ident, ?variants, ?ty_params, ?id, ?ann)) {\n-            let vec[ast.variant] new_variants = vec();\n-            for (ast.variant v in variants) {\n-                let vec[ast.variant_arg] new_args = vec();\n-                for (ast.variant_arg va in v.node.args) {\n+        case (ast::item_tag(?ident, ?variants, ?ty_params, ?id, ?ann)) {\n+            let vec[ast::variant] new_variants = vec();\n+            for (ast::variant v in variants) {\n+                let vec[ast::variant_arg] new_args = vec();\n+                for (ast::variant_arg va in v.node.args) {\n                     auto new_ty = fold_ty[ENV](env_, fld, va.ty);\n                     new_args += vec(rec(ty=new_ty, id=va.id));\n                 }\n                 auto new_v = rec(name=v.node.name, args=new_args,\n                                  id=v.node.id, ann=v.node.ann);\n-                new_variants += vec(respan[ast.variant_](v.span, new_v));\n+                new_variants += vec(respan[ast::variant_](v.span, new_v));\n             }\n             ret fld.fold_item_tag(env_, i.span, ident, new_variants,\n                                   ty_params, id, ann);\n         }\n \n-        case (ast.item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n-            let ast._obj ob_ = fold_obj[ENV](env_, fld, ob);\n+        case (ast::item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n+            let ast::_obj ob_ = fold_obj[ENV](env_, fld, ob);\n             ret fld.fold_item_obj(env_, i.span, ident, ob_, tps, odid, ann);\n         }\n \n@@ -1051,19 +1051,19 @@ fn fold_item[ENV](&ENV env, &ast_fold[ENV] fld, &@item i) -> @item {\n     fail;\n }\n \n-fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n+fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast::_mod m) -> ast::_mod {\n \n     let vec[@view_item] view_items = vec();\n     let vec[@item] items = vec();\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        Vec.push[@view_item](view_items, new_vi);\n+        _vec::push[@view_item](view_items, new_vi);\n     }\n \n     for (@item i in m.items) {\n         auto new_item = fold_item[ENV](e, fld, i);\n-        Vec.push[@item](items, new_item);\n+        _vec::push[@item](items, new_item);\n     }\n \n     ret fld.fold_mod(e, rec(view_items=view_items, items=items));\n@@ -1077,10 +1077,10 @@ fn fold_native_item[ENV](&ENV env, &ast_fold[ENV] fld,\n         ret i;\n     }\n     alt (i.node) {\n-        case (ast.native_item_ty(?ident, ?id)) {\n+        case (ast::native_item_ty(?ident, ?id)) {\n             ret fld.fold_native_item_ty(env_, i.span, ident, id);\n         }\n-        case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n+        case (ast::native_item_fn(?ident, ?lname, ?fn_decl,\n                                  ?ty_params, ?id, ?ann)) {\n             auto d = fold_fn_decl[ENV](env_, fld, fn_decl);\n             ret fld.fold_native_item_fn(env_, i.span, ident, lname, d,\n@@ -1090,18 +1090,18 @@ fn fold_native_item[ENV](&ENV env, &ast_fold[ENV] fld,\n }\n \n fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n-                        &ast.native_mod m) -> ast.native_mod {\n+                        &ast::native_mod m) -> ast::native_mod {\n     let vec[@view_item] view_items = vec();\n     let vec[@native_item] items = vec();\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        Vec.push[@view_item](view_items, new_vi);\n+        _vec::push[@view_item](view_items, new_vi);\n     }\n \n     for (@native_item i in m.items) {\n         auto new_item = fold_native_item[ENV](e, fld, i);\n-        Vec.push[@native_item](items, new_item);\n+        _vec::push[@native_item](items, new_item);\n     }\n \n     ret fld.fold_native_mod(e, rec(native_name=m.native_name,\n@@ -1111,12 +1111,12 @@ fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n }\n \n fn fold_crate[ENV](&ENV env, &ast_fold[ENV] fld,\n-                   &@ast.crate c) -> @ast.crate {\n+                   &@ast::crate c) -> @ast::crate {\n     // FIXME: possibly fold the directives so you process any expressions\n-    // within them? Not clear. After front/eval.rs, nothing else should look\n+    // within them? Not clear. After front/eval::rs, nothing else should look\n     // at crate directives.\n     let ENV env_ = fld.update_env_for_crate(env, c);\n-    let ast._mod m = fold_mod[ENV](env_, fld, c.node.module);\n+    let ast::_mod m = fold_mod[ENV](env_, fld, c.node.module);\n     ret fld.fold_crate(env_, c.span, c.node.directives, m);\n }\n \n@@ -1129,332 +1129,332 @@ fn respan[T](&span sp, &T t) -> spanned[T] {\n \n // Path identity.\n \n-fn identity_fold_path[ENV](&ENV env, &span sp, &ast.path_ p) -> path {\n+fn identity_fold_path[ENV](&ENV env, &span sp, &ast::path_ p) -> path {\n     ret respan(sp, p);\n }\n \n // Type identities.\n \n fn identity_fold_ty_nil[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_nil);\n+    ret @respan(sp, ast::ty_nil);\n }\n \n fn identity_fold_ty_bool[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_bool);\n+    ret @respan(sp, ast::ty_bool);\n }\n \n fn identity_fold_ty_int[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_int);\n+    ret @respan(sp, ast::ty_int);\n }\n \n fn identity_fold_ty_uint[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_uint);\n+    ret @respan(sp, ast::ty_uint);\n }\n \n fn identity_fold_ty_float[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_float);\n+    ret @respan(sp, ast::ty_float);\n }\n \n fn identity_fold_ty_machine[ENV](&ENV env, &span sp,\n                                  ty_mach tm) -> @ty {\n-    ret @respan(sp, ast.ty_machine(tm));\n+    ret @respan(sp, ast::ty_machine(tm));\n }\n \n fn identity_fold_ty_char[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_char);\n+    ret @respan(sp, ast::ty_char);\n }\n \n fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast.ty_str);\n+    ret @respan(sp, ast::ty_str);\n }\n \n fn identity_fold_ty_box[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n-    ret @respan(sp, ast.ty_box(tm));\n+    ret @respan(sp, ast::ty_box(tm));\n }\n \n fn identity_fold_ty_vec[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n-    ret @respan(sp, ast.ty_vec(tm));\n+    ret @respan(sp, ast::ty_vec(tm));\n }\n \n fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n                              &vec[mt] elts) -> @ty {\n-    ret @respan(sp, ast.ty_tup(elts));\n+    ret @respan(sp, ast::ty_tup(elts));\n }\n \n fn identity_fold_ty_rec[ENV](&ENV env, &span sp,\n-                             &vec[ast.ty_field] elts) -> @ty {\n-    ret @respan(sp, ast.ty_rec(elts));\n+                             &vec[ast::ty_field] elts) -> @ty {\n+    ret @respan(sp, ast::ty_rec(elts));\n }\n \n fn identity_fold_ty_obj[ENV](&ENV env, &span sp,\n-                             &vec[ast.ty_method] meths) -> @ty {\n-    ret @respan(sp, ast.ty_obj(meths));\n+                             &vec[ast::ty_method] meths) -> @ty {\n+    ret @respan(sp, ast::ty_obj(meths));\n }\n \n fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n-                            ast.proto proto,\n-                            &vec[rec(ast.mode mode, @ty ty)] inputs,\n+                            ast::proto proto,\n+                            &vec[rec(ast::mode mode, @ty ty)] inputs,\n                             &@ty output) -> @ty {\n-    ret @respan(sp, ast.ty_fn(proto, inputs, output));\n+    ret @respan(sp, ast::ty_fn(proto, inputs, output));\n }\n \n-fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast.path p,\n+fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast::path p,\n                               &ann a) -> @ty {\n-    ret @respan(sp, ast.ty_path(p, a));\n+    ret @respan(sp, ast::ty_path(p, a));\n }\n \n fn identity_fold_ty_chan[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n-    ret @respan(sp, ast.ty_chan(t));\n+    ret @respan(sp, ast::ty_chan(t));\n }\n \n fn identity_fold_ty_port[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n-    ret @respan(sp, ast.ty_port(t));\n+    ret @respan(sp, ast::ty_port(t));\n }\n \n // Expr identities.\n \n fn identity_fold_expr_vec[ENV](&ENV env, &span sp, &vec[@expr] es,\n-                               ast.mutability mut, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_vec(es, mut, a));\n+                               ast::mutability mut, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_vec(es, mut, a));\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n-                               &vec[ast.elt] es, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_tup(es, a));\n+                               &vec[ast::elt] es, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_tup(es, a));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               &vec[ast.field] fields,\n-                               &Option.t[@expr] base, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_rec(fields, base, a));\n+                               &vec[ast::field] fields,\n+                               &option::t[@expr] base, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_rec(fields, base, a));\n }\n \n fn identity_fold_expr_call[ENV](&ENV env, &span sp, &@expr f,\n                                 &vec[@expr] args, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_call(f, args, a));\n+    ret @respan(sp, ast::expr_call(f, args, a));\n }\n \n fn identity_fold_expr_self_method[ENV](&ENV env, &span sp, &ident id,\n                                        &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_self_method(id, a));\n+    ret @respan(sp, ast::expr_self_method(id, a));\n }\n \n fn identity_fold_expr_bind[ENV](&ENV env, &span sp, &@expr f,\n-                                &vec[Option.t[@expr]] args_opt, &ann a)\n+                                &vec[option::t[@expr]] args_opt, &ann a)\n         -> @expr {\n-    ret @respan(sp, ast.expr_bind(f, args_opt, a));\n+    ret @respan(sp, ast::expr_bind(f, args_opt, a));\n }\n \n fn identity_fold_expr_spawn[ENV](&ENV env, &span sp,\n-                                 ast.spawn_dom dom, &Option.t[str] name,\n+                                 ast::spawn_dom dom, &option::t[str] name,\n                                  &@expr f, &vec[@expr] args,\n                                  &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_spawn(dom, name, f, args, a));\n+    ret @respan(sp, ast::expr_spawn(dom, name, f, args, a));\n }\n \n-fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n+fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast::binop b,\n                                   &@expr lhs, &@expr rhs,\n                                   &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_binary(b, lhs, rhs, a));\n+    ret @respan(sp, ast::expr_binary(b, lhs, rhs, a));\n }\n \n fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast.unop u, &@expr e, &ann a)\n+                                 ast::unop u, &@expr e, &ann a)\n         -> @expr {\n-    ret @respan(sp, ast.expr_unary(u, e, a));\n+    ret @respan(sp, ast::expr_unary(u, e, a));\n }\n \n-fn identity_fold_expr_lit[ENV](&ENV env, &span sp, &@ast.lit lit,\n+fn identity_fold_expr_lit[ENV](&ENV env, &span sp, &@ast::lit lit,\n                                &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_lit(lit, a));\n+    ret @respan(sp, ast::expr_lit(lit, a));\n }\n \n-fn identity_fold_expr_cast[ENV](&ENV env, &span sp, &@ast.expr e,\n-                                &@ast.ty t, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_cast(e, t, a));\n+fn identity_fold_expr_cast[ENV](&ENV env, &span sp, &@ast::expr e,\n+                                &@ast::ty t, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_cast(e, t, a));\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               &@expr cond, &block thn,\n-                              &Option.t[@expr] els, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_if(cond, thn, els, a));\n+                              &option::t[@expr] els, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_if(cond, thn, els, a));\n }\n \n fn identity_fold_expr_for[ENV](&ENV env, &span sp,\n                                &@decl d, &@expr seq,\n                                &block body, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_for(d, seq, body, a));\n+    ret @respan(sp, ast::expr_for(d, seq, body, a));\n }\n \n fn identity_fold_expr_for_each[ENV](&ENV env, &span sp,\n                                     &@decl d, &@expr seq,\n                                     &block body, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_for_each(d, seq, body, a));\n+    ret @respan(sp, ast::expr_for_each(d, seq, body, a));\n }\n \n fn identity_fold_expr_while[ENV](&ENV env, &span sp,\n                                  &@expr cond, &block body, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_while(cond, body, a));\n+    ret @respan(sp, ast::expr_while(cond, body, a));\n }\n \n fn identity_fold_expr_do_while[ENV](&ENV env, &span sp,\n                                     &block body, &@expr cond,\n                                     &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_do_while(body, cond, a));\n+    ret @respan(sp, ast::expr_do_while(body, cond, a));\n }\n \n fn identity_fold_expr_alt[ENV](&ENV env, &span sp,\n                                &@expr e, &vec[arm] arms,\n                                &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_alt(e, arms, a));\n+    ret @respan(sp, ast::expr_alt(e, arms, a));\n }\n \n fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n                                  &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_block(blk, a));\n+    ret @respan(sp, ast::expr_block(blk, a));\n }\n \n fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n                                   &@expr lhs, &@expr rhs, &ann a)\n         -> @expr {\n-    ret @respan(sp, ast.expr_assign(lhs, rhs, a));\n+    ret @respan(sp, ast::expr_assign(lhs, rhs, a));\n }\n \n-fn identity_fold_expr_assign_op[ENV](&ENV env, &span sp, ast.binop op,\n+fn identity_fold_expr_assign_op[ENV](&ENV env, &span sp, ast::binop op,\n                                      &@expr lhs, &@expr rhs, &ann a)\n         -> @expr {\n-    ret @respan(sp, ast.expr_assign_op(op, lhs, rhs, a));\n+    ret @respan(sp, ast::expr_assign_op(op, lhs, rhs, a));\n }\n \n fn identity_fold_expr_send[ENV](&ENV e, &span sp,\n                                 &@expr lhs, &@expr rhs, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_send(lhs, rhs, a));\n+    ret @respan(sp, ast::expr_send(lhs, rhs, a));\n }\n \n fn identity_fold_expr_recv[ENV](&ENV e, &span sp,\n                                 &@expr lhs, &@expr rhs, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_recv(lhs, rhs, a));\n+    ret @respan(sp, ast::expr_recv(lhs, rhs, a));\n }\n \n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n                                  &@expr e, &ident i, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_field(e, i, a));\n+    ret @respan(sp, ast::expr_field(e, i, a));\n }\n \n fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n                                  &@expr e, &@expr ix, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_index(e, ix, a));\n+    ret @respan(sp, ast::expr_index(e, ix, a));\n }\n \n fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n                                 &path p, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_path(p, a));\n+    ret @respan(sp, ast::expr_path(p, a));\n }\n \n fn identity_fold_expr_ext[ENV](&ENV env, &span sp,\n                                &path p, &vec[@expr] args,\n-                               &Option.t[str] body,\n+                               &option::t[str] body,\n                                &@expr expanded,\n                                &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_ext(p, args, body, expanded, a));\n+    ret @respan(sp, ast::expr_ext(p, args, body, expanded, a));\n }\n \n fn identity_fold_expr_fail[ENV](&ENV env, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_fail(a));\n+    ret @respan(sp, ast::expr_fail(a));\n }\n \n fn identity_fold_expr_break[ENV](&ENV env, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_break(a));\n+    ret @respan(sp, ast::expr_break(a));\n }\n \n fn identity_fold_expr_cont[ENV](&ENV env, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_cont(a));\n+    ret @respan(sp, ast::expr_cont(a));\n }\n \n fn identity_fold_expr_ret[ENV](&ENV env, &span sp,\n-                               &Option.t[@expr] rv, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_ret(rv, a));\n+                               &option::t[@expr] rv, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_ret(rv, a));\n }\n \n fn identity_fold_expr_put[ENV](&ENV env, &span sp,\n-                               &Option.t[@expr] rv, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_put(rv, a));\n+                               &option::t[@expr] rv, &ann a) -> @expr {\n+    ret @respan(sp, ast::expr_put(rv, a));\n }\n \n fn identity_fold_expr_be[ENV](&ENV env, &span sp,\n                               &@expr x, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_be(x, a));\n+    ret @respan(sp, ast::expr_be(x, a));\n }\n \n fn identity_fold_expr_log[ENV](&ENV e, &span sp, int lvl, &@expr x,\n                                &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_log(lvl, x, a));\n+    ret @respan(sp, ast::expr_log(lvl, x, a));\n }\n \n fn identity_fold_expr_check[ENV](&ENV e, &span sp, &@expr x, &ann a)\n     -> @expr {\n-    ret @respan(sp, ast.expr_check(x, a));\n+    ret @respan(sp, ast::expr_check(x, a));\n }\n \n fn identity_fold_expr_assert[ENV](&ENV e, &span sp, &@expr x, &ann a)\n     -> @expr {\n-    ret @respan(sp, ast.expr_assert(x, a));\n+    ret @respan(sp, ast::expr_assert(x, a));\n }\n \n fn identity_fold_expr_port[ENV](&ENV e, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_port(a));\n+    ret @respan(sp, ast::expr_port(a));\n }\n \n fn identity_fold_expr_chan[ENV](&ENV e, &span sp, &@expr x,\n                                 &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_chan(x, a));\n+    ret @respan(sp, ast::expr_chan(x, a));\n }\n \n // Decl identities.\n \n fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n-                                 &@ast.local local) -> @decl {\n-    ret @respan(sp, ast.decl_local(local));\n+                                 &@ast::local local) -> @decl {\n+    ret @respan(sp, ast::decl_local(local));\n }\n \n fn identity_fold_decl_item[ENV](&ENV e, &span sp, &@item i) -> @decl {\n-    ret @respan(sp, ast.decl_item(i));\n+    ret @respan(sp, ast::decl_item(i));\n }\n \n \n // Pat identities.\n \n fn identity_fold_pat_wild[ENV](&ENV e, &span sp, &ann a) -> @pat {\n-    ret @respan(sp, ast.pat_wild(a));\n+    ret @respan(sp, ast::pat_wild(a));\n }\n \n fn identity_fold_pat_lit[ENV](&ENV e, &span sp,\n-                              &@ast.lit lit, &ann a) -> @pat {\n-    ret @respan(sp, ast.pat_lit(lit, a));\n+                              &@ast::lit lit, &ann a) -> @pat {\n+    ret @respan(sp, ast::pat_lit(lit, a));\n }\n \n fn identity_fold_pat_bind[ENV](&ENV e, &span sp, &ident i,\n                                &def_id did, &ann a)\n         -> @pat {\n-    ret @respan(sp, ast.pat_bind(i, did, a));\n+    ret @respan(sp, ast::pat_bind(i, did, a));\n }\n \n fn identity_fold_pat_tag[ENV](&ENV e, &span sp, &path p, &vec[@pat] args,\n                               &ann a) -> @pat {\n-    ret @respan(sp, ast.pat_tag(p, args, a));\n+    ret @respan(sp, ast::pat_tag(p, args, a));\n }\n \n \n // Stmt identities.\n \n fn identity_fold_stmt_decl[ENV](&ENV env, &span sp,\n                                 &@decl d, &ann a) -> @stmt {\n-    ret @respan(sp, ast.stmt_decl(d, a));\n+    ret @respan(sp, ast::stmt_decl(d, a));\n }\n \n fn identity_fold_stmt_expr[ENV](&ENV e, &span sp,\n                                 &@expr x, &ann a) -> @stmt {\n-    ret @respan(sp, ast.stmt_expr(x, a));\n+    ret @respan(sp, ast::stmt_expr(x, a));\n }\n \n \n@@ -1463,76 +1463,77 @@ fn identity_fold_stmt_expr[ENV](&ENV e, &span sp,\n fn identity_fold_item_const[ENV](&ENV e, &span sp, &ident i,\n                                   &@ty t, &@expr ex,\n                                  &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast.item_const(i, t, ex, id, a));\n+    ret @respan(sp, ast::item_const(i, t, ex, id, a));\n }\n \n fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ident i,\n-                              &ast._fn f, &vec[ast.ty_param] ty_params,\n+                              &ast::_fn f, &vec[ast::ty_param] ty_params,\n                               &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n+    ret @respan(sp, ast::item_fn(i, f, ty_params, id, a));\n }\n \n fn identity_fold_native_item_fn[ENV](&ENV e, &span sp, &ident i,\n-                                     &Option.t[str] link_name,\n-                                     &ast.fn_decl decl,\n-                                     &vec[ast.ty_param] ty_params,\n+                                     &option::t[str] link_name,\n+                                     &ast::fn_decl decl,\n+                                     &vec[ast::ty_param] ty_params,\n                                      &def_id id, &ann a) -> @native_item {\n-    ret @respan(sp, ast.native_item_fn(i, link_name, decl, ty_params, id, a));\n+    ret @respan(sp, ast::native_item_fn(i, link_name, decl, ty_params,\n+                                        id, a));\n }\n \n fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ident i,\n-                               &ast._mod m, &def_id id) -> @item {\n-    ret @respan(sp, ast.item_mod(i, m, id));\n+                               &ast::_mod m, &def_id id) -> @item {\n+    ret @respan(sp, ast::item_mod(i, m, id));\n }\n \n fn identity_fold_item_native_mod[ENV](&ENV e, &span sp, &ident i,\n-                                      &ast.native_mod m,\n+                                      &ast::native_mod m,\n                                       &def_id id) -> @item {\n-    ret @respan(sp, ast.item_native_mod(i, m, id));\n+    ret @respan(sp, ast::item_native_mod(i, m, id));\n }\n \n fn identity_fold_item_ty[ENV](&ENV e, &span sp, &ident i,\n-                              &@ty t, &vec[ast.ty_param] ty_params,\n+                              &@ty t, &vec[ast::ty_param] ty_params,\n                               &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast.item_ty(i, t, ty_params, id, a));\n+    ret @respan(sp, ast::item_ty(i, t, ty_params, id, a));\n }\n \n fn identity_fold_native_item_ty[ENV](&ENV e, &span sp, &ident i,\n                                      &def_id id) -> @native_item {\n-    ret @respan(sp, ast.native_item_ty(i, id));\n+    ret @respan(sp, ast::native_item_ty(i, id));\n }\n \n fn identity_fold_item_tag[ENV](&ENV e, &span sp, &ident i,\n-                               &vec[ast.variant] variants,\n-                               &vec[ast.ty_param] ty_params,\n+                               &vec[ast::variant] variants,\n+                               &vec[ast::ty_param] ty_params,\n                                &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast.item_tag(i, variants, ty_params, id, a));\n+    ret @respan(sp, ast::item_tag(i, variants, ty_params, id, a));\n }\n \n fn identity_fold_item_obj[ENV](&ENV e, &span sp, &ident i,\n-                               &ast._obj ob, &vec[ast.ty_param] ty_params,\n-                               &ast.obj_def_ids odid, &ann a) -> @item {\n-    ret @respan(sp, ast.item_obj(i, ob, ty_params, odid, a));\n+                               &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+                               &ast::obj_def_ids odid, &ann a) -> @item {\n+    ret @respan(sp, ast::item_obj(i, ob, ty_params, odid, a));\n }\n \n // View Item folds.\n \n fn identity_fold_view_item_use[ENV](&ENV e, &span sp, &ident i,\n                                     &vec[@meta_item] meta_items,\n-                                    &def_id id, &Option.t[int] cnum)\n+                                    &def_id id, &option::t[int] cnum)\n     -> @view_item {\n-    ret @respan(sp, ast.view_item_use(i, meta_items, id, cnum));\n+    ret @respan(sp, ast::view_item_use(i, meta_items, id, cnum));\n }\n \n fn identity_fold_view_item_import[ENV](&ENV e, &span sp, &ident i,\n                                        &vec[ident] is, &def_id id)\n     -> @view_item {\n-    ret @respan(sp, ast.view_item_import(i, is, id));\n+    ret @respan(sp, ast::view_item_import(i, is, id));\n }\n \n fn identity_fold_view_item_export[ENV](&ENV e, &span sp, &ident i)\n     -> @view_item {\n-    ret @respan(sp, ast.view_item_export(i));\n+    ret @respan(sp, ast::view_item_export(i));\n }\n \n // Annotation folding.\n@@ -1543,50 +1544,50 @@ fn identity_fold_ann[ENV](&ENV e, &ann a) -> ann {\n \n // Additional identities.\n \n-fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n+fn identity_fold_block[ENV](&ENV e, &span sp, &ast::block_ blk) -> block {\n     ret respan(sp, blk);\n }\n \n fn identity_fold_fn_decl[ENV](&ENV e,\n                               &vec[arg] inputs,\n                               &@ty output,\n-                              &purity p) -> ast.fn_decl {\n+                              &purity p) -> ast::fn_decl {\n     ret rec(inputs=inputs, output=output, purity=p);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n                          &fn_decl decl,\n-                         ast.proto proto,\n-                         &block body) -> ast._fn {\n+                         ast::proto proto,\n+                         &block body) -> ast::_fn {\n     ret rec(decl=decl, proto=proto, body=body);\n }\n \n-fn identity_fold_mod[ENV](&ENV e, &ast._mod m) -> ast._mod {\n+fn identity_fold_mod[ENV](&ENV e, &ast::_mod m) -> ast::_mod {\n     ret m;\n }\n \n fn identity_fold_native_mod[ENV](&ENV e,\n-                                 &ast.native_mod m) -> ast.native_mod {\n+                                 &ast::native_mod m) -> ast::native_mod {\n     ret m;\n }\n \n fn identity_fold_crate[ENV](&ENV e, &span sp,\n-                            &vec[@ast.crate_directive] cdirs,\n-                            &ast._mod m) -> @ast.crate {\n+                            &vec[@ast::crate_directive] cdirs,\n+                            &ast::_mod m) -> @ast::crate {\n     ret @respan(sp, rec(directives=cdirs, module=m));\n }\n \n fn identity_fold_obj[ENV](&ENV e,\n-                          &vec[ast.obj_field] fields,\n-                          &vec[@ast.method] methods,\n-                          &Option.t[@ast.method] dtor) -> ast._obj {\n+                          &vec[ast::obj_field] fields,\n+                          &vec[@ast::method] methods,\n+                          &option::t[@ast::method] dtor) -> ast::_obj {\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n \n \n // Env update identities.\n \n-fn identity_update_env_for_crate[ENV](&ENV e, &@ast.crate c) -> ENV {\n+fn identity_update_env_for_crate[ENV](&ENV e, &@ast::crate c) -> ENV {\n     ret e;\n }\n "}, {"sha": "e10f2e7319e19827c0b37bb505313a85fccb901f", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 257, "deletions": 257, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,23 +1,23 @@\n-import std.Str;\n-import std.UInt;\n-import std.Vec;\n-import std.Map.hashmap;\n-import std.EBML;\n-import std.IO;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-\n-import front.ast;\n-import middle.fold;\n-import middle.trans;\n-import middle.ty;\n-import back.x86;\n-import util.common;\n-\n-import lib.llvm.llvm;\n-import lib.llvm.llvm.ValueRef;\n-import lib.llvm.False;\n+import std::_str;\n+import std::_uint;\n+import std::_vec;\n+import std::map::hashmap;\n+import std::ebml;\n+import std::io;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+\n+import front::ast;\n+import middle::fold;\n+import middle::trans;\n+import middle::ty;\n+import back::x86;\n+import util::common;\n+\n+import lib::llvm::llvm;\n+import lib::llvm::llvm::ValueRef;\n+import lib::llvm::False;\n \n const uint tag_paths = 0x01u;\n const uint tag_items = 0x02u;\n@@ -55,14 +55,14 @@ type ty_abbrev = rec(uint pos, uint len, str s);\n \n tag abbrev_ctxt {\n     ac_no_abbrevs;\n-    ac_use_abbrevs(hashmap[ty.t, ty_abbrev]);\n+    ac_use_abbrevs(hashmap[ty::t, ty_abbrev]);\n }\n \n mod Encode {\n \n     type ctxt = rec(\n-        fn(&ast.def_id) -> str ds,          // Def -> str Callback.\n-        ty.ctxt tcx,                        // The type context.\n+        fn(&ast::def_id) -> str ds,          // Def -> str Callback:\n+        ty::ctxt tcx,                        // The type context.\n         abbrev_ctxt abbrevs\n     );\n \n@@ -73,22 +73,22 @@ mod Encode {\n         }\n     }\n \n-    fn ty_str(&@ctxt cx, &ty.t t) -> str {\n+    fn ty_str(&@ctxt cx, &ty::t t) -> str {\n         assert (!cx_uses_abbrevs(cx));\n-        auto sw = IO.string_writer();\n+        auto sw = io::string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();\n     }\n \n-    fn enc_ty(&IO.writer w, &@ctxt cx, &ty.t t) {\n+    fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n         alt (cx.abbrevs) {\n             case (ac_no_abbrevs) {\n                 auto result_str;\n                 alt (cx.tcx.short_names_cache.find(t)) {\n                     case (some[str](?s)) { result_str = s; }\n                     case (none[str]) {\n-                        auto sw = IO.string_writer();\n-                        enc_sty(sw.get_writer(), cx, ty.struct(cx.tcx, t));\n+                        auto sw = io::string_writer();\n+                        enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n                         result_str = sw.get_str();\n                         cx.tcx.short_names_cache.insert(t, result_str);\n                     }\n@@ -103,7 +103,7 @@ mod Encode {\n                     }\n                     case (none[ty_abbrev]) {\n                         auto pos = w.get_buf_writer().tell();\n-                        auto ss = enc_sty(w, cx, ty.struct(cx.tcx, t));\n+                        auto ss = enc_sty(w, cx, ty::struct(cx.tcx, t));\n                         auto end = w.get_buf_writer().tell();\n                         auto len = end-pos;\n                         fn estimate_sz(uint u) -> uint {\n@@ -121,8 +121,8 @@ mod Encode {\n                         if (abbrev_len < len) {\n                             // I.e. it's actually an abbreviation.\n                             auto s = (\"#\"\n-                                      + UInt.to_str(pos, 16u) + \":\"\n-                                      + UInt.to_str(len, 16u) + \"#\");\n+                                      + _uint::to_str(pos, 16u) + \":\"\n+                                      + _uint::to_str(len, 16u) + \"#\");\n                             auto a = rec(pos=pos, len=len, s=s);\n                             abbrevs.insert(t, a);\n                         }\n@@ -133,127 +133,127 @@ mod Encode {\n         }\n     }\n \n-    fn enc_mt(&IO.writer w, &@ctxt cx, &ty.mt mt) {\n+    fn enc_mt(&io::writer w, &@ctxt cx, &ty::mt mt) {\n         alt (mt.mut) {\n-            case (ast.imm)       { }\n-            case (ast.mut)       { w.write_char('m'); }\n-            case (ast.maybe_mut) { w.write_char('?'); }\n+            case (ast::imm)       { }\n+            case (ast::mut)       { w.write_char('m'); }\n+            case (ast::maybe_mut) { w.write_char('?'); }\n         }\n         enc_ty(w, cx, mt.ty);\n     }\n \n-    fn enc_sty(&IO.writer w, &@ctxt cx, &ty.sty st) {\n+    fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         alt (st) {\n-            case (ty.ty_nil) { w.write_char('n'); }\n-            case (ty.ty_bool) { w.write_char('b'); }\n-            case (ty.ty_int) { w.write_char('i'); }\n-            case (ty.ty_uint) { w.write_char('u'); }\n-            case (ty.ty_float) { w.write_char('l'); }\n-            case (ty.ty_machine(?mach)) {\n+            case (ty::ty_nil) { w.write_char('n'); }\n+            case (ty::ty_bool) { w.write_char('b'); }\n+            case (ty::ty_int) { w.write_char('i'); }\n+            case (ty::ty_uint) { w.write_char('u'); }\n+            case (ty::ty_float) { w.write_char('l'); }\n+            case (ty::ty_machine(?mach)) {\n                 alt (mach) {\n-                    case (common.ty_u8) { w.write_str(\"Mb\"); }\n-                    case (common.ty_u16) { w.write_str(\"Mw\"); }\n-                    case (common.ty_u32) { w.write_str(\"Ml\"); }\n-                    case (common.ty_u64) { w.write_str(\"Md\"); }\n-                    case (common.ty_i8) { w.write_str(\"MB\"); }\n-                    case (common.ty_i16) { w.write_str(\"MW\"); }\n-                    case (common.ty_i32) { w.write_str(\"ML\"); }\n-                    case (common.ty_i64) { w.write_str(\"MD\"); }\n-                    case (common.ty_f32) { w.write_str(\"Mf\"); }\n-                    case (common.ty_f64) { w.write_str(\"MF\"); }\n+                    case (common::ty_u8) { w.write_str(\"Mb\"); }\n+                    case (common::ty_u16) { w.write_str(\"Mw\"); }\n+                    case (common::ty_u32) { w.write_str(\"Ml\"); }\n+                    case (common::ty_u64) { w.write_str(\"Md\"); }\n+                    case (common::ty_i8) { w.write_str(\"MB\"); }\n+                    case (common::ty_i16) { w.write_str(\"MW\"); }\n+                    case (common::ty_i32) { w.write_str(\"ML\"); }\n+                    case (common::ty_i64) { w.write_str(\"MD\"); }\n+                    case (common::ty_f32) { w.write_str(\"Mf\"); }\n+                    case (common::ty_f64) { w.write_str(\"MF\"); }\n                 }\n             }\n-            case (ty.ty_char) {w.write_char('c');}\n-            case (ty.ty_str) {w.write_char('s');}\n-            case (ty.ty_tag(?def,?tys)) { // TODO restore def_id\n+            case (ty::ty_char) {w.write_char('c');}\n+            case (ty::ty_str) {w.write_char('s');}\n+            case (ty::ty_tag(?def,?tys)) { // TODO restore def_id\n                 w.write_str(\"t[\");\n                 w.write_str(cx.ds(def));\n                 w.write_char('|');\n-                for (ty.t t in tys) {\n+                for (ty::t t in tys) {\n                     enc_ty(w, cx, t);\n                 }\n                 w.write_char(']');\n             }\n-            case (ty.ty_box(?mt)) {w.write_char('@'); enc_mt(w, cx, mt); }\n-            case (ty.ty_vec(?mt)) {w.write_char('V'); enc_mt(w, cx, mt); }\n-            case (ty.ty_port(?t)) {w.write_char('P'); enc_ty(w, cx, t); }\n-            case (ty.ty_chan(?t)) {w.write_char('C'); enc_ty(w, cx, t); }\n-            case (ty.ty_tup(?mts)) {\n+            case (ty::ty_box(?mt)) {w.write_char('@'); enc_mt(w, cx, mt); }\n+            case (ty::ty_vec(?mt)) {w.write_char('V'); enc_mt(w, cx, mt); }\n+            case (ty::ty_port(?t)) {w.write_char('P'); enc_ty(w, cx, t); }\n+            case (ty::ty_chan(?t)) {w.write_char('C'); enc_ty(w, cx, t); }\n+            case (ty::ty_tup(?mts)) {\n                 w.write_str(\"T[\");\n-                for (ty.mt mt in mts) {\n+                for (ty::mt mt in mts) {\n                     enc_mt(w, cx, mt);\n                 }\n                 w.write_char(']');\n             }\n-            case (ty.ty_rec(?fields)) {\n+            case (ty::ty_rec(?fields)) {\n                 w.write_str(\"R[\");\n-                for (ty.field field in fields) {\n+                for (ty::field field in fields) {\n                     w.write_str(field.ident);\n                     w.write_char('=');\n                     enc_mt(w, cx, field.mt);\n                 }\n                 w.write_char(']');\n             }\n-            case (ty.ty_fn(?proto,?args,?out)) {\n+            case (ty::ty_fn(?proto,?args,?out)) {\n                 enc_proto(w, proto);\n                 enc_ty_fn(w, cx, args, out);\n             }\n-            case (ty.ty_native_fn(?abi,?args,?out)) {\n+            case (ty::ty_native_fn(?abi,?args,?out)) {\n                 w.write_char('N');\n                 alt (abi) {\n-                    case (ast.native_abi_rust) { w.write_char('r'); }\n-                    case (ast.native_abi_rust_intrinsic) {\n+                    case (ast::native_abi_rust) { w.write_char('r'); }\n+                    case (ast::native_abi_rust_intrinsic) {\n                         w.write_char('i');\n                     }\n-                    case (ast.native_abi_cdecl) { w.write_char('c'); }\n-                    case (ast.native_abi_llvm) { w.write_char('l'); }\n+                    case (ast::native_abi_cdecl) { w.write_char('c'); }\n+                    case (ast::native_abi_llvm) { w.write_char('l'); }\n                 }\n                 enc_ty_fn(w, cx, args, out);\n             }\n-            case (ty.ty_obj(?methods)) {\n+            case (ty::ty_obj(?methods)) {\n                 w.write_str(\"O[\");\n-                for (ty.method m in methods) {\n+                for (ty::method m in methods) {\n                     enc_proto(w, m.proto);\n                     w.write_str(m.ident);\n                     enc_ty_fn(w, cx, m.inputs, m.output);\n                 }\n                 w.write_char(']');\n             }\n-            case (ty.ty_var(?id)) {\n+            case (ty::ty_var(?id)) {\n                 w.write_char('X');\n-                w.write_str(common.istr(id));\n+                w.write_str(common::istr(id));\n             }\n-            case (ty.ty_native) {w.write_char('E');}\n-            case (ty.ty_param(?id)) {\n+            case (ty::ty_native) {w.write_char('E');}\n+            case (ty::ty_param(?id)) {\n                 w.write_char('p');\n-                w.write_str(common.uistr(id));\n+                w.write_str(common::uistr(id));\n             }\n-            case (ty.ty_type) {w.write_char('Y');}\n+            case (ty::ty_type) {w.write_char('Y');}\n \n             // These two don't appear in crate metadata, but are here because\n             // `hash_ty()` uses this function.\n-            case (ty.ty_bound_param(?id)) {\n+            case (ty::ty_bound_param(?id)) {\n                 w.write_char('o');\n-                w.write_str(common.uistr(id));\n+                w.write_str(common::uistr(id));\n             }\n-            case (ty.ty_local(?def)) {\n+            case (ty::ty_local(?def)) {\n                 w.write_char('L');\n                 w.write_str(cx.ds(def));\n             }\n         }\n     }\n \n-    fn enc_proto(&IO.writer w, ast.proto proto) {\n+    fn enc_proto(&io::writer w, ast::proto proto) {\n         alt (proto) {\n-            case (ast.proto_iter) { w.write_char('W'); }\n-            case (ast.proto_fn) { w.write_char('F'); }\n+            case (ast::proto_iter) { w.write_char('W'); }\n+            case (ast::proto_fn) { w.write_char('F'); }\n         }\n     }\n \n-    fn enc_ty_fn(&IO.writer w, &@ctxt cx, &vec[ty.arg] args, &ty.t out) {\n+    fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out) {\n         w.write_char('[');\n-        for (ty.arg arg in args) {\n-            if (arg.mode == ty.mo_alias) { w.write_char('&'); }\n+        for (ty::arg arg in args) {\n+            if (arg.mode == ty::mo_alias) { w.write_char('&'); }\n             enc_ty(w, cx, arg.ty);\n         }\n         w.write_char(']');\n@@ -263,338 +263,338 @@ mod Encode {\n }\n \n \n-// Returns a Plain Old LLVM String.\n+// Returns a Plain Old LLVM String:\n fn C_postr(&str s) -> ValueRef {\n-    ret llvm.LLVMConstString(Str.buf(s), Str.byte_len(s), False);\n+    ret llvm::LLVMConstString(_str::buf(s), _str::byte_len(s), False);\n }\n \n \n // Path table encoding\n \n-fn encode_name(&EBML.writer ebml_w, &str name) {\n-    EBML.start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(Str.bytes(name));\n-    EBML.end_tag(ebml_w);\n+fn encode_name(&ebml::writer ebml_w, &str name) {\n+    ebml::start_tag(ebml_w, tag_paths_data_name);\n+    ebml_w.writer.write(_str::bytes(name));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_def_id(&EBML.writer ebml_w, &ast.def_id id) {\n-    EBML.start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(Str.bytes(def_to_str(id)));\n-    EBML.end_tag(ebml_w);\n+fn encode_def_id(&ebml::writer ebml_w, &ast::def_id id) {\n+    ebml::start_tag(ebml_w, tag_def_id);\n+    ebml_w.writer.write(_str::bytes(def_to_str(id)));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&EBML.writer ebml_w,\n-                            &vec[ast.variant] variants,\n+fn encode_tag_variant_paths(&ebml::writer ebml_w,\n+                            &vec[ast::variant] variants,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n-    for (ast.variant variant in variants) {\n+    for (ast::variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n-        EBML.start_tag(ebml_w, tag_paths_data_item);\n+        ebml::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, variant.node.id);\n-        EBML.end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n }\n \n-fn add_to_index(&EBML.writer ebml_w,\n+fn add_to_index(&ebml::writer ebml_w,\n                 &vec[str] path,\n                 &mutable vec[tup(str, uint)] index,\n                 &str name) {\n     auto full_path = path + vec(name);\n-    index += vec(tup(Str.connect(full_path, \"::\"), ebml_w.writer.tell()));\n+    index += vec(tup(_str::connect(full_path, \"::\"), ebml_w.writer.tell()));\n }\n \n-fn encode_native_module_item_paths(&EBML.writer ebml_w,\n-                                   &ast.native_mod nmod,\n+fn encode_native_module_item_paths(&ebml::writer ebml_w,\n+                                   &ast::native_mod nmod,\n                                    &vec[str] path,\n                                    &mutable vec[tup(str, uint)] index) {\n-    for (@ast.native_item nitem in nmod.items) {\n+    for (@ast::native_item nitem in nmod.items) {\n         alt (nitem.node) {\n-            case (ast.native_item_ty(?id, ?did)) {\n+            case (ast::native_item_ty(?id, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n-            case (ast.native_item_fn(?id, _, _, _, ?did, _)) {\n+            case (ast::native_item_fn(?id, _, _, _, ?did, _)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_module_item_paths(&EBML.writer ebml_w,\n-                            &ast._mod module,\n+fn encode_module_item_paths(&ebml::writer ebml_w,\n+                            &ast::_mod module,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     // TODO: only encode exported items\n-    for (@ast.item it in module.items) {\n+    for (@ast::item it in module.items) {\n         alt (it.node) {\n-            case (ast.item_const(?id, _, ?tps, ?did, ?ann)) {\n+            case (ast::item_const(?id, _, ?tps, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n-            case (ast.item_fn(?id, _, ?tps, ?did, ?ann)) {\n+            case (ast::item_fn(?id, _, ?tps, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n-            case (ast.item_mod(?id, ?_mod, ?did)) {\n+            case (ast::item_mod(?id, ?_mod, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_mod);\n+                ebml::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 encode_module_item_paths(ebml_w, _mod, path + vec(id), index);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n-            case (ast.item_native_mod(?id, ?nmod, ?did)) {\n+            case (ast::item_native_mod(?id, ?nmod, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_mod);\n+                ebml::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 encode_native_module_item_paths(ebml_w, nmod, path + vec(id),\n                                                 index);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n-            case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n+            case (ast::item_ty(?id, _, ?tps, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n-            case (ast.item_tag(?id, ?variants, ?tps, ?did, _)) {\n+            case (ast::item_tag(?id, ?variants, ?tps, ?did, _)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n \n                 encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n-            case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n+            case (ast::item_obj(?id, _, ?tps, ?odid, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                EBML.start_tag(ebml_w, tag_paths_data_item);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, odid.ctor);\n                 encode_obj_type_id(ebml_w, odid.ty);\n-                EBML.end_tag(ebml_w);\n+                ebml::end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_item_paths(&EBML.writer ebml_w, &@ast.crate crate)\n+fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate)\n         -> vec[tup(str, uint)] {\n     let vec[tup(str, uint)] index = vec();\n     let vec[str] path = vec();\n-    EBML.start_tag(ebml_w, tag_paths);\n+    ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n     ret index;\n }\n \n \n // Item info table encoding\n \n-fn encode_kind(&EBML.writer ebml_w, u8 c) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_kind);\n+fn encode_kind(&ebml::writer ebml_w, u8 c) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_kind);\n     ebml_w.writer.write(vec(c));\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(&ast.def_id did) -> str {\n+fn def_to_str(&ast::def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n \n-fn encode_type_param_count(&EBML.writer ebml_w, &vec[ast.ty_param] tps) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    EBML.write_vint(ebml_w.writer, Vec.len[ast.ty_param](tps));\n-    EBML.end_tag(ebml_w);\n+fn encode_type_param_count(&ebml::writer ebml_w, &vec[ast::ty_param] tps) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n+    ebml::write_vint(ebml_w.writer, _vec::len[ast::ty_param](tps));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_variant_id(&EBML.writer ebml_w, &ast.def_id vid) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(Str.bytes(def_to_str(vid)));\n-    EBML.end_tag(ebml_w);\n+fn encode_variant_id(&ebml::writer ebml_w, &ast::def_id vid) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_variant);\n+    ebml_w.writer.write(_str::bytes(def_to_str(vid)));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(&@trans.crate_ctxt cx, &EBML.writer ebml_w, &ty.t typ) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_type);\n+fn encode_type(&@trans::crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_type);\n \n     auto f = def_to_str;\n     auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx,\n                             abbrevs=ac_use_abbrevs(cx.type_abbrevs));\n-    Encode.enc_ty(IO.new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n-    EBML.end_tag(ebml_w);\n+    Encode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_symbol(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                 &ast.def_id did) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(Str.bytes(cx.item_symbols.get(did)));\n-    EBML.end_tag(ebml_w);\n+fn encode_symbol(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n+                 &ast::def_id did) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(_str::bytes(cx.item_symbols.get(did)));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_discriminant(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                       &ast.def_id did) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(Str.bytes(cx.discrim_symbols.get(did)));\n-    EBML.end_tag(ebml_w);\n+fn encode_discriminant(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n+                       &ast::def_id did) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(_str::bytes(cx.discrim_symbols.get(did)));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(&EBML.writer ebml_w, &ast.def_id id) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(Str.bytes(def_to_str(id)));\n-    EBML.end_tag(ebml_w);\n+fn encode_tag_id(&ebml::writer ebml_w, &ast::def_id id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n+    ebml_w.writer.write(_str::bytes(def_to_str(id)));\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_obj_type_id(&EBML.writer ebml_w, &ast.def_id id) {\n-    EBML.start_tag(ebml_w, tag_items_data_item_obj_type_id);\n-    ebml_w.writer.write(Str.bytes(def_to_str(id)));\n-    EBML.end_tag(ebml_w);\n+fn encode_obj_type_id(&ebml::writer ebml_w, &ast::def_id id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_obj_type_id);\n+    ebml_w.writer.write(_str::bytes(def_to_str(id)));\n+    ebml::end_tag(ebml_w);\n }\n \n \n-fn encode_tag_variant_info(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                           &ast.def_id did, &vec[ast.variant] variants,\n+fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n+                           &ast::def_id did, &vec[ast::variant] variants,\n                            &mutable vec[tup(int, uint)] index,\n-                           &vec[ast.ty_param] ty_params) {\n-    for (ast.variant variant in variants) {\n+                           &vec[ast::ty_param] ty_params) {\n+    for (ast::variant variant in variants) {\n         index += vec(tup(variant.node.id._1, ebml_w.writer.tell()));\n \n-        EBML.start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n-        encode_type(cx, ebml_w, trans.node_ann_type(cx, variant.node.ann));\n-        if (Vec.len[ast.variant_arg](variant.node.args) > 0u) {\n+        encode_type(cx, ebml_w, trans::node_ann_type(cx, variant.node.ann));\n+        if (_vec::len[ast::variant_arg](variant.node.args) > 0u) {\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(cx, ebml_w, variant.node.id);\n         encode_type_param_count(ebml_w, ty_params);\n-        EBML.end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n }\n \n-fn encode_info_for_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                        @ast.item item, &mutable vec[tup(int, uint)] index) {\n+fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n+                        @ast::item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n-        case (ast.item_const(_, _, _, ?did, ?ann)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_const(_, _, _, ?did, ?ann)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'c' as u8);\n-            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        case (ast.item_fn(_, _, ?tps, ?did, ?ann)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_fn(_, _, ?tps, ?did, ?ann)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        case (ast.item_mod(_, _, ?did)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_mod(_, _, ?did)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'm' as u8);\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        case (ast.item_native_mod(?id, _, ?did)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_native_mod(?id, _, ?did)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'n' as u8);\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_ty(?id, _, ?tps, ?did, ?ann)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n-            EBML.end_tag(ebml_w);\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n+            ebml::end_tag(ebml_w);\n         }\n-        case (ast.item_tag(?id, ?variants, ?tps, ?did, ?ann)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_tag(?id, ?variants, ?tps, ?did, ?ann)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n-            for (ast.variant v in variants) {\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n+            for (ast::variant v in variants) {\n                 encode_variant_id(ebml_w, v.node.id);\n             }\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n \n             encode_tag_variant_info(cx, ebml_w, did, variants, index, tps);\n         }\n-        case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+        case (ast::item_obj(?id, _, ?tps, ?odid, ?ann)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ctor);\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            auto fn_ty = trans.node_ann_type(cx, ann);\n+            auto fn_ty = trans::node_ann_type(cx, ann);\n             encode_type(cx, ebml_w, fn_ty);\n             encode_symbol(cx, ebml_w, odid.ctor);\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n \n-            EBML.start_tag(ebml_w, tag_items_data_item);\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, ty.ty_fn_ret(cx.tcx, fn_ty));\n-            EBML.end_tag(ebml_w);\n+            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n+            ebml::end_tag(ebml_w);\n         }\n     }\n }\n \n-fn encode_info_for_native_item(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                               &@ast.native_item nitem) {\n-    EBML.start_tag(ebml_w, tag_items_data_item);\n+fn encode_info_for_native_item(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n+                               &@ast::native_item nitem) {\n+    ebml::start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n-        case (ast.native_item_ty(_, ?did)) {\n+        case (ast::native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'T' as u8);\n-            encode_type(cx, ebml_w, ty.mk_native(cx.tcx));\n+            encode_type(cx, ebml_w, ty::mk_native(cx.tcx));\n         }\n-        case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n+        case (ast::native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'F' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n         }\n     }\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(&@trans.crate_ctxt cx, &EBML.writer ebml_w)\n+fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w)\n         -> vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = vec();\n \n-    EBML.start_tag(ebml_w, tag_items_data);\n-    for each (@tup(ast.def_id, @ast.item) kvp in cx.items.items()) {\n+    ebml::start_tag(ebml_w, tag_items_data);\n+    for each (@tup(ast::def_id, @ast::item) kvp in cx.items.items()) {\n         index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n         encode_info_for_item(cx, ebml_w, kvp._1, index);\n     }\n-    for each (@tup(ast.def_id, @ast.native_item) kvp in\n+    for each (@tup(ast::def_id, @ast::native_item) kvp in\n             cx.native_items.items()) {\n         index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n \n     ret index;\n }\n@@ -610,7 +610,7 @@ fn hash_def_num(&int def_num) -> uint {\n \n fn hash_path(&str s) -> uint {\n     auto h = 5381u;\n-    for (u8 ch in Str.bytes(s)) {\n+    for (u8 ch in _str::bytes(s)) {\n         h = ((h << 5u) + h) ^ (ch as uint);\n     }\n     ret h;\n@@ -619,7 +619,7 @@ fn hash_path(&str s) -> uint {\n fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n         -> vec[vec[tup(T, uint)]] {\n     let vec[vec[tup(T, uint)]] buckets = vec();\n-    for each (uint i in UInt.range(0u, 256u)) {\n+    for each (uint i in _uint::range(0u, 256u)) {\n         let vec[tup(T, uint)] bucket = vec();\n         buckets += vec(bucket);\n     }\n@@ -632,69 +632,69 @@ fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n     ret buckets;\n }\n \n-fn encode_index[T](&EBML.writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n-                   fn(&IO.writer, &T) write_fn) {\n-    auto writer = IO.new_writer_(ebml_w.writer);\n+fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+                   fn(&io::writer, &T) write_fn) {\n+    auto writer = io::new_writer_(ebml_w.writer);\n \n-    EBML.start_tag(ebml_w, tag_index);\n+    ebml::start_tag(ebml_w, tag_index);\n \n     let vec[uint] bucket_locs = vec();\n-    EBML.start_tag(ebml_w, tag_index_buckets);\n+    ebml::start_tag(ebml_w, tag_index_buckets);\n     for (vec[tup(T, uint)] bucket in buckets) {\n         bucket_locs += vec(ebml_w.writer.tell());\n \n-        EBML.start_tag(ebml_w, tag_index_buckets_bucket);\n+        ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n         for (tup(T, uint) elt in bucket) {\n-            EBML.start_tag(ebml_w, tag_index_buckets_bucket_elt);\n+            ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt._1, 4u);\n             write_fn(writer, elt._0);\n-            EBML.end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        EBML.end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n \n-    EBML.start_tag(ebml_w, tag_index_table);\n+    ebml::start_tag(ebml_w, tag_index_table);\n     for (uint pos in bucket_locs) {\n         writer.write_be_uint(pos, 4u);\n     }\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n \n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn write_str(&IO.writer writer, &str s) {\n+fn write_str(&io::writer writer, &str s) {\n     writer.write_str(s);\n }\n \n-fn write_int(&IO.writer writer, &int n) {\n+fn write_int(&io::writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n \n-fn encode_metadata(&@trans.crate_ctxt cx, &@ast.crate crate)\n+fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate)\n         -> ValueRef {\n-    auto string_w = IO.string_writer();\n+    auto string_w = io::string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n-    auto ebml_w = EBML.create_writer(buf_w);\n+    auto ebml_w = ebml::create_writer(buf_w);\n \n     // Encode and index the paths.\n-    EBML.start_tag(ebml_w, tag_paths);\n+    ebml::start_tag(ebml_w, tag_paths);\n     auto paths_index = encode_item_paths(ebml_w, crate);\n     auto str_writer = write_str;\n     auto path_hasher = hash_path;\n     auto paths_buckets = create_index[str](paths_index, path_hasher);\n     encode_index[str](ebml_w, paths_buckets, str_writer);\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n \n     // Encode and index the items.\n-    EBML.start_tag(ebml_w, tag_items);\n+    ebml::start_tag(ebml_w, tag_items);\n     auto items_index = encode_info_for_items(cx, ebml_w);\n     auto int_writer = write_int;\n     auto item_hasher = hash_def_num;\n     auto items_buckets = create_index[int](items_index, item_hasher);\n     encode_index[int](ebml_w, items_buckets, int_writer);\n-    EBML.end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n@@ -703,17 +703,17 @@ fn encode_metadata(&@trans.crate_ctxt cx, &@ast.crate crate)\n     ret C_postr(string_w.get_str());\n }\n \n-fn write_metadata(&@trans.crate_ctxt cx, &@ast.crate crate) {\n+fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n     auto llmeta = C_postr(\"\");\n     if (cx.sess.get_opts().shared) {\n         llmeta = encode_metadata(cx, crate);\n     }\n \n-    auto llconst = trans.C_struct(vec(llmeta));\n-    auto llglobal = llvm.LLVMAddGlobal(cx.llmod, trans.val_ty(llconst),\n-                                       Str.buf(\"rust_metadata\"));\n-    llvm.LLVMSetInitializer(llglobal, llconst);\n-    llvm.LLVMSetSection(llglobal, Str.buf(x86.get_meta_sect_name()));\n+    auto llconst = trans::C_struct(vec(llmeta));\n+    auto llglobal = llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n+                                       _str::buf(\"rust_metadata\"));\n+    llvm::LLVMSetInitializer(llglobal, llconst);\n+    llvm::LLVMSetSection(llglobal, _str::buf(x86::get_meta_sect_name()));\n }\n \n //"}, {"sha": "c81d9030556cd37fe9977fbee993e9aeb616dfe8", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 223, "deletions": 223, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,26 +1,25 @@\n-import front.ast;\n-import front.ast.ident;\n-import front.ast.def;\n-import front.ast.def_id;\n-import front.ast.ann;\n-import front.creader;\n-import driver.session.session;\n-import util.common.new_def_hash;\n-import util.common.new_int_hash;\n-import util.common.new_uint_hash;\n-import util.common.new_str_hash;\n-import util.common.span;\n-import util.typestate_ann.ts_ann;\n-import std.Map.hashmap;\n-import std.List;\n-import std.List.list;\n-import std.List.nil;\n-import std.List.cons;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n-import std.Str;\n-import std.Vec;\n+import front::ast;\n+import front::ast::ident;\n+import front::ast::def;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::creader;\n+import driver::session::session;\n+import util::common::new_def_hash;\n+import util::common::new_int_hash;\n+import util::common::new_uint_hash;\n+import util::common::new_str_hash;\n+import util::common::span;\n+import util::typestate_ann::ts_ann;\n+import std::map::hashmap;\n+import std::list::list;\n+import std::list::nil;\n+import std::list::cons;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import std::_str;\n+import std::_vec;\n \n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n@@ -34,53 +33,53 @@ import std.Vec;\n //  isn't a const.)\n \n tag scope {\n-    scope_crate(@ast.crate);\n-    scope_item(@ast.item);\n-    scope_native_item(@ast.native_item);\n-    scope_loop(@ast.decl); // there's only 1 decl per loop.\n-    scope_block(ast.block);\n-    scope_arm(ast.arm);\n+    scope_crate(@ast::crate);\n+    scope_item(@ast::item);\n+    scope_native_item(@ast::native_item);\n+    scope_loop(@ast::decl); // there's only 1 decl per loop.\n+    scope_block(ast::block);\n+    scope_arm(ast::arm);\n }\n \n tag import_state {\n-    todo(@ast.view_item, list[scope]);\n+    todo(@ast::view_item, list[scope]);\n     resolving(span);\n-    resolved(Option.t[def] /* value */, Option.t[def] /* type */);\n+    resolved(option::t[def] /* value */, option::t[def] /* type */);\n }\n \n type ext_hash = hashmap[tup(def_id,str),def];\n fn new_ext_hash() -> ext_hash {\n     fn hash(&tup(def_id,str) v) -> uint {\n-        ret Str.hash(v._1) + util.common.hash_def(v._0);\n+        ret _str::hash(v._1) + util::common::hash_def(v._0);\n     }\n     fn eq(&tup(def_id,str) v1, &tup(def_id,str) v2) -> bool {\n-        ret util.common.def_eq(v1._0, v2._0) &&\n-            Str.eq(v1._1, v2._1);\n+        ret util::common::def_eq(v1._0, v2._0) &&\n+            _str::eq(v1._1, v2._1);\n     }\n-    ret std.Map.mk_hashmap[tup(def_id,str),def](hash, eq);\n+    ret std::map::mk_hashmap[tup(def_id,str),def](hash, eq);\n }\n \n tag mod_index_entry {\n-    mie_view_item(@ast.view_item);\n-    mie_item(@ast.item);\n-    mie_tag_variant(@ast.item /* tag item */, uint /* variant index */);\n+    mie_view_item(@ast::view_item);\n+    mie_item(@ast::item);\n+    mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n }\n type mod_index = hashmap[ident,mod_index_entry];\n-type indexed_mod = rec(ast._mod m, mod_index index);\n+type indexed_mod = rec(ast::_mod m, mod_index index);\n \n tag native_mod_index_entry {\n-    nmie_view_item(@ast.view_item);\n-    nmie_item(@ast.native_item);\n+    nmie_view_item(@ast::view_item);\n+    nmie_item(@ast::native_item);\n }\n type nmod_index = hashmap[ident,native_mod_index_entry];\n-type indexed_nmod = rec(ast.native_mod m, nmod_index index);\n+type indexed_nmod = rec(ast::native_mod m, nmod_index index);\n \n type def_map = hashmap[uint,def];\n \n type env = rec(def_map def_map,\n-               hashmap[ast.def_num,import_state] imports,\n-               hashmap[ast.def_num,@indexed_mod] mod_map,\n-               hashmap[ast.def_num,@indexed_nmod] nmod_map,\n+               hashmap[ast::def_num,import_state] imports,\n+               hashmap[ast::def_num,@indexed_mod] mod_map,\n+               hashmap[ast::def_num,@indexed_nmod] nmod_map,\n                hashmap[def_id,vec[ident]] ext_map,\n                ext_hash ext_cache,\n                session sess);\n@@ -94,8 +93,8 @@ tag namespace {\n     ns_type;\n }\n \n-fn resolve_crate(session sess, @ast.crate crate)\n-    -> tup(@ast.crate, def_map) {\n+fn resolve_crate(session sess, @ast::crate crate)\n+    -> tup(@ast::crate, def_map) {\n     auto e = @rec(def_map = new_uint_hash[def](),\n                   imports = new_int_hash[import_state](),\n                   mod_map = new_int_hash[@indexed_mod](),\n@@ -111,47 +110,47 @@ fn resolve_crate(session sess, @ast.crate crate)\n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n \n-fn map_crate(&@env e, &ast.crate c) {\n+fn map_crate(&@env e, &ast::crate c) {\n     auto cell = @mutable nil[scope];\n     auto v = rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n                  visit_crate_post = bind pop_env_for_crate(cell, _),\n                  visit_view_item_pre = bind visit_view_item(e, cell, _),\n                  visit_item_pre = bind push_env_for_item_map_mod(e, cell, _),\n                  visit_item_post = bind pop_env_for_item(cell, _)\n-                 with walk.default_visitor());\n+                 with walk::default_visitor());\n     // Register the top-level mod\n     e.mod_map.insert(-1, @rec(m=c.node.module,\n                               index=index_mod(c.node.module)));\n-    walk.walk_crate(v, c);\n+    walk::walk_crate(v, c);\n \n     // Helpers for this pass.\n-    fn push_env_for_crate(@mutable list[scope] sc, &ast.crate c) {\n+    fn push_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n         *sc = cons[scope](scope_crate(@c), @*sc);\n     }\n-    fn pop_env_for_crate(@mutable list[scope] sc, &ast.crate c) {\n-        *sc = List.cdr(*sc);\n+    fn pop_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n+        *sc = std::list::cdr(*sc);\n     }\n     fn push_env_for_item_map_mod(@env e, @mutable list[scope] sc,\n-                                 &@ast.item i) {\n+                                 &@ast::item i) {\n         *sc = cons[scope](scope_item(i), @*sc);\n         alt (i.node) {\n-            case (ast.item_mod(_, ?md, ?defid)) {\n+            case (ast::item_mod(_, ?md, ?defid)) {\n                 auto index = index_mod(md);\n                 e.mod_map.insert(defid._1, @rec(m=md, index=index));\n             }\n-            case (ast.item_native_mod(_, ?nmd, ?defid)) {\n+            case (ast::item_native_mod(_, ?nmd, ?defid)) {\n                 auto index = index_nmod(nmd);\n                 e.nmod_map.insert(defid._1, @rec(m=nmd, index=index));\n             }\n             case (_) {}\n         }\n     }\n-    fn pop_env_for_item(@mutable list[scope] sc, &@ast.item i) {\n-        *sc = List.cdr(*sc);\n+    fn pop_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n+        *sc = std::list::cdr(*sc);\n     }\n-    fn visit_view_item(@env e, @mutable list[scope] sc, &@ast.view_item i) {\n+    fn visit_view_item(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n         alt (i.node) {\n-            case (ast.view_item_import(_, ?ids, ?defid)) {\n+            case (ast::view_item_import(_, ?ids, ?defid)) {\n                 e.imports.insert(defid._1, todo(i, *sc));\n             }\n             case (_) {}\n@@ -160,7 +159,7 @@ fn map_crate(&@env e, &ast.crate c) {\n }\n \n fn resolve_imports(&env e) {\n-    for each (@tup(ast.def_num, import_state) it in e.imports.items()) {\n+    for each (@tup(ast::def_num, import_state) it in e.imports.items()) {\n         alt (it._1) {\n             case (todo(?item, ?sc)) {\n                 resolve_import(e, item, sc);\n@@ -171,7 +170,7 @@ fn resolve_imports(&env e) {\n }\n \n // FIXME this should use walk (will need to add walk_arm)\n-fn resolve_names(&@env e, &ast.crate c) -> @ast.crate {\n+fn resolve_names(&@env e, &ast::crate c) -> @ast::crate {\n     auto fld = @rec(fold_pat_tag = bind fold_pat_tag(e,_,_,_,_,_),\n                     fold_expr_path = bind fold_expr_path(e,_,_,_,_),\n                     fold_ty_path = bind fold_ty_path(e,_,_,_,_),\n@@ -182,41 +181,41 @@ fn resolve_names(&@env e, &ast.crate c) -> @ast.crate {\n                     update_env_for_block = bind update_env_for_block(_,_),\n                     update_env_for_arm = bind update_env_for_arm(_,_),\n                     update_env_for_expr = bind update_env_for_expr(_,_)\n-                    with *fold.new_identity_fold[list[scope]]());\n-    ret fold.fold_crate(nil[scope], fld, @c);\n+                    with *fold::new_identity_fold[list[scope]]());\n+    ret fold::fold_crate(nil[scope], fld, @c);\n \n     // Helpers for this pass\n \n-    fn update_env_for_crate(&list[scope] sc, &@ast.crate c) -> list[scope] {\n+    fn update_env_for_crate(&list[scope] sc, &@ast::crate c) -> list[scope] {\n         ret cons[scope](scope_crate(c), @sc);\n     }\n-    fn update_env_for_item(&list[scope] sc, &@ast.item i) -> list[scope] {\n+    fn update_env_for_item(&list[scope] sc, &@ast::item i) -> list[scope] {\n         ret cons[scope](scope_item(i), @sc);\n     }\n-    fn update_env_for_native_item(&list[scope] sc, &@ast.native_item i)\n+    fn update_env_for_native_item(&list[scope] sc, &@ast::native_item i)\n         -> list[scope] {\n         ret cons[scope](scope_native_item(i), @sc);\n     }\n-    fn update_env_for_block(&list[scope] sc, &ast.block b) -> list[scope] {\n+    fn update_env_for_block(&list[scope] sc, &ast::block b) -> list[scope] {\n         ret cons[scope](scope_block(b), @sc);\n     }\n-    fn update_env_for_expr(&list[scope] sc, &@ast.expr x) -> list[scope] {\n+    fn update_env_for_expr(&list[scope] sc, &@ast::expr x) -> list[scope] {\n         alt (x.node) {\n-            case (ast.expr_for(?d, _, _, _)) {\n+            case (ast::expr_for(?d, _, _, _)) {\n                 ret cons[scope](scope_loop(d), @sc);\n             }\n-            case (ast.expr_for_each(?d, _, _, _)) {\n+            case (ast::expr_for_each(?d, _, _, _)) {\n                 ret cons[scope](scope_loop(d), @sc);\n             }\n             case (_) { ret sc; }\n         }\n     }\n-    fn update_env_for_arm(&list[scope] sc, &ast.arm p) -> list[scope] {\n+    fn update_env_for_arm(&list[scope] sc, &ast::arm p) -> list[scope] {\n         ret cons[scope](scope_arm(p), @sc);\n     }\n }\n \n-fn lookup_import(&env e, def_id defid, namespace ns) -> Option.t[def] {\n+fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n     alt (e.imports.get(defid._1)) {\n         case (todo(?item, ?sc)) {\n             resolve_import(e, item, sc);\n@@ -232,16 +231,16 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> Option.t[def] {\n     }\n }\n \n-fn resolve_import(&env e, &@ast.view_item it, &list[scope] sc) {\n+fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n     auto defid; auto ids;\n     alt (it.node) {\n-        case (ast.view_item_import(_, ?_ids, ?_defid)) {\n+        case (ast::view_item_import(_, ?_ids, ?_defid)) {\n             defid = _defid; ids = _ids;\n         }\n     }\n     e.imports.insert(defid._1, resolving(it.span));\n     \n-    auto n_idents = Vec.len(ids);\n+    auto n_idents = _vec::len(ids);\n     auto end_id = ids.(n_idents - 1u);\n \n     if (n_idents == 1u) {\n@@ -270,48 +269,48 @@ fn resolve_import(&env e, &@ast.view_item it, &list[scope] sc) {\n     }\n \n     fn register(&env e, def_id defid, &span sp, ident id,\n-                Option.t[def] val, Option.t[def] typ) {\n+                option::t[def] val, option::t[def] typ) {\n         if (val == none[def] && typ == none[def]) {\n             unresolved(e, sp, id, \"import\");\n         }\n         e.imports.insert(defid._1, resolved(val, typ));\n     }\n }\n \n-fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p, &ann a)\n-    -> @ast.expr {\n+fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast::path p, &ann a)\n+    -> @ast::expr {\n     auto df = lookup_path_strict(*e, sc, sp, p.node.idents, ns_value);\n-    e.def_map.insert(ast.ann_tag(a), df);\n-    ret @fold.respan(sp, ast.expr_path(p, a));\n+    e.def_map.insert(ast::ann_tag(a), df);\n+    ret @fold::respan(sp, ast::expr_path(p, a));\n }\n \n \n-fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast.path p,\n-                &vec[@ast.pat] args, &ann a) -> @ast.pat {\n+fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast::path p,\n+                &vec[@ast::pat] args, &ann a) -> @ast::pat {\n     alt (lookup_path_strict(*e, sc, sp, p.node.idents, ns_value)) {\n-        case (ast.def_variant(?did, ?vid)) {\n-            e.def_map.insert(ast.ann_tag(a), ast.def_variant(did, vid));\n-            ret @fold.respan[ast.pat_](sp, ast.pat_tag(p, args, a));\n+        case (ast::def_variant(?did, ?vid)) {\n+            e.def_map.insert(ast::ann_tag(a), ast::def_variant(did, vid));\n+            ret @fold::respan[ast::pat_](sp, ast::pat_tag(p, args, a));\n         }\n         case (_) {\n             e.sess.span_err(sp, \"not a tag variant: \" +\n-                            Str.connect(p.node.idents, \"::\"));\n+                            _str::connect(p.node.idents, \"::\"));\n             fail;\n         }\n     }\n }\n \n-fn fold_ty_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n-                &ast.ann a) -> @ast.ty {\n+fn fold_ty_path(@env e, &list[scope] sc, &span sp, &ast::path p,\n+                &ast::ann a) -> @ast::ty {\n     auto new_def = lookup_path_strict(*e, sc, sp, p.node.idents, ns_type);\n-    e.def_map.insert(ast.ann_tag(a), new_def);\n-    ret @fold.respan[ast.ty_](sp, ast.ty_path(p, a));\n+    e.def_map.insert(ast::ann_tag(a), new_def);\n+    ret @fold::respan[ast::ty_](sp, ast::ty_path(p, a));\n }\n \n fn is_module(def d) -> bool {\n     alt (d) {\n-        case (ast.def_mod(_)) { ret true; }\n-        case (ast.def_native_mod(_)) { ret true; }\n+        case (ast::def_mod(_)) { ret true; }\n+        case (ast::def_native_mod(_)) { ret true; }\n         case (_) { ret false; }\n     }\n }\n@@ -329,7 +328,7 @@ fn unresolved(&env e, &span sp, ident id, str kind) {\n \n fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n                       namespace ns) -> def {\n-    auto n_idents = Vec.len(idents);\n+    auto n_idents = _vec::len(idents);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), ns);\n     auto i = 1u;\n     while (i < n_idents) {\n@@ -341,7 +340,7 @@ fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n         i += 1u;\n     }\n     if (is_module(dcur)) {\n-        e.sess.span_err(sp, Str.connect(idents, \"::\") +\n+        e.sess.span_err(sp, _str::connect(idents, \"::\") +\n                         \" is a module, not a \" + ns_name(ns));\n     }\n     ret dcur;\n@@ -361,34 +360,34 @@ fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, ident id,\n }\n \n fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n-    -> Option.t[def] {\n+    -> option::t[def] {\n     fn in_scope(&env e, ident id, &scope s, namespace ns)\n-        -> Option.t[def] {\n+        -> option::t[def] {\n         alt (s) {\n             case (scope_crate(?c)) {\n-                auto defid = tup(ast.local_crate, -1);\n+                auto defid = tup(ast::local_crate, -1);\n                 ret lookup_in_regular_mod(e, defid, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n-                    case (ast.item_fn(_, ?f, ?ty_params, _, _)) {\n+                    case (ast::item_fn(_, ?f, ?ty_params, _, _)) {\n                         ret lookup_in_fn(id, f.decl, ty_params, ns);\n                     }\n-                    case (ast.item_obj(_, ?ob, ?ty_params, _, _)) {\n+                    case (ast::item_obj(_, ?ob, ?ty_params, _, _)) {\n                         ret lookup_in_obj(id, ob, ty_params, ns);\n                     }\n-                    case (ast.item_tag(_, _, ?ty_params, _, _)) {\n+                    case (ast::item_tag(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n                             ret lookup_in_ty_params(id, ty_params);\n                         }\n                     }\n-                    case (ast.item_mod(_, _, ?defid)) {\n+                    case (ast::item_mod(_, _, ?defid)) {\n                         ret lookup_in_regular_mod(e, defid, id, ns, inside);\n                     }\n-                    case (ast.item_native_mod(_, ?m, ?defid)) {\n+                    case (ast::item_native_mod(_, ?m, ?defid)) {\n                         ret lookup_in_native_mod(e, defid, id, ns);\n                     }\n-                    case (ast.item_ty(_, _, ?ty_params, _, _)) {\n+                    case (ast::item_ty(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n                             ret lookup_in_ty_params(id, ty_params);\n                         }\n@@ -399,7 +398,7 @@ fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n \n             case (scope_native_item(?it)) {\n                 alt (it.node) {\n-                    case (ast.native_item_fn(_, _, ?decl, ?ty_params, _, _)) {\n+                    case (ast::native_item_fn(_, _, ?decl, ?ty_params, _, _)){\n                         ret lookup_in_fn(id, decl, ty_params, ns);\n                     }\n                 }\n@@ -408,9 +407,9 @@ fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n             case (scope_loop(?d)) {\n                 if (ns == ns_value) {\n                     alt (d.node) {\n-                        case (ast.decl_local(?local)) {\n-                            if (Str.eq(local.ident, id)) {\n-                                ret some(ast.def_local(local.id));\n+                        case (ast::decl_local(?local)) {\n+                            if (_str::eq(local.ident, id)) {\n+                                ret some(ast::def_local(local.id));\n                             }\n                         }\n                     }\n@@ -445,27 +444,27 @@ fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n     }\n }\n \n-fn lookup_in_ty_params(ident id, &vec[ast.ty_param] ty_params)\n-    -> Option.t[def] {\n+fn lookup_in_ty_params(ident id, &vec[ast::ty_param] ty_params)\n+    -> option::t[def] {\n     auto i = 0u;\n-    for (ast.ty_param tp in ty_params) {\n-        if (Str.eq(tp, id)) {\n-            ret some(ast.def_ty_arg(i));\n+    for (ast::ty_param tp in ty_params) {\n+        if (_str::eq(tp, id)) {\n+            ret some(ast::def_ty_arg(i));\n         }\n         i += 1u;\n     }\n     ret none[def];\n }\n \n-fn lookup_in_pat(ident id, &ast.pat pat) -> Option.t[def] {\n+fn lookup_in_pat(ident id, &ast::pat pat) -> option::t[def] {\n     alt (pat.node) {\n-        case (ast.pat_bind(?name, ?defid, _)) {\n-            if (Str.eq(name, id)) { ret some(ast.def_binding(defid)); }\n+        case (ast::pat_bind(?name, ?defid, _)) {\n+            if (_str::eq(name, id)) { ret some(ast::def_binding(defid)); }\n         }\n-        case (ast.pat_wild(_)) {}\n-        case (ast.pat_lit(_, _)) {}\n-        case (ast.pat_tag(_, ?pats, _)) {\n-            for (@ast.pat p in pats) {\n+        case (ast::pat_wild(_)) {}\n+        case (ast::pat_lit(_, _)) {}\n+        case (ast::pat_tag(_, ?pats, _)) {\n+            for (@ast::pat p in pats) {\n                 auto found = lookup_in_pat(id, *p);\n                 if (found != none[def]) { ret found; }\n             }\n@@ -475,12 +474,12 @@ fn lookup_in_pat(ident id, &ast.pat pat) -> Option.t[def] {\n }\n \n \n-fn lookup_in_fn(ident id, &ast.fn_decl decl,\n-                &vec[ast.ty_param] ty_params, namespace ns) -> Option.t[def] {\n+fn lookup_in_fn(ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n+                namespace ns) -> option::t[def] {\n     if (ns == ns_value) {\n-        for (ast.arg a in decl.inputs) {\n-            if (Str.eq(a.ident, id)) {\n-                ret some(ast.def_arg(a.id));\n+        for (ast::arg a in decl.inputs) {\n+            if (_str::eq(a.ident, id)) {\n+                ret some(ast::def_arg(a.id));\n             }\n         }\n         ret none[def];\n@@ -489,12 +488,12 @@ fn lookup_in_fn(ident id, &ast.fn_decl decl,\n     }\n }\n \n-fn lookup_in_obj(ident id, &ast._obj ob, &vec[ast.ty_param] ty_params,\n-                 namespace ns) -> Option.t[def] {\n+fn lookup_in_obj(ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+                 namespace ns) -> option::t[def] {\n     if (ns == ns_value) {\n-        for (ast.obj_field f in ob.fields) {\n-            if (Str.eq(f.ident, id)) {\n-                ret some(ast.def_obj_field(f.id));\n+        for (ast::obj_field f in ob.fields) {\n+            if (_str::eq(f.ident, id)) {\n+                ret some(ast::def_obj_field(f.id));\n             }\n         }\n         ret none[def];\n@@ -503,36 +502,36 @@ fn lookup_in_obj(ident id, &ast._obj ob, &vec[ast.ty_param] ty_params,\n     }\n }\n \n-fn lookup_in_block(ident id, &ast.block_ b, namespace ns)\n-    -> Option.t[def] {\n-    for (@ast.stmt st in b.stmts) {\n+fn lookup_in_block(ident id, &ast::block_ b, namespace ns)\n+    -> option::t[def] {\n+    for (@ast::stmt st in b.stmts) {\n         alt (st.node) {\n-            case (ast.stmt_decl(?d,_)) {\n+            case (ast::stmt_decl(?d,_)) {\n                 alt (d.node) {\n-                    case (ast.decl_local(?loc)) {\n-                        if (ns == ns_value && Str.eq(id, loc.ident)) {\n-                            ret some(ast.def_local(loc.id));\n+                    case (ast::decl_local(?loc)) {\n+                        if (ns == ns_value && _str::eq(id, loc.ident)) {\n+                            ret some(ast::def_local(loc.id));\n                         }\n                     }\n-                    case (ast.decl_item(?it)) {\n+                    case (ast::decl_item(?it)) {\n                         alt (it.node) {\n-                            case (ast.item_tag(?name, ?variants, _,\n+                            case (ast::item_tag(?name, ?variants, _,\n                                                ?defid, _)) {\n                                 if (ns == ns_type) {\n-                                    if (Str.eq(name, id)) {\n-                                        ret some(ast.def_ty(defid));\n+                                    if (_str::eq(name, id)) {\n+                                        ret some(ast::def_ty(defid));\n                                     }\n                                 } else {\n-                                    for (ast.variant v in variants) {\n-                                        if (Str.eq(v.node.name, id)) {\n-                                            ret some(ast.def_variant(\n+                                    for (ast::variant v in variants) {\n+                                        if (_str::eq(v.node.name, id)) {\n+                                            ret some(ast::def_variant(\n                                                       defid, v.node.id));\n                                         }\n                                     }\n                                 }\n                             }\n                             case (_) {\n-                                if (Str.eq(ast.item_ident(it), id)) {\n+                                if (_str::eq(ast::item_ident(it), id)) {\n                                     auto found = found_def_item(it, ns);\n                                     if (found != none[def]) { ret found; }\n                                 }\n@@ -547,29 +546,29 @@ fn lookup_in_block(ident id, &ast.block_ b, namespace ns)\n     ret none[def];\n }\n \n-fn found_def_item(@ast.item i, namespace ns) -> Option.t[def] {\n+fn found_def_item(@ast::item i, namespace ns) -> option::t[def] {\n     alt (i.node) {\n-        case (ast.item_const(_, _, _, ?defid, _)) {\n-            if (ns == ns_value) { ret some(ast.def_const(defid)); }\n+        case (ast::item_const(_, _, _, ?defid, _)) {\n+            if (ns == ns_value) { ret some(ast::def_const(defid)); }\n         }\n-        case (ast.item_fn(_, _, _, ?defid, _)) {\n-            if (ns == ns_value) { ret some(ast.def_fn(defid)); }\n+        case (ast::item_fn(_, _, _, ?defid, _)) {\n+            if (ns == ns_value) { ret some(ast::def_fn(defid)); }\n         }\n-        case (ast.item_mod(_, _, ?defid)) {\n-            ret some(ast.def_mod(defid));\n+        case (ast::item_mod(_, _, ?defid)) {\n+            ret some(ast::def_mod(defid));\n         }\n-        case (ast.item_native_mod(_, _, ?defid)) {\n-            ret some(ast.def_native_mod(defid));\n+        case (ast::item_native_mod(_, _, ?defid)) {\n+            ret some(ast::def_native_mod(defid));\n         }\n-        case (ast.item_ty(_, _, _, ?defid, _)) {\n-            if (ns == ns_type) { ret some(ast.def_ty(defid)); }\n+        case (ast::item_ty(_, _, _, ?defid, _)) {\n+            if (ns == ns_type) { ret some(ast::def_ty(defid)); }\n         }\n-        case (ast.item_tag(_, _, _, ?defid, _)) {\n-            if (ns == ns_type) { ret some(ast.def_ty(defid)); }\n+        case (ast::item_tag(_, _, _, ?defid, _)) {\n+            if (ns == ns_type) { ret some(ast::def_ty(defid)); }\n         }\n-        case (ast.item_obj(_, _, _, ?odid, _)) {\n-            if (ns == ns_value) { ret some(ast.def_obj(odid.ctor)); }\n-            else { ret some(ast.def_obj(odid.ty)); }\n+        case (ast::item_obj(_, _, _, ?odid, _)) {\n+            if (ns == ns_value) { ret some(ast::def_obj(odid.ctor)); }\n+            else { ret some(ast::def_obj(odid.ty)); }\n         }\n         case (_) { }\n     }\n@@ -590,11 +589,11 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, ident id,\n }\n \n fn lookup_in_mod(&env e, def m, ident id, namespace ns, dir dr)\n-    -> Option.t[def] {\n-    auto defid = ast.def_id_of_def(m);\n-    if (defid._0 != ast.local_crate) { // Not in this crate\n+    -> option::t[def] {\n+    auto defid = ast::def_id_of_def(m);\n+    if (defid._0 != ast::local_crate) { // Not in this crate\n         auto cached = e.ext_cache.find(tup(defid,id));\n-        if (cached != none[def] && check_def_by_ns(Option.get(cached), ns)) {\n+        if (cached != none[def] && check_def_by_ns(option::get(cached), ns)) {\n             ret cached;\n         }\n         auto path = vec(id);\n@@ -603,40 +602,41 @@ fn lookup_in_mod(&env e, def m, ident id, namespace ns, dir dr)\n         }\n         auto fnd = lookup_external(e, defid._0, path, ns);\n         if (fnd != none[def]) {\n-            e.ext_cache.insert(tup(defid,id), Option.get(fnd));\n+            e.ext_cache.insert(tup(defid,id), option::get(fnd));\n         }\n         ret fnd;\n     }\n     alt (m) {\n-        case (ast.def_mod(?defid)) {\n+        case (ast::def_mod(?defid)) {\n             ret lookup_in_regular_mod(e, defid, id, ns, dr);\n         }\n-        case (ast.def_native_mod(?defid)) {\n+        case (ast::def_native_mod(?defid)) {\n             ret lookup_in_native_mod(e, defid, id, ns);\n         }\n     }\n }\n \n-fn found_view_item(&env e, @ast.view_item vi, namespace ns) -> Option.t[def] {\n+fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n+    -> option::t[def] {\n     alt (vi.node) {\n-        case (ast.view_item_use(_, _, _, ?cnum)) {\n-            ret some(ast.def_mod(tup(Option.get(cnum), -1)));\n+        case (ast::view_item_use(_, _, _, ?cnum)) {\n+            ret some(ast::def_mod(tup(option::get(cnum), -1)));\n         }\n-        case (ast.view_item_import(_, _, ?defid)) {\n+        case (ast::view_item_import(_, _, ?defid)) {\n             ret lookup_import(e, defid, ns);\n         }\n     }\n }\n \n fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n-    -> Option.t[def] {\n+    -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n     auto found = info.index.find(id);\n     if (found == none[mod_index_entry] || \n-        (dr == outside && !ast.is_exported(id, info.m))) {\n+        (dr == outside && !ast::is_exported(id, info.m))) {\n         ret none[def];\n     }\n-    alt (Option.get(found)) {\n+    alt (option::get(found)) {\n         case (mie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n@@ -645,10 +645,10 @@ fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n         }\n         case (mie_tag_variant(?item, ?variant_idx)) {\n             alt (item.node) {\n-                case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n+                case (ast::item_tag(_, ?variants, _, ?tid, _)) {\n                     if (ns == ns_value) {\n                         auto vid = variants.(variant_idx).node.id;\n-                        ret some(ast.def_variant(tid, vid));\n+                        ret some(ast::def_variant(tid, vid));\n                     } else {\n                         ret none[def];\n                     }\n@@ -659,26 +659,26 @@ fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n }\n \n fn lookup_in_native_mod(&env e, def_id defid, ident id, namespace ns)\n-    -> Option.t[def] {\n+    -> option::t[def] {\n     auto info = e.nmod_map.get(defid._1);\n     auto found = info.index.find(id);\n     if (found == none[native_mod_index_entry]) {\n         ret none[def];\n     }\n-    alt (Option.get(found)) {\n+    alt (option::get(found)) {\n         case (nmie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n         case (nmie_item(?item)) {\n             alt (item.node) {\n-                case (ast.native_item_ty(_, ?id)) {\n+                case (ast::native_item_ty(_, ?id)) {\n                     if (ns == ns_type) {\n-                        ret some(ast.def_native_ty(id));\n+                        ret some(ast::def_native_ty(id));\n                     }\n                 }\n-                case (ast.native_item_fn(_, _, _, _, ?id, _)) {\n+                case (ast::native_item_fn(_, _, _, _, ?id, _)) {\n                     if (ns == ns_value) {\n-                        ret some(ast.def_native_fn(id));\n+                        ret some(ast::def_native_fn(id));\n                     }\n                 }\n             }\n@@ -690,48 +690,48 @@ fn lookup_in_native_mod(&env e, def_id defid, ident id, namespace ns)\n \n // Module indexing\n \n-fn index_mod(&ast._mod md) -> mod_index {\n+fn index_mod(&ast::_mod md) -> mod_index {\n     auto index = new_str_hash[mod_index_entry]();\n \n-    for (@ast.view_item it in md.view_items) {\n+    for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n-            case(ast.view_item_use(?id, _, _, _)) {\n+            case(ast::view_item_use(?id, _, _, _)) {\n                 index.insert(id, mie_view_item(it));\n             }\n-            case(ast.view_item_import(?def_ident,_,_)) {\n+            case(ast::view_item_import(?def_ident,_,_)) {\n                 index.insert(def_ident, mie_view_item(it));\n             }\n-            case(ast.view_item_export(_)) {}\n+            case(ast::view_item_export(_)) {}\n         }\n     }\n \n-    for (@ast.item it in md.items) {\n+    for (@ast::item it in md.items) {\n         alt (it.node) {\n-            case (ast.item_const(?id, _, _, _, _)) {\n+            case (ast::item_const(?id, _, _, _, _)) {\n                 index.insert(id, mie_item(it));\n             }\n-            case (ast.item_fn(?id, _, _, _, _)) {\n+            case (ast::item_fn(?id, _, _, _, _)) {\n                 index.insert(id, mie_item(it));\n             }\n-            case (ast.item_mod(?id, _, _)) {\n+            case (ast::item_mod(?id, _, _)) {\n                 index.insert(id, mie_item(it));\n             }\n-            case (ast.item_native_mod(?id, _, _)) {\n+            case (ast::item_native_mod(?id, _, _)) {\n                 index.insert(id, mie_item(it));\n             }\n-            case (ast.item_ty(?id, _, _, _, _)) {\n+            case (ast::item_ty(?id, _, _, _, _)) {\n                 index.insert(id, mie_item(it));\n             }\n-            case (ast.item_tag(?id, ?variants, _, _, _)) {\n+            case (ast::item_tag(?id, ?variants, _, _, _)) {\n                 index.insert(id, mie_item(it));\n                 let uint variant_idx = 0u;\n-                for (ast.variant v in variants) {\n+                for (ast::variant v in variants) {\n                     index.insert(v.node.name,\n                                  mie_tag_variant(it, variant_idx));\n                     variant_idx += 1u;\n                 }\n             }\n-            case (ast.item_obj(?id, _, _, _, _)) {\n+            case (ast::item_obj(?id, _, _, _, _)) {\n                 index.insert(id, mie_item(it));\n             }\n         }\n@@ -740,24 +740,24 @@ fn index_mod(&ast._mod md) -> mod_index {\n     ret index;\n }\n \n-fn index_nmod(&ast.native_mod md) -> nmod_index {\n+fn index_nmod(&ast::native_mod md) -> nmod_index {\n     auto index = new_str_hash[native_mod_index_entry]();\n \n-    for (@ast.view_item it in md.view_items) {\n+    for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n-            case(ast.view_item_import(?def_ident,_,_)) {\n+            case(ast::view_item_import(?def_ident,_,_)) {\n                 index.insert(def_ident, nmie_view_item(it));\n             }\n-            case(ast.view_item_export(_)) {}\n+            case(ast::view_item_export(_)) {}\n         }\n     }\n \n-    for (@ast.native_item it in md.items) {\n+    for (@ast::native_item it in md.items) {\n         alt (it.node) {\n-            case (ast.native_item_ty(?id, _)) {\n+            case (ast::native_item_ty(?id, _)) {\n                 index.insert(id, nmie_item(it));\n             }\n-            case (ast.native_item_fn(?id, _, _, _, _, _)) {\n+            case (ast::native_item_fn(?id, _, _, _, _, _)) {\n                 index.insert(id, nmie_item(it));\n             }\n         }\n@@ -771,31 +771,31 @@ fn index_nmod(&ast.native_mod md) -> nmod_index {\n // FIXME creader should handle multiple namespaces\n fn check_def_by_ns(def d, namespace ns) -> bool {\n     ret alt (d) {\n-        case (ast.def_fn(?id)) { ns == ns_value }\n-        case (ast.def_obj(?id)) { ns == ns_value }\n-        case (ast.def_obj_field(?id)) { ns == ns_value }\n-        case (ast.def_mod(?id)) { true }\n-        case (ast.def_native_mod(?id)) { true }\n-        case (ast.def_const(?id)) { ns == ns_value }\n-        case (ast.def_arg(?id)) { ns == ns_value }\n-        case (ast.def_local(?id)) { ns == ns_value }\n-        case (ast.def_upvar(?id)) { ns == ns_value }\n-        case (ast.def_variant(_, ?id)) { ns == ns_value }\n-        case (ast.def_ty(?id)) { ns == ns_type }\n-        case (ast.def_binding(?id)) { ns == ns_type }\n-        case (ast.def_use(?id)) { true }\n-        case (ast.def_native_ty(?id)) { ns == ns_type }\n-        case (ast.def_native_fn(?id)) { ns == ns_value }\n+        case (ast::def_fn(?id)) { ns == ns_value }\n+        case (ast::def_obj(?id)) { ns == ns_value }\n+        case (ast::def_obj_field(?id)) { ns == ns_value }\n+        case (ast::def_mod(?id)) { true }\n+        case (ast::def_native_mod(?id)) { true }\n+        case (ast::def_const(?id)) { ns == ns_value }\n+        case (ast::def_arg(?id)) { ns == ns_value }\n+        case (ast::def_local(?id)) { ns == ns_value }\n+        case (ast::def_upvar(?id)) { ns == ns_value }\n+        case (ast::def_variant(_, ?id)) { ns == ns_value }\n+        case (ast::def_ty(?id)) { ns == ns_type }\n+        case (ast::def_binding(?id)) { ns == ns_type }\n+        case (ast::def_use(?id)) { true }\n+        case (ast::def_native_ty(?id)) { ns == ns_type }\n+        case (ast::def_native_fn(?id)) { ns == ns_value }\n     };\n }\n \n fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n-    -> Option.t[def] {\n-    auto found = creader.lookup_def(e.sess, cnum, ids);\n+    -> option::t[def] {\n+    auto found = creader::lookup_def(e.sess, cnum, ids);\n     if (found != none[def]) {\n-        auto d = Option.get(found);\n+        auto d = option::get(found);\n         if (!check_def_by_ns(d, ns)) { ret none[def]; }\n-        e.ext_map.insert(ast.def_id_of_def(d), ids);\n+        e.ext_map.insert(ast::def_id_of_def(d), ids);\n     }\n     ret found;\n }"}, {"sha": "55f938d42fb186a86cc84802a1a5684ac4038824", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1443, "deletions": 1432, "changes": 2875, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2"}, {"sha": "ad876b3820d2ca56a4c148fe4b45f0c0bcc6a898", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 401, "deletions": 399, "changes": 800, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,37 +1,37 @@\n-import std.Str;\n-import std.UInt;\n-import std.Vec;\n-import std.Box;\n-import std.UFind;\n-import std.Map;\n-import std.Map.hashmap;\n-import std.Option;\n-import std.Option.none;\n-import std.Option.some;\n-\n-import driver.session;\n-import front.ast;\n-import front.ast.mutability;\n-import front.creader;\n-import middle.metadata;\n-import util.common;\n-\n-import util.common.ty_u8;\n-import util.common.ty_u16;\n-import util.common.ty_u32;\n-import util.common.ty_u64;\n-\n-import util.common.ty_i8;\n-import util.common.ty_i16;\n-import util.common.ty_i32;\n-import util.common.ty_i64;\n-\n-import util.common.ty_f32;\n-import util.common.ty_f64;\n-\n-import util.common.new_def_hash;\n-import util.common.span;\n-import util.typestate_ann.ts_ann;\n+import std::_str;\n+import std::_uint;\n+import std::_vec;\n+import std::box;\n+import std::ufind;\n+import std::map;\n+import std::map::hashmap;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+\n+import driver::session;\n+import front::ast;\n+import front::ast::mutability;\n+import front::creader;\n+import middle::metadata;\n+import util::common;\n+\n+import util::common::ty_u8;\n+import util::common::ty_u16;\n+import util::common::ty_u32;\n+import util::common::ty_u64;\n+\n+import util::common::ty_i8;\n+import util::common::ty_i16;\n+import util::common::ty_i32;\n+import util::common::ty_i64;\n+\n+import util::common::ty_f32;\n+import util::common::ty_f64;\n+\n+import util::common::new_def_hash;\n+import util::common::span;\n+import util::typestate_ann::ts_ann;\n \n // Data types\n \n@@ -42,23 +42,23 @@ tag mode {\n }\n \n type arg = rec(mode mode, t ty);\n-type field = rec(ast.ident ident, mt mt);\n-type method = rec(ast.proto proto,\n-                  ast.ident ident,\n+type field = rec(ast::ident ident, mt mt);\n+type method = rec(ast::proto proto,\n+                  ast::ident ident,\n                   vec[arg] inputs,\n                   t output);\n \n-type mt = rec(t ty, ast.mutability mut);\n+type mt = rec(t ty, ast::mutability mut);\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type creader_cache = hashmap[tup(int,uint,uint),ty.t];\n+type creader_cache = hashmap[tup(int,uint,uint),ty::t];\n type ctxt = rec(@type_store ts,\n-                session.session sess,\n-                resolve.def_map def_map,\n+                session::session sess,\n+                resolve::def_map def_map,\n                 creader_cache rcache,\n                 hashmap[t,str] short_names_cache);\n-type ty_ctxt = ctxt;    // Needed for disambiguation from Unify.ctxt.\n+type ty_ctxt = ctxt;    // Needed for disambiguation from Unify::ctxt.\n \n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n@@ -71,7 +71,7 @@ fn method_ty_to_fn_ty(ctxt cx, method m) -> t {\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariants.\n type raw_t = rec(sty struct,\n-                 Option.t[str] cname,\n+                 option::t[str] cname,\n                  uint hash,\n                  bool has_params,\n                  bool has_bound_params,\n@@ -81,29 +81,29 @@ type raw_t = rec(sty struct,\n type t = uint;\n \n // NB: If you change this, you'll probably want to change the corresponding\n-// AST structure in front/ast.rs as well.\n+// AST structure in front/ast::rs as well.\n tag sty {\n     ty_nil;\n     ty_bool;\n     ty_int;\n     ty_float;\n     ty_uint;\n-    ty_machine(util.common.ty_mach);\n+    ty_machine(util::common::ty_mach);\n     ty_char;\n     ty_str;\n-    ty_tag(ast.def_id, vec[t]);\n+    ty_tag(ast::def_id, vec[t]);\n     ty_box(mt);\n     ty_vec(mt);\n     ty_port(t);\n     ty_chan(t);\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast.proto, vec[arg], t);\n-    ty_native_fn(ast.native_abi, vec[arg], t);\n+    ty_fn(ast::proto, vec[arg], t);\n+    ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n-    ty_local(ast.def_id);                           // type of a local var\n+    ty_local(ast::def_id);                           // type of a local var\n     ty_param(uint);                                 // fn/tag type param\n     ty_bound_param(uint);                           // bound param, only paths\n     ty_type;\n@@ -114,9 +114,9 @@ tag sty {\n // Data structures used in type unification\n \n type unify_handler = obj {\n-    fn resolve_local(ast.def_id id) -> Option.t[t];\n-    fn record_local(ast.def_id id, t ty);  // TODO: -> Unify.result\n-    fn record_param(uint index, t binding) -> Unify.result;\n+    fn resolve_local(ast::def_id id) -> option::t[t];\n+    fn record_local(ast::def_id id, t ty);  // TODO: -> Unify::result\n+    fn record_param(uint index, t binding) -> Unify::result;\n };\n \n tag type_err {\n@@ -127,15 +127,15 @@ tag type_err {\n     terr_tuple_mutability;\n     terr_record_size(uint, uint);\n     terr_record_mutability;\n-    terr_record_fields(ast.ident,ast.ident);\n+    terr_record_fields(ast::ident,ast::ident);\n     terr_meth_count;\n-    terr_obj_meths(ast.ident,ast.ident);\n+    terr_obj_meths(ast::ident,ast::ident);\n     terr_arg_count;\n }\n \n \n type ty_param_count_and_ty = tup(uint, t);\n-type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n+type type_cache = hashmap[ast::def_id,ty_param_count_and_ty];\n \n const uint idx_nil      = 0u;\n const uint idx_bool     = 1u;\n@@ -165,7 +165,7 @@ type type_store = rec(mutable vec[raw_t] others,\n fn mk_type_store() -> @type_store {\n     let vec[raw_t] others = vec();\n     let hashmap[raw_t,uint] ost =\n-        Map.mk_hashmap[raw_t,uint](hash_raw_ty, eq_raw_ty);\n+        map::mk_hashmap[raw_t,uint](hash_raw_ty, eq_raw_ty);\n \n     auto ts = @rec(mutable others=others, other_structural=ost);\n \n@@ -190,7 +190,7 @@ fn mk_type_store() -> @type_store {\n     intern(ts, ty_native, none[str]);\n     intern(ts, ty_type, none[str]);\n \n-    assert Vec.len(ts.others) == idx_first_others;\n+    assert _vec::len(ts.others) == idx_first_others;\n \n     ret ts;\n }\n@@ -207,22 +207,22 @@ fn mk_rcache() -> creader_cache {\n     }\n     auto h = hash_cache_entry;\n     auto e = eq_cache_entries;\n-    ret Map.mk_hashmap[tup(int,uint,uint),t](h, e);\n+    ret map::mk_hashmap[tup(int,uint,uint),t](h, e);\n }\n \n-fn mk_ctxt(session.session s, resolve.def_map dm) -> ctxt {\n+fn mk_ctxt(session::session s, resolve::def_map dm) -> ctxt {\n     ret rec(ts = mk_type_store(),\n             sess = s,\n             def_map = dm,\n             rcache = mk_rcache(),\n             short_names_cache =\n-                Map.mk_hashmap[ty.t,str](ty.hash_ty, ty.eq_ty));\n+                map::mk_hashmap[ty::t,str](ty::hash_ty, ty::eq_ty));\n }\n \n \n // Type constructors\n \n-fn mk_raw_ty(&@type_store ts, &sty st, &Option.t[str] cname) -> raw_t {\n+fn mk_raw_ty(&@type_store ts, &sty st, &option::t[str] cname) -> raw_t {\n     auto h = hash_type_info(st, cname);\n \n     let bool has_params = false;\n@@ -352,16 +352,16 @@ fn mk_raw_ty(&@type_store ts, &sty st, &Option.t[str] cname) -> raw_t {\n }\n \n fn intern_raw_ty(&@type_store ts, &raw_t rt) {\n-    auto type_num = Vec.len[raw_t](ts.others);\n+    auto type_num = _vec::len[raw_t](ts.others);\n     ts.others += vec(rt);\n     ts.other_structural.insert(rt, type_num);\n }\n \n-fn intern(&@type_store ts, &sty st, &Option.t[str] cname) {\n+fn intern(&@type_store ts, &sty st, &option::t[str] cname) {\n     intern_raw_ty(ts, mk_raw_ty(ts, st, cname));\n }\n \n-fn gen_ty_full(&ctxt cx, &sty st, &Option.t[str] cname) -> t {\n+fn gen_ty_full(&ctxt cx, &sty st, &option::t[str] cname) -> t {\n     auto raw_type = mk_raw_ty(cx.ts, st, cname);\n \n     // Is it interned?\n@@ -370,8 +370,8 @@ fn gen_ty_full(&ctxt cx, &sty st, &Option.t[str] cname) -> t {\n             ret typ;\n         }\n         case (none[t]) {\n-            // Nope. Insert it and return.\n-            auto type_num = Vec.len[raw_t](cx.ts.others);\n+            // Nope: Insert it and return.\n+            auto type_num = _vec::len[raw_t](cx.ts.others);\n             intern_raw_ty(cx.ts, raw_type);\n             // log_err \"added: \" + ty_to_str(tystore, raw_type);\n             ret type_num;\n@@ -391,7 +391,7 @@ fn mk_int(&ctxt cx) -> t          { ret idx_int; }\n fn mk_float(&ctxt cx) -> t        { ret idx_float; }\n fn mk_uint(&ctxt cx) -> t         { ret idx_uint; }\n \n-fn mk_mach(&ctxt cx, &util.common.ty_mach tm) -> t {\n+fn mk_mach(&ctxt cx, &util::common::ty_mach tm) -> t {\n     alt (tm) {\n         case (ty_u8)  { ret idx_u8; }\n         case (ty_u16) { ret idx_u16; }\n@@ -412,7 +412,7 @@ fn mk_mach(&ctxt cx, &util.common.ty_mach tm) -> t {\n fn mk_char(&ctxt cx) -> t    { ret idx_char; }\n fn mk_str(&ctxt cx) -> t     { ret idx_str; }\n \n-fn mk_tag(&ctxt cx, &ast.def_id did, &vec[t] tys) -> t {\n+fn mk_tag(&ctxt cx, &ast::def_id did, &vec[t] tys) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n }\n \n@@ -421,7 +421,7 @@ fn mk_box(&ctxt cx, &mt tm) -> t {\n }\n \n fn mk_imm_box(&ctxt cx, &t ty) -> t {\n-    ret mk_box(cx, rec(ty=ty, mut=ast.imm));\n+    ret mk_box(cx, rec(ty=ty, mut=ast::imm));\n }\n \n fn mk_vec(&ctxt cx, &mt tm) -> t  { ret gen_ty(cx, ty_vec(tm)); }\n@@ -433,20 +433,20 @@ fn mk_tup(&ctxt cx, &vec[mt] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n \n fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n     // TODO: map\n-    let vec[ty.mt] mts = vec();\n+    let vec[ty::mt] mts = vec();\n     for (t typ in tys) {\n-        mts += vec(rec(ty=typ, mut=ast.imm));\n+        mts += vec(rec(ty=typ, mut=ast::imm));\n     }\n     ret mk_tup(cx, mts);\n }\n \n fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_fn(&ctxt cx, &ast.proto proto, &vec[arg] args, &t ty) -> t {\n+fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty));\n }\n \n-fn mk_native_fn(&ctxt cx, &ast.native_abi abi, &vec[arg] args, &t ty) -> t {\n+fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &vec[arg] args, &t ty) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n@@ -458,7 +458,7 @@ fn mk_var(&ctxt cx, int v) -> t {\n     ret gen_ty(cx, ty_var(v));\n }\n \n-fn mk_local(&ctxt cx, ast.def_id did) -> t {\n+fn mk_local(&ctxt cx, ast::def_id did) -> t {\n     ret gen_ty(cx, ty_local(did));\n }\n \n@@ -478,17 +478,17 @@ fn mk_native(&ctxt cx) -> t  { ret idx_native; }\n fn struct(&ctxt cx, &t typ) -> sty { ret cx.ts.others.(typ).struct; }\n \n // Returns the canonical name of the given type.\n-fn cname(&ctxt cx, &t typ) -> Option.t[str] { ret cx.ts.others.(typ).cname; }\n+fn cname(&ctxt cx, &t typ) -> option::t[str] { ret cx.ts.others.(typ).cname; }\n \n \n // Stringification\n \n-fn path_to_str(&ast.path pth) -> str {\n-    auto result = Str.connect(pth.node.idents,  \"::\");\n-    if (Vec.len[@ast.ty](pth.node.types) > 0u) {\n-        auto f = pretty.pprust.ty_to_str;\n+fn path_to_str(&ast::path pth) -> str {\n+    auto result = _str::connect(pth.node.idents,  \"::\");\n+    if (_vec::len[@ast::ty](pth.node.types) > 0u) {\n+        auto f = pretty::pprust::ty_to_str;\n         result += \"[\";\n-        result += Str.connect(Vec.map[@ast.ty,str](f, pth.node.types), \",\");\n+        result += _str::connect(_vec::map(f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;\n@@ -508,31 +508,31 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     }\n \n     fn fn_to_str(ctxt cx,\n-                 ast.proto proto,\n-                 Option.t[ast.ident] ident,\n+                 ast::proto proto,\n+                 option::t[ast::ident] ident,\n                  vec[arg] inputs, t output) -> str {\n             auto f = bind fn_input_to_str(cx, _);\n \n             auto s;\n             alt (proto) {\n-                case (ast.proto_iter) {\n+                case (ast::proto_iter) {\n                     s = \"iter\";\n                 }\n-                case (ast.proto_fn) {\n+                case (ast::proto_fn) {\n                     s = \"fn\";\n                 }\n             }\n \n             alt (ident) {\n-                case (some[ast.ident](?i)) {\n+                case (some[ast::ident](?i)) {\n                     s += \" \";\n                     s += i;\n                 }\n                 case (_) { }\n             }\n \n             s += \"(\";\n-            s += Str.connect(Vec.map[arg,str](f, inputs), \", \");\n+            s += _str::connect(_vec::map[arg,str](f, inputs), \", \");\n             s += \")\";\n \n             if (struct(cx, output) != ty_nil) {\n@@ -542,7 +542,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     }\n \n     fn method_to_str(ctxt cx, &method m) -> str {\n-        ret fn_to_str(cx, m.proto, some[ast.ident](m.ident),\n+        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident),\n                       m.inputs, m.output) + \";\";\n     }\n \n@@ -553,9 +553,9 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     fn mt_to_str(ctxt cx, &mt m) -> str {\n         auto mstr;\n         alt (m.mut) {\n-            case (ast.mut)       { mstr = \"mutable \"; }\n-            case (ast.imm)       { mstr = \"\";         }\n-            case (ast.maybe_mut) { mstr = \"mutable? \"; }\n+            case (ast::mut)       { mstr = \"mutable \"; }\n+            case (ast::imm)       { mstr = \"\";         }\n+            case (ast::maybe_mut) { mstr = \"mutable? \"; }\n         }\n \n         ret mstr + ty_to_str(cx, m.ty);\n@@ -577,7 +577,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n         case (ty_int)          { s += \"int\";                            }\n         case (ty_float)        { s += \"float\";                          }\n         case (ty_uint)         { s += \"uint\";                           }\n-        case (ty_machine(?tm)) { s += common.ty_mach_to_str(tm);        }\n+        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm);        }\n         case (ty_char)         { s += \"char\";                           }\n         case (ty_str)          { s += \"str\";                            }\n         case (ty_box(?tm))     { s += \"@\" + mt_to_str(cx, tm);          }\n@@ -588,56 +588,58 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n         case (ty_tup(?elems)) {\n             auto f = bind mt_to_str(cx, _);\n-            auto strs = Vec.map[mt,str](f, elems);\n-            s += \"tup(\" + Str.connect(strs, \",\") + \")\";\n+            auto strs = _vec::map[mt,str](f, elems);\n+            s += \"tup(\" + _str::connect(strs, \",\") + \")\";\n         }\n \n         case (ty_rec(?elems)) {\n             auto f = bind field_to_str(cx, _);\n-            auto strs = Vec.map[field,str](f, elems);\n-            s += \"rec(\" + Str.connect(strs, \",\") + \")\";\n+            auto strs = _vec::map[field,str](f, elems);\n+            s += \"rec(\" + _str::connect(strs, \",\") + \")\";\n         }\n \n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-            s += \"<tag#\" + util.common.istr(id._0) + \":\" +\n-                util.common.istr(id._1) + \">\";\n-            if (Vec.len[t](tps) > 0u) {\n+            s += \"<tag#\" + util::common::istr(id._0) + \":\" +\n+                util::common::istr(id._1) + \">\";\n+            if (_vec::len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n-                auto strs = Vec.map[t,str](f, tps);\n-                s += \"[\" + Str.connect(strs, \",\") + \"]\";\n+                auto strs = _vec::map[t,str](f, tps);\n+                s += \"[\" + _str::connect(strs, \",\") + \"]\";\n             }\n         }\n \n         case (ty_fn(?proto, ?inputs, ?output)) {\n-            s += fn_to_str(cx, proto, none[ast.ident], inputs, output);\n+            s += fn_to_str(cx, proto, none[ast::ident], inputs, output);\n         }\n \n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            s += fn_to_str(cx, ast.proto_fn, none[ast.ident], inputs, output);\n+            s += fn_to_str(cx, ast::proto_fn, none[ast::ident],\n+                           inputs, output);\n         }\n \n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n-            auto m = Vec.map[method,str](f, meths);\n-            s += \"obj {\\n\\t\" + Str.connect(m, \"\\n\\t\") + \"\\n}\";\n+            auto m = _vec::map[method,str](f, meths);\n+            s += \"obj {\\n\\t\" + _str::connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n \n         case (ty_var(?v)) {\n-            s += \"<T\" + util.common.istr(v) + \">\";\n+            s += \"<T\" + util::common::istr(v) + \">\";\n         }\n \n         case (ty_local(?id)) {\n-            s += \"<L\" + util.common.istr(id._0) + \":\" +\n-                util.common.istr(id._1) + \">\";\n+            s += \"<L\" + util::common::istr(id._0) + \":\" +\n+                util::common::istr(id._1) + \">\";\n         }\n \n         case (ty_param(?id)) {\n-            s += \"'\" + Str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n+            s += \"'\" + _str::unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n         }\n \n         case (ty_bound_param(?id)) {\n-            s += \"''\" + Str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n+            s += \"''\" + _str::unsafe_from_bytes(vec(('a' as u8) +\n+                                                    (id as u8)));\n         }\n     }\n \n@@ -646,9 +648,9 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n fn ty_to_short_str(ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n-    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata.ac_no_abbrevs);\n-    auto s = metadata.Encode.ty_str(ecx, typ);\n-    if (Str.byte_len(s) >= 32u) { s = Str.substr(s, 0u, 32u); }\n+    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::ac_no_abbrevs);\n+    auto s = metadata::Encode::ty_str(ecx, typ);\n+    if (_str::byte_len(s) >= 32u) { s = _str::substr(s, 0u, 32u); }\n     ret s;\n }\n \n@@ -862,7 +864,7 @@ fn type_is_sequence(&ctxt cx, &t ty) -> bool {\n \n fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n-        case (ty_str)      { ret mk_mach(cx, common.ty_u8); }\n+        case (ty_str)      { ret mk_mach(cx, common::ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n@@ -943,14 +945,14 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n-            while (i < Vec.len[mt](mts)) {\n+            while (i < _vec::len[mt](mts)) {\n                 if (type_has_dynamic_size(cx, mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n-            while (i < Vec.len[field](fields)) {\n+            while (i < _vec::len[field](fields)) {\n                 if (type_has_dynamic_size(cx, fields.(i).mt.ty)) {\n                     ret true;\n                 }\n@@ -959,7 +961,7 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n-            while (i < Vec.len[t](subtys)) {\n+            while (i < _vec::len[t](subtys)) {\n                 if (type_has_dynamic_size(cx, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n@@ -976,15 +978,15 @@ fn type_is_integral(&ctxt cx, &t ty) -> bool {\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n             alt (m) {\n-                case (common.ty_i8) { ret true; }\n-                case (common.ty_i16) { ret true; }\n-                case (common.ty_i32) { ret true; }\n-                case (common.ty_i64) { ret true; }\n-\n-                case (common.ty_u8) { ret true; }\n-                case (common.ty_u16) { ret true; }\n-                case (common.ty_u32) { ret true; }\n-                case (common.ty_u64) { ret true; }\n+                case (common::ty_i8) { ret true; }\n+                case (common::ty_i16) { ret true; }\n+                case (common::ty_i32) { ret true; }\n+                case (common::ty_i64) { ret true; }\n+\n+                case (common::ty_u8) { ret true; }\n+                case (common::ty_u16) { ret true; }\n+                case (common::ty_u32) { ret true; }\n+                case (common::ty_u64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -998,8 +1000,8 @@ fn type_is_fp(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common.ty_f32) { ret true; }\n-                case (common.ty_f64) { ret true; }\n+                case (common::ty_f32) { ret true; }\n+                case (common::ty_f64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1016,10 +1018,10 @@ fn type_is_signed(&ctxt cx, &t ty) -> bool {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common.ty_i8) { ret true; }\n-                case (common.ty_i16) { ret true; }\n-                case (common.ty_i32) { ret true; }\n-                case (common.ty_i64) { ret true; }\n+                case (common::ty_i8) { ret true; }\n+                case (common::ty_i16) { ret true; }\n+                case (common::ty_i32) { ret true; }\n+                case (common::ty_i64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1028,15 +1030,15 @@ fn type_is_signed(&ctxt cx, &t ty) -> bool {\n     fail;\n }\n \n-fn type_param(&ctxt cx, &t ty) -> Option.t[uint] {\n+fn type_param(&ctxt cx, &t ty) -> option::t[uint] {\n     alt (struct(cx, ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n     }\n     ret none[uint];\n }\n \n-fn def_to_str(&ast.def_id did) -> str {\n+fn def_to_str(&ast::def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n \n@@ -1050,7 +1052,7 @@ fn hash_type_structure(&sty st) -> uint {\n         ret h;\n     }\n \n-    fn hash_def(uint id, ast.def_id did) -> uint {\n+    fn hash_def(uint id, ast::def_id did) -> uint {\n         auto h = id;\n         h += h << 5u + (did._0 as uint);\n         h += h << 5u + (did._1 as uint);\n@@ -1080,18 +1082,18 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_uint) { ret 4u; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common.ty_i8) { ret 5u; }\n-                case (common.ty_i16) { ret 6u; }\n-                case (common.ty_i32) { ret 7u; }\n-                case (common.ty_i64) { ret 8u; }\n+                case (common::ty_i8) { ret 5u; }\n+                case (common::ty_i16) { ret 6u; }\n+                case (common::ty_i32) { ret 7u; }\n+                case (common::ty_i64) { ret 8u; }\n \n-                case (common.ty_u8) { ret 9u; }\n-                case (common.ty_u16) { ret 10u; }\n-                case (common.ty_u32) { ret 11u; }\n-                case (common.ty_u64) { ret 12u; }\n+                case (common::ty_u8) { ret 9u; }\n+                case (common::ty_u16) { ret 10u; }\n+                case (common::ty_u32) { ret 11u; }\n+                case (common::ty_u64) { ret 12u; }\n \n-                case (common.ty_f32) { ret 13u; }\n-                case (common.ty_f64) { ret 14u; }\n+                case (common::ty_f32) { ret 13u; }\n+                case (common::ty_f64) { ret 14u; }\n             }\n         }\n         case (ty_char) { ret 15u; }\n@@ -1127,7 +1129,7 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_obj(?methods)) {\n             auto h = 27u;\n             for (method m in methods) {\n-                h += h << 5u + Str.hash(m.ident);\n+                h += h << 5u + _str::hash(m.ident);\n             }\n             ret h;\n         }\n@@ -1140,11 +1142,11 @@ fn hash_type_structure(&sty st) -> uint {\n     }\n }\n \n-fn hash_type_info(&sty st, &Option.t[str] cname_opt) -> uint {\n+fn hash_type_info(&sty st, &option::t[str] cname_opt) -> uint {\n     auto h = hash_type_structure(st);\n     alt (cname_opt) {\n         case (none[str]) { /* no-op */ }\n-        case (some[str](?s)) { h += h << 5u + Str.hash(s); }\n+        case (some[str](?s)) { h += h << 5u + _str::hash(s); }\n     }\n     ret h;\n }\n@@ -1165,8 +1167,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 &vec[arg] args_b, &t rty_b) -> bool {\n         if (!eq_ty(rty_a, rty_b)) { ret false; }\n \n-        auto len = Vec.len[arg](args_a);\n-        if (len != Vec.len[arg](args_b)) { ret false; }\n+        auto len = _vec::len[arg](args_a);\n+        if (len != _vec::len[arg](args_b)) { ret false; }\n \n         auto i = 0u;\n         while (i < len) {\n@@ -1178,7 +1180,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         ret true;\n     }\n \n-    fn equal_def(&ast.def_id did_a, &ast.def_id did_b) -> bool {\n+    fn equal_def(&ast::def_id did_a, &ast::def_id did_b) -> bool {\n         ret did_a._0 == did_b._0 && did_a._1 == did_b._1;\n     }\n \n@@ -1238,8 +1240,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (ty_tag(?id_b, ?tys_b)) {\n                     if (!equal_def(id_a, id_b)) { ret false; }\n \n-                    auto len = Vec.len[t](tys_a);\n-                    if (len != Vec.len[t](tys_b)) { ret false; }\n+                    auto len = _vec::len[t](tys_a);\n+                    if (len != _vec::len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!eq_ty(tys_a.(i), tys_b.(i))) { ret false; }\n@@ -1283,8 +1285,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_tup(?mts_a)) {\n             alt (b) {\n                 case (ty_tup(?mts_b)) {\n-                    auto len = Vec.len[mt](mts_a);\n-                    if (len != Vec.len[mt](mts_b)) { ret false; }\n+                    auto len = _vec::len[mt](mts_a);\n+                    if (len != _vec::len[mt](mts_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!equal_mt(mts_a.(i), mts_b.(i))) { ret false; }\n@@ -1298,12 +1300,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_rec(?flds_a)) {\n             alt (b) {\n                 case (ty_rec(?flds_b)) {\n-                    auto len = Vec.len[field](flds_a);\n-                    if (len != Vec.len[field](flds_b)) { ret false; }\n+                    auto len = _vec::len[field](flds_a);\n+                    if (len != _vec::len[field](flds_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto fld_a = flds_a.(i); auto fld_b = flds_b.(i);\n-                        if (!Str.eq(fld_a.ident, fld_b.ident) ||\n+                        if (!_str::eq(fld_a.ident, fld_b.ident) ||\n                                 !equal_mt(fld_a.mt, fld_b.mt)) {\n                             ret false;\n                         }\n@@ -1335,13 +1337,13 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_obj(?methods_a)) {\n             alt (b) {\n                 case (ty_obj(?methods_b)) {\n-                    auto len = Vec.len[method](methods_a);\n-                    if (len != Vec.len[method](methods_b)) { ret false; }\n+                    auto len = _vec::len[method](methods_a);\n+                    if (len != _vec::len[method](methods_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto m_a = methods_a.(i); auto m_b = methods_b.(i);\n                         if (m_a.proto != m_b.proto ||\n-                                !Str.eq(m_a.ident, m_b.ident) ||\n+                                !_str::eq(m_a.ident, m_b.ident) ||\n                                 !equal_fn(m_a.inputs, m_a.output,\n                                           m_b.inputs, m_b.output)) {\n                             ret false;\n@@ -1413,7 +1415,7 @@ fn eq_raw_ty(&raw_t a, &raw_t b) -> bool {\n         case (some[str](?s_a)) {\n             alt (b.cname) {\n                 case (some[str](?s_b)) {\n-                    if (!Str.eq(s_a, s_b)) { ret false; }\n+                    if (!_str::eq(s_a, s_b)) { ret false; }\n                 }\n                 case (_) { ret false; }\n             }\n@@ -1429,25 +1431,25 @@ fn eq_raw_ty(&raw_t a, &raw_t b) -> bool {\n fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n \n-fn ann_to_type(&ast.ann ann) -> t {\n+fn ann_to_type(&ast::ann ann) -> t {\n     alt (ann) {\n-        case (ast.ann_none(_)) {\n+        case (ast::ann_none(_)) {\n             log_err \"ann_to_type() called on node with no type\";\n             fail;\n         }\n-        case (ast.ann_type(_, ?ty, _, _)) {\n+        case (ast::ann_type(_, ?ty, _, _)) {\n             ret ty;\n         }\n     }\n }\n \n-fn ann_to_type_params(&ast.ann ann) -> vec[t] {\n+fn ann_to_type_params(&ast::ann ann) -> vec[t] {\n     alt (ann) {\n-        case (ast.ann_none(_)) {\n+        case (ast::ann_none(_)) {\n             log_err \"ann_to_type_params() called on node with no type params\";\n             fail;\n         }\n-        case (ast.ann_type(_, _, ?tps, _)) {\n+        case (ast::ann_type(_, _, ?tps, _)) {\n             alt (tps) {\n                 case (none[vec[t]]) {\n                     let vec[t] result = vec();\n@@ -1461,15 +1463,15 @@ fn ann_to_type_params(&ast.ann ann) -> vec[t] {\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(ctxt cx, ast.ann a) -> t {\n+fn ann_to_monotype(ctxt cx, ast::ann a) -> t {\n     // TODO: Refactor to use recursive pattern matching when we're more\n     // confident that it works.\n     alt (a) {\n-        case (ast.ann_none(_)) {\n+        case (ast::ann_none(_)) {\n             log_err \"ann_to_monotype() called on expression with no type!\";\n             fail;\n         }\n-        case (ast.ann_type(_, ?typ, ?tps_opt, _)) {\n+        case (ast::ann_type(_, ?typ, ?tps_opt, _)) {\n             alt (tps_opt) {\n                 case (none[vec[t]]) { ret typ; }\n                 case (some[vec[t]](?tps)) {\n@@ -1481,8 +1483,8 @@ fn ann_to_monotype(ctxt cx, ast.ann a) -> t {\n }\n \n // Turns a type into an ann_type, using defaults for other fields.\n-fn triv_ann(&ast.ann old, t typ) -> ast.ann {\n-    ret ast.ann_type(ast.ann_tag(old), typ, none[vec[t]], none[@ts_ann]);\n+fn triv_ann(&ast::ann old, t typ) -> ast::ann {\n+    ret ast::ann_type(ast::ann_tag(old), typ, none[vec[t]], none[@ts_ann]);\n }\n \n // Returns the number of distinct type parameters in the given type.\n@@ -1508,7 +1510,7 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n     let @mutable vec[uint] param_indices = @mutable v;\n     auto f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n-    ret Vec.len[uint](*param_indices);\n+    ret _vec::len[uint](*param_indices);\n }\n \n fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n@@ -1531,38 +1533,38 @@ fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n     alt (struct(cx, fty)) {\n-        case (ty.ty_fn(_, ?a, _)) { ret a; }\n-        case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n+        case (ty::ty_fn(_, ?a, _)) { ret a; }\n+        case (ty::ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_proto(&ctxt cx, &t fty) -> ast.proto {\n+fn ty_fn_proto(&ctxt cx, &t fty) -> ast::proto {\n     alt (struct(cx, fty)) {\n-        case (ty.ty_fn(?p, _, _)) { ret p; }\n+        case (ty::ty_fn(?p, _, _)) { ret p; }\n     }\n     fail;\n }\n \n-fn ty_fn_abi(&ctxt cx, &t fty) -> ast.native_abi {\n+fn ty_fn_abi(&ctxt cx, &t fty) -> ast::native_abi {\n     alt (struct(cx, fty)) {\n-        case (ty.ty_native_fn(?a, _, _)) { ret a; }\n+        case (ty::ty_native_fn(?a, _, _)) { ret a; }\n     }\n     fail;\n }\n \n fn ty_fn_ret(&ctxt cx, &t fty) -> t {\n     alt (struct(cx, fty)) {\n-        case (ty.ty_fn(_, _, ?r)) { ret r; }\n-        case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n+        case (ty::ty_fn(_, _, ?r)) { ret r; }\n+        case (ty::ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n     alt (struct(cx, fty)) {\n-        case (ty.ty_fn(_, _, _)) { ret true; }\n-        case (ty.ty_native_fn(_, _, _)) { ret true; }\n+        case (ty::ty_fn(_, _, _)) { ret true; }\n+        case (ty::ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n     }\n     ret false;\n@@ -1573,53 +1575,53 @@ fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n \n // Given an item, returns the associated type as well as the number of type\n // parameters it has.\n-fn native_item_ty(&@ast.native_item it) -> ty_param_count_and_ty {\n+fn native_item_ty(&@ast::native_item it) -> ty_param_count_and_ty {\n     auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n-        case (ast.native_item_fn(_, _, _, ?tps, _, ?ann)) {\n-            ty_param_count = Vec.len[ast.ty_param](tps);\n+        case (ast::native_item_fn(_, _, _, ?tps, _, ?ann)) {\n+            ty_param_count = _vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n     }\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn item_ty(&@ast.item it) -> ty_param_count_and_ty {\n+fn item_ty(&@ast::item it) -> ty_param_count_and_ty {\n     auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n-        case (ast.item_const(_, _, _, _, ?ann)) {\n+        case (ast::item_const(_, _, _, _, ?ann)) {\n             ty_param_count = 0u;\n             result_ty = ann_to_type(ann);\n         }\n-        case (ast.item_fn(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = Vec.len[ast.ty_param](tps);\n+        case (ast::item_fn(_, _, ?tps, _, ?ann)) {\n+            ty_param_count = _vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n-        case (ast.item_mod(_, _, _)) {\n+        case (ast::item_mod(_, _, _)) {\n             fail;   // modules are typeless\n         }\n-        case (ast.item_ty(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = Vec.len[ast.ty_param](tps);\n+        case (ast::item_ty(_, _, ?tps, _, ?ann)) {\n+            ty_param_count = _vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n-        case (ast.item_tag(_, _, ?tps, ?did, ?ann)) {\n-            ty_param_count = Vec.len[ast.ty_param](tps);\n+        case (ast::item_tag(_, _, ?tps, ?did, ?ann)) {\n+            ty_param_count = _vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n-        case (ast.item_obj(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = Vec.len[ast.ty_param](tps);\n+        case (ast::item_obj(_, _, ?tps, _, ?ann)) {\n+            ty_param_count = _vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n     }\n \n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(&ctxt cx, &@ast.stmt s) -> t {\n+fn stmt_ty(&ctxt cx, &@ast::stmt s) -> t {\n     alt (s.node) {\n-        case (ast.stmt_expr(?e,_)) {\n+        case (ast::stmt_expr(?e,_)) {\n             ret expr_ty(cx, e);\n         }\n         case (_) {\n@@ -1628,133 +1630,133 @@ fn stmt_ty(&ctxt cx, &@ast.stmt s) -> t {\n     }\n }\n \n-fn block_ty(&ctxt cx, &ast.block b) -> t {\n+fn block_ty(&ctxt cx, &ast::block b) -> t {\n     alt (b.node.expr) {\n-        case (some[@ast.expr](?e)) { ret expr_ty(cx, e); }\n-        case (none[@ast.expr])     { ret mk_nil(cx); }\n+        case (some[@ast::expr](?e)) { ret expr_ty(cx, e); }\n+        case (none[@ast::expr])     { ret mk_nil(cx); }\n     }\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(&ctxt cx, &@ast.pat pat) -> t {\n+fn pat_ty(&ctxt cx, &@ast::pat pat) -> t {\n     alt (pat.node) {\n-        case (ast.pat_wild(?ann))           { ret ann_to_monotype(cx, ann); }\n-        case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(cx, ann); }\n-        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(cx, ann); }\n-        case (ast.pat_tag(_, _, ?ann))      { ret ann_to_monotype(cx, ann); }\n+        case (ast::pat_wild(?ann))           { ret ann_to_monotype(cx, ann); }\n+        case (ast::pat_lit(_, ?ann))         { ret ann_to_monotype(cx, ann); }\n+        case (ast::pat_bind(_, _, ?ann))     { ret ann_to_monotype(cx, ann); }\n+        case (ast::pat_tag(_, _, ?ann))      { ret ann_to_monotype(cx, ann); }\n     }\n     fail;   // not reached\n }\n \n-fn expr_ann(&@ast.expr e) -> ast.ann {\n+fn expr_ann(&@ast::expr e) -> ast::ann {\n     alt(e.node) {\n-        case (ast.expr_vec(_,_,?a)) {\n+        case (ast::expr_vec(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_tup(_,?a)) {\n+        case (ast::expr_tup(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_rec(_,_,?a)) {\n+        case (ast::expr_rec(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_call(_,_,?a)) {\n+        case (ast::expr_call(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_bind(_,_,?a)) {\n+        case (ast::expr_bind(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_binary(_,_,_,?a)) {\n+        case (ast::expr_binary(_,_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_unary(_,_,?a)) {\n+        case (ast::expr_unary(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_lit(_,?a)) {\n+        case (ast::expr_lit(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_cast(_,_,?a)) {\n+        case (ast::expr_cast(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_if(_,_,_,?a)) {\n+        case (ast::expr_if(_,_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_while(_,_,?a)) {\n+        case (ast::expr_while(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_for(_,_,_,?a)) {\n+        case (ast::expr_for(_,_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_for_each(_,_,_,?a)) {\n+        case (ast::expr_for_each(_,_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_do_while(_,_,?a)) {\n+        case (ast::expr_do_while(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_alt(_,_,?a)) {\n+        case (ast::expr_alt(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_block(_,?a)) {\n+        case (ast::expr_block(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_assign(_,_,?a)) {\n+        case (ast::expr_assign(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_assign_op(_,_,_,?a)) {\n+        case (ast::expr_assign_op(_,_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_send(_,_,?a)) {\n+        case (ast::expr_send(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_recv(_,_,?a)) {\n+        case (ast::expr_recv(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_field(_,_,?a)) {\n+        case (ast::expr_field(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_index(_,_,?a)) {\n+        case (ast::expr_index(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_path(_,?a)) {\n+        case (ast::expr_path(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_ext(_,_,_,_,?a)) {\n+        case (ast::expr_ext(_,_,_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_fail(?a)) {\n+        case (ast::expr_fail(?a)) {\n             ret a;\n         }\n-        case (ast.expr_ret(_,?a)) {\n+        case (ast::expr_ret(_,?a)) {\n             ret a; \n         }\n-        case (ast.expr_put(_,?a)) {\n+        case (ast::expr_put(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_be(_,?a)) {\n+        case (ast::expr_be(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_log(_,_,?a)) {\n+        case (ast::expr_log(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_assert(_,?a)) {\n+        case (ast::expr_assert(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_check(_,?a)) {\n+        case (ast::expr_check(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_port(?a)) {\n+        case (ast::expr_port(?a)) {\n             ret a;\n         }\n-        case (ast.expr_chan(_,?a)) {\n+        case (ast::expr_chan(_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_break(?a)) {\n+        case (ast::expr_break(?a)) {\n             ret a;\n         }\n-        case (ast.expr_cont(?a)) {\n+        case (ast::expr_cont(?a)) {\n             ret a;\n         }\n-        case (ast.expr_self_method(_, ?a)) {\n+        case (ast::expr_self_method(_, ?a)) {\n             ret a;\n         }\n     }\n@@ -1766,74 +1768,74 @@ fn expr_ann(&@ast.expr e) -> ast.ann {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(&ctxt cx, &@ast.expr expr) -> t {\n+fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n     ret ann_to_monotype(cx, expr_ann(expr));\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &@ast.expr expr) -> tup(vec[t], t) {\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n     auto a = expr_ann(expr);\n \n     ret tup(ann_to_type_params(a), ann_to_type(a));\n }\n \n-fn expr_has_ty_params(&@ast.expr expr) -> bool {\n+fn expr_has_ty_params(&@ast::expr expr) -> bool {\n     // FIXME: Rewrite using complex patterns when they're trustworthy.\n     alt (expr_ann(expr)) {\n-        case (ast.ann_none(_)) { fail; }\n-        case (ast.ann_type(_, _, ?tps_opt, _)) {\n-            ret !Option.is_none[vec[t]](tps_opt);\n+        case (ast::ann_none(_)) { fail; }\n+        case (ast::ann_type(_, _, ?tps_opt, _)) {\n+            ret !option::is_none[vec[t]](tps_opt);\n         }\n     }\n }\n \n // FIXME: At the moment this works only for call, bind, and path expressions.\n-fn replace_expr_type(&@ast.expr expr,\n-                     &tup(vec[t], t) new_tyt) -> @ast.expr {\n+fn replace_expr_type(&@ast::expr expr,\n+                     &tup(vec[t], t) new_tyt) -> @ast::expr {\n     auto new_tps;\n     if (expr_has_ty_params(expr)) {\n         new_tps = some[vec[t]](new_tyt._0);\n     } else {\n         new_tps = none[vec[t]];\n     }\n \n-    fn mkann_fn(t tyt, Option.t[vec[t]] tps, &ast.ann old_ann) -> ast.ann {\n-        ret ast.ann_type(ast.ann_tag(old_ann), tyt, tps, none[@ts_ann]);\n+    fn mkann_fn(t tyt, option::t[vec[t]] tps, &ast::ann old_ann) -> ast::ann {\n+        ret ast::ann_type(ast::ann_tag(old_ann), tyt, tps, none[@ts_ann]);\n     }\n     auto mkann = bind mkann_fn(new_tyt._1, new_tps, _);\n \n     alt (expr.node) {\n-        case (ast.expr_call(?callee, ?args, ?a)) {\n-            ret @fold.respan(expr.span,\n-                             ast.expr_call(callee, args, mkann(a)));\n+        case (ast::expr_call(?callee, ?args, ?a)) {\n+            ret @fold::respan(expr.span,\n+                             ast::expr_call(callee, args, mkann(a)));\n         }\n-        case (ast.expr_self_method(?ident, ?a)) {\n-            ret @fold.respan(expr.span,\n-                             ast.expr_self_method(ident, mkann(a)));\n+        case (ast::expr_self_method(?ident, ?a)) {\n+            ret @fold::respan(expr.span,\n+                             ast::expr_self_method(ident, mkann(a)));\n         }\n-        case (ast.expr_bind(?callee, ?args, ?a)) {\n-            ret @fold.respan(expr.span,\n-                             ast.expr_bind(callee, args, mkann(a)));\n+        case (ast::expr_bind(?callee, ?args, ?a)) {\n+            ret @fold::respan(expr.span,\n+                             ast::expr_bind(callee, args, mkann(a)));\n         }\n-        case (ast.expr_field(?e, ?i, ?a)) {\n-            ret @fold.respan(expr.span,\n-                             ast.expr_field(e, i, mkann(a)));\n+        case (ast::expr_field(?e, ?i, ?a)) {\n+            ret @fold::respan(expr.span,\n+                             ast::expr_field(e, i, mkann(a)));\n         }\n-        case (ast.expr_path(?p, ?a)) {\n-            ret @fold.respan(expr.span,\n-                             ast.expr_path(p, mkann(a)));\n+        case (ast::expr_path(?p, ?a)) {\n+            ret @fold::respan(expr.span,\n+                             ast::expr_path(p, mkann(a)));\n         }\n         case (_) {\n             log_err \"unhandled expr type in replace_expr_type(): \" +\n-                util.common.expr_to_str(expr);\n+                util::common::expr_to_str(expr);\n             fail;\n         }\n     }\n }\n \n // Expression utilities\n \n-fn field_num(&session.session sess, &span sp,\n-             &ast.ident id) -> uint {\n+fn field_num(&session::session sess, &span sp,\n+             &ast::ident id) -> uint {\n     let uint accum = 0u;\n     let uint i = 0u;\n     for (u8 c in id) {\n@@ -1849,7 +1851,7 @@ fn field_num(&session.session sess, &span sp,\n                 accum += (c as uint) - ('0' as uint);\n             } else {\n                 auto s = \"\";\n-                s += Str.unsafe_from_byte(c);\n+                s += _str::unsafe_from_byte(c);\n                 sess.span_err(sp,\n                               \"bad numeric field on tuple: \"\n                               + \" non-digit character: \"\n@@ -1861,11 +1863,11 @@ fn field_num(&session.session sess, &span sp,\n     ret accum;\n }\n \n-fn field_idx(&session.session sess, &span sp,\n-             &ast.ident id, &vec[field] fields) -> uint {\n+fn field_idx(&session::session sess, &span sp,\n+             &ast::ident id, &vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) {\n-        if (Str.eq(f.ident, id)) {\n+        if (_str::eq(f.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -1874,11 +1876,11 @@ fn field_idx(&session.session sess, &span sp,\n     fail;\n }\n \n-fn method_idx(&session.session sess, &span sp,\n-              &ast.ident id, &vec[method] meths) -> uint {\n+fn method_idx(&session::session sess, &span sp,\n+              &ast::ident id, &vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) {\n-        if (Str.eq(m.ident, id)) {\n+        if (_str::eq(m.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -1889,18 +1891,18 @@ fn method_idx(&session.session sess, &span sp,\n \n fn sort_methods(&vec[method] meths) -> vec[method] {\n     fn method_lteq(&method a, &method b) -> bool {\n-        ret Str.lteq(a.ident, b.ident);\n+        ret _str::lteq(a.ident, b.ident);\n     }\n \n-    ret std.Sort.merge_sort[method](bind method_lteq(_,_), meths);\n+    ret std::sort::merge_sort[method](bind method_lteq(_,_), meths);\n }\n \n-fn is_lval(&@ast.expr expr) -> bool {\n+fn is_lval(&@ast::expr expr) -> bool {\n     alt (expr.node) {\n-        case (ast.expr_field(_,_,_))    { ret true;  }\n-        case (ast.expr_index(_,_,_))    { ret true;  }\n-        case (ast.expr_path(_,_))       { ret true;  }\n-        case (ast.expr_unary(ast.deref,_,_))  { ret true; }\n+        case (ast::expr_field(_,_,_))    { ret true;  }\n+        case (ast::expr_index(_,_,_))    { ret true;  }\n+        case (ast::expr_path(_,_))       { ret true;  }\n+        case (ast::expr_unary(ast::deref,_,_))  { ret true; }\n         case (_)                        { ret false; }\n     }\n }\n@@ -1916,7 +1918,7 @@ mod Unify {\n         ures_err(type_err, t, t);\n     }\n \n-    type ctxt = rec(UFind.ufind sets,\n+    type ctxt = rec(ufind::ufind sets,\n                     hashmap[int,uint] var_ids,\n                     mutable vec[mutable vec[t]] types,\n                     unify_handler handler,\n@@ -1939,18 +1941,18 @@ mod Unify {\n     }\n \n     // Unifies two mutability flags.\n-    fn unify_mut(ast.mutability expected, ast.mutability actual)\n-            -> Option.t[ast.mutability] {\n+    fn unify_mut(ast::mutability expected, ast::mutability actual)\n+            -> option::t[ast::mutability] {\n         if (expected == actual) {\n-            ret some[ast.mutability](expected);\n+            ret some[ast::mutability](expected);\n         }\n-        if (expected == ast.maybe_mut) {\n-            ret some[ast.mutability](actual);\n+        if (expected == ast::maybe_mut) {\n+            ret some[ast::mutability](actual);\n         }\n-        if (actual == ast.maybe_mut) {\n-            ret some[ast.mutability](expected);\n+        if (actual == ast::maybe_mut) {\n+            ret some[ast::mutability](expected);\n         }\n-        ret none[ast.mutability];\n+        ret none[ast::mutability];\n     }\n \n     tag fn_common_res {\n@@ -1964,8 +1966,8 @@ mod Unify {\n                        &vec[arg] expected_inputs, &t expected_output,\n                        &vec[arg] actual_inputs, &t actual_output)\n         -> fn_common_res {\n-        auto expected_len = Vec.len[arg](expected_inputs);\n-        auto actual_len = Vec.len[arg](actual_inputs);\n+        auto expected_len = _vec::len[arg](expected_inputs);\n+        auto actual_len = _vec::len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n             ret fn_common_res_err(ures_err(terr_arg_count,\n                                            expected, actual));\n@@ -2020,8 +2022,8 @@ mod Unify {\n     }\n \n     fn unify_fn(&@ctxt cx,\n-                &ast.proto e_proto,\n-                &ast.proto a_proto,\n+                &ast::proto e_proto,\n+                &ast::proto a_proto,\n                 &t expected,\n                 &t actual,\n                 &vec[arg] expected_inputs, &t expected_output,\n@@ -2046,8 +2048,8 @@ mod Unify {\n     }\n \n     fn unify_native_fn(&@ctxt cx,\n-                       &ast.native_abi e_abi,\n-                       &ast.native_abi a_abi,\n+                       &ast::native_abi e_abi,\n+                       &ast::native_abi a_abi,\n                        &t expected,\n                        &t actual,\n                        &vec[arg] expected_inputs, &t expected_output,\n@@ -2079,8 +2081,8 @@ mod Unify {\n                  &vec[method] actual_meths) -> result {\n       let vec[method] result_meths = vec();\n       let uint i = 0u;\n-      let uint expected_len = Vec.len[method](expected_meths);\n-      let uint actual_len = Vec.len[method](actual_meths);\n+      let uint expected_len = _vec::len[method](expected_meths);\n+      let uint actual_len = _vec::len[method](actual_meths);\n \n       if (expected_len != actual_len) {\n         ret ures_err(terr_meth_count, expected, actual);\n@@ -2089,7 +2091,7 @@ mod Unify {\n       while (i < expected_len) {\n         auto e_meth = expected_meths.(i);\n         auto a_meth = actual_meths.(i);\n-        if (! Str.eq(e_meth.ident, a_meth.ident)) {\n+        if (! _str::eq(e_meth.ident, a_meth.ident)) {\n           ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n                        expected, actual);\n         }\n@@ -2122,7 +2124,7 @@ mod Unify {\n         auto set_num;\n         alt (cx.var_ids.find(id)) {\n         case (none[uint]) {\n-            set_num = UFind.make_set(cx.sets);\n+            set_num = ufind::make_set(cx.sets);\n             cx.var_ids.insert(id, set_num);\n         }\n         case (some[uint](?n)) { set_num = n; }\n@@ -2143,17 +2145,17 @@ mod Unify {\n         alt (struct(cx.tcx, actual)) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n-            case (ty.ty_var(?actual_id)) {\n+            case (ty::ty_var(?actual_id)) {\n                 auto actual_n = get_or_create_set(cx, actual_id);\n                 alt (struct(cx.tcx, expected)) {\n-                    case (ty.ty_var(?expected_id)) {\n+                    case (ty::ty_var(?expected_id)) {\n                         auto expected_n = get_or_create_set(cx, expected_id);\n-                        UFind.union(cx.sets, expected_n, actual_n);\n+                        ufind::union(cx.sets, expected_n, actual_n);\n                     }\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = Vec.len[vec[t]](cx.types);\n+                        auto vlen = _vec::len[vec[t]](cx.types);\n                         if (actual_n < vlen) {\n                             cx.types.(actual_n) += vec(expected);\n                         } else {\n@@ -2164,7 +2166,7 @@ mod Unify {\n                 }\n                 ret ures_ok(actual);\n             }\n-            case (ty.ty_local(?actual_id)) {\n+            case (ty::ty_local(?actual_id)) {\n                 auto result_ty;\n                 alt (cx.handler.resolve_local(actual_id)) {\n                     case (none[t]) { result_ty = expected; }\n@@ -2180,9 +2182,9 @@ mod Unify {\n                 cx.handler.record_local(actual_id, result_ty);\n                 ret ures_ok(result_ty);\n             }\n-            case (ty.ty_bound_param(?actual_id)) {\n+            case (ty::ty_bound_param(?actual_id)) {\n                 alt (struct(cx.tcx, expected)) {\n-                    case (ty.ty_local(_)) {\n+                    case (ty::ty_local(_)) {\n                         log_err \"TODO: bound param unifying with local\";\n                         fail;\n                     }\n@@ -2196,31 +2198,31 @@ mod Unify {\n         }\n \n         alt (struct(cx.tcx, expected)) {\n-            case (ty.ty_nil)        { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_bool)       { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_int)        { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_uint)       { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_machine(_)) { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_float)      { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_char)       { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_str)        { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_type)       { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_native)     { ret struct_cmp(cx, expected, actual); }\n-            case (ty.ty_param(_))   { ret struct_cmp(cx, expected, actual); }\n-\n-            case (ty.ty_tag(?expected_id, ?expected_tps)) {\n+            case (ty::ty_nil)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_bool)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_int)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_uint)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_machine(_)) { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_float)      { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_char)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_str)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_type)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_native)     { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_param(_))   { ret struct_cmp(cx, expected, actual); }\n+\n+            case (ty::ty_tag(?expected_id, ?expected_tps)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_tag(?actual_id, ?actual_tps)) {\n+                    case (ty::ty_tag(?actual_id, ?actual_tps)) {\n                         if (expected_id._0 != actual_id._0 ||\n                                 expected_id._1 != actual_id._1) {\n                             ret ures_err(terr_mismatch, expected, actual);\n                         }\n \n                         // TODO: factor this cruft out, see the TODO in the\n-                        // ty.ty_tup case\n+                        // ty::ty_tup case\n                         let vec[t] result_tps = vec();\n                         auto i = 0u;\n-                        auto expected_len = Vec.len[t](expected_tps);\n+                        auto expected_len = _vec::len[t](expected_tps);\n                         while (i < expected_len) {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n@@ -2231,7 +2233,7 @@ mod Unify {\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    Vec.push[t](result_tps, rty);\n+                                    _vec::push[t](result_tps, rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -2249,16 +2251,16 @@ mod Unify {\n                 ret ures_err(terr_mismatch, expected, actual);\n             }\n \n-            case (ty.ty_box(?expected_mt)) {\n+            case (ty::ty_box(?expected_mt)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_box(?actual_mt)) {\n+                    case (ty::ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none[ast.mutability]) {\n+                            case (none[ast::mutability]) {\n                                 ret ures_err(terr_box_mutability, expected,\n                                              actual);\n                             }\n-                            case (some[ast.mutability](?m)) { mut = m; }\n+                            case (some[ast::mutability](?m)) { mut = m; }\n                         }\n \n                         auto result = unify_step(cx,\n@@ -2281,16 +2283,16 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_vec(?expected_mt)) {\n+            case (ty::ty_vec(?expected_mt)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_vec(?actual_mt)) {\n+                    case (ty::ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none[ast.mutability]) {\n+                            case (none[ast::mutability]) {\n                                 ret ures_err(terr_vec_mutability, expected,\n                                              actual);\n                             }\n-                            case (some[ast.mutability](?m)) { mut = m; }\n+                            case (some[ast::mutability](?m)) { mut = m; }\n                         }\n \n                         auto result = unify_step(cx,\n@@ -2313,9 +2315,9 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_port(?expected_sub)) {\n+            case (ty::ty_port(?expected_sub)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_port(?actual_sub)) {\n+                    case (ty::ty_port(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n                                                  actual_sub);\n@@ -2335,9 +2337,9 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_chan(?expected_sub)) {\n+            case (ty::ty_chan(?expected_sub)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_chan(?actual_sub)) {\n+                    case (ty::ty_chan(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n                                                  actual_sub);\n@@ -2357,11 +2359,11 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_tup(?expected_elems)) {\n+            case (ty::ty_tup(?expected_elems)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_tup(?actual_elems)) {\n-                        auto expected_len = Vec.len[ty.mt](expected_elems);\n-                        auto actual_len = Vec.len[ty.mt](actual_elems);\n+                    case (ty::ty_tup(?actual_elems)) {\n+                        auto expected_len = _vec::len[ty::mt](expected_elems);\n+                        auto actual_len = _vec::len[ty::mt](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -2370,7 +2372,7 @@ mod Unify {\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[ty.mt] result_elems = vec();\n+                        let vec[ty::mt] result_elems = vec();\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n@@ -2379,11 +2381,11 @@ mod Unify {\n                             auto mut;\n                             alt (unify_mut(expected_elem.mut,\n                                            actual_elem.mut)) {\n-                                case (none[ast.mutability]) {\n+                                case (none[ast::mutability]) {\n                                     auto err = terr_tuple_mutability;\n                                     ret ures_err(err, expected, actual);\n                                 }\n-                                case (some[ast.mutability](?m)) { mut = m; }\n+                                case (some[ast::mutability](?m)) { mut = m; }\n                             }\n \n                             auto result = unify_step(cx,\n@@ -2411,11 +2413,11 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_rec(?expected_fields)) {\n+            case (ty::ty_rec(?expected_fields)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_rec(?actual_fields)) {\n-                        auto expected_len = Vec.len[field](expected_fields);\n-                        auto actual_len = Vec.len[field](actual_fields);\n+                    case (ty::ty_rec(?actual_fields)) {\n+                        auto expected_len = _vec::len[field](expected_fields);\n+                        auto actual_len = _vec::len[field](actual_fields);\n                         if (expected_len != actual_len) {\n                             auto err = terr_record_size(expected_len,\n                                                         actual_len);\n@@ -2433,14 +2435,14 @@ mod Unify {\n                             auto mut;\n                             alt (unify_mut(expected_field.mt.mut,\n                                            actual_field.mt.mut)) {\n-                                case (none[ast.mutability]) {\n+                                case (none[ast::mutability]) {\n                                     ret ures_err(terr_record_mutability,\n                                                  expected, actual);\n                                 }\n-                                case (some[ast.mutability](?m)) { mut = m; }\n+                                case (some[ast::mutability](?m)) { mut = m; }\n                             }\n \n-                            if (!Str.eq(expected_field.ident,\n+                            if (!_str::eq(expected_field.ident,\n                                          actual_field.ident)) {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n@@ -2454,7 +2456,7 @@ mod Unify {\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n-                                    Vec.push[field]\n+                                    _vec::push[field]\n                                         (result_fields,\n                                          rec(mt=mt with expected_field));\n                                 }\n@@ -2475,9 +2477,9 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n+            case (ty::ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n+                    case (ty::ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n                         ret unify_fn(cx, ep, ap,\n                                      expected, actual,\n                                      expected_inputs, expected_output,\n@@ -2490,10 +2492,10 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_native_fn(?e_abi, ?expected_inputs,\n+            case (ty::ty_native_fn(?e_abi, ?expected_inputs,\n                                   ?expected_output)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_native_fn(?a_abi, ?actual_inputs,\n+                    case (ty::ty_native_fn(?a_abi, ?actual_inputs,\n                                           ?actual_output)) {\n                         ret unify_native_fn(cx, e_abi, a_abi,\n                                             expected, actual,\n@@ -2506,9 +2508,9 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_obj(?expected_meths)) {\n+            case (ty::ty_obj(?expected_meths)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty.ty_obj(?actual_meths)) {\n+                    case (ty::ty_obj(?actual_meths)) {\n                         ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n                     }\n@@ -2518,10 +2520,10 @@ mod Unify {\n                 }\n             }\n \n-            case (ty.ty_var(?expected_id)) {\n+            case (ty::ty_var(?expected_id)) {\n                 // Add a binding.\n                 auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = Vec.len[vec[t]](cx.types);\n+                auto vlen = _vec::len[vec[t]](cx.types);\n                 if (expected_n < vlen) {\n                     cx.types.(expected_n) += vec(actual);\n                 } else {\n@@ -2531,7 +2533,7 @@ mod Unify {\n                 ret ures_ok(expected);\n             }\n \n-            case (ty.ty_local(?expected_id)) {\n+            case (ty::ty_local(?expected_id)) {\n                 auto result_ty;\n                 alt (cx.handler.resolve_local(expected_id)) {\n                     case (none[t]) { result_ty = actual; }\n@@ -2548,7 +2550,7 @@ mod Unify {\n                 ret ures_ok(result_ty);\n             }\n \n-            case (ty.ty_bound_param(?expected_id)) {\n+            case (ty::ty_bound_param(?expected_id)) {\n                 ret cx.handler.record_param(expected_id, actual);\n             }\n         }\n@@ -2568,7 +2570,7 @@ mod Unify {\n                 case (ty_var(?id)) {\n                     alt (cx.var_ids.find(id)) {\n                         case (some[uint](?n)) {\n-                            auto root = UFind.find(cx.sets, n);\n+                            auto root = ufind::find(cx.sets, n);\n                             ret types.(root);\n                         }\n                         case (none[uint]) { ret typ; }\n@@ -2585,23 +2587,23 @@ mod Unify {\n     fn unify_sets(&@ctxt cx) -> vec[t] {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] set_types = vec(mutable throwaway);\n-        Vec.pop[vec[t]](set_types);   // FIXME: botch\n+        _vec::pop[vec[t]](set_types);   // FIXME: botch\n \n-        for (UFind.node node in cx.sets.nodes) {\n+        for (ufind::node node in cx.sets.nodes) {\n             let vec[t] v = vec();\n             set_types += vec(mutable v);\n         }\n \n         auto i = 0u;\n-        while (i < Vec.len[vec[t]](set_types)) {\n-            auto root = UFind.find(cx.sets, i);\n+        while (i < _vec::len[vec[t]](set_types)) {\n+            auto root = ufind::find(cx.sets, i);\n             set_types.(root) += cx.types.(i);\n             i += 1u;\n         }\n \n         let vec[t] result = vec();\n         for (vec[t] types in set_types) {\n-            if (Vec.len[t](types) > 1u) {\n+            if (_vec::len[t](types) > 1u) {\n                 log_err \"unification of > 1 types in a type set is \" +\n                     \"unimplemented\";\n                 fail;\n@@ -2618,10 +2620,10 @@ mod Unify {\n              &ty_ctxt tcx) -> result {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] types = vec(mutable throwaway);\n-        Vec.pop[vec[t]](types);   // FIXME: botch\n+        _vec::pop[vec[t]](types);   // FIXME: botch\n \n-        auto cx = @rec(sets=UFind.make(),\n-                       var_ids=common.new_int_hash[uint](),\n+        auto cx = @rec(sets=ufind::make(),\n+                       var_ids=common::new_int_hash[uint](),\n                        mutable types=types,\n                        handler=handler,\n                        tcx=tcx);\n@@ -2631,7 +2633,7 @@ mod Unify {\n         case (ures_ok(?typ)) {\n             // Fast path: if there are no local variables, don't perform\n             // substitutions.\n-            if (Vec.len(cx.sets.nodes) == 0u) {\n+            if (_vec::len(cx.sets.nodes) == 0u) {\n                 ret ures_ok(typ);\n             }\n \n@@ -2645,7 +2647,7 @@ mod Unify {\n     }\n }\n \n-fn type_err_to_str(&ty.type_err err) -> str {\n+fn type_err_to_str(&ty::type_err err) -> str {\n     alt (err) {\n         case (terr_mismatch) {\n             ret \"types differ\";\n@@ -2657,16 +2659,16 @@ fn type_err_to_str(&ty.type_err err) -> str {\n             ret \"vectors differ in mutability\";\n         }\n         case (terr_tuple_size(?e_sz, ?a_sz)) {\n-            ret \"expected a tuple with \" + UInt.to_str(e_sz, 10u) +\n-                \" elements but found one with \" + UInt.to_str(a_sz, 10u) +\n+            ret \"expected a tuple with \" + _uint::to_str(e_sz, 10u) +\n+                \" elements but found one with \" + _uint::to_str(a_sz, 10u) +\n                 \" elements\";\n         }\n         case (terr_tuple_mutability) {\n             ret \"tuple elements differ in mutability\";\n         }\n         case (terr_record_size(?e_sz, ?a_sz)) {\n-            ret \"expected a record with \" + UInt.to_str(e_sz, 10u) +\n-                \" fields but found one with \" + UInt.to_str(a_sz, 10u) +\n+            ret \"expected a record with \" + _uint::to_str(e_sz, 10u) +\n+                \" fields but found one with \" + _uint::to_str(a_sz, 10u) +\n                 \" fields\";\n         }\n         case (terr_record_mutability) {\n@@ -2732,31 +2734,31 @@ fn bind_params_in_type(&ctxt cx, &t typ) -> t {\n }\n \n \n-fn def_has_ty_params(&ast.def def) -> bool {\n+fn def_has_ty_params(&ast::def def) -> bool {\n     alt (def) {\n-        case (ast.def_fn(_))            { ret true;  }\n-        case (ast.def_obj(_))           { ret true;  }\n-        case (ast.def_obj_field(_))     { ret false; }\n-        case (ast.def_mod(_))           { ret false; }\n-        case (ast.def_const(_))         { ret false; }\n-        case (ast.def_arg(_))           { ret false; }\n-        case (ast.def_local(_))         { ret false; }\n-        case (ast.def_variant(_, _))    { ret true;  }\n-        case (ast.def_ty(_))            { ret false; }\n-        case (ast.def_ty_arg(_))        { ret false; }\n-        case (ast.def_binding(_))       { ret false; }\n-        case (ast.def_use(_))           { ret false; }\n-        case (ast.def_native_ty(_))     { ret false; }\n-        case (ast.def_native_fn(_))     { ret true;  }\n+        case (ast::def_fn(_))            { ret true;  }\n+        case (ast::def_obj(_))           { ret true;  }\n+        case (ast::def_obj_field(_))     { ret false; }\n+        case (ast::def_mod(_))           { ret false; }\n+        case (ast::def_const(_))         { ret false; }\n+        case (ast::def_arg(_))           { ret false; }\n+        case (ast::def_local(_))         { ret false; }\n+        case (ast::def_variant(_, _))    { ret true;  }\n+        case (ast::def_ty(_))            { ret false; }\n+        case (ast::def_ty_arg(_))        { ret false; }\n+        case (ast::def_binding(_))       { ret false; }\n+        case (ast::def_use(_))           { ret false; }\n+        case (ast::def_native_ty(_))     { ret false; }\n+        case (ast::def_native_fn(_))     { ret true;  }\n     }\n }\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-fn lookup_item_type(session.session sess,\n+fn lookup_item_type(session::session sess,\n                     ctxt cx,\n                     &type_cache cache,\n-                    ast.def_id did) -> ty_param_count_and_ty {\n+                    ast::def_id did) -> ty_param_count_and_ty {\n     if (did._0 == sess.get_targ_crate_num()) {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n@@ -2766,7 +2768,7 @@ fn lookup_item_type(session.session sess,\n     alt (cache.find(did)) {\n         case (some[ty_param_count_and_ty](?tpt)) { ret tpt; }\n         case (none[ty_param_count_and_ty]) {\n-            auto tyt = creader.get_type(sess, cx, did);\n+            auto tyt = creader::get_type(sess, cx, did);\n             cache.insert(did, tyt);\n             ret tyt;\n         }"}, {"sha": "fb7634a2306f16563316b49204e25949656f40e3", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1014, "deletions": 1003, "changes": 2017, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2"}, {"sha": "2d46309adbcdd1101ac3878e7d72fffcc8b6f061", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 363, "deletions": 362, "changes": 725, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,214 +1,214 @@\n-import front.ast;\n-import front.ast.ann;\n-import front.ast.method;\n-import front.ast.ty;\n-import front.ast.mutability;\n-import front.ast.item;\n-import front.ast.block;\n-import front.ast.block_;\n-import front.ast.obj_field;\n-import front.ast.decl;\n-import front.ast.arm;\n-import front.ast.stmt;\n-import front.ast.stmt_;\n-import front.ast.stmt_decl;\n-import front.ast.stmt_expr;\n-import front.ast.stmt_crate_directive;\n-import front.ast.decl_local;\n-import front.ast.decl_item;\n-import front.ast.ident;\n-import front.ast.def_id;\n-import front.ast.ann;\n-import front.ast.field;\n-import front.ast.expr;\n-import front.ast.expr_call;\n-import front.ast.expr_vec;\n-import front.ast.expr_tup;\n-import front.ast.expr_path;\n-import front.ast.expr_field;\n-import front.ast.expr_index;\n-import front.ast.expr_log;\n-import front.ast.expr_block;\n-import front.ast.expr_rec;\n-import front.ast.expr_if;\n-import front.ast.expr_binary;\n-import front.ast.expr_unary;\n-import front.ast.expr_assign;\n-import front.ast.expr_assign_op;\n-import front.ast.expr_while;\n-import front.ast.expr_do_while;\n-import front.ast.expr_alt;\n-import front.ast.expr_lit;\n-import front.ast.expr_ret;\n-import front.ast.expr_self_method;\n-import front.ast.expr_bind;\n-import front.ast.expr_spawn;\n-import front.ast.expr_ext;\n-import front.ast.expr_fail;\n-import front.ast.expr_break;\n-import front.ast.expr_cont;\n-import front.ast.expr_send;\n-import front.ast.expr_recv;\n-import front.ast.expr_put;\n-import front.ast.expr_port;\n-import front.ast.expr_chan;\n-import front.ast.expr_be;\n-import front.ast.expr_check;\n-import front.ast.expr_assert;\n-import front.ast.expr_cast;\n-import front.ast.expr_for;\n-import front.ast.expr_for_each;\n-import front.ast.path;\n-import front.ast.elt;\n-import front.ast.crate_directive;\n-import front.ast.fn_decl;\n-import front.ast._obj;\n-import front.ast.native_mod;\n-import front.ast.variant;\n-import front.ast.ty_param;\n-import front.ast.ty;\n-import front.ast.proto;\n-import front.ast.pat;\n-import front.ast.binop;\n-import front.ast.unop;\n-import front.ast.def;\n-import front.ast.lit;\n-import front.ast.init_op;\n-import front.ast.initializer;\n-import front.ast.local;\n-import front.ast._fn;\n-import front.ast.ann_none;\n-import front.ast.ann_type;\n-import front.ast._obj;\n-import front.ast._mod;\n-import front.ast.crate;\n-import front.ast.item_fn;\n-import front.ast.item_obj;\n-import front.ast.def_local;\n-\n-import middle.fold;\n-import middle.fold.respan;\n-import driver.session;\n-import util.common;\n-import util.common.span;\n-import util.common.spanned;\n-import util.common.new_str_hash;\n-import util.common.new_def_hash;\n-import util.common.uistr;\n-import util.common.elt_exprs;\n-import util.common.field_exprs;\n-import util.common.log_expr;\n-import util.common.log_expr_err;\n-import util.common.log_stmt;\n-import util.common.log_block;\n-import util.common.log_stmt_err;\n-import util.common.log_fn_err;\n-import util.common.log_fn;\n-import util.common.log_block_err;\n-import util.common.has_nonlocal_exits;\n-import util.common.decl_lhs;\n-import util.typestate_ann;\n-import util.typestate_ann.ts_ann;\n-import util.typestate_ann.empty_pre_post;\n-import util.typestate_ann.empty_poststate;\n-import util.typestate_ann.true_precond;\n-import util.typestate_ann.true_postcond;\n-import util.typestate_ann.false_postcond;\n-import util.typestate_ann.postcond;\n-import util.typestate_ann.precond;\n-import util.typestate_ann.poststate;\n-import util.typestate_ann.prestate;\n-import util.typestate_ann.pre_and_post;\n-import util.typestate_ann.get_pre;\n-import util.typestate_ann.get_post;\n-import util.typestate_ann.ann_precond;\n-import util.typestate_ann.ann_prestate;\n-import util.typestate_ann.set_precondition;\n-import util.typestate_ann.set_postcondition;\n-import util.typestate_ann.set_prestate;\n-import util.typestate_ann.set_poststate;\n-import util.typestate_ann.set_in_postcond;\n-import util.typestate_ann.set_in_poststate;\n-import util.typestate_ann.implies;\n-import util.typestate_ann.pre_and_post_state;\n-import util.typestate_ann.empty_states;\n-import util.typestate_ann.empty_prestate;\n-import util.typestate_ann.empty_ann;\n-import util.typestate_ann.extend_prestate;\n-import util.typestate_ann.extend_poststate;\n-import util.typestate_ann.relax_prestate;\n-import util.typestate_ann.intersect;\n-import util.typestate_ann.pp_clone;\n-import util.typestate_ann.clone;\n-\n-import middle.ty;\n-import middle.ty.ann_to_type;\n-import middle.ty.arg;\n-import middle.ty.expr_ann;\n-import middle.ty.ty_to_str;\n-\n-import pretty.pprust.print_block;\n-import pretty.pprust.print_expr;\n-import pretty.pprust.print_decl;\n-import pretty.pp.mkstate;\n-import std.IO.stdout;\n-import std.IO.str_writer;\n-import std.IO.string_writer;\n-import std.Vec.map;\n-import std.Vec;\n-import std.Vec.len;\n-import std.Vec.pop;\n-import std.Vec.push;\n-import std.Vec.slice;\n-import std.Vec.unzip;\n-import std.Vec.plus_option;\n-import std.Vec.cat_options;\n-import std.Option;\n-import std.Option.t;\n-import std.Option.some;\n-import std.Option.none;\n-import std.Option.from_maybe;\n-import std.Option.maybe;\n-import std.Option.is_none;\n-import std.Option.get;\n-import std.Map.hashmap;\n-import std.List;\n-import std.List.list;\n-import std.List.cons;\n-import std.List.nil;\n-import std.List.foldl;\n-import std.List.find;\n-import std.UInt;\n-import std.BitV;\n-import std.Util.fst;\n-import std.Util.snd;\n-\n-import util.typestate_ann;\n-import util.typestate_ann.difference;\n-import util.typestate_ann.union;\n-import util.typestate_ann.pps_len;\n-import util.typestate_ann.require_and_preserve;\n-\n-import resolve.def_map;\n+import front::ast;\n+import front::ast::ann;\n+import front::ast::method;\n+import front::ast::ty;\n+import front::ast::mutability;\n+import front::ast::item;\n+import front::ast::block;\n+import front::ast::block_;\n+import front::ast::obj_field;\n+import front::ast::decl;\n+import front::ast::arm;\n+import front::ast::stmt;\n+import front::ast::stmt_;\n+import front::ast::stmt_decl;\n+import front::ast::stmt_expr;\n+import front::ast::stmt_crate_directive;\n+import front::ast::decl_local;\n+import front::ast::decl_item;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::field;\n+import front::ast::expr;\n+import front::ast::expr_call;\n+import front::ast::expr_vec;\n+import front::ast::expr_tup;\n+import front::ast::expr_path;\n+import front::ast::expr_field;\n+import front::ast::expr_index;\n+import front::ast::expr_log;\n+import front::ast::expr_block;\n+import front::ast::expr_rec;\n+import front::ast::expr_if;\n+import front::ast::expr_binary;\n+import front::ast::expr_unary;\n+import front::ast::expr_assign;\n+import front::ast::expr_assign_op;\n+import front::ast::expr_while;\n+import front::ast::expr_do_while;\n+import front::ast::expr_alt;\n+import front::ast::expr_lit;\n+import front::ast::expr_ret;\n+import front::ast::expr_self_method;\n+import front::ast::expr_bind;\n+import front::ast::expr_spawn;\n+import front::ast::expr_ext;\n+import front::ast::expr_fail;\n+import front::ast::expr_break;\n+import front::ast::expr_cont;\n+import front::ast::expr_send;\n+import front::ast::expr_recv;\n+import front::ast::expr_put;\n+import front::ast::expr_port;\n+import front::ast::expr_chan;\n+import front::ast::expr_be;\n+import front::ast::expr_check;\n+import front::ast::expr_assert;\n+import front::ast::expr_cast;\n+import front::ast::expr_for;\n+import front::ast::expr_for_each;\n+import front::ast::path;\n+import front::ast::elt;\n+import front::ast::crate_directive;\n+import front::ast::fn_decl;\n+import front::ast::_obj;\n+import front::ast::native_mod;\n+import front::ast::variant;\n+import front::ast::ty_param;\n+import front::ast::ty;\n+import front::ast::proto;\n+import front::ast::pat;\n+import front::ast::binop;\n+import front::ast::unop;\n+import front::ast::def;\n+import front::ast::lit;\n+import front::ast::init_op;\n+import front::ast::initializer;\n+import front::ast::local;\n+import front::ast::_fn;\n+import front::ast::ann_none;\n+import front::ast::ann_type;\n+import front::ast::_obj;\n+import front::ast::_mod;\n+import front::ast::crate;\n+import front::ast::item_fn;\n+import front::ast::item_obj;\n+import front::ast::def_local;\n+\n+import middle::fold;\n+import middle::fold::respan;\n+import driver::session;\n+import util::common;\n+import util::common::span;\n+import util::common::spanned;\n+import util::common::new_str_hash;\n+import util::common::new_def_hash;\n+import util::common::uistr;\n+import util::common::elt_exprs;\n+import util::common::field_exprs;\n+import util::common::log_expr;\n+import util::common::log_expr_err;\n+import util::common::log_stmt;\n+import util::common::log_block;\n+import util::common::log_stmt_err;\n+import util::common::log_fn_err;\n+import util::common::log_fn;\n+import util::common::log_block_err;\n+import util::common::has_nonlocal_exits;\n+import util::common::decl_lhs;\n+import util::typestate_ann;\n+import util::typestate_ann::ts_ann;\n+import util::typestate_ann::empty_pre_post;\n+import util::typestate_ann::empty_poststate;\n+import util::typestate_ann::true_precond;\n+import util::typestate_ann::true_postcond;\n+import util::typestate_ann::false_postcond;\n+import util::typestate_ann::postcond;\n+import util::typestate_ann::precond;\n+import util::typestate_ann::poststate;\n+import util::typestate_ann::prestate;\n+import util::typestate_ann::pre_and_post;\n+import util::typestate_ann::get_pre;\n+import util::typestate_ann::get_post;\n+import util::typestate_ann::ann_precond;\n+import util::typestate_ann::ann_prestate;\n+import util::typestate_ann::set_precondition;\n+import util::typestate_ann::set_postcondition;\n+import util::typestate_ann::set_prestate;\n+import util::typestate_ann::set_poststate;\n+import util::typestate_ann::set_in_postcond;\n+import util::typestate_ann::set_in_poststate;\n+import util::typestate_ann::implies;\n+import util::typestate_ann::pre_and_post_state;\n+import util::typestate_ann::empty_states;\n+import util::typestate_ann::empty_prestate;\n+import util::typestate_ann::empty_ann;\n+import util::typestate_ann::extend_prestate;\n+import util::typestate_ann::extend_poststate;\n+import util::typestate_ann::relax_prestate;\n+import util::typestate_ann::intersect;\n+import util::typestate_ann::pp_clone;\n+import util::typestate_ann::clone;\n+\n+import middle::ty;\n+import middle::ty::ann_to_type;\n+import middle::ty::arg;\n+import middle::ty::expr_ann;\n+import middle::ty::ty_to_str;\n+\n+import pretty::pprust::print_block;\n+import pretty::pprust::print_expr;\n+import pretty::pprust::print_decl;\n+import pretty::pp::mkstate;\n+import std::io::stdout;\n+import std::io::str_writer;\n+import std::io::string_writer;\n+import std::_vec::map;\n+import std::_vec;\n+import std::_vec::len;\n+import std::_vec::pop;\n+import std::_vec::push;\n+import std::_vec::slice;\n+import std::_vec::unzip;\n+import std::_vec::plus_option;\n+import std::_vec::cat_options;\n+import std::option;\n+import std::option::t;\n+import std::option::some;\n+import std::option::none;\n+import std::option::from_maybe;\n+import std::option::maybe;\n+import std::option::is_none;\n+import std::option::get;\n+import std::map::hashmap;\n+import std::list;\n+import std::list::list;\n+import std::list::cons;\n+import std::list::nil;\n+import std::list::foldl;\n+import std::list::find;\n+import std::_uint;\n+import std::bitv;\n+import std::util::fst;\n+import std::util::snd;\n+\n+import util::typestate_ann;\n+import util::typestate_ann::difference;\n+import util::typestate_ann::union;\n+import util::typestate_ann::pps_len;\n+import util::typestate_ann::require_and_preserve;\n+\n+import resolve::def_map;\n \n /**** debugging junk  ****/\n \n-fn bitv_to_str(fn_info enclosing, BitV.t v) -> str {\n+fn bitv_to_str(fn_info enclosing, bitv::t v) -> str {\n   auto s = \"\";\n \n   for each (@tup(def_id, tup(uint, ident)) p in enclosing.items()) {\n-    if (BitV.get(v, p._1._0)) {\n+    if (bitv::get(v, p._1._0)) {\n       s += \" \" + p._1._1 + \" \";\n     }\n   }\n   ret s;\n }\n \n-fn log_bitv(fn_info enclosing, BitV.t v) {\n+fn log_bitv(fn_info enclosing, bitv::t v) {\n     log(bitv_to_str(enclosing, v));\n }\n \n-fn log_bitv_err(fn_info enclosing, BitV.t v) {\n+fn log_bitv_err(fn_info enclosing, bitv::t v) {\n     log_err(bitv_to_str(enclosing, v));\n }\n \n@@ -233,35 +233,35 @@ fn log_cond_err(vec[uint] v) -> () {\n }\n \n fn log_pp(&pre_and_post pp) -> () {\n-  auto p1 = BitV.to_vec(pp.precondition);\n-  auto p2 = BitV.to_vec(pp.postcondition);\n+  auto p1 = bitv::to_vec(pp.precondition);\n+  auto p2 = bitv::to_vec(pp.postcondition);\n   log(\"pre:\");\n   log_cond(p1);\n   log(\"post:\");\n   log_cond(p2);\n }\n \n fn log_pp_err(&pre_and_post pp) -> () {\n-  auto p1 = BitV.to_vec(pp.precondition);\n-  auto p2 = BitV.to_vec(pp.postcondition);\n+  auto p1 = bitv::to_vec(pp.precondition);\n+  auto p2 = bitv::to_vec(pp.postcondition);\n   log_err(\"pre:\");\n   log_cond_err(p1);\n   log_err(\"post:\");\n   log_cond_err(p2);\n }\n \n fn log_states(&pre_and_post_state pp) -> () {\n-  auto p1 = BitV.to_vec(pp.prestate);\n-  auto p2 = BitV.to_vec(pp.poststate);\n+  auto p1 = bitv::to_vec(pp.prestate);\n+  auto p2 = bitv::to_vec(pp.poststate);\n   log(\"prestate:\");\n   log_cond(p1);\n   log(\"poststate:\");\n   log_cond(p2);\n }\n \n fn log_states_err(&pre_and_post_state pp) -> () {\n-  auto p1 = BitV.to_vec(pp.prestate);\n-  auto p2 = BitV.to_vec(pp.poststate);\n+  auto p1 = bitv::to_vec(pp.prestate);\n+  auto p2 = bitv::to_vec(pp.poststate);\n   log_err(\"prestate:\");\n   log_cond_err(p1);\n   log_err(\"poststate:\");\n@@ -286,9 +286,9 @@ fn print_idents(vec[ident] idents) -> () {\n    variable in a given function) to bit number \n    (also remembers the ident for error-logging purposes) */\n type var_info     = tup(uint, ident);\n-type fn_info      = std.Map.hashmap[def_id, var_info];\n+type fn_info      = std::map::hashmap[def_id, var_info];\n /* mapping from function name to fn_info map */\n-type fn_info_map = std.Map.hashmap[def_id, fn_info];\n+type fn_info_map = std::map::hashmap[def_id, fn_info];\n  \n fn bit_num(def_id v, fn_info m) -> uint {\n   assert (m.contains_key(v));\n@@ -307,25 +307,25 @@ fn num_locals(fn_info m) -> uint {\n   ret m.size();\n }\n \n-fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@ast.local loc)\n+fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@ast::local loc)\n     -> @decl {\n     log(\"collect_local: pushing \" + loc.ident);\n-    Vec.push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+    _vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n     ret @respan(sp, decl_local(loc));\n }\n \n fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n-  auto res = @Vec.alloc[tup(ident,def_id)](0u);\n+  auto res = @_vec::alloc[tup(ident,def_id)](0u);\n \n-  auto fld = fold.new_identity_fold[@vec[tup(ident, def_id)]]();\n+  auto fld = fold::new_identity_fold[@vec[tup(ident, def_id)]]();\n   fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n-  auto ignore = fold.fold_fn[@vec[tup(ident, def_id)]](res, fld, f);\n+  auto ignore = fold::fold_fn[@vec[tup(ident, def_id)]](res, fld, f);\n \n   ret res;\n }\n \n fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n-    log(nm + \" |-> \" + util.common.uistr(next));\n+    log(nm + \" |-> \" + util::common::uistr(next));\n   tbl.insert(v, tup(next,nm));\n   ret (next + 1u);\n }\n@@ -335,13 +335,13 @@ fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n fn mk_fn_info(_fn f) -> fn_info {\n   auto res = new_def_hash[var_info]();\n   let uint next = 0u;\n-  let vec[ast.arg] f_args = f.decl.inputs;\n+  let vec[ast::arg] f_args = f.decl.inputs;\n \n   /* ignore args, which we know are initialized;\n      just collect locally declared vars */\n \n   let @vec[tup(ident,def_id)] locals = find_locals(f);\n-  log(uistr(Vec.len[tup(ident, def_id)](*locals)) + \" locals\");\n+  log(uistr(_vec::len[tup(ident, def_id)](*locals)) + \" locals\");\n   for (tup(ident,def_id) p in *locals) {\n     next = add_var(p._1, p._0, next, res);\n   }\n@@ -351,19 +351,19 @@ fn mk_fn_info(_fn f) -> fn_info {\n \n /* extends mk_fn_info to a function item, side-effecting the map fi from\n    function IDs to fn_info maps */\n-fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, &ident i, &ast._fn f,\n-                 &vec[ast.ty_param] ty_params, &def_id id, &ann a) -> @item {\n+fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, &ident i, &ast::_fn f,\n+                 &vec[ast::ty_param] ty_params, &def_id id, &ann a) -> @item {\n   fi.insert(id, mk_fn_info(f));\n   log(i + \" has \" + uistr(num_locals(mk_fn_info(f))) + \" local vars\");\n   ret @respan(sp, item_fn(i, f, ty_params, id, a));\n }\n \n /* extends mk_fn_info to an obj item, side-effecting the map fi from\n    function IDs to fn_info maps */\n-fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, &ident i, &ast._obj o,\n-                       &vec[ast.ty_param] ty_params,\n-                       &ast.obj_def_ids odid, &ann a) -> @item {\n-    auto all_methods = Vec.clone[@method](o.methods);\n+fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, &ident i, &ast::_obj o,\n+                       &vec[ast::ty_param] ty_params,\n+                       &ast::obj_def_ids odid, &ann a) -> @item {\n+    auto all_methods = _vec::clone[@method](o.methods);\n     plus_option[@method](all_methods, o.dtor);\n     for (@method m in all_methods) {\n         fi.insert(m.node.id, mk_fn_info(m.node.meth));\n@@ -376,14 +376,14 @@ fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, &ident i, &ast._obj o,\n /* initializes the global fn_info_map (mapping each function ID, including\n    nested locally defined functions, onto a mapping from local variable name\n    to bit number) */\n-fn mk_f_to_fn_info(@ast.crate c) -> fn_info_map {\n+fn mk_f_to_fn_info(@ast::crate c) -> fn_info_map {\n   auto res = new_def_hash[fn_info]();\n \n-  auto fld = fold.new_identity_fold[fn_info_map]();\n+  auto fld = fold::new_identity_fold[fn_info_map]();\n   fld = @rec(fold_item_fn  = bind mk_fn_info_item_fn(_,_,_,_,_,_,_),\n              fold_item_obj = bind mk_fn_info_item_obj(_,_,_,_,_,_,_)\n                with *fld);\n-  fold.fold_crate[fn_info_map](res, fld, c);\n+  fold::fold_crate[fn_info_map](res, fld, c);\n \n   ret res;\n }\n@@ -402,7 +402,7 @@ fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n   }\n }\n \n-fn ann_to_ts_ann_fail(ann a) -> Option.t[@ts_ann] {\n+fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] {\n   alt (a) {\n       case (ann_none(_)) { \n           log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n@@ -431,7 +431,7 @@ fn ann_to_poststate(ann a) -> poststate {\n     ret (ann_to_ts_ann_fail_more(a)).states.poststate;\n }\n \n-fn stmt_to_ann(&stmt s) -> Option.t[@ts_ann] {\n+fn stmt_to_ann(&stmt s) -> option::t[@ts_ann] {\n   alt (s.node) {\n     case (stmt_decl(_,?a)) {\n         ret ann_to_ts_ann_fail(a);\n@@ -651,7 +651,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n /* works on either postconds or preconds\n  should probably rethink the whole type synonym situation */\n fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = Vec.len[postcond](rest);\n+  auto sz = _vec::len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -664,7 +664,7 @@ fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n \n fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n   if (len[postcond](pcs) > 0u) {\n-      ret union_postconds_go(BitV.clone(pcs.(0)), pcs);\n+      ret union_postconds_go(bitv::clone(pcs.(0)), pcs);\n   }\n   else {\n       ret empty_prestate(nv);\n@@ -673,7 +673,7 @@ fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n \n /* Gee, maybe we could use foldl or something */\n fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = Vec.len[postcond](rest);\n+  auto sz = _vec::len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -688,7 +688,7 @@ fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n   assert (len[postcond](pcs) > 0u);\n \n-  ret intersect_postconds_go(BitV.clone(pcs.(0)), pcs);\n+  ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n }\n \n /******* AST-traversing code ********/\n@@ -719,8 +719,8 @@ fn find_pre_post_obj(&def_map dm, &fn_info_map fm, _obj o) -> () {\n         find_pre_post_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(dm, fm, _);\n-    Vec.map[@method, ()](f, o.methods);\n-    Option.map[@method, ()](f, o.dtor);\n+    _vec::map[@method, ()](f, o.methods);\n+    option::map[@method, ()](f, o.dtor);\n }\n \n fn find_pre_post_state_obj(&def_map dm, &fn_info_map fm, _obj o) -> bool {\n@@ -729,35 +729,35 @@ fn find_pre_post_state_obj(&def_map dm, &fn_info_map fm, _obj o) -> bool {\n         ret find_pre_post_state_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(dm, fm, _);\n-    auto flags = Vec.map[@method, bool](f, o.methods);\n-    auto changed = Vec.or(flags);\n+    auto flags = _vec::map[@method, bool](f, o.methods);\n+    auto changed = _vec::or(flags);\n     changed = changed || maybe[@method, bool](false, f, o.dtor);\n     ret changed;\n }\n \n fn find_pre_post_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                       &item i) -> () {\n   alt (i.node) {\n-    case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n+    case (ast::item_const(?id, ?t, ?e, ?di, ?a)) {\n         find_pre_post_expr(dm, fm, enclosing, e);\n     }\n-    case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n+    case (ast::item_fn(?id, ?f, ?ps, ?di, ?a)) {\n       assert (fm.contains_key(di));\n       find_pre_post_fn(dm, fm, fm.get(di), f);\n     }\n-    case (ast.item_mod(?id, ?m, ?di)) {\n+    case (ast::item_mod(?id, ?m, ?di)) {\n       find_pre_post_mod(m);\n     }\n-    case (ast.item_native_mod(?id, ?nm, ?di)) {\n+    case (ast::item_native_mod(?id, ?nm, ?di)) {\n       find_pre_post_native_mod(nm);\n     }\n-    case (ast.item_ty(_,_,_,_,_)) {\n+    case (ast::item_ty(_,_,_,_,_)) {\n       ret;\n     }\n-    case (ast.item_tag(_,_,_,_,_)) {\n+    case (ast::item_tag(_,_,_,_,_)) {\n       ret;\n     }\n-    case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n+    case (ast::item_obj(?id, ?o, ?ps, ?di, ?a)) {\n         find_pre_post_obj(dm, fm, o);\n     }\n   }\n@@ -777,19 +777,19 @@ fn find_pre_post_exprs(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     }\n     auto f = bind do_one(dm, fm, enclosing, _);\n \n-    Vec.map[@expr, ()](f, args);\n+    _vec::map[@expr, ()](f, args);\n \n     fn get_pp(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n     auto g = get_pp;\n-    auto pps = Vec.map[@expr, pre_and_post](g, args);\n+    auto pps = _vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n \n     set_pre_and_post(a,\n        rec(precondition=seq_preconds(enclosing, pps),\n            postcondition=union_postconds\n-           (nv, (Vec.map[pre_and_post, postcond](h, pps)))));\n+           (nv, (_vec::map[pre_and_post, postcond](h, pps)))));\n }\n \n fn find_pre_post_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n@@ -816,13 +816,13 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n-            auto args = Vec.clone[@expr](operands);\n-            Vec.push[@expr](args, operator);\n+            auto args = _vec::clone[@expr](operands);\n+            _vec::push[@expr](args, operator);\n             find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-            auto args = Vec.clone[@expr](operands);\n-            Vec.push[@expr](args, operator);\n+            auto args = _vec::clone[@expr](operands);\n+            _vec::push[@expr](args, operator);\n             find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_vec(?args, _, ?a)) {\n@@ -834,7 +834,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         case (expr_path(?p, ?a)) {\n             auto res = empty_pre_post(num_local_vars);\n \n-            alt (dm.get(ast.ann_tag(a))) {\n+            alt (dm.get(ast::ann_tag(a))) {\n                 case (def_local(?d_id)) {\n                     auto i = bit_num(d_id, enclosing);\n                     require_and_preserve(i, res);\n@@ -875,13 +875,13 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n             auto es = field_exprs(fields);\n-            Vec.plus_option[@expr](es, maybe_base);\n+            _vec::plus_option[@expr](es, maybe_base);\n             find_pre_post_exprs(dm, fm, enclosing, es, a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                    alt (dm.get(ast.ann_tag(a_lhs))) {\n+                    alt (dm.get(ast::ann_tag(a_lhs))) {\n                         case (def_local(?d_id)) {\n                             find_pre_post_expr(dm, fm, enclosing, rhs);\n                             set_pre_and_post(a, expr_pp(rhs));\n@@ -902,7 +902,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                    alt (dm.get(ast.ann_tag(a_lhs))) {\n+                    alt (dm.get(ast::ann_tag(a_lhs))) {\n                         case (def_local(?d_id)) {\n                             find_pre_post_expr(dm, fm, enclosing, rhs);\n                             set_pre_and_post(a, expr_pp(rhs));\n@@ -1048,7 +1048,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                 ret block_pp(an_alt.block);\n             }\n             auto f = bind do_an_alt(dm, fm, enclosing, _);\n-            auto alt_pps = Vec.map[arm, pre_and_post](f, alts);\n+            auto alt_pps = _vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n                           fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n@@ -1062,7 +1062,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, enclosing, _, _);\n \n-            auto alts_overall_pp = Vec.foldl[pre_and_post, pre_and_post]\n+            auto alts_overall_pp = _vec::foldl[pre_and_post, pre_and_post]\n                                     (g, e_pp, alt_pps);\n \n             set_pre_and_post(a, alts_overall_pp);\n@@ -1088,8 +1088,8 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             set_pre_and_post(a, expr_pp(p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n-            auto args = Vec.cat_options[@expr](maybe_args);\n-            Vec.push[@expr](args, operator); /* ??? order of eval? */\n+            auto args = _vec::cat_options[@expr](maybe_args);\n+            _vec::push[@expr](args, operator); /* ??? order of eval? */\n             find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_break(?a)) {\n@@ -1131,17 +1131,17 @@ fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n }\n \n fn find_pre_post_stmt(&def_map dm, fn_info_map fm, &fn_info enclosing,\n-                      &ast.stmt s) -> () {\n+                      &ast::stmt s) -> () {\n     log(\"stmt =\");\n     log_stmt(s);\n \n   auto num_local_vars = num_locals(enclosing);\n   alt(s.node) {\n-    case(ast.stmt_decl(?adecl, ?a)) {\n+    case(ast::stmt_decl(?adecl, ?a)) {\n         alt(adecl.node) {\n-            case(ast.decl_local(?alocal)) {\n+            case(ast::decl_local(?alocal)) {\n                 alt(alocal.init) {\n-                    case(some[ast.initializer](?an_init)) {\n+                    case(some[ast::initializer](?an_init)) {\n                         find_pre_post_expr(dm, fm, enclosing, an_init.expr);\n                         auto rhs_pp = expr_pp(an_init.expr);\n                         set_pre_and_post(alocal.ann, rhs_pp);\n@@ -1157,7 +1157,7 @@ fn find_pre_post_stmt(&def_map dm, fn_info_map fm, &fn_info enclosing,\n                         log_err(\"pp = \");\n                         log_pp(stmt_pp(s)); */\n                     }\n-                    case(none[ast.initializer]) {\n+                    case(none[ast::initializer]) {\n                         auto pp = empty_pre_post(num_local_vars);\n                         set_pre_and_post(alocal.ann, pp);\n                         set_pre_and_post(a, pp);\n@@ -1207,33 +1207,33 @@ fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     }\n     auto do_one = bind do_one_(dm, fm, enclosing, _);\n     \n-    Vec.map[@stmt, ()](do_one, b.node.stmts);\n+    _vec::map[@stmt, ()](do_one, b.node.stmts);\n     fn do_inner_(def_map dm, fn_info_map fm, fn_info i, &@expr e) -> () {\n         find_pre_post_expr(dm, fm, i, e);\n     }\n     auto do_inner = bind do_inner_(dm, fm, enclosing, _);\n-    Option.map[@expr, ()](do_inner, b.node.expr);\n+    option::map[@expr, ()](do_inner, b.node.expr);\n \n     let vec[pre_and_post] pps = vec();\n \n     fn get_pp_stmt(&@stmt s) -> pre_and_post {\n         ret stmt_pp(*s);\n     }\n     auto f = get_pp_stmt;\n-    pps += Vec.map[@stmt, pre_and_post](f, b.node.stmts);\n+    pps += _vec::map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n     auto g = get_pp_expr;\n     plus_option[pre_and_post](pps,\n-       Option.map[@expr, pre_and_post](g, b.node.expr));\n+       option::map[@expr, pre_and_post](g, b.node.expr));\n \n     auto block_precond  = seq_preconds(enclosing, pps);\n     auto h = get_post;\n-    auto postconds =  Vec.map[pre_and_post, postcond](h, pps);\n+    auto postconds =  _vec::map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    Vec.push[postcond](postconds, block_precond);\n+    _vec::push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n     if (! has_nonlocal_exits(b)) {\n@@ -1248,8 +1248,8 @@ fn find_pre_post_fn(&def_map dm, &fn_info_map fm, &fn_info fi, &_fn f) -> () {\n     find_pre_post_block(dm, fm, fi, f.body);\n }\n \n-fn check_item_fn(&def_map dm, &fn_info_map fm, &span sp, &ident i, &ast._fn f,\n-                 &vec[ast.ty_param] ty_params,\n+fn check_item_fn(&def_map dm, &fn_info_map fm, &span sp, &ident i,\n+                 &ast::_fn f, &vec[ast::ty_param] ty_params,\n                  &def_id id, &ann a) -> @item {\n \n     log(\"check_item_fn:\");\n@@ -1258,33 +1258,33 @@ fn check_item_fn(&def_map dm, &fn_info_map fm, &span sp, &ident i, &ast._fn f,\n   assert (fm.contains_key(id));\n   find_pre_post_fn(dm, fm, fm.get(id), f);\n \n-  ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n+  ret @respan(sp, ast::item_fn(i, f, ty_params, id, a));\n }\n \n fn find_pre_post_state_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                             @item i) -> bool {\n  alt (i.node) {\n-    case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n+    case (ast::item_const(?id, ?t, ?e, ?di, ?a)) {\n         ret find_pre_post_state_expr(dm, fm, enclosing,\n               empty_prestate(num_locals(enclosing)), e);\n     }\n-    case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n+    case (ast::item_fn(?id, ?f, ?ps, ?di, ?a)) {\n       assert (fm.contains_key(di));\n       ret find_pre_post_state_fn(dm, fm, fm.get(di), f);\n     }\n-    case (ast.item_mod(?id, ?m, ?di)) {\n+    case (ast::item_mod(?id, ?m, ?di)) {\n       ret find_pre_post_state_mod(m);\n     }\n-    case (ast.item_native_mod(?id, ?nm, ?di)) {\n+    case (ast::item_native_mod(?id, ?nm, ?di)) {\n       ret find_pre_post_state_native_mod(nm);\n     }\n-    case (ast.item_ty(_,_,_,_,_)) {\n+    case (ast::item_ty(_,_,_,_,_)) {\n       ret false;\n     }\n-    case (ast.item_tag(_,_,_,_,_)) {\n+    case (ast::item_tag(_,_,_,_,_)) {\n       ret false;\n     }\n-    case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n+    case (ast::item_obj(?id, ?o, ?ps, ?di, ?a)) {\n         ret find_pre_post_state_obj(dm, fm, o);\n     }\n   }\n@@ -1518,7 +1518,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n \n         alt (lhs.node) {\n             case (expr_path(_, ?a_lhs)) {\n-                alt (dm.get(ast.ann_tag(a_lhs))) {\n+                alt (dm.get(ast::ann_tag(a_lhs))) {\n                     case (def_local(?d_id)) {\n                         // assignment to local var\n                         changed = pure_exp(a_lhs, pres) || changed;\n@@ -1546,7 +1546,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n \n         alt (lhs.node) {\n             case (expr_path(?p, ?a_lhs)) {\n-                alt (dm.get(ast.ann_tag(a_lhs))) {\n+                alt (dm.get(ast::ann_tag(a_lhs))) {\n                     case (def_local(?d_id)) {\n                         // receive to local var\n                         changed = pure_exp(a_lhs, pres) || changed;\n@@ -1708,7 +1708,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                   || changed;\n         auto e_post = expr_poststate(e);\n         auto a_post;\n-        if (Vec.len[arm](alts) > 0u) {\n+        if (_vec::len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n             for (arm an_alt in alts) {\n                 changed = find_pre_post_state_block(dm, fm, enclosing, e_post,\n@@ -1788,18 +1788,18 @@ fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n               log(\"*At beginning: stmt = \");\n               log_stmt(*s);\n               log(\"*prestate = \");\n-              log(BitV.to_str(stmt_ann.states.prestate));\n+              log(bitv::to_str(stmt_ann.states.prestate));\n               log(\"*poststate =\");\n-              log(BitV.to_str(stmt_ann.states.poststate));\n+              log(bitv::to_str(stmt_ann.states.poststate));\n               log(\"*changed =\");\n               log(changed);\n   \n   alt (s.node) {\n     case (stmt_decl(?adecl, ?a)) {\n       alt (adecl.node) {\n-        case (ast.decl_local(?alocal)) {\n+        case (ast::decl_local(?alocal)) {\n           alt (alocal.init) {\n-            case (some[ast.initializer](?an_init)) {\n+            case (some[ast::initializer](?an_init)) {\n                 changed = extend_prestate(stmt_ann.states.prestate, pres)\n                     || changed;\n                 changed = find_pre_post_state_expr\n@@ -1811,7 +1811,7 @@ fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n               log(\"Summary: stmt = \");\n               log_stmt(*s);\n               log(\"prestate = \");\n-              log(BitV.to_str(stmt_ann.states.prestate));\n+              log(bitv::to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n               log(\"poststate =\");\n               log_bitv(enclosing, stmt_ann.states.poststate);\n@@ -1820,7 +1820,7 @@ fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n   \n               ret changed;\n             }\n-            case (none[ast.initializer]) {\n+            case (none[ast::initializer]) {\n               changed = extend_prestate(stmt_ann.states.prestate, pres)\n                   || changed;\n               changed = extend_poststate(stmt_ann.states.poststate, pres)\n@@ -1829,7 +1829,7 @@ fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             }\n           }\n         }\n-        case (ast.decl_item(?an_item)) {\n+        case (ast::decl_item(?an_item)) {\n             changed = extend_prestate(stmt_ann.states.prestate, pres)\n                || changed;\n             changed = extend_poststate(stmt_ann.states.poststate, pres)\n@@ -1850,10 +1850,10 @@ fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                     log(\"Summary: stmt = \");\n               log_stmt(*s);\n               log(\"prestate = \");\n-              log(BitV.to_str(stmt_ann.states.prestate));\n+              log(bitv::to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n               log(\"poststate =\");\n-              log(BitV.to_str(stmt_ann.states.poststate));\n+              log(bitv::to_str(stmt_ann.states.poststate));\n               log_bitv(enclosing, stmt_ann.states.poststate);\n               log(\"changed =\");\n               log(changed);\n@@ -1926,7 +1926,7 @@ fn find_pre_post_state_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n }\n \n fn find_pre_post_state_fn(&def_map dm, &fn_info_map f_info, &fn_info fi,\n-                          &ast._fn f) -> bool {\n+                          &ast::_fn f) -> bool {\n     /* FIXME: where do we set args as being initialized?\n        What about for methods? */\n     auto num_local_vars = num_locals(fi);\n@@ -1981,23 +1981,23 @@ fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n   }\n }\n \n-fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n+fn check_states_against_conditions(fn_info enclosing, &ast::_fn f) -> () {\n   fn do_one_(fn_info i, &@stmt s) -> () {\n     check_states_stmt(i, *s);\n   }\n   auto do_one = bind do_one_(enclosing, _);\n  \n-  Vec.map[@stmt, ()](do_one, f.body.node.stmts);\n+  _vec::map[@stmt, ()](do_one, f.body.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> () {\n     check_states_expr(i, e);\n   }\n   auto do_inner = bind do_inner_(enclosing, _);\n-  Option.map[@expr, ()](do_inner, f.body.node.expr);\n+  option::map[@expr, ()](do_inner, f.body.node.expr);\n   \n }\n \n fn check_fn_states(&def_map dm, &fn_info_map f_info_map, &fn_info f_info,\n-                   &ast._fn f) -> () {\n+                   &ast::_fn f) -> () {\n     /* Compute the pre- and post-states for this function */\n     // (Fixpoint iteration)\n     while (find_pre_post_state_fn(dm, f_info_map, f_info, f)) {}\n@@ -2008,7 +2008,7 @@ fn check_fn_states(&def_map dm, &fn_info_map f_info_map, &fn_info f_info,\n }\n \n fn check_item_fn_state(def_map dm, &fn_info_map f_info_map, &span sp,\n-                       &ident i, &ast._fn f, &vec[ast.ty_param] ty_params,\n+                       &ident i, &ast::_fn f, &vec[ast::ty_param] ty_params,\n                        &def_id id, &ann a) -> @item {\n \n   /* Look up the var-to-bit-num map for this function */\n@@ -2018,7 +2018,7 @@ fn check_item_fn_state(def_map dm, &fn_info_map f_info_map, &span sp,\n   check_fn_states(dm, f_info_map, f_info, f);\n \n   /* Rebuild the same function */\n-  ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n+  ret @respan(sp, ast::item_fn(i, f, ty_params, id, a));\n }\n \n fn check_method_states(&def_map dm, &fn_info_map f_info_map, @method m) {\n@@ -2029,13 +2029,13 @@ fn check_method_states(&def_map dm, &fn_info_map f_info_map, @method m) {\n \n fn check_obj_state(def_map dm, &fn_info_map f_info_map,\n                    &vec[obj_field] fields, &vec[@method] methods,\n-                   &Option.t[@method] dtor) -> ast._obj {\n+                   &option::t[@method] dtor) -> ast::_obj {\n     fn one(def_map dm, fn_info_map fm, &@method m) -> () {\n         ret check_method_states(dm, fm, m);\n     }\n     auto f = bind one(dm, f_info_map,_);\n-    Vec.map[@method, ()](f, methods);\n-    Option.map[@method, ()](f, dtor);\n+    _vec::map[@method, ()](f, methods);\n+    option::map[@method, ()](f, dtor);\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n \n@@ -2079,34 +2079,34 @@ fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n             fail;\n         }\n         case (ann_type(_, ?t,?ps,_)) {\n-            auto fld0 = fold.new_identity_fold[fn_info]();\n+            auto fld0 = fold::new_identity_fold[fn_info]();\n \n             fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n-            ret fold.fold_block[fn_info](fi, fld0, respan(sp, b)); \n+            ret fold::fold_block[fn_info](fi, fld0, respan(sp, b)); \n         }\n     }\n     \n }\n \n-fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n-                vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast::_fn f,\n+                vec[ast::ty_param] ty_params, def_id id, ann a) -> @item {\n \n     assert (fm.contains_key(id));\n     auto f_info = fm.get(id);\n \n     log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n \n-    auto fld0 = fold.new_identity_fold[fn_info]();\n+    auto fld0 = fold::new_identity_fold[fn_info]();\n \n     fld0 = @rec(fold_ann = bind init_ann(_,_) \n                     with *fld0);\n \n-    ret fold.fold_item[fn_info]\n+    ret fold::fold_item[fn_info]\n            (f_info, fld0, @respan(sp, item_fn(i, f, ty_params, id, a))); \n }\n \n /* This is painstakingly written as an explicit recursion b/c the\n-   standard ast.fold doesn't traverse in the correct order:\n+   standard ast::fold doesn't traverse in the correct order:\n    consider\n    fn foo() {\n       fn bar() {\n@@ -2125,15 +2125,15 @@ fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind one(fm,_);\n-    ret Vec.map[@expr, @expr](f, es);\n+    ret _vec::map[@expr, @expr](f, es);\n }\n fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n     fn one(fn_info_map fm, &elt e) -> elt {\n         ret rec(mut=e.mut,\n                 expr=annotate_expr(fm, e.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret Vec.map[elt, elt](f, es);\n+    ret _vec::map[elt, elt](f, es);\n }\n fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n     fn one(fn_info_map fm, &field f) -> field {\n@@ -2142,31 +2142,31 @@ fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n                  expr=annotate_expr(fm, f.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret Vec.map[field, field](f, fs);\n+    ret _vec::map[field, field](f, fs);\n }\n-fn annotate_option_exp(&fn_info_map fm, &Option.t[@expr] o)\n-  -> Option.t[@expr] {\n+fn annotate_option_exp(&fn_info_map fm, &option::t[@expr] o)\n+  -> option::t[@expr] {\n     fn one(fn_info_map fm, &@expr e) -> @expr {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind one(fm,_);\n-    ret Option.map[@expr, @expr](f, o);\n+    ret option::map[@expr, @expr](f, o);\n }\n-fn annotate_option_exprs(&fn_info_map fm, &vec[Option.t[@expr]] es)\n-  -> vec[Option.t[@expr]] {\n-    fn one(fn_info_map fm, &Option.t[@expr] o) -> Option.t[@expr] {\n+fn annotate_option_exprs(&fn_info_map fm, &vec[option::t[@expr]] es)\n+  -> vec[option::t[@expr]] {\n+    fn one(fn_info_map fm, &option::t[@expr] o) -> option::t[@expr] {\n         ret annotate_option_exp(fm, o);\n     }\n     auto f = bind one(fm,_);\n-    ret Vec.map[Option.t[@expr], Option.t[@expr]](f, es);\n+    ret _vec::map[option::t[@expr], option::t[@expr]](f, es);\n }\n fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n     auto d1 = d.node;\n     alt (d.node) {\n         case (decl_local(?l)) {\n             alt(l.init) {\n                 case (some[initializer](?init)) {\n-                    let Option.t[initializer] an_i =\n+                    let option::t[initializer] an_i =\n                         some[initializer]\n                           (rec(expr=annotate_expr(fm, init.expr)\n                                  with init));\n@@ -2188,7 +2188,7 @@ fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n                  block=annotate_block(fm, a.block));\n     }\n     auto f = bind one(fm,_);\n-    ret Vec.map[arm, arm](f, alts);\n+    ret _vec::map[arm, arm](f, alts);\n \n }\n fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n@@ -2339,172 +2339,173 @@ fn annotate_block(&fn_info_map fm, &block b) -> block {\n \n     for (@stmt s in b.node.stmts) {\n         auto new_s = annotate_stmt(fm, s);\n-        Vec.push[@stmt](new_stmts, new_s);\n+        _vec::push[@stmt](new_stmts, new_s);\n     }\n     fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind ann_e(fm,_);\n \n-    auto new_e = Option.map[@expr, @expr](f, b.node.expr);\n+    auto new_e = option::map[@expr, @expr](f, b.node.expr);\n \n     ret respan(b.span,\n           rec(stmts=new_stmts, expr=new_e with b.node));\n }\n-fn annotate_fn(&fn_info_map fm, &ast._fn f) -> ast._fn {\n+fn annotate_fn(&fn_info_map fm, &ast::_fn f) -> ast::_fn {\n     // subexps have *already* been annotated based on\n     // f's number-of-locals\n     ret rec(body=annotate_block(fm, f.body) with f);\n }\n-fn annotate_mod(&fn_info_map fm, &ast._mod m) -> ast._mod {\n+fn annotate_mod(&fn_info_map fm, &ast::_mod m) -> ast::_mod {\n     let vec[@item] new_items = vec();\n \n     for (@item i in m.items) {\n         auto new_i = annotate_item(fm, i);\n-        Vec.push[@item](new_items, new_i);\n+        _vec::push[@item](new_items, new_i);\n     }\n     ret rec(items=new_items with m);\n }\n fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n     auto f_info = get_fn_info(fm, m.node.id);\n-    auto fld0 = fold.new_identity_fold[fn_info]();\n+    auto fld0 = fold::new_identity_fold[fn_info]();\n     fld0 = @rec(fold_ann = bind init_ann(_,_) \n                 with *fld0);\n-    auto outer = fold.fold_method[fn_info](f_info, fld0, m);\n+    auto outer = fold::fold_method[fn_info](f_info, fld0, m);\n     auto new_fn = annotate_fn(fm, outer.node.meth);\n     ret @respan(m.span,\n                 rec(meth=new_fn with m.node));\n }\n \n-fn annotate_obj(&fn_info_map fm, &ast._obj o) -> ast._obj {\n+fn annotate_obj(&fn_info_map fm, &ast::_obj o) -> ast::_obj {\n     fn one(fn_info_map fm, &@method m) -> @method {\n         ret annotate_method(fm, m);\n     }\n     auto f = bind one(fm,_);\n-    auto new_methods = Vec.map[@method, @method](f, o.methods);\n-    auto new_dtor    = Option.map[@method, @method](f, o.dtor);\n+    auto new_methods = _vec::map[@method, @method](f, o.methods);\n+    auto new_dtor    = option::map[@method, @method](f, o.dtor);\n     ret rec(methods=new_methods, dtor=new_dtor with o);\n }\n \n  \n // Only annotates the components of the item recursively.\n-fn annotate_item_inner(&fn_info_map fm, &@ast.item item) -> @ast.item {\n+fn annotate_item_inner(&fn_info_map fm, &@ast::item item) -> @ast::item {\n     alt (item.node) {\n         /* FIXME can't skip this case -- exprs contain blocks contain stmts,\n          which contain decls */\n-        case (ast.item_const(_,_,_,_,_)) {\n+        case (ast::item_const(_,_,_,_,_)) {\n             // this has already been annotated by annotate_item\n             ret item;\n         }\n-        case (ast.item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n+        case (ast::item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n             ret @respan(item.span,\n-                       ast.item_fn(ident, annotate_fn(fm, ff), tps, id, ann));\n+                        ast::item_fn(ident, annotate_fn(fm, ff),\n+                                     tps, id, ann));\n         }\n-        case (ast.item_mod(?ident, ?mm, ?id)) {\n+        case (ast::item_mod(?ident, ?mm, ?id)) {\n             ret @respan(item.span,\n-                       ast.item_mod(ident, annotate_mod(fm, mm), id));\n+                       ast::item_mod(ident, annotate_mod(fm, mm), id));\n         }\n-        case (ast.item_native_mod(?ident, ?mm, ?id)) {\n+        case (ast::item_native_mod(?ident, ?mm, ?id)) {\n             ret item;\n         }\n-        case (ast.item_ty(_,_,_,_,_)) {\n+        case (ast::item_ty(_,_,_,_,_)) {\n             ret item;\n         }\n-        case (ast.item_tag(_,_,_,_,_)) {\n+        case (ast::item_tag(_,_,_,_,_)) {\n             ret item;\n         }\n-        case (ast.item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n+        case (ast::item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n             ret @respan(item.span,\n-              ast.item_obj(ident, annotate_obj(fm, ob), tps, odid, ann));\n+              ast::item_obj(ident, annotate_obj(fm, ob), tps, odid, ann));\n         }\n     } \n }\n \n-fn annotate_item(&fn_info_map fm, &@ast.item item) -> @ast.item {\n+fn annotate_item(&fn_info_map fm, &@ast::item item) -> @ast::item {\n     // Using a fold, recursively set all anns in this item\n     // to be blank.\n     // *Then*, call annotate_item recursively to do the right\n     // thing for any nested items inside this one.\n     \n     alt (item.node) {\n-        case (ast.item_const(_,_,_,_,_)) {\n-            auto fld0 = fold.new_identity_fold[()]();\n+        case (ast::item_const(_,_,_,_,_)) {\n+            auto fld0 = fold::new_identity_fold[()]();\n             fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n                         with *fld0);\n-            ret fold.fold_item[()]((), fld0, item);\n+            ret fold::fold_item[()]((), fld0, item);\n         }\n-        case (ast.item_fn(?i,?ff,?tps,?id,?ann)) {\n+        case (ast::item_fn(?i,?ff,?tps,?id,?ann)) {\n             auto f_info = get_fn_info(fm, id);\n-            auto fld0 = fold.new_identity_fold[fn_info]();\n+            auto fld0 = fold::new_identity_fold[fn_info]();\n             fld0 = @rec(fold_ann = bind init_ann(_,_) \n                         with *fld0);\n-            auto outer = fold.fold_item[fn_info](f_info, fld0, item);\n+            auto outer = fold::fold_item[fn_info](f_info, fld0, item);\n             // now recurse into any nested items\n             ret annotate_item_inner(fm, outer);\n          }\n-        case (ast.item_mod(?i, ?mm, ?id)) {\n-            auto fld0 = fold.new_identity_fold[()]();\n+        case (ast::item_mod(?i, ?mm, ?id)) {\n+            auto fld0 = fold::new_identity_fold[()]();\n             fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n                         with *fld0);\n-            auto outer = fold.fold_item[()]((), fld0, item);\n+            auto outer = fold::fold_item[()]((), fld0, item);\n             ret annotate_item_inner(fm, outer);\n         }\n-        case (ast.item_native_mod(?i, ?nm, ?id)) {\n+        case (ast::item_native_mod(?i, ?nm, ?id)) {\n             ret item;\n         }\n-        case (ast.item_ty(_,_,_,_,_)) {\n+        case (ast::item_ty(_,_,_,_,_)) {\n             ret item;\n         }\n-        case (ast.item_tag(_,_,_,_,_)) {\n+        case (ast::item_tag(_,_,_,_,_)) {\n             ret item;\n         }\n-        case (ast.item_obj(?i,?ob,?tps,?odid,?ann)) {\n-            auto fld0 = fold.new_identity_fold[()]();\n+        case (ast::item_obj(?i,?ob,?tps,?odid,?ann)) {\n+            auto fld0 = fold::new_identity_fold[()]();\n             fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n                         with *fld0);\n-            auto outer = fold.fold_item[()]((), fld0, item);\n+            auto outer = fold::fold_item[()]((), fld0, item);\n             ret annotate_item_inner(fm, outer);\n         }\n     }\n }\n \n-fn annotate_module(&fn_info_map fm, &ast._mod module) -> ast._mod {\n+fn annotate_module(&fn_info_map fm, &ast::_mod module) -> ast::_mod {\n     let vec[@item] new_items = vec();\n \n     for (@item i in module.items) {\n         auto new_item = annotate_item(fm, i);\n-        Vec.push[@item](new_items, new_item);\n+        _vec::push[@item](new_items, new_item);\n     }\n \n     ret rec(items = new_items with module);\n }\n \n-fn annotate_crate(&fn_info_map fm, &@ast.crate crate) -> @ast.crate {\n+fn annotate_crate(&fn_info_map fm, &@ast::crate crate) -> @ast::crate {\n     ret @respan(crate.span,\n                rec(module = annotate_module(fm, crate.node.module)\n                    with crate.node));\n }\n \n-fn check_crate(@ast.crate crate, def_map dm) -> @ast.crate {\n+fn check_crate(@ast::crate crate, def_map dm) -> @ast::crate {\n   /* Build the global map from function id to var-to-bit-num-map */\n   auto fm = mk_f_to_fn_info(crate);\n \n   /* Add a blank ts_ann to every statement (and expression) */\n   auto with_anns = annotate_crate(fm, crate);\n \n   /* Compute the pre and postcondition for every subexpression */\n-  auto fld = fold.new_identity_fold[fn_info_map]();\n+  auto fld = fold::new_identity_fold[fn_info_map]();\n   fld = @rec(fold_item_fn = bind check_item_fn(dm,_,_,_,_,_,_,_) with *fld);\n-  auto with_pre_postconditions = fold.fold_crate[fn_info_map]\n+  auto with_pre_postconditions = fold::fold_crate[fn_info_map]\n     (fm, fld, with_anns);\n \n-  auto fld1 = fold.new_identity_fold[fn_info_map]();\n+  auto fld1 = fold::new_identity_fold[fn_info_map]();\n \n   fld1 = @rec(fold_item_fn = bind check_item_fn_state(dm,_,_,_,_,_,_,_),\n               fold_obj     = bind check_obj_state(dm,_,_,_,_)\n               with *fld1);\n \n-  ret fold.fold_crate[fn_info_map](fm, fld1,\n+  ret fold::fold_crate[fn_info_map](fm, fld1,\n                                     with_pre_postconditions);\n }\n "}, {"sha": "848c43385d52fedb242fa2f5ceac070af9cf70cd", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 157, "deletions": 157, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,120 +1,120 @@\n-import front.ast;\n+import front::ast;\n \n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n \n type ast_visitor =\n     rec(fn () -> bool                  keep_going,\n         fn () -> bool                  want_crate_directives,\n-        fn (&ast.crate c)              visit_crate_pre,\n-        fn (&ast.crate c)              visit_crate_post,\n-        fn (&@ast.crate_directive cd)  visit_crate_directive_pre,\n-        fn (&@ast.crate_directive cd)  visit_crate_directive_post,\n-        fn (&@ast.view_item i)         visit_view_item_pre,\n-        fn (&@ast.view_item i)         visit_view_item_post,\n-        fn (&@ast.native_item i)       visit_native_item_pre,\n-        fn (&@ast.native_item i)       visit_native_item_post,\n-        fn (&@ast.item i)              visit_item_pre,\n-        fn (&@ast.item i)              visit_item_post,\n-        fn (&ast.block b)              visit_block_pre,\n-        fn (&ast.block b)              visit_block_post,\n-        fn (&@ast.stmt s)              visit_stmt_pre,\n-        fn (&@ast.stmt s)              visit_stmt_post,\n-        fn (&@ast.decl d)              visit_decl_pre,\n-        fn (&@ast.decl d)              visit_decl_post,\n-        fn (&@ast.expr e)              visit_expr_pre,\n-        fn (&@ast.expr e)              visit_expr_post,\n-        fn (&@ast.ty t)                visit_ty_pre,\n-        fn (&@ast.ty t)                visit_ty_post);\n+        fn (&ast::crate c)              visit_crate_pre,\n+        fn (&ast::crate c)              visit_crate_post,\n+        fn (&@ast::crate_directive cd)  visit_crate_directive_pre,\n+        fn (&@ast::crate_directive cd)  visit_crate_directive_post,\n+        fn (&@ast::view_item i)         visit_view_item_pre,\n+        fn (&@ast::view_item i)         visit_view_item_post,\n+        fn (&@ast::native_item i)       visit_native_item_pre,\n+        fn (&@ast::native_item i)       visit_native_item_post,\n+        fn (&@ast::item i)              visit_item_pre,\n+        fn (&@ast::item i)              visit_item_post,\n+        fn (&ast::block b)              visit_block_pre,\n+        fn (&ast::block b)              visit_block_post,\n+        fn (&@ast::stmt s)              visit_stmt_pre,\n+        fn (&@ast::stmt s)              visit_stmt_post,\n+        fn (&@ast::decl d)              visit_decl_pre,\n+        fn (&@ast::decl d)              visit_decl_post,\n+        fn (&@ast::expr e)              visit_expr_pre,\n+        fn (&@ast::expr e)              visit_expr_post,\n+        fn (&@ast::ty t)                visit_ty_pre,\n+        fn (&@ast::ty t)                visit_ty_post);\n \n-fn walk_crate(&ast_visitor v, &ast.crate c) {\n+fn walk_crate(&ast_visitor v, &ast::crate c) {\n     if (!v.keep_going()) { ret; }\n     v.visit_crate_pre(c);\n     walk_mod(v, c.node.module);\n     v.visit_crate_post(c);\n }\n \n-fn walk_crate_directive(&ast_visitor v, @ast.crate_directive cd) {\n+fn walk_crate_directive(&ast_visitor v, @ast::crate_directive cd) {\n     if (!v.keep_going()) { ret; }\n     if (!v.want_crate_directives()) { ret; }\n     v.visit_crate_directive_pre(cd);\n     alt (cd.node) {\n-        case (ast.cdir_let(_, ?e, ?cdirs)) {\n+        case (ast::cdir_let(_, ?e, ?cdirs)) {\n             walk_expr(v, e);\n-            for (@ast.crate_directive cdir in cdirs) {\n+            for (@ast::crate_directive cdir in cdirs) {\n                 walk_crate_directive(v, cdir);\n             }\n         }\n-        case (ast.cdir_src_mod(_, _)) {}\n-        case (ast.cdir_dir_mod(_, _, ?cdirs)) {\n-            for (@ast.crate_directive cdir in cdirs) {\n+        case (ast::cdir_src_mod(_, _)) {}\n+        case (ast::cdir_dir_mod(_, _, ?cdirs)) {\n+            for (@ast::crate_directive cdir in cdirs) {\n                 walk_crate_directive(v, cdir);\n             }\n         }\n-        case (ast.cdir_view_item(?vi)) {\n+        case (ast::cdir_view_item(?vi)) {\n             walk_view_item(v, vi);\n         }\n-        case (ast.cdir_meta(_)) {}\n-        case (ast.cdir_syntax(_)) {}\n-        case (ast.cdir_auth(_, _)) {}\n+        case (ast::cdir_meta(_)) {}\n+        case (ast::cdir_syntax(_)) {}\n+        case (ast::cdir_auth(_, _)) {}\n     }\n     v.visit_crate_directive_post(cd);\n }\n \n-fn walk_mod(&ast_visitor v, &ast._mod m) {\n+fn walk_mod(&ast_visitor v, &ast::_mod m) {\n     if (!v.keep_going()) { ret; }\n-    for (@ast.view_item vi in m.view_items) {\n+    for (@ast::view_item vi in m.view_items) {\n         walk_view_item(v, vi);\n     }\n-    for (@ast.item i in m.items) {\n+    for (@ast::item i in m.items) {\n         walk_item(v, i);\n     }\n }\n \n-fn walk_view_item(&ast_visitor v, @ast.view_item vi) {\n+fn walk_view_item(&ast_visitor v, @ast::view_item vi) {\n     if (!v.keep_going()) { ret; }\n     v.visit_view_item_pre(vi);\n     v.visit_view_item_post(vi);\n }\n \n-fn walk_item(&ast_visitor v, @ast.item i) {\n+fn walk_item(&ast_visitor v, @ast::item i) {\n     if (!v.keep_going()) { ret; }\n     v.visit_item_pre(i);\n     alt (i.node) {\n-        case (ast.item_const(_, ?t, ?e, _, _)) {\n+        case (ast::item_const(_, ?t, ?e, _, _)) {\n             walk_ty(v, t);\n             walk_expr(v, e);\n         }\n-        case (ast.item_fn(_, ?f, _, _, _)) {\n+        case (ast::item_fn(_, ?f, _, _, _)) {\n             walk_fn(v, f);\n         }\n-        case (ast.item_mod(_, ?m, _)) {\n+        case (ast::item_mod(_, ?m, _)) {\n             walk_mod(v, m);\n         }\n-        case (ast.item_native_mod(_, ?nm, _)) {\n+        case (ast::item_native_mod(_, ?nm, _)) {\n             walk_native_mod(v, nm);\n         }\n-        case (ast.item_ty(_, ?t, _, _, _)) {\n+        case (ast::item_ty(_, ?t, _, _, _)) {\n             walk_ty(v, t);\n         }\n-        case (ast.item_tag(_, ?variants, _, _, _)) {\n-            for (ast.variant vr in variants) {\n-                for (ast.variant_arg va in vr.node.args) {\n+        case (ast::item_tag(_, ?variants, _, _, _)) {\n+            for (ast::variant vr in variants) {\n+                for (ast::variant_arg va in vr.node.args) {\n                     walk_ty(v, va.ty);\n                 }\n             }\n         }\n-        case (ast.item_obj(_, ?ob, _, _, _)) {\n-            for (ast.obj_field f in ob.fields) {\n+        case (ast::item_obj(_, ?ob, _, _, _)) {\n+            for (ast::obj_field f in ob.fields) {\n                 walk_ty(v, f.ty);\n             }\n-            for (@ast.method m in ob.methods) {\n+            for (@ast::method m in ob.methods) {\n                 walk_fn(v, m.node.meth);\n             }\n             alt (ob.dtor) {\n-                case (none[@ast.method]) {}\n-                case (some[@ast.method](?m)) {\n+                case (none[@ast::method]) {}\n+                case (some[@ast::method](?m)) {\n                     walk_fn(v, m.node.meth);\n                 }\n             }\n@@ -124,282 +124,282 @@ fn walk_item(&ast_visitor v, @ast.item i) {\n     v.visit_item_post(i);\n }\n \n-fn walk_ty(&ast_visitor v, @ast.ty t) {\n+fn walk_ty(&ast_visitor v, @ast::ty t) {\n     if (!v.keep_going()) { ret; }\n     v.visit_ty_pre(t);\n     alt (t.node) {\n-        case (ast.ty_nil) {}\n-        case (ast.ty_bool) {}\n-        case (ast.ty_int) {}\n-        case (ast.ty_uint) {}\n-        case (ast.ty_float) {}\n-        case (ast.ty_machine(_)) {}\n-        case (ast.ty_char) {}\n-        case (ast.ty_str) {}\n-        case (ast.ty_box(?mt)) { walk_ty(v, mt.ty); }\n-        case (ast.ty_vec(?mt)) { walk_ty(v, mt.ty); }\n-        case (ast.ty_port(?t)) { walk_ty(v, t); }\n-        case (ast.ty_chan(?t)) { walk_ty(v, t); }\n-        case (ast.ty_tup(?mts)) {\n-            for (ast.mt mt in mts) {\n+        case (ast::ty_nil) {}\n+        case (ast::ty_bool) {}\n+        case (ast::ty_int) {}\n+        case (ast::ty_uint) {}\n+        case (ast::ty_float) {}\n+        case (ast::ty_machine(_)) {}\n+        case (ast::ty_char) {}\n+        case (ast::ty_str) {}\n+        case (ast::ty_box(?mt)) { walk_ty(v, mt.ty); }\n+        case (ast::ty_vec(?mt)) { walk_ty(v, mt.ty); }\n+        case (ast::ty_port(?t)) { walk_ty(v, t); }\n+        case (ast::ty_chan(?t)) { walk_ty(v, t); }\n+        case (ast::ty_tup(?mts)) {\n+            for (ast::mt mt in mts) {\n                 walk_ty(v, mt.ty);\n             }\n         }\n-        case (ast.ty_rec(?flds)) {\n-            for (ast.ty_field f in flds) {\n+        case (ast::ty_rec(?flds)) {\n+            for (ast::ty_field f in flds) {\n                 walk_ty(v, f.mt.ty);\n             }\n         }\n-        case (ast.ty_fn(_, ?args, ?out)) {\n-            for (ast.ty_arg a in args) {\n+        case (ast::ty_fn(_, ?args, ?out)) {\n+            for (ast::ty_arg a in args) {\n                 walk_ty(v, a.ty);\n             }\n             walk_ty(v, out);\n         }\n-        case (ast.ty_obj(?tmeths)) {\n-            for (ast.ty_method m in tmeths) {\n-                for (ast.ty_arg a in m.inputs) {\n+        case (ast::ty_obj(?tmeths)) {\n+            for (ast::ty_method m in tmeths) {\n+                for (ast::ty_arg a in m.inputs) {\n                     walk_ty(v, a.ty);\n                 }\n                 walk_ty(v, m.output);\n             }\n         }\n-        case (ast.ty_path(_, _)) {}\n-        case (ast.ty_type) {}\n-        case (ast.ty_constr(?t, _)) { walk_ty(v, t); }\n+        case (ast::ty_path(_, _)) {}\n+        case (ast::ty_type) {}\n+        case (ast::ty_constr(?t, _)) { walk_ty(v, t); }\n     }\n     v.visit_ty_post(t);\n }\n \n-fn walk_native_mod(&ast_visitor v, &ast.native_mod nm) {\n+fn walk_native_mod(&ast_visitor v, &ast::native_mod nm) {\n     if (!v.keep_going()) { ret; }\n-    for (@ast.view_item vi in nm.view_items) {\n+    for (@ast::view_item vi in nm.view_items) {\n         walk_view_item(v, vi);\n     }\n-    for (@ast.native_item ni in nm.items) {\n+    for (@ast::native_item ni in nm.items) {\n         walk_native_item(v, ni);\n     }\n }\n \n-fn walk_native_item(&ast_visitor v, @ast.native_item ni) {\n+fn walk_native_item(&ast_visitor v, @ast::native_item ni) {\n     if (!v.keep_going()) { ret; }\n     v.visit_native_item_pre(ni);\n     alt (ni.node) {\n-        case (ast.native_item_fn(_, _, ?fd, _, _, _)) {\n+        case (ast::native_item_fn(_, _, ?fd, _, _, _)) {\n             walk_fn_decl(v, fd);\n         }\n-        case (ast.native_item_ty(_, _)) {\n+        case (ast::native_item_ty(_, _)) {\n         }\n     }\n     v.visit_native_item_post(ni);\n }\n \n-fn walk_fn_decl(&ast_visitor v, &ast.fn_decl fd) {\n-    for (ast.arg a in fd.inputs) {\n+fn walk_fn_decl(&ast_visitor v, &ast::fn_decl fd) {\n+    for (ast::arg a in fd.inputs) {\n         walk_ty(v, a.ty);\n     }\n     walk_ty(v, fd.output);\n }\n \n-fn walk_fn(&ast_visitor v, &ast._fn f) {\n+fn walk_fn(&ast_visitor v, &ast::_fn f) {\n     if (!v.keep_going()) { ret; }\n     walk_fn_decl(v, f.decl);\n     walk_block(v, f.body);\n }\n \n-fn walk_block(&ast_visitor v, &ast.block b) {\n+fn walk_block(&ast_visitor v, &ast::block b) {\n     if (!v.keep_going()) { ret; }\n     v.visit_block_pre(b);\n-    for (@ast.stmt s in b.node.stmts) {\n+    for (@ast::stmt s in b.node.stmts) {\n         walk_stmt(v, s);\n     }\n     walk_expr_opt(v, b.node.expr);\n     v.visit_block_post(b);\n }\n \n-fn walk_stmt(&ast_visitor v, @ast.stmt s) {\n+fn walk_stmt(&ast_visitor v, @ast::stmt s) {\n     if (!v.keep_going()) { ret; }\n     v.visit_stmt_pre(s);\n     alt (s.node) {\n-        case (ast.stmt_decl(?d, _)) {\n+        case (ast::stmt_decl(?d, _)) {\n             walk_decl(v, d);\n         }\n-        case (ast.stmt_expr(?e, _)) {\n+        case (ast::stmt_expr(?e, _)) {\n             walk_expr(v, e);\n         }\n-        case (ast.stmt_crate_directive(?cdir)) {\n+        case (ast::stmt_crate_directive(?cdir)) {\n             walk_crate_directive(v, cdir);\n         }\n     }\n     v.visit_stmt_post(s);\n }\n \n-fn walk_decl(&ast_visitor v, @ast.decl d) {\n+fn walk_decl(&ast_visitor v, @ast::decl d) {\n     if (!v.keep_going()) { ret; }\n     v.visit_decl_pre(d);\n     alt (d.node) {\n-        case (ast.decl_local(?loc)) {\n+        case (ast::decl_local(?loc)) {\n             alt (loc.ty) {\n-                case (none[@ast.ty]) {}\n-                case (some[@ast.ty](?t)) { walk_ty(v, t); }\n+                case (none[@ast::ty]) {}\n+                case (some[@ast::ty](?t)) { walk_ty(v, t); }\n             }\n             alt (loc.init) {\n-                case (none[ast.initializer]) {}\n-                case (some[ast.initializer](?i)) {\n+                case (none[ast::initializer]) {}\n+                case (some[ast::initializer](?i)) {\n                     walk_expr(v, i.expr);\n                 }\n             }\n         }\n-        case (ast.decl_item(?it)) {\n+        case (ast::decl_item(?it)) {\n             walk_item(v, it);\n         }\n     }\n     v.visit_decl_post(d);\n }\n \n-fn walk_expr_opt(&ast_visitor v, Option.t[@ast.expr] eo) {\n+fn walk_expr_opt(&ast_visitor v, option::t[@ast::expr] eo) {\n     alt (eo) {\n-        case (none[@ast.expr]) {}\n-        case (some[@ast.expr](?e)) {\n+        case (none[@ast::expr]) {}\n+        case (some[@ast::expr](?e)) {\n             walk_expr(v, e);\n         }\n     }\n }\n \n-fn walk_exprs(&ast_visitor v, vec[@ast.expr] exprs) {\n-    for (@ast.expr e in exprs) {\n+fn walk_exprs(&ast_visitor v, vec[@ast::expr] exprs) {\n+    for (@ast::expr e in exprs) {\n         walk_expr(v, e);\n     }\n }\n \n-fn walk_expr(&ast_visitor v, @ast.expr e) {\n+fn walk_expr(&ast_visitor v, @ast::expr e) {\n     if (!v.keep_going()) { ret; }\n     v.visit_expr_pre(e);\n     alt (e.node) {\n-        case (ast.expr_vec(?es, _, _)) {\n+        case (ast::expr_vec(?es, _, _)) {\n             walk_exprs(v, es);\n         }\n-        case (ast.expr_tup(?elts, _)) {\n-            for (ast.elt e in elts) {\n+        case (ast::expr_tup(?elts, _)) {\n+            for (ast::elt e in elts) {\n                 walk_expr(v, e.expr);\n             }\n         }\n-        case (ast.expr_rec(?flds, ?base, _)) {\n-            for (ast.field f in flds) {\n+        case (ast::expr_rec(?flds, ?base, _)) {\n+            for (ast::field f in flds) {\n                 walk_expr(v, f.expr);\n             }\n             walk_expr_opt(v, base);\n         }\n-        case (ast.expr_call(?callee, ?args, _)) {\n+        case (ast::expr_call(?callee, ?args, _)) {\n             walk_expr(v, callee);\n             walk_exprs(v, args);\n         }\n-        case (ast.expr_self_method(_, _)) { }\n-        case (ast.expr_bind(?callee, ?args, _)) {\n+        case (ast::expr_self_method(_, _)) { }\n+        case (ast::expr_bind(?callee, ?args, _)) {\n             walk_expr(v, callee);\n-            for (Option.t[@ast.expr] eo in args) {\n+            for (option::t[@ast::expr] eo in args) {\n                 walk_expr_opt(v, eo);\n             }\n         }\n-        case (ast.expr_spawn(_, _, ?callee, ?args, _)) {\n+        case (ast::expr_spawn(_, _, ?callee, ?args, _)) {\n             walk_expr(v, callee);\n             walk_exprs(v, args);\n         }\n-        case (ast.expr_binary(_, ?a, ?b, _)) {\n+        case (ast::expr_binary(_, ?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_unary(_, ?a, _)) {\n+        case (ast::expr_unary(_, ?a, _)) {\n             walk_expr(v, a);\n         }\n-        case (ast.expr_lit(_, _)) { }\n-        case (ast.expr_cast(?x, ?t, _)) {\n+        case (ast::expr_lit(_, _)) { }\n+        case (ast::expr_cast(?x, ?t, _)) {\n             walk_expr(v, x);\n             walk_ty(v, t);\n         }\n-        case (ast.expr_if(?x, ?b, ?eo, _)) {\n+        case (ast::expr_if(?x, ?b, ?eo, _)) {\n             walk_expr(v, x);\n             walk_block(v, b);\n             walk_expr_opt(v, eo);\n         }\n-        case (ast.expr_while(?x, ?b, _)) {\n+        case (ast::expr_while(?x, ?b, _)) {\n             walk_expr(v, x);\n             walk_block(v, b);\n         }\n-        case (ast.expr_for(?dcl, ?x, ?b, _)) {\n+        case (ast::expr_for(?dcl, ?x, ?b, _)) {\n             walk_decl(v, dcl);\n             walk_expr(v, x);\n             walk_block(v, b);\n         }\n-        case (ast.expr_for_each(?dcl, ?x, ?b, _)) {\n+        case (ast::expr_for_each(?dcl, ?x, ?b, _)) {\n             walk_decl(v, dcl);\n             walk_expr(v, x);\n             walk_block(v, b);\n         }\n-        case (ast.expr_do_while(?b, ?x, _)) {\n+        case (ast::expr_do_while(?b, ?x, _)) {\n             walk_block(v, b);\n             walk_expr(v, x);\n         }\n-        case (ast.expr_alt(?x, ?arms, _)) {\n+        case (ast::expr_alt(?x, ?arms, _)) {\n             walk_expr(v, x);\n-            for (ast.arm a in arms) {\n+            for (ast::arm a in arms) {\n                 walk_block(v, a.block);\n             }\n         }\n-        case (ast.expr_block(?b, _)) {\n+        case (ast::expr_block(?b, _)) {\n             walk_block(v, b);\n         }\n-        case (ast.expr_assign(?a, ?b, _)) {\n+        case (ast::expr_assign(?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_assign_op(_, ?a, ?b, _)) {\n+        case (ast::expr_assign_op(_, ?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_send(?a, ?b, _)) {\n+        case (ast::expr_send(?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_recv(?a, ?b, _)) {\n+        case (ast::expr_recv(?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_field(?x, _, _)) {\n+        case (ast::expr_field(?x, _, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_index(?a, ?b, _)) {\n+        case (ast::expr_index(?a, ?b, _)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_path(_, _)) { }\n-        case (ast.expr_ext(_, ?args, ?body, ?expansion, _)) {\n+        case (ast::expr_path(_, _)) { }\n+        case (ast::expr_ext(_, ?args, ?body, ?expansion, _)) {\n             // Only walk expansion, not args/body.\n             walk_expr(v, expansion);\n         }\n-        case (ast.expr_fail(_)) { }\n-        case (ast.expr_break(_)) { }\n-        case (ast.expr_cont(_)) { }\n-        case (ast.expr_ret(?eo, _)) {\n+        case (ast::expr_fail(_)) { }\n+        case (ast::expr_break(_)) { }\n+        case (ast::expr_cont(_)) { }\n+        case (ast::expr_ret(?eo, _)) {\n             walk_expr_opt(v, eo);\n         }\n-        case (ast.expr_put(?eo, _)) {\n+        case (ast::expr_put(?eo, _)) {\n             walk_expr_opt(v, eo);\n         }\n-        case (ast.expr_be(?x, _)) {\n+        case (ast::expr_be(?x, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_log(_,?x, _)) {\n+        case (ast::expr_log(_,?x, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_check(?x, _)) {\n+        case (ast::expr_check(?x, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_assert(?x, _)) {\n+        case (ast::expr_assert(?x, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_port(_)) { }\n-        case (ast.expr_chan(?x, _)) {\n+        case (ast::expr_port(_)) { }\n+        case (ast::expr_chan(?x, _)) {\n             walk_expr(v, x);\n         }\n     }\n@@ -408,16 +408,16 @@ fn walk_expr(&ast_visitor v, @ast.expr e) {\n \n fn def_keep_going() -> bool { ret true; }\n fn def_want_crate_directives() -> bool { ret false; }\n-fn def_visit_crate(&ast.crate c) { }\n-fn def_visit_crate_directive(&@ast.crate_directive c) { }\n-fn def_visit_view_item(&@ast.view_item vi) { }\n-fn def_visit_native_item(&@ast.native_item ni) { }\n-fn def_visit_item(&@ast.item i) { }\n-fn def_visit_block(&ast.block b) { }\n-fn def_visit_stmt(&@ast.stmt s) { }\n-fn def_visit_decl(&@ast.decl d) { }\n-fn def_visit_expr(&@ast.expr e) { }\n-fn def_visit_ty(&@ast.ty t) { }\n+fn def_visit_crate(&ast::crate c) { }\n+fn def_visit_crate_directive(&@ast::crate_directive c) { }\n+fn def_visit_view_item(&@ast::view_item vi) { }\n+fn def_visit_native_item(&@ast::native_item ni) { }\n+fn def_visit_item(&@ast::item i) { }\n+fn def_visit_block(&ast::block b) { }\n+fn def_visit_stmt(&@ast::stmt s) { }\n+fn def_visit_decl(&@ast::decl d) { }\n+fn def_visit_expr(&@ast::expr e) { }\n+fn def_visit_ty(&@ast::ty t) { }\n \n fn default_visitor() -> ast_visitor {\n "}, {"sha": "aff0843d27d241c79175e7cadf4072921ec01122", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n-import std.IO;\n-import std.Vec;\n-import std.Str;\n+import std::io;\n+import std::_vec;\n+import std::_str;\n \n tag boxtype {box_h; box_v; box_hv; box_align;}\n tag contexttype {cx_h; cx_v;}\n@@ -19,7 +19,7 @@ type context = rec(contexttype tp, uint indent);\n \n type ps = @rec(mutable vec[context] context,\n                uint width,\n-               IO.writer out,\n+               io::writer out,\n                mutable uint col,\n                mutable uint spaces,\n                mutable vec[token] buffered,\n@@ -30,7 +30,7 @@ type ps = @rec(mutable vec[context] context,\n                mutable bool start_of_box,\n                mutable bool potential_brk);\n \n-fn mkstate(IO.writer out, uint width) -> ps {\n+fn mkstate(io::writer out, uint width) -> ps {\n   let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n   let vec[token] buff = vec();\n   let vec[boxtype] sd = vec();\n@@ -57,12 +57,12 @@ fn write_spaces(ps p, uint i) {\n \n fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n-  Vec.push[context](p.context, rec(tp=tp, indent=indent));\n+  _vec::push[context](p.context, rec(tp=tp, indent=indent));\n   p.start_of_box = true;\n }\n \n fn pop_context(ps p) {\n-  Vec.pop[context](p.context);\n+  _vec::pop[context](p.context);\n }\n \n fn add_token(ps p, token tok) {\n@@ -89,22 +89,22 @@ fn buffer_token(ps p, token tok) {\n   } else {\n     alt (tok) {\n       case (open(?tp,_)) {\n-        Vec.push[boxtype](p.scandepth, tp);\n+        _vec::push[boxtype](p.scandepth, tp);\n         if (p.scanning == scan_h) {\n           if (tp == box_h) {\n             check_potential_brk(p);\n           }\n         }\n       }\n       case (close) {\n-        Vec.pop[boxtype](p.scandepth);\n-        if (Vec.len[boxtype](p.scandepth) == 0u) {\n+        _vec::pop[boxtype](p.scandepth);\n+        if (_vec::len[boxtype](p.scandepth) == 0u) {\n           finish_scan(p, true);\n         }\n       }\n       case (brk(_)) {\n         if (p.scanning == scan_h) {\n-          if (p.scandepth.(Vec.len[boxtype](p.scandepth)-1u) == box_v) {\n+          if (p.scandepth.(_vec::len[boxtype](p.scandepth)-1u) == box_v) {\n             finish_scan(p, true);\n           }\n         }\n@@ -123,7 +123,7 @@ fn check_potential_brk(ps p) {\n \n fn finish_scan(ps p, bool fits) {\n   auto buf = p.buffered;\n-  auto front = Vec.shift[token](buf);\n+  auto front = _vec::shift[token](buf);\n   auto chosen_tp = cx_h;\n   if (!fits) {chosen_tp = cx_v;}\n   alt (front) {\n@@ -154,10 +154,10 @@ fn start_scan(ps p, token tok, scantype tp) {\n }\n \n fn cur_context(ps p) -> context {\n-  ret p.context.(Vec.len[context](p.context)-1u);\n+  ret p.context.(_vec::len[context](p.context)-1u);\n }\n fn base_indent(ps p) -> uint {\n-  auto i = Vec.len[context](p.context);\n+  auto i = _vec::len[context](p.context);\n   while (i > 0u) {\n     i -= 1u;\n     auto cx = p.context.(i);\n@@ -190,7 +190,7 @@ fn do_token(ps p, token tok) {\n       line_break(p);\n     }\n     case (word(?w)) {\n-      auto len = Str.char_len(w);\n+      auto len = _str::char_len(w);\n       if (len + p.col + p.spaces > p.width && !start_of_box &&\n           !p.start_of_line) {\n         line_break(p);\n@@ -202,7 +202,7 @@ fn do_token(ps p, token tok) {\n     case (cword(?w)) {\n       before_print(p, true);\n       p.out.write_str(w);\n-      p.col += Str.char_len(w);\n+      p.col += _str::char_len(w);\n     }\n     case (open(?tp, ?indent)) {\n       if (tp == box_v) {\n@@ -247,8 +247,8 @@ fn token_size(token tok) -> uint {\n   alt (tok) {\n     case (brk(?sz)) {ret sz;}\n     case (hardbrk) {ret 0xFFFFFFu;}\n-    case (word(?w)) {ret Str.char_len(w);}\n-    case (cword(?w)) {ret Str.char_len(w);}\n+    case (word(?w)) {ret _str::char_len(w);}\n+    case (cword(?w)) {ret _str::char_len(w);}\n     case (open(_, _)) {ret 0u;}\n     case (close) {ret 0u;}\n   }"}, {"sha": "3c959b999c2d2a7bb6b582df28243fe9aea4e36e", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 255, "deletions": 253, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,85 +1,85 @@\n-import std.Vec;\n-import std.Str;\n-import std.IO;\n-import std.Option;\n-import driver.session.session;\n-import front.ast;\n-import front.lexer;\n-import util.common;\n-import pp.end; import pp.wrd; import pp.space; import pp.line;\n+import std::_vec;\n+import std::_str;\n+import std::io;\n+import std::option;\n+import driver::session::session;\n+import front::ast;\n+import front::lexer;\n+import util::common;\n+import pp::end; import pp::wrd; import pp::space; import pp::line;\n \n const uint indent_unit = 4u;\n const int as_prec = 5;\n const uint default_columns = 78u;\n \n-type ps = @rec(pp.ps s,\n-               Option.t[vec[lexer.cmnt]] comments,\n+type ps = @rec(pp::ps s,\n+               option::t[vec[lexer::cmnt]] comments,\n                mutable uint cur_cmnt);\n \n-fn print_file(session sess, ast._mod _mod, str filename, IO.writer out) {\n-    auto cmnts = lexer.gather_comments(sess, filename);\n-    auto s = @rec(s=pp.mkstate(out, default_columns),\n-                  comments=Option.some[vec[lexer.cmnt]](cmnts),\n+fn print_file(session sess, ast::_mod _mod, str filename, io::writer out) {\n+    auto cmnts = lexer::gather_comments(sess, filename);\n+    auto s = @rec(s=pp::mkstate(out, default_columns),\n+                  comments=option::some[vec[lexer::cmnt]](cmnts),\n                   mutable cur_cmnt=0u);\n     print_mod(s, _mod);\n }\n \n-fn ty_to_str(&@ast.ty ty) -> str {\n-    auto writer = IO.string_writer();\n-    auto s = @rec(s=pp.mkstate(writer.get_writer(), 0u),\n-                  comments=Option.none[vec[lexer.cmnt]],\n+fn ty_to_str(&@ast::ty ty) -> str {\n+    auto writer = io::string_writer();\n+    auto s = @rec(s=pp::mkstate(writer.get_writer(), 0u),\n+                  comments=option::none[vec[lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n     print_type(s, ty);\n     ret writer.get_str();\n }\n \n-fn block_to_str(&ast.block blk) -> str {\n-    auto writer = IO.string_writer();\n-    auto s = @rec(s=pp.mkstate(writer.get_writer(), 78u),\n-                  comments=Option.none[vec[lexer.cmnt]],\n+fn block_to_str(&ast::block blk) -> str {\n+    auto writer = io::string_writer();\n+    auto s = @rec(s=pp::mkstate(writer.get_writer(), 78u),\n+                  comments=option::none[vec[lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n     print_block(s, blk);\n     ret writer.get_str();\n }\n \n-fn pat_to_str(&@ast.pat p) -> str {\n-    auto writer = IO.string_writer();\n-    auto s = @rec(s=pp.mkstate(writer.get_writer(), 78u),\n-                  comments=Option.none[vec[lexer.cmnt]],\n+fn pat_to_str(&@ast::pat p) -> str {\n+    auto writer = io::string_writer();\n+    auto s = @rec(s=pp::mkstate(writer.get_writer(), 78u),\n+                  comments=option::none[vec[lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n     print_pat(s, p);\n     ret writer.get_str();\n }\n \n fn hbox(ps s) {\n-    pp.hbox(s.s, indent_unit);\n+    pp::hbox(s.s, indent_unit);\n }\n fn wrd1(ps s, str word) {\n     wrd(s.s, word);\n     space(s.s);\n }\n fn popen(ps s) {\n     wrd(s.s, \"(\");\n-    pp.abox(s.s);\n+    pp::abox(s.s);\n }\n fn popen_h(ps s) {\n     wrd(s.s, \"(\");\n-    pp.hbox(s.s, 0u);\n+    pp::hbox(s.s, 0u);\n }\n fn pclose(ps s) {\n     end(s.s);\n     wrd(s.s, \")\");\n }\n fn bopen(ps s) {\n     wrd(s.s, \"{\");\n-    pp.vbox(s.s, indent_unit);\n+    pp::vbox(s.s, indent_unit);\n     line(s.s);\n }\n fn bclose(ps s) {\n     end(s.s);\n-    pp.cwrd(s.s, \"}\");\n+    pp::cwrd(s.s, \"}\");\n }\n-fn bclose_c(ps s, common.span span) {\n+fn bclose_c(ps s, common::span span) {\n     maybe_print_comment(s, span.hi);\n     bclose(s);\n }\n@@ -92,8 +92,8 @@ fn commasep[IN](ps s, vec[IN] elts, fn(ps, &IN) op) {\n     }\n }\n fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n-                            fn(&IN) -> common.span get_span) {\n-    auto len = Vec.len[IN](elts);\n+                            fn(&IN) -> common::span get_span) {\n+    auto len = _vec::len[IN](elts);\n     auto i = 0u;\n     for (IN elt in elts) {\n         op(s, elt);\n@@ -104,99 +104,101 @@ fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n         }\n     }\n }\n-fn commasep_exprs(ps s, vec[@ast.expr] exprs) {\n-    fn expr_span(&@ast.expr expr) -> common.span {ret expr.span;}\n+fn commasep_exprs(ps s, vec[@ast::expr] exprs) {\n+    fn expr_span(&@ast::expr expr) -> common::span {ret expr.span;}\n     auto f = print_expr;\n     auto gs = expr_span;\n-    commasep_cmnt[@ast.expr](s, exprs, f, gs);\n+    commasep_cmnt[@ast::expr](s, exprs, f, gs);\n }\n \n-fn print_mod(ps s, ast._mod _mod) {\n-    for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n+fn print_mod(ps s, ast::_mod _mod) {\n+    for (@ast::view_item vitem in _mod.view_items) {\n+        print_view_item(s, vitem);\n+    }\n     line(s.s);\n-    for (@ast.item item in _mod.items) {print_item(s, item);}\n+    for (@ast::item item in _mod.items) {print_item(s, item);}\n     print_remaining_comments(s);\n }\n \n-fn print_type(ps s, &@ast.ty ty) {\n+fn print_type(ps s, &@ast::ty ty) {\n     maybe_print_comment(s, ty.span.lo);\n     hbox(s);\n     alt (ty.node) {\n-        case (ast.ty_nil) {wrd(s.s, \"()\");}\n-        case (ast.ty_bool) {wrd(s.s, \"bool\");}\n-        case (ast.ty_int) {wrd(s.s, \"int\");}\n-        case (ast.ty_uint) {wrd(s.s, \"uint\");}\n-        case (ast.ty_float) {wrd(s.s, \"float\");}\n-        case (ast.ty_machine(?tm)) {wrd(s.s, common.ty_mach_to_str(tm));}\n-        case (ast.ty_char) {wrd(s.s, \"char\");}\n-        case (ast.ty_str) {wrd(s.s, \"str\");}\n-        case (ast.ty_box(?mt)) {wrd(s.s, \"@\"); print_mt(s, mt);}\n-        case (ast.ty_vec(?mt)) {\n+        case (ast::ty_nil) {wrd(s.s, \"()\");}\n+        case (ast::ty_bool) {wrd(s.s, \"bool\");}\n+        case (ast::ty_int) {wrd(s.s, \"int\");}\n+        case (ast::ty_uint) {wrd(s.s, \"uint\");}\n+        case (ast::ty_float) {wrd(s.s, \"float\");}\n+        case (ast::ty_machine(?tm)) {wrd(s.s, common::ty_mach_to_str(tm));}\n+        case (ast::ty_char) {wrd(s.s, \"char\");}\n+        case (ast::ty_str) {wrd(s.s, \"str\");}\n+        case (ast::ty_box(?mt)) {wrd(s.s, \"@\"); print_mt(s, mt);}\n+        case (ast::ty_vec(?mt)) {\n             wrd(s.s, \"vec[\"); print_mt(s, mt); wrd(s.s, \"]\");\n         }\n-        case (ast.ty_port(?t)) {\n+        case (ast::ty_port(?t)) {\n             wrd(s.s, \"port[\"); print_type(s, t); wrd(s.s, \"]\");\n         }\n-        case (ast.ty_chan(?t)) {\n+        case (ast::ty_chan(?t)) {\n             wrd(s.s, \"chan[\"); print_type(s, t); wrd(s.s, \"]\");\n         }\n-        case (ast.ty_type) {wrd(s.s, \"type\");}\n-        case (ast.ty_tup(?elts)) {\n+        case (ast::ty_type) {wrd(s.s, \"type\");}\n+        case (ast::ty_tup(?elts)) {\n             wrd(s.s, \"tup\");\n             popen(s);\n             auto f = print_mt;\n-            commasep[ast.mt](s, elts, f);\n+            commasep[ast::mt](s, elts, f);\n             pclose(s);\n         }\n-        case (ast.ty_rec(?fields)) {\n+        case (ast::ty_rec(?fields)) {\n             wrd(s.s, \"rec\");\n             popen(s);\n-            fn print_field(ps s, &ast.ty_field f) {\n+            fn print_field(ps s, &ast::ty_field f) {\n                 hbox(s);\n                 print_mt(s, f.mt);\n                 space(s.s);\n                 wrd(s.s, f.ident);\n                 end(s.s);\n             }\n-            fn get_span(&ast.ty_field f) -> common.span {\n+            fn get_span(&ast::ty_field f) -> common::span {\n               // Try to reconstruct the span for this field\n               auto sp = f.mt.ty.span;\n-              auto hi = sp.hi + Str.char_len(f.ident) + 1u;\n+              auto hi = sp.hi + _str::char_len(f.ident) + 1u;\n               ret rec(hi=hi with sp);\n             }\n             auto f = print_field;\n             auto gs = get_span;\n-            commasep_cmnt[ast.ty_field](s, fields, f, gs);\n+            commasep_cmnt[ast::ty_field](s, fields, f, gs);\n             pclose(s);\n         }\n-        case (ast.ty_obj(?methods)) {\n+        case (ast::ty_obj(?methods)) {\n             wrd1(s, \"obj\");\n             bopen(s);\n-            for (ast.ty_method m in methods) {\n+            for (ast::ty_method m in methods) {\n                 hbox(s);\n-                print_ty_fn(s, m.proto, Option.some[str](m.ident),\n+                print_ty_fn(s, m.proto, option::some[str](m.ident),\n                             m.inputs, m.output);\n                 wrd(s.s, \";\");\n                 end(s.s);\n                 line(s.s);\n             }\n             bclose_c(s, ty.span);\n         }\n-        case (ast.ty_fn(?proto,?inputs,?output)) {\n-            print_ty_fn(s, proto, Option.none[str], inputs, output);\n+        case (ast::ty_fn(?proto,?inputs,?output)) {\n+            print_ty_fn(s, proto, option::none[str], inputs, output);\n         }\n-        case (ast.ty_path(?path,_)) {\n+        case (ast::ty_path(?path,_)) {\n             print_path(s, path);\n         }\n     }\n     end(s.s);\n }\n \n-fn print_item(ps s, @ast.item item) {\n+fn print_item(ps s, @ast::item item) {\n     maybe_print_comment(s, item.span.lo);\n     hbox(s);\n     alt (item.node) {\n-        case (ast.item_const(?id, ?ty, ?expr, _, _)) {\n+        case (ast::item_const(?id, ?ty, ?expr, _, _)) {\n             wrd1(s, \"const\");\n             print_type(s, ty);\n             space(s.s);\n@@ -205,44 +207,44 @@ fn print_item(ps s, @ast.item item) {\n             print_expr(s, expr);\n             wrd(s.s, \";\");\n         }\n-        case (ast.item_fn(?name,?_fn,?typarams,_,_)) {\n+        case (ast::item_fn(?name,?_fn,?typarams,_,_)) {\n             print_fn(s, _fn.decl, name, typarams);\n             space(s.s);\n             print_block(s, _fn.body);\n         }\n-        case (ast.item_mod(?id,?_mod,_)) {\n+        case (ast::item_mod(?id,?_mod,_)) {\n             wrd1(s, \"mod\");\n             wrd1(s, id);\n             bopen(s);\n-            for (@ast.item itm in _mod.items) {print_item(s, itm);}\n+            for (@ast::item itm in _mod.items) {print_item(s, itm);}\n             bclose_c(s, item.span);\n         }\n-        case (ast.item_native_mod(?id,?nmod,_)) {\n+        case (ast::item_native_mod(?id,?nmod,_)) {\n             wrd1(s, \"native\");\n             alt (nmod.abi) {\n-                case (ast.native_abi_rust) {wrd1(s, \"\\\"rust\\\"\");}\n-                case (ast.native_abi_cdecl) {wrd1(s, \"\\\"cdecl\\\"\");}\n-                case (ast.native_abi_rust_intrinsic) {\n+                case (ast::native_abi_rust) {wrd1(s, \"\\\"rust\\\"\");}\n+                case (ast::native_abi_cdecl) {wrd1(s, \"\\\"cdecl\\\"\");}\n+                case (ast::native_abi_rust_intrinsic) {\n                     wrd1(s, \"\\\"rust-intrinstic\\\"\");\n                 }\n             }\n             wrd1(s, \"mod\");\n             wrd1(s, id);\n             bopen(s);\n-            for (@ast.native_item item in nmod.items) {\n+            for (@ast::native_item item in nmod.items) {\n                 hbox(s);\n                 maybe_print_comment(s, item.span.lo);\n                 alt (item.node) {\n-                    case (ast.native_item_ty(?id,_)) {\n+                    case (ast::native_item_ty(?id,_)) {\n                         wrd1(s, \"type\");\n                         wrd(s.s, id);\n                     }\n-                    case (ast.native_item_fn(?id,?lname,?decl,\n+                    case (ast::native_item_fn(?id,?lname,?decl,\n                                              ?typarams,_,_)) {\n                         print_fn(s, decl, id, typarams);\n                         alt (lname) {\n-                            case (Option.none[str]) {}\n-                            case (Option.some[str](?ss)) {\n+                            case (option::none[str]) {}\n+                            case (option::some[str](?ss)) {\n                                 print_string(s, ss);\n                             }\n                         }\n@@ -253,7 +255,7 @@ fn print_item(ps s, @ast.item item) {\n             }\n             bclose_c(s, item.span);\n         }\n-        case (ast.item_ty(?id,?ty,?params,_,_)) {\n+        case (ast::item_ty(?id,?ty,?params,_,_)) {\n             wrd1(s, \"type\");\n             wrd(s.s, id);\n             print_type_params(s, params);\n@@ -262,51 +264,51 @@ fn print_item(ps s, @ast.item item) {\n             print_type(s, ty);\n             wrd(s.s, \";\");\n         }\n-        case (ast.item_tag(?id,?variants,?params,_,_)) {\n+        case (ast::item_tag(?id,?variants,?params,_,_)) {\n             wrd1(s, \"tag\");\n             wrd(s.s, id);\n             print_type_params(s, params);\n             space(s.s);\n             bopen(s);\n-            for (ast.variant v in variants) {\n+            for (ast::variant v in variants) {\n                 maybe_print_comment(s, v.span.lo);\n                 wrd(s.s, v.node.name);\n-                if (Vec.len[ast.variant_arg](v.node.args) > 0u) {\n+                if (_vec::len[ast::variant_arg](v.node.args) > 0u) {\n                     popen(s);\n-                    fn print_variant_arg(ps s, &ast.variant_arg arg) {\n+                    fn print_variant_arg(ps s, &ast::variant_arg arg) {\n                         print_type(s, arg.ty);\n                     }\n                     auto f = print_variant_arg;\n-                    commasep[ast.variant_arg](s, v.node.args, f);\n+                    commasep[ast::variant_arg](s, v.node.args, f);\n                     pclose(s);\n                 }\n                 wrd(s.s, \";\");\n                 if (!maybe_print_line_comment(s, v.span)) {line(s.s);}\n             }\n             bclose_c(s, item.span);\n         }\n-        case (ast.item_obj(?id,?_obj,?params,_,_)) {\n+        case (ast::item_obj(?id,?_obj,?params,_,_)) {\n             wrd1(s, \"obj\");\n             wrd(s.s, id);\n             print_type_params(s, params);\n             popen(s);\n-            fn print_field(ps s, &ast.obj_field field) {\n+            fn print_field(ps s, &ast::obj_field field) {\n                 hbox(s);\n                 print_type(s, field.ty);\n                 space(s.s);\n                 wrd(s.s, field.ident);\n                 end(s.s);\n             }\n-            fn get_span(&ast.obj_field f) -> common.span {ret f.ty.span;}\n+            fn get_span(&ast::obj_field f) -> common::span {ret f.ty.span;}\n             auto f = print_field;\n             auto gs = get_span;\n-            commasep_cmnt[ast.obj_field](s, _obj.fields, f, gs);\n+            commasep_cmnt[ast::obj_field](s, _obj.fields, f, gs);\n             pclose(s);\n             space(s.s);\n             bopen(s);\n-            for (@ast.method meth in _obj.methods) {\n+            for (@ast::method meth in _obj.methods) {\n                 hbox(s);\n-                let vec[ast.ty_param] typarams = vec();\n+                let vec[ast::ty_param] typarams = vec();\n                 maybe_print_comment(s, meth.span.lo);\n                 print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n                 space(s.s);\n@@ -315,7 +317,7 @@ fn print_item(ps s, @ast.item item) {\n                 line(s.s);\n             }\n             alt (_obj.dtor) {\n-                case (Option.some[@ast.method](?dtor)) {\n+                case (option::some[@ast::method](?dtor)) {\n                     hbox(s);\n                     wrd1(s, \"close\");\n                     print_block(s, dtor.node.meth.body);\n@@ -332,20 +334,20 @@ fn print_item(ps s, @ast.item item) {\n     line(s.s);\n }\n \n-fn print_block(ps s, ast.block blk) {\n+fn print_block(ps s, ast::block blk) {\n     maybe_print_comment(s, blk.span.lo);\n     bopen(s);\n-    for (@ast.stmt st in blk.node.stmts) {\n+    for (@ast::stmt st in blk.node.stmts) {\n         maybe_print_comment(s, st.span.lo);\n         alt (st.node) {\n-          case (ast.stmt_decl(?decl,_)) {print_decl(s, decl);}\n-          case (ast.stmt_expr(?expr,_)) {print_expr(s, expr);}\n+          case (ast::stmt_decl(?decl,_)) {print_decl(s, decl);}\n+          case (ast::stmt_expr(?expr,_)) {print_expr(s, expr);}\n         }\n-        if (front.parser.stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n+        if (front::parser::stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n         if (!maybe_print_line_comment(s, st.span)) {line(s.s);}\n     }\n     alt (blk.node.expr) {\n-        case (Option.some[@ast.expr](?expr)) {\n+        case (option::some[@ast::expr](?expr)) {\n             print_expr(s, expr);\n             if (!maybe_print_line_comment(s, expr.span)) {line(s.s);}\n         }\n@@ -354,87 +356,87 @@ fn print_block(ps s, ast.block blk) {\n     bclose_c(s, blk.span);\n }\n \n-fn print_literal(ps s, @ast.lit lit) {\n+fn print_literal(ps s, @ast::lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt (lit.node) {\n-        case (ast.lit_str(?st)) {print_string(s, st);}\n-        case (ast.lit_char(?ch)) {\n-            wrd(s.s, \"'\" + escape_str(Str.from_bytes(vec(ch as u8)), '\\'')\n+        case (ast::lit_str(?st)) {print_string(s, st);}\n+        case (ast::lit_char(?ch)) {\n+            wrd(s.s, \"'\" + escape_str(_str::from_bytes(vec(ch as u8)), '\\'')\n                 + \"'\");\n         }\n-        case (ast.lit_int(?val)) {\n-            wrd(s.s, common.istr(val));\n+        case (ast::lit_int(?val)) {\n+            wrd(s.s, common::istr(val));\n         }\n-        case (ast.lit_uint(?val)) { // FIXME clipping? uistr?\n-            wrd(s.s, common.istr(val as int) + \"u\");\n+        case (ast::lit_uint(?val)) { // FIXME clipping? uistr?\n+            wrd(s.s, common::istr(val as int) + \"u\");\n         }\n-        case (ast.lit_float(?fstr)) {\n+        case (ast::lit_float(?fstr)) {\n             wrd(s.s, fstr);\n         }\n-        case (ast.lit_mach_int(?mach,?val)) {\n-            wrd(s.s, common.istr(val as int));\n-            wrd(s.s, common.ty_mach_to_str(mach));\n+        case (ast::lit_mach_int(?mach,?val)) {\n+            wrd(s.s, common::istr(val as int));\n+            wrd(s.s, common::ty_mach_to_str(mach));\n         }\n-        case (ast.lit_mach_float(?mach,?val)) {\n+        case (ast::lit_mach_float(?mach,?val)) {\n             // val is already a str\n             wrd(s.s, val);\n-            wrd(s.s, common.ty_mach_to_str(mach));\n+            wrd(s.s, common::ty_mach_to_str(mach));\n         }\n-        case (ast.lit_nil) {wrd(s.s, \"()\");}\n-        case (ast.lit_bool(?val)) {\n+        case (ast::lit_nil) {wrd(s.s, \"()\");}\n+        case (ast::lit_bool(?val)) {\n             if (val) {wrd(s.s, \"true\");} else {wrd(s.s, \"false\");}\n         }\n     }\n }\n \n-fn print_expr(ps s, &@ast.expr expr) {\n+fn print_expr(ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n     hbox(s);\n     alt (expr.node) {\n-        case (ast.expr_vec(?exprs,?mut,_)) {\n-            if (mut == ast.mut) {\n+        case (ast::expr_vec(?exprs,?mut,_)) {\n+            if (mut == ast::mut) {\n                 wrd1(s, \"mutable\");\n             }\n             wrd(s.s, \"vec\");\n             popen(s);\n             commasep_exprs(s, exprs);\n             pclose(s);\n         }\n-        case (ast.expr_tup(?exprs,_)) {\n-            fn printElt(ps s, &ast.elt elt) {\n+        case (ast::expr_tup(?exprs,_)) {\n+            fn printElt(ps s, &ast::elt elt) {\n                 hbox(s);\n-                if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n+                if (elt.mut == ast::mut) {wrd1(s, \"mutable\");}\n                 print_expr(s, elt.expr);\n                 end(s.s);\n             }\n-            fn get_span(&ast.elt elt) -> common.span {ret elt.expr.span;}\n+            fn get_span(&ast::elt elt) -> common::span {ret elt.expr.span;}\n             wrd(s.s, \"tup\");\n             popen(s);\n             auto f = printElt;\n             auto gs = get_span;\n-            commasep_cmnt[ast.elt](s, exprs, f, gs);\n+            commasep_cmnt[ast::elt](s, exprs, f, gs);\n             pclose(s);\n         }\n-        case (ast.expr_rec(?fields,?wth,_)) {\n-            fn print_field(ps s, &ast.field field) {\n+        case (ast::expr_rec(?fields,?wth,_)) {\n+            fn print_field(ps s, &ast::field field) {\n                 hbox(s);\n-                if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n+                if (field.mut == ast::mut) {wrd1(s, \"mutable\");}\n                 wrd(s.s, field.ident);\n                 wrd(s.s, \"=\");\n                 print_expr(s, field.expr);\n                 end(s.s);\n             }\n-            fn get_span(&ast.field field) -> common.span {\n+            fn get_span(&ast::field field) -> common::span {\n                 ret field.expr.span;\n             }\n             wrd(s.s, \"rec\");\n             popen(s);\n             auto f = print_field;\n             auto gs = get_span;\n-            commasep_cmnt[ast.field](s, fields, f, gs);\n+            commasep_cmnt[ast::field](s, fields, f, gs);\n             alt (wth) {\n-                case (Option.some[@ast.expr](?expr)) {\n-                    if (Vec.len[ast.field](fields) > 0u) {space(s.s);}\n+                case (option::some[@ast::expr](?expr)) {\n+                    if (_vec::len[ast::field](fields) > 0u) {space(s.s);}\n                     hbox(s);\n                     wrd1(s, \"with\");\n                     print_expr(s, expr);\n@@ -444,20 +446,20 @@ fn print_expr(ps s, &@ast.expr expr) {\n             }\n             pclose(s);\n         }\n-        case (ast.expr_call(?func,?args,_)) {\n+        case (ast::expr_call(?func,?args,_)) {\n             print_expr(s, func);\n             popen(s);\n             commasep_exprs(s, args);\n             pclose(s);\n         }\n-        case (ast.expr_self_method(?ident,_)) {\n+        case (ast::expr_self_method(?ident,_)) {\n             wrd(s.s, \"self.\");\n             print_ident(s, ident);\n         }\n-        case (ast.expr_bind(?func,?args,_)) {\n-            fn print_opt(ps s, &Option.t[@ast.expr] expr) {\n+        case (ast::expr_bind(?func,?args,_)) {\n+            fn print_opt(ps s, &option::t[@ast::expr] expr) {\n                 alt (expr) {\n-                    case (Option.some[@ast.expr](?expr)) {\n+                    case (option::some[@ast::expr](?expr)) {\n                         print_expr(s, expr);\n                     }\n                     case (_) {wrd(s.s, \"_\");}\n@@ -467,61 +469,61 @@ fn print_expr(ps s, &@ast.expr expr) {\n             print_expr(s, func);\n             popen(s);\n             auto f = print_opt;\n-            commasep[Option.t[@ast.expr]](s, args, f);\n+            commasep[option::t[@ast::expr]](s, args, f);\n             pclose(s);\n         }\n-    case (ast.expr_spawn(_,_,?e,?es,_)) {\n+    case (ast::expr_spawn(_,_,?e,?es,_)) {\n           wrd1(s, \"spawn\");\n           print_expr(s, e);\n           popen(s);\n           commasep_exprs(s, es);\n           pclose(s);\n         }\n-        case (ast.expr_binary(?op,?lhs,?rhs,_)) {\n+        case (ast::expr_binary(?op,?lhs,?rhs,_)) {\n             auto prec = operator_prec(op);\n             print_maybe_parens(s, lhs, prec);\n             space(s.s);\n-            wrd1(s, ast.binop_to_str(op));\n+            wrd1(s, ast::binop_to_str(op));\n             print_maybe_parens(s, rhs, prec + 1);\n         }\n-        case (ast.expr_unary(?op,?expr,_)) {\n-            wrd(s.s, ast.unop_to_str(op));\n+        case (ast::expr_unary(?op,?expr,_)) {\n+            wrd(s.s, ast::unop_to_str(op));\n             print_expr(s, expr);\n         }\n-        case (ast.expr_lit(?lit,_)) {\n+        case (ast::expr_lit(?lit,_)) {\n             print_literal(s, lit);\n         }\n-        case (ast.expr_cast(?expr,?ty,_)) {\n+        case (ast::expr_cast(?expr,?ty,_)) {\n             print_maybe_parens(s, expr, as_prec);\n             space(s.s);\n             wrd1(s, \"as\");\n             print_type(s, ty);\n         }\n-        case (ast.expr_if(?test,?block,?elseopt,_)) {\n+        case (ast::expr_if(?test,?block,?elseopt,_)) {\n             wrd1(s, \"if\");\n             popen_h(s);\n             print_expr(s, test);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n             alt (elseopt) {\n-                case (Option.some[@ast.expr](?_else)) {\n+                case (option::some[@ast::expr](?_else)) {\n                     space(s.s);\n                     wrd1(s, \"else\");\n                     print_expr(s, _else);\n                 }\n                 case (_) { /* fall through */ }\n             }\n         }\n-        case (ast.expr_while(?test,?block,_)) {\n+        case (ast::expr_while(?test,?block,_)) {\n             wrd1(s, \"while\");\n             popen_h(s);\n             print_expr(s, test);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast.expr_for(?decl,?expr,?block,_)) {\n+        case (ast::expr_for(?decl,?expr,?block,_)) {\n             wrd1(s, \"for\");\n             popen_h(s);\n             print_for_decl(s, decl);\n@@ -532,7 +534,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast.expr_for_each(?decl,?expr,?block,_)) {\n+        case (ast::expr_for_each(?decl,?expr,?block,_)) {\n             wrd1(s, \"for each\");\n             popen_h(s);\n             print_for_decl(s, decl);\n@@ -543,7 +545,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast.expr_do_while(?block,?expr,_)) {\n+        case (ast::expr_do_while(?block,?expr,_)) {\n             wrd1(s, \"do\");\n             space(s.s);\n             print_block(s, block);\n@@ -553,14 +555,14 @@ fn print_expr(ps s, &@ast.expr expr) {\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast.expr_alt(?expr,?arms,_)) {\n+        case (ast::expr_alt(?expr,?arms,_)) {\n             wrd1(s, \"alt\");\n             popen_h(s);\n             print_expr(s, expr);\n             pclose(s);\n             space(s.s);\n             bopen(s);\n-            for (ast.arm arm in arms) {\n+            for (ast::arm arm in arms) {\n                 hbox(s);\n                 wrd1(s, \"case\");\n                 popen_h(s);\n@@ -573,117 +575,117 @@ fn print_expr(ps s, &@ast.expr expr) {\n             }\n             bclose_c(s, expr.span);\n         }\n-        case (ast.expr_block(?block,_)) {\n+        case (ast::expr_block(?block,_)) {\n             print_block(s, block);\n         }\n-        case (ast.expr_assign(?lhs,?rhs,_)) {\n+        case (ast::expr_assign(?lhs,?rhs,_)) {\n             print_expr(s, lhs);\n             space(s.s);\n             wrd1(s, \"=\");\n             print_expr(s, rhs);\n         }\n-        case (ast.expr_assign_op(?op,?lhs,?rhs,_)) {\n+        case (ast::expr_assign_op(?op,?lhs,?rhs,_)) {\n             print_expr(s, lhs);\n             space(s.s);\n-            wrd(s.s, ast.binop_to_str(op));\n+            wrd(s.s, ast::binop_to_str(op));\n             wrd1(s, \"=\");\n             print_expr(s, rhs);\n         }\n-        case (ast.expr_send(?lhs, ?rhs, _)) {\n+        case (ast::expr_send(?lhs, ?rhs, _)) {\n             print_expr(s, lhs);\n             space(s.s);\n             wrd1(s, \"<|\");\n             print_expr(s, rhs);\n         }\n-        case (ast.expr_recv(?lhs, ?rhs, _)) {\n+        case (ast::expr_recv(?lhs, ?rhs, _)) {\n             print_expr(s, lhs);\n             space(s.s);\n             wrd1(s, \"<-\");\n             print_expr(s, rhs);\n         }\n-        case (ast.expr_field(?expr,?id,_)) {\n+        case (ast::expr_field(?expr,?id,_)) {\n             print_expr(s, expr);\n             wrd(s.s, \".\");\n             wrd(s.s, id);\n         }\n-        case (ast.expr_index(?expr,?index,_)) {\n+        case (ast::expr_index(?expr,?index,_)) {\n             print_expr(s, expr);\n             wrd(s.s, \".\");\n             popen_h(s);\n             print_expr(s, index);\n             pclose(s);\n         }\n-        case (ast.expr_path(?path,_)) {\n+        case (ast::expr_path(?path,_)) {\n             print_path(s, path);\n         }\n-        case (ast.expr_fail(_)) {\n+        case (ast::expr_fail(_)) {\n             wrd(s.s, \"fail\");\n         }\n-        case (ast.expr_break(_)) {\n+        case (ast::expr_break(_)) {\n             wrd(s.s, \"break\");\n         }\n-        case (ast.expr_cont(_)) {\n+        case (ast::expr_cont(_)) {\n             wrd(s.s, \"cont\");\n         }\n-        case (ast.expr_ret(?result,_)) {\n+        case (ast::expr_ret(?result,_)) {\n             wrd(s.s, \"ret\");\n             alt (result) {\n-                case (Option.some[@ast.expr](?expr)) {\n+                case (option::some[@ast::expr](?expr)) {\n                     space(s.s);\n                     print_expr(s, expr);\n                 }\n                 case (_) {}\n             }\n         }\n-        case (ast.expr_put(?result,_)) {\n+        case (ast::expr_put(?result,_)) {\n             wrd(s.s, \"put\");\n             alt (result) {\n-                case (Option.some[@ast.expr](?expr)) {\n+                case (option::some[@ast::expr](?expr)) {\n                     space(s.s);\n                     print_expr(s, expr);\n                 }\n                 case (_) {}\n             }\n         }\n-        case (ast.expr_be(?result,_)) {\n+        case (ast::expr_be(?result,_)) {\n             wrd1(s, \"be\");\n             print_expr(s, result);\n         }\n-        case (ast.expr_log(?lvl,?expr,_)) {\n+        case (ast::expr_log(?lvl,?expr,_)) {\n             alt (lvl) {\n                 case (1) {wrd1(s, \"log\");}\n                 case (0) {wrd1(s, \"log_err\");}\n             }\n             print_expr(s, expr);\n         }\n-        case (ast.expr_check(?expr,_)) {\n+        case (ast::expr_check(?expr,_)) {\n             wrd1(s, \"check\");\n             popen_h(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast.expr_assert(?expr,_)) {\n+        case (ast::expr_assert(?expr,_)) {\n             wrd1(s, \"assert\");\n             popen_h(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n+        case (ast::expr_ext(?path, ?args, ?body, _, _)) {\n             wrd(s.s, \"#\");\n             print_path(s, path);\n-            if (Vec.len[@ast.expr](args) > 0u) {\n+            if (_vec::len[@ast::expr](args) > 0u) {\n                 popen(s);\n                 commasep_exprs(s, args);\n                 pclose(s);\n             }\n             // FIXME: extension 'body'\n         }\n-        case (ast.expr_port(_)) {\n+        case (ast::expr_port(_)) {\n             wrd(s.s, \"port\");\n             popen_h(s);\n             pclose(s);\n         }\n-        case (ast.expr_chan(?expr, _)) {\n+        case (ast::expr_chan(?expr, _)) {\n             wrd(s.s, \"chan\");\n             popen_h(s);\n             print_expr(s, expr);\n@@ -693,13 +695,13 @@ fn print_expr(ps s, &@ast.expr expr) {\n     end(s.s);\n }\n \n-fn print_decl(ps s, @ast.decl decl) {\n+fn print_decl(ps s, @ast::decl decl) {\n     maybe_print_comment(s, decl.span.lo);\n     hbox(s);\n     alt (decl.node) {\n-        case (ast.decl_local(?loc)) {\n+        case (ast::decl_local(?loc)) {\n             alt (loc.ty) {\n-                case (Option.some[@ast.ty](?ty)) {\n+                case (option::some[@ast::ty](?ty)) {\n                     wrd1(s, \"let\");\n                     print_type(s, ty);\n                     space(s.s);\n@@ -710,13 +712,13 @@ fn print_decl(ps s, @ast.decl decl) {\n             }\n             wrd(s.s, loc.ident);\n             alt (loc.init) {\n-                case (Option.some[ast.initializer](?init)) {\n+                case (option::some[ast::initializer](?init)) {\n                     space(s.s);\n                     alt (init.op) {\n-                        case (ast.init_assign) {\n+                        case (ast::init_assign) {\n                             wrd1(s, \"=\");\n                         }\n-                        case (ast.init_recv) {\n+                        case (ast::init_recv) {\n                             wrd1(s, \"<-\");\n                         }\n                     }\n@@ -725,65 +727,65 @@ fn print_decl(ps s, @ast.decl decl) {\n                 case (_) {}\n             }\n         }\n-        case (ast.decl_item(?item)) {\n+        case (ast::decl_item(?item)) {\n             print_item(s, item);\n         }\n     }\n     end(s.s);\n }\n \n-fn print_ident(ps s, ast.ident ident) {\n+fn print_ident(ps s, ast::ident ident) {\n     wrd(s.s, ident);\n }\n \n-fn print_for_decl(ps s, @ast.decl decl) {\n+fn print_for_decl(ps s, @ast::decl decl) {\n     alt (decl.node) {\n-        case (ast.decl_local(?loc)) {\n-            print_type(s, Option.get[@ast.ty](loc.ty));\n+        case (ast::decl_local(?loc)) {\n+            print_type(s, option::get[@ast::ty](loc.ty));\n             space(s.s);\n             wrd(s.s, loc.ident);\n         }\n     }\n }\n \n-fn print_path(ps s, ast.path path) {\n+fn print_path(ps s, ast::path path) {\n     maybe_print_comment(s, path.span.lo);\n     auto first = true;\n     for (str id in path.node.idents) {\n         if (first) {first = false;}\n         else {wrd(s.s, \"::\");}\n         wrd(s.s, id);\n     }\n-    if (Vec.len[@ast.ty](path.node.types) > 0u) {\n+    if (_vec::len[@ast::ty](path.node.types) > 0u) {\n         wrd(s.s, \"[\");\n         auto f = print_type;\n-        commasep[@ast.ty](s, path.node.types, f);\n+        commasep[@ast::ty](s, path.node.types, f);\n         wrd(s.s, \"]\");\n     }\n }\n \n-fn print_pat(ps s, &@ast.pat pat) {\n+fn print_pat(ps s, &@ast::pat pat) {\n     maybe_print_comment(s, pat.span.lo);\n     alt (pat.node) {\n-        case (ast.pat_wild(_)) {wrd(s.s, \"_\");}\n-        case (ast.pat_bind(?id,_,_)) {wrd(s.s, \"?\" + id);}\n-        case (ast.pat_lit(?lit,_)) {print_literal(s, lit);}\n-        case (ast.pat_tag(?path,?args,_)) {\n+        case (ast::pat_wild(_)) {wrd(s.s, \"_\");}\n+        case (ast::pat_bind(?id,_,_)) {wrd(s.s, \"?\" + id);}\n+        case (ast::pat_lit(?lit,_)) {print_literal(s, lit);}\n+        case (ast::pat_tag(?path,?args,_)) {\n             print_path(s, path);\n-            if (Vec.len[@ast.pat](args) > 0u) {\n+            if (_vec::len[@ast::pat](args) > 0u) {\n                 popen_h(s);\n                 auto f = print_pat;\n-                commasep[@ast.pat](s, args, f);\n+                commasep[@ast::pat](s, args, f);\n                 pclose(s);\n             }\n         }\n     }\n }\n \n-fn print_fn(ps s, ast.fn_decl decl, str name,\n-                   vec[ast.ty_param] typarams) {\n+fn print_fn(ps s, ast::fn_decl decl, str name,\n+                   vec[ast::ty_param] typarams) {\n     alt (decl.purity) {\n-        case (ast.impure_fn) {\n+        case (ast::impure_fn) {\n             wrd1(s, \"fn\");\n         }\n         case (_) {\n@@ -793,19 +795,19 @@ fn print_fn(ps s, ast.fn_decl decl, str name,\n     wrd(s.s, name);\n     print_type_params(s, typarams);\n     popen(s);\n-    fn print_arg(ps s, &ast.arg x) {\n+    fn print_arg(ps s, &ast::arg x) {\n         hbox(s);\n-        if (x.mode == ast.alias) {wrd(s.s, \"&\");}\n+        if (x.mode == ast::alias) {wrd(s.s, \"&\");}\n         print_type(s, x.ty);\n         space(s.s);\n         wrd(s.s, x.ident);\n         end(s.s);\n     }\n     auto f = print_arg;\n-    commasep[ast.arg](s, decl.inputs, f);\n+    commasep[ast::arg](s, decl.inputs, f);\n     pclose(s);\n     maybe_print_comment(s, decl.output.span.lo);\n-    if (decl.output.node != ast.ty_nil) {\n+    if (decl.output.node != ast::ty_nil) {\n         space(s.s);\n         hbox(s);\n         wrd1(s, \"->\");\n@@ -814,42 +816,42 @@ fn print_fn(ps s, ast.fn_decl decl, str name,\n     }\n }\n \n-fn print_type_params(ps s, vec[ast.ty_param] params) {\n-    if (Vec.len[ast.ty_param](params) > 0u) {\n+fn print_type_params(ps s, vec[ast::ty_param] params) {\n+    if (_vec::len[ast::ty_param](params) > 0u) {\n         wrd(s.s, \"[\");\n-        fn printParam(ps s, &ast.ty_param param) {\n+        fn printParam(ps s, &ast::ty_param param) {\n             wrd(s.s, param);\n         }\n         auto f = printParam;\n-        commasep[ast.ty_param](s, params, f);\n+        commasep[ast::ty_param](s, params, f);\n         wrd(s.s, \"]\");\n     }\n }\n \n-fn print_view_item(ps s, @ast.view_item item) {\n+fn print_view_item(ps s, @ast::view_item item) {\n     maybe_print_comment(s, item.span.lo);\n     hbox(s);\n     alt (item.node) {\n-        case (ast.view_item_use(?id,?mta,_,_)) {\n+        case (ast::view_item_use(?id,?mta,_,_)) {\n             wrd1(s, \"use\");\n             wrd(s.s, id);\n-            if (Vec.len[@ast.meta_item](mta) > 0u) {\n+            if (_vec::len[@ast::meta_item](mta) > 0u) {\n                 popen(s);\n-                fn print_meta(ps s, &@ast.meta_item item) {\n+                fn print_meta(ps s, &@ast::meta_item item) {\n                     hbox(s);\n                     wrd1(s, item.node.name);\n                     wrd1(s, \"=\");\n                     print_string(s, item.node.value);\n                     end(s.s);\n                 }\n                 auto f = print_meta;\n-                commasep[@ast.meta_item](s, mta, f);\n+                commasep[@ast::meta_item](s, mta, f);\n                 pclose(s);\n             }\n         }\n-        case (ast.view_item_import(?id,?ids,_)) {\n+        case (ast::view_item_import(?id,?ids,_)) {\n             wrd1(s, \"import\");\n-            if (!Str.eq(id, ids.(Vec.len[str](ids)-1u))) {\n+            if (!_str::eq(id, ids.(_vec::len[str](ids)-1u))) {\n                 wrd1(s, id);\n                 wrd1(s, \"=\");\n             }\n@@ -860,7 +862,7 @@ fn print_view_item(ps s, @ast.view_item item) {\n                 wrd(s.s, elt);\n             }\n         }\n-        case (ast.view_item_export(?id)) {\n+        case (ast::view_item_export(?id)) {\n             wrd1(s, \"export\");\n             wrd(s.s, id);\n         }\n@@ -872,20 +874,20 @@ fn print_view_item(ps s, @ast.view_item item) {\n \n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n-fn operator_prec(ast.binop op) -> int {\n-    for (front.parser.op_spec spec in front.parser.prec_table()) {\n+fn operator_prec(ast::binop op) -> int {\n+    for (front::parser::op_spec spec in front::parser::prec_table()) {\n         if (spec.op == op) {ret spec.prec;}\n     }\n     fail;\n }\n \n-fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n+fn print_maybe_parens(ps s, @ast::expr expr, int outer_prec) {\n     auto add_them;\n     alt (expr.node) {\n-        case (ast.expr_binary(?op,_,_,_)) {\n+        case (ast::expr_binary(?op,_,_,_)) {\n             add_them = operator_prec(op) < outer_prec;\n         }\n-        case (ast.expr_cast(_,_,_)) {\n+        case (ast::expr_cast(_,_,_)) {\n             add_them = as_prec < outer_prec;\n         }\n         case (_) {\n@@ -899,7 +901,7 @@ fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n \n fn escape_str(str st, char to_escape) -> str {\n     let str out = \"\";\n-    auto len = Str.byte_len(st);\n+    auto len = _str::byte_len(st);\n     auto i = 0u;\n     while (i < len) {\n         alt (st.(i) as char) {\n@@ -909,19 +911,19 @@ fn escape_str(str st, char to_escape) -> str {\n             case ('\\\\') {out += \"\\\\\\\\\";}\n             case (?cur) {\n                 if (cur == to_escape) {out += \"\\\\\";}\n-                Str.push_byte(out, cur as u8);\n+                _str::push_byte(out, cur as u8);\n             }\n         }\n         i += 1u;\n     }\n     ret out;\n }\n \n-fn print_mt(ps s, &ast.mt mt) {\n+fn print_mt(ps s, &ast::mt mt) {\n     alt (mt.mut) {\n-        case (ast.mut)       { wrd1(s, \"mutable\");  }\n-        case (ast.maybe_mut) { wrd1(s, \"mutable?\"); }\n-        case (ast.imm)       { /* nothing */        }\n+        case (ast::mut)       { wrd1(s, \"mutable\");  }\n+        case (ast::maybe_mut) { wrd1(s, \"mutable?\"); }\n+        case (ast::imm)       { /* nothing */        }\n     }\n     print_type(s, mt.ty);\n }\n@@ -930,24 +932,24 @@ fn print_string(ps s, str st) {\n     wrd(s.s, \"\\\"\"); wrd(s.s, escape_str(st, '\"')); wrd(s.s, \"\\\"\");\n }\n \n-fn print_ty_fn(ps s, ast.proto proto, Option.t[str] id,\n-               vec[ast.ty_arg] inputs, @ast.ty output) {\n-    if (proto == ast.proto_fn) {wrd(s.s, \"fn\");}\n+fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n+               vec[ast::ty_arg] inputs, @ast::ty output) {\n+    if (proto == ast::proto_fn) {wrd(s.s, \"fn\");}\n     else {wrd(s.s, \"iter\");}\n     alt (id) {\n-        case (Option.some[str](?id)) {space(s.s); wrd(s.s, id);}\n+        case (option::some[str](?id)) {space(s.s); wrd(s.s, id);}\n         case (_) {}\n     }\n     popen_h(s);\n-    fn print_arg(ps s, &ast.ty_arg input) {\n-        if (input.mode == ast.alias) {wrd(s.s, \"&\");}\n+    fn print_arg(ps s, &ast::ty_arg input) {\n+        if (input.mode == ast::alias) {wrd(s.s, \"&\");}\n         print_type(s, input.ty);\n     }\n     auto f = print_arg;\n-    commasep[ast.ty_arg](s, inputs, f);\n+    commasep[ast::ty_arg](s, inputs, f);\n     pclose(s);\n     maybe_print_comment(s, output.span.lo);\n-    if (output.node != ast.ty_nil) {\n+    if (output.node != ast::ty_nil) {\n         space(s.s);\n         hbox(s);\n         wrd1(s, \"->\");\n@@ -956,21 +958,21 @@ fn print_ty_fn(ps s, ast.proto proto, Option.t[str] id,\n     }\n }\n \n-fn next_comment(ps s) -> Option.t[lexer.cmnt] {\n+fn next_comment(ps s) -> option::t[lexer::cmnt] {\n     alt (s.comments) {\n-        case (Option.some[vec[lexer.cmnt]](?cmnts)) {\n-            if (s.cur_cmnt < Vec.len[lexer.cmnt](cmnts)) {\n-                ret Option.some[lexer.cmnt](cmnts.(s.cur_cmnt));\n-            } else {ret Option.none[lexer.cmnt];}\n+        case (option::some[vec[lexer::cmnt]](?cmnts)) {\n+            if (s.cur_cmnt < _vec::len[lexer::cmnt](cmnts)) {\n+                ret option::some[lexer::cmnt](cmnts.(s.cur_cmnt));\n+            } else {ret option::none[lexer::cmnt];}\n         }\n-        case (_) {ret Option.none[lexer.cmnt];}\n+        case (_) {ret option::none[lexer::cmnt];}\n     }\n }\n \n fn maybe_print_comment(ps s, uint pos) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (Option.some[lexer.cmnt](?cmnt)) {\n+            case (option::some[lexer::cmnt](?cmnt)) {\n                 if (cmnt.pos < pos) {\n                     print_comment(s, cmnt.val);\n                     if (cmnt.space_after) {line(s.s);}\n@@ -982,9 +984,9 @@ fn maybe_print_comment(ps s, uint pos) {\n     }\n }\n \n-fn maybe_print_line_comment(ps s, common.span span) -> bool {\n+fn maybe_print_line_comment(ps s, common::span span) -> bool {\n     alt (next_comment(s)) {\n-        case (Option.some[lexer.cmnt](?cmnt)) {\n+        case (option::some[lexer::cmnt](?cmnt)) {\n             if (span.hi + 4u >= cmnt.pos) {\n                 wrd(s.s, \" \");\n                 print_comment(s, cmnt.val);\n@@ -1000,7 +1002,7 @@ fn maybe_print_line_comment(ps s, common.span span) -> bool {\n fn print_remaining_comments(ps s) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (Option.some[lexer.cmnt](?cmnt)) {\n+            case (option::some[lexer::cmnt](?cmnt)) {\n                 print_comment(s, cmnt.val);\n                 if (cmnt.space_after) {line(s.s);}\n                 s.cur_cmnt += 1u;\n@@ -1010,20 +1012,20 @@ fn print_remaining_comments(ps s) {\n     }\n }\n \n-fn print_comment(ps s, lexer.cmnt_ cmnt) {\n+fn print_comment(ps s, lexer::cmnt_ cmnt) {\n     alt (cmnt) {\n-        case (lexer.cmnt_line(?val)) {\n+        case (lexer::cmnt_line(?val)) {\n             wrd(s.s, \"// \" + val);\n-            pp.hardbreak(s.s);\n+            pp::hardbreak(s.s);\n         }\n-        case (lexer.cmnt_block(?lines)) {\n-            pp.abox(s.s);\n+        case (lexer::cmnt_block(?lines)) {\n+            pp::abox(s.s);\n             wrd(s.s, \"/* \");\n-            pp.abox(s.s);\n+            pp::abox(s.s);\n             auto first = true;\n             for (str ln in lines) {\n                 if (first) {first = false;}\n-                else {pp.hardbreak(s.s);}\n+                else {pp::hardbreak(s.s);}\n                 wrd(s.s, ln);\n             }\n             end(s.s);"}, {"sha": "1e619b293f9387e8c1fb13715d67be06221b5a6e", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -55,11 +55,11 @@ mod util {\n     mod typestate_ann;\n }\n \n-auth front.creader.load_crate = unsafe;\n-auth front.creader.get_metadata_section = unsafe;\n-auth middle.metadata = unsafe;\n-auth middle.trans = unsafe;\n-auth lib.llvm = unsafe;\n+auth front::creader::load_crate = unsafe;\n+auth front::creader::get_metadata_section = unsafe;\n+auth middle::metadata = unsafe;\n+auth middle::trans = unsafe;\n+auth lib::llvm = unsafe;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "dc5e6d0897e3c8887952fe43a1bfee54db5af301", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,23 +1,23 @@\n-import std.Map;\n-import std.Map.hashmap;\n-import std.UInt;\n-import std.Int;\n-import std.Vec;\n-import std.Option.none;\n-import front.ast;\n-import util.typestate_ann.ts_ann;\n-\n-import middle.fold;\n-import middle.fold.respan;\n-\n-import std.IO.stdout;\n-import std.IO.str_writer;\n-import std.IO.string_writer;\n-import pretty.pprust.print_block;\n-import pretty.pprust.print_expr;\n-import pretty.pprust.print_decl;\n-import pretty.pprust.print_fn;\n-import pretty.pp.mkstate;\n+import std::map;\n+import std::map::hashmap;\n+import std::_uint;\n+import std::_int;\n+import std::_vec;\n+import std::option::none;\n+import front::ast;\n+import util::typestate_ann::ts_ann;\n+\n+import middle::fold;\n+import middle::fold::respan;\n+\n+import std::io::stdout;\n+import std::io::str_writer;\n+import std::io::string_writer;\n+import pretty::pprust::print_block;\n+import pretty::pprust::print_expr;\n+import pretty::pprust::print_decl;\n+import pretty::pprust::print_fn;\n+import pretty::pp::mkstate;\n \n type filename = str;\n type span = rec(uint lo, uint hi);\n@@ -56,221 +56,221 @@ fn ty_mach_to_str(ty_mach tm) -> str {\n     }\n }\n \n-fn new_str_hash[V]() -> std.Map.hashmap[str,V] {\n-    let std.Map.hashfn[str] hasher = std.Str.hash;\n-    let std.Map.eqfn[str] eqer = std.Str.eq;\n-    ret std.Map.mk_hashmap[str,V](hasher, eqer);\n+fn new_str_hash[V]() -> std::map::hashmap[str,V] {\n+    let std::map::hashfn[str] hasher = std::_str::hash;\n+    let std::map::eqfn[str] eqer = std::_str::eq;\n+    ret std::map::mk_hashmap[str,V](hasher, eqer);\n }\n \n-fn def_eq(&ast.def_id a, &ast.def_id b) -> bool {\n+fn def_eq(&ast::def_id a, &ast::def_id b) -> bool {\n     ret a._0 == b._0 && a._1 == b._1;\n }\n \n-fn hash_def(&ast.def_id d) -> uint {\n+fn hash_def(&ast::def_id d) -> uint {\n     auto h = 5381u;\n     h = ((h << 5u) + h) ^ (d._0 as uint);\n     h = ((h << 5u) + h) ^ (d._1 as uint);\n     ret h;\n }\n \n-fn new_def_hash[V]() -> std.Map.hashmap[ast.def_id,V] {\n-    let std.Map.hashfn[ast.def_id] hasher = hash_def;\n-    let std.Map.eqfn[ast.def_id] eqer = def_eq;\n-    ret std.Map.mk_hashmap[ast.def_id,V](hasher, eqer);\n+fn new_def_hash[V]() -> std::map::hashmap[ast::def_id,V] {\n+    let std::map::hashfn[ast::def_id] hasher = hash_def;\n+    let std::map::eqfn[ast::def_id] eqer = def_eq;\n+    ret std::map::mk_hashmap[ast::def_id,V](hasher, eqer);\n }\n \n-fn new_int_hash[V]() -> std.Map.hashmap[int,V] {\n+fn new_int_hash[V]() -> std::map::hashmap[int,V] {\n     fn hash_int(&int x) -> uint { ret x as uint; }\n     fn eq_int(&int a, &int b) -> bool { ret a == b; }\n     auto hasher = hash_int;\n     auto eqer = eq_int;\n-    ret std.Map.mk_hashmap[int,V](hasher, eqer);\n+    ret std::map::mk_hashmap[int,V](hasher, eqer);\n }\n \n-fn new_uint_hash[V]() -> std.Map.hashmap[uint,V] {\n+fn new_uint_hash[V]() -> std::map::hashmap[uint,V] {\n     fn hash_uint(&uint x) -> uint { ret x; }\n     fn eq_uint(&uint a, &uint b) -> bool { ret a == b; }\n     auto hasher = hash_uint;\n     auto eqer = eq_uint;\n-    ret std.Map.mk_hashmap[uint,V](hasher, eqer);\n+    ret std::map::mk_hashmap[uint,V](hasher, eqer);\n }\n \n fn istr(int i) -> str {\n-    ret Int.to_str(i, 10u);\n+    ret _int::to_str(i, 10u);\n }\n \n fn uistr(uint i) -> str {\n-    ret UInt.to_str(i, 10u);\n+    ret _uint::to_str(i, 10u);\n }\n \n-fn elt_expr(&ast.elt e) -> @ast.expr { ret e.expr; }\n+fn elt_expr(&ast::elt e) -> @ast::expr { ret e.expr; }\n \n-fn elt_exprs(&vec[ast.elt] elts) -> vec[@ast.expr] {\n+fn elt_exprs(&vec[ast::elt] elts) -> vec[@ast::expr] {\n     auto f = elt_expr;\n-    ret Vec.map[ast.elt, @ast.expr](f, elts);\n+    ret _vec::map[ast::elt, @ast::expr](f, elts);\n }\n \n-fn field_expr(&ast.field f) -> @ast.expr { ret f.expr; }\n+fn field_expr(&ast::field f) -> @ast::expr { ret f.expr; }\n \n-fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n+fn field_exprs(vec[ast::field] fields) -> vec [@ast::expr] {\n     auto f = field_expr;\n-    ret Vec.map[ast.field, @ast.expr](f, fields);\n+    ret _vec::map[ast::field, @ast::expr](f, fields);\n }\n \n-fn plain_ann(&ast.ann old, middle.ty.ctxt tcx) -> ast.ann {\n-    ret ast.ann_type(ast.ann_tag(old), middle.ty.mk_nil(tcx),\n-                   none[vec[middle.ty.t]], none[@ts_ann]);\n+fn plain_ann(&ast::ann old, middle::ty::ctxt tcx) -> ast::ann {\n+    ret ast::ann_type(ast::ann_tag(old), middle::ty::mk_nil(tcx),\n+                   none[vec[middle::ty::t]], none[@ts_ann]);\n }\n \n-fn expr_to_str(&@ast.expr e) -> str {\n+fn expr_to_str(&@ast::expr e) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n-                  comments=none[vec[front.lexer.cmnt]],\n+                  comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n   print_expr(out, e);\n   ret s.get_str();\n }\n \n-fn log_expr(&ast.expr e) -> () {\n+fn log_expr(&ast::expr e) -> () {\n     log(expr_to_str(@e));\n }\n \n-fn log_expr_err(&ast.expr e) -> () {\n+fn log_expr_err(&ast::expr e) -> () {\n     log_err(expr_to_str(@e));\n }\n \n-fn block_to_str(&ast.block b) -> str {\n+fn block_to_str(&ast::block b) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n-                  comments=none[vec[front.lexer.cmnt]],\n+                  comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n \n   print_block(out, b);\n   ret s.get_str();\n }\n \n-fn log_block(&ast.block b) -> () {\n+fn log_block(&ast::block b) -> () {\n     log(block_to_str(b));\n }\n \n-fn log_block_err(&ast.block b) -> () {\n+fn log_block_err(&ast::block b) -> () {\n     log_err(block_to_str(b));\n }\n \n-fn log_ann(&ast.ann a) -> () {\n+fn log_ann(&ast::ann a) -> () {\n     alt (a) {\n-        case (ast.ann_none(_)) {\n+        case (ast::ann_none(_)) {\n             log(\"ann_none\");\n         }\n-        case (ast.ann_type(_,_,_,_)) {\n+        case (ast::ann_type(_,_,_,_)) {\n             log(\"ann_type\");\n         }\n     }\n }\n \n-fn fun_to_str(&ast._fn f, str name, vec[ast.ty_param] params) -> str {\n+fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n  let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n-                  comments=none[vec[front.lexer.cmnt]],\n+                  comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n \n   print_fn(out, f.decl, name, params);\n   ret s.get_str();\n }\n \n-fn log_fn(&ast._fn f, str name, vec[ast.ty_param] params) -> () {\n+fn log_fn(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n     log(fun_to_str(f, name, params));\n }\n \n-fn log_fn_err(&ast._fn f, str name, vec[ast.ty_param] params) -> () {\n+fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n     log_err(fun_to_str(f, name, params));\n }\n \n-fn stmt_to_str(&ast.stmt st) -> str {\n+fn stmt_to_str(&ast::stmt st) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n-                  comments=none[vec[front.lexer.cmnt]],\n+                  comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u);\n   alt (st.node) {\n-    case (ast.stmt_decl(?decl,_)) {\n+    case (ast::stmt_decl(?decl,_)) {\n       print_decl(out, decl);\n     }\n-    case (ast.stmt_expr(?ex,_)) {\n+    case (ast::stmt_expr(?ex,_)) {\n       print_expr(out, ex);\n     }\n     case (_) { /* do nothing */ }\n   }\n   ret s.get_str();\n }\n \n-fn log_stmt(&ast.stmt st) -> () {\n+fn log_stmt(&ast::stmt st) -> () {\n     log(stmt_to_str(st));\n }\n \n-fn log_stmt_err(&ast.stmt st) -> () {\n+fn log_stmt_err(&ast::stmt st) -> () {\n     log_err(stmt_to_str(st));\n }\n \n-fn decl_lhs(@ast.decl d) -> ast.def_id {\n+fn decl_lhs(@ast::decl d) -> ast::def_id {\n     alt (d.node) {\n-        case (ast.decl_local(?l)) {\n+        case (ast::decl_local(?l)) {\n             ret l.id;\n         }\n-        case (ast.decl_item(?an_item)) {\n+        case (ast::decl_item(?an_item)) {\n             alt (an_item.node) {\n-                case (ast.item_const(_,_,_,?d,_)) {\n+                case (ast::item_const(_,_,_,?d,_)) {\n                     ret d;\n                 }\n-                case (ast.item_fn(_,_,_,?d,_)) {\n+                case (ast::item_fn(_,_,_,?d,_)) {\n                     ret d;\n                 }\n-                case (ast.item_mod(_,_,?d)) {\n+                case (ast::item_mod(_,_,?d)) {\n                     ret d;\n                 }\n-                case (ast.item_native_mod(_,_,?d)) {\n+                case (ast::item_native_mod(_,_,?d)) {\n                     ret d;\n                 }\n-                case (ast.item_ty(_,_,_,?d,_)) {\n+                case (ast::item_ty(_,_,_,?d,_)) {\n                     ret d;\n                 }\n-                case (ast.item_tag(_,_,_,?d,_)) {\n+                case (ast::item_tag(_,_,_,?d,_)) {\n                     ret d;\n                 }\n-                case (ast.item_obj(_,_,_,?d,_)) {\n+                case (ast::item_obj(_,_,_,?d,_)) {\n                     ret d.ctor; /* This doesn't really make sense */\n                 }\n             }\n         } \n     }\n }\n \n-fn has_nonlocal_exits(&ast.block b) -> bool {\n+fn has_nonlocal_exits(&ast::block b) -> bool {\n     /* overkill, but just passing around a mutable bool doesn't seem\n        to work in rustboot */\n     auto has_exits = new_str_hash[()]();\n \n-   fn set_break(&flag f, &span sp, &ast.ann a) -> @ast.expr {\n+   fn set_break(&flag f, &span sp, &ast::ann a) -> @ast::expr {\n         f.insert(\"foo\", ());\n-        ret @respan(sp, ast.expr_break(a));\n+        ret @respan(sp, ast::expr_break(a));\n     }\n-    fn set_cont(&flag f, &span sp, &ast.ann a) -> @ast.expr {\n+    fn set_cont(&flag f, &span sp, &ast::ann a) -> @ast::expr {\n         f.insert(\"foo\", ());\n-        ret @respan(sp, ast.expr_cont(a));\n+        ret @respan(sp, ast::expr_cont(a));\n     }\n     fn check_b(&flag f) -> bool {\n         ret (f.size() == 0u);\n     }\n \n-    auto fld0 = fold.new_identity_fold[flag]();\n+    auto fld0 = fold::new_identity_fold[flag]();\n \n     fld0 = @rec(fold_expr_break = bind set_break(_,_,_),\n                 fold_expr_cont  = bind set_cont(_,_,_),\n                 keep_going      = bind check_b(_) with *fld0);\n-    fold.fold_block[flag](has_exits, fld0, b);\n+    fold::fold_block[flag](has_exits, fld0, b);\n \n     ret (has_exits.size() > 0u);\n }"}, {"sha": "249dc5ca61d6afe3e5a8e2d2ee4e28321d9d6df3", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,21 +1,21 @@\n-import front.ast.ident;\n-import std.Vec;\n-import std.BitV;\n+import front::ast::ident;\n+import std::_vec;\n+import std::bitv;\n \n /* \n    This says: this expression requires the idents in <pre> to be initialized,\n    and given the precondition, it guarantees that the idents in <post> are\n    initialized.\n  */\n-type precond  = BitV.t; /* 1 means \"this variable must be initialized\"\n+type precond  = bitv::t; /* 1 means \"this variable must be initialized\"\n                            0 means \"don't care about this variable\" */\n-type postcond = BitV.t; /* 1 means \"this variable is initialized\"\n+type postcond = bitv::t; /* 1 means \"this variable is initialized\"\n                            0 means \"don't know about this variable */\n \n-type prestate = BitV.t; /* 1 means \"this variable is definitely initialized\"\n+type prestate = bitv::t; /* 1 means \"this variable is definitely initialized\"\n                            0 means \"don't know whether this variable is\n                            initialized\" */\n-type poststate = BitV.t; /* 1 means \"this variable is definitely initialized\"\n+type poststate = bitv::t; /* 1 means \"this variable is definitely initialized\"\n                             0 means \"don't know whether this variable is\n                             initialized\" */\n \n@@ -29,7 +29,7 @@ type pre_and_post_state = rec(prestate prestate, poststate poststate);\n type ts_ann = rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n-  be BitV.create(num_vars, false);\n+  be bitv::create(num_vars, false);\n }\n \n fn true_postcond(uint num_vars) -> postcond {\n@@ -45,7 +45,7 @@ fn empty_poststate(uint num_vars) -> poststate {\n }\n \n fn false_postcond(uint num_vars) -> postcond {\n-    be BitV.create(num_vars, true);\n+    be bitv::create(num_vars, true);\n }\n \n fn empty_pre_post(uint num_vars) -> pre_and_post {\n@@ -72,15 +72,15 @@ fn get_post(&pre_and_post p) -> postcond {\n }\n \n fn difference(&precond p1, &precond p2) -> bool {\n-  be BitV.difference(p1, p2);\n+  be bitv::difference(p1, p2);\n }\n \n fn union(&precond p1, &precond p2) -> bool {\n-  be BitV.union(p1, p2);\n+  be bitv::union(p1, p2);\n }\n \n fn intersect(&precond p1, &precond p2) -> bool {\n-  be BitV.intersect(p1, p2);\n+  be bitv::intersect(p1, p2);\n }\n \n fn pps_len(&pre_and_post p) -> uint {\n@@ -91,62 +91,62 @@ fn pps_len(&pre_and_post p) -> uint {\n \n fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   // sets the ith bit in p's pre and post\n-  BitV.set(p.precondition, i, true);\n-  BitV.set(p.postcondition, i, true);\n+  bitv::set(p.precondition, i, true);\n+  bitv::set(p.postcondition, i, true);\n }\n \n fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n   // sets the ith bit in p's post\n-  auto was_set = BitV.get(p.postcondition, i);\n-  BitV.set(p.postcondition, i, true);\n+  auto was_set = bitv::get(p.postcondition, i);\n+  bitv::set(p.postcondition, i, true);\n   ret !was_set;\n }\n \n fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n   // sets the ith bit in p's post\n-  auto was_set = BitV.get(s.poststate, i);\n-  BitV.set(s.poststate, i, true);\n+  auto was_set = bitv::get(s.poststate, i);\n+  bitv::set(s.poststate, i, true);\n   ret !was_set;\n }\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n fn set_precondition(&ts_ann a, &precond p) -> () {\n-  BitV.copy(a.conditions.precondition, p);\n+  bitv::copy(a.conditions.precondition, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_postcondition(&ts_ann a, &postcond p) -> () {\n-  BitV.copy(a.conditions.postcondition, p);\n+  bitv::copy(a.conditions.postcondition, p);\n }\n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n fn set_prestate(@ts_ann a, &prestate p) -> bool {\n-  ret BitV.copy(a.states.prestate, p);\n+  ret bitv::copy(a.states.prestate, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_poststate(@ts_ann a, &poststate p) -> bool {\n-  ret BitV.copy(a.states.poststate, p);\n+  ret bitv::copy(a.states.poststate, p);\n }\n \n // Set all the bits in p that are set in new\n fn extend_prestate(&prestate p, &poststate new) -> bool {\n-  ret BitV.union(p, new);\n+  ret bitv::union(p, new);\n }\n \n // Set all the bits in p that are set in new\n fn extend_poststate(&poststate p, &poststate new) -> bool {\n-  ret BitV.union(p, new);\n+  ret bitv::union(p, new);\n }\n \n // Clears the given bit in p\n fn relax_prestate(uint i, &prestate p) -> bool {\n-    auto was_set = BitV.get(p, i);\n-    BitV.set(p, i, false);\n+    auto was_set = bitv::get(p, i);\n+    bitv::set(p, i, false);\n     ret was_set;\n }\n \n@@ -164,16 +164,16 @@ fn pp_clone(&pre_and_post p) -> pre_and_post {\n }\n \n fn clone(prestate p) -> prestate {\n-    ret BitV.clone(p);\n+    ret bitv::clone(p);\n }\n \n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = 0\n-fn implies(BitV.t a, BitV.t b) -> bool {\n-  auto tmp = BitV.clone(b);\n-  BitV.difference(tmp, a);\n-  ret BitV.is_false(tmp);\n+fn implies(bitv::t a, bitv::t b) -> bool {\n+  auto tmp = bitv::clone(b);\n+  bitv::difference(tmp, a);\n+  ret bitv::is_false(tmp);\n }\n \n //"}, {"sha": "567843f28c575d09ce27e18abb500d60a3096465", "filename": "src/lib/GenericOS.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1d3364487eb647f2d7fcb412a260c960e38c73e/src%2Flib%2FGenericOS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d3364487eb647f2d7fcb412a260c960e38c73e/src%2Flib%2FGenericOS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FGenericOS.rs?ref=b1d3364487eb647f2d7fcb412a260c960e38c73e", "patch": "@@ -1,9 +0,0 @@\n-fn getenv(str n) -> Option.t[str] {\n-  auto s = OS.libc.getenv(Str.buf(n));\n-  if ((s as int) == 0) {\n-    ret Option.none[str];\n-  } else {\n-    ret Option.some[str](Str.str_from_cstr(s));\n-  }\n-}\n-"}, {"sha": "321602ec1d8cd4d00f8bd69136ce7aa01126a0fa", "filename": "src/lib/_int.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -29,9 +29,9 @@ fn to_str(int n, uint radix) -> str\n {\n     assert (0u < radix && radix <= 16u);\n     if (n < 0) {\n-        ret \"-\" + UInt.to_str((-n) as uint, radix);\n+        ret \"-\" + _uint::to_str((-n) as uint, radix);\n     } else {\n-        ret UInt.to_str(n as uint, radix);\n+        ret _uint::to_str(n as uint, radix);\n     }\n }\n ", "previous_filename": "src/lib/Int.rs"}, {"sha": "36b2376d4dbed0b45516e822019bfcd604069287", "filename": "src/lib/_str.rs", "status": "renamed", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n-import rustrt.sbuf;\n+import rustrt::sbuf;\n \n-import Vec.rustrt.vbuf;\n+import _vec::rustrt::vbuf;\n \n native \"rust\" mod rustrt {\n     type sbuf;\n@@ -84,7 +84,7 @@ const uint tag_six_b = 0xfc_u;\n \n fn is_utf8(vec[u8] v) -> bool {\n     auto i = 0u;\n-    auto total = Vec.len[u8](v);\n+    auto total = _vec::len[u8](v);\n     while (i < total) {\n         auto chsize = utf8_char_width(v.(i));\n         if (chsize == 0u) {ret false;}\n@@ -111,7 +111,7 @@ fn is_ascii(str s) -> bool {\n }\n \n fn alloc(uint n_bytes) -> str {\n-    ret rustrt.str_alloc(n_bytes);\n+    ret rustrt::str_alloc(n_bytes);\n }\n \n // Returns the number of bytes (a.k.a. UTF-8 code units) in s.\n@@ -120,67 +120,67 @@ fn alloc(uint n_bytes) -> str {\n // http://icu-project.org/apiref/icu4c/classBreakIterator.html for a\n // way to implement those.\n fn byte_len(str s) -> uint {\n-    ret rustrt.str_byte_len(s);\n+    ret rustrt::str_byte_len(s);\n }\n \n fn buf(str s) -> sbuf {\n-    ret rustrt.str_buf(s);\n+    ret rustrt::str_buf(s);\n }\n \n fn bytes(str s) -> vec[u8] {\n-    ret rustrt.str_vec(s);\n+    ret rustrt::str_vec(s);\n }\n \n fn from_bytes(vec[u8] v) : is_utf8(v) -> str {\n-    ret rustrt.str_from_vec(v);\n+    ret rustrt::str_from_vec(v);\n }\n \n // FIXME temp thing\n fn unsafe_from_bytes(vec[mutable? u8] v) -> str {\n-    ret rustrt.str_from_vec(v);\n+    ret rustrt::str_from_vec(v);\n }\n \n fn unsafe_from_byte(u8 u) -> str {\n-    ret rustrt.str_from_vec(vec(u));\n+    ret rustrt::str_from_vec(vec(u));\n }\n \n fn str_from_cstr(sbuf cstr) -> str {\n-    ret rustrt.str_from_cstr(cstr);\n+    ret rustrt::str_from_cstr(cstr);\n }\n \n fn str_from_buf(sbuf buf, uint len) -> str {\n-    ret rustrt.str_from_buf(buf, len);\n+    ret rustrt::str_from_buf(buf, len);\n }\n \n fn push_utf8_bytes(&mutable str s, char ch) {\n     auto code = ch as uint;\n     if (code < max_one_b) {\n-        s = rustrt.str_push_byte(s, code);\n+        s = rustrt::str_push_byte(s, code);\n     } else if (code < max_two_b) {\n-        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x1f_u) | tag_two_b);\n-        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 6u) & 0x1f_u) | tag_two_b);\n+        s = rustrt::str_push_byte(s, (code & 0x3f_u) | tag_cont);\n     } else if (code < max_three_b) {\n-        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x0f_u) | tag_three_b);\n-        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 12u) & 0x0f_u) | tag_three_b);\n+        s = rustrt::str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, (code & 0x3f_u) | tag_cont);\n     } else if (code < max_four_b) {\n-        s = rustrt.str_push_byte(s, ((code >> 18u) & 0x07_u) | tag_four_b);\n-        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 18u) & 0x07_u) | tag_four_b);\n+        s = rustrt::str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, (code & 0x3f_u) | tag_cont);\n     } else if (code < max_five_b) {\n-        s = rustrt.str_push_byte(s, ((code >> 24u) & 0x03_u) | tag_five_b);\n-        s = rustrt.str_push_byte(s, ((code >> 18u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 24u) & 0x03_u) | tag_five_b);\n+        s = rustrt::str_push_byte(s, ((code >> 18u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, (code & 0x3f_u) | tag_cont);\n     } else {\n-        s = rustrt.str_push_byte(s, ((code >> 30u) & 0x01_u) | tag_six_b);\n-        s = rustrt.str_push_byte(s, ((code >> 24u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, ((code >> 18u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n-        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 30u) & 0x01_u) | tag_six_b);\n+        s = rustrt::str_push_byte(s, ((code >> 24u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 18u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt::str_push_byte(s, (code & 0x3f_u) | tag_cont);\n     }\n }\n \n@@ -253,7 +253,7 @@ fn to_chars(str s) -> vec[char] {\n     auto len = byte_len(s);\n     while (i < len) {\n         auto cur = char_range_at(s, i);\n-        Vec.push[char](buf, cur._0);\n+        _vec::push[char](buf, cur._0);\n         i = cur._1;\n     }\n     ret buf;\n@@ -287,8 +287,8 @@ fn unshift_char(&mutable str s, char ch) {\n }\n \n fn refcount(str s) -> uint {\n-    auto r = rustrt.refcount[u8](s);\n-    if (r == Dbg.const_refcount) {\n+    auto r = rustrt::refcount[u8](s);\n+    if (r == dbg::const_refcount) {\n         ret r;\n     } else {\n         // -1 because calling this function incremented the refcount.\n@@ -311,7 +311,7 @@ fn index(str s, u8 c) -> int {\n }\n \n fn rindex(str s, u8 c) -> int {\n-    let int n = Str.byte_len(s) as int;\n+    let int n = _str::byte_len(s) as int;\n     while (n >= 0) {\n         if (s.(n) == c) {\n             ret n;\n@@ -387,8 +387,8 @@ fn substr(str s, uint begin, uint len) -> str {\n fn slice(str s, uint begin, uint end) -> str {\n     // FIXME: Typestate precondition\n     assert (begin <= end);\n-    assert (end <= Str.byte_len(s));\n-    ret rustrt.str_slice(s, begin, end);\n+    assert (end <= _str::byte_len(s));\n+    ret rustrt::str_slice(s, begin, end);\n }\n \n fn shift_byte(&mutable str s) -> u8 {\n@@ -408,7 +408,7 @@ fn pop_byte(&mutable str s) -> u8 {\n }\n \n fn push_byte(&mutable str s, u8 b) {\n-    s = rustrt.str_push_byte(s, b as uint);\n+    s = rustrt::str_push_byte(s, b as uint);\n }\n \n fn unshift_byte(&mutable str s, u8 b) {\n@@ -432,7 +432,7 @@ fn split(str s, u8 sep) -> vec[str] {\n             ends_with_sep = false;\n         }\n     }\n-    if (Str.byte_len(accum) != 0u ||\n+    if (_str::byte_len(accum) != 0u ||\n         ends_with_sep) {\n         v += vec(accum);\n     }", "previous_filename": "src/lib/Str.rs"}, {"sha": "b6b754f0cb2d624006b9a312411fbaf626327c9b", "filename": "src/lib/_task.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_task.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -8,7 +8,7 @@ native \"rust\" mod rustrt {\n  * arg: time_in_us maximum number of microseconds to yield control for\n  */\n fn sleep(uint time_in_us) {\n-    ret rustrt.task_sleep(time_in_us);\n+    ret rustrt::task_sleep(time_in_us);\n }\n \n // Local Variables:", "previous_filename": "src/lib/Task.rs"}, {"sha": "e094e5812bddb5b86663266f37fa84aec9ce65b1", "filename": "src/lib/_u8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_u8.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "previous_filename": "src/lib/U8.rs"}, {"sha": "a68901cc06d7505ff24481bc7cbaaa4f9c4866ab", "filename": "src/lib/_uint.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -23,7 +23,7 @@ iter range(uint lo, uint hi) -> uint {\n fn next_power_of_two(uint n) -> uint {\n     // FIXME change |* uint(4)| below to |* uint(8) / uint(2)| and watch the\n     // world explode.\n-    let uint halfbits = Sys.rustrt.size_of[uint]() * 4u;\n+    let uint halfbits = sys::rustrt::size_of[uint]() * 4u;\n     let uint tmp = n - 1u;\n     let uint shift = 1u;\n     while (shift <= halfbits) {\n@@ -34,12 +34,12 @@ fn next_power_of_two(uint n) -> uint {\n }\n \n fn parse_buf(vec[u8] buf, uint radix) -> uint {\n-    if (Vec.len[u8](buf) == 0u) {\n+    if (_vec::len[u8](buf) == 0u) {\n         log_err \"parse_buf(): buf is empty\";\n         fail;\n     }\n \n-    auto i = Vec.len[u8](buf) - 1u;\n+    auto i = _vec::len[u8](buf) - 1u;\n     auto power = 1u;\n     auto n = 0u;\n     while (true) {\n@@ -83,15 +83,15 @@ fn to_str(uint num, uint radix) -> str\n \n     let str s = \"\";\n     while (n != 0u) {\n-        s += Str.unsafe_from_byte(digit(n % radix) as u8);\n+        s += _str::unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n \n     let str s1 = \"\";\n-    let uint len = Str.byte_len(s);\n+    let uint len = _str::byte_len(s);\n     while (len != 0u) {\n         len -= 1u;\n-        s1 += Str.unsafe_from_byte(s.(len));\n+        s1 += _str::unsafe_from_byte(s.(len));\n     }\n     ret s1;\n ", "previous_filename": "src/lib/UInt.rs"}, {"sha": "0988864a160dcdc6743513b12772523562611aa0", "filename": "src/lib/_vec.rs", "status": "renamed", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,8 +1,8 @@\n-import Option.none;\n-import Option.some;\n-import Util.orb;\n+import option::none;\n+import option::some;\n+import util::orb;\n \n-type vbuf = rustrt.vbuf;\n+type vbuf = rustrt::vbuf;\n \n type operator2[T,U,V] = fn(&T, &U) -> V;\n \n@@ -38,16 +38,16 @@ native \"rust\" mod rustrt {\n }\n \n fn alloc[T](uint n_elts) -> vec[T] {\n-    ret rustrt.vec_alloc[vec[T], T](n_elts);\n+    ret rustrt::vec_alloc[vec[T], T](n_elts);\n }\n \n fn alloc_mut[T](uint n_elts) -> vec[mutable T] {\n-    ret rustrt.vec_alloc_mut[vec[mutable T], T](n_elts);\n+    ret rustrt::vec_alloc_mut[vec[mutable T], T](n_elts);\n }\n \n fn refcount[T](array[T] v) -> uint {\n-    auto r = rustrt.refcount[T](v);\n-    if (r == Dbg.const_refcount) {\n+    auto r = rustrt::refcount[T](v);\n+    if (r == dbg::const_refcount) {\n         ret r;\n     } else {\n         // -1 because calling this function incremented the refcount.\n@@ -56,7 +56,7 @@ fn refcount[T](array[T] v) -> uint {\n }\n \n fn vec_from_vbuf[T](vbuf v, uint n_elts) -> vec[T] {\n-    ret rustrt.vec_from_vbuf[T](v, n_elts);\n+    ret rustrt::vec_from_vbuf[T](v, n_elts);\n }\n \n // FIXME: Remove me; this is a botch to get around rustboot's bad typechecker.\n@@ -119,28 +119,28 @@ fn init_elt_mut[T](&T t, uint n_elts) -> vec[mutable T] {\n }\n \n fn buf[T](array[T] v) -> vbuf {\n-    ret rustrt.vec_buf[T](v, 0u);\n+    ret rustrt::vec_buf[T](v, 0u);\n }\n \n fn len[T](array[T] v) -> uint {\n-    ret rustrt.vec_len[T](v);\n+    ret rustrt::vec_len[T](v);\n }\n \n fn len_set[T](array[T] v, uint n) {\n-    rustrt.vec_len_set[T](v, n);\n+    rustrt::vec_len_set[T](v, n);\n }\n \n fn buf_off[T](array[T] v, uint offset) -> vbuf {\n      assert (offset < len[T](v));\n-    ret rustrt.vec_buf[T](v, offset);\n+    ret rustrt::vec_buf[T](v, offset);\n }\n \n fn print_debug_info[T](array[T] v) {\n-    rustrt.vec_print_debug_info[T](v);\n+    rustrt::vec_print_debug_info[T](v);\n }\n \n // Returns the last element of v.\n-fn last[T](array[T] v) -> Option.t[T] {\n+fn last[T](array[T] v) -> option::t[T] {\n     auto l = len[T](v);\n     if (l == 0u) {\n         ret none[T];\n@@ -199,14 +199,14 @@ fn grow[T](&array[T] v, uint n, &T initval) {\n }\n \n fn grow_set[T](&vec[mutable T] v, uint index, &T initval, &T val) {\n-    auto length = Vec.len(v);\n+    auto length = _vec::len(v);\n     if (index >= length) {\n         grow(v, index - length + 1u, initval);\n     }\n     v.(index) = val;\n }\n \n-fn map[T, U](&Option.operator[T,U] f, &array[T] v) -> vec[U] {\n+fn map[T, U](&option::operator[T,U] f, &array[T] v) -> vec[U] {\n     let vec[U] u = alloc[U](len[T](v));\n     for (T ve in v) {\n         u += vec(f(ve));\n@@ -230,7 +230,7 @@ fn map2[T,U,V](&operator2[T,U,V] f, &array[T] v0, &array[U] v1) -> vec[V] {\n     ret u;\n }\n \n-fn find[T](fn (&T) -> bool f, &array[T] v) -> Option.t[T] {\n+fn find[T](fn (&T) -> bool f, &array[T] v) -> option::t[T] {\n     for (T elt in v) {\n         if (f(elt)) {\n             ret some[T](elt);\n@@ -270,24 +270,24 @@ fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n \n fn or(&vec[bool] v) -> bool {\n     auto f = orb;\n-    ret Vec.foldl[bool, bool](f, false, v);\n+    ret _vec::foldl[bool, bool](f, false, v);\n }\n \n fn clone[T](&vec[T] v) -> vec[T] {\n     ret slice[T](v, 0u, len[T](v));\n }\n \n-fn plus_option[T](&vec[T] v, &Option.t[T] o) -> () {\n+fn plus_option[T](&vec[T] v, &option::t[T] o) -> () {\n     alt (o) {\n         case (none[T]) {}\n         case (some[T](?x)) { v += vec(x); }\n     }\n }\n \n-fn cat_options[T](&vec[Option.t[T]] v) -> vec[T] {\n+fn cat_options[T](&vec[option::t[T]] v) -> vec[T] {\n     let vec[T] res = vec();\n \n-    for (Option.t[T] o in v) {\n+    for (option::t[T] o in v) {\n         alt (o) {\n             case (none[T]) { }\n             case (some[T](?t)) {", "previous_filename": "src/lib/Vec.rs"}, {"sha": "1b4528a44a99c19e0436bd872ed5b97a904344e6", "filename": "src/lib/bitv.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -21,19 +21,19 @@ fn create(uint nbits, bool init) -> t {\n         elt = 0u;\n     }\n \n-    auto storage = Vec.init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n+    auto storage = _vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n     ret rec(storage = storage, nbits = nbits);\n }\n \n fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n-    auto len = Vec.len(v1.storage);\n+    auto len = _vec::len(v1.storage);\n \n-    assert (Vec.len(v0.storage) == len);\n+    assert (_vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n \n     auto changed = false;\n \n-    for each (uint i in UInt.range(0u, len)) {\n+    for each (uint i in _uint::range(0u, len)) {\n         auto w0 = v0.storage.(i);\n         auto w1 = v1.storage.(i);\n \n@@ -75,9 +75,9 @@ fn copy(&t v0, t v1) -> bool {\n }\n \n fn clone(t v) -> t {\n-    auto storage = Vec.init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n-    auto len = Vec.len(v.storage);\n-    for each (uint i in UInt.range(0u, len)) {\n+    auto storage = _vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    auto len = _vec::len(v.storage);\n+    for each (uint i in _uint::range(0u, len)) {\n         storage.(i) = v.storage.(i);\n     }\n     ret rec(storage = storage, nbits = v.nbits);\n@@ -97,7 +97,7 @@ fn get(&t v, uint i) -> bool {\n fn equal(&t v0, &t v1) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n-    auto len = Vec.len(v1.storage);\n+    auto len = _vec::len(v1.storage);\n     auto i = 0u;\n     while (i < len) {\n         if (v0.storage.(i) != v1.storage.(i)) {\n@@ -109,13 +109,13 @@ fn equal(&t v0, &t v1) -> bool {\n }\n \n fn clear(&t v) {\n-    for each (uint i in UInt.range(0u, Vec.len(v.storage))) {\n+    for each (uint i in _uint::range(0u, _vec::len(v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n \n fn invert(&t v) {\n-    for each (uint i in UInt.range(0u, Vec.len(v.storage))) {\n+    for each (uint i in _uint::range(0u, _vec::len(v.storage))) {\n         v.storage.(i) = ~v.storage.(i);\n     }\n }\n@@ -176,13 +176,13 @@ fn init_to_vec(t v, uint i) -> uint {\n \n fn to_vec(&t v) -> vec[uint] {\n     auto sub = bind init_to_vec(v, _);\n-    ret Vec.init_fn[uint](sub, v.nbits);\n+    ret _vec::init_fn[uint](sub, v.nbits);\n }\n \n fn to_str(&t v) -> str {\n     auto res = \"\";\n \n-    for (uint i in BitV.to_vec(v)) {\n+    for (uint i in bitv::to_vec(v)) {\n         if (i == 1u) {\n             res += \"1\";\n         }\n@@ -196,7 +196,7 @@ fn to_str(&t v) -> str {\n \n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n-    assert (v0.nbits == Vec.len[uint](v1));\n+    assert (v0.nbits == _vec::len[uint](v1));\n     auto len = v0.nbits;\n     auto i = 0u;\n     while (i < len) {", "previous_filename": "src/lib/BitV.rs"}, {"sha": "4429fd6a0b0d1c90154a0482059a51df3e6fb5a1", "filename": "src/lib/box.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbox.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,5 +4,5 @@ native \"rust\" mod rustrt {\n     fn rust_ptr_eq[T](@T a, @T b) -> int;\n }\n \n-fn ptr_eq[T](@T a, @T b) -> bool { ret rustrt.rust_ptr_eq[T](a, b) != 0; }\n+fn ptr_eq[T](@T a, @T b) -> bool { ret rustrt::rust_ptr_eq[T](a, b) != 0; }\n ", "previous_filename": "src/lib/Box.rs"}, {"sha": "be3675625674732181ec43f7eecd200d0b49a866", "filename": "src/lib/dbg.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -20,23 +20,23 @@ native \"rust\" mod rustrt {\n }\n \n fn debug_vec[T](vec[T] v) {\n-    Vec.print_debug_info[T](v);\n+    _vec::print_debug_info[T](v);\n }\n \n fn debug_tydesc[T]() {\n-    rustrt.debug_tydesc[T]();\n+    rustrt::debug_tydesc[T]();\n }\n \n fn debug_opaque[T](&T x) {\n-    rustrt.debug_opaque[T](x);\n+    rustrt::debug_opaque[T](x);\n }\n \n fn debug_box[T](@T x) {\n-    rustrt.debug_box[T](x);\n+    rustrt::debug_box[T](x);\n }\n \n fn debug_tag[T](&T x) {\n-    rustrt.debug_tag[T](x);\n+    rustrt::debug_tag[T](x);\n }\n \n /**\n@@ -49,19 +49,19 @@ fn debug_tag[T](&T x) {\n  * the front of any obj's data tuple.x\n  */\n fn debug_obj[T](&T x, uint nmethods, uint nbytes) {\n-    rustrt.debug_obj[T](x, nmethods, nbytes);\n+    rustrt::debug_obj[T](x, nmethods, nbytes);\n }\n \n fn debug_fn[T](&T x) {\n-    rustrt.debug_fn[T](x);\n+    rustrt::debug_fn[T](x);\n }\n \n fn ptr_cast[T, U](@T x) -> @U {\n-    ret rustrt.debug_ptrcast[T, U](x);\n+    ret rustrt::debug_ptrcast[T, U](x);\n }\n \n fn trap(str s) {\n-    rustrt.debug_trap(s);\n+    rustrt::debug_trap(s);\n }\n \n // Local Variables:", "previous_filename": "src/lib/Dbg.rs"}, {"sha": "c0ded5bf54677cee3a157bd1ab559bd8454abcb8", "filename": "src/lib/deque.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -19,7 +19,7 @@ type t[T] = obj {\n \n fn create[T]() -> t[T] {\n \n-    type cell[T] = Option.t[T];\n+    type cell[T] = option::t[T];\n \n     let uint initial_capacity = 32u; // 2^5\n \n@@ -28,25 +28,25 @@ fn create[T]() -> t[T] {\n      * elsewhere.\n      */\n     fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-        assert (nelts == Vec.len[cell[T]](elts));\n+        assert (nelts == _vec::len[cell[T]](elts));\n \n         fn fill[T](uint i, uint nelts, uint lo,\n                    vec[cell[T]] old) -> cell[T] {\n             if (i < nelts) {\n                 ret old.((lo + i) % nelts);\n             } else {\n-                ret Option.none[T];\n+                ret option::none[T];\n             }\n         }\n \n-        let uint nalloc = UInt.next_power_of_two(nelts + 1u);\n-        let Vec.init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n-        ret Vec.init_fn[cell[T]](copy_op, nalloc);\n+        let uint nalloc = _uint::next_power_of_two(nelts + 1u);\n+        let _vec::init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n+        ret _vec::init_fn[cell[T]](copy_op, nalloc);\n     }\n \n     fn get[T](vec[cell[T]] elts, uint i) -> T {\n         alt (elts.(i)) {\n-            case (Option.some[T](?t)) { ret t; }\n+            case (option::some[T](?t)) { ret t; }\n             case (_) { fail; }\n         }\n         fail;   // FIXME: remove me when exhaustiveness checking works\n@@ -63,18 +63,18 @@ fn create[T]() -> t[T] {\n                 let uint oldlo = lo;\n \n                 if (lo == 0u) {\n-                    lo = Vec.len[cell[T]](elts) - 1u;\n+                    lo = _vec::len[cell[T]](elts) - 1u;\n                 } else {\n                     lo -= 1u;\n                 }\n \n                 if (lo == hi) {\n                     elts = grow[T](nelts, oldlo, elts);\n-                    lo = Vec.len[cell[T]](elts) - 1u;\n+                    lo = _vec::len[cell[T]](elts) - 1u;\n                     hi = nelts;\n                 }\n \n-                elts.(lo) = Option.some[T](t);\n+                elts.(lo) = option::some[T](t);\n                 nelts += 1u;\n             }\n \n@@ -85,8 +85,8 @@ fn create[T]() -> t[T] {\n                     hi = nelts;\n                 }\n \n-                elts.(hi) = Option.some[T](t);\n-                hi = (hi + 1u) % Vec.len[cell[T]](elts);\n+                elts.(hi) = option::some[T](t);\n+                hi = (hi + 1u) % _vec::len[cell[T]](elts);\n                 nelts += 1u;\n             }\n \n@@ -96,21 +96,21 @@ fn create[T]() -> t[T] {\n              */\n             fn pop_front() -> T {\n                 let T t = get[T](elts, lo);\n-                elts.(lo) = Option.none[T];\n-                lo = (lo + 1u) % Vec.len[cell[T]](elts);\n+                elts.(lo) = option::none[T];\n+                lo = (lo + 1u) % _vec::len[cell[T]](elts);\n                 nelts -= 1u;\n                 ret t;\n             }\n \n             fn pop_back() -> T {\n                 if (hi == 0u) {\n-                    hi = Vec.len[cell[T]](elts) - 1u;\n+                    hi = _vec::len[cell[T]](elts) - 1u;\n                 } else {\n                     hi -= 1u;\n                 }\n \n                 let T t = get[T](elts, hi);\n-                elts.(hi) = Option.none[T];\n+                elts.(hi) = option::none[T];\n                 nelts -= 1u;\n                 ret t;\n             }\n@@ -124,12 +124,12 @@ fn create[T]() -> t[T] {\n             }\n \n             fn get(int i) -> T {\n-                let uint idx = (lo + (i as uint)) % Vec.len[cell[T]](elts);\n+                let uint idx = (lo + (i as uint)) % _vec::len[cell[T]](elts);\n                 ret get[T](elts, idx);\n             }\n \n         }\n-    let vec[cell[T]] v = Vec.init_elt[cell[T]](Option.none[T],\n+    let vec[cell[T]] v = _vec::init_elt[cell[T]](option::none[T],\n                                                 initial_capacity);\n \n     ret deque[T](0u, 0u, 0u, v);", "previous_filename": "src/lib/Deque.rs"}, {"sha": "0efb05b83c3f7d3e8e1bfe458aa199532300a2fd", "filename": "src/lib/ebml.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,17 +1,17 @@\n-// Simple Extensible Binary Markup Language (EBML) reader and writer on a\n+// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n \n-import Option.none;\n-import Option.some;\n+import option::none;\n+import option::some;\n \n type ebml_tag = rec(uint id, uint size);\n type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n \n // TODO: When we have module renaming, make \"reader\" and \"writer\" separate\n // modules within this file.\n \n-// EBML reading\n+// ebml reading\n \n type doc = rec(vec[u8] data,\n                uint start,\n@@ -38,7 +38,7 @@ fn vint_at(vec[u8] data, uint start) -> tup(uint, uint) {\n }\n \n fn new_doc(vec[u8] data) -> doc {\n-    ret rec(data=data, start=0u, end=Vec.len[u8](data));\n+    ret rec(data=data, start=0u, end=_vec::len[u8](data));\n }\n \n fn doc_at(vec[u8] data, uint start) -> doc {\n@@ -48,7 +48,7 @@ fn doc_at(vec[u8] data, uint start) -> doc {\n     ret rec(data=data, start=elt_size._1, end=end);\n }\n \n-fn maybe_get_doc(doc d, uint tg) -> Option.t[doc] {\n+fn maybe_get_doc(doc d, uint tg) -> option::t[doc] {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(d.data, pos);\n@@ -65,7 +65,7 @@ fn get_doc(doc d, uint tg) -> doc {\n     alt (maybe_get_doc(d, tg)) {\n         case (some[doc](?d)) {ret d;}\n         case (none[doc]) {\n-            log_err \"failed to find block with tag \" + UInt.to_str(tg, 10u);\n+            log_err \"failed to find block with tag \" + _uint::to_str(tg, 10u);\n             fail;\n         }\n     }\n@@ -94,7 +94,7 @@ iter tagged_docs(doc d, uint tg) -> doc {\n }\n \n fn doc_data(doc d) -> vec[u8] {\n-    ret Vec.slice[u8](d.data, d.start, d.end);\n+    ret _vec::slice[u8](d.data, d.start, d.end);\n }\n \n fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n@@ -114,11 +114,11 @@ fn doc_as_uint(doc d) -> uint {\n     ret be_uint_from_bytes(d.data, d.start, d.end - d.start);\n }\n \n-// EBML writing\n+// ebml writing\n \n-type writer = rec(IO.buf_writer writer, mutable vec[uint] size_positions);\n+type writer = rec(io::buf_writer writer, mutable vec[uint] size_positions);\n \n-fn write_sized_vint(&IO.buf_writer w, uint n, uint size) {\n+fn write_sized_vint(&io::buf_writer w, uint n, uint size) {\n     let vec[u8] buf;\n     alt (size) {\n         case (1u) {\n@@ -148,7 +148,7 @@ fn write_sized_vint(&IO.buf_writer w, uint n, uint size) {\n     w.write(buf);\n }\n \n-fn write_vint(&IO.buf_writer w, uint n) {\n+fn write_vint(&io::buf_writer w, uint n) {\n     if (n < 0x7fu)          { write_sized_vint(w, n, 1u); ret; }\n     if (n < 0x4000u)        { write_sized_vint(w, n, 2u); ret; }\n     if (n < 0x200000u)      { write_sized_vint(w, n, 3u); ret; }\n@@ -157,15 +157,15 @@ fn write_vint(&IO.buf_writer w, uint n) {\n     fail;\n }\n \n-fn create_writer(&IO.buf_writer w) -> writer {\n+fn create_writer(&io::buf_writer w) -> writer {\n     let vec[uint] size_positions = vec();\n     ret rec(writer=w, mutable size_positions=size_positions);\n }\n \n-// TODO: Provide a function to write the standard EBML header.\n+// TODO: Provide a function to write the standard ebml header.\n \n fn start_tag(&writer w, uint tag_id) {\n-    // Write the tag ID.\n+    // Write the tag ID:\n     write_vint(w.writer, tag_id);\n \n     // Write a placeholder four-byte size.\n@@ -175,11 +175,11 @@ fn start_tag(&writer w, uint tag_id) {\n }\n \n fn end_tag(&writer w) {\n-    auto last_size_pos = Vec.pop[uint](w.size_positions);\n+    auto last_size_pos = _vec::pop[uint](w.size_positions);\n     auto cur_pos = w.writer.tell();\n-    w.writer.seek(last_size_pos as int, IO.seek_set);\n+    w.writer.seek(last_size_pos as int, io::seek_set);\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n-    w.writer.seek(cur_pos as int, IO.seek_set);\n+    w.writer.seek(cur_pos as int, io::seek_set);\n }\n \n // TODO: optionally perform \"relaxations\" on end_tag to more efficiently", "previous_filename": "src/lib/EBML.rs"}, {"sha": "c5691fe9b915c79a07cf3374764242c371140c32", "filename": "src/lib/extfmt.rs", "status": "renamed", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -13,8 +13,8 @@\n  * combinations at the moment.\n  */\n \n-import Option.none;\n-import Option.some;\n+import option::none;\n+import option::some;\n \n /*\n  * We have a CT (compile-time) module that parses format strings into a\n@@ -66,7 +66,7 @@ mod CT {\n     }\n \n     // A formatted conversion from an expression to a string\n-    type conv = rec(Option.t[int] param,\n+    type conv = rec(option::t[int] param,\n                     vec[flag] flags,\n                     count width,\n                     count precision,\n@@ -80,11 +80,11 @@ mod CT {\n \n     fn parse_fmt_string(str s) -> vec[piece] {\n         let vec[piece] pieces = vec();\n-        auto lim = Str.byte_len(s);\n+        auto lim = _str::byte_len(s);\n         auto buf = \"\";\n \n         fn flush_buf(str buf, &vec[piece] pieces) -> str {\n-            if (Str.byte_len(buf) > 0u) {\n+            if (_str::byte_len(buf) > 0u) {\n                 auto piece = piece_string(buf);\n                 pieces += vec(piece);\n             }\n@@ -93,15 +93,15 @@ mod CT {\n \n         auto i = 0u;\n         while (i < lim) {\n-            auto curr = Str.substr(s, i, 1u);\n-            if (Str.eq(curr, \"%\")) {\n+            auto curr = _str::substr(s, i, 1u);\n+            if (_str::eq(curr, \"%\")) {\n                 i += 1u;\n                 if (i >= lim) {\n                     log_err \"unterminated conversion at end of string\";\n                     fail;\n                 }\n-                auto curr2 = Str.substr(s, i, 1u);\n-                if (Str.eq(curr2, \"%\")) {\n+                auto curr2 = _str::substr(s, i, 1u);\n+                if (_str::eq(curr2, \"%\")) {\n                     i += 1u;\n                 } else {\n                     buf = flush_buf(buf, pieces);\n@@ -118,14 +118,14 @@ mod CT {\n         ret pieces;\n     }\n \n-    fn peek_num(str s, uint i, uint lim) -> Option.t[tup(uint, uint)] {\n+    fn peek_num(str s, uint i, uint lim) -> option::t[tup(uint, uint)] {\n         if (i >= lim) {\n             ret none[tup(uint, uint)];\n         }\n \n         auto c = s.(i);\n         if (!('0' as u8 <= c && c <= '9' as u8)) {\n-            ret Option.none[tup(uint, uint)];\n+            ret option::none[tup(uint, uint)];\n         }\n \n         auto n = (c - ('0' as u8)) as uint;\n@@ -156,7 +156,7 @@ mod CT {\n                 ty._1);\n     }\n \n-    fn parse_parameter(str s, uint i, uint lim) -> tup(Option.t[int], uint) {\n+    fn parse_parameter(str s, uint i, uint lim) -> tup(option::t[int], uint) {\n         if (i >= lim) {\n             ret tup(none[int], i);\n         }\n@@ -270,27 +270,27 @@ mod CT {\n         }\n \n         auto t;\n-        auto tstr = Str.substr(s, i, 1u);\n-        if (Str.eq(tstr, \"b\")) {\n+        auto tstr = _str::substr(s, i, 1u);\n+        if (_str::eq(tstr, \"b\")) {\n             t = ty_bool;\n-        } else if (Str.eq(tstr, \"s\")) {\n+        } else if (_str::eq(tstr, \"s\")) {\n             t = ty_str;\n-        } else if (Str.eq(tstr, \"c\")) {\n+        } else if (_str::eq(tstr, \"c\")) {\n             t = ty_char;\n-        } else if (Str.eq(tstr, \"d\")\n-                   || Str.eq(tstr, \"i\")) {\n+        } else if (_str::eq(tstr, \"d\")\n+                   || _str::eq(tstr, \"i\")) {\n             // TODO: Do we really want two signed types here?\n             // How important is it to be printf compatible?\n             t = ty_int(signed);\n-        } else if (Str.eq(tstr, \"u\")) {\n+        } else if (_str::eq(tstr, \"u\")) {\n             t = ty_int(unsigned);\n-        } else if (Str.eq(tstr, \"x\")) {\n+        } else if (_str::eq(tstr, \"x\")) {\n             t = ty_hex(case_lower);\n-        } else if (Str.eq(tstr, \"X\")) {\n+        } else if (_str::eq(tstr, \"X\")) {\n             t = ty_hex(case_upper);\n-        } else if (Str.eq(tstr, \"t\")) {\n+        } else if (_str::eq(tstr, \"t\")) {\n             t = ty_bits;\n-        } else if (Str.eq(tstr, \"o\")) {\n+        } else if (_str::eq(tstr, \"o\")) {\n             t = ty_octal;\n         } else {\n             log_err \"unknown type in conversion\";\n@@ -315,7 +315,7 @@ mod RT {\n         flag_alternate;\n         // FIXME: This is a hack to avoid creating 0-length vec exprs,\n         // which have some difficulty typechecking currently. See\n-        // comments in front.extfmt.make_flags\n+        // comments in front::extfmt::make_flags\n         flag_none;\n     }\n \n@@ -364,7 +364,7 @@ mod RT {\n                 res = uint_to_str_prec(u, 16u, prec);\n             }\n             case (ty_hex_upper) {\n-                res = Str.to_upper(uint_to_str_prec(u, 16u, prec));\n+                res = _str::to_upper(uint_to_str_prec(u, 16u, prec));\n             }\n             case (ty_bits) {\n                 res = uint_to_str_prec(u, 2u, prec);\n@@ -383,13 +383,13 @@ mod RT {\n         } else {\n             s = \"false\";\n         }\n-        // Run the boolean conversion through the string conversion logic,\n+        // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         ret conv_str(cv, s);\n     }\n \n     fn conv_char(&conv cv, char c) -> str {\n-        ret pad(cv, Str.from_char(c), pad_nozero);\n+        ret pad(cv, _str::from_char(c), pad_nozero);\n     }\n \n     fn conv_str(&conv cv, str s) -> str {\n@@ -399,9 +399,9 @@ mod RT {\n             }\n             case (count_is(?max)) {\n                 // For strings, precision is the maximum characters displayed\n-                if (max as uint < Str.char_len(s)) {\n+                if (max as uint < _str::char_len(s)) {\n                     // FIXME: substr works on bytes, not chars!\n-                    unpadded = Str.substr(s, 0u, max as uint);\n+                    unpadded = _str::substr(s, 0u, max as uint);\n                 }\n             }\n         }\n@@ -420,15 +420,15 @@ mod RT {\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to UInt. but it doesn't seem all that useful.\n+    // to _uint: but it doesn't seem all that useful.\n     fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n         auto s;\n \n         if (prec == 0u && num == 0u) {\n             s = \"\";\n         } else {\n-            s = UInt.to_str(num, radix);\n-            auto len = Str.char_len(s);\n+            s = _uint::to_str(num, radix);\n+            auto len = _str::char_len(s);\n             if (len < prec) {\n                 auto diff = prec - len;\n                 auto pad = str_init_elt('0', diff);\n@@ -450,12 +450,12 @@ mod RT {\n         }\n     }\n \n-    // FIXME: This might be useful in Str. but needs to be utf8 safe first\n+    // FIXME: This might be useful in _str: but needs to be utf8 safe first\n     fn str_init_elt(char c, uint n_elts) -> str {\n-        auto svec = Vec.init_elt[u8](c as u8, n_elts);\n+        auto svec = _vec::init_elt[u8](c as u8, n_elts);\n         // FIXME: Using unsafe_from_bytes because rustboot\n         // can't figure out the is_utf8 predicate on from_bytes?\n-        ret Str.unsafe_from_bytes(svec);\n+        ret _str::unsafe_from_bytes(svec);\n     }\n \n     tag pad_mode {\n@@ -476,7 +476,7 @@ mod RT {\n             }\n         }\n \n-        auto strlen = Str.char_len(s);\n+        auto strlen = _str::char_len(s);\n         if (uwidth <= strlen) {\n             ret s;\n         }\n@@ -532,16 +532,16 @@ mod RT {\n         // instead.\n         if (signed\n             && zero_padding\n-            && Str.byte_len(s) > 0u) {\n+            && _str::byte_len(s) > 0u) {\n \n             auto head = s.(0);\n             if (head == '+' as u8\n                 || head == '-' as u8\n                 || head == ' ' as u8) {\n \n-                auto headstr = Str.unsafe_from_bytes(vec(head));\n-                auto bytelen = Str.byte_len(s);\n-                auto numpart = Str.substr(s, 1u, bytelen - 1u);\n+                auto headstr = _str::unsafe_from_bytes(vec(head));\n+                auto bytelen = _str::byte_len(s);\n+                auto numpart = _str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;\n             }\n         }", "previous_filename": "src/lib/ExtFmt.rs"}, {"sha": "a897576944b597c4a44b6d4f96e48aa96e26956d", "filename": "src/lib/fs.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,43 +3,43 @@ native \"rust\" mod rustrt {\n }\n \n fn path_sep() -> str {\n-    ret Str.from_char(OS_FS.path_sep);\n+    ret _str::from_char(os_fs::path_sep);\n }\n \n type path = str;\n \n fn dirname(path p) -> path {\n-    let int i = Str.rindex(p, OS_FS.path_sep as u8);\n+    let int i = _str::rindex(p, os_fs::path_sep as u8);\n     if (i == -1) {\n-        i = Str.rindex(p, OS_FS.alt_path_sep as u8);\n+        i = _str::rindex(p, os_fs::alt_path_sep as u8);\n         if (i == -1) {\n             ret p;\n         }\n     }\n-    ret Str.substr(p, 0u, i as uint);\n+    ret _str::substr(p, 0u, i as uint);\n }\n \n fn connect(path pre, path post) -> path {\n-    auto len = Str.byte_len(pre);\n-    if (pre.(len - 1u) == (OS_FS.path_sep as u8)) { // Trailing '/'?\n+    auto len = _str::byte_len(pre);\n+    if (pre.(len - 1u) == (os_fs::path_sep as u8)) { // Trailing '/'?\n         ret pre + post;\n     }\n     ret pre + path_sep() + post;\n }\n \n fn file_is_dir(path p) -> bool {\n-  ret rustrt.rust_file_is_dir(p) != 0;\n+  ret rustrt::rust_file_is_dir(p) != 0;\n }\n \n fn list_dir(path p) -> vec[str] {\n-  auto pl = Str.byte_len(p);\n-  if (pl == 0u || p.(pl - 1u) as char != OS_FS.path_sep) {\n+  auto pl = _str::byte_len(p);\n+  if (pl == 0u || p.(pl - 1u) as char != os_fs::path_sep) {\n     p += path_sep();\n   }\n   let vec[str] full_paths = vec();\n-  for (str filename in OS_FS.list_dir(p)) {\n-    if (!Str.eq(filename, \".\")) {if (!Str.eq(filename, \"..\")) {\n-      Vec.push[str](full_paths, p + filename);\n+  for (str filename in os_fs::list_dir(p)) {\n+    if (!_str::eq(filename, \".\")) {if (!_str::eq(filename, \"..\")) {\n+      _vec::push[str](full_paths, p + filename);\n     }}\n   }\n   ret full_paths;", "previous_filename": "src/lib/FS.rs"}, {"sha": "6b2795af93e90b6700f2a6a878255900cfc78328", "filename": "src/lib/generic_os.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -0,0 +1,9 @@\n+fn getenv(str n) -> option::t[str] {\n+  auto s = os::libc::getenv(_str::buf(n));\n+  if ((s as int) == 0) {\n+    ret option::none[str];\n+  } else {\n+    ret option::some[str](_str::str_from_cstr(s));\n+  }\n+}\n+"}, {"sha": "c1bcaae30c54357319d2dd2d28e9ba790eb0b2dd", "filename": "src/lib/getopts.rs", "status": "renamed", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -7,8 +7,8 @@\n  * argument values out of the match object.\n  */ \n \n-import Option.some;\n-import Option.none;\n+import option::some;\n+import option::none;\n \n tag name { long(str); short(char); }\n tag hasarg { yes; no; maybe; }\n@@ -17,7 +17,7 @@ tag occur { req; optional; multi; }\n type opt = rec(name name, hasarg hasarg, occur occur);\n \n fn mkname(str nm) -> name {\n-    if (Str.char_len(nm) == 1u) { ret short(Str.char_at(nm, 0u)); }\n+    if (_str::char_len(nm) == 1u) { ret short(_str::char_at(nm, 0u)); }\n     else { ret long(nm); }\n }\n fn reqopt(str name) -> opt {\n@@ -41,11 +41,11 @@ tag optval {\n type match = rec(vec[opt] opts, vec[mutable vec[optval]] vals, vec[str] free);\n \n fn is_arg(str arg) -> bool {\n-    ret Str.byte_len(arg) > 1u && arg.(0) == '-' as u8;\n+    ret _str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n }\n fn name_str(name nm) -> str {\n     alt (nm) {\n-        case (short(?ch)) {ret Str.from_char(ch);}\n+        case (short(?ch)) {ret _str::from_char(ch);}\n         case (long(?s)) {ret s;}\n     }\n }\n@@ -55,16 +55,16 @@ fn name_eq(name a, name b) -> bool {\n     alt (a) {\n         case (long(?a)) {\n             alt (b) {\n-                case (long(?b)) { ret Str.eq(a, b); }\n+                case (long(?b)) { ret _str::eq(a, b); }\n                 case (_) { ret false; }\n             }\n         }\n         case (_) { if (a == b) { ret true; } else {ret false; } }\n     }\n }\n-fn find_opt(vec[opt] opts, name nm) -> Option.t[uint] {\n+fn find_opt(vec[opt] opts, name nm) -> option::t[uint] {\n     auto i = 0u;\n-    auto l = Vec.len[opt](opts);\n+    auto l = _vec::len[opt](opts);\n     while (i < l) {\n         if (name_eq(opts.(i).name, nm)) { ret some[uint](i); }\n         i += 1u;\n@@ -91,7 +91,7 @@ fn fail_str(fail_ f) -> str {\n             ret \"Required option '\" + nm + \"' missing.\";\n         }\n         case (option_duplicated(?nm)) {\n-            ret \"Option '\" + nm + \"' given more than once.\";\n+            ret \"option '\" + nm + \"' given more than once.\";\n         }\n     }\n }\n@@ -102,41 +102,41 @@ tag result {\n }\n \n fn getopts(vec[str] args, vec[opt] opts) -> result {\n-    auto n_opts = Vec.len[opt](opts);\n-    fn empty_(uint x) -> vec[optval]{ret Vec.empty[optval]();}\n+    auto n_opts = _vec::len[opt](opts);\n+    fn empty_(uint x) -> vec[optval]{ret _vec::empty[optval]();}\n     auto f = empty_;\n-    auto vals = Vec.init_fn_mut[vec[optval]](f, n_opts);\n+    auto vals = _vec::init_fn_mut[vec[optval]](f, n_opts);\n     let vec[str] free = vec();\n \n-    auto l = Vec.len[str](args);\n+    auto l = _vec::len[str](args);\n     auto i = 0u;\n     while (i < l) {\n         auto cur = args.(i);\n-        auto curlen = Str.byte_len(cur);\n+        auto curlen = _str::byte_len(cur);\n         if (!is_arg(cur)) {\n-            Vec.push[str](free, cur);\n-        } else if (Str.eq(cur, \"--\")) {\n-            free += Vec.slice[str](args, i + 1u, l);\n+            _vec::push[str](free, cur);\n+        } else if (_str::eq(cur, \"--\")) {\n+            free += _vec::slice[str](args, i + 1u, l);\n             break;\n         } else {\n             auto names;\n-            auto i_arg = Option.none[str];\n+            auto i_arg = option::none[str];\n             if (cur.(1) == '-' as u8) {\n-                auto tail = Str.slice(cur, 2u, curlen);\n-                auto eq = Str.index(tail, '=' as u8);\n+                auto tail = _str::slice(cur, 2u, curlen);\n+                auto eq = _str::index(tail, '=' as u8);\n                 if (eq == -1) {\n                     names = vec(long(tail));\n                 } else {\n-                    names = vec(long(Str.slice(tail, 0u, eq as uint)));\n-                    i_arg = Option.some[str]\n-                        (Str.slice(tail, (eq as uint) + 1u, curlen - 2u));\n+                    names = vec(long(_str::slice(tail, 0u, eq as uint)));\n+                    i_arg = option::some[str]\n+                        (_str::slice(tail, (eq as uint) + 1u, curlen - 2u));\n                 }\n             } else {\n                 auto j = 1u;\n                 names = vec();\n                 while (j < curlen) {\n-                    auto range = Str.char_range_at(cur, j);\n-                    Vec.push[name](names, short(range._0));\n+                    auto range = _str::char_range_at(cur, j);\n+                    _vec::push[name](names, short(range._0));\n                     j = range._1;\n                 }\n             }\n@@ -152,29 +152,29 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                 }\n                 alt (opts.(optid).hasarg) {\n                     case (no) {\n-                        Vec.push[optval](vals.(optid), given);\n+                        _vec::push[optval](vals.(optid), given);\n                     }\n                     case (maybe) {\n-                        if (!Option.is_none[str](i_arg)) {\n-                            Vec.push[optval](vals.(optid),\n-                                              val(Option.get[str](i_arg)));\n-                        } else if (name_pos < Vec.len[name](names) ||\n+                        if (!option::is_none[str](i_arg)) {\n+                            _vec::push[optval](vals.(optid),\n+                                              val(option::get[str](i_arg)));\n+                        } else if (name_pos < _vec::len[name](names) ||\n                                    i + 1u == l || is_arg(args.(i + 1u))) {\n-                            Vec.push[optval](vals.(optid), given);\n+                            _vec::push[optval](vals.(optid), given);\n                         } else {\n                             i += 1u;\n-                            Vec.push[optval](vals.(optid), val(args.(i)));\n+                            _vec::push[optval](vals.(optid), val(args.(i)));\n                         }\n                     }\n                     case (yes) {\n-                        if (!Option.is_none[str](i_arg)) {\n-                            Vec.push[optval](vals.(optid),\n-                                              val(Option.get[str](i_arg)));\n+                        if (!option::is_none[str](i_arg)) {\n+                            _vec::push[optval](vals.(optid),\n+                                              val(option::get[str](i_arg)));\n                         } else if (i + 1u == l) {\n                             ret failure(argument_missing(name_str(nm)));\n                         } else {\n                             i += 1u;\n-                            Vec.push[optval](vals.(optid), val(args.(i)));\n+                            _vec::push[optval](vals.(optid), val(args.(i)));\n                         }\n                     }\n                 }\n@@ -185,7 +185,7 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n \n     i = 0u;\n     while (i < n_opts) {\n-        auto n = Vec.len[optval](vals.(i));\n+        auto n = _vec::len[optval](vals.(i));\n         auto occ = opts.(i).occur;\n         if (occ == req) {if (n == 0u) {\n             ret failure(option_missing(name_str(opts.(i).name)));\n@@ -212,7 +212,7 @@ fn opt_val(match m, str nm) -> optval {\n     ret opt_vals(m, nm).(0);\n }\n fn opt_present(match m, str nm) -> bool {\n-    ret Vec.len[optval](opt_vals(m, nm)) > 0u;\n+    ret _vec::len[optval](opt_vals(m, nm)) > 0u;\n }\n fn opt_str(match m, str nm) -> str {\n     alt (opt_val(m, nm)) {\n@@ -224,15 +224,15 @@ fn opt_strs(match m, str nm) -> vec[str] {\n     let vec[str] acc = vec();\n     for (optval v in opt_vals(m, nm)) {\n         alt (v) {\n-            case (val(?s)) { Vec.push[str](acc, s); }\n+            case (val(?s)) { _vec::push[str](acc, s); }\n             case (_) {}\n         }\n     }\n     ret acc;\n }\n-fn opt_maybe_str(match m, str nm) -> Option.t[str] {\n+fn opt_maybe_str(match m, str nm) -> option::t[str] {\n     auto vals = opt_vals(m, nm);\n-    if (Vec.len[optval](vals) == 0u) { ret none[str]; }\n+    if (_vec::len[optval](vals) == 0u) { ret none[str]; }\n     alt (vals.(0)) {\n         case (val(?s)) { ret some[str](s); }\n         case (_) { ret none[str]; }", "previous_filename": "src/lib/GetOpts.rs"}, {"sha": "c996584f8f0583ed3df79dead1146d8f73248955", "filename": "src/lib/io.rs", "status": "renamed", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,8 +1,8 @@\n-import OS.libc;\n+import os::libc;\n \n native \"rust\" mod rustrt {\n-  fn rust_get_stdin() -> OS.libc.FILE;\n-  fn rust_get_stdout() -> OS.libc.FILE;\n+  fn rust_get_stdin() -> os::libc::FILE;\n+  fn rust_get_stdout() -> os::libc::FILE;\n }\n \n // Reading\n@@ -55,30 +55,30 @@ fn convert_whence(seek_style whence) -> int {\n     }\n }\n \n-state obj FILE_buf_reader(OS.libc.FILE f, bool must_close) {\n+state obj FILE_buf_reader(os::libc::FILE f, bool must_close) {\n     fn read(uint len) -> vec[u8] {\n-        auto buf = Vec.alloc[u8](len);\n-        auto read = OS.libc.fread(Vec.buf[u8](buf), 1u, len, f);\n-        Vec.len_set[u8](buf, read);\n+        auto buf = _vec::alloc[u8](len);\n+        auto read = os::libc::fread(_vec::buf[u8](buf), 1u, len, f);\n+        _vec::len_set[u8](buf, read);\n         ret buf;\n     }\n     fn read_byte() -> int {\n-        ret OS.libc.fgetc(f);\n+        ret os::libc::fgetc(f);\n     }\n     fn unread_byte(int byte) {\n-        OS.libc.ungetc(byte, f);\n+        os::libc::ungetc(byte, f);\n     }\n     fn eof() -> bool {\n-        ret OS.libc.feof(f) != 0;\n+        ret os::libc::feof(f) != 0;\n     }\n     fn seek(int offset, seek_style whence) {\n-        assert (OS.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n     }\n     fn tell() -> uint {\n-        ret OS.libc.ftell(f) as uint;\n+        ret os::libc::ftell(f) as uint;\n     }\n     drop {\n-        if (must_close) { OS.libc.fclose(f); }\n+        if (must_close) { os::libc::fclose(f); }\n     }\n }\n \n@@ -100,7 +100,7 @@ state obj new_reader(buf_reader rdr) {\n         auto c0 = rdr.read_byte();\n         if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n         auto b0 = c0 as u8;\n-        auto w = Str.utf8_char_width(b0);\n+        auto w = _str::utf8_char_width(b0);\n         assert (w > 0u);\n         if (w == 1u) {ret b0 as char;}\n         auto val = 0u;\n@@ -112,7 +112,7 @@ state obj new_reader(buf_reader rdr) {\n             val <<= 6u;\n             val += (next & 0x3f) as uint;\n         }\n-        // See Str.char_at\n+        // See _str::char_at\n         val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n         ret val as char;\n     }\n@@ -126,19 +126,19 @@ state obj new_reader(buf_reader rdr) {\n         while (go_on) {\n             auto ch = rdr.read_byte();\n             if (ch == -1 || ch == 10) {go_on = false;}\n-            else {Vec.push[u8](buf, ch as u8);}\n+            else {_vec::push[u8](buf, ch as u8);}\n         }\n-        ret Str.unsafe_from_bytes(buf);\n+        ret _str::unsafe_from_bytes(buf);\n     }\n     fn read_c_str() -> str {\n         let vec[u8] buf = vec();\n         auto go_on = true;\n         while (go_on) {\n             auto ch = rdr.read_byte();\n             if (ch < 1) {go_on = false;}\n-            else {Vec.push[u8](buf, ch as u8);}\n+            else {_vec::push[u8](buf, ch as u8);}\n         }\n-        ret Str.unsafe_from_bytes(buf);\n+        ret _str::unsafe_from_bytes(buf);\n     }\n     // FIXME deal with eof?\n     fn read_le_uint(uint size) -> uint {\n@@ -164,7 +164,7 @@ state obj new_reader(buf_reader rdr) {\n     // FIXME deal with eof?\n     fn read_be_uint(uint size) -> uint {\n         auto val = 0u;\n-        auto sz = size; // FIXME: trans.ml bug workaround\n+        auto sz = size; // FIXME: trans::ml bug workaround\n         while (sz > 0u) {\n             sz -= 1u;\n             val += (rdr.read_byte() as uint) << (sz * 8u);\n@@ -187,11 +187,11 @@ state obj new_reader(buf_reader rdr) {\n }\n \n fn stdin() -> reader {\n-    ret new_reader(FILE_buf_reader(rustrt.rust_get_stdin(), false));\n+    ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), false));\n }\n \n fn file_reader(str path) -> reader {\n-    auto f = OS.libc.fopen(Str.buf(path), Str.buf(\"r\"));\n+    auto f = os::libc::fopen(_str::buf(path), _str::buf(\"r\"));\n     if (f as uint == 0u) {\n         log_err \"error opening \" + path;\n         fail;\n@@ -212,17 +212,17 @@ type byte_buf = @rec(vec[u8] buf, mutable uint pos);\n \n state obj byte_buf_reader(byte_buf bbuf) {\n     fn read(uint len) -> vec[u8] {\n-        auto rest = Vec.len[u8](bbuf.buf) - bbuf.pos;\n+        auto rest = _vec::len[u8](bbuf.buf) - bbuf.pos;\n         auto to_read = len;\n         if (rest < to_read) {\n             to_read = rest;\n         }\n-        auto range = Vec.slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n+        auto range = _vec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n         bbuf.pos += to_read;\n         ret range;\n     }\n     fn read_byte() -> int {\n-        if (bbuf.pos == Vec.len[u8](bbuf.buf)) {ret -1;}\n+        if (bbuf.pos == _vec::len[u8](bbuf.buf)) {ret -1;}\n         auto b = bbuf.buf.(bbuf.pos);\n         bbuf.pos += 1u;\n         ret b as int;\n@@ -234,12 +234,12 @@ state obj byte_buf_reader(byte_buf bbuf) {\n     }\n \n     fn eof() -> bool {\n-        ret bbuf.pos == Vec.len[u8](bbuf.buf);\n+        ret bbuf.pos == _vec::len[u8](bbuf.buf);\n     }\n \n     fn seek(int offset, seek_style whence) {\n         auto pos = bbuf.pos;\n-        auto len = Vec.len[u8](bbuf.buf);\n+        auto len = _vec::len[u8](bbuf.buf);\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -268,40 +268,40 @@ type buf_writer = state obj {\n   fn tell() -> uint; // FIXME: eventually u64\n };\n \n-state obj FILE_writer(OS.libc.FILE f, bool must_close) {\n+state obj FILE_writer(os::libc::FILE f, bool must_close) {\n     fn write(vec[u8] v) {\n-        auto len = Vec.len[u8](v);\n-        auto vbuf = Vec.buf[u8](v);\n-        auto nout = OS.libc.fwrite(vbuf, len, 1u, f);\n+        auto len = _vec::len[u8](v);\n+        auto vbuf = _vec::buf[u8](v);\n+        auto nout = os::libc::fwrite(vbuf, len, 1u, f);\n         if (nout < 1u) {\n             log_err \"error dumping buffer\";\n         }\n     }\n \n     fn seek(int offset, seek_style whence) {\n-        assert (OS.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n     }\n \n     fn tell() -> uint {\n-        ret OS.libc.ftell(f) as uint;\n+        ret os::libc::ftell(f) as uint;\n     }\n \n     drop {\n-        if (must_close) {OS.libc.fclose(f);}\n+        if (must_close) {os::libc::fclose(f);}\n     }\n }\n \n state obj fd_buf_writer(int fd, bool must_close) {\n     fn write(vec[u8] v) {\n-        auto len = Vec.len[u8](v);\n+        auto len = _vec::len[u8](v);\n         auto count = 0u;\n         auto vbuf;\n         while (count < len) {\n-            vbuf = Vec.buf_off[u8](v, count);\n-            auto nout = OS.libc.write(fd, vbuf, len);\n+            vbuf = _vec::buf_off[u8](v, count);\n+            auto nout = os::libc::write(fd, vbuf, len);\n             if (nout < 0) {\n                 log_err \"error dumping buffer\";\n-                log_err Sys.rustrt.last_os_error();\n+                log_err sys::rustrt::last_os_error();\n                 fail;\n             }\n             count += nout as uint;\n@@ -319,32 +319,32 @@ state obj fd_buf_writer(int fd, bool must_close) {\n     }\n \n     drop {\n-        if (must_close) {OS.libc.close(fd);}\n+        if (must_close) {os::libc::close(fd);}\n     }\n }\n \n fn file_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n     let int fflags =\n-        OS.libc_constants.O_WRONLY() |\n-        OS.libc_constants.O_BINARY();\n+        os::libc_constants::O_WRONLY() |\n+        os::libc_constants::O_BINARY();\n \n     for (fileflag f in flags) {\n         alt (f) {\n-            case (append)   { fflags |= OS.libc_constants.O_APPEND(); }\n-            case (create)   { fflags |= OS.libc_constants.O_CREAT(); }\n-            case (truncate) { fflags |= OS.libc_constants.O_TRUNC(); }\n+            case (append)   { fflags |= os::libc_constants::O_APPEND(); }\n+            case (create)   { fflags |= os::libc_constants::O_CREAT(); }\n+            case (truncate) { fflags |= os::libc_constants::O_TRUNC(); }\n             case (none) {}\n         }\n     }\n \n-    auto fd = OS.libc.open(Str.buf(path),\n+    auto fd = os::libc::open(_str::buf(path),\n                            fflags,\n-                           OS.libc_constants.S_IRUSR() |\n-                           OS.libc_constants.S_IWUSR());\n+                           os::libc_constants::S_IRUSR() |\n+                           os::libc_constants::S_IWUSR());\n \n     if (fd < 0) {\n         log_err \"error opening file for writing\";\n-        log_err Sys.rustrt.last_os_error();\n+        log_err sys::rustrt::last_os_error();\n         fail;\n     }\n     ret fd_buf_writer(fd, true);\n@@ -390,17 +390,17 @@ state obj new_writer(buf_writer out) {\n         ret out;\n     }\n     fn write_str(str s) {\n-        out.write(Str.bytes(s));\n+        out.write(_str::bytes(s));\n     }\n     fn write_char(char ch) {\n         // FIXME needlessly consy\n-        out.write(Str.bytes(Str.from_char(ch)));\n+        out.write(_str::bytes(_str::from_char(ch)));\n     }\n     fn write_int(int n) {\n-        out.write(Str.bytes(Int.to_str(n, 10u)));\n+        out.write(_str::bytes(_int::to_str(n, 10u)));\n     }\n     fn write_uint(uint n) {\n-        out.write(Str.bytes(UInt.to_str(n, 10u)));\n+        out.write(_str::bytes(_uint::to_str(n, 10u)));\n     }\n     fn write_bytes(vec[u8] bytes) {\n         out.write(bytes);\n@@ -427,7 +427,7 @@ fn file_writer(str path, vec[fileflag] flags) -> writer {\n \n // FIXME: fileflags\n fn buffered_file_buf_writer(str path) -> buf_writer {\n-    auto f = OS.libc.fopen(Str.buf(path), Str.buf(\"w\"));\n+    auto f = os::libc::fopen(_str::buf(path), _str::buf(\"w\"));\n     if (f as uint == 0u) {\n         log_err \"error opening \" + path;\n         fail;\n@@ -451,21 +451,21 @@ type mutable_byte_buf = @rec(mutable vec[mutable u8] buf, mutable uint pos);\n state obj byte_buf_writer(mutable_byte_buf buf) {\n     fn write(vec[u8] v) {\n         // Fast path.\n-        if (buf.pos == Vec.len(buf.buf)) {\n+        if (buf.pos == _vec::len(buf.buf)) {\n             // FIXME: Fix our type system. There's no reason you shouldn't be\n             // able to add a mutable vector to an immutable one.\n-            auto mv = Vec.rustrt.unsafe_vec_to_mut[u8](v);\n+            auto mv = _vec::rustrt::unsafe_vec_to_mut[u8](v);\n             buf.buf += mv;\n-            buf.pos += Vec.len[u8](v);\n+            buf.pos += _vec::len[u8](v);\n             ret;\n         }\n \n-        // FIXME: Optimize. These should be unique pointers.\n-        auto vlen = Vec.len[u8](v);\n+        // FIXME: Optimize: These should be unique pointers.\n+        auto vlen = _vec::len[u8](v);\n         auto vpos = 0u;\n         while (vpos < vlen) {\n             auto b = v.(vpos);\n-            if (buf.pos == Vec.len(buf.buf)) {\n+            if (buf.pos == _vec::len(buf.buf)) {\n                 buf.buf += vec(mutable b);\n             } else {\n                 buf.buf.(buf.pos) = b;\n@@ -477,7 +477,7 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n \n     fn seek(int offset, seek_style whence) {\n         auto pos = buf.pos;\n-        auto len = Vec.len(buf.buf);\n+        auto len = _vec::len(buf.buf);\n         buf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -487,12 +487,12 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n     let vec[mutable u8] b = vec(mutable 0u8);\n-    Vec.pop(b);\n+    _vec::pop(b);\n \n     let mutable_byte_buf buf = @rec(mutable buf = b, mutable pos = 0u);\n     state obj str_writer_wrap(writer wr, mutable_byte_buf buf) {\n         fn get_writer() -> writer {ret wr;}\n-        fn get_str() -> str {ret Str.unsafe_from_bytes(buf.buf);}\n+        fn get_str() -> str {ret _str::unsafe_from_bytes(buf.buf);}\n     }\n     ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }", "previous_filename": "src/lib/IO.rs"}, {"sha": "3b074e411fd542a36bb84aba770809b35fc8a212", "filename": "src/lib/linux_os.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n-import Str.sbuf;\n-import Vec.vbuf;\n+import _str::sbuf;\n+import _vec::vbuf;\n \n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n \n-native mod libc = \"libc.so.6\" {\n+native mod libc = \"libc::so.6\" {\n \n     fn open(sbuf s, int flags, uint mode) -> int;\n     fn read(int fd, vbuf buf, uint count) -> int;\n@@ -66,17 +66,17 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (OS.libc.pipe(Vec.buf(fds)) == 0);\n+    assert (os::libc::pipe(_vec::buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n-fn fd_FILE(int fd) -> libc.FILE {\n-    ret libc.fdopen(fd, Str.buf(\"r\"));\n+fn fd_FILE(int fd) -> libc::FILE {\n+    ret libc::fdopen(fd, _str::buf(\"r\"));\n }\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    assert (OS.libc.waitpid(pid, Vec.buf(status), 0) != -1);\n+    assert (os::libc::waitpid(pid, _vec::buf(status), 0) != -1);\n     ret status.(0);\n }\n ", "previous_filename": "src/lib/linux_OS.rs"}, {"sha": "86d6c21dacca4ab074bdc0a48b43c507e97c0641", "filename": "src/lib/list.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import Option.some;\n-import Option.none;\n+import option::some;\n+import option::none;\n \n // FIXME: It would probably be more appealing to define this as\n // type list[T] = rec(T hd, option[@list[T]] tl), but at the moment\n@@ -27,7 +27,7 @@ fn foldl[T,U](&list[T] ls, &U u, fn(&T t, &U u) -> U f) -> U {\n }\n \n fn find[T,U](&list[T] ls,\n-             (fn(&T) -> Option.t[U]) f) -> Option.t[U] {\n+             (fn(&T) -> option::t[U]) f) -> option::t[U] {\n   alt(ls) {\n     case (cons[T](?hd, ?tl)) {\n         alt (f(hd)) {", "previous_filename": "src/lib/List.rs"}, {"sha": "2ad893198533df554cd596a72cf00a730b15271d", "filename": "src/lib/macos_os.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,7 +1,7 @@\n-import Str.sbuf;\n-import Vec.vbuf;\n+import _str::sbuf;\n+import _vec::vbuf;\n \n-native mod libc = \"libc.dylib\" {\n+native mod libc = \"libc::dylib\" {\n \n     fn open(sbuf s, int flags, uint mode) -> int;\n     fn read(int fd, vbuf buf, uint count) -> int;\n@@ -63,17 +63,17 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (OS.libc.pipe(Vec.buf(fds)) == 0);\n+    assert (os::libc::pipe(_vec::buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n-fn fd_FILE(int fd) -> libc.FILE {\n-    ret libc.fdopen(fd, Str.buf(\"r\"));\n+fn fd_FILE(int fd) -> libc::FILE {\n+    ret libc::fdopen(fd, _str::buf(\"r\"));\n }\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    assert (OS.libc.waitpid(pid, Vec.buf(status), 0) != -1);\n+    assert (os::libc::waitpid(pid, _vec::buf(status), 0) != -1);\n     ret status.(0);\n }\n ", "previous_filename": "src/lib/macos_OS.rs"}, {"sha": "5483dccf3420a714ea80eb595f95b2db641c98b8", "filename": "src/lib/map.rs", "status": "renamed", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -11,16 +11,16 @@ state type hashmap[K, V] = state obj {\n                                  fn insert(&K key, &V val) -> bool;\n                                  fn contains_key(&K key) -> bool;\n                                  fn get(&K key) -> V;\n-                                 fn find(&K key) -> Option.t[V];\n-                                 fn remove(&K key) -> Option.t[V];\n+                                 fn find(&K key) -> option::t[V];\n+                                 fn remove(&K key) -> option::t[V];\n                                  fn rehash();\n                                  iter items() -> @tup(K,V);\n };\n \n fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n     let uint initial_capacity = 32u; // 2^5\n-    let Util.rational load_factor = rec(num=3, den=4);\n+    let util::rational load_factor = rec(num=3, den=4);\n \n     tag bucket[K, V] {\n         nil;\n@@ -29,7 +29,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     }\n \n     fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n-        ret Vec.init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n+        ret _vec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n     }\n \n     // Derive two hash functions from the one given by taking the upper\n@@ -96,7 +96,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                          vec[mutable bucket[K, V]] bkts,\n                          uint nbkts,\n                          &K key)\n-        -> Option.t[V]\n+        -> option::t[V]\n         {\n             let uint i = 0u;\n             let uint h = hasher(key);\n@@ -105,17 +105,17 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                 alt (bkts.(j)) {\n                     case (some[K, V](?k, ?v)) {\n                         if (eqer(key, k)) {\n-                            ret Option.some[V](v);\n+                            ret option::some[V](v);\n                         }\n                     }\n                     case (nil[K, V]) {\n-                        ret Option.none[V];\n+                        ret option::none[V];\n                     }\n                     case (deleted[K, V]) { }\n                 }\n                 i += 1u;\n             }\n-            ret Option.none[V];\n+            ret option::none[V];\n         }\n \n \n@@ -140,15 +140,15 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                             mutable vec[mutable bucket[K, V]] bkts,\n                             mutable uint nbkts,\n                             mutable uint nelts,\n-                            Util.rational lf)\n+                            util::rational lf)\n         {\n             fn size() -> uint { ret nelts; }\n \n             fn insert(&K key, &V val) -> bool {\n-                let Util.rational load = rec(num=(nelts + 1u) as int,\n+                let util::rational load = rec(num=(nelts + 1u) as int,\n                                              den=nbkts as int);\n-                if (!Util.rational_leq(load, lf)) {\n-                    let uint nnewbkts = UInt.next_power_of_two(nbkts + 1u);\n+                if (!util::rational_leq(load, lf)) {\n+                    let uint nnewbkts = _uint::next_power_of_two(nbkts + 1u);\n                     let vec[mutable bucket[K, V]] newbkts =\n                         make_buckets[K, V](nnewbkts);\n                     rehash[K, V](hasher, eqer, bkts, nbkts,\n@@ -167,27 +167,27 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n             fn contains_key(&K key) -> bool {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (Option.some[V](_)) { ret true; }\n+                    case (option::some[V](_)) { ret true; }\n                     case (_) { ret false; }\n                 }\n                 fail;   // FIXME: remove me when exhaustiveness checking works\n             }\n \n             fn get(&K key) -> V {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (Option.some[V](?val)) { ret val; }\n+                    case (option::some[V](?val)) { ret val; }\n                     case (_) { fail; }\n                 }\n                 fail;   // FIXME: remove me when exhaustiveness checking works\n             }\n \n-            fn find(&K key) -> Option.t[V] {\n+            fn find(&K key) -> option::t[V] {\n                 // FIXME: should be 'be' but parametric tail-calls don't\n                 // work at the moment.\n                 ret find_common[K, V](hasher, eqer, bkts, nbkts, key);\n             }\n \n-            fn remove(&K key) -> Option.t[V] {\n+            fn remove(&K key) -> option::t[V] {\n                 let uint i = 0u;\n                 let uint h = hasher(key);\n                 while (i < nbkts) {\n@@ -197,17 +197,17 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                             if (eqer(key, k)) {\n                                 bkts.(j) = deleted[K, V];\n                                 nelts -= 1u;\n-                                ret Option.some[V](v);\n+                                ret option::some[V](v);\n                             }\n                         }\n                         case (deleted[K, V]) { }\n                         case (nil[K, V]) {\n-                            ret Option.none[V];\n+                            ret option::none[V];\n                         }\n                     }\n                     i += 1u;\n                 }\n-                ret Option.none[V];\n+                ret option::none[V];\n             }\n \n             fn rehash() {", "previous_filename": "src/lib/Map.rs"}, {"sha": "78ed2fb3614efcfca47dc7a9f08857ab6264290f", "filename": "src/lib/option.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// lib/Option.rs\n+// lib/option::rs\n \n tag t[T] {\n     none;\n@@ -39,7 +39,7 @@ fn is_none[T](&t[T] opt) -> bool {\n }\n \n fn from_maybe[T](&T def, &t[T] opt) -> T {\n-    auto f = bind Util.id[T](_);\n+    auto f = bind util::id[T](_);\n     ret maybe[T, T](def, f, opt);\n }\n ", "previous_filename": "src/lib/Option.rs"}, {"sha": "1244dd1bd98d10f57349e011c7496552e2284415", "filename": "src/lib/posix_fs.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,21 +1,21 @@\n native \"rust\" mod rustrt {\n-  fn rust_dirent_filename(OS.libc.dirent ent) -> str;\n+  fn rust_dirent_filename(os::libc::dirent ent) -> str;\n }\n \n fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n-  auto dir = OS.libc.opendir(Str.buf(path));\n+  auto dir = os::libc::opendir(_str::buf(path));\n   assert (dir as uint != 0u);\n   let vec[str] result = vec();\n   while (true) {\n-    auto ent = OS.libc.readdir(dir);\n+    auto ent = os::libc::readdir(dir);\n     if (ent as int == 0) {\n-        OS.libc.closedir(dir);\n+        os::libc::closedir(dir);\n         ret result;\n     }\n-    Vec.push[str](result, rustrt.rust_dirent_filename(ent));\n+    _vec::push[str](result, rustrt::rust_dirent_filename(ent));\n   }\n-  OS.libc.closedir(dir);\n+  os::libc::closedir(dir);\n   ret result;\n }\n ", "previous_filename": "src/lib/posix_FS.rs"}, {"sha": "da8f552ff53e21b3c9cd63796c3015deb80883ab", "filename": "src/lib/rand.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frand.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -12,16 +12,16 @@ native \"rust\" mod rustrt {\n type rng = obj { fn next() -> u32; };\n \n fn mk_rng() -> rng {\n-    obj rt_rng(rustrt.rctx c) {\n+    obj rt_rng(rustrt::rctx c) {\n         fn next() -> u32 {\n-            ret rustrt.rand_next(c);\n+            ret rustrt::rand_next(c);\n         }\n         drop {\n-            rustrt.rand_free(c);\n+            rustrt::rand_free(c);\n         }\n     }\n \n-    ret rt_rng(rustrt.rand_new());\n+    ret rt_rng(rustrt::rand_new());\n }\n \n // Local Variables:", "previous_filename": "src/lib/Rand.rs"}, {"sha": "abcf1472067efddf367c00fd58e8a5618a2e9415", "filename": "src/lib/run_program.rs", "status": "renamed", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,74 +1,74 @@\n-import Str.sbuf;\n-import Vec.vbuf;\n+import _str::sbuf;\n+import _vec::vbuf;\n \n native \"rust\" mod rustrt {\n     fn rust_run_program(vbuf argv, int in_fd, int out_fd, int err_fd) -> int;\n }\n \n fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n-    auto argptrs = vec(Str.buf(prog));\n+    auto argptrs = vec(_str::buf(prog));\n     for (str arg in args) {\n-        Vec.push[sbuf](argptrs, Str.buf(arg));\n+        _vec::push[sbuf](argptrs, _str::buf(arg));\n     }\n-    Vec.push[sbuf](argptrs, 0 as sbuf);\n+    _vec::push[sbuf](argptrs, 0 as sbuf);\n     ret argptrs;\n }\n \n fn run_program(str prog, vec[str] args) -> int {\n-    auto pid = rustrt.rust_run_program(Vec.buf[sbuf](argvec(prog, args)),\n+    auto pid = rustrt::rust_run_program(_vec::buf[sbuf](argvec(prog, args)),\n                                        0, 0, 0);\n-    ret OS.waitpid(pid);\n+    ret os::waitpid(pid);\n }\n \n type program =\n     state obj {\n         fn get_id() -> int;\n-        fn input() -> IO.writer;\n-        fn output() -> IO.reader;\n+        fn input() -> io::writer;\n+        fn output() -> io::reader;\n         fn close_input();\n         fn finish() -> int;\n     };\n \n fn start_program(str prog, vec[str] args) -> @program {\n-    auto pipe_input = OS.pipe();\n-    auto pipe_output = OS.pipe();\n-    auto pid = rustrt.rust_run_program\n-        (Vec.buf[sbuf](argvec(prog, args)),\n+    auto pipe_input = os::pipe();\n+    auto pipe_output = os::pipe();\n+    auto pid = rustrt::rust_run_program\n+        (_vec::buf[sbuf](argvec(prog, args)),\n          pipe_input._0, pipe_output._1, 0);\n     if (pid == -1) {fail;}\n-    OS.libc.close(pipe_input._0);\n-    OS.libc.close(pipe_output._1);\n+    os::libc::close(pipe_input._0);\n+    os::libc::close(pipe_output._1);\n \n     state obj new_program(int pid,\n                           int in_fd,\n-                          OS.libc.FILE out_file,\n+                          os::libc::FILE out_file,\n                           mutable bool finished) {\n         fn get_id() -> int {ret pid;}\n-        fn input() -> IO.writer {\n-            ret IO.new_writer(IO.fd_buf_writer(in_fd, false));\n+        fn input() -> io::writer {\n+            ret io::new_writer(io::fd_buf_writer(in_fd, false));\n         }\n-        fn output() -> IO.reader {\n-            ret IO.new_reader(IO.FILE_buf_reader(out_file, false));\n+        fn output() -> io::reader {\n+            ret io::new_reader(io::FILE_buf_reader(out_file, false));\n         }\n         fn close_input() {\n-            OS.libc.close(in_fd);\n+            os::libc::close(in_fd);\n         }\n         fn finish() -> int {\n             if (finished) {ret 0;}\n             finished = true;\n-            OS.libc.close(in_fd);\n-            ret OS.waitpid(pid);\n+            os::libc::close(in_fd);\n+            ret os::waitpid(pid);\n         }\n         drop {\n             if (!finished) {\n-                OS.libc.close(in_fd);\n-                OS.waitpid(pid);\n+                os::libc::close(in_fd);\n+                os::waitpid(pid);\n             }\n-            OS.libc.fclose(out_file);\n+            os::libc::fclose(out_file);\n         }\n     }\n     ret @new_program(pid, pipe_input._1,\n-                     OS.fd_FILE(pipe_output._0),\n+                     os::fd_FILE(pipe_output._0),\n                      false);\n }\n \n@@ -80,7 +80,7 @@ fn program_output(str prog, vec[str] args)\n     auto buf = \"\";\n     while (!out.eof()) {\n         auto bytes = out.read_bytes(4096u);\n-        buf += Str.unsafe_from_bytes(bytes);\n+        buf += _str::unsafe_from_bytes(bytes);\n     }\n     ret rec(status=pr.finish(), out=buf);\n }", "previous_filename": "src/lib/Run_Program.rs"}, {"sha": "96535d121f9453250c1b2badb0d2e5c8d6775d9c", "filename": "src/lib/sha1.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -74,8 +74,8 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(&sha1state st) {\n \n         // FIXME: Make precondition\n-        assert (Vec.len(st.h) == digest_buf_len);\n-        assert (Vec.len(st.work_buf) == work_buf_len);\n+        assert (_vec::len(st.h) == digest_buf_len);\n+        assert (_vec::len(st.work_buf) == work_buf_len);\n \n         let int t; // Loop counter\n         auto w = st.work_buf;\n@@ -196,7 +196,7 @@ fn mk_sha1() -> sha1 {\n      */\n     fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n-        assert (Vec.len(st.msg_block) == msg_block_len);\n+        assert (_vec::len(st.msg_block) == msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -240,7 +240,7 @@ fn mk_sha1() -> sha1 {\n \n         fn reset() {\n             // FIXME: Should be typestate precondition\n-            assert (Vec.len(st.h) == digest_buf_len);\n+            assert (_vec::len(st.h) == digest_buf_len);\n \n             st.len_low = 0u32;\n             st.len_high = 0u32;\n@@ -260,7 +260,7 @@ fn mk_sha1() -> sha1 {\n         }\n \n         fn input_str(&str msg) {\n-            add_input(st, Str.bytes(msg));\n+            add_input(st, _str::bytes(msg));\n         }\n \n         fn result() -> vec[u8] {\n@@ -271,19 +271,19 @@ fn mk_sha1() -> sha1 {\n             auto r = mk_result(st);\n             auto s = \"\";\n             for (u8 b in r) {\n-                s += UInt.to_str(b as uint, 16u);\n+                s += _uint::to_str(b as uint, 16u);\n             }\n             ret s;\n         }\n     }\n \n-    auto st = rec(h = Vec.init_elt_mut[u32](0u32, digest_buf_len),\n+    auto st = rec(h = _vec::init_elt_mut[u32](0u32, digest_buf_len),\n                   mutable len_low = 0u32,\n                   mutable len_high = 0u32,\n-                  msg_block = Vec.init_elt_mut[u8](0u8, msg_block_len),\n+                  msg_block = _vec::init_elt_mut[u8](0u8, msg_block_len),\n                   mutable msg_block_idx = 0u,\n                   mutable computed = false,\n-                  work_buf = Vec.init_elt_mut[u32](0u32, work_buf_len));\n+                  work_buf = _vec::init_elt_mut[u32](0u32, work_buf_len));\n     auto sh = sha1(st);\n     sh.reset();\n     ret sh;", "previous_filename": "src/lib/SHA1.rs"}, {"sha": "3b3c64036be2e0343bd49c98639caf5dad683f5b", "filename": "src/lib/sort.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import Vec.len;\n-import Vec.slice;\n+import _vec::len;\n+import _vec::slice;\n \n type lteq[T] = fn(&T a, &T b) -> bool;\n ", "previous_filename": "src/lib/Sort.rs"}, {"sha": "5c0ea313ad43ddac89587b209b38e18b34bb755b", "filename": "src/lib/std.rc", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -6,76 +6,76 @@ meta (name = \"std\",\n \n // Built-in types support modules.\n \n-mod Int;\n-mod UInt;\n-mod U8;\n-mod Vec;\n-mod Str;\n+mod _int;\n+mod _uint;\n+mod _u8;\n+mod _vec;\n+mod _str;\n \n-// General IO and system-services modules.\n+// General io and system-services modules.\n \n-mod IO;\n-mod Sys;\n-mod Task;\n+mod io;\n+mod sys;\n+mod _task;\n \n // Utility modules.\n \n-mod Option;\n-mod Util;\n+mod option;\n+mod util;\n \n // Authorize various rule-bendings.\n \n-auth IO = unsafe;\n-auth FS = unsafe;\n-auth OS_FS = unsafe;\n-auth Run = unsafe;\n-auth Str = unsafe;\n-auth Vec = unsafe;\n-auth Task = unsafe;\n+auth io = unsafe;\n+auth fs = unsafe;\n+auth os_fs = unsafe;\n+auth run = unsafe;\n+auth _str = unsafe;\n+auth _vec = unsafe;\n+auth _task = unsafe;\n \n-auth Dbg = unsafe;\n+auth dbg = unsafe;\n \n-auth UInt.next_power_of_two = unsafe;\n-auth Map.mk_hashmap = unsafe;\n-auth Rand.mk_rng = unsafe;\n+auth _uint::next_power_of_two = unsafe;\n+auth map::mk_hashmap = unsafe;\n+auth rand::mk_rng = unsafe;\n \n-// Target-OS module.\n+// Target-os module.\n \n-// TODO: Have each OS module re-export everything from GenericOS.\n-mod GenericOS;\n+// TODO: Have each os module re-export everything from genericos.\n+mod generic_os;\n \n alt (target_os) {\n     case (\"win32\") {\n-        mod OS = \"win32_OS.rs\";\n-        mod OS_FS = \"win32_FS.rs\";\n+        mod os = \"win32_os.rs\";\n+        mod os_fs = \"win32_fs.rs\";\n     } case (\"macos\") {\n-        mod OS = \"macos_OS.rs\";\n-        mod OS_FS = \"posix_FS.rs\";\n+        mod os = \"macos_os.rs\";\n+        mod os_fs = \"posix_fs.rs\";\n     } else {\n-        mod OS = \"linux_OS.rs\";\n-        mod OS_FS = \"posix_FS.rs\";\n+        mod os = \"linux_os.rs\";\n+        mod os_fs = \"posix_fs.rs\";\n     }\n }\n \n-mod Run = \"Run_Program.rs\";\n-mod FS;\n+mod run = \"run_program.rs\";\n+mod fs;\n \n // FIXME: parametric\n-mod Map;\n-mod Deque;\n-mod List;\n-mod Rand;\n-mod Dbg;\n-mod BitV;\n-mod Sort;\n-mod SHA1;\n-mod EBML;\n-mod UFind;\n-mod ExtFmt;\n-mod Box;\n-mod GetOpts;\n-mod Term;\n-mod Time;\n+mod map;\n+mod deque;\n+mod list;\n+mod rand;\n+mod dbg;\n+mod bitv;\n+mod sort;\n+mod sha1;\n+mod ebml;\n+mod ufind;\n+mod extfmt;\n+mod box;\n+mod getopts;\n+mod term;\n+mod time;\n \n // Local Variables:\n // mode: rust;"}, {"sha": "77eab003573a683a547e463e5f9af125b2f4e915", "filename": "src/lib/sys.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "previous_filename": "src/lib/Sys.rs"}, {"sha": "6fd54a2d4e6f5437a293cea738fddd0b8ad59040", "filename": "src/lib/term.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -21,20 +21,20 @@ const u8 color_bright_magenta = 13u8;\n const u8 color_bright_cyan = 14u8;\n const u8 color_bright_white = 15u8;\n \n-fn esc(IO.buf_writer writer) {\n+fn esc(io::buf_writer writer) {\n     writer.write(vec(0x1bu8, '[' as u8));\n }\n \n-fn reset(IO.buf_writer writer) {\n+fn reset(io::buf_writer writer) {\n     esc(writer);\n     writer.write(vec('0' as u8, 'm' as u8));\n }\n \n fn color_supported() -> bool {\n-    ret GenericOS.getenv(\"TERM\") == Option.some[str](\"xterm-color\");\n+    ret generic_os::getenv(\"TERM\") == option::some[str](\"xterm-color\");\n }\n \n-fn set_color(IO.buf_writer writer, u8 first_char, u8 color) {\n+fn set_color(io::buf_writer writer, u8 first_char, u8 color) {\n     assert (color < 16u8);\n \n     esc(writer);\n@@ -45,11 +45,11 @@ fn set_color(IO.buf_writer writer, u8 first_char, u8 color) {\n     writer.write(vec(first_char, ('0' as u8) + color, 'm' as u8));\n }\n \n-fn fg(IO.buf_writer writer, u8 color) {\n+fn fg(io::buf_writer writer, u8 color) {\n     ret set_color(writer, '3' as u8, color);\n }\n \n-fn bg(IO.buf_writer writer, u8 color) {\n+fn bg(io::buf_writer writer, u8 color) {\n     ret set_color(writer, '4' as u8, color);\n }\n ", "previous_filename": "src/lib/Term.rs"}, {"sha": "645d19ac2739ec299ee0c605d0fda8e97c7c7369", "filename": "src/lib/time.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftime.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -6,7 +6,7 @@ type timeval = rec(u32 sec, u32 usec);\n \n fn get_time() -> timeval {\n     let timeval res = rec(sec=0u32, usec=0u32);\n-    rustrt.get_time(res.sec, res.usec);\n+    rustrt::get_time(res.sec, res.usec);\n     ret res;\n }\n ", "previous_filename": "src/lib/Time.rs"}, {"sha": "faa77305b9edac22d7f940d76187ccdc45022eeb", "filename": "src/lib/ufind.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,19 +1,19 @@\n-import Option.none;\n-import Option.some;\n+import option::none;\n+import option::some;\n \n // A very naive implementation of union-find with unsigned integer nodes.\n \n-type node = Option.t[uint];\n+type node = option::t[uint];\n type ufind = rec(mutable vec[mutable node] nodes);\n \n fn make() -> ufind {\n     let vec[mutable node] v = vec(mutable none[uint]);\n-    Vec.pop(v);  // FIXME: botch\n+    _vec::pop(v);  // FIXME: botch\n     ret rec(mutable nodes=v);\n }\n \n fn make_set(&ufind ufnd) -> uint {\n-    auto idx = Vec.len(ufnd.nodes);\n+    auto idx = _vec::len(ufnd.nodes);\n     ufnd.nodes += vec(mutable none[uint]);\n     ret idx;\n }", "previous_filename": "src/lib/UFind.rs"}, {"sha": "b8d8ed6587d79eee01c4081590108161a32b65f6", "filename": "src/lib/util.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,10 +4,10 @@ fn id[T](&T x) -> T {\n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n  * the constraint once fixed. */\n-type rational = rec(int num, int den); // : Int.positive(*.den);\n+type rational = rec(int num, int den); // : _int::positive(*.den);\n \n fn rational_leq(&rational x, &rational y) -> bool {\n-    // NB: Uses the fact that rationals have positive denominators WLOG.\n+    // NB: Uses the fact that rationals have positive denominators WLOG:\n     ret x.num * y.den <= y.num * x.den;\n }\n ", "previous_filename": "src/lib/Util.rs"}, {"sha": "3e2c4f67bc2a8a9b6cc1b8c6be46ecc0c5ae07ad", "filename": "src/lib/win32_fs.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,7 +4,7 @@ native \"rust\" mod rustrt {\n }\n \n fn list_dir(str path) -> vec[str] {\n-  ret rustrt.rust_list_files(path+\"*\");\n+  ret rustrt::rust_list_files(path+\"*\");\n }\n \n /* FIXME: win32 path handling actually accepts '/' or '\\' and has subtly", "previous_filename": "src/lib/win32_FS.rs"}, {"sha": "e9555249ed4abe734ffc3f22668445db435ebc4c", "filename": "src/lib/win32_os.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import Str.sbuf;\n-import Vec.vbuf;\n+import _str::sbuf;\n+import _vec::vbuf;\n \n native mod libc = \"msvcrt.dll\" {\n     fn open(sbuf s, int flags, uint mode) -> int = \"_open\";\n@@ -53,21 +53,21 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (OS.libc._pipe(Vec.buf(fds), 1024u,\n-                        libc_constants.O_BINARY()) == 0);\n+    assert (os::libc::_pipe(_vec::buf(fds), 1024u,\n+                        libc_constants::O_BINARY()) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n-fn fd_FILE(int fd) -> libc.FILE {\n-    ret libc._fdopen(fd, Str.buf(\"r\"));\n+fn fd_FILE(int fd) -> libc::FILE {\n+    ret libc::_fdopen(fd, _str::buf(\"r\"));\n }\n \n native \"rust\" mod rustrt {\n     fn rust_process_wait(int handle) -> int;\n }\n \n fn waitpid(int pid) -> int {\n-    ret rustrt.rust_process_wait(pid);\n+    ret rustrt::rust_process_wait(pid);\n }\n \n // Local Variables:", "previous_filename": "src/lib/win32_OS.rs"}, {"sha": "5aa3dc2f5445550083bf3cc6de01ba6465fcfe10", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n-/* -*- mode:rust;indent-tabs-mode:nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*- \n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std.Int;\n-import std.Str;\n+import std::_int;\n+import std::_str;\n \n fn b1() -> str {\n   ret \"# of beer on the wall, # of beer.\";\n@@ -32,15 +32,15 @@ case (1) {\n     ns = \"1 bottle\";\n   }\n  case (_) {\n-    ns = Int.to_str(n, 10u) + \" bottles\";\n+    ns = _int::to_str(n, 10u) + \" bottles\";\n   }\n   }\n-  while (i < Str.byte_len(t)) {\n+  while (i < _str::byte_len(t)) {\n     if (t.(i) == ('#' as u8)) {\n       b += ns;\n     }\n     else {\n-      Str.push_byte(b, t.(i));\n+      _str::push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "311fca460c8c511315b65c6c0d767d6454fc2561", "filename": "src/test/bench/99-bottles/99bob-pattern.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n-/* -*- mode:rust;indent-tabs-mode:nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*- \n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std.Int;\n-import std.Str;\n+import std::_int;\n+import std::_str;\n \n tag bottle { none; dual; single; multiple(int);}\n \n@@ -25,8 +25,8 @@ fn show(bottle b) {\n       log \"Take one down and pass it around, 1 bottle of beer on the wall.\";\n     }\n     case (multiple(?n)) {\n-      let str nb =  Int.to_str(n, 10u);\n-      let str mb = Int.to_str(n - 1, 10u);\n+      let str nb =  _int::to_str(n, 10u);\n+      let str mb = _int::to_str(n - 1, 10u);\n       log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n       log \"Take one down and pass it around, \" \n         + mb + \" bottles of beer on the wall.\";"}, {"sha": "569b076a5ec67e20c022581360c96a60498d0119", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n-/* -*- mode:rust;indent-tabs-mode:nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*- \n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std.Int;\n-import std.Str;\n+import std::_int;\n+import std::_str;\n \n fn b1() -> str {\n   ret \"# of beer on the wall, # of beer.\";\n@@ -31,15 +31,15 @@ case (1) {\n     ns = \"1 bottle\";\n   }\n  case (_) {\n-    ns = Int.to_str(n, 10u) + \" bottles\";\n+    ns = _int::to_str(n, 10u) + \" bottles\";\n   }\n   }\n-  while (i < Str.byte_len(t)) {\n+  while (i < _str::byte_len(t)) {\n     if (t.(i) == ('#' as u8)) {\n       b += ns;\n     }\n     else {\n-      Str.push_byte(b, t.(i));\n+      _str::push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "202b653b78f79b281c2cf8362a383d216bd24be9", "filename": "src/test/bench/99-bottles/99bob-tail.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,15 +1,15 @@\n-/* -*- mode:rust;indent-tabs-mode:nil -*- \n+/* -*- mode::rust;indent-tabs-mode::nil -*- \n  * Implementation of 99 Bottles of Beer\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std.Int;\n-import std.Str;\n+import std::_int;\n+import std::_str;\n \n fn main() {\n   fn multiple(int n) {\n-    let str nb =  Int.to_str(n, 10u);\n-    let str mb =  Int.to_str(n - 1, 10u);\n+    let str nb =  _int::to_str(n, 10u);\n+    let str mb =  _int::to_str(n - 1, 10u);\n     log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n     log \"Take one down and pass it around, \" \n       + mb + \" bottles of beer on the wall.\";"}, {"sha": "735ac2d506e7f503bc9b804a44fb255ce59f5159", "filename": "src/test/bench/shootout/binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n use std;\n \n-import std.Int;\n+import std::_int;\n \n tag tree {\n   nil;\n@@ -49,7 +49,7 @@ fn main() {\n \n   auto depth = min_depth;\n   while (depth <= max_depth) {\n-    auto iterations = Int.pow(2, (max_depth - depth + min_depth) as uint);\n+    auto iterations = _int::pow(2, (max_depth - depth + min_depth) as uint);\n     auto chk = 0;\n \n     auto i = 1;"}, {"sha": "0d24d338202905ec5742a33b49d34fac556d1c5f", "filename": "src/test/bench/shootout/fannkuchredux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,8 +2,8 @@\n \n use std;\n \n-import std.Int;\n-import std.Vec;\n+import std::_int;\n+import std::_vec;\n \n fn fannkuch(int n) -> int {\n \n@@ -12,9 +12,9 @@ fn fannkuch(int n) -> int {\n   }\n   auto perm1init_ = perm1init; // Rustboot workaround\n \n-  auto perm = Vec.init_elt(0, n as uint);\n-  auto perm1 = Vec.init_fn(perm1init_, n as uint);\n-  auto count = Vec.init_elt(0, n as uint);\n+  auto perm = _vec::init_elt(0, n as uint);\n+  auto perm1 = _vec::init_fn(perm1init_, n as uint);\n+  auto count = _vec::init_elt(0, n as uint);\n \n   auto f = 0;\n   auto i = 0;"}, {"sha": "ec962e38a4810d282e3186297f1946ff90b24c8d", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -7,10 +7,10 @@\n  * http://shootout.alioth.debian.org/\n  */\n use std;\n-import std.Vec;\n-import std.Str;\n-import std.UInt;\n-import std.Int;\n+import std::_vec;\n+import std::_str;\n+import std::_uint;\n+import std::_int;\n \n fn LINE_LENGTH() -> uint {\n   ret 60u;\n@@ -54,38 +54,38 @@ fn select_random(u32 r, vec[aminoacids] genelist) -> char {\n       ret v.(hi)._0;\n     }\n   }\n-  ret bisect(genelist, 0u, Vec.len[aminoacids](genelist) - 1u, r);\n+  ret bisect(genelist, 0u, _vec::len[aminoacids](genelist) - 1u, r);\n }\n \n fn make_random_fasta(str id, str desc, vec[aminoacids] genelist, int n) {\n   log(\">\" + id + \" \" + desc);\n-  auto rng = myrandom(std.Rand.mk_rng().next());\n+  auto rng = myrandom(std::rand::mk_rng().next());\n   let str op = \"\";\n-  for each (uint i in UInt.range(0u, n as uint)) {\n-    Str.push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n-    if (Str.byte_len(op) >= LINE_LENGTH()) {\n+  for each (uint i in _uint::range(0u, n as uint)) {\n+    _str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n+    if (_str::byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n     }\n   }\n-  if (Str.byte_len(op) > 0u) {\n+  if (_str::byte_len(op) > 0u) {\n     log(op);\n   }\n }\n \n fn make_repeat_fasta(str id, str desc, str s, int n) {\n   log(\">\" + id + \" \" + desc);\n   let str op = \"\";\n-  let uint sl = Str.byte_len(s);\n-  for each (uint i in UInt.range(0u, n as uint)) {\n+  let uint sl = _str::byte_len(s);\n+  for each (uint i in _uint::range(0u, n as uint)) {\n \n-    Str.push_byte(op, s.(i % sl));\n-    if (Str.byte_len(op) >= LINE_LENGTH()) {\n+    _str::push_byte(op, s.(i % sl));\n+    if (_str::byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n     }\n   }\n-  if (Str.byte_len(op) > 0u) {\n+  if (_str::byte_len(op) > 0u) {\n     log(op);\n   }\n }"}, {"sha": "b665e7609db4cc1faeb82b43a36a443f07c0a781", "filename": "src/test/bench/shootout/nbody.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -19,33 +19,33 @@ fn main() {\n                               // 50000000\n         );\n \n-    let vec[Body.props] bodies = NBodySystem.MakeNBodySystem();\n+    let vec[Body::props] bodies = NBodySystem::MakeNBodySystem();\n \n     for (int n in inputs) {\n-        log NBodySystem.energy(bodies);\n+        log NBodySystem::energy(bodies);\n \n         let int i = 0;\n         while (i < n) {\n-            NBodySystem.advance(bodies, 0.01);\n+            NBodySystem::advance(bodies, 0.01);\n             i += 1;\n         }\n-        log NBodySystem.energy(bodies);\n+        log NBodySystem::energy(bodies);\n     }\n }\n \n-// Body.props is a record of floats, so\n-// vec[Body.props] is a vector of records of floats\n+// Body::props is a record of floats, so\n+// vec[Body::props] is a vector of records of floats\n \n mod NBodySystem {\n \n-    fn MakeNBodySystem() -> vec[Body.props] {\n-        let vec[Body.props] bodies = vec(\n-            // these each return a Body.props\n-            Body.sun(), \n-            Body.jupiter(), \n-            Body.saturn(), \n-            Body.uranus(), \n-            Body.neptune());\n+    fn MakeNBodySystem() -> vec[Body::props] {\n+        let vec[Body::props] bodies = vec(\n+            // these each return a Body::props\n+            Body::sun(), \n+            Body::jupiter(), \n+            Body::saturn(), \n+            Body::uranus(), \n+            Body::neptune());\n \n         let float px = 0.0;\n         let float py = 0.0;\n@@ -61,12 +61,12 @@ mod NBodySystem {\n         }\n \n         // side-effecting\n-        Body.offsetMomentum(bodies.(0), px, py, pz);\n+        Body::offsetMomentum(bodies.(0), px, py, pz);\n \n         ret bodies;\n     }\n \n-    fn advance(vec[Body.props] bodies, float dt) -> () {\n+    fn advance(vec[Body::props] bodies, float dt) -> () {\n \n         let int i = 0;\n         while (i < 5) {\n@@ -86,14 +86,14 @@ mod NBodySystem {\n         }\n     }\n \n-    fn advance_one(&Body.props bi, &Body.props bj, float dt) {\n+    fn advance_one(&Body::props bi, &Body::props bj, float dt) {\n         let float dx = bi.x - bj.x;\n         let float dy = bi.y - bj.y;\n         let float dz = bi.z - bj.z;\n \n         let float dSquared = dx * dx + dy * dy + dz * dz;\n \n-        let float distance = llvm.sqrt(dSquared);\n+        let float distance = llvm::sqrt(dSquared);\n         let float mag = dt / (dSquared * distance);\n \n         bi.vx -= dx * bj.mass * mag;\n@@ -105,13 +105,13 @@ mod NBodySystem {\n         bj.vz += dz * bi.mass * mag;\n     }\n \n-    fn move(&Body.props b, float dt) {\n+    fn move(&Body::props b, float dt) {\n         b.x += dt * b.vx;\n         b.y += dt * b.vy;\n         b.z += dt * b.vz;\n     }\n \n-    fn energy(vec[Body.props] bodies) -> float {\n+    fn energy(vec[Body::props] bodies) -> float {\n         let float dx;\n         let float dy;\n         let float dz;\n@@ -131,7 +131,7 @@ mod NBodySystem {\n                 dy = bodies.(i).y - bodies.(j).y;\n                 dz = bodies.(i).z - bodies.(j).z;\n \n-                distance = llvm.sqrt(dx*dx + dy*dy + dz*dz);\n+                distance = llvm::sqrt(dx*dx + dy*dy + dz*dz);\n                 e -= (bodies.(i).mass * bodies.(j).mass) / distance;\n                 \n                 j += 1;\n@@ -158,7 +158,7 @@ mod Body {\n                      mutable float vz, \n                      float mass);\n \n-    fn jupiter() -> Body.props {\n+    fn jupiter() -> Body::props {\n         ret rec(\n             mutable x  =  4.84143144246472090e+00,\n             mutable y  = -1.16032004402742839e+00,\n@@ -170,7 +170,7 @@ mod Body {\n             );\n     }\n \n-    fn saturn() -> Body.props {\n+    fn saturn() -> Body::props {\n         ret rec(\n             mutable x  =  8.34336671824457987e+00,\n             mutable y  =  4.12479856412430479e+00,\n@@ -182,7 +182,7 @@ mod Body {\n             );\n    }\n \n-    fn uranus() -> Body.props {\n+    fn uranus() -> Body::props {\n         ret rec(\n             mutable x  =  1.28943695621391310e+01,\n             mutable y  = -1.51111514016986312e+01,\n@@ -194,7 +194,7 @@ mod Body {\n             );\n     }\n \n-    fn neptune() -> Body.props {\n+    fn neptune() -> Body::props {\n         ret rec(\n             mutable x  =  1.53796971148509165e+01,\n             mutable y  = -2.59193146099879641e+01,\n@@ -206,7 +206,7 @@ mod Body {\n             );\n    }\n \n-   fn sun() -> Body.props {\n+   fn sun() -> Body::props {\n        ret rec(\n            mutable x  =  0.0,\n            mutable y  =  0.0,\n@@ -218,7 +218,7 @@ mod Body {\n            );\n    }\n \n-   fn offsetMomentum(&Body.props props,\n+   fn offsetMomentum(&Body::props props,\n                             float px, \n                             float py, \n                             float pz) -> () {"}, {"sha": "e8388c5570701b0b76a14e77e15fdcd5976f64ad", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,5 +5,5 @@ mod m1 {\n }\n \n fn main(vec[str] args) {\n-  log m1.a;\n+  log m1::a;\n }"}, {"sha": "607c917387b752dcaadbcccfe63a1e793b44abfe", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n-// error-pattern: can't refer to a module as a first-class value\n+// error-pattern: is a module, not a\n \n mod m1 {\n   mod a {\n   }\n }\n \n fn main(vec[str] args) {\n-  log m1.a;\n+  log m1::a;\n }"}, {"sha": "f7c8fac16d81baa514ea996d79f52b2f15bfa036", "filename": "src/test/compile-fail/break-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n // xfail-boot\n-// error-pattern:Unsatisfied precondition\n+// error-pattern::Unsatisfied precondition\n \n fn foo() -> int {\n   let int x;"}, {"sha": "608ca03b323e057147c55c8081edd09efac3b7ee", "filename": "src/test/compile-fail/break-uninit2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n // xfail-boot\n-// error-pattern:Unsatisfied precondition\n+// error-pattern::Unsatisfied precondition\n \n fn foo() -> int {\n   let int x;"}, {"sha": "75b9de2886b9b18fc345c994ec12730a66e35f0a", "filename": "src/test/compile-fail/export-boot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-boot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-boot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-boot.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -17,5 +17,5 @@ mod foo {\n }\n \n fn main() {\n-  foo.z(10);\n+  foo::z(10);\n }"}, {"sha": "2c64a48d99ccde4968de994b81ca9cb9ac181c69", "filename": "src/test/compile-fail/export-fully-qualified.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -10,7 +10,7 @@ mod foo {\n   export bar;\n \n   fn bar() {\n-    foo.baz();\n+    foo::baz();\n   }\n \n   fn baz() {"}, {"sha": "1ef963f852a2d581db6f5f705cc2be1a82dc9bf4", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage0\n // error-pattern: unresolved import\n \n-import m.unexported;\n+import m::unexported;\n \n mod m {\n   export exported;"}, {"sha": "7676191c8ea56d6a8736bf42c4fba5d2da7de561", "filename": "src/test/compile-fail/export-no-tag-variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -13,5 +13,5 @@ mod foo {\n }\n \n fn main() {\n-  auto x = foo.t1;\n+  auto x = foo::t1;\n }"}, {"sha": "5af6b07cf1ead60a16ef0719323145db86b158df", "filename": "src/test/compile-fail/export-tag-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -13,5 +13,5 @@ mod foo {\n }\n \n fn main() {\n-  auto z = foo.y1;\n+  auto z = foo::y1;\n }"}, {"sha": "8df742f4df2b2f7459283f4e0eda18d0cb4bf9e3", "filename": "src/test/compile-fail/export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -11,5 +11,5 @@ mod foo {\n }\n \n fn main() {\n-  foo.z(10);\n+  foo::z(10);\n }"}, {"sha": "720a21d8df51b5701a0b48681dedbebf50b0ee07", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,7 +5,7 @@ mod foo {\n   export x;\n \n   fn x() {\n-    bar.x();\n+    bar::x();\n   }\n }\n \n@@ -21,5 +21,5 @@ mod bar {\n }\n \n fn main() {\n-  foo.x();\n+  foo::x();\n }"}, {"sha": "fdb9f41d18b2c8e831c84f6b3ae0224ea3b61dc1", "filename": "src/test/compile-fail/import-loop-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,11 +1,11 @@\n-// error-pattern:cyclic import\n+// error-pattern::cyclic import\n \n mod a {\n-  import b.x;\n+  import b::x;\n }\n \n mod b {\n-  import a.x;\n+  import a::x;\n \n   fn main() {\n     auto y = x;"}, {"sha": "f6d1f02038a6f8263ad3dd21dbc7aebbd85d2c83", "filename": "src/test/compile-fail/import-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:cyclic import\n+// error-pattern::cyclic import\n \n import x;\n "}, {"sha": "7fe01bf49805557936f70847b939fc4bd9e95052", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,8 +1,8 @@\n // xfail-boot\n // xfail-stage0\n // error-pattern: unresolved import: baz\n-import zed.bar;\n-import zed.baz;\n+import zed::bar;\n+import zed::baz;\n mod zed {\n   fn bar() {\n     log \"bar\";"}, {"sha": "beb704ca3e74e19738a1cf6ae600a3a2f6783567", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n // xfail-boot\n // error-pattern: unresolved name\n-import baz.zed.bar;\n+import baz::zed::bar;\n mod baz {\n }\n mod zed {"}, {"sha": "ba7a178c37d1715b2da49e4dfd1a4ee7cb984521", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n // xfail-boot\n // error-pattern: main is not a module or crate\n-import main.bar;\n+import main::bar;\n \n fn main(vec[str] args) {\n   log \"foo\";"}, {"sha": "3df84c10fb4eb74afc79ef3da2f1e2bfb5db29d9", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,8 +1,8 @@\n // xfail-boot\n // error-pattern: cyclic import\n \n-import zed.bar;\n-import bar.zed;\n+import zed::bar;\n+import bar::zed;\n \n fn main(vec[str] args) {\n   log \"loop\";"}, {"sha": "a4be26a49f0998035c1ba242b95af66e30b15c48", "filename": "src/test/compile-fail/multiline-comment-line-tracking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n // -*- rust -*-\n-// error-pattern:9:2\n+// error-pattern::9:2\n \n /* 1\n  * 2"}, {"sha": "b3eae575d2ab0aa1e353592d3e96e980c5d89c7f", "filename": "src/test/compile-fail/reserved-dec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-dec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-dec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-dec.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int dec = 0;"}, {"sha": "cb8b5fa15414e5c8931c1d047cb543cf42a271fb", "filename": "src/test/compile-fail/reserved-f128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-f128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-f128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-f128.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int f128 = 0;"}, {"sha": "d004ffb88ccadea2fc53b71ab1d862002a017c2e", "filename": "src/test/compile-fail/reserved-f16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-f16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-f16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-f16.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int f16 = 0;"}, {"sha": "7d57424bdc109186965d0f17e87f160c541d7eeb", "filename": "src/test/compile-fail/reserved-f80.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-f80.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-f80.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-f80.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int f80 = 0;"}, {"sha": "6c49ab6eee0ee04e6f19a00efeb5d2d929e64e2c", "filename": "src/test/compile-fail/reserved-m128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-m128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-m128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-m128.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int m128 = 0;"}, {"sha": "e40f8427421051263e05d37358838c4822ef9d4e", "filename": "src/test/compile-fail/reserved-m32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-m32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-m32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-m32.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int m32 = 0;"}, {"sha": "ef0406f5f557e1bdd69e9fec5cc10fd07f7c0b15", "filename": "src/test/compile-fail/reserved-m64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-m64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Freserved-m64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-m64.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:reserved keyword\n+// error-pattern::reserved keyword\n \n fn main() {\n   let int m64 = 0;"}, {"sha": "a65f5abf7dc5be0b3d84ba57499ceadebd48adcd", "filename": "src/test/compile-fail/self-missing-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n // xfail-boot\n-// error-pattern:expecting ., found (\n+// error-pattern::expecting ., found (\n fn main() {\n \n   obj foo() {"}, {"sha": "d8e9ef804532554f1ccf6fe594ca557a2ea398e5", "filename": "src/test/compile-fail/use-uninit-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:Unsatisfied precondition\n+// error-pattern::Unsatisfied precondition\n \n fn foo(int x) {\n   log x;"}, {"sha": "9628d4f9c23d743df4c8a129f5ebd1962725a012", "filename": "src/test/compile-fail/use-uninit-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:Unsatisfied precondition\n+// error-pattern::Unsatisfied precondition\n \n fn foo(int x) {\n   log x;"}, {"sha": "bc8d74c2eb1983c1b5094f0a7181c0e2acde540b", "filename": "src/test/compile-fail/use-uninit-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:Unsatisfied precondition\n+// error-pattern::Unsatisfied precondition\n \n fn main() {\n  state obj foo(int x) {"}, {"sha": "4f27b5bc307956346d5f928f83b4adbc36a2814d", "filename": "src/test/compile-fail/use-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:Unsatisfied precondition\n+// error-pattern::Unsatisfied precondition\n \n fn foo(int x) {\n   log x;"}, {"sha": "3a56ebfd305136535b37c4409c99395ea06ab224", "filename": "src/test/run-fail/explicit-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // xfail-stage1\n // xfail-stage2\n-// error-pattern:explicit\n+// error-pattern::explicit\n \n fn main() {\n   fail;"}, {"sha": "aedebc5542a3d7765e63555aa43f7aab1c48de0f", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // xfail-stage1\n // xfail-stage2\n-// error-pattern:1 == 2\n+// error-pattern::1 == 2\n \n fn main() {\n    assert (1 == 2);"}, {"sha": "d75391bc68cd04db5f0c128e6562e1cb5a170454", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage2\n // -*- rust -*-\n \n-// error-pattern:1 == 2\n+// error-pattern::1 == 2\n \n fn child() {\n   assert (1 == 2);"}, {"sha": "a74f98152fed948de13f2c26b1848fa883c5a123", "filename": "src/test/run-fail/non-exhaustive-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage2\n // -*- rust -*-\n \n-// error-pattern:non-exhaustive match failure\n+// error-pattern::non-exhaustive match failure\n \n tag t {\n   a;"}, {"sha": "3af784a43c5310334b1d9cd7963542856e73920f", "filename": "src/test/run-fail/pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpred.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage2\n // -*- rust -*-\n \n-// error-pattern:predicate check\n+// error-pattern::predicate check\n \n fn f(int a, int b) : lt(a,b) {\n }"}, {"sha": "c31f22c0e8e8b4ba4de5f70786d96a73eb5892a3", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage2\n // -*- rust -*-\n \n-// error-pattern:bounds check\n+// error-pattern::bounds check\n \n fn main() {\n   let str s = \"hello\";"}, {"sha": "c492ffeac43d937af8aeab885e92b19b1bce6018", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage2\n // -*- rust -*-\n \n-// error-pattern:bounds check\n+// error-pattern::bounds check\n \n fn main() {\n   let vec[int] v = vec(10);"}, {"sha": "837548d36fc22ef4834f02dbb5536cc3439d24cd", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage2\n // -*- rust -*-\n \n-// error-pattern:bounds check\n+// error-pattern::bounds check\n \n fn main() {\n   let vec[int] v = vec(10, 20);"}, {"sha": "a785f91d3b449951bf0ea8cf428d2cd98442431c", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std.Option;\n-import std.Option.t;\n-import std.Option.none;\n-import std.Option.some;\n+import std::option;\n+import std::option::t;\n+import std::option::none;\n+import std::option::some;\n \n-fn foo[T](&Option.t[T] y) {\n+fn foo[T](&option::t[T] y) {\n   let int x;\n   \n   let vec[int] res = vec();"}, {"sha": "205500e1c92293a7e76874ef10265773a122fdd1", "filename": "src/test/run-pass/alt-path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Falt-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Falt-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-path.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,9 +4,9 @@ mod m1 {\n     foo2;\n   }\n }\n-fn bar(m1.foo x) {\n+fn bar(m1::foo x) {\n   alt(x) {\n-    case (m1.foo1) {\n+      case (m1::foo1) {\n     }\n   }\n }"}, {"sha": "a59248ebfa8eb699171d256d190f7308fa5d72a8", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,9 +1,9 @@\n // -*- rust -*-\n \n use std;\n-import std.Str;\n+import std::_str;\n \n-// FIXME: import std.Dbg.const_refcount. Currently\n+// FIXME: import std::dbg.const_refcount. Currently\n // cross-crate const references don't work.\n const uint const_refcount = 0x7bad_face_u;\n \n@@ -20,13 +20,13 @@ fn foo(str s) {\n     case (_) { log \"?\"; fail; }\n   }\n \n-  log Str.refcount(s);\n-  assert (Str.refcount(s) == const_refcount);\n+  log _str::refcount(s);\n+  assert (_str::refcount(s) == const_refcount);\n }\n \n fn main() {\n   let str s = \"hi\";     // ref up\n   foo(s);               // ref up then down\n-  log Str.refcount(s);\n-  assert (Str.refcount(s) == const_refcount);\n+  log _str::refcount(s);\n+  assert (_str::refcount(s) == const_refcount);\n }"}, {"sha": "7e488631051a04f62a323721e5c09f1282dfac10", "filename": "src/test/run-pass/export-abstract-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-abstract-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-abstract-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-abstract-tag.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -15,5 +15,5 @@ mod foo {\n }\n \n fn main() {\n-  let foo.t v = foo.f();\n+  let foo::t v = foo::f();\n }"}, {"sha": "533df528043c8efddd7eabb4c939d8670b7ea77a", "filename": "src/test/run-pass/export-non-interference2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -14,5 +14,5 @@ mod foo {\n }\n \n fn main() {\n-  foo.bar.y();\n+  foo::bar::y();\n }"}, {"sha": "7b936b63e1150187f98794512d68687e83415d54", "filename": "src/test/run-pass/export-non-interference3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@ mod foo {\n   export x;\n \n   fn x() {\n-    bar.x();\n+    bar::x();\n   }\n }\n \n@@ -15,5 +15,5 @@ mod bar {\n }\n \n fn main() {\n-  foo.x();\n+  foo::x();\n }"}, {"sha": "309261a50d5ebb887d3da3862350da8ce571d02e", "filename": "src/test/run-pass/export-tag-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-tag-variant.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -8,5 +8,5 @@ mod foo {\n }\n \n fn main() {\n-  auto v = foo.t1;\n+  auto v = foo::t1;\n }"}, {"sha": "dcb88af2f73d42c80db0c25bbdbcc972aa69136c", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -20,5 +20,5 @@ mod foo {\n }\n \n fn main() {\n-  foo.g(foo.f());\n+  foo::g(foo::f());\n }\n\\ No newline at end of file"}, {"sha": "49dc3ed789de71933fa604e9bc1223a01c587085", "filename": "src/test/run-pass/generic-fn-twice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fgeneric-fn-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fgeneric-fn-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-twice.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,6 +5,6 @@ mod foomod {\n }\n \n fn main() {\n-  foomod.foo[int]();\n-  foomod.foo[int]();\n+  foomod::foo[int]();\n+  foomod::foo[int]();\n }"}, {"sha": "2bccd392a33a230b42f5ec59947ad5bc471e8f18", "filename": "src/test/run-pass/import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,8 +5,8 @@ mod foo {\n }\n \n mod bar {\n-  import foo.x;\n-  import z = foo.x;\n+  import foo::x;\n+  import z = foo::x;\n   fn main() {\n     x(10);\n     z(10);"}, {"sha": "2531b857ae1709871d3ddd310e6bc2be9d684494", "filename": "src/test/run-pass/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-import zed.bar;\n+import zed::bar;\n mod zed {\n   fn bar() {\n     log \"bar\";"}, {"sha": "282c4d232d4387de9aad428511048374fa8f65bc", "filename": "src/test/run-pass/import3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport3.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import zed.bar;\n-import baz.zed;\n+import zed::bar;\n+import baz::zed;\n mod baz {\n   mod zed {\n     fn bar() {"}, {"sha": "2c4170a397ea7fb54de612c979d673cfd4c7f7b4", "filename": "src/test/run-pass/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport4.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,4 +1,4 @@\n-import zed.bar;\n+import zed::bar;\n mod zed {\n   fn bar() {\n     log \"bar\";"}, {"sha": "077cc14cd970ed2087cb8bd99b9a4a0ada7b4f69", "filename": "src/test/run-pass/import5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport5.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n-import foo.bar;\n+import foo::bar;\n mod foo {\n-  import zed.bar;\n+  import zed::bar;\n   mod zed {\n     fn bar() {\n       log \"foo\";"}, {"sha": "c8268d99c25b31d91d66c30fe0a38d4356fb4e9c", "filename": "src/test/run-pass/import6.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport6.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import bar.baz;\n-import foo.zed;\n+import bar::baz;\n+import foo::zed;\n mod foo {\n   mod zed {\n     fn baz() {\n@@ -8,7 +8,7 @@ mod foo {\n   }\n }\n mod bar {\n-  import zed.baz;\n+  import zed::baz;\n }\n fn main(vec[str] args) {\n   baz();"}, {"sha": "6b11762efdeb02a9602c849a34df5cd6d0857be7", "filename": "src/test/run-pass/import7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport7.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import bar.baz;\n-import foo.zed;\n+import bar::baz;\n+import foo::zed;\n mod foo {\n   mod zed {\n     fn baz() {\n@@ -8,7 +8,7 @@ mod foo {\n   }\n }\n mod bar {\n-  import zed.baz;\n+  import zed::baz;\n   mod foo {\n     mod zed {\n     }"}, {"sha": "753d6da0acf2814e654b4e8fa9de750d5d123dfc", "filename": "src/test/run-pass/import8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fimport8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport8.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n-import foo.x;\n-import z = foo.x;\n+import foo::x;\n+import z = foo::x;\n \n mod foo {\n   fn x(int y) {"}, {"sha": "03f32bc4cd6c29e23d6a68cabc3c03a213e69323", "filename": "src/test/run-pass/inner-module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Finner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Finner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finner-module.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -7,11 +7,11 @@ mod inner {\n     }\n   }\n   fn hello() {\n-    inner2.hello();\n+    inner2::hello();\n   }\n }\n \n fn main() {\n-  inner.hello();\n-  inner.inner2.hello();\n+  inner::hello();\n+  inner::inner2::hello();\n }"}, {"sha": "506d5b2ad1d0a7de9cc9d665aed453de5d3bee74", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,132 +1,132 @@\n use std;\n-import std.Vec;\n-import std.BitV;\n+import std::_vec;\n+import std::bitv;\n \n fn test_0_elements() {\n   auto act;\n   auto exp;\n \n-  act = BitV.create(0u, false);\n-  exp = Vec.init_elt[uint](0u, 0u);\n+  act = bitv::create(0u, false);\n+  exp = _vec::init_elt[uint](0u, 0u);\n   // FIXME: why can't I write vec[uint]()?\n-  assert (BitV.eq_vec(act, exp));\n+  assert (bitv::eq_vec(act, exp));\n }\n \n fn test_1_element() {\n   auto act;\n \n-  act = BitV.create(1u, false);\n-  assert (BitV.eq_vec(act, vec(0u)));\n+  act = bitv::create(1u, false);\n+  assert (bitv::eq_vec(act, vec(0u)));\n \n-  act = BitV.create(1u, true);\n-  assert (BitV.eq_vec(act, vec(1u)));\n+  act = bitv::create(1u, true);\n+  assert (bitv::eq_vec(act, vec(1u)));\n }\n \n fn test_10_elements() {\n   auto act;\n \n   // all 0\n-  act = BitV.create(10u, false);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+  act = bitv::create(10u, false);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n-  act = BitV.create(10u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+  act = bitv::create(10u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = BitV.create(10u, false);\n-  BitV.set(act, 0u, true);\n-  BitV.set(act, 1u, true);\n-  BitV.set(act, 2u, true);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 4u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n+  act = bitv::create(10u, false);\n+  bitv::set(act, 0u, true);\n+  bitv::set(act, 1u, true);\n+  bitv::set(act, 2u, true);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 4u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = BitV.create(10u, false);\n-  BitV.set(act, 5u, true);\n-  BitV.set(act, 6u, true);\n-  BitV.set(act, 7u, true);\n-  BitV.set(act, 8u, true);\n-  BitV.set(act, 9u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n+  act = bitv::create(10u, false);\n+  bitv::set(act, 5u, true);\n+  bitv::set(act, 6u, true);\n+  bitv::set(act, 7u, true);\n+  bitv::set(act, 8u, true);\n+  bitv::set(act, 9u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = BitV.create(10u, false);\n-  BitV.set(act, 0u, true);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 6u, true);\n-  BitV.set(act, 9u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n+  act = bitv::create(10u, false);\n+  bitv::set(act, 0u, true);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 6u, true);\n+  bitv::set(act, 9u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n }\n \n fn test_31_elements() {\n   auto act;\n \n   // all 0\n-  act = BitV.create(31u, false);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(31u, false);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n-  act = BitV.create(31u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = bitv::create(31u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = BitV.create(31u, false);\n-  BitV.set(act, 0u, true);\n-  BitV.set(act, 1u, true);\n-  BitV.set(act, 2u, true);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 4u, true);\n-  BitV.set(act, 5u, true);\n-  BitV.set(act, 6u, true);\n-  BitV.set(act, 7u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = bitv::create(31u, false);\n+  bitv::set(act, 0u, true);\n+  bitv::set(act, 1u, true);\n+  bitv::set(act, 2u, true);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 4u, true);\n+  bitv::set(act, 5u, true);\n+  bitv::set(act, 6u, true);\n+  bitv::set(act, 7u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = BitV.create(31u, false);\n-  BitV.set(act, 16u, true);\n-  BitV.set(act, 17u, true);\n-  BitV.set(act, 18u, true);\n-  BitV.set(act, 19u, true);\n-  BitV.set(act, 20u, true);\n-  BitV.set(act, 21u, true);\n-  BitV.set(act, 22u, true);\n-  BitV.set(act, 23u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(31u, false);\n+  bitv::set(act, 16u, true);\n+  bitv::set(act, 17u, true);\n+  bitv::set(act, 18u, true);\n+  bitv::set(act, 19u, true);\n+  bitv::set(act, 20u, true);\n+  bitv::set(act, 21u, true);\n+  bitv::set(act, 22u, true);\n+  bitv::set(act, 23u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = BitV.create(31u, false);\n-  BitV.set(act, 24u, true);\n-  BitV.set(act, 25u, true);\n-  BitV.set(act, 26u, true);\n-  BitV.set(act, 27u, true);\n-  BitV.set(act, 28u, true);\n-  BitV.set(act, 29u, true);\n-  BitV.set(act, 30u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(31u, false);\n+  bitv::set(act, 24u, true);\n+  bitv::set(act, 25u, true);\n+  bitv::set(act, 26u, true);\n+  bitv::set(act, 27u, true);\n+  bitv::set(act, 28u, true);\n+  bitv::set(act, 29u, true);\n+  bitv::set(act, 30u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = BitV.create(31u, false);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 17u, true);\n-  BitV.set(act, 30u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(31u, false);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 17u, true);\n+  bitv::set(act, 30u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n@@ -136,71 +136,71 @@ fn test_32_elements() {\n   auto act;\n \n   // all 0\n-  act = BitV.create(32u, false);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(32u, false);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n-  act = BitV.create(32u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = bitv::create(32u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = BitV.create(32u, false);\n-  BitV.set(act, 0u, true);\n-  BitV.set(act, 1u, true);\n-  BitV.set(act, 2u, true);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 4u, true);\n-  BitV.set(act, 5u, true);\n-  BitV.set(act, 6u, true);\n-  BitV.set(act, 7u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = bitv::create(32u, false);\n+  bitv::set(act, 0u, true);\n+  bitv::set(act, 1u, true);\n+  bitv::set(act, 2u, true);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 4u, true);\n+  bitv::set(act, 5u, true);\n+  bitv::set(act, 6u, true);\n+  bitv::set(act, 7u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = BitV.create(32u, false);\n-  BitV.set(act, 16u, true);\n-  BitV.set(act, 17u, true);\n-  BitV.set(act, 18u, true);\n-  BitV.set(act, 19u, true);\n-  BitV.set(act, 20u, true);\n-  BitV.set(act, 21u, true);\n-  BitV.set(act, 22u, true);\n-  BitV.set(act, 23u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(32u, false);\n+  bitv::set(act, 16u, true);\n+  bitv::set(act, 17u, true);\n+  bitv::set(act, 18u, true);\n+  bitv::set(act, 19u, true);\n+  bitv::set(act, 20u, true);\n+  bitv::set(act, 21u, true);\n+  bitv::set(act, 22u, true);\n+  bitv::set(act, 23u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = BitV.create(32u, false);\n-  BitV.set(act, 24u, true);\n-  BitV.set(act, 25u, true);\n-  BitV.set(act, 26u, true);\n-  BitV.set(act, 27u, true);\n-  BitV.set(act, 28u, true);\n-  BitV.set(act, 29u, true);\n-  BitV.set(act, 30u, true);\n-  BitV.set(act, 31u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(32u, false);\n+  bitv::set(act, 24u, true);\n+  bitv::set(act, 25u, true);\n+  bitv::set(act, 26u, true);\n+  bitv::set(act, 27u, true);\n+  bitv::set(act, 28u, true);\n+  bitv::set(act, 29u, true);\n+  bitv::set(act, 30u, true);\n+  bitv::set(act, 31u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = BitV.create(32u, false);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 17u, true);\n-  BitV.set(act, 30u, true);\n-  BitV.set(act, 31u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(32u, false);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 17u, true);\n+  bitv::set(act, 30u, true);\n+  bitv::set(act, 31u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n@@ -210,77 +210,77 @@ fn test_33_elements() {\n   auto act;\n \n   // all 0\n-  act = BitV.create(33u, false);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(33u, false);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // all 1\n-  act = BitV.create(33u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = bitv::create(33u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u)));\n \n   // mixed\n-  act = BitV.create(33u, false);\n-  BitV.set(act, 0u, true);\n-  BitV.set(act, 1u, true);\n-  BitV.set(act, 2u, true);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 4u, true);\n-  BitV.set(act, 5u, true);\n-  BitV.set(act, 6u, true);\n-  BitV.set(act, 7u, true);\n-  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = bitv::create(33u, false);\n+  bitv::set(act, 0u, true);\n+  bitv::set(act, 1u, true);\n+  bitv::set(act, 2u, true);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 4u, true);\n+  bitv::set(act, 5u, true);\n+  bitv::set(act, 6u, true);\n+  bitv::set(act, 7u, true);\n+  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // mixed\n-  act = BitV.create(33u, false);\n-  BitV.set(act, 16u, true);\n-  BitV.set(act, 17u, true);\n-  BitV.set(act, 18u, true);\n-  BitV.set(act, 19u, true);\n-  BitV.set(act, 20u, true);\n-  BitV.set(act, 21u, true);\n-  BitV.set(act, 22u, true);\n-  BitV.set(act, 23u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(33u, false);\n+  bitv::set(act, 16u, true);\n+  bitv::set(act, 17u, true);\n+  bitv::set(act, 18u, true);\n+  bitv::set(act, 19u, true);\n+  bitv::set(act, 20u, true);\n+  bitv::set(act, 21u, true);\n+  bitv::set(act, 22u, true);\n+  bitv::set(act, 23u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // mixed\n-  act = BitV.create(33u, false);\n-  BitV.set(act, 24u, true);\n-  BitV.set(act, 25u, true);\n-  BitV.set(act, 26u, true);\n-  BitV.set(act, 27u, true);\n-  BitV.set(act, 28u, true);\n-  BitV.set(act, 29u, true);\n-  BitV.set(act, 30u, true);\n-  BitV.set(act, 31u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(33u, false);\n+  bitv::set(act, 24u, true);\n+  bitv::set(act, 25u, true);\n+  bitv::set(act, 26u, true);\n+  bitv::set(act, 27u, true);\n+  bitv::set(act, 28u, true);\n+  bitv::set(act, 29u, true);\n+  bitv::set(act, 30u, true);\n+  bitv::set(act, 31u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u)));\n \n   // mixed\n-  act = BitV.create(33u, false);\n-  BitV.set(act, 3u, true);\n-  BitV.set(act, 17u, true);\n-  BitV.set(act, 30u, true);\n-  BitV.set(act, 31u, true);\n-  BitV.set(act, 32u, true);\n-  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  act = bitv::create(33u, false);\n+  bitv::set(act, 3u, true);\n+  bitv::set(act, 17u, true);\n+  bitv::set(act, 30u, true);\n+  bitv::set(act, 31u, true);\n+  bitv::set(act, 32u, true);\n+  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,"}, {"sha": "e0e10f5a865e6792777fc5fd48da3d71601c3509", "filename": "src/test/run-pass/lib-box.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-box.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,12 +1,12 @@\n use std;\n-import std.Box;\n+import std::box;\n \n fn main() {\n     auto x = @3;\n     auto y = @3;\n-    assert (Box.ptr_eq[int](x, x));\n-    assert (Box.ptr_eq[int](y, y));\n-    assert (!Box.ptr_eq[int](x, y));\n-    assert (!Box.ptr_eq[int](y, x));\n+    assert (box::ptr_eq[int](x, x));\n+    assert (box::ptr_eq[int](y, y));\n+    assert (!box::ptr_eq[int](x, y));\n+    assert (!box::ptr_eq[int](y, x));\n }\n "}, {"sha": "186697fb92791c60aadb9cd1d9d1318c3911e7cc", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,10 +1,10 @@\n // -*- rust -*-\n \n use std;\n-import std.Deque;\n+import std::deque;\n \n fn test_simple() {\n-  let Deque.t[int] d = Deque.create[int]();\n+  let deque::t[int] d = deque::create[int]();\n   assert (d.size() == 0u);\n   d.add_front(17);\n   d.add_front(42);\n@@ -57,7 +57,7 @@ fn test_simple() {\n }\n \n fn test_boxes(@int a, @int b, @int c, @int d) {\n-  let Deque.t[@int] deq = Deque.create[@int]();\n+  let deque::t[@int] deq = deque::create[@int]();\n   assert (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);\n@@ -93,7 +93,7 @@ fn test_boxes(@int a, @int b, @int c, @int d) {\n type eqfn[T] = fn(&T a, &T b) -> bool;\n \n fn test_parameterized[T](eqfn[T] e, &T a, &T b, &T c, &T d) {\n-  let Deque.t[T] deq = Deque.create[T]();\n+  let deque::t[T] deq = deque::create[T]();\n   assert (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);"}, {"sha": "20d70ccf756cc08f90bf7cda477ad1752f8427c0", "filename": "src/test/run-pass/lib-int.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,25 +1,25 @@\n use std;\n \n-import std.Int;\n-import std.Str.eq;\n+import std::_int;\n+import std::_str::eq;\n \n fn test_to_str() {\n-  assert (eq(Int.to_str(0, 10u), \"0\"));\n-  assert (eq(Int.to_str(1, 10u), \"1\"));\n-  assert (eq(Int.to_str(-1, 10u), \"-1\"));\n-  assert (eq(Int.to_str(255, 16u), \"ff\"));\n-  assert (eq(Int.to_str(100, 10u), \"100\"));\n+  assert (eq(_int::to_str(0, 10u), \"0\"));\n+  assert (eq(_int::to_str(1, 10u), \"1\"));\n+  assert (eq(_int::to_str(-1, 10u), \"-1\"));\n+  assert (eq(_int::to_str(255, 16u), \"ff\"));\n+  assert (eq(_int::to_str(100, 10u), \"100\"));\n }\n \n fn test_pow() {\n-  assert (Int.pow(0, 0u) == 1);\n-  assert (Int.pow(0, 1u) == 0);\n-  assert (Int.pow(0, 2u) == 0);\n-  assert (Int.pow(-1, 0u) == -1);\n-  assert (Int.pow(1, 0u) == 1);\n-  assert (Int.pow(-3, 2u) == 9);\n-  assert (Int.pow(-3, 3u) == -27);\n-  assert (Int.pow(4, 9u) == 262144);\n+  assert (_int::pow(0, 0u) == 1);\n+  assert (_int::pow(0, 1u) == 0);\n+  assert (_int::pow(0, 2u) == 0);\n+  assert (_int::pow(-1, 0u) == -1);\n+  assert (_int::pow(1, 0u) == 1);\n+  assert (_int::pow(-3, 2u) == 9);\n+  assert (_int::pow(-3, 3u) == -27);\n+  assert (_int::pow(4, 9u) == 262144);\n }\n \n fn main() {"}, {"sha": "53c1391214bb3b840475068d1d4cef50970490de", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,8 +5,8 @@\n // -*- rust -*-\n \n use std;\n-import std.IO;\n-import std.Str;\n+import std::io;\n+import std::_str;\n \n fn test_simple(str tmpfilebase) {\n   let str tmpfile = tmpfilebase + \".tmp\";\n@@ -15,14 +15,14 @@ fn test_simple(str tmpfilebase) {\n   log frood;\n \n   {\n-    let IO.writer out = IO.file_writer(tmpfile, vec(IO.create));\n+    let io::writer out = io::file_writer(tmpfile, vec(io::create));\n     out.write_str(frood);\n   }\n \n-  let IO.reader inp = IO.file_reader(tmpfile);\n+  let io::reader inp = io::file_reader(tmpfile);\n   let str frood2 = inp.read_c_str();\n   log frood2;\n-  assert (Str.eq(frood, frood2));\n+  assert (_str::eq(frood, frood2));\n }\n \n fn main(vec[str] argv) {"}, {"sha": "402ef108149960b5c55bd4b51ecd4357f5c223d9", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,32 +1,32 @@\n // -*- rust -*-\n \n use std;\n-import std.Map;\n-import std.Str;\n-import std.UInt;\n-import std.Util;\n+import std::map;\n+import std::_str;\n+import std::_uint;\n+import std::util;\n \n fn test_simple() {\n   log \"*** starting test_simple\";\n \n   fn eq_uint(&uint x, &uint y) -> bool { ret x == y; }\n   fn hash_uint(&uint u) -> uint {\n-    // FIXME: can't use std.Util.id since we'd be capturing a type param,\n+    // FIXME: can't use std::util::id since we'd be capturing a type param,\n     // and presently we can't close items over type params.\n     ret u;\n   }\n \n-  let Map.hashfn[uint] hasher_uint = hash_uint;\n-  let Map.eqfn[uint] eqer_uint = eq_uint;\n+  let map::hashfn[uint] hasher_uint = hash_uint;\n+  let map::eqfn[uint] eqer_uint = eq_uint;\n \n-  let Map.hashfn[str] hasher_str = Str.hash;\n-  let Map.eqfn[str] eqer_str = Str.eq;\n+  let map::hashfn[str] hasher_str = _str::hash;\n+  let map::eqfn[str] eqer_str = _str::eq;\n \n \n   log \"uint -> uint\";\n \n-  let Map.hashmap[uint, uint] hm_uu = Map.mk_hashmap[uint, uint](hasher_uint,\n-                                                                 eqer_uint);\n+  let map::hashmap[uint, uint] hm_uu =\n+      map::mk_hashmap[uint, uint](hasher_uint, eqer_uint);\n \n   assert (hm_uu.insert(10u, 12u));\n   assert (hm_uu.insert(11u, 13u));\n@@ -49,7 +49,7 @@ fn test_simple() {\n \n   log \"str -> uint\";\n \n-  let Map.hashmap[str, uint] hm_su = Map.mk_hashmap[str, uint](hasher_str,\n+  let map::hashmap[str, uint] hm_su = map::mk_hashmap[str, uint](hasher_str,\n                                                                eqer_str);\n   assert (hm_su.insert(\"ten\", 12u));\n   assert (hm_su.insert(eleven, 13u));\n@@ -70,42 +70,42 @@ fn test_simple() {\n \n   log \"uint -> str\";\n \n-  let Map.hashmap[uint, str] hm_us = Map.mk_hashmap[uint, str](hasher_uint,\n+  let map::hashmap[uint, str] hm_us = map::mk_hashmap[uint, str](hasher_uint,\n                                                                eqer_uint);\n \n   assert (hm_us.insert(10u, \"twelve\"));\n   assert (hm_us.insert(11u, \"thirteen\"));\n   assert (hm_us.insert(12u, \"fourteen\"));\n \n-  assert (Str.eq(hm_us.get(11u), \"thirteen\"));\n-  assert (Str.eq(hm_us.get(12u), \"fourteen\"));\n-  assert (Str.eq(hm_us.get(10u), \"twelve\"));\n+  assert (_str::eq(hm_us.get(11u), \"thirteen\"));\n+  assert (_str::eq(hm_us.get(12u), \"fourteen\"));\n+  assert (_str::eq(hm_us.get(10u), \"twelve\"));\n \n   assert (!hm_us.insert(12u, \"fourteen\"));\n-  assert (Str.eq(hm_us.get(12u), \"fourteen\"));\n+  assert (_str::eq(hm_us.get(12u), \"fourteen\"));\n \n   assert (!hm_us.insert(12u, \"twelve\"));\n-  assert (Str.eq(hm_us.get(12u), \"twelve\"));\n+  assert (_str::eq(hm_us.get(12u), \"twelve\"));\n \n \n   log \"str -> str\";\n \n-  let Map.hashmap[str, str] hm_ss = Map.mk_hashmap[str, str](hasher_str,\n+  let map::hashmap[str, str] hm_ss = map::mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n   assert (hm_ss.insert(ten, \"twelve\"));\n   assert (hm_ss.insert(eleven, \"thirteen\"));\n   assert (hm_ss.insert(twelve, \"fourteen\"));\n \n-  assert (Str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-  assert (Str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-  assert (Str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n+  assert (_str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n+  assert (_str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (_str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n \n   assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-  assert (Str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (_str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n \n   assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-  assert (Str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+  assert (_str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n \n   log \"*** finished test_simple\";\n }\n@@ -120,33 +120,33 @@ fn test_growth() {\n \n   fn eq_uint(&uint x, &uint y) -> bool { ret x == y; }\n   fn hash_uint(&uint u) -> uint {\n-    // FIXME: can't use std.Util.id since we'd be capturing a type param,\n+    // FIXME: can't use std::util::id since we'd be capturing a type param,\n     // and presently we can't close items over type params.\n     ret u;\n   }\n \n \n   log \"uint -> uint\";\n \n-  let Map.hashfn[uint] hasher_uint = hash_uint;\n-  let Map.eqfn[uint] eqer_uint = eq_uint;\n-  let Map.hashmap[uint, uint] hm_uu = Map.mk_hashmap[uint, uint](hasher_uint,\n-                                                                 eqer_uint);\n+  let map::hashfn[uint] hasher_uint = hash_uint;\n+  let map::eqfn[uint] eqer_uint = eq_uint;\n+  let map::hashmap[uint, uint] hm_uu =\n+      map::mk_hashmap[uint, uint](hasher_uint, eqer_uint);\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n     assert (hm_uu.insert(i, i * i));\n-    log \"inserting \" + UInt.to_str(i, 10u)\n-      + \" -> \" + UInt.to_str(i * i, 10u);\n+    log \"inserting \" + _uint::to_str(i, 10u)\n+      + \" -> \" + _uint::to_str(i * i, 10u);\n     i += 1u;\n   }\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n-      + UInt.to_str(hm_uu.get(i), 10u);\n+    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n+      + _uint::to_str(hm_uu.get(i), 10u);\n     assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n@@ -160,25 +160,25 @@ fn test_growth() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n-      + UInt.to_str(hm_uu.get(i), 10u);\n+    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n+      + _uint::to_str(hm_uu.get(i), 10u);\n     assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n \n   log \"str -> str\";\n \n-  let Map.hashfn[str] hasher_str = Str.hash;\n-  let Map.eqfn[str] eqer_str = Str.eq;\n-  let Map.hashmap[str, str] hm_ss = Map.mk_hashmap[str, str](hasher_str,\n+  let map::hashfn[str] hasher_str = _str::hash;\n+  let map::eqfn[str] eqer_str = _str::eq;\n+  let map::hashmap[str, str] hm_ss = map::mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm_ss.insert(UInt.to_str(i, 2u), UInt.to_str(i * i, 2u)));\n-    log \"inserting \\\"\" + UInt.to_str(i, 2u)\n-      + \"\\\" -> \\\"\" + UInt.to_str(i * i, 2u) + \"\\\"\";\n+    assert (hm_ss.insert(_uint::to_str(i, 2u), _uint::to_str(i * i, 2u)));\n+    log \"inserting \\\"\" + _uint::to_str(i, 2u)\n+      + \"\\\" -> \\\"\" + _uint::to_str(i * i, 2u) + \"\\\"\";\n     i += 1u;\n   }\n \n@@ -187,31 +187,31 @@ fn test_growth() {\n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\\\"\"\n-      + UInt.to_str(i, 2u)\n+      + _uint::to_str(i, 2u)\n       + \"\\\") = \\\"\"\n-      + hm_ss.get(UInt.to_str(i, 2u)) + \"\\\"\";\n+      + hm_ss.get(_uint::to_str(i, 2u)) + \"\\\"\";\n \n-    assert (Str.eq(hm_ss.get(UInt.to_str(i, 2u)),\n-                   UInt.to_str(i * i, 2u)));\n+    assert (_str::eq(hm_ss.get(_uint::to_str(i, 2u)),\n+                   _uint::to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n-  assert (hm_ss.insert(UInt.to_str(num_to_insert, 2u),\n-                      UInt.to_str(17u, 2u)));\n+  assert (hm_ss.insert(_uint::to_str(num_to_insert, 2u),\n+                      _uint::to_str(17u, 2u)));\n \n-  assert (Str.eq(hm_ss.get(UInt.to_str(num_to_insert, 2u)),\n-                 UInt.to_str(17u, 2u)));\n+  assert (_str::eq(hm_ss.get(_uint::to_str(num_to_insert, 2u)),\n+                 _uint::to_str(17u, 2u)));\n \n   log \"-----\";\n \n   hm_ss.rehash();\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\\\"\" + UInt.to_str(i, 2u) + \"\\\") = \\\"\"\n-      + hm_ss.get(UInt.to_str(i, 2u)) + \"\\\"\";\n-    assert (Str.eq(hm_ss.get(UInt.to_str(i, 2u)),\n-                   UInt.to_str(i * i, 2u)));\n+    log \"get(\\\"\" + _uint::to_str(i, 2u) + \"\\\") = \\\"\"\n+      + hm_ss.get(_uint::to_str(i, 2u)) + \"\\\"\";\n+    assert (_str::eq(hm_ss.get(_uint::to_str(i, 2u)),\n+                   _uint::to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n@@ -234,15 +234,15 @@ fn test_removal() {\n   assert (hash(2u) == hash(3u));\n   assert (hash(0u) != hash(2u));\n \n-  let Map.hashfn[uint] hasher = hash;\n-  let Map.eqfn[uint] eqer = eq;\n-  let Map.hashmap[uint, uint] hm = Map.mk_hashmap[uint, uint](hasher, eqer);\n+  let map::hashfn[uint] hasher = hash;\n+  let map::eqfn[uint] eqer = eq;\n+  let map::hashmap[uint, uint] hm = map::mk_hashmap[uint, uint](hasher, eqer);\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n     assert (hm.insert(i, i * i));\n-    log \"inserting \" + UInt.to_str(i, 10u)\n-      + \" -> \" + UInt.to_str(i * i, 10u);\n+    log \"inserting \" + _uint::to_str(i, 10u)\n+      + \" -> \" + _uint::to_str(i * i, 10u);\n     i += 1u;\n   }\n \n@@ -279,8 +279,8 @@ fn test_removal() {\n \n   i = 1u;\n   while (i < num_to_insert) {\n-    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n-      + UInt.to_str(hm.get(i), 10u);\n+    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n+      + _uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n@@ -294,8 +294,8 @@ fn test_removal() {\n \n   i = 1u;\n   while (i < num_to_insert) {\n-    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n-      + UInt.to_str(hm.get(i), 10u);\n+    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n+      + _uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n@@ -305,8 +305,8 @@ fn test_removal() {\n   i = 0u;\n   while (i < num_to_insert) {\n     assert (hm.insert(i, i * i));\n-    log \"inserting \" + UInt.to_str(i, 10u)\n-      + \" -> \" + UInt.to_str(i * i, 10u);\n+    log \"inserting \" + _uint::to_str(i, 10u)\n+      + \" -> \" + _uint::to_str(i * i, 10u);\n     i += 2u;\n   }\n \n@@ -316,8 +316,8 @@ fn test_removal() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n-      + UInt.to_str(hm.get(i), 10u);\n+    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n+      + _uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 1u;\n   }\n@@ -333,8 +333,8 @@ fn test_removal() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n-      + UInt.to_str(hm.get(i), 10u);\n+    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n+      + _uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 1u;\n   }"}, {"sha": "cf004f1dbe53810d3046af3c4ea325118ff15f7b", "filename": "src/test/run-pass/lib-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-option.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,5 +1,5 @@\n use std;\n \n fn main() {\n-  auto x = std.Option.some[int](10);\n+  auto x = std::option::some[int](10);\n }"}, {"sha": "2f086667686c66ea1f840d8b7b6034b02c8e3064", "filename": "src/test/run-pass/lib-qsort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,13 +1,13 @@\n use std;\n \n fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n-  auto len = std.Vec.len[int](v1);\n+  auto len = std::_vec::len[int](v1);\n \n   fn ltequal(&int a, &int b) -> bool {\n     ret a <= b;\n   }\n   auto f = ltequal;\n-  std.Sort.quick_sort[int](f, v1);\n+  std::sort::quick_sort[int](f, v1);\n   auto i = 0u;\n   while (i < len) {\n     log v2.(i);"}, {"sha": "388811bcb7c8da2ca775cf378771059c4da61570", "filename": "src/test/run-pass/lib-rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-rand.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,14 +4,14 @@\n // -*- rust -*-\n \n use std;\n-import std.Rand;\n+import std::rand;\n \n fn main() {\n-  let Rand.rng r1 = Rand.mk_rng();\n+  let rand::rng r1 = rand::mk_rng();\n   log r1.next();\n   log r1.next();\n   {\n-    auto r2 = Rand.mk_rng();\n+    auto r2 = rand::mk_rng();\n     log r1.next();\n     log r2.next();\n     log r1.next();"}, {"sha": "18ea4f38fb7f7c26336727336bc6f1af588eb967", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,9 +5,9 @@\n \n use std;\n \n-import std.SHA1;\n-import std.Vec;\n-import std.Str;\n+import std::sha1;\n+import std::_vec;\n+import std::_str;\n \n fn main() {\n \n@@ -67,8 +67,8 @@ fn main() {\n     auto tests = fips_180_1_tests + wikipedia_tests;\n \n     fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n-        assert (Vec.len[u8](v0) == Vec.len[u8](v1));\n-        auto len = Vec.len[u8](v0);\n+        assert (_vec::len[u8](v0) == _vec::len[u8](v1));\n+        auto len = _vec::len[u8](v0);\n         auto i = 0u;\n         while (i < len) {\n             auto a = v0.(i);\n@@ -79,7 +79,7 @@ fn main() {\n     }\n \n     // Test that it works when accepting the message all at once\n-    auto sh = SHA1.mk_sha1();\n+    auto sh = sha1::mk_sha1();\n     for (test t in tests) {\n         sh.input_str(t.input);\n         auto out = sh.result();\n@@ -89,11 +89,11 @@ fn main() {\n \n     // Test that it works when accepting the message in pieces\n     for (test t in tests) {\n-        auto len = Str.byte_len(t.input);\n+        auto len = _str::byte_len(t.input);\n         auto left = len;\n         while (left > 0u) {\n             auto take = (left + 1u) / 2u;\n-            sh.input_str(Str.substr(t.input, len - left, take));\n+            sh.input_str(_str::substr(t.input, len - left, take));\n             left = left - take;\n         }\n         auto out = sh.result();"}, {"sha": "6ec266fa2108da5837f8d745e185d7c5f84eb48f", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,12 +1,12 @@\n use std;\n \n fn check_sort(vec[int] v1, vec[int] v2) {\n-  auto len = std.Vec.len[int](v1);\n+  auto len = std::_vec::len[int](v1);\n   fn lteq(&int a, &int b) -> bool {\n     ret a <= b;\n   }\n   auto f = lteq;\n-  auto v3 = std.Sort.merge_sort[int](f, v1);\n+  auto v3 = std::sort::merge_sort[int](f, v1);\n   auto i = 0u;\n   while (i < len) {\n     log v3.(i);"}, {"sha": "af1148a5f8a2399483aad570a031a1c39c4550b4", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,14 +4,14 @@\n // -*- rust -*-\n \n use std;\n-import std.Str;\n+import std::_str;\n \n fn main() {\n     auto s = \"hello\";\n-    auto sb = Str.rustrt.str_buf(s);\n-    auto s_cstr = Str.rustrt.str_from_cstr(sb);\n-    assert (Str.eq(s_cstr, s));\n-    auto s_buf = Str.rustrt.str_from_buf(sb, 5u);\n-    assert (Str.eq(s_buf, s));\n+    auto sb = str.rustrt.str_buf(s);\n+    auto s_cstr = str.rustrt.str_from_cstr(sb);\n+    assert (str.eq(s_cstr, s));\n+    auto s_buf = str.rustrt.str_from_buf(sb, 5u);\n+    assert (str.eq(s_buf, s));\n }\n "}, {"sha": "eff9eef1258910da56f8205beb61226fd60a3862", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,38 +2,38 @@\n // xfail-stage0\n \n use std;\n-import std.Str;\n+import std::_str;\n \n fn test_bytes_len() {\n-  assert (Str.byte_len(\"\") == 0u);\n-  assert (Str.byte_len(\"hello world\") == 11u);\n-  assert (Str.byte_len(\"\\x63\") == 1u);\n-  assert (Str.byte_len(\"\\xa2\") == 2u);\n-  assert (Str.byte_len(\"\\u03c0\") == 2u);\n-  assert (Str.byte_len(\"\\u2620\") == 3u);\n-  assert (Str.byte_len(\"\\U0001d11e\") == 4u);\n+  assert (_str::byte_len(\"\") == 0u);\n+  assert (_str::byte_len(\"hello world\") == 11u);\n+  assert (_str::byte_len(\"\\x63\") == 1u);\n+  assert (_str::byte_len(\"\\xa2\") == 2u);\n+  assert (_str::byte_len(\"\\u03c0\") == 2u);\n+  assert (_str::byte_len(\"\\u2620\") == 3u);\n+  assert (_str::byte_len(\"\\U0001d11e\") == 4u);\n }\n \n fn test_index_and_rindex() {\n-  assert (Str.index(\"hello\", 'e' as u8) == 1);\n-  assert (Str.index(\"hello\", 'o' as u8) == 4);\n-  assert (Str.index(\"hello\", 'z' as u8) == -1);\n-  assert (Str.rindex(\"hello\", 'l' as u8) == 3);\n-  assert (Str.rindex(\"hello\", 'h' as u8) == 0);\n-  assert (Str.rindex(\"hello\", 'z' as u8) == -1);\n+  assert (_str::index(\"hello\", 'e' as u8) == 1);\n+  assert (_str::index(\"hello\", 'o' as u8) == 4);\n+  assert (_str::index(\"hello\", 'z' as u8) == -1);\n+  assert (_str::rindex(\"hello\", 'l' as u8) == 3);\n+  assert (_str::rindex(\"hello\", 'h' as u8) == 0);\n+  assert (_str::rindex(\"hello\", 'z' as u8) == -1);\n }\n \n fn test_split() {\n   fn t(&str s, char c, int i, &str k) {\n     log \"splitting: \" + s;\n     log i;\n-    auto v = Str.split(s, c as u8);\n+    auto v = _str::split(s, c as u8);\n     log \"split to: \";\n     for (str z in v) {\n       log z;\n     }\n     log \"comparing: \" + v.(i) + \" vs. \" + k;\n-    assert (Str.eq(v.(i), k));\n+    assert (_str::eq(v.(i), k));\n   }\n   t(\"abc.hello.there\", '.', 0, \"abc\");\n   t(\"abc.hello.there\", '.', 1, \"hello\");\n@@ -46,7 +46,7 @@ fn test_split() {\n \n fn test_find() {\n   fn t(&str haystack, &str needle, int i) {\n-    let int j = Str.find(haystack,needle);\n+    let int j = _str::find(haystack,needle);\n     log \"searched for \" + needle;\n     log j;\n     assert (i == j);\n@@ -60,8 +60,8 @@ fn test_find() {\n \n fn test_substr() {\n   fn t(&str a, &str b, int start) {\n-    assert (Str.eq(Str.substr(a, start as uint,\n-                              Str.byte_len(b)), b));\n+    assert (_str::eq(_str::substr(a, start as uint,\n+                              _str::byte_len(b)), b));\n   }\n \n   t(\"hello\", \"llo\", 2);\n@@ -71,7 +71,7 @@ fn test_substr() {\n \n fn test_concat() {\n   fn t(&vec[str] v, &str s) {\n-    assert (Str.eq(Str.concat(v), s));\n+    assert (_str::eq(_str::concat(v), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \"youknowI'mnogood\");\n@@ -82,7 +82,7 @@ fn test_concat() {\n \n fn test_connect() {\n   fn t(&vec[str] v, &str sep, &str s) {\n-    assert (Str.eq(Str.connect(v, sep), s));\n+    assert (_str::eq(_str::connect(v, sep), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \" \", \"you know I'm no good\");\n@@ -97,14 +97,14 @@ fn test_to_upper() {\n   auto unicode = \"\\u65e5\\u672c\";\n   auto input = \"abcDEF\" + unicode + \"xyz:.;\";\n   auto expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n-  auto actual = Str.to_upper(input);\n-  assert (Str.eq(expected, actual));\n+  auto actual = _str::to_upper(input);\n+  assert (_str::eq(expected, actual));\n }\n \n fn test_slice() {\n-  assert (Str.eq(\"ab\", Str.slice(\"abc\", 0u, 2u)));\n-  assert (Str.eq(\"bc\", Str.slice(\"abc\", 1u, 3u)));\n-  assert (Str.eq(\"\", Str.slice(\"abc\", 1u, 1u)));\n+  assert (_str::eq(\"ab\", _str::slice(\"abc\", 0u, 2u)));\n+  assert (_str::eq(\"bc\", _str::slice(\"abc\", 1u, 3u)));\n+  assert (_str::eq(\"\", _str::slice(\"abc\", 1u, 1u)));\n \n   fn a_million_letter_a() -> str {\n     auto i = 0;\n@@ -126,8 +126,8 @@ fn test_slice() {\n     ret res;\n   }\n \n-  assert (Str.eq(half_a_million_letter_a(),\n-                 Str.slice(a_million_letter_a(),\n+  assert (_str::eq(half_a_million_letter_a(),\n+                 _str::slice(a_million_letter_a(),\n                            0u,\n                            500000u)));\n }"}, {"sha": "f1cca720ed7c3dba94bf50c9d6927c42a4ce4bd1", "filename": "src/test/run-pass/lib-task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-task.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std.Task;\n+import std::_task;\n \n fn main() {\n-  Task.sleep(1000000u);\n+  _task::sleep(1000000u);\n }\n\\ No newline at end of file"}, {"sha": "3de24ba3d4963da28d3afb3f34ea75053539eb7b", "filename": "src/test/run-pass/lib-uint.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-uint.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,47 +1,47 @@\n // -*- rust -*-\n \n use std;\n-import std.UInt;\n+import std::_uint;\n \n fn main() {\n-  assert (UInt.next_power_of_two(0u) == 0u);\n-  assert (UInt.next_power_of_two(1u) == 1u);\n-  assert (UInt.next_power_of_two(2u) == 2u);\n-  assert (UInt.next_power_of_two(3u) == 4u);\n-  assert (UInt.next_power_of_two(4u) == 4u);\n-  assert (UInt.next_power_of_two(5u) == 8u);\n-  assert (UInt.next_power_of_two(6u) == 8u);\n-  assert (UInt.next_power_of_two(7u) == 8u);\n-  assert (UInt.next_power_of_two(8u) == 8u);\n-  assert (UInt.next_power_of_two(9u) == 16u);\n-  assert (UInt.next_power_of_two(10u) == 16u);\n-  assert (UInt.next_power_of_two(11u) == 16u);\n-  assert (UInt.next_power_of_two(12u) == 16u);\n-  assert (UInt.next_power_of_two(13u) == 16u);\n-  assert (UInt.next_power_of_two(14u) == 16u);\n-  assert (UInt.next_power_of_two(15u) == 16u);\n-  assert (UInt.next_power_of_two(16u) == 16u);\n-  assert (UInt.next_power_of_two(17u) == 32u);\n-  assert (UInt.next_power_of_two(18u) == 32u);\n-  assert (UInt.next_power_of_two(19u) == 32u);\n-  assert (UInt.next_power_of_two(20u) == 32u);\n-  assert (UInt.next_power_of_two(21u) == 32u);\n-  assert (UInt.next_power_of_two(22u) == 32u);\n-  assert (UInt.next_power_of_two(23u) == 32u);\n-  assert (UInt.next_power_of_two(24u) == 32u);\n-  assert (UInt.next_power_of_two(25u) == 32u);\n-  assert (UInt.next_power_of_two(26u) == 32u);\n-  assert (UInt.next_power_of_two(27u) == 32u);\n-  assert (UInt.next_power_of_two(28u) == 32u);\n-  assert (UInt.next_power_of_two(29u) == 32u);\n-  assert (UInt.next_power_of_two(30u) == 32u);\n-  assert (UInt.next_power_of_two(31u) == 32u);\n-  assert (UInt.next_power_of_two(32u) == 32u);\n-  assert (UInt.next_power_of_two(33u) == 64u);\n-  assert (UInt.next_power_of_two(34u) == 64u);\n-  assert (UInt.next_power_of_two(35u) == 64u);\n-  assert (UInt.next_power_of_two(36u) == 64u);\n-  assert (UInt.next_power_of_two(37u) == 64u);\n-  assert (UInt.next_power_of_two(38u) == 64u);\n-  assert (UInt.next_power_of_two(39u) == 64u);\n+  assert (_uint::next_power_of_two(0u) == 0u);\n+  assert (_uint::next_power_of_two(1u) == 1u);\n+  assert (_uint::next_power_of_two(2u) == 2u);\n+  assert (_uint::next_power_of_two(3u) == 4u);\n+  assert (_uint::next_power_of_two(4u) == 4u);\n+  assert (_uint::next_power_of_two(5u) == 8u);\n+  assert (_uint::next_power_of_two(6u) == 8u);\n+  assert (_uint::next_power_of_two(7u) == 8u);\n+  assert (_uint::next_power_of_two(8u) == 8u);\n+  assert (_uint::next_power_of_two(9u) == 16u);\n+  assert (_uint::next_power_of_two(10u) == 16u);\n+  assert (_uint::next_power_of_two(11u) == 16u);\n+  assert (_uint::next_power_of_two(12u) == 16u);\n+  assert (_uint::next_power_of_two(13u) == 16u);\n+  assert (_uint::next_power_of_two(14u) == 16u);\n+  assert (_uint::next_power_of_two(15u) == 16u);\n+  assert (_uint::next_power_of_two(16u) == 16u);\n+  assert (_uint::next_power_of_two(17u) == 32u);\n+  assert (_uint::next_power_of_two(18u) == 32u);\n+  assert (_uint::next_power_of_two(19u) == 32u);\n+  assert (_uint::next_power_of_two(20u) == 32u);\n+  assert (_uint::next_power_of_two(21u) == 32u);\n+  assert (_uint::next_power_of_two(22u) == 32u);\n+  assert (_uint::next_power_of_two(23u) == 32u);\n+  assert (_uint::next_power_of_two(24u) == 32u);\n+  assert (_uint::next_power_of_two(25u) == 32u);\n+  assert (_uint::next_power_of_two(26u) == 32u);\n+  assert (_uint::next_power_of_two(27u) == 32u);\n+  assert (_uint::next_power_of_two(28u) == 32u);\n+  assert (_uint::next_power_of_two(29u) == 32u);\n+  assert (_uint::next_power_of_two(30u) == 32u);\n+  assert (_uint::next_power_of_two(31u) == 32u);\n+  assert (_uint::next_power_of_two(32u) == 32u);\n+  assert (_uint::next_power_of_two(33u) == 64u);\n+  assert (_uint::next_power_of_two(34u) == 64u);\n+  assert (_uint::next_power_of_two(35u) == 64u);\n+  assert (_uint::next_power_of_two(36u) == 64u);\n+  assert (_uint::next_power_of_two(37u) == 64u);\n+  assert (_uint::next_power_of_two(38u) == 64u);\n+  assert (_uint::next_power_of_two(39u) == 64u);\n }"}, {"sha": "c85374bf3cd7961a70bbd19491838727105f7cb6", "filename": "src/test/run-pass/lib-vec-str-conversions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std.Str;\n-import std.Vec;\n+import std::_str;\n+import std::_vec;\n \n fn test_simple() {\n   let str s1 = \"All mimsy were the borogoves\";\n@@ -14,12 +14,12 @@ fn test_simple() {\n    * working, but we should implement is_utf8 before that happens.\n    */\n \n-  let vec[u8] v = Str.bytes(s1);\n-  let str s2 = Str.from_bytes(v);\n+  let vec[u8] v = _str::bytes(s1);\n+  let str s2 = _str::from_bytes(v);\n \n   let uint i = 0u;\n-  let uint n1 = Str.byte_len(s1);\n-  let uint n2 = Vec.len[u8](v);\n+  let uint n1 = _str::byte_len(s1);\n+  let uint n2 = _vec::len[u8](v);\n \n   assert (n1 == n2);\n \n@@ -33,7 +33,7 @@ fn test_simple() {\n   }\n \n   log \"refcnt is\";\n-  log Str.refcount(s1);\n+  log _str::refcount(s1);\n }\n \n fn main() {"}, {"sha": "f7e6157a14d5d39681cd5e387ac5b5325539d1de", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,8 +1,8 @@\n use std;\n \n fn test_init_elt() {\n-  let vec[uint] v = std.Vec.init_elt[uint](5u, 3u);\n-  assert (std.Vec.len[uint](v) == 3u);\n+  let vec[uint] v = std::_vec::init_elt[uint](5u, 3u);\n+  assert (std::_vec::len[uint](v) == 3u);\n   assert (v.(0) == 5u);\n   assert (v.(1) == 5u);\n   assert (v.(2) == 5u);\n@@ -13,8 +13,8 @@ fn id(uint x) -> uint {\n }\n fn test_init_fn() {\n   let fn(uint)->uint op = id;\n-  let vec[uint] v = std.Vec.init_fn[uint](op, 5u);\n-  assert (std.Vec.len[uint](v) == 5u);\n+  let vec[uint] v = std::_vec::init_fn[uint](op, 5u);\n+  assert (std::_vec::len[uint](v) == 5u);\n   assert (v.(0) == 0u);\n   assert (v.(1) == 1u);\n   assert (v.(2) == 2u);\n@@ -24,17 +24,17 @@ fn test_init_fn() {\n \n fn test_slice() {\n   let vec[int] v = vec(1,2,3,4,5);\n-  auto v2 = std.Vec.slice[int](v, 2u, 4u);\n-  assert (std.Vec.len[int](v2) == 2u);\n+  auto v2 = std::_vec::slice[int](v, 2u, 4u);\n+  assert (std::_vec::len[int](v2) == 2u);\n   assert (v2.(0) == 3);\n   assert (v2.(1) == 4);\n }\n \n fn test_map() {\n   fn square(&int x) -> int { ret x * x; }\n-  let std.Option.operator[int, int] op = square;\n+  let std::option::operator[int, int] op = square;\n   let vec[int] v = vec(1, 2, 3, 4, 5);\n-  let vec[int] s = std.Vec.map[int, int](op, v);\n+  let vec[int] s = std::_vec::map[int, int](op, v);\n   let int i = 0;\n   while (i < 5) {\n     assert (v.(i) * v.(i) == s.(i));\n@@ -47,7 +47,7 @@ fn test_map2() {\n   auto f = times;\n   auto v0 = vec(1, 2, 3, 4, 5);\n   auto v1 = vec(5, 4, 3, 2, 1);\n-  auto u = std.Vec.map2[int,int,int](f, v0, v1);\n+  auto u = std::_vec::map2[int,int,int](f, v0, v1);\n \n   auto i = 0;\n   while (i < 5) {"}, {"sha": "7a884e41f438c2e115c130d6b1ac6e4363676087", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -16,6 +16,6 @@ fn main() {\n   let @cell first = @tup(mutable @nil());\n   let @cell second = @tup(mutable @link(first));\n   first._0 = @link(second);\n-  std.Sys.rustrt.gc();\n+  std::sys.rustrt.gc();\n   let @cell third = @tup(mutable @nil());\n }"}, {"sha": "c63220dfbfa97f17d070996c1974f68bb433ede8", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   grow(v);\n   grow(v);\n   grow(v);\n-  auto len = std.Vec.len[int](v);\n+  auto len = std::_vec::len[int](v);\n   log len;\n   assert (len == (3 as uint));\n }"}, {"sha": "df2540aef041d9125184a55ec0eb362aca91ad62", "filename": "src/test/run-pass/native2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fnative2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fnative2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative2.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -10,7 +10,7 @@ native mod zed {\n }\n \n native mod libc = \"libc.dylib\" {\n-    fn write(int fd, rustrt.vbuf buf, uint count) -> int;\n+    fn write(int fd, rustrt::vbuf buf, uint count) -> int;\n }\n \n native \"cdecl\" mod baz {"}, {"sha": "c44c96e59e0952d62116c97a0302fb2961fdaed7", "filename": "src/test/run-pass/nested-pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-pattern.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,13 +1,13 @@\n // a bug was causing this to complain about leaked memory on exit\n \n use std;\n-import std.Option;\n-import std.Option.some;\n-import std.Option.none;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n \n tag t {\n   foo(int, uint);\n-  bar(int, Option.t[int]);\n+  bar(int, option::t[int]);\n }\n \n fn nested(t o) {"}, {"sha": "6b06e727ba04dbc530563c45c1091ffbc2dbbd7e", "filename": "src/test/run-pass/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpath.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,5 +4,5 @@ mod foo {\n }\n \n fn main(vec[str] args) {\n-  foo.bar(0u);\n+  foo::bar(0u);\n }"}, {"sha": "b742af7cd124d078fb29c9157666492b118460b5", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -5,9 +5,9 @@\n \n use std;\n \n-import std.Option;\n-import std.UInt;\n-import std.Vec;\n+import std::option;\n+import std::_uint;\n+import std::_vec;\n \n // A 12-byte unit to send over the channel\n type record = rec(u32 val1, u32 val2, u32 val3);\n@@ -33,7 +33,7 @@ fn test_grow() {\n \n     let record val = rec(val1=0u32, val2=0u32, val3=0u32);\n \n-    for each (uint i in UInt.range(0u, 100u)) {\n+    for each (uint i in _uint::range(0u, 100u)) {\n         mychan <| val;\n     }\n }\n@@ -53,11 +53,11 @@ fn test_shrink2() {\n \n     let record val = rec(val1=0u32, val2=0u32, val3=0u32);\n \n-    for each (uint i in UInt.range(0u, 100u)) {\n+    for each (uint i in _uint::range(0u, 100u)) {\n         mychan <| val;\n     }\n \n-    for each (uint i in UInt.range(0u, 100u)) {\n+    for each (uint i in _uint::range(0u, 100u)) {\n         auto x <- myport;\n     }\n }\n@@ -67,7 +67,7 @@ fn test_rotate() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n-    for each (uint i in UInt.range(0u, 100u)) {\n+    for each (uint i in _uint::range(0u, 100u)) {\n         auto val = rec(val1=i as u32,\n                        val2=i as u32,\n                        val3=i as u32);\n@@ -86,15 +86,15 @@ fn test_rotate_grow() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n-    for each (uint j in UInt.range(0u, 10u)) {\n-        for each (uint i in UInt.range(0u, 10u)) {\n+    for each (uint j in _uint::range(0u, 10u)) {\n+        for each (uint i in _uint::range(0u, 10u)) {\n             let record val = rec(val1=i as u32,\n                                  val2=i as u32,\n                                  val3=i as u32);\n             mychan <| val;\n         }\n \n-        for each (uint i in UInt.range(0u, 10u)) {\n+        for each (uint i in _uint::range(0u, 10u)) {\n             auto x <- myport;\n             assert (x.val1 == i as u32);\n             assert (x.val2 == i as u32);"}, {"sha": "b4bd6017c93b6bb36b49067dc34d8c415f0c5ac8", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n fn main() {\n-  auto x = spawn m.child(10);\n+  auto x = spawn m::child(10);\n   join x;\n }\n mod m {"}, {"sha": "ed2e3a7a90dbcd7cae7760195c17b4c2f5b50cc8", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std.Str;\n+import std::_str;\n \n fn test1() {\n   let str s = \"hello\";\n@@ -20,8 +20,8 @@ fn test2() {\n   log a;\n   log b;\n \n-  assert (Str.eq(a, \"abcABCabc\"));\n-  assert (Str.eq(b, \"ABCabcABC\"));\n+  assert (_str::eq(a, \"abcABCabc\"));\n+  assert (_str::eq(b, \"ABCabcABC\"));\n }\n \n fn main() {"}, {"sha": "f0da72a3e0cb905537716a54174a1571b725b43e", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,11 +1,11 @@\n // xfail-boot\n use std;\n-import std.Str;\n+import std::_str;\n \n fn test(str actual, str expected) {\n   log actual;\n   log expected;\n-  assert (Str.eq(actual, expected));\n+  assert (_str::eq(actual, expected));\n }\n \n fn main() {"}, {"sha": "8adab6e9f0f655e2d59ef03890e9a9f06dbc7978", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -6,7 +6,7 @@ fn main() -> () {\n }\n \n fn start() {\n-    log \"Started / Finished Task.\";\n+    log \"Started / Finished task.\";\n }\n \n fn test00() {"}, {"sha": "2aa38b86aa3d6b26127efd7d23bf6cd04888a958", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -3,25 +3,25 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std.Task;\n+import std::_task;\n \n fn main() -> () {\n     test00();\n }\n \n fn start(int task_number) {\n-    log \"Started / Finished Task.\";\n+    log \"Started / Finished task.\";\n }\n     \n fn test00() {    \n     let int i = 0;\n     let task t = spawn thread \"child\" start(i);\n     \n     // Sleep long enough for the task to finish.\n-    Task.sleep(10000u);\n+    _task::sleep(10000u);\n     \n     // Try joining tasks that have already finished.\n     join t;\n     \n-    log \"Joined Task.\";\n+    log \"Joined task.\";\n }\n\\ No newline at end of file"}, {"sha": "72f3c9568fef30f35dbc705aa032b4298f5146b0", "filename": "src/test/run-pass/task-comm-13-thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std.Task;\n+import std::_task;\n \n fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n@@ -17,5 +17,5 @@ fn main() -> () {\n     let port[int] p = port();\n     let task a = spawn thread \"start\" start(chan(p), 0, 10);\n     join a;\n-    log \"Joined Task\";\n+    log \"Joined task\";\n }\n\\ No newline at end of file"}, {"sha": "c6de853332e4ea8be8423c713fa882ffd9fcfe65", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std.Task;\n+import std::_task;\n \n fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n@@ -17,5 +17,5 @@ fn main() -> () {\n     let port[int] p = port();\n     let task a = spawn \"start\" start(chan(p), 0, 10);\n     join a;\n-    log \"Joined Task\";\n+    log \"Joined task\";\n }\n\\ No newline at end of file"}, {"sha": "7199db0c9f10cca36186214984e3d259d5c0672f", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -97,12 +97,12 @@ fn test03() {\n }\n \n fn test04_start() {\n-    log \"Started Task\";\n+    log \"Started task\";\n     let int i = 1024 * 1024 * 64;\n     while (i > 0) {\n         i = i - 1;\n     }\n-    log \"Finished Task\";\n+    log \"Finished task\";\n }\n \n fn test04() {"}, {"sha": "fbc608ae8a6d0da3f5c17653add250513b2f1839", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n \n-import size_of = std.Sys.rustrt.size_of;\n+import size_of = std::sys.rustrt.size_of;\n \n use std;\n "}, {"sha": "f9ac5345bf3ecc971e48b71dccdc395809f115ea", "filename": "src/test/run-pass/use-import-export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fuse-import-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fuse-import-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-import-export.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -15,7 +15,7 @@ mod bar {\n }\n \n fn main() {\n-  foo.x();\n-  bar.y();\n+  foo::x();\n+  bar::y();\n }\n "}, {"sha": "ee8ae10ad87610897634174c46131efa790be80c", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -7,17 +7,17 @@ use zed(name = \"std\");\n use bar(name = \"std\", ver = \"0.0.1\");\n \n // FIXME: commented out since resolve doesn't know how to handle crates yet.\n-// import std.Str;\n-// import x = std.Str;\n+// import std::str;\n+// import x = std::str;\n \n mod baz {\n   use std;\n   use libc();\n   use zed(name = \"std\");\n   use bar(name = \"std\", ver = \"0.0.1\");\n \n-  // import std.Str;\n-  // import x = std.Str;\n+  // import std::str;\n+  // import x = std::str;\n }\n \n fn main() {"}, {"sha": "3281f448b05d297492611789ee4bddae37b9b835", "filename": "src/test/run-pass/user.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fuser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fuser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuser.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -8,10 +8,10 @@ use std (name = \"std\",\n          uuid = _, ver = _);\n \n fn main() {\n-  auto s = std.Str.alloc(10 as uint);\n+  auto s = std::str.alloc(10 as uint);\n   s += \"hello \";\n   log s;\n   s += \"there\";\n   log s;\n-  auto z = std.Vec.alloc[int](10 as uint);\n+  auto z = std::vec.alloc[int](10 as uint);\n }"}, {"sha": "a79294ec57274327814ea47895b6aa067afd82ff", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -2,34 +2,34 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std.Str;\n-import std.Vec;\n-import std.IO;\n+import std::_str;\n+import std::_vec;\n+import std::io;\n \n fn main() {\n   // Chars of 1, 2, 3, and 4 bytes\n   let vec[char] chs = vec('e', '\u00e9', '\u20ac', 0x10000 as char);\n-  let str s = Str.from_chars(chs);\n+  let str s = _str::from_chars(chs);\n \n-  assert (Str.byte_len(s) == 10u);\n-  assert (Str.char_len(s) == 4u);\n-  assert (Vec.len[char](Str.to_chars(s)) == 4u);\n-  assert (Str.eq(Str.from_chars(Str.to_chars(s)), s));\n-  assert (Str.char_at(s, 0u) == 'e');\n-  assert (Str.char_at(s, 1u) == '\u00e9');\n+  assert (_str::byte_len(s) == 10u);\n+  assert (_str::char_len(s) == 4u);\n+  assert (_vec::len[char](_str::to_chars(s)) == 4u);\n+  assert (_str::eq(_str::from_chars(_str::to_chars(s)), s));\n+  assert (_str::char_at(s, 0u) == 'e');\n+  assert (_str::char_at(s, 1u) == '\u00e9');\n \n-  assert (Str.is_utf8(Str.bytes(s)));\n-  assert (!Str.is_utf8(vec(0x80_u8)));\n-  assert (!Str.is_utf8(vec(0xc0_u8)));\n-  assert (!Str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n+  assert (_str::is_utf8(_str::bytes(s)));\n+  assert (!_str::is_utf8(vec(0x80_u8)));\n+  assert (!_str::is_utf8(vec(0xc0_u8)));\n+  assert (!_str::is_utf8(vec(0xc0_u8, 0x10_u8)));\n \n   auto stack = \"a\u00d7c\u20ac\";\n-  assert (Str.pop_char(stack) == '\u20ac');\n-  assert (Str.pop_char(stack) == 'c');\n-  Str.push_char(stack, 'u');\n-  assert (Str.eq(stack, \"a\u00d7u\"));\n-  assert (Str.shift_char(stack) == 'a');\n-  assert (Str.shift_char(stack) == '\u00d7');\n-  Str.unshift_char(stack, '\u00df');\n-  assert (Str.eq(stack, \"\u00dfu\"));\n+  assert (_str::pop_char(stack) == '\u20ac');\n+  assert (_str::pop_char(stack) == 'c');\n+  _str::push_char(stack, 'u');\n+  assert (_str::eq(stack, \"a\u00d7u\"));\n+  assert (_str::shift_char(stack) == 'a');\n+  assert (_str::shift_char(stack) == '\u00d7');\n+  _str::unshift_char(stack, '\u00df');\n+  assert (_str::eq(stack, \"\u00dfu\"));\n }"}, {"sha": "d0ca6ab9c8c4c3e619012aed389debe03df071ce", "filename": "src/test/run-pass/vec-alloc-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -6,7 +6,7 @@\n use std;\n \n fn slice[T](vec[T] e) {\n-  let vec[T] result = std.Vec.alloc[T](1 as uint);\n+  let vec[T] result = std::vec.alloc[T](1 as uint);\n   log \"alloced\";\n   result += e;\n   log \"appended\";"}, {"sha": "dc36799bce4e38aee4c2221181c41887dc98a726", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -4,11 +4,11 @@\n // -*- rust -*-\n \n use std;\n-import std.Str;\n-import std.Vec;\n+import std::_str;\n+import std::_vec;\n \n \n-// FIXME: import std.Dbg.const_refcount. Currently\n+// FIXME: import std::dbg::const_refcount. Currently\n // cross-crate const references don't work.\n const uint const_refcount = 0x7bad_face_u;\n \n@@ -53,30 +53,30 @@ fn slow_growth2_helper(str s) {   // ref up: s\n     let vec[str] v = vec(mumble); // ref up: v, mumble\n     let acc a = acc(v);           // ref up: a, v\n \n-    log Vec.refcount[str](v);\n-    assert (Vec.refcount[str](v) == 2u);\n+    log _vec::refcount[str](v);\n+    assert (_vec::refcount[str](v) == 2u);\n \n     a.add(s);                     // ref up: mumble, s.  ref down: v\n \n-    log Vec.refcount[str](v);\n-    log Str.refcount(s);\n-    log Str.refcount(mumble);\n+    log _vec::refcount[str](v);\n+    log _str::refcount(s);\n+    log _str::refcount(mumble);\n \n-    assert (Vec.refcount[str](v) == 1u);\n-    assert (Str.refcount(s) == const_refcount);\n-    assert (Str.refcount(mumble) == const_refcount);\n+    assert (_vec::refcount[str](v) == 1u);\n+    assert (_str::refcount(s) == const_refcount);\n+    assert (_str::refcount(mumble) == const_refcount);\n \n     log v.(0);\n-    log Vec.len[str](v);\n-    assert (Str.eq(v.(0), mumble));\n-    assert (Vec.len[str](v) == 1u);\n+    log _vec::len[str](v);\n+    assert (_str::eq(v.(0), mumble));\n+    assert (_vec::len[str](v) == 1u);\n   }                               // ref down: a, mumble, s, v\n \n-  log Str.refcount(s);\n-  log Str.refcount(mumble);\n+  log _str::refcount(s);\n+  log _str::refcount(mumble);\n \n-  assert (Str.refcount(s) == const_refcount);\n-  assert (Str.refcount(mumble) == const_refcount);\n+  assert (_str::refcount(s) == const_refcount);\n+  assert (_str::refcount(mumble) == const_refcount);\n \n   log mumble;\n   log ss;\n@@ -85,8 +85,8 @@ fn slow_growth2_helper(str s) {   // ref up: s\n fn slow_growth2() {\n   let str s = \"hi\";               // ref up: s\n   slow_growth2_helper(s);\n-  log Str.refcount(s);\n-  assert (Str.refcount(s) == const_refcount);\n+  log _str::refcount(s);\n+  assert (_str::refcount(s) == const_refcount);\n }\n \n fn main() {"}, {"sha": "86ba642b61f640a964c1c08f1234ad839a34c85a", "filename": "src/test/run-pass/vec-ref-count.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs?ref=3816e57fd2a8ab19e4ac6d4b3ddd5b49d5973ff2", "patch": "@@ -1,12 +1,12 @@\n use std;\n-import std.Vec;\n+import std::_vec;\n \n fn main() {\n     auto v = vec(1, 2, 3);\n-    log_err Vec.refcount[int](v);\n-    log_err Vec.refcount[int](v);\n-    log_err Vec.refcount[int](v);\n-    assert (Vec.refcount[int](v) == 1u || Vec.refcount[int](v) == 2u);\n-    assert (Vec.refcount[int](v) == 1u || Vec.refcount[int](v) == 2u);\n+    log_err _vec::refcount[int](v);\n+    log_err _vec::refcount[int](v);\n+    log_err _vec::refcount[int](v);\n+    assert (_vec::refcount[int](v) == 1u || _vec::refcount[int](v) == 2u);\n+    assert (_vec::refcount[int](v) == 1u || _vec::refcount[int](v) == 2u);\n }\n "}]}