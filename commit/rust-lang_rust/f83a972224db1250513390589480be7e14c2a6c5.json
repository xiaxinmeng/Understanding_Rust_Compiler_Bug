{"sha": "f83a972224db1250513390589480be7e14c2a6c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4M2E5NzIyMjRkYjEyNTA1MTMzOTA1ODk0ODBiZTdlMTRjMmE2YzU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-23T19:34:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-21T14:27:26Z"}, "message": "rustc_resolve: fix fallout of merging ast::ViewItem into ast::Item.", "tree": {"sha": "09a737bef8236e2cfa14f3eaaec29da2986a46f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09a737bef8236e2cfa14f3eaaec29da2986a46f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83a972224db1250513390589480be7e14c2a6c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83a972224db1250513390589480be7e14c2a6c5", "html_url": "https://github.com/rust-lang/rust/commit/f83a972224db1250513390589480be7e14c2a6c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83a972224db1250513390589480be7e14c2a6c5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dbefcec947e8161f4d713a7ceb1b64d7bd4ab1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dbefcec947e8161f4d713a7ceb1b64d7bd4ab1c", "html_url": "https://github.com/rust-lang/rust/commit/7dbefcec947e8161f4d713a7ceb1b64d7bd4ab1c"}], "stats": {"total": 334, "additions": 156, "deletions": 178}, "files": [{"sha": "65bd83d7937fb5bc43c08c78f855562b7979653a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 131, "deletions": 153, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/f83a972224db1250513390589480be7e14c2a6c5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83a972224db1250513390589480be7e14c2a6c5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f83a972224db1250513390589480be7e14c2a6c5", "patch": "@@ -39,9 +39,9 @@ use rustc::middle::subst::FnSpace;\n use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use syntax::ast::{Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n use syntax::ast::{PathListIdent, PathListMod};\n use syntax::ast::{Public, SelfStatic};\n@@ -50,8 +50,7 @@ use syntax::ast::StructVariantKind;\n use syntax::ast::TupleVariantKind;\n use syntax::ast::TyObjectSum;\n use syntax::ast::{TypeImplItem, UnnamedField};\n-use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n-use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast::TyPath;\n use syntax::ast;\n@@ -238,11 +237,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // If the block has view items, we need an anonymous module.\n-        if block.view_items.len() > 0 {\n-            return true;\n-        }\n-\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n@@ -262,7 +256,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n         }\n \n-        // If we found neither view items nor items, we don't need to create\n+        // If we found no items, we don't need to create\n         // an anonymous module.\n \n         return false;\n@@ -280,6 +274,133 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n \n         match item.node {\n+            ItemUse(ref view_path) => {\n+                // Extract and intern the module part of the path. For\n+                // globs and lists, the path is found directly in the AST;\n+                // for simple paths we have to munge the path a little.\n+                let module_path = match view_path.node {\n+                    ViewPathSimple(_, ref full_path) => {\n+                        full_path.segments\n+                            .init()\n+                            .iter().map(|ident| ident.identifier.name)\n+                            .collect()\n+                    }\n+\n+                    ViewPathGlob(ref module_ident_path) |\n+                    ViewPathList(ref module_ident_path, _) => {\n+                        module_ident_path.segments\n+                            .iter().map(|ident| ident.identifier.name).collect()\n+                    }\n+                };\n+\n+                // Build up the import directives.\n+                let shadowable = item.attrs.iter().any(|attr| {\n+                    attr.name() == token::get_name(special_idents::prelude_import.name)\n+                });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n+\n+                match view_path.node {\n+                    ViewPathSimple(binding, ref full_path) => {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" ||\n+                           token::get_name(source_name).get() == \"self\" {\n+                            self.resolve_error(view_path.span,\n+                                \"`self` imports are only allowed within a { } list\");\n+                        }\n+\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    subclass,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                    ViewPathList(_, ref source_items) => {\n+                        // Make sure there's at most one `mod` import in the list.\n+                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n+                            PathListMod { .. } => Some(item.span),\n+                            _ => None\n+                        }).collect::<Vec<Span>>();\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`self` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `self` import appears here\");\n+                            }\n+                        }\n+\n+                        for source_item in source_items.iter() {\n+                            let (module_path, name) = match source_item.node {\n+                                PathListIdent { name, .. } =>\n+                                    (module_path.clone(), name.name),\n+                                PathListMod { .. } => {\n+                                    let name = match module_path.last() {\n+                                        Some(name) => *name,\n+                                        None => {\n+                                            self.resolve_error(source_item.span,\n+                                                \"`self` import can only appear in an import list \\\n+                                                 with a non-empty prefix\");\n+                                            continue;\n+                                        }\n+                                    };\n+                                    let module_path = module_path.init();\n+                                    (module_path.to_vec(), name)\n+                                }\n+                            };\n+                            self.build_import_directive(\n+                                &**parent,\n+                                module_path,\n+                                SingleImport(name, name),\n+                                source_item.span,\n+                                source_item.node.id(),\n+                                is_public,\n+                                shadowable);\n+                        }\n+                    }\n+                    ViewPathGlob(_) => {\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    GlobImport,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                }\n+                parent.clone()\n+            }\n+\n+            ItemExternCrate(_) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link = ModuleParentLink(parent.downgrade(), name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_string(&*external_module));\n+                    self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n+                    parent.external_module_children.borrow_mut()\n+                          .insert(name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(&external_module);\n+                }\n+                parent.clone()\n+            }\n+\n             ItemMod(..) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n@@ -650,145 +771,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                           variant.span, PUBLIC | IMPORTABLE);\n     }\n \n-    /// Constructs the reduced graph for one 'view item'. View items consist\n-    /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem, parent: &Rc<Module>) {\n-        match view_item.node {\n-            ViewItemUse(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n-                    ViewPathSimple(_, ref full_path, _) => {\n-                        full_path.segments\n-                            .init()\n-                            .iter().map(|ident| ident.identifier.name)\n-                            .collect()\n-                    }\n-\n-                    ViewPathGlob(ref module_ident_path, _) |\n-                    ViewPathList(ref module_ident_path, _, _) => {\n-                        module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n-                    }\n-                };\n-\n-                // Build up the import directives.\n-                let is_public = view_item.vis == ast::Public;\n-                let shadowable =\n-                    view_item.attrs\n-                             .iter()\n-                             .any(|attr| {\n-                                 attr.name() == token::get_name(\n-                                    special_idents::prelude_import.name)\n-                             });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n-\n-                match view_path.node {\n-                    ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" ||\n-                           token::get_name(source_name).get() == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n-                        }\n-\n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                    ViewPathList(_, ref source_items, _) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n-                        if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `self` import appears here\");\n-                            }\n-                        }\n-\n-                        for source_item in source_items.iter() {\n-                            let (module_path, name) = match source_item.node {\n-                                PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name.name),\n-                                PathListMod { .. } => {\n-                                    let name = match module_path.last() {\n-                                        Some(name) => *name,\n-                                        None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n-                                            continue;\n-                                        }\n-                                    };\n-                                    let module_path = module_path.init();\n-                                    (module_path.to_vec(), name)\n-                                }\n-                            };\n-                            self.build_import_directive(\n-                                &**parent,\n-                                module_path,\n-                                SingleImport(name, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n-                        }\n-                    }\n-                    ViewPathGlob(_, id) => {\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                }\n-            }\n-\n-            ViewItemExternCrate(name, _, node_id) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n-                    self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(parent.downgrade(), name.name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n-                    self.check_for_conflicts_between_external_crates(\n-                        &**parent,\n-                        name.name,\n-                        view_item.span);\n-                    parent.external_module_children.borrow_mut()\n-                          .insert(name.name, external_module.clone());\n-                    self.build_reduced_graph_for_external_crate(&external_module);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item<F>(&mut self,\n                                                foreign_item: &ForeignItem,\n@@ -1270,10 +1252,6 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        self.builder.build_reduced_graph_for_view_item(view_item, &self.parent);\n-    }\n-\n     fn visit_block(&mut self, block: &Block) {\n         let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n         let old_parent = replace(&mut self.parent, np);"}, {"sha": "97370112ab40f422af7504dad50f23f71d84709a", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f83a972224db1250513390589480be7e14c2a6c5/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83a972224db1250513390589480be7e14c2a6c5/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=f83a972224db1250513390589480be7e14c2a6c5", "patch": "@@ -25,7 +25,6 @@ use Namespace::{TypeNS, ValueNS};\n use rustc::lint;\n use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n-use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse};\n use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n@@ -109,53 +108,54 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_view_item(&mut self, vi: &ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if vi.vis == ast::Public || vi.span == DUMMY_SP {\n-            visit::walk_view_item(self, vi);\n+        if item.vis == ast::Public || item.span == DUMMY_SP {\n+            visit::walk_item(self, item);\n             return;\n         }\n \n-        match vi.node {\n-            ViewItemExternCrate(_, _, id) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+        match item.node {\n+            ast::ItemExternCrate(_) => {\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                              id,\n-                                              vi.span,\n+                                              item.id,\n+                                              item.span,\n                                               \"unused extern crate\".to_string());\n                     }\n                 }\n             },\n-            ViewItemUse(ref p) => {\n+            ast::ItemUse(ref p) => {\n                 match p.node {\n-                    ViewPathSimple(_, _, id) => {\n-                        self.finalize_import(id, p.span)\n+                    ViewPathSimple(_, _) => {\n+                        self.finalize_import(item.id, p.span)\n                     }\n \n-                    ViewPathList(_, ref list, _) => {\n+                    ViewPathList(_, ref list) => {\n                         for i in list.iter() {\n                             self.finalize_import(i.node.id(), i.span);\n                         }\n                     }\n-                    ViewPathGlob(_, id) => {\n-                        if !self.used_imports.contains(&(id, TypeNS)) &&\n-                           !self.used_imports.contains(&(id, ValueNS)) {\n+                    ViewPathGlob(_) => {\n+                        if !self.used_imports.contains(&(item.id, TypeNS)) &&\n+                           !self.used_imports.contains(&(item.id, ValueNS)) {\n                             self.session\n                                 .add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                          id,\n+                                          item.id,\n                                           p.span,\n                                           \"unused import\".to_string());\n                         }\n                     }\n                 }\n             }\n+            _ => {}\n         }\n \n-        visit::walk_view_item(self, vi);\n+        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "e4453e8fc59840d88182bf94b5bffc54b410ecf8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f83a972224db1250513390589480be7e14c2a6c5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83a972224db1250513390589480be7e14c2a6c5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f83a972224db1250513390589480be7e14c2a6c5", "patch": "@@ -65,10 +65,10 @@ use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n-use syntax::ast::{MethodImplItem, Mod, Name, NodeId};\n+use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n+use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n+use syntax::ast::{Local, MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path};\n use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n@@ -1139,7 +1139,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.krate == LOCAL_CRATE {\n+        if did.krate == ast::LOCAL_CRATE {\n             self.ast_map.expect_item(did.node).ident.name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n@@ -2966,9 +2966,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n-           ItemMac(..) => {\n+            ItemExternCrate(_) | ItemUse(_) | ItemMac(..) => {\n                 // do nothing, these are just around to be encoded\n-           }\n+            }\n         }\n     }\n "}]}