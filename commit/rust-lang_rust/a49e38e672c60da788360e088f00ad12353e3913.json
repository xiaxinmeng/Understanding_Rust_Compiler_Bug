{"sha": "a49e38e672c60da788360e088f00ad12353e3913", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OWUzOGU2NzJjNjBkYTc4ODM2MGUwODhmMDBhZDEyMzUzZTM5MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-23T20:10:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-23T20:10:29Z"}, "message": "Auto merge of #88265 - m-ou-se:rollup-soymv20, r=m-ou-se\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #87976 (Account for tabs when highlighting multiline code suggestions)\n - #88174 (Clarify some wording in Rust 2021 lint docs)\n - #88188 (Greatly improve limitation handling on parallel rustdoc GUI test run)\n - #88230 (Fix typos \u201ca\u201d\u2192\u201can\u201d)\n - #88232 (Add notes to macro-not-found diagnostics to point out how things with the same name were not a match.)\n - #88259 (Do not mark `-Z thir-unsafeck` as unsound anymore)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4fa9f598720e53ebe4efbe6499c6d61dcf120326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fa9f598720e53ebe4efbe6499c6d61dcf120326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49e38e672c60da788360e088f00ad12353e3913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49e38e672c60da788360e088f00ad12353e3913", "html_url": "https://github.com/rust-lang/rust/commit/a49e38e672c60da788360e088f00ad12353e3913", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49e38e672c60da788360e088f00ad12353e3913/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "html_url": "https://github.com/rust-lang/rust/commit/9583fd1bdd0127328e25e5b8c24dff575ec2c86b"}, {"sha": "e7101326160ebf6642339a5099d22f6502bf2ae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7101326160ebf6642339a5099d22f6502bf2ae4", "html_url": "https://github.com/rust-lang/rust/commit/e7101326160ebf6642339a5099d22f6502bf2ae4"}], "stats": {"total": 854, "additions": 573, "deletions": 281}, "files": [{"sha": "710a592e258b43d1ec067d6562e9c705ebee05b8", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -495,7 +495,7 @@ impl Token {\n         self.lifetime().is_some()\n     }\n \n-    /// Returns `true` if the token is a identifier whose name is the given\n+    /// Returns `true` if the token is an identifier whose name is the given\n     /// string slice.\n     pub fn is_ident_named(&self, name: Symbol) -> bool {\n         self.ident().map_or(false, |(ident, _)| ident.name == name)"}, {"sha": "3eb38514b3cfa502dc4855a2253fd936eebb286b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1265,7 +1265,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     ty,\n                                 );\n \n-                                // Construct a AnonConst where the expr is the \"ty\"'s path.\n+                                // Construct an AnonConst where the expr is the \"ty\"'s path.\n \n                                 let parent_def_id = self.current_hir_id_owner.0;\n                                 let node_id = self.resolver.next_node_id();\n@@ -2690,7 +2690,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Report an error on illegal use of `'_` or a `&T` with no explicit lifetime;\n-    /// return a \"error lifetime\".\n+    /// return an \"error lifetime\".\n     fn new_error_lifetime(&mut self, id: Option<NodeId>, span: Span) -> hir::Lifetime {\n         let (id, msg, label) = match id {\n             Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),"}, {"sha": "4ad711ccaf1cac7e3c3bc1a463fb8fb85b0cee30", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1700,7 +1700,7 @@ where\n /// One or more fields: call the base case function on the first value (which depends on\n /// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n /// fields.\n-/// When the `substructure` is a `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n+/// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n /// is returned. Statics may not be folded over.\n /// See `cs_op` in `partial_ord.rs` for a model example.\n pub fn cs_fold1<F, B>("}, {"sha": "07e1b55afe5be961bf73d46dd2939367bac9bddc", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -558,7 +558,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n         if self.sess().target.arch == \"amdgpu\" {\n-            // amdgpu/LLVM does something weird and thinks a i64 value is\n+            // amdgpu/LLVM does something weird and thinks an i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n             // tripping an assertion. So, for now, just disable this\n             // optimization."}, {"sha": "e30c49295ba8c2b7054d5812651cc0a99ffb87ad", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -137,9 +137,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         match scalar.value {\n                             Primitive::Int(..) => {\n                                 if self.cx().size_of(ret_ty).bytes() < 4 {\n-                                    // `va_arg` should not be called on a integer type\n+                                    // `va_arg` should not be called on an integer type\n                                     // less than 4 bytes in length. If it is, promote\n-                                    // the integer to a `i32` and truncate the result\n+                                    // the integer to an `i32` and truncate the result\n                                     // back to the smaller type.\n                                     let promoted_result = emit_va_arg(self, args[0], tcx.types.i32);\n                                     self.trunc(promoted_result, llret_ty)\n@@ -1031,7 +1031,7 @@ fn generic_simd_intrinsic(\n         // vector mask and returns an unsigned integer containing the most\n         // significant bit (MSB) of each lane.\n \n-        // If the vector has less than 8 lanes, an u8 is returned with zeroed\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed\n         // trailing bits.\n         let expected_int_bits = in_len.max(8);\n         match ret_ty.kind() {"}, {"sha": "65869483025fb7e04f432e4b46807fa788bd2789", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -901,7 +901,7 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     //\n     // Performance note: Unordered comparison can be lowered to a \"flipped\"\n     // comparison and a negation, and the negation can be merged into the\n-    // select. Therefore, it not necessarily any more expensive than a\n+    // select. Therefore, it not necessarily any more expensive than an\n     // ordered (\"normal\") comparison. Whether these optimizations will be\n     // performed is ultimately up to the backend, but at least x86 does\n     // perform them."}, {"sha": "5b27a407ad422eb09925e404da83328ba31fc1c9", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -321,7 +321,7 @@ pub unsafe trait IntoErasedSendSync<'a> {\n /////////////////////////////////////////////////////////////////////////////\n \n impl<O, T: ?Sized> OwningRef<O, T> {\n-    /// Creates a new owning reference from a owner\n+    /// Creates a new owning reference from an owner\n     /// initialized to the direct dereference of it.\n     ///\n     /// # Example\n@@ -368,7 +368,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref.map(|array| &array[2]);\n     ///     assert_eq!(*owning_ref, 3);\n@@ -396,7 +396,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref.try_map(|array| {\n     ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n@@ -430,7 +430,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// in an additional `Box<O>`.\n     ///\n     /// This can be used to safely erase the owner of any `OwningRef<O, T>`\n-    /// to a `OwningRef<Box<Erased>, T>`.\n+    /// to an `OwningRef<Box<Erased>, T>`.\n     pub fn map_owner_box(self) -> OwningRef<Box<O>, T> {\n         OwningRef { reference: self.reference, owner: Box::new(self.owner) }\n     }\n@@ -511,7 +511,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n }\n \n impl<O, T: ?Sized> OwningRefMut<O, T> {\n-    /// Creates a new owning reference from a owner\n+    /// Creates a new owning reference from an owner\n     /// initialized to the direct dereference of it.\n     ///\n     /// # Example\n@@ -558,7 +558,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref_mut.map(|array| &array[2]);\n     ///     assert_eq!(*owning_ref, 3);\n@@ -586,7 +586,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref_mut = owning_ref_mut.map_mut(|array| &mut array[2]);\n     ///     assert_eq!(*owning_ref_mut, 3);\n@@ -614,7 +614,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref = owning_ref_mut.try_map(|array| {\n     ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n@@ -644,7 +644,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n     ///\n-    ///     // create a owning reference that points at the\n+    ///     // create an owning reference that points at the\n     ///     // third element of the array.\n     ///     let owning_ref_mut = owning_ref_mut.try_map_mut(|array| {\n     ///         if array[2] == 3 { Ok(&mut array[2]) } else { Err(()) }\n@@ -678,7 +678,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// in an additional `Box<O>`.\n     ///\n     /// This can be used to safely erase the owner of any `OwningRefMut<O, T>`\n-    /// to a `OwningRefMut<Box<Erased>, T>`.\n+    /// to an `OwningRefMut<Box<Erased>, T>`.\n     pub fn map_owner_box(self) -> OwningRefMut<Box<O>, T> {\n         OwningRefMut { reference: self.reference, owner: Box::new(self.owner) }\n     }\n@@ -970,7 +970,7 @@ where\n     }\n }\n \n-// ^ FIXME: Is a Into impl for calling into_inner() possible as well?\n+// ^ FIXME: Is an Into impl for calling into_inner() possible as well?\n \n impl<O, T: ?Sized> Debug for OwningRef<O, T>\n where\n@@ -1139,27 +1139,27 @@ impl<T: 'static> ToHandleMut for RefCell<T> {\n // about which handle creation to use (i.e., read() vs try_read()) as well as\n // what to do with error results.\n \n-/// Typedef of a owning reference that uses a `Box` as the owner.\n+/// Typedef of an owning reference that uses a `Box` as the owner.\n pub type BoxRef<T, U = T> = OwningRef<Box<T>, U>;\n-/// Typedef of a owning reference that uses a `Vec` as the owner.\n+/// Typedef of an owning reference that uses a `Vec` as the owner.\n pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n-/// Typedef of a owning reference that uses a `String` as the owner.\n+/// Typedef of an owning reference that uses a `String` as the owner.\n pub type StringRef = OwningRef<String, str>;\n \n-/// Typedef of a owning reference that uses a `Rc` as the owner.\n+/// Typedef of an owning reference that uses a `Rc` as the owner.\n pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n-/// Typedef of a owning reference that uses a `Arc` as the owner.\n+/// Typedef of an owning reference that uses an `Arc` as the owner.\n pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n \n-/// Typedef of a owning reference that uses a `Ref` as the owner.\n+/// Typedef of an owning reference that uses a `Ref` as the owner.\n pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `RefMut` as the owner.\n+/// Typedef of an owning reference that uses a `RefMut` as the owner.\n pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `MutexGuard` as the owner.\n+/// Typedef of an owning reference that uses a `MutexGuard` as the owner.\n pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `RwLockReadGuard` as the owner.\n+/// Typedef of an owning reference that uses a `RwLockReadGuard` as the owner.\n pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n-/// Typedef of a owning reference that uses a `RwLockWriteGuard` as the owner.\n+/// Typedef of an owning reference that uses a `RwLockWriteGuard` as the owner.\n pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n \n /// Typedef of a mutable owning reference that uses a `Box` as the owner.\n@@ -1219,11 +1219,11 @@ unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n     }\n }\n \n-/// Typedef of a owning reference that uses an erased `Box` as the owner.\n+/// Typedef of an owning reference that uses an erased `Box` as the owner.\n pub type ErasedBoxRef<U> = OwningRef<Box<dyn Erased>, U>;\n-/// Typedef of a owning reference that uses an erased `Rc` as the owner.\n+/// Typedef of an owning reference that uses an erased `Rc` as the owner.\n pub type ErasedRcRef<U> = OwningRef<Rc<dyn Erased>, U>;\n-/// Typedef of a owning reference that uses an erased `Arc` as the owner.\n+/// Typedef of an owning reference that uses an erased `Arc` as the owner.\n pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n \n /// Typedef of a mutable owning reference that uses an erased `Box` as the owner."}, {"sha": "0bbd0eda0c6e1cdd0130013c598eb0c83a395b6b", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -220,7 +220,7 @@ impl SelfProfilerRef {\n         VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n \n-    /// Start profiling a extra verbose generic activity. Profiling continues until the\n+    /// Start profiling an extra verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"extra verbose\" generic activities also print a timing entry to\n     /// stdout if the compiler is invoked with -Ztime-passes."}, {"sha": "f99ca53ab25dface5c9550a943bcf87b69fae37d", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -14,7 +14,7 @@\n //!\n //! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n //!\n-//! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n+//! `rustc_erase_owner!` erases an OwningRef owner into Erased or Erased + Send + Sync\n //! depending on the value of cfg!(parallel_compiler).\n \n use crate::owning_ref::{Erased, OwningRef};"}, {"sha": "9b07f86846eb32089b26b5834dcdb72ab0b29e9e", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -5,7 +5,7 @@\n //!\n //! - If you have a list that rarely stores more than one element, then this\n //!   data-structure can store the element without allocating and only uses as\n-//!   much space as a `Option<(T, usize)>`. If T can double as the `Option`\n+//!   much space as an `Option<(T, usize)>`. If T can double as the `Option`\n //!   discriminant, it will even only be as large as `T, usize`.\n //!\n //! If you expect to store more than 1 element in the common case, steer clear"}, {"sha": "25777f4133b94e952176c431190252780eefd0f2", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1623,7 +1623,7 @@ impl EmitterWriter {\n             let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n             draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n             let mut lines = complete.lines();\n-            for (line_pos, (line, parts)) in\n+            for (line_pos, (line, highlight_parts)) in\n                 lines.by_ref().zip(highlights).take(MAX_SUGGESTION_HIGHLIGHT_LINES).enumerate()\n             {\n                 // Print the span column to avoid confusion\n@@ -1658,7 +1658,7 @@ impl EmitterWriter {\n                     );\n                     buffer.puts(row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n                 } else if is_multiline {\n-                    match &parts[..] {\n+                    match &highlight_parts[..] {\n                         [SubstitutionHighlight { start: 0, end }] if *end == line.len() => {\n                             buffer.puts(row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n                         }\n@@ -1676,16 +1676,24 @@ impl EmitterWriter {\n                 // print the suggestion\n                 buffer.append(row_num, &replace_tabs(line), Style::NoStyle);\n \n-                if is_multiline {\n-                    for SubstitutionHighlight { start, end } in parts {\n-                        buffer.set_style_range(\n-                            row_num,\n-                            max_line_num_len + 3 + start,\n-                            max_line_num_len + 3 + end,\n-                            Style::Addition,\n-                            true,\n-                        );\n-                    }\n+                // Colorize addition/replacements with green.\n+                for &SubstitutionHighlight { start, end } in highlight_parts {\n+                    // Account for tabs when highlighting (#87972).\n+                    let tabs: usize = line\n+                        .chars()\n+                        .take(start)\n+                        .map(|ch| match ch {\n+                            '\\t' => 3,\n+                            _ => 0,\n+                        })\n+                        .sum();\n+                    buffer.set_style_range(\n+                        row_num,\n+                        max_line_num_len + 3 + start + tabs,\n+                        max_line_num_len + 3 + end + tabs,\n+                        Style::Addition,\n+                        true,\n+                    );\n                 }\n                 row_num += 1;\n             }\n@@ -1723,13 +1731,6 @@ impl EmitterWriter {\n                     assert!(underline_start >= 0 && underline_end >= 0);\n                     let padding: usize = max_line_num_len + 3;\n                     for p in underline_start..underline_end {\n-                        // Colorize addition/replacements with green.\n-                        buffer.set_style(\n-                            row_num - 1,\n-                            (padding as isize + p) as usize,\n-                            Style::Addition,\n-                            true,\n-                        );\n                         if !show_diff {\n                             // If this is a replacement, underline with `^`, if this is an addition\n                             // underline with `+`."}, {"sha": "a48d4fe8bb55adb670f0b8286a0dbdf864b27328", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -283,16 +283,21 @@ impl CodeSuggestion {\n                 let mut buf = String::new();\n \n                 let mut line_highlight = vec![];\n+                // We need to keep track of the difference between the existing code and the added\n+                // or deleted code in order to point at the correct column *after* substitution.\n+                let mut acc = 0;\n                 for part in &substitution.parts {\n                     let cur_lo = sm.lookup_char_pos(part.span.lo());\n                     if prev_hi.line == cur_lo.line {\n                         let mut count =\n                             push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n                         while count > 0 {\n                             highlights.push(std::mem::take(&mut line_highlight));\n+                            acc = 0;\n                             count -= 1;\n                         }\n                     } else {\n+                        acc = 0;\n                         highlights.push(std::mem::take(&mut line_highlight));\n                         let mut count = push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n                         while count > 0 {\n@@ -316,18 +321,43 @@ impl CodeSuggestion {\n                         }\n                     }\n                     // Add a whole line highlight per line in the snippet.\n+                    let len: isize = part\n+                        .snippet\n+                        .split('\\n')\n+                        .next()\n+                        .unwrap_or(&part.snippet)\n+                        .chars()\n+                        .map(|c| match c {\n+                            '\\t' => 4,\n+                            _ => 1,\n+                        })\n+                        .sum();\n                     line_highlight.push(SubstitutionHighlight {\n-                        start: cur_lo.col.0,\n-                        end: cur_lo.col.0\n-                            + part.snippet.split('\\n').next().unwrap_or(&part.snippet).len(),\n+                        start: (cur_lo.col.0 as isize + acc) as usize,\n+                        end: (cur_lo.col.0 as isize + acc + len) as usize,\n                     });\n+                    buf.push_str(&part.snippet);\n+                    let cur_hi = sm.lookup_char_pos(part.span.hi());\n+                    if prev_hi.line == cur_lo.line {\n+                        // Account for the difference between the width of the current code and the\n+                        // snippet being suggested, so that the *later* suggestions are correctly\n+                        // aligned on the screen.\n+                        acc += len as isize - (cur_hi.col.0 - cur_lo.col.0) as isize;\n+                    }\n+                    prev_hi = cur_hi;\n+                    prev_line = sf.get_line(prev_hi.line - 1);\n                     for line in part.snippet.split('\\n').skip(1) {\n+                        acc = 0;\n                         highlights.push(std::mem::take(&mut line_highlight));\n-                        line_highlight.push(SubstitutionHighlight { start: 0, end: line.len() });\n+                        let end: usize = line\n+                            .chars()\n+                            .map(|c| match c {\n+                                '\\t' => 4,\n+                                _ => 1,\n+                            })\n+                            .sum();\n+                        line_highlight.push(SubstitutionHighlight { start: 0, end });\n                     }\n-                    buf.push_str(&part.snippet);\n-                    prev_hi = sm.lookup_char_pos(part.span.hi());\n-                    prev_line = sf.get_line(prev_hi.line - 1);\n                 }\n                 highlights.push(std::mem::take(&mut line_highlight));\n                 let only_capitalization = is_case_difference(sm, &buf, bounding_span);"}, {"sha": "888d1c1832b09d2e00e4a6bc2c6b5676f5e6ee2f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -974,7 +974,7 @@ pub enum PatKind<'hir> {\n     /// Invariant: `pats.len() >= 2`.\n     Or(&'hir [Pat<'hir>]),\n \n-    /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n+    /// A path pattern for a unit struct/variant or a (maybe-associated) constant.\n     Path(QPath<'hir>),\n \n     /// A tuple pattern (e.g., `(a, b)`).\n@@ -2323,7 +2323,7 @@ pub enum TyKind<'hir> {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath<'hir>),\n-    /// A opaque type definition itself. This is currently only used for the\n+    /// An opaque type definition itself. This is currently only used for the\n     /// `opaque type Foo: Trait` item that `impl Trait` in desugars to.\n     ///\n     /// The generic argument list contains the lifetimes (and in the future"}, {"sha": "7f153867596ec8439a6077b8dfab9a2b9dc7199a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -313,7 +313,7 @@ pub trait Visitor<'v>: Sized {\n     }\n \n     /// When invoking `visit_all_item_likes()`, you need to supply an\n-    /// item-like visitor. This method converts a \"intra-visit\"\n+    /// item-like visitor. This method converts an \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n     /// If you use this, you probably don't want to process the\n     /// contents of nested item-like things, since the outer loop will"}, {"sha": "4830158c15afc6463bf5fb2dcd7ee67e01218654", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1697,7 +1697,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n-        // it's a actual definition. According to the comments (e.g. in\n+        // it's an actual definition. According to the comments (e.g. in\n         // librustc_typeck/check/compare_method.rs:compare_predicate_entailment) the latter\n         // is relied upon by some other code. This might (or might not) need cleanup.\n         let body_owner_def_id ="}, {"sha": "042e6159aff8b220b4abe97ad372f1af027cf49f", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -307,7 +307,7 @@ where\n     /// relations between `'0` and `'a`).\n     ///\n     /// The variable `pair` can be either a `(vid, ty)` or `(ty, vid)`\n-    /// -- in other words, it is always a (unresolved) inference\n+    /// -- in other words, it is always an (unresolved) inference\n     /// variable `vid` and a type `ty` that are being related, but the\n     /// vid may appear either as the \"a\" type or the \"b\" type,\n     /// depending on where it appears in the tuple. The trait\n@@ -389,7 +389,7 @@ where\n     }\n }\n \n-/// When we instantiate a inference variable with a value in\n+/// When we instantiate an inference variable with a value in\n /// `relate_ty_var`, we always have the pair of a `TyVid` and a `Ty`,\n /// but the ordering may vary (depending on whether the inference\n /// variable was found on the `a` or `b` sides). Therefore, this trait"}, {"sha": "af31ab0923decb72c580212b932ec59964133d5b", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -186,7 +186,7 @@ pub enum GenericKind<'tcx> {\n ///        ('a: min) || ('b: min)\n ///     }\n ///\n-/// This is described with a `AnyRegion('a, 'b)` node.\n+/// This is described with an `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n     /// Given a kind K and a bound B, expands to a function like the"}, {"sha": "89db8f464b4e7c7e41c2c003a4ab7def776c3341", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -96,7 +96,7 @@ impl Default for InferCtxtUndoLogs<'_> {\n }\n \n /// The UndoLogs trait defines how we undo a particular kind of action (of type T). We can undo any\n-/// action that is convertable into a UndoLog (per the From impls above).\n+/// action that is convertable into an UndoLog (per the From impls above).\n impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>\n where\n     UndoLog<'tcx>: From<T>,"}, {"sha": "b450c398946e5c66e5c2d4286c0e3121a4190d10", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -28,7 +28,7 @@ pub use self::project::{\n pub use rustc_middle::traits::*;\n \n /// An `Obligation` represents some trait reference (e.g., `i32: Eq`) for\n-/// which the \"impl_source\" must be found. The process of finding a \"impl_source\" is\n+/// which the \"impl_source\" must be found. The process of finding an \"impl_source\" is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for i32`) that\n /// satisfies the obligation, or else finding a bound that is in"}, {"sha": "b64a891cb2526402a421551b2050e2af390fc155", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -489,7 +489,7 @@ impl Cursor<'_> {\n         // Start is already eaten, eat the rest of identifier.\n         self.eat_while(is_id_continue);\n         // Known prefixes must have been handled earlier. So if\n-        // we see a prefix here, it is definitely a unknown prefix.\n+        // we see a prefix here, it is definitely an unknown prefix.\n         match self.first() {\n             '#' | '\"' | '\\'' => UnknownPrefix,\n             _ => Ident,"}, {"sha": "03344973bb3e64372a72d66160fdce572f191287", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -118,7 +118,7 @@ fn to_camel_case(s: &str) -> String {\n         })\n         .fold((String::new(), None), |(acc, prev): (String, Option<String>), next| {\n             // separate two components with an underscore if their boundary cannot\n-            // be distinguished using a uppercase/lowercase case distinction\n+            // be distinguished using an uppercase/lowercase case distinction\n             let join = if let Some(prev) = prev {\n                 let l = prev.chars().last().unwrap();\n                 let f = next.chars().next().unwrap();"}, {"sha": "e25c51991f5740cc9d235254ef5b45c94e13ce41", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     ty::Projection(..) => {\n                         let ty = self.cx.tcx.normalize_erasing_regions(self.cx.param_env, ty);\n \n-                        // If `ty` is a opaque type directly then `super_visit_with` won't invoke\n+                        // If `ty` is an opaque type directly then `super_visit_with` won't invoke\n                         // this function again.\n                         if ty.has_opaque_types() {\n                             self.visit_ty(ty)"}, {"sha": "b51eaf8e35374224514373f073fc16c38c4c0fb7", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -3070,16 +3070,19 @@ declare_lint! {\n \n declare_lint! {\n     /// The `rust_2021_incompatible_closure_captures` lint detects variables that aren't completely\n-    /// captured in Rust 2021 and affect the Drop order of at least one path starting at this variable.\n-    /// It can also detect when a variable implements a trait, but one of its field does not and\n-    /// the field is captured by a closure and used with the assumption that said field implements\n+    /// captured in Rust 2021, such that the `Drop` order of their fields may differ between\n+    /// Rust 2018 and 2021.\n+    ///\n+    /// It can also detect when a variable implements a trait like `Send`, but one of its fields does not,\n+    /// and the field is captured by a closure and used with the assumption that said field implements\n     /// the same trait as the root variable.\n     ///\n     /// ### Example of drop reorder\n     ///\n     /// ```rust,compile_fail\n-    /// # #![deny(rust_2021_incompatible_closure_captures)]\n+    /// #![deny(rust_2021_incompatible_closure_captures)]\n     /// # #![allow(unused)]\n+    ///\n     /// struct FancyInteger(i32);\n     ///\n     /// impl Drop for FancyInteger {\n@@ -3133,8 +3136,8 @@ declare_lint! {\n     /// ### Explanation\n     ///\n     /// In the above example, only `fptr.0` is captured in Rust 2021.\n-    /// The field is of type *mut i32 which doesn't implement Send, making the code invalid as the\n-    /// field cannot be sent between thread safely.\n+    /// The field is of type `*mut i32`, which doesn't implement `Send`,\n+    /// making the code invalid as the field cannot be sent between threads safely.\n     pub RUST_2021_INCOMPATIBLE_CLOSURE_CAPTURES,\n     Allow,\n     \"detects closures affected by Rust 2021 changes\",\n@@ -3254,6 +3257,7 @@ declare_lint! {\n     ///\n     /// ```rust,compile_fail\n     /// #![deny(rust_2021_incompatible_or_patterns)]\n+    ///\n     /// macro_rules! match_any {\n     ///     ( $expr:expr , $( $( $pat:pat )|+ => $expr_arm:expr ),+ ) => {\n     ///         match $expr {\n@@ -3275,7 +3279,7 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// In Rust 2021, the pat matcher will match new patterns, which include the | character.\n+    /// In Rust 2021, the `pat` matcher will match additional patterns, which include the `|` character.\n     pub RUST_2021_INCOMPATIBLE_OR_PATTERNS,\n     Allow,\n     \"detects usage of old versions of or-patterns\",\n@@ -3320,8 +3324,8 @@ declare_lint! {\n     /// In Rust 2021, one of the important introductions is the [prelude changes], which add\n     /// `TryFrom`, `TryInto`, and `FromIterator` into the standard library's prelude. Since this\n     /// results in an ambiguity as to which method/function to call when an existing `try_into`\n-    ///  method is called via dot-call syntax or a `try_from`/`from_iter` associated function\n-    ///  is called directly on a type.\n+    /// method is called via dot-call syntax or a `try_from`/`from_iter` associated function\n+    /// is called directly on a type.\n     ///\n     /// [prelude changes]: https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html#prelude-changes\n     pub RUST_2021_PRELUDE_COLLISIONS,\n@@ -3371,7 +3375,7 @@ declare_lint! {\n }\n \n declare_lint! {\n-    /// The `unsupported_calling_conventions` lint is output whenever there is an use of the\n+    /// The `unsupported_calling_conventions` lint is output whenever there is a use of the\n     /// `stdcall`, `fastcall`, `thiscall`, `vectorcall` calling conventions (or their unwind\n     /// variants) on targets that cannot meaningfully be supported for the requested target.\n     ///"}, {"sha": "4e591b28f608781d8f4d13a61a3097034eab5643", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -62,7 +62,7 @@ crate struct CrateMetadata {\n     // --- Some data pre-decoded from the metadata blob, usually for performance ---\n     /// Properties of the whole crate.\n     /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// lifetime is only used behind `Lazy`, and therefore acts like a\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     /// is being used to decode those values.\n     root: CrateRoot<'static>,"}, {"sha": "8efec8ef5674d6b19b4dabbd2c39db46d243dd18", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -63,7 +63,7 @@ impl MaybeFnLike for hir::Expr<'_> {\n     }\n }\n \n-/// Carries either an FnLikeNode or a Expr, as these are the two\n+/// Carries either an FnLikeNode or an Expr, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n #[derive(Copy, Clone)]"}, {"sha": "6c92c65a6dd975e7097293186414805d9fca92fa", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -151,7 +151,7 @@ rustc_index::newtype_index! {\n static_assert_size!(ScopeData, 4);\n \n impl Scope {\n-    /// Returns a item-local ID associated with this scope.\n+    /// Returns an item-local ID associated with this scope.\n     ///\n     /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`."}, {"sha": "5d17bb9b15f4b7ebe9de5cd2f3c183adb7e63f12", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -46,7 +46,7 @@ static_assert_size!(InterpErrorInfo<'_>, 8);\n /// Packages the kind of error we got from the const code interpreter\n /// up with a Rust-level backtrace of where the error occurred.\n /// These should always be constructed by calling `.into()` on\n-/// a `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*`\n+/// an `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*`\n /// macros for this.\n #[derive(Debug)]\n pub struct InterpErrorInfo<'tcx>(Box<InterpErrorInfoInner<'tcx>>);"}, {"sha": "cc31d8c2c18799301370ab4a8f39170e13b0f5e1", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -17,7 +17,7 @@ use super::{\n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n pub struct ConstAlloc<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n+    // the value lives here, at offset 0, and that allocation definitely is an `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,\n@@ -113,7 +113,7 @@ impl<'tcx> ConstValue<'tcx> {\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a\n-/// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 16 bytes in\n+/// `memory::Allocation`. It is in many ways like a small chunk of an `Allocation`, up to 16 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n ///\n@@ -376,27 +376,27 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         self.to_bits(sz)\n     }\n \n-    /// Converts the scalar to produce an `u8`. Fails if the scalar is a pointer.\n+    /// Converts the scalar to produce a `u8`. Fails if the scalar is a pointer.\n     pub fn to_u8(self) -> InterpResult<'static, u8> {\n         self.to_unsigned_with_bit_width(8).map(|v| u8::try_from(v).unwrap())\n     }\n \n-    /// Converts the scalar to produce an `u16`. Fails if the scalar is a pointer.\n+    /// Converts the scalar to produce a `u16`. Fails if the scalar is a pointer.\n     pub fn to_u16(self) -> InterpResult<'static, u16> {\n         self.to_unsigned_with_bit_width(16).map(|v| u16::try_from(v).unwrap())\n     }\n \n-    /// Converts the scalar to produce an `u32`. Fails if the scalar is a pointer.\n+    /// Converts the scalar to produce a `u32`. Fails if the scalar is a pointer.\n     pub fn to_u32(self) -> InterpResult<'static, u32> {\n         self.to_unsigned_with_bit_width(32).map(|v| u32::try_from(v).unwrap())\n     }\n \n-    /// Converts the scalar to produce an `u64`. Fails if the scalar is a pointer.\n+    /// Converts the scalar to produce a `u64`. Fails if the scalar is a pointer.\n     pub fn to_u64(self) -> InterpResult<'static, u64> {\n         self.to_unsigned_with_bit_width(64).map(|v| u64::try_from(v).unwrap())\n     }\n \n-    /// Converts the scalar to produce an `u128`. Fails if the scalar is a pointer.\n+    /// Converts the scalar to produce a `u128`. Fails if the scalar is a pointer.\n     pub fn to_u128(self) -> InterpResult<'static, u128> {\n         self.to_unsigned_with_bit_width(128)\n     }"}, {"sha": "74d303cee5d1efc14c6689cecde1a9c651cb857d", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -265,7 +265,7 @@ impl BorrowKind {\n             BorrowKind::Shared => hir::Mutability::Not,\n \n             // We have no type corresponding to a unique imm borrow, so\n-            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // use `&mut`. It gives all the capabilities of a `&uniq`\n             // and hence is a safe \"over approximation\".\n             BorrowKind::Unique => hir::Mutability::Mut,\n "}, {"sha": "45ea3e3d9f35e1cbe27776c895661e347c14822a", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1202,7 +1202,7 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n-    /// The data of an user variable, for debug info.\n+    /// The data of a user variable, for debug info.\n     VarDebugInfo,\n }\n "}, {"sha": "68de7f29193d8f61797996c481e82fbdfce92c7e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -648,7 +648,7 @@ rustc_queries! {\n         }\n     }\n \n-    /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error.\n+    /// HACK: when evaluated, this reports an \"unsafe derive on repr(packed)\" error.\n     ///\n     /// Unsafety checking is executed for each method separately, but we only want\n     /// to emit this error once per derive. As there are some impls with multiple\n@@ -1733,7 +1733,7 @@ rustc_queries! {\n     }\n \n     /// Performs an HIR-based well-formed check on the item with the given `HirId`. If\n-    /// we get an `Umimplemented` error that matches the provided `Predicate`, return\n+    /// we get an `Unimplemented` error that matches the provided `Predicate`, return\n     /// the cause of the newly created obligation.\n     ///\n     /// This is only used by error-reporting code to get a better cause (in particular, a better"}, {"sha": "457e80c1663ac413660e65d5db0ed0b7a720dd48", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -509,7 +509,7 @@ pub enum ImplSource<'tcx, N> {\n     TraitUpcasting(ImplSourceTraitUpcastingData<'tcx, N>),\n \n     /// ImplSource automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `ImplSource::UserDefined` in spirit, but the\n+    /// of the closure expression. This is an `ImplSource::UserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n     Closure(ImplSourceClosureData<'tcx, N>),\n "}, {"sha": "62996bf4cbef20cbabd6ac505afbde0533ad811b", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -111,7 +111,7 @@ pub enum SelectionCandidate<'tcx> {\n     ProjectionCandidate(usize),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression.\n+    /// generated for an `||` expression.\n     ClosureCandidate,\n \n     /// Implementation of a `Generator` trait by one of the anonymous types"}, {"sha": "27927bcca72b7a6accc5a017c64f2ee5c68d0417", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -209,7 +209,7 @@ impl<'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n-    /// Returns `true` if this is a enum.\n+    /// Returns `true` if this is an enum.\n     #[inline]\n     pub fn is_enum(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_ENUM)"}, {"sha": "4eacb3c4176c990ea2fcbfdb0ac926926830dccd", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -434,7 +434,7 @@ impl BorrowKind {\n             ImmBorrow => hir::Mutability::Not,\n \n             // We have no type corresponding to a unique imm borrow, so\n-            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // use `&mut`. It gives all the capabilities of a `&uniq`\n             // and hence is a safe \"over approximation\".\n             UniqueImmBorrow => hir::Mutability::Mut,\n         }"}, {"sha": "36db258e92d200e41eacc6b5c55a9afda11f2643", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -209,7 +209,7 @@ where\n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     fn decode(decoder: &mut D) -> Result<Ty<'tcx>, D::Error> {\n-        // Handle shorthands first, if we have an usize > 0x80.\n+        // Handle shorthands first, if we have a usize > 0x80.\n         if decoder.positioned_at_shorthand() {\n             let pos = decoder.read_usize()?;\n             assert!(pos >= SHORTHAND_OFFSET);\n@@ -228,7 +228,7 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n     fn decode(decoder: &mut D) -> Result<ty::Binder<'tcx, ty::PredicateKind<'tcx>>, D::Error> {\n         let bound_vars = Decodable::decode(decoder)?;\n-        // Handle shorthands first, if we have an usize > 0x80.\n+        // Handle shorthands first, if we have a usize > 0x80.\n         Ok(ty::Binder::bind_with_vars(\n             if decoder.positioned_at_shorthand() {\n                 let pos = decoder.read_usize()?;"}, {"sha": "28e894c5cae2d7d85c06fd8c4635f08037669958", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1792,7 +1792,7 @@ pub mod tls {\n         if context == 0 {\n             f(None)\n         } else {\n-            // We could get a `ImplicitCtxt` pointer from another thread.\n+            // We could get an `ImplicitCtxt` pointer from another thread.\n             // Ensure that `ImplicitCtxt` is `Sync`.\n             sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n "}, {"sha": "77d82ee6eae6ffab0c06633f0d3cfc36f7f5fb68", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -9,7 +9,7 @@ use crate::ty::{DefId, SubstsRef};\n \n mod def_id_forest;\n \n-// The methods in this module calculate `DefIdForest`s of modules in which a\n+// The methods in this module calculate `DefIdForest`s of modules in which an\n // `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n //\n // # Example"}, {"sha": "80c99872dd7663e0fd405e581654ea5208e89bb2", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -2571,14 +2571,14 @@ where\n     /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n     ///\n     /// NB: this doesn't handle virtual calls - those should use `FnAbi::of_instance`\n-    /// instead, where the instance is a `InstanceDef::Virtual`.\n+    /// instead, where the instance is an `InstanceDef::Virtual`.\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n \n     /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n     /// direct calls to an `fn`.\n     ///\n     /// NB: that includes virtual calls, which are represented by \"direct calls\"\n-    /// to a `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n+    /// to an `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n \n     fn new_internal("}, {"sha": "62e093581b8622322b0604546e028ead7251e4f9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -865,7 +865,7 @@ impl<'tcx> Predicate<'tcx> {\n \n /// Represents the bounds declared on a particular set of type\n /// parameters. Should eventually be generalized into a flag list of\n-/// where-clauses. You can obtain a `InstantiatedPredicates` list from a\n+/// where-clauses. You can obtain an `InstantiatedPredicates` list from a\n /// `GenericPredicates` by using the `instantiate` method. Note that this method\n /// reflects an important semantic invariant of `InstantiatedPredicates`: while\n /// the `GenericPredicates` are expressed in terms of the bound type\n@@ -1371,7 +1371,7 @@ bitflags! {\n     }\n }\n \n-/// Definition of a variant -- a struct's fields or a enum variant.\n+/// Definition of a variant -- a struct's fields or an enum variant.\n #[derive(Debug, HashStable)]\n pub struct VariantDef {\n     /// `DefId` that identifies the variant itself."}, {"sha": "8e0a2d4a28df026167d7fada4d7c6083ea5bd951", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -239,7 +239,7 @@ static_assert_size!(TyKind<'_>, 32);\n ///   implements `CK<(u32, u32), Output = u32>`, where `CK` is the trait\n ///   specified above.\n /// - U is a type parameter representing the types of its upvars, tupled up\n-///   (borrowed, if appropriate; that is, if an U field represents a by-ref upvar,\n+///   (borrowed, if appropriate; that is, if a U field represents a by-ref upvar,\n ///    and the up-var has the type `Foo`, then that field of U will be `&Foo`).\n ///\n /// So, for example, given this function:\n@@ -1323,7 +1323,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// These are regions that are stored behind a binder and must be substituted\n /// with some concrete region before being used. There are two kind of\n /// bound regions: early-bound, which are bound in an item's `Generics`,\n-/// and are substituted by a `InternalSubsts`, and late-bound, which are part of\n+/// and are substituted by an `InternalSubsts`, and late-bound, which are part of\n /// higher-ranked types (e.g., `for<'a> fn(&'a ())`), and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n@@ -1471,7 +1471,7 @@ pub type PolyExistentialProjection<'tcx> = Binder<'tcx, ExistentialProjection<'t\n impl<'tcx> ExistentialProjection<'tcx> {\n     /// Extracts the underlying existential trait reference from this projection.\n     /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n-    /// then this function would return a `exists T. T: Iterator` existential trait\n+    /// then this function would return an `exists T. T: Iterator` existential trait\n     /// reference.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();"}, {"sha": "4fbb4d1806f83fb774c2cac1d62789bc4a8ba633", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -22,7 +22,7 @@ use std::ops::ControlFlow;\n \n /// An entity in the Rust type system, which can be one of\n /// several kinds (types, lifetimes, and consts).\n-/// To reduce memory usage, a `GenericArg` is a interned pointer,\n+/// To reduce memory usage, a `GenericArg` is an interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -204,12 +204,12 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         GeneratorSubsts { substs: self }\n     }\n \n-    /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n+    /// Creates an `InternalSubsts` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| tcx.mk_param_from_def(param))\n     }\n \n-    /// Creates a `InternalSubsts` for generic parameter definitions,\n+    /// Creates an `InternalSubsts` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n     /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly"}, {"sha": "a78206034f08a50206d657980e4469f13641749b", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -681,7 +681,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n-    /// trait -- frozen types are those that do not contain a\n+    /// trait -- frozen types are those that do not contain an\n     /// `UnsafeCell` anywhere. This is a language concept used to\n     /// distinguish \"true immutability\", which is relevant to\n     /// optimization as well as the rules around static values. Note"}, {"sha": "6561fe37c1c475b00f7520417c9199fedacd221a", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -825,7 +825,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // We're going to want to traverse the first borrowed place to see if we can find\n                 // field access to a union. If we find that, then we will keep the place of the\n                 // union being accessed and the field that was being accessed so we can check the\n-                // second borrowed place for the same union and a access to a different field.\n+                // second borrowed place for the same union and an access to a different field.\n                 for (place_base, elem) in first_borrowed_place.iter_projections().rev() {\n                     match elem {\n                         ProjectionElem::Field(field, _) if union_ty(place_base).is_some() => {\n@@ -838,7 +838,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             })\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n-                // borrowed place and look for a access to a different field of the same union.\n+                // borrowed place and look for an access to a different field of the same union.\n                 for (place_base, elem) in second_borrowed_place.iter_projections().rev() {\n                     if let ProjectionElem::Field(field, _) = elem {\n                         if let Some(union_ty) = union_ty(place_base) {"}, {"sha": "f40a2db330a97062321e7ab72b26da575ab8a33f", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -606,7 +606,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Checks if a borrowed value was captured by a trait object. We do this by\n     /// looking forward in the MIR from the reserve location and checking if we see\n-    /// a unsized cast to a trait object on our data.\n+    /// an unsized cast to a trait object on our data.\n     fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n         // Start at the reserve location, find the place that we want to see cast to a trait object.\n         let location = borrow.reserve_location;\n@@ -666,7 +666,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                             _ => {}\n                         },\n-                        // If we see a unsized cast, then if it is our data we should check\n+                        // If we see an unsized cast, then if it is our data we should check\n                         // whether it is being cast to a trait object.\n                         Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), operand, ty) => {\n                             match operand {"}, {"sha": "7be3f5414879e742495797e33d0b3f8e70f239e4", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 // If the place is immutable then:\n                 //\n-                // - Either we deref a immutable ref to get to our final place.\n+                // - Either we deref an immutable ref to get to our final place.\n                 //    - We don't capture derefs of raw ptrs\n                 // - Or the final place is immut because the root variable of the capture\n                 //   isn't marked mut and we should suggest that to the user.\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let reason = if let PlaceBase::Upvar(upvar_id) = closure_kind_origin.base {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;\n-                // we have a origin for this closure kind starting at this root variable so it's safe to unwrap here\n+                // we have an origin for this closure kind starting at this root variable so it's safe to unwrap here\n                 let captured_places = tables.closure_min_captures[id].get(&root_hir_id).unwrap();\n \n                 let origin_projection = closure_kind_origin"}, {"sha": "cbb8f064bb81ae6132770ca6ce15e2225f2d8215", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag\n     }\n \n-    /// Reports a error specifically for when data is escaping a closure.\n+    /// Reports an error specifically for when data is escaping a closure.\n     ///\n     /// ```text\n     /// error: borrowed data escapes outside of function\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag\n     }\n \n-    /// Adds a suggestion to errors where a `impl Trait` is returned.\n+    /// Adds a suggestion to errors where an `impl Trait` is returned.\n     ///\n     /// ```text\n     /// help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as"}, {"sha": "1dcb06765625899768022a79e169f4dfef0a690c", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1241,7 +1241,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        // Special case: you can assign a immutable local variable\n+        // Special case: you can assign an immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n         if let Some(local) = place_span.0.as_local() {\n@@ -1702,7 +1702,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // initialization state of `a.b` is all we need to inspect to\n         // know if `a.b.c` is valid (and from that we infer that the\n         // dereference and `.d` access is also valid, since we assume\n-        // `a.b.c` is assigned a reference to a initialized and\n+        // `a.b.c` is assigned a reference to an initialized and\n         // well-formed record structure.)\n \n         // Therefore, if we seek out the *closest* prefix for which we\n@@ -1889,7 +1889,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n                 // assigning to (P->variant) is okay if assigning to `P` is okay\n                 //\n-                // FIXME: is this true even if P is a adt with a dtor?\n+                // FIXME: is this true even if P is an adt with a dtor?\n                 { }\n \n                 // assigning to (*P) requires P to be initialized\n@@ -2003,8 +2003,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if let Some((prefix, mpi)) = shortest_uninit_seen {\n-                // Check for a reassignment into a uninitialized field of a union (for example,\n-                // after a move out). In this case, do not report a error here. There is an\n+                // Check for a reassignment into an uninitialized field of a union (for example,\n+                // after a move out). In this case, do not report an error here. There is an\n                 // exception, if this is the first assignment into the union (that is, there is\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case."}, {"sha": "3c9b4272b36497dc3fe826d9986e2c182ba2c5b1", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -169,7 +169,7 @@ struct UniversalRegionIndices<'tcx> {\n     /// used because trait matching and type-checking will feed us\n     /// region constraints that reference those regions and we need to\n     /// be able to map them our internal `RegionVid`. This is\n-    /// basically equivalent to a `InternalSubsts`, except that it also\n+    /// basically equivalent to an `InternalSubsts`, except that it also\n     /// contains an entry for `ReStatic` -- it might be nice to just\n     /// use a substs, and then handle `ReStatic` another way.\n     indices: FxHashMap<ty::Region<'tcx>, RegionVid>,"}, {"sha": "81f78621d1458520d90aa98b906da2125f77776d", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -295,7 +295,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// we can find the data.\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n-    /// in a `Immediate`, not on which data is stored there currently.\n+    /// in an `Immediate`, not on which data is stored there currently.\n     pub(crate) fn try_read_immediate(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,"}, {"sha": "b0cd6405eb9014f2c8cfc3bc085a8be13cd64db2", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -857,7 +857,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // types above, in `visit_primitive`.\n                 // In run-time mode, we accept pointers in here.  This is actually more\n                 // permissive than a per-element check would be, e.g., we accept\n-                // an &[u8] that contains a pointer even though bytewise checking would\n+                // a &[u8] that contains a pointer even though bytewise checking would\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer."}, {"sha": "a559a6ce415a3b8d8aae04c07e46c8b25ab9d782", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -455,7 +455,7 @@ fn mono_item_visibility(\n         def_id\n     } else {\n         return if export_generics && is_generic {\n-            // If it is a upstream monomorphization and we export generics, we must make\n+            // If it is an upstream monomorphization and we export generics, we must make\n             // it available to downstream crates.\n             *can_be_internalized = false;\n             default_visibility(tcx, def_id, true)"}, {"sha": "8923d989b2944a63796842d5e1f6cbddf2e60e26", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -86,7 +86,7 @@ impl NonConstOp for FnCallNonConst {\n     }\n }\n \n-/// A call to a `#[unstable]` const fn or `#[rustc_const_unstable]` function.\n+/// A call to an `#[unstable]` const fn or `#[rustc_const_unstable]` function.\n ///\n /// Contains the name of the feature that would allow the use of this function.\n #[derive(Debug)]"}, {"sha": "4578f04c0345260a053bae3edef5a20f2de929a0", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n-        // That would require an uniform one-def no-mutation analysis\n+        // That would require a uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = ConstPropagator::new(body, dummy_body, tcx);\n         optimization_finder.visit_body(body);"}, {"sha": "6726b669ff2aae96ac90176a2593239ac6bcf430", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -100,7 +100,7 @@ impl CoverageCounters {\n         CounterValueReference::from(next)\n     }\n \n-    /// Expression IDs start from u32::MAX and go down because a Expression can reference\n+    /// Expression IDs start from u32::MAX and go down because an Expression can reference\n     /// (add or subtract counts) of both Counter regions and Expression regions. The counter\n     /// expression operand IDs must be unique across both types.\n     fn next_expression(&mut self) -> InjectedExpressionId {"}, {"sha": "f7fbea6ad53711a5c82b3937a8e57221634ee553", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     /// process (via `take_counter()`).\n     ///\n     /// Any other counter associated with a `BasicCoverageBlock`, or its incoming edge, but not\n-    /// associated with a `CoverageSpan`, should only exist if the counter is a `Expression`\n+    /// associated with a `CoverageSpan`, should only exist if the counter is an `Expression`\n     /// dependency (one of the expression operands). Collect them, and inject the additional\n     /// counters into the MIR, without a reportable coverage span.\n     fn inject_indirect_counters("}, {"sha": "f4a1b0ddba53f2a3ecbf4db1c0e998d4afdd9cf6", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -88,11 +88,11 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n /// For each such call, determines what the dataflow bit-state is for\n /// the L-value corresponding to `expr`; if the bit-state is a 1, then\n /// that call to `rustc_peek` is ignored by the sanity check. If the\n-/// bit-state is a 0, then this pass emits a error message saying\n+/// bit-state is a 0, then this pass emits an error message saying\n /// \"rustc_peek: bit not set\".\n ///\n /// The intention is that one can write unit tests for dataflow by\n-/// putting code into an UI test and using `rustc_peek` to\n+/// putting code into a UI test and using `rustc_peek` to\n /// make observations about the results of dataflow static analyses.\n ///\n /// (If there are any calls to `rustc_peek` that do not match the"}, {"sha": "21c5a64f82337f0482c02c47ee60fca11f870d95", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     unpack!(this.expr_into_dest(destination, else_blk, &this.thir[else_opt]))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n-                    // we implicitly generate a `else {}` if it is not specified.\n+                    // we implicitly generate an `else {}` if it is not specified.\n                     let correct_si = this.source_info(expr_span.shrink_to_hi());\n                     this.cfg.push_assign_unit(else_blk, correct_si, destination, this.tcx);\n                     else_blk\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                     this.diverge_from(loop_block);\n \n-                    // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n+                    // The \u201creturn\u201d value of the loop body must always be a unit. We therefore\n                     // introduce a unit temporary as the destination for the loop body.\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test."}, {"sha": "a36af024ad8d0e92f52c84f8234ee3ebe09f6b51", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1936,7 +1936,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // }\n             // ```\n             //\n-            // would yield a `arm_block` something like:\n+            // would yield an `arm_block` something like:\n             //\n             // ```\n             // StorageLive(_4);        // _4 is `x`"}, {"sha": "bfebe860971e9f8e28e6973c503e8a3d83357140", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -700,7 +700,7 @@ fn construct_const<'a, 'tcx>(\n     builder.finish()\n }\n \n-/// Construct MIR for a item that has had errors in type checking.\n+/// Construct MIR for an item that has had errors in type checking.\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let tcx_hir = tcx.hir();\n         let hir_typeck_results = self.typeck_results;\n \n-        // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n+        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n         // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar"}, {"sha": "f1d882e1ddd7055d06e7b3e45aa99536e16620ab", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -788,7 +788,7 @@ impl<'tcx> Cx<'tcx> {\n                 self.user_substs_applied_to_ty_of_hir_id(hir_id)\n             }\n \n-            // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n+            // `Self` is used in expression as a tuple struct constructor or a unit struct constructor\n             Res::SelfCtor(_) => self.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n             _ => bug!(\"user_substs_applied_to_res: unexpected res {:?} at {:?}\", res, hir_id),"}, {"sha": "344006e9fb4c902af74703640f3b0036b968db12", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -762,7 +762,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n                     for i in 0..*alt_count {\n                         let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n                         if sub_set.is_empty() {\n-                            // Found a unreachable subpattern.\n+                            // Found an unreachable subpattern.\n                             spans.push(expanded[i].span);\n                         } else {\n                             fill_spans(sub_set, spans);"}, {"sha": "9f06bdcc135ba3d626d97fb418ffd18df84e859c", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -301,7 +301,7 @@ impl<'a> Parser<'a> {\n         // If we 'broke' the last token (e.g. breaking a '>>' token to two '>' tokens),\n         // then extend the range of captured tokens to include it, since the parser\n         // was not actually bumped past it. When the `LazyTokenStream` gets converted\n-        // into a `AttrAnnotatedTokenStream`, we will create the proper token.\n+        // into an `AttrAnnotatedTokenStream`, we will create the proper token.\n         if self.token_cursor.break_last_token {\n             assert_eq!(\n                 trailing,\n@@ -320,7 +320,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Grab any replace ranges that occur *inside* the current AST node.\n             // We will perform the actual replacement when we convert the `LazyTokenStream`\n-            // to a `AttrAnnotatedTokenStream`\n+            // to an `AttrAnnotatedTokenStream`\n             let start_calls: u32 = cursor_snapshot_next_calls.try_into().unwrap();\n             self.capture_state.replace_ranges[replace_ranges_start..replace_ranges_end]\n                 .iter()\n@@ -486,7 +486,7 @@ fn make_token_stream(\n         if let AttrAnnotatedTokenTree::Token(last_token) = last_token {\n             let unglued_first = last_token.kind.break_two_token_op().unwrap().0;\n \n-            // A 'unglued' token is always two ASCII characters\n+            // An 'unglued' token is always two ASCII characters\n             let mut first_span = last_token.span.shrink_to_lo();\n             first_span = first_span.with_hi(first_span.lo() + rustc_span::BytePos(1));\n "}, {"sha": "326c8f81ffbf9f64973bfbddaa7c3efadcbc17a0", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1092,7 +1092,7 @@ impl<'a> Parser<'a> {\n         // added to the return value after the fact.\n         //\n         // Therefore, prevent sub-parser from parsing\n-        // attributes by giving them a empty \"already-parsed\" list.\n+        // attributes by giving them an empty \"already-parsed\" list.\n         let attrs = AttrVec::new();\n \n         // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`."}, {"sha": "4c3c140d17100a8fd00d6107d296ea7b5feb1571", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -152,7 +152,7 @@ pub struct Parser<'a> {\n /// attribute, we parse a nested AST node that has `#[cfg]` or `#[cfg_attr]`\n /// In this case, we use a `ReplaceRange` to replace the entire inner AST node\n /// with `FlatToken::AttrTarget`, allowing us to perform eager cfg-expansion\n-/// on a `AttrAnnotatedTokenStream`\n+/// on an `AttrAnnotatedTokenStream`\n ///\n /// 2. When we parse an inner attribute while collecting tokens. We\n /// remove inner attributes from the token stream entirely, and\n@@ -165,7 +165,7 @@ pub type ReplaceRange = (Range<u32>, Vec<(FlatToken, Spacing)>);\n \n /// Controls how we capture tokens. Capturing can be expensive,\n /// so we try to avoid performing capturing in cases where\n-/// we will never need a `AttrAnnotatedTokenStream`\n+/// we will never need an `AttrAnnotatedTokenStream`\n #[derive(Copy, Clone)]\n pub enum Capturing {\n     /// We aren't performing any capturing - this is the default mode.\n@@ -1362,10 +1362,10 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     }\n }\n \n-/// A helper struct used when building a `AttrAnnotatedTokenStream` from\n+/// A helper struct used when building an `AttrAnnotatedTokenStream` from\n /// a `LazyTokenStream`. Both delimiter and non-delimited tokens\n /// are stored as `FlatToken::Token`. A vector of `FlatToken`s\n-/// is then 'parsed' to build up a `AttrAnnotatedTokenStream` with nested\n+/// is then 'parsed' to build up an `AttrAnnotatedTokenStream` with nested\n /// `AttrAnnotatedTokenTree::Delimited` tokens\n #[derive(Debug, Clone)]\n pub enum FlatToken {\n@@ -1375,10 +1375,10 @@ pub enum FlatToken {\n     /// Holds the `AttributesData` for an AST node. The\n     /// `AttributesData` is inserted directly into the\n     /// constructed `AttrAnnotatedTokenStream` as\n-    /// a `AttrAnnotatedTokenTree::Attributes`\n+    /// an `AttrAnnotatedTokenTree::Attributes`\n     AttrTarget(AttributesData),\n     /// A special 'empty' token that is ignored during the conversion\n-    /// to a `AttrAnnotatedTokenStream`. This is used to simplify the\n+    /// to an `AttrAnnotatedTokenStream`. This is used to simplify the\n     /// handling of replace ranges.\n     Empty,\n }"}, {"sha": "281995c3755491844e64c695f7d864ba7e254450", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -575,7 +575,7 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n-    /// Given the path segments of a `ItemKind::Use`, then we need\n+    /// Given the path segments of an `ItemKind::Use`, then we need\n     /// to update the visibility of the intermediate use so that it isn't linted\n     /// by `unreachable_pub`.\n     ///"}, {"sha": "ca2c22854c4f5d1bd9d2c9eaaaa76f79471b2456", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -956,9 +956,61 @@ impl<'a> Resolver<'a> {\n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n             err.span_note(ident.span, &msg);\n+            return;\n         }\n         if self.macro_names.contains(&ident.normalize_to_macros_2_0()) {\n             err.help(\"have you added the `#[macro_use]` on the module/import?\");\n+            return;\n+        }\n+        for ns in [Namespace::MacroNS, Namespace::TypeNS, Namespace::ValueNS] {\n+            if let Ok(binding) = self.early_resolve_ident_in_lexical_scope(\n+                ident,\n+                ScopeSet::All(ns, false),\n+                &parent_scope,\n+                false,\n+                false,\n+                ident.span,\n+            ) {\n+                let desc = match binding.res() {\n+                    Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n+                        \"a function-like macro\".to_string()\n+                    }\n+                    Res::Def(DefKind::Macro(MacroKind::Attr), _) | Res::NonMacroAttr(..) => {\n+                        format!(\"an attribute: `#[{}]`\", ident)\n+                    }\n+                    Res::Def(DefKind::Macro(MacroKind::Derive), _) => {\n+                        format!(\"a derive macro: `#[derive({})]`\", ident)\n+                    }\n+                    Res::ToolMod => {\n+                        // Don't confuse the user with tool modules.\n+                        continue;\n+                    }\n+                    Res::Def(DefKind::Trait, _) if macro_kind == MacroKind::Derive => {\n+                        \"only a trait, without a derive macro\".to_string()\n+                    }\n+                    res => format!(\n+                        \"{} {}, not {} {}\",\n+                        res.article(),\n+                        res.descr(),\n+                        macro_kind.article(),\n+                        macro_kind.descr_expected(),\n+                    ),\n+                };\n+                if let crate::NameBindingKind::Import { import, .. } = binding.kind {\n+                    if !import.span.is_dummy() {\n+                        err.span_note(\n+                            import.span,\n+                            &format!(\"`{}` is imported here, but it is {}\", ident, desc),\n+                        );\n+                        // Silence the 'unused import' warning we might get,\n+                        // since this diagnostic already covers that import.\n+                        self.record_use(ident, binding, false);\n+                        return;\n+                    }\n+                }\n+                err.note(&format!(\"`{}` is in scope, but it is {}\", ident, desc));\n+                return;\n+            }\n         }\n     }\n "}, {"sha": "9d923599db7619608399a4299bfcae000b073579", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1826,7 +1826,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err.emit();\n     }\n \n-    // FIXME(const_generics): This patches over a ICE caused by non-'static lifetimes in const\n+    // FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n     // generics. We are disallowing this until we can decide on how we want to handle non-'static\n     // lifetimes in const generics. See issue #74052 for discussion.\n     crate fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &hir::Lifetime) {"}, {"sha": "18475444f6831d6f591cf2e50d41d8a85ca66ffe", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -668,7 +668,7 @@ enum NameBindingKind<'a> {\n }\n \n impl<'a> NameBindingKind<'a> {\n-    /// Is this a name binding of a import?\n+    /// Is this a name binding of an import?\n     fn is_import(&self) -> bool {\n         matches!(*self, NameBindingKind::Import { .. })\n     }\n@@ -3065,7 +3065,7 @@ impl<'a> Resolver<'a> {\n             self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n         // Only suggest removing an import if both bindings are to the same def, if both spans\n         // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n-        // been introduced by a item.\n+        // been introduced by an item.\n         let should_remove_import = duplicate\n             && !has_dummy_span\n             && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n@@ -3160,7 +3160,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// This function adds a suggestion to remove a unnecessary binding from an import that is\n+    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n     /// nested. In the following example, this function will be invoked to remove the `a` binding\n     /// in the second use statement:\n     ///\n@@ -3212,7 +3212,7 @@ impl<'a> Resolver<'a> {\n                     Applicability::MaybeIncorrect,\n                 );\n             } else {\n-                // Remove the entire line if we cannot extend the span back, this indicates a\n+                // Remove the entire line if we cannot extend the span back, this indicates an\n                 // `issue_52891::{self}` case.\n                 err.span_suggestion(\n                     import.use_span_with_attributes,"}, {"sha": "e5369b4bbfdeafc494ad5b1d796a7925341304dc", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1202,7 +1202,7 @@ impl Json {\n         matches!(*self, Json::I64(_) | Json::U64(_) | Json::F64(_))\n     }\n \n-    /// Returns `true` if the Json value is a `i64`.\n+    /// Returns `true` if the Json value is an `i64`.\n     pub fn is_i64(&self) -> bool {\n         matches!(*self, Json::I64(_))\n     }\n@@ -1217,7 +1217,7 @@ impl Json {\n         matches!(*self, Json::F64(_))\n     }\n \n-    /// If the Json value is a number, returns or cast it to a `i64`;\n+    /// If the Json value is a number, returns or cast it to an `i64`;\n     /// returns `None` otherwise.\n     pub fn as_i64(&self) -> Option<i64> {\n         match *self {"}, {"sha": "ecc8dae04800a3a44dd7c031e8804e238d0ca61f", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -644,7 +644,7 @@ impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n }\n \n // FIXME: #15036\n-// Should use `try_borrow`, returning a\n+// Should use `try_borrow`, returning an\n // `encoder.error(\"attempting to Encode borrowed RefCell\")`\n // from `encode` when `try_borrow` returns `None`.\n "}, {"sha": "f36fc29e9741716ef351f63212da8f15a302771a", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1287,7 +1287,7 @@ options! {\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     thir_unsafeck: bool = (false, parse_bool, [TRACKED],\n-        \"use the work-in-progress THIR unsafety checker. NOTE: this is unsound (default: no)\"),\n+        \"use the THIR unsafety checker (default: no)\"),\n     /// We default to 1 here since we want to behave like\n     /// a sequential compiler for now. This'll likely be adjusted\n     /// in the future. Note that -Zthreads=0 is the way to get"}, {"sha": "f700397fcdf0d28e220ec917a851500f1f87ffc1", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -100,7 +100,7 @@ pub trait FileLoader {\n     /// Query the existence of a file.\n     fn file_exists(&self, path: &Path) -> bool;\n \n-    /// Read the contents of an UTF-8 file into memory.\n+    /// Read the contents of a UTF-8 file into memory.\n     fn read_file(&self, path: &Path) -> io::Result<String>;\n }\n "}, {"sha": "bb24f7bb135ef0b22e9cac3eb2353fbdd42a8c65", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -469,7 +469,7 @@ impl InlineAsmRegClass {\n         }\n     }\n \n-    /// Returns a list of supported types for this register class, each with a\n+    /// Returns a list of supported types for this register class, each with an\n     /// options target feature required to use this type.\n     pub fn supported_types(\n         self,"}, {"sha": "c5a6e301deba96c1d835da9e9d63d54116097411", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ///     ?0: Iterator<Item = ?1>\n     ///     ?1: Debug\n     ///\n-    /// Moreover, it returns a `OpaqueTypeMap` that would map `?0` to\n+    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n     /// info about the `impl Iterator<..>` type and `?1` to info about\n     /// the `impl Debug` type.\n     ///\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     //\n-                    // Here, the return type of `foo` references a\n+                    // Here, the return type of `foo` references an\n                     // `Opaque` indeed, but not one whose value is\n                     // presently being inferred. You can get into a\n                     // similar situation with closure return types"}, {"sha": "f06f0e32f414b73f90e35192996ba41ba780fcb3", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::ErrorReported;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n \n-/// Attempts to resolve an obligation to a `ImplSource`. The result is\n+/// Attempts to resolve an obligation to an `ImplSource`. The result is\n /// a shallow `ImplSource` resolution, meaning that we do not\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested"}, {"sha": "90b6ee5f5a6a670b39e27a4251343e578cdff971", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -2009,7 +2009,7 @@ pub enum ArgKind {\n     Arg(String, String),\n \n     /// An argument of tuple type. For a \"found\" argument, the span is\n-    /// the location in the source of the pattern. For a \"expected\"\n+    /// the location in the source of the pattern. For an \"expected\"\n     /// argument, it will be None. The vector is a list of (name, ty)\n     /// strings for the components of the tuple.\n     Tuple(Option<Span>, Vec<(String, String)>),"}, {"sha": "40841a6e32d00e2cc97db003a445b919873e426c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1365,7 +1365,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // When a future does not implement a trait because of a captured type in one of the\n         // generators somewhere in the call stack, then the result is a chain of obligations.\n         //\n-        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // Given an `async fn` A that calls an `async fn` B which captures a non-send type and that\n         // future is passed as an argument to a function C which requires a `Send` type, then the\n         // chain looks something like this:\n         //"}, {"sha": "19e3c1afb9fb6691ed50ff634692b8cf4ff6261c", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -62,7 +62,7 @@ enum ProjectionTyCandidate<'tcx> {\n     /// Bounds specified on an object type\n     Object(ty::PolyProjectionPredicate<'tcx>),\n \n-    /// From a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    /// From an \"impl\" (or a \"pseudo-impl\" returned by select)\n     Select(Selection<'tcx>),\n }\n \n@@ -1011,7 +1011,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n /// Note that we used to return `Error` here, but that was quite\n /// dubious -- the premise was that an error would *eventually* be\n /// reported, when the obligation was processed. But in general once\n-/// you see a `Error` you are supposed to be able to assume that an\n+/// you see an `Error` you are supposed to be able to assume that an\n /// error *has been* reported, so that you can take whatever heuristic\n /// paths you want to take. To make things worse, it was possible for\n /// cycles to arise, where you basically had a setup like `<MyType<$0>"}, {"sha": "03087e3353a6e918261ad1a73d6c5eb25b27ee27", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         // FIXME this `unchecked_map` is only necessary because the\n         // query is defined as taking a `ParamEnvAnd<Ty>`; it should\n-        // take a `ImpliedOutlivesBounds` instead\n+        // take an `ImpliedOutlivesBounds` instead\n         let canonicalized = canonicalized.unchecked_map(|ParamEnvAnd { param_env, value }| {\n             let ImpliedOutlivesBounds { ty } = value;\n             param_env.and(ty)"}, {"sha": "ba62ce1d5312ebfa5d61b75cb1000b741069d049", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -257,7 +257,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ImplSourceBuiltinData { nested: obligations }\n     }\n \n-    /// This handles the case where a `auto trait Foo` impl is being used.\n+    /// This handles the case where an `auto trait Foo` impl is being used.\n     /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n     ///\n     /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds"}, {"sha": "88aca794a6be6971ea4d7bfcb2b1bfb431fe5393", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -149,7 +149,7 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n     let penv = tcx.param_env(impl1_def_id);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n-    // Create a infcx, taking the predicates of impl1 as assumptions:\n+    // Create an infcx, taking the predicates of impl1 as assumptions:\n     tcx.infer_ctxt().enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds."}, {"sha": "1d457d6761fd084c1e0c7bab1c98ba5f0746921b", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -718,7 +718,7 @@ impl<'tcx> chalk_ir::UnificationDatabase<RustInterner<'tcx>> for RustIrDatabase<\n     }\n }\n \n-/// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n+/// Creates an `InternalSubsts` that maps each generic parameter to a higher-ranked\n /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n /// the type parameter index. For regions, we use the `BoundRegionKind::BrNamed`\n /// variant (which has a `DefId`)."}, {"sha": "8332e7384110e032635faf27466a439ad986f972", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -185,7 +185,7 @@ fn impl_constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n ///       such.\n-///     - a Error, if a type contained itself. The representability\n+///     - an Error, if a type contained itself. The representability\n ///       check should catch this case.\n fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstraint<'_> {\n     let def = tcx.adt_def(def_id);\n@@ -253,7 +253,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n     // report these errors right here; this doesn't actually feel\n     // right to me, because constructing the environment feels like a\n-    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // kind of an \"idempotent\" action, but I'm not sure where would be\n     // a better place. In practice, we construct environments for\n     // every fn once during type checking, and we'll abort if there\n     // are any errors at that point, so after type checking you can be"}, {"sha": "7d7d69b40798f8424866f1747da5db9bb3804316", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -2350,7 +2350,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Infer => {\n                 // Infer also appears as the type of arguments or return\n-                // values in a ExprKind::Closure, or as\n+                // values in an ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)"}, {"sha": "65ba1c08b6243fa36c1b751cdc19f62253a37a23", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -617,7 +617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n-    /// user specified. The \"desugared\" return type is a `impl\n+    /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n     fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {"}, {"sha": "f9b7bb8ea9915c0138c8724b47d01f478eb8a0b1", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -743,7 +743,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // possibly be referring to the current closure,\n                     // because we haven't produced the `Closure` for\n                     // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of a unresolved\n+                    // code is looking for a self type of an unresolved\n                     // inference variable.\n                     ty::PredicateKind::ClosureKind(..) => None,\n                     ty::PredicateKind::TypeWellFormedFromEnv(..) => None,"}, {"sha": "16f3de58078ac1c4c747221652990eb68d103dd7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -96,7 +96,7 @@ pub struct FnCtxt<'a, 'tcx> {\n     ///   `foo(return)`; we warn on the `foo()` expression. (We then\n     ///   update the flag to `WarnedAlways` to suppress duplicate\n     ///   reports.) Similarly, if we traverse to a fresh statement (or\n-    ///   tail expression) from a `Always` setting, we will issue a\n+    ///   tail expression) from an `Always` setting, we will issue a\n     ///   warning. This corresponds to something like `{return;\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`."}, {"sha": "fc7f55e24b2f3dbc603e96f67a19e3f184ecc7e8", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1456,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // an immut-ref after on top of this.\n                 ty::Ref(.., hir::Mutability::Mut) => is_mutbl = hir::Mutability::Mut,\n \n-                // The place isn't mutable once we dereference a immutable reference.\n+                // The place isn't mutable once we dereference an immutable reference.\n                 ty::Ref(.., hir::Mutability::Not) => return hir::Mutability::Not,\n \n                 // Dereferencing a box doesn't change mutability"}, {"sha": "95d3bb1172305b391992e1b32b9364938e2a4ed2", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -155,7 +155,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         }\n \n         // If the extern crate isn't in the extern prelude,\n-        // there is no way it can be written as an `use`.\n+        // there is no way it can be written as a `use`.\n         let orig_name = extern_crate.orig_name.unwrap_or(item.ident.name);\n         if !extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n             continue;"}, {"sha": "77834feb9ad55eef02afaf16747839f6a1114c2e", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -819,7 +819,7 @@ fn copy_or_move<'a, 'tcx>(\n }\n \n // - If a place is used in a `ByValue` context then move it if it's not a `Copy` type.\n-// - If the place that is a `Copy` type consider it a `ImmBorrow`.\n+// - If the place that is a `Copy` type consider it an `ImmBorrow`.\n fn delegate_consume<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     delegate: &mut (dyn Delegate<'tcx> + 'a),"}, {"sha": "ccf0fb7273837b57577ee97fe91f677e4557aab2", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -297,7 +297,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // to apply the substs, and not filter this predicate, we might then falsely\n         // conclude that e.g., `X: 'x` was a reasonable inferred requirement.\n         //\n-        // Another similar case is where we have a inferred\n+        // Another similar case is where we have an inferred\n         // requirement like `<Self as Trait>::Foo: 'b`. We presently\n         // ignore such requirements as well (cc #54467)-- though\n         // conceivably it might be better if we could extract the `Foo"}, {"sha": "3ed3c2382cac69193a07129fa91d9b6e2a9981f3", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -387,7 +387,7 @@ pub mod __alloc_error_handler {\n         panic!(\"memory allocation of {} bytes failed\", size)\n     }\n \n-    // if there is a `#[alloc_error_handler]`\n+    // if there is an `#[alloc_error_handler]`\n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rg_oom(size: usize, align: usize) -> ! {\n         let layout = unsafe { Layout::from_size_align_unchecked(size, align) };"}, {"sha": "28e4f8bba05c8d5272e477f98ad4a00e57f5d3fd", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -46,7 +46,7 @@\n //!     }\n //! }\n //!\n-//! // Each node is represented as an `usize`, for a shorter implementation.\n+//! // Each node is represented as a `usize`, for a shorter implementation.\n //! struct Edge {\n //!     node: usize,\n //!     cost: usize,"}, {"sha": "77c52e51abb2e2b149538199f5d53033ecfc441f", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -45,7 +45,7 @@ impl<T, const N: usize> IntoIter<T, N> {\n     /// use std::array;\n     ///\n     /// for value in array::IntoIter::new([1, 2, 3, 4, 5]) {\n-    ///     // The type of `value` is a `i32` here, instead of `&i32`\n+    ///     // The type of `value` is an `i32` here, instead of `&i32`\n     ///     let _: i32 = value;\n     /// }\n     /// ```"}, {"sha": "0dadbdd1bd0543e4c08423b91c59363f8e777f7b", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -958,7 +958,7 @@ impl char {\n     /// Returns an iterator that yields the uppercase mapping of this `char` as one or more\n     /// `char`s.\n     ///\n-    /// If this `char` does not have a uppercase mapping, the iterator yields the same `char`.\n+    /// If this `char` does not have an uppercase mapping, the iterator yields the same `char`.\n     ///\n     /// If this `char` has a one-to-one uppercase mapping given by the [Unicode Character\n     /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`."}, {"sha": "9278dbb54989383e561e849a53fa0ef7938d0fa3", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1013,7 +1013,7 @@ extern \"rust-intrinsic\" {\n     /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n     /// ```\n     ///\n-    /// Turning an `&str` into an `&[u8]`:\n+    /// Turning an `&str` into a `&[u8]`:\n     ///\n     /// ```\n     /// // this is not a good way to do this."}, {"sha": "17697fa0e045a28cc5256cab47d4bb4e4cebf616", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -563,7 +563,7 @@ where\n }\n \n unsafe trait SpecTrustedRandomAccess: Iterator {\n-    /// If `Self: TrustedRandomAccess`, it must be safe to call a\n+    /// If `Self: TrustedRandomAccess`, it must be safe to call\n     /// `Iterator::__iterator_get_unchecked(self, index)`.\n     unsafe fn try_get_unchecked(&mut self, index: usize) -> Self::Item;\n }"}, {"sha": "844459d77cd9661691bfc19ad944131b39f6ac3a", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -25,7 +25,7 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// (lower bound is equal to upper bound), or the upper bound is [`None`].\n /// The upper bound must only be [`None`] if the actual iterator length is\n /// larger than [`usize::MAX`]. In that case, the lower bound must be\n-/// [`usize::MAX`], resulting in a [`Iterator::size_hint()`] of\n+/// [`usize::MAX`], resulting in an [`Iterator::size_hint()`] of\n /// `(usize::MAX, None)`.\n ///\n /// The iterator must produce exactly the number of elements it reported"}, {"sha": "84fd1a532c1aa300af2d3ada59394f0468f2abb7", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -660,7 +660,7 @@ pub unsafe fn zeroed<T>() -> T {\n #[rustc_diagnostic_item = \"mem_uninitialized\"]\n #[track_caller]\n pub unsafe fn uninitialized<T>() -> T {\n-    // SAFETY: the caller must guarantee that an unitialized value is valid for `T`.\n+    // SAFETY: the caller must guarantee that an uninitialized value is valid for `T`.\n     unsafe {\n         intrinsics::assert_uninit_valid::<T>();\n         MaybeUninit::uninit().assume_init()"}, {"sha": "75405f471541825b9e4b5f976e3a120d10866d79", "filename": "library/core/src/num/dec2flt/lemire.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -9,7 +9,7 @@ use crate::num::dec2flt::table::{\n /// Compute a float using an extended-precision representation.\n ///\n /// Fast conversion of a the significant digits and decimal exponent\n-/// a float to a extended representation with a binary float. This\n+/// a float to an extended representation with a binary float. This\n /// algorithm will accurately parse the vast majority of cases,\n /// and uses a 128-bit representation (with a fallback 192-bit\n /// representation)."}, {"sha": "02c9dadc0868dcb5067124963c8d3d8f5f760d31", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -767,7 +767,7 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///\n /// # Examples\n ///\n-/// Read an usize value from a byte buffer:\n+/// Read a usize value from a byte buffer:\n ///\n /// ```\n /// use std::mem;\n@@ -960,7 +960,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// # Examples\n ///\n-/// Write an usize value to a byte buffer:\n+/// Write a usize value to a byte buffer:\n ///\n /// ```\n /// use std::mem;\n@@ -1232,7 +1232,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let smoda = stride & a_minus_one;\n     // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n     let gcdpow = unsafe { intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a)) };\n-    // SAFETY: gcdpow has an upper-bound that\u2019s at most the number of bits in an usize.\n+    // SAFETY: gcdpow has an upper-bound that\u2019s at most the number of bits in a usize.\n     let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n \n     // SAFETY: gcd is always greater or equal to 1."}, {"sha": "243922b18b565dfd0a5b55fdf944f04d9f7aa555", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -262,7 +262,7 @@ pub mod token_stream {\n }\n \n /// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n-/// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n+/// For example, `quote!(a + b)` will produce an expression, that, when evaluated, constructs\n /// the `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`.\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term."}, {"sha": "36077a42b48ac9a49d8f5acd30e0b4c3ef5bcb46", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1247,7 +1247,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n }\n \n impl<'a, K, V> IterMut<'a, K, V> {\n-    /// Returns a iterator of references over the remaining items.\n+    /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.rustc_iter() }\n@@ -1276,7 +1276,7 @@ pub struct IntoIter<K, V> {\n }\n \n impl<K, V> IntoIter<K, V> {\n-    /// Returns a iterator of references over the remaining items.\n+    /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.rustc_iter() }\n@@ -1379,7 +1379,7 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n impl<'a, K, V> Drain<'a, K, V> {\n-    /// Returns a iterator of references over the remaining items.\n+    /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.rustc_iter() }"}, {"sha": "0d082648591cef1986dc3041c804aae4ebbd2633", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -46,7 +46,7 @@ use crate::sys_common::memchr;\n ///\n /// # Extracting a raw pointer to the whole C string\n ///\n-/// `CString` implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n+/// `CString` implements an [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n /// trait. This method will give you a `*const c_char` which you can\n /// feed directly to extern functions that expect a nul-terminated\n /// string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n@@ -730,7 +730,7 @@ impl CString {\n     /// );\n     /// ```\n     ///\n-    /// A incorrectly formatted [`Vec`] will produce an error.\n+    /// An incorrectly formatted [`Vec`] will produce an error.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -939,7 +939,7 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n-    /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n+    /// Converts a [`CString`] into an [`Arc`]`<CStr>` without copying or allocating.\n     #[inline]\n     fn from(s: CString) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.into_inner());"}, {"sha": "fe4e3af91ad0a6df1a738570ac6a33561a72bb56", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -94,7 +94,7 @@\n //!\n //! * [`OsStr`] represents a borrowed reference to a string in a\n //! format that can be passed to the operating system. It can be\n-//! converted into an UTF-8 Rust string slice in a similar way to\n+//! converted into a UTF-8 Rust string slice in a similar way to\n //! [`OsString`].\n //!\n //! # Conversions"}, {"sha": "f05295f89af1f03997ad8e0491ba151ca22ecd4a", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -359,7 +359,7 @@ impl OsString {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<String> for OsString {\n-    /// Converts a [`String`] into a [`OsString`].\n+    /// Converts a [`String`] into an [`OsString`].\n     ///\n     /// This conversion does not allocate or copy memory.\n     #[inline]\n@@ -880,7 +880,7 @@ impl From<Box<OsStr>> for OsString {\n \n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n-    /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n@@ -897,7 +897,7 @@ impl Clone for Box<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n-    /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into an [`Arc`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -916,7 +916,7 @@ impl From<&OsStr> for Arc<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n-    /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "28254fea0d374209395981ea877ecf9339418285", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1150,7 +1150,7 @@ impl<'a> DerefMut for IoSliceMut<'a> {\n \n /// A buffer type used with `Write::write_vectored`.\n ///\n-/// It is semantically a wrapper around an `&[u8]`, but is guaranteed to be\n+/// It is semantically a wrapper around a `&[u8]`, but is guaranteed to be\n /// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n /// Windows.\n #[stable(feature = \"iovec\", since = \"1.36.0\")]"}, {"sha": "749a441d1826361e7c8b324c43db468659726d25", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -2289,7 +2289,7 @@ mod dyn_keyword {}\n /// }\n ///\n /// let mut u = IntOrFloat { f: 1.0 };\n-/// // Reading the fields of an union is always unsafe\n+/// // Reading the fields of a union is always unsafe\n /// assert_eq!(unsafe { u.i }, 1065353216);\n /// // Updating through any of the field will modify all of them\n /// u.i = 1073741824;"}, {"sha": "43d930677fad3d53e41712f6844bf9b19d54f49c", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -561,8 +561,8 @@ impl From<SocketAddrV6> for SocketAddr {\n impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n     /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n     ///\n-    /// This conversion creates a [`SocketAddr::V4`] for a [`IpAddr::V4`]\n-    /// and creates a [`SocketAddr::V6`] for a [`IpAddr::V6`].\n+    /// This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`]\n+    /// and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].\n     ///\n     /// `u16` is treated as port of the newly created [`SocketAddr`].\n     fn from(pieces: (I, u16)) -> SocketAddr {"}, {"sha": "4165a7beaa8f260bf56535284e24551021852953", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -380,7 +380,7 @@ impl IpAddr {\n         matches!(self, IpAddr::V6(_))\n     }\n \n-    /// Converts this address to an `IpAddr::V4` if it is a IPv4-mapped IPv6 addresses, otherwise it\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it\n     /// return `self` as-is.\n     ///\n     /// # Examples\n@@ -1621,8 +1621,8 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Converts this address to an `IpAddr::V4` if it is a IPv4-mapped addresses, otherwise it\n-    /// returns self wrapped in a `IpAddr::V6`.\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it\n+    /// returns self wrapped in an `IpAddr::V6`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1f9d42812ecc78177fe2c6da52cd998f9031cbc0", "filename": "library/std/src/os/unix/net/ancillary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -279,7 +279,7 @@ pub enum AncillaryData<'a> {\n }\n \n impl<'a> AncillaryData<'a> {\n-    /// Create a `AncillaryData::ScmRights` variant.\n+    /// Create an `AncillaryData::ScmRights` variant.\n     ///\n     /// # Safety\n     ///\n@@ -291,7 +291,7 @@ impl<'a> AncillaryData<'a> {\n         AncillaryData::ScmRights(scm_rights)\n     }\n \n-    /// Create a `AncillaryData::ScmCredentials` variant.\n+    /// Create an `AncillaryData::ScmCredentials` variant.\n     ///\n     /// # Safety\n     ///"}, {"sha": "8d29fa7d66f995db0c4cdbd8142b0400516bb705", "filename": "library/std/src/os/windows/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fffi.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -30,7 +30,7 @@\n //! [`OsString`] is the Rust wrapper for owned strings in the\n //! preferred representation of the operating system. On Windows,\n //! this struct gets augmented with an implementation of the\n-//! [`OsStringExt`] trait, which has a [`OsStringExt::from_wide`] method. This\n+//! [`OsStringExt`] trait, which has an [`OsStringExt::from_wide`] method. This\n //! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n //! you get such a slice out of a `WCHAR` Windows API.\n //!"}, {"sha": "6f2618c63b5d553c1e1d2b380eda5399288e76c1", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -162,7 +162,7 @@ impl io::Read for Stdin {\n         }\n \n         let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n-        // In the worst case, an UTF-8 string can take 3 bytes for every `u16` of an UTF-16. So\n+        // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n         // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n         // lost.\n         let amount = cmp::min(buf.len() / 3, utf16_buf.len());"}, {"sha": "64873b850d3fa2e2a4dd46fcf3bd60042bb93b90", "filename": "library/std/src/sys_common/remutex/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -30,7 +30,7 @@ fn smoke() {\n #[test]\n fn is_mutex() {\n     let m = unsafe {\n-        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n+        // FIXME: Simplify this if Arc gets an Arc::get_pin_mut.\n         let mut m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n         Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n         Pin::new_unchecked(m)\n@@ -52,7 +52,7 @@ fn is_mutex() {\n #[test]\n fn trylock_works() {\n     let m = unsafe {\n-        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n+        // FIXME: Simplify this if Arc gets an Arc::get_pin_mut.\n         let mut m = Arc::new(ReentrantMutex::new(()));\n         Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n         Pin::new_unchecked(m)"}, {"sha": "9508bd7da594b8853e207b517e089d87bfcc55f6", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -785,7 +785,7 @@ pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n /// Copied from core::str::raw::slice_unchecked\n #[inline]\n pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {\n-    // memory layout of an &[u8] and &Wtf8 are the same\n+    // memory layout of a &[u8] and &Wtf8 are the same\n     Wtf8::from_bytes_unchecked(slice::from_raw_parts(s.bytes.as_ptr().add(begin), end - begin))\n }\n "}, {"sha": "fa96b7abff6d61aa0920c52398e1d52c29e8b903", "filename": "library/std/src/time/monotonic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -84,7 +84,7 @@ pub mod inner {\n     pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n         let delta = raw.checked_sub_instant(&ZERO).unwrap();\n         // Split into seconds and nanos since Duration doesn't have a\n-        // constructor that takes an u128\n+        // constructor that takes a u128\n         let secs = delta.as_secs() as u128;\n         let nanos = delta.subsec_nanos() as u128;\n         let timestamp: u128 = secs << 64 | nanos;"}, {"sha": "1830909d944606e1799a3acc5f2f48889a6a5ef9", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -22,7 +22,7 @@ use crate::html::render::IndexItem;\n ///\n /// This structure purposefully does not implement `Clone` because it's intended\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// to `Send` so it may be stored in an `Arc` instance and shared among the various\n /// rendering threads.\n #[derive(Default)]\n crate struct Cache {"}, {"sha": "5eb545f758247788aac28d2977098492699d3571", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1331,7 +1331,7 @@ window.initSearch = function(rawSearchIndex) {\n             // an array of [(Number) item type,\n             //              (String) name]\n             var paths = rawSearchIndex[crate].p;\n-            // a array of [(String) alias name\n+            // an array of [(String) alias name\n             //             [Number] index to items]\n             var aliases = rawSearchIndex[crate].a;\n "}, {"sha": "fc53acf75cb8678a4c272ac7a2c40a58d7436832", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_import_removed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -8,7 +8,7 @@\n // functions and the modules are enclosed in `[]`)\n //\n // In our specific instance, the earlier compilations were inlining the call\n-// to`B` into `A`; thus `A` ended up with a external reference to the symbol `D`\n+// to`B` into `A`; thus `A` ended up with an external reference to the symbol `D`\n // in its object code, to be resolved at subsequent link time. The LTO import\n // information provided by LLVM for those runs reflected that information: it\n // explicitly says during those runs, `B` definition and `D` declaration were"}, {"sha": "a5fb0f640b24a0d178fe0600c96f3a48a4ec6a52", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -7,7 +7,7 @@ fn dummy(x: u8) -> u8 {\n \n // EMIT_MIR copy_propagation_arg.foo.DestinationPropagation.diff\n fn foo(mut x: u8) {\n-    // calling `dummy` to make an use of `x` that copyprop cannot eliminate\n+    // calling `dummy` to make a use of `x` that copyprop cannot eliminate\n     x = dummy(x); // this will assign a local to `x`\n }\n "}, {"sha": "c771c09da88335bcd49a0007c0242da2b4bbc401", "filename": "src/test/rustdoc-ui/coverage/allow_missing_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fallow_missing_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fallow_missing_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fallow_missing_docs.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -8,7 +8,7 @@ pub mod mod_foo {\n     pub struct Bar;\n }\n \n-/// This is a struct with a `#[allow(missing_docs)]`\n+/// This is a struct with an `#[allow(missing_docs)]`\n pub struct AllowTheMissingDocs {\n     #[allow(missing_docs)]\n     pub empty_str: String,"}, {"sha": "48b140d91744ca955d21ea88ff45b5c180743e66", "filename": "src/test/ui-fulldeps/internal-lints/pass_ty_by_ref_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: -Z unstable-options\n // NOTE: This test doesn't actually require `fulldeps`\n-// so we could instead use it as an `ui` test.\n+// so we could instead use it as a `ui` test.\n //\n // Considering that all other `internal-lints` are tested here\n // this seems like the cleaner solution though."}, {"sha": "edfecb91036925fca39492d97254a953bf83b974", "filename": "src/test/ui/async-await/drop-order/drop-order-for-temporary-in-tail-return-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -10,7 +10,7 @@\n // Test the drop order for parameters relative to local variables and\n // temporaries created in the tail return expression of the function\n // body. In particular, check that this drop order is the same between\n-// a `async fn` and an ordinary `fn`. See #64512.\n+// an `async fn` and an ordinary `fn`. See #64512.\n \n extern crate arc_wake;\n "}, {"sha": "3a33af2d2eec8d08e8fec5146861abafe75ce1a8", "filename": "src/test/ui/async-await/issues/issue-53249.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-53249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-53249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-53249.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -8,7 +8,7 @@ use std::future::Future;\n use std::marker::Unpin;\n use std::pin::Pin;\n \n-// This is a regression test for a ICE/unbounded recursion issue relating to async-await.\n+// This is a regression test for an ICE/unbounded recursion issue relating to async-await.\n \n #[derive(Debug)]\n #[must_use = \"futures do nothing unless polled\"]"}, {"sha": "59309a7f2888b5d26c039cf0f81563b958ad2112", "filename": "src/test/ui/async-await/issues/issue-69307.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,6 +1,6 @@\n // Regression test for #69307\n //\n-// Having a `async { .. foo.await .. }` block appear inside of a `+=`\n+// Having an `async { .. foo.await .. }` block appear inside of a `+=`\n // expression was causing an ICE due to a failure to save/restore\n // state in the AST numbering pass when entering a nested body.\n //"}, {"sha": "c82bc369f430181f594aa0a38f2356b521dfcd2d", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -3,7 +3,7 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n-// Test cases for types that implement a insignificant drop (stlib defined)\n+// Test cases for types that implement an insignificant drop (stlib defined)\n \n // `t` needs Drop because one of its elements needs drop,\n // therefore precise capture might affect drop ordering"}, {"sha": "57ab15ae8f2439041e440060209a480df4cd4457", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -3,7 +3,7 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n-// Test cases for types that implement a insignificant drop (stlib defined)\n+// Test cases for types that implement an insignificant drop (stlib defined)\n \n // `t` needs Drop because one of its elements needs drop,\n // therefore precise capture might affect drop ordering"}, {"sha": "e59ae297da1a781fdbc324796be8ee73b77600b4", "filename": "src/test/ui/consts/cast-discriminant-zst-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// Test a ZST enum whose dicriminant is ~0i128. This caused an ICE when casting to a i32.\n+// Test a ZST enum whose dicriminant is ~0i128. This caused an ICE when casting to an i32.\n #![feature(bench_black_box)]\n use std::hint::black_box;\n "}, {"sha": "567802376184da5316e82becf37edbb70d9724c1", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,4 +1,4 @@\n-// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+// Test an `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n //\n // In particular, we test this pattern in trait solving, where it is not connected\n // to any part of the source code."}, {"sha": "9b9e4496a870dc926c88791b9e4aaebc4e54d623", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,4 +1,4 @@\n-// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+// Test an `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n //\n // In particular, we test this pattern in trait solving, where it is not connected\n // to any part of the source code."}, {"sha": "84746ca2c889ce8172b33158dd4611f9c8088d1b", "filename": "src/test/ui/issues/issue-11692-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -3,6 +3,8 @@ error: cannot find macro `test` in this scope\n    |\n LL |     concat!(test!());\n    |             ^^^^\n+   |\n+   = note: `test` is in scope, but it is an attribute: `#[test]`\n \n error: aborting due to previous error\n "}, {"sha": "7c45c099304fa8b4f21ca6825685b354fc361ec3", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -30,7 +30,7 @@ struct \u5bf9__\u5426;\n struct \u30d2__\u03c7;\n //~^ ERROR type `\u30d2__\u03c7` should have an upper camel case name\n \n-// also cannot have lowercase letter next to a underscore.\n+// also cannot have lowercase letter next to an underscore.\n // so this triggers the lint:\n \n struct Hello_\u4f60\u597d;"}, {"sha": "14e2f66068b01f1a76535e2fd4836e901d529759", "filename": "src/test/ui/macros/issue-88206.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88206.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88206.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-88206.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -0,0 +1,66 @@\n+// compile-flags: -Z deduplicate-diagnostics=yes\n+\n+#![warn(unused_imports)]\n+\n+use std::str::*;\n+//~^ NOTE `from_utf8` is imported here, but it is a function\n+//~| NOTE `from_utf8_mut` is imported here, but it is a function\n+//~| NOTE `from_utf8_unchecked` is imported here, but it is a function\n+\n+mod hey {\n+    pub trait Serialize {}\n+    pub trait Deserialize {}\n+\n+    pub struct X(i32);\n+}\n+\n+use hey::{Serialize, Deserialize, X};\n+//~^ NOTE `Serialize` is imported here, but it is only a trait, without a derive macro\n+//~| NOTE `Deserialize` is imported here, but it is a trait\n+//~| NOTE `X` is imported here, but it is a struct\n+\n+#[derive(Serialize)]\n+//~^ ERROR cannot find derive macro `Serialize`\n+struct A;\n+\n+#[derive(from_utf8_mut)]\n+//~^ ERROR cannot find derive macro `from_utf8_mut`\n+struct B;\n+\n+#[derive(println)]\n+//~^ ERROR cannot find derive macro `println`\n+//~| NOTE `println` is in scope, but it is a function-like macro\n+struct C;\n+\n+#[Deserialize]\n+//~^ ERROR cannot find attribute `Deserialize`\n+struct D;\n+\n+#[from_utf8_unchecked]\n+//~^ ERROR cannot find attribute `from_utf8_unchecked`\n+struct E;\n+\n+#[println]\n+//~^ ERROR cannot find attribute `println`\n+//~| NOTE `println` is in scope, but it is a function-like macro\n+struct F;\n+\n+fn main() {\n+    from_utf8!();\n+    //~^ ERROR cannot find macro `from_utf8`\n+\n+    Box!();\n+    //~^ ERROR cannot find macro `Box`\n+    //~| NOTE `Box` is in scope, but it is a struct\n+\n+    Copy!();\n+    //~^ ERROR cannot find macro `Copy`\n+    //~| NOTE `Copy` is in scope, but it is a derive macro\n+\n+    test!();\n+    //~^ ERROR cannot find macro `test`\n+    //~| NOTE `test` is in scope, but it is an attribute\n+\n+    X!();\n+    //~^ ERROR cannot find macro `X`\n+}"}, {"sha": "f7f5b564880075c9b676da0b544accbbac194092", "filename": "src/test/ui/macros/issue-88206.stderr", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88206.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88206.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-88206.stderr?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -0,0 +1,114 @@\n+error: cannot find macro `X` in this scope\n+  --> $DIR/issue-88206.rs:64:5\n+   |\n+LL |     X!();\n+   |     ^\n+   |\n+note: `X` is imported here, but it is a struct, not a macro\n+  --> $DIR/issue-88206.rs:17:35\n+   |\n+LL | use hey::{Serialize, Deserialize, X};\n+   |                                   ^\n+\n+error: cannot find macro `test` in this scope\n+  --> $DIR/issue-88206.rs:60:5\n+   |\n+LL |     test!();\n+   |     ^^^^\n+   |\n+   = note: `test` is in scope, but it is an attribute: `#[test]`\n+\n+error: cannot find macro `Copy` in this scope\n+  --> $DIR/issue-88206.rs:56:5\n+   |\n+LL |     Copy!();\n+   |     ^^^^\n+   |\n+   = note: `Copy` is in scope, but it is a derive macro: `#[derive(Copy)]`\n+\n+error: cannot find macro `Box` in this scope\n+  --> $DIR/issue-88206.rs:52:5\n+   |\n+LL |     Box!();\n+   |     ^^^\n+   |\n+   = note: `Box` is in scope, but it is a struct, not a macro\n+\n+error: cannot find macro `from_utf8` in this scope\n+  --> $DIR/issue-88206.rs:49:5\n+   |\n+LL |     from_utf8!();\n+   |     ^^^^^^^^^\n+   |\n+note: `from_utf8` is imported here, but it is a function, not a macro\n+  --> $DIR/issue-88206.rs:5:5\n+   |\n+LL | use std::str::*;\n+   |     ^^^^^^^^^^^\n+\n+error: cannot find attribute `println` in this scope\n+  --> $DIR/issue-88206.rs:43:3\n+   |\n+LL | #[println]\n+   |   ^^^^^^^\n+   |\n+   = note: `println` is in scope, but it is a function-like macro\n+\n+error: cannot find attribute `from_utf8_unchecked` in this scope\n+  --> $DIR/issue-88206.rs:39:3\n+   |\n+LL | #[from_utf8_unchecked]\n+   |   ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `from_utf8_unchecked` is imported here, but it is a function, not an attribute\n+  --> $DIR/issue-88206.rs:5:5\n+   |\n+LL | use std::str::*;\n+   |     ^^^^^^^^^^^\n+\n+error: cannot find attribute `Deserialize` in this scope\n+  --> $DIR/issue-88206.rs:35:3\n+   |\n+LL | #[Deserialize]\n+   |   ^^^^^^^^^^^\n+   |\n+note: `Deserialize` is imported here, but it is a trait, not an attribute\n+  --> $DIR/issue-88206.rs:17:22\n+   |\n+LL | use hey::{Serialize, Deserialize, X};\n+   |                      ^^^^^^^^^^^\n+\n+error: cannot find derive macro `println` in this scope\n+  --> $DIR/issue-88206.rs:30:10\n+   |\n+LL | #[derive(println)]\n+   |          ^^^^^^^\n+   |\n+   = note: `println` is in scope, but it is a function-like macro\n+\n+error: cannot find derive macro `from_utf8_mut` in this scope\n+  --> $DIR/issue-88206.rs:26:10\n+   |\n+LL | #[derive(from_utf8_mut)]\n+   |          ^^^^^^^^^^^^^\n+   |\n+note: `from_utf8_mut` is imported here, but it is a function, not a derive macro\n+  --> $DIR/issue-88206.rs:5:5\n+   |\n+LL | use std::str::*;\n+   |     ^^^^^^^^^^^\n+\n+error: cannot find derive macro `Serialize` in this scope\n+  --> $DIR/issue-88206.rs:22:10\n+   |\n+LL | #[derive(Serialize)]\n+   |          ^^^^^^^^^\n+   |\n+note: `Serialize` is imported here, but it is only a trait, without a derive macro\n+  --> $DIR/issue-88206.rs:17:11\n+   |\n+LL | use hey::{Serialize, Deserialize, X};\n+   |           ^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "cbdef5f0d40a94eb2d4a705ffe70303bda06136a", "filename": "src/test/ui/macros/issue-88228.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -13,6 +13,7 @@ struct A;\n \n #[derive(println)]\n //~^ ERROR cannot find derive macro `println`\n+//~|`println` is in scope, but it is a function-like macro\n struct B;\n \n fn main() {"}, {"sha": "62afa67a783c9404c4288da55d8287035f1ad5b1", "filename": "src/test/ui/macros/issue-88228.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.stderr?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,5 +1,5 @@\n error: cannot find macro `bla` in this scope\n-  --> $DIR/issue-88228.rs:19:5\n+  --> $DIR/issue-88228.rs:20:5\n    |\n LL |     bla!();\n    |     ^^^\n@@ -12,6 +12,8 @@ error: cannot find derive macro `println` in this scope\n    |\n LL | #[derive(println)]\n    |          ^^^^^^^\n+   |\n+   = note: `println` is in scope, but it is a function-like macro\n \n error: cannot find derive macro `Bla` in this scope\n   --> $DIR/issue-88228.rs:9:10"}, {"sha": "70900a6bc81d3a1468003c2dda68f9781d1fc505", "filename": "src/test/ui/macros/macro-path-prelude-fail-3.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -8,6 +8,8 @@ LL |     inline!();\n    |\n LL |     macro_rules! line {\n    |     ----------------- similarly named macro `line` defined here\n+   |\n+   = note: `inline` is in scope, but it is an attribute: `#[inline]`\n \n error: aborting due to previous error\n "}, {"sha": "ebea6d3d9d1ea8e4005558791701b560971d3b59", "filename": "src/test/ui/nll/issue-21232-partial-init-and-erroneous-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1,4 +1,4 @@\n-// This test enumerates various cases of interest where a ADT or tuple is\n+// This test enumerates various cases of interest where an ADT or tuple is\n // partially initialized and then used in some way that is wrong *even*\n // after rust-lang/rust#54987 is implemented.\n //"}, {"sha": "633a6c6a0d3cb29e5182302a63ff7e85c22b144b", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -93,30 +93,40 @@ error: cannot find macro `my_macro_attr` in this scope\n    |\n LL |     my_macro_attr!();\n    |     ^^^^^^^^^^^^^\n+   |\n+   = note: `my_macro_attr` is in scope, but it is an attribute: `#[my_macro_attr]`\n \n error: cannot find macro `MyTrait` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:33:5\n    |\n LL |     MyTrait!();\n    |     ^^^^^^^\n+   |\n+   = note: `MyTrait` is in scope, but it is a derive macro: `#[derive(MyTrait)]`\n \n error: cannot find attribute `my_macro` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:38:3\n    |\n LL | #[my_macro]\n    |   ^^^^^^^^\n+   |\n+   = note: `my_macro` is in scope, but it is a function-like macro\n \n error: cannot find derive macro `my_macro` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:48:10\n    |\n LL | #[derive(my_macro)]\n    |          ^^^^^^^^\n+   |\n+   = note: `my_macro` is in scope, but it is a function-like macro\n \n error: cannot find derive macro `my_macro` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:48:10\n    |\n LL | #[derive(my_macro)]\n    |          ^^^^^^^^\n+   |\n+   = note: `my_macro` is in scope, but it is a function-like macro\n \n error: aborting due to 20 previous errors\n "}, {"sha": "9d2855f5c61666011f536b75d58c8fc2c6777f99", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -30,7 +30,7 @@ fn main() {\n     match enum_unit {\n         NonExhaustiveEnum::Unit => 1,\n         NonExhaustiveEnum::Tuple(_) => 2,\n-        // This particular arm tests that a enum marked as non-exhaustive\n+        // This particular arm tests that an enum marked as non-exhaustive\n         // will not error if its variants are matched exhaustively.\n         NonExhaustiveEnum::Struct { field } => field,\n         _ => 0 // no error with wildcard"}, {"sha": "a71051243c893dbd3b669315f3a11a1a51b49829", "filename": "src/test/ui/traits/reservation-impl/non-lattice-ok.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -5,7 +5,7 @@\n \n // Why did we ever want to do this?\n //\n-// We want to eventually add a `impl<T> From<!> for T` impl. That impl conflicts\n+// We want to eventually add an `impl<T> From<!> for T` impl. That impl conflicts\n // with existing impls - at least the `impl<T> From<T> for T` impl. There are\n // 2 ways we thought of for dealing with that conflict:\n //\n@@ -23,7 +23,7 @@\n // actually cause any ambiguity.\n //\n // Now it turned out lattice specialization doesn't work it, because an\n-// `impl<T> From<T> for Smaht<T>` would require a `impl From<!> for Smaht<!>`,\n+// `impl<T> From<T> for Smaht<T>` would require an `impl From<!> for Smaht<!>`,\n // breaking backwards-compatibility in a fairly painful way. So if we want to\n // go with a known approach, we should go with a \"marker trait overlap\"-style\n // approach."}, {"sha": "3f4f7ea1c10c39291d3aa798d1c87a1d162d4d88", "filename": "src/test/ui/union/union-nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Funion%2Funion-nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftest%2Fui%2Funion%2Funion-nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nonzero.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -13,7 +13,7 @@\n // optimizations to types containing unions even if they're theoretically possible. (discussion:\n // https://github.com/rust-lang/rust/issues/36394)\n //\n-// Notably this nails down part of the behavior that `MaybeUninit` assumes: that a\n+// Notably this nails down part of the behavior that `MaybeUninit` assumes: that an\n // `Option<MaybeUninit<&u8>>` does not take advantage of non-zero optimization, and thus is a safe\n // construct.\n "}, {"sha": "4dd0ffe77ea49fbff542b3c20a48ad053aa94650", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -164,7 +164,7 @@ fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion();\n         // span between BinOp LHS and RHS\n         let binop_span = lhs.span.between(rhs.span);\n-        // if RHS is a UnOp\n+        // if RHS is an UnOp\n         if let ExprKind::Unary(op, ref un_rhs) = rhs.kind;\n         // from UnOp operator to UnOp operand\n         let unop_operand_span = rhs.span.until(un_rhs.span);"}, {"sha": "2296842e86f556ae6dc64572f0e440146ba6d7f7", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -268,7 +268,7 @@ impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     }\n }\n \n-/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// a wrapper around `MinifyingSugg`, which carries an operator like currying\n /// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n struct Offset {\n     value: MinifyingSugg<'static>,"}, {"sha": "3f9110295fc6bcb4abe594e0fd6ec6dea2f17ee1", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -122,7 +122,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n     // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n     // 'unfrozen'. However, this code causes a false negative in which\n-    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // a type contains a layout-unknown type, but also an unsafe cell like `const CELL: Cell<T>`.\n     // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n     // since it works when a pointer indirection involves (`Cell<*const T>`).\n     // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n@@ -266,7 +266,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 // in other words, lint consts whose value *could* be unfrozen, not definitely is.\n                 // This feels inconsistent with how the lint treats generic types,\n                 // which avoids linting types which potentially become unfrozen.\n-                // One could check whether a unfrozen type have a *frozen variant*\n+                // One could check whether an unfrozen type have a *frozen variant*\n                 // (like `body_id_opt.map_or_else(|| !has_frozen_variant(...), ...)`),\n                 // and do the same as the case of generic types at impl items.\n                 // Note that it isn't sufficient to check if it has an enum\n@@ -293,7 +293,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 }) => {\n                     if_chain! {\n                         // Lint a trait impl item only when the definition is a generic type,\n-                        // assuming a assoc const is not meant to be a interior mutable type.\n+                        // assuming an assoc const is not meant to be an interior mutable type.\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n                         if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n                             .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);"}, {"sha": "3258c9fb3fed0ef244813e52bf47f6d3a65f9722", "filename": "src/tools/clippy/clippy_lints/src/ptr_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -74,7 +74,7 @@ impl LateLintPass<'_> for PtrEq {\n     }\n }\n \n-// If the given expression is a cast to an usize, return the lhs of the cast\n+// If the given expression is a cast to a usize, return the lhs of the cast\n // E.g., `foo as *const _ as usize` returns `foo as *const _`.\n fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {"}, {"sha": "4fa361fedafac434dbd26510c421506bed51e0b8", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -51,7 +51,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// Will add unnecessary pair of parentheses when the\n-    /// expression is not wrapped in a pair but starts with a opening parenthesis\n+    /// expression is not wrapped in a pair but starts with an opening parenthesis\n     /// and ends with a closing one.\n     /// I.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n     ///"}, {"sha": "b9e317a3cfd03af73f46ea09bc2f6997936fb107", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -74,7 +74,7 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for bindings that shadow other bindings already in\n-    /// scope, either without a initialization or with one that does not even use\n+    /// scope, either without an initialization or with one that does not even use\n     /// the original value.\n     ///\n     /// ### Why is this bad?"}, {"sha": "c192f9094a8a97bdfd840c3edfd27e09948d61e4", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -198,7 +198,7 @@ define_Conf! {\n     (enum_variant_name_threshold: u64 = 3),\n     /// Lint: LARGE_ENUM_VARIANT.\n     ///\n-    /// The maximum size of a enum's variant to avoid box suggestion\n+    /// The maximum size of an enum's variant to avoid box suggestion\n     (enum_variant_size_threshold: u64 = 200),\n     /// Lint: VERBOSE_BIT_MASK.\n     ///"}, {"sha": "9ba1381da659397d6d500ba7cc1e9fbe6de28198", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n     }\n \n-    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    /// Lookup a possibly constant expression from an `ExprKind::Path`.\n     fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n         let res = self.typeck_results.qpath_res(qpath, id);\n         match res {"}, {"sha": "32a73984674adac82d7a0c2da4b4797d2e734530", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -587,7 +587,7 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n /// For example, if `e` represents the `v[0].a.b[x]`\n /// this method will return a tuple, composed of a `Vec`\n /// containing the `Expr`s for `v[0], v[0].a, v[0].a.b, v[0].a.b[x]`\n-/// and a `Expr` for root of them, `v`\n+/// and an `Expr` for root of them, `v`\n fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'a Expr<'hir>) {\n     let mut result = vec![];\n     let root = loop {"}, {"sha": "65d93e8f86e43f1c7953d83f45721bb9add27c43", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -434,7 +434,7 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n         matches!(op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n-    /// Returns `true` if the operator is a arithmetic operator\n+    /// Returns `true` if the operator is an arithmetic operator\n     /// (i.e., `+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: AssocOp) -> bool {\n         matches!("}, {"sha": "256a336db821d8711c6c3f958e2b814784b2f701", "filename": "src/tools/clippy/tests/ui/declare_interior_mutable_const/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -117,7 +117,7 @@ impl SelfType for AtomicUsize {\n     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n }\n \n-// Even though a constant contains a generic type, if it also have a interior mutable type,\n+// Even though a constant contains a generic type, if it also have an interior mutable type,\n // it should be linted at the definition site.\n trait BothOfCellAndGeneric<T> {\n     // this is a false negative in the current implementation."}, {"sha": "f291918225f450e21b6914ffc7f7afeab7e639ee", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -1733,7 +1733,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     /// For each `aux-build: foo/bar` annotation, we check to find the\n-    /// file in a `auxiliary` directory relative to the test itself.\n+    /// file in an `auxiliary` directory relative to the test itself.\n     fn compute_aux_test_paths(&self, rel_ab: &str) -> TestPaths {\n         let test_ab = self\n             .testpaths"}, {"sha": "d34dcc0f0942fd0138ee0b997f8014abc693f122", "filename": "src/tools/rustdoc-gui/tester.js", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustdoc-gui%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustdoc-gui%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui%2Ftester.js?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -3,6 +3,7 @@\n // ```\n // npm install browser-ui-test\n // ```\n+\n const fs = require(\"fs\");\n const path = require(\"path\");\n const os = require('os');\n@@ -172,12 +173,14 @@ async function main(argv) {\n     files.sort();\n \n     console.log(`Running ${files.length} rustdoc-gui tests...`);\n+\n     if (opts[\"jobs\"] < 1) {\n         process.setMaxListeners(files.length + 1);\n     } else {\n-        process.setMaxListeners(opts[\"jobs\"]);\n+        process.setMaxListeners(opts[\"jobs\"] + 1);\n     }\n-    let tests = [];\n+\n+    const tests_queue = [];\n     let results = {\n         successful: [],\n         failed: [],\n@@ -187,19 +190,18 @@ async function main(argv) {\n     for (let i = 0; i < files.length; ++i) {\n         const file_name = files[i];\n         const testPath = path.join(opts[\"tests_folder\"], file_name);\n-        tests.push(\n-            runTest(testPath, options)\n+        const callback = runTest(testPath, options)\n             .then(out => {\n                 const [output, nb_failures] = out;\n                 results[nb_failures === 0 ? \"successful\" : \"failed\"].push({\n                     file_name: file_name,\n                     output: output,\n                 });\n                 if (nb_failures > 0) {\n-                    status_bar.erroneous()\n+                    status_bar.erroneous();\n                     failed = true;\n                 } else {\n-                    status_bar.successful()\n+                    status_bar.successful();\n                 }\n             })\n             .catch(err => {\n@@ -210,13 +212,19 @@ async function main(argv) {\n                 status_bar.erroneous();\n                 failed = true;\n             })\n-        );\n+            .finally(() => {\n+                // We now remove the promise from the tests_queue.\n+                tests_queue.splice(tests_queue.indexOf(callback), 1);\n+            });\n+        tests_queue.push(callback);\n         if (no_headless) {\n-            await tests[i];\n+            await tests_queue[i];\n+        } else if (opts[\"jobs\"] > 0 && tests_queue.length >= opts[\"jobs\"]) {\n+            await Promise.race(tests_queue);\n         }\n     }\n-    if (!no_headless) {\n-        await Promise.all(tests);\n+    if (!no_headless && tests_queue.length > 0) {\n+        await Promise.all(tests_queue);\n     }\n     status_bar.finish();\n "}, {"sha": "a9bc89544d820cd5c0b592fdc9ee4d74c0057ff3", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -401,7 +401,7 @@ fn rewrite_macro_inner(\n                 handle_vec_semi(context, shape, arg_vec, macro_name, style)\n             } else {\n                 // If we are rewriting `vec!` macro or other special macros,\n-                // then we can rewrite this as an usual array literal.\n+                // then we can rewrite this as a usual array literal.\n                 // Otherwise, we must preserve the original existence of trailing comma.\n                 let macro_name = &macro_name.as_str();\n                 let mut force_trailing_comma = if trailing_comma {"}, {"sha": "64ae15672df8ff1c88f3d749d6d2de14bff2f9c3", "filename": "src/tools/rustfmt/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -153,7 +153,7 @@ pub(crate) fn rewrite_string<'a>(\n     wrap_str(result, fmt.config.max_width(), fmt.shape)\n }\n \n-/// Returns the index to the end of the URL if the split at index of the given string includes an\n+/// Returns the index to the end of the URL if the split at index of the given string includes a\n /// URL or alike. Otherwise, returns `None`.\n fn detect_url(s: &[&str], index: usize) -> Option<usize> {\n     let start = match s[..=index].iter().rposition(|g| is_whitespace(g)) {"}, {"sha": "770693d165b7ee142919fdb8bef986260a28462e", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -36,7 +36,7 @@ pub(crate) struct SnippetProvider {\n     big_snippet: Lrc<String>,\n     /// A position of the start of `big_snippet`, used as an offset.\n     start_pos: usize,\n-    /// A end position of the file that this snippet lives.\n+    /// An end position of the file that this snippet lives.\n     end_pos: usize,\n }\n "}, {"sha": "4c71a2c6ab90b655bf18504e81899faf21db815d", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The features are detected using the `detect_features` function below.\n //! This function uses the CPUID instruction to read the feature flags from the\n-//! CPU and encodes them in an `usize` where each bit position represents\n+//! CPU and encodes them in a `usize` where each bit position represents\n //! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n //!\n //! The enum `Feature` is used to map bit positions to feature names, and the"}, {"sha": "b985dd8caa1ffa0ecbdd9fc5e2945424567d0025", "filename": "src/tools/rustfmt/tests/target/cfg_if/detect/arch/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The features are detected using the `detect_features` function below.\n //! This function uses the CPUID instruction to read the feature flags from the\n-//! CPU and encodes them in an `usize` where each bit position represents\n+//! CPU and encodes them in a `usize` where each bit position represents\n //! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n //!\n //! The enum `Feature` is used to map bit positions to feature names, and the"}, {"sha": "022a3dfde8217bcc173e4d9cd995daf8aa3fc3b2", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49e38e672c60da788360e088f00ad12353e3913/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=a49e38e672c60da788360e088f00ad12353e3913", "patch": "@@ -66,7 +66,7 @@ enum LIUState {\n     EXP_END,\n }\n \n-/// Returns `true` if `line` appears to be a line comment containing an URL,\n+/// Returns `true` if `line` appears to be a line comment containing a URL,\n /// possibly with a Markdown link label in front, and nothing else.\n /// The Markdown link label, if present, may not contain whitespace.\n /// Lines of this form are allowed to be overlength, because Markdown"}]}