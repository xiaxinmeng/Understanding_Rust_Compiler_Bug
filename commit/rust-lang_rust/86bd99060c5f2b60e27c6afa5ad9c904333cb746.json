{"sha": "86bd99060c5f2b60e27c6afa5ad9c904333cb746", "node_id": "C_kwDOAAsO6NoAKDg2YmQ5OTA2MGM1ZjJiNjBlMjdjNmFmYTVhZDljOTA0MzMzY2I3NDY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-02T18:35:14Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-03T06:26:10Z"}, "message": "Reuse resolve_label to check lifetime shadowing.", "tree": {"sha": "3af169c7dfbd981d42525715fe9fc7f723a3ae6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3af169c7dfbd981d42525715fe9fc7f723a3ae6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86bd99060c5f2b60e27c6afa5ad9c904333cb746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86bd99060c5f2b60e27c6afa5ad9c904333cb746", "html_url": "https://github.com/rust-lang/rust/commit/86bd99060c5f2b60e27c6afa5ad9c904333cb746", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86bd99060c5f2b60e27c6afa5ad9c904333cb746/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75409d5e423d0ba21a44eb7c2bf11df6bcf6072", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75409d5e423d0ba21a44eb7c2bf11df6bcf6072", "html_url": "https://github.com/rust-lang/rust/commit/c75409d5e423d0ba21a44eb7c2bf11df6bcf6072"}], "stats": {"total": 69, "additions": 29, "deletions": 40}, "files": [{"sha": "5c968655e29ecab27779c4b4a630377f0a4c339a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/86bd99060c5f2b60e27c6afa5ad9c904333cb746/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bd99060c5f2b60e27c6afa5ad9c904333cb746/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=86bd99060c5f2b60e27c6afa5ad9c904333cb746", "patch": "@@ -1548,13 +1548,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// Searches the current set of local scopes for labels. Returns the `NodeId` of the resolved\n     /// label and reports an error if the label is not found or is unreachable.\n-    fn resolve_label(&mut self, mut label: Ident) -> Option<NodeId> {\n+    fn resolve_label(&mut self, mut label: Ident) -> Result<(NodeId, Span), ResolutionError<'a>> {\n         let mut suggestion = None;\n \n-        // Preserve the original span so that errors contain \"in this macro invocation\"\n-        // information.\n-        let original_span = label.span;\n-\n         for i in (0..self.label_ribs.len()).rev() {\n             let rib = &self.label_ribs[i];\n \n@@ -1570,18 +1566,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if let Some((ident, id)) = rib.bindings.get_key_value(&ident) {\n                 let definition_span = ident.span;\n                 return if self.is_label_valid_from_rib(i) {\n-                    Some(*id)\n+                    Ok((*id, definition_span))\n                 } else {\n-                    self.report_error(\n-                        original_span,\n-                        ResolutionError::UnreachableLabel {\n-                            name: label.name,\n-                            definition_span,\n-                            suggestion,\n-                        },\n-                    );\n-\n-                    None\n+                    Err(ResolutionError::UnreachableLabel {\n+                        name: label.name,\n+                        definition_span,\n+                        suggestion,\n+                    })\n                 };\n             }\n \n@@ -1590,11 +1581,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             suggestion = suggestion.or_else(|| self.suggestion_for_label_in_rib(i, label));\n         }\n \n-        self.report_error(\n-            original_span,\n-            ResolutionError::UndeclaredLabel { name: label.name, suggestion },\n-        );\n-        None\n+        Err(ResolutionError::UndeclaredLabel { name: label.name, suggestion })\n     }\n \n     /// Determine whether or not a label from the `rib_index`th label rib is reachable.\n@@ -3152,17 +3139,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             }\n \n-            let ident = label.ident.normalize_to_macro_rules();\n-            for rib in self.label_ribs.iter_mut().rev() {\n-                if let Some((&orig_ident, _)) = rib.bindings.get_key_value(&ident) {\n-                    diagnostics::signal_label_shadowing(self.r.session, orig_ident, label.ident)\n-                }\n-                if rib.kind.is_label_barrier() {\n-                    break;\n-                }\n+            if let Ok((_, orig_span)) = self.resolve_label(label.ident) {\n+                diagnostics::signal_label_shadowing(self.r.session, orig_span, label.ident)\n             }\n \n             self.with_label_rib(NormalRibKind, |this| {\n+                let ident = label.ident.normalize_to_macro_rules();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });\n@@ -3266,10 +3248,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                if let Some(node_id) = self.resolve_label(label.ident) {\n-                    // Since this res is a label, it is never read.\n-                    self.r.label_res_map.insert(expr.id, node_id);\n-                    self.diagnostic_metadata.unused_labels.remove(&node_id);\n+                match self.resolve_label(label.ident) {\n+                    Ok((node_id, _)) => {\n+                        // Since this res is a label, it is never read.\n+                        self.r.label_res_map.insert(expr.id, node_id);\n+                        self.diagnostic_metadata.unused_labels.remove(&node_id);\n+                    }\n+                    Err(error) => {\n+                        self.report_error(label.ident.span, error);\n+                    }\n                 }\n \n                 // visit `break` argument if any"}, {"sha": "6d5318ae6f78099c9dadeb23f005305c3b6c2422", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86bd99060c5f2b60e27c6afa5ad9c904333cb746/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bd99060c5f2b60e27c6afa5ad9c904333cb746/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=86bd99060c5f2b60e27c6afa5ad9c904333cb746", "patch": "@@ -2066,15 +2066,17 @@ pub fn signal_lifetime_shadowing(\n     err.emit();\n }\n \n-/// Shadowing involving a label is only a warning, due to issues with\n-/// labels and lifetimes not being macro-hygienic.\n-pub fn signal_label_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n+/// Shadowing involving a label is only a warning for historical reasons.\n+//FIXME: make this a proper lint.\n+pub fn signal_label_shadowing(sess: &Session, orig: Span, shadower: Ident) {\n+    let name = shadower.name;\n+    let shadower = shadower.span;\n     let mut err = sess.struct_span_warn(\n-        shadower.span,\n-        &format!(\"label name `{}` shadows a label name that is already in scope\", orig.name),\n+        shadower,\n+        &format!(\"label name `{}` shadows a label name that is already in scope\", name),\n     );\n-    err.span_label(orig.span, \"first declared here\");\n-    err.span_label(shadower.span, format!(\"label `{}` already in scope\", orig.name));\n+    err.span_label(orig, \"first declared here\");\n+    err.span_label(shadower, format!(\"label `{}` already in scope\", name));\n     err.emit();\n }\n "}]}