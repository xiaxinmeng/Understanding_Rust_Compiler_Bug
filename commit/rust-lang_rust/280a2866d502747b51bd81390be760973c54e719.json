{"sha": "280a2866d502747b51bd81390be760973c54e719", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MGEyODY2ZDUwMjc0N2I1MWJkODEzOTBiZTc2MDk3M2M1NGU3MTk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-06T13:04:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-13T20:14:58Z"}, "message": "Drop the cache lock earlier.", "tree": {"sha": "ea3738702603defd4d9230d881dfa2b01c721d7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea3738702603defd4d9230d881dfa2b01c721d7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/280a2866d502747b51bd81390be760973c54e719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/280a2866d502747b51bd81390be760973c54e719", "html_url": "https://github.com/rust-lang/rust/commit/280a2866d502747b51bd81390be760973c54e719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/280a2866d502747b51bd81390be760973c54e719/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b0bc6b8380942fb45f1839b9fd91e66fad8045", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b0bc6b8380942fb45f1839b9fd91e66fad8045", "html_url": "https://github.com/rust-lang/rust/commit/15b0bc6b8380942fb45f1839b9fd91e66fad8045"}], "stats": {"total": 33, "additions": 17, "deletions": 16}, "files": [{"sha": "ec71c8685804fb2bfd35259fe8dcf84f9ce02363", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/280a2866d502747b51bd81390be760973c54e719/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/280a2866d502747b51bd81390be760973c54e719/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=280a2866d502747b51bd81390be760973c54e719", "patch": "@@ -37,7 +37,7 @@ pub trait QueryCache: QueryStorage {\n         key: &Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n-    ) -> Result<R, QueryLookup<'s, Self::Sharded>>\n+    ) -> Result<R, QueryLookup>\n     where\n         OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R;\n \n@@ -98,12 +98,12 @@ where\n         state: &'s QueryCacheStore<Self>,\n         key: &K,\n         on_hit: OnHit,\n-    ) -> Result<R, QueryLookup<'s, Self::Sharded>>\n+    ) -> Result<R, QueryLookup>\n     where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n     {\n-        let lookup = state.get_lookup(key);\n-        let result = lookup.lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n+        let (lookup, lock) = state.get_lookup(key);\n+        let result = lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n             let hit_result = on_hit(&value.0, value.1);\n@@ -181,12 +181,12 @@ where\n         state: &'s QueryCacheStore<Self>,\n         key: &K,\n         on_hit: OnHit,\n-    ) -> Result<R, QueryLookup<'s, Self::Sharded>>\n+    ) -> Result<R, QueryLookup>\n     where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n     {\n-        let lookup = state.get_lookup(key);\n-        let result = lookup.lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n+        let (lookup, lock) = state.get_lookup(key);\n+        let result = lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n             let hit_result = on_hit(&&value.0, value.1);"}, {"sha": "c2e89e131b3fe58c3edf1ed013516ce8f7a3e8cb", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/280a2866d502747b51bd81390be760973c54e719/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/280a2866d502747b51bd81390be760973c54e719/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=280a2866d502747b51bd81390be760973c54e719", "patch": "@@ -46,10 +46,9 @@ impl<C: QueryCache> Default for QueryCacheStore<C> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub struct QueryLookup<'tcx, C> {\n+pub struct QueryLookup {\n     pub(super) key_hash: u64,\n     shard: usize,\n-    pub(super) lock: LockGuard<'tcx, C>,\n }\n \n // We compute the key's hash once and then use it for both the\n@@ -62,11 +61,14 @@ fn hash_for_shard<K: Hash>(key: &K) -> u64 {\n }\n \n impl<C: QueryCache> QueryCacheStore<C> {\n-    pub(super) fn get_lookup<'tcx>(&'tcx self, key: &C::Key) -> QueryLookup<'tcx, C::Sharded> {\n+    pub(super) fn get_lookup<'tcx>(\n+        &'tcx self,\n+        key: &C::Key,\n+    ) -> (QueryLookup, LockGuard<'tcx, C::Sharded>) {\n         let key_hash = hash_for_shard(key);\n         let shard = get_shard_index_by_hash(key_hash);\n         let lock = self.shards.get_shard_by_index(shard).lock();\n-        QueryLookup { key_hash, shard, lock }\n+        (QueryLookup { key_hash, shard }, lock)\n     }\n \n     pub fn iter_results<R>(\n@@ -178,19 +180,18 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'a, 'b, CTX>(\n+    fn try_start<'b, CTX>(\n         tcx: CTX,\n         state: &'b QueryState<CTX::DepKind, CTX::Query, C::Key>,\n         cache: &'b QueryCacheStore<C>,\n         span: Span,\n         key: &C::Key,\n-        lookup: QueryLookup<'a, C::Sharded>,\n+        lookup: QueryLookup,\n         query: &QueryVtable<CTX, C::Key, C::Value>,\n     ) -> TryGetJob<'b, CTX::DepKind, CTX::Query, C>\n     where\n         CTX: QueryContext,\n     {\n-        mem::drop(lookup.lock);\n         let shard = lookup.shard;\n         let mut state_lock = state.shards.get_shard_by_index(shard).lock();\n         let lock = &mut *state_lock;\n@@ -379,7 +380,7 @@ fn try_get_cached<'a, CTX, C, R, OnHit>(\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n-) -> Result<R, QueryLookup<'a, C::Sharded>>\n+) -> Result<R, QueryLookup>\n where\n     C: QueryCache,\n     CTX: QueryContext,\n@@ -403,7 +404,7 @@ fn try_execute_query<CTX, C>(\n     cache: &QueryCacheStore<C>,\n     span: Span,\n     key: C::Key,\n-    lookup: QueryLookup<'_, C::Sharded>,\n+    lookup: QueryLookup,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> C::Stored\n where"}]}