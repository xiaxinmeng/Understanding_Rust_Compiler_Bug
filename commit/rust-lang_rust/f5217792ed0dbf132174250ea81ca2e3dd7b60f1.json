{"sha": "f5217792ed0dbf132174250ea81ca2e3dd7b60f1", "node_id": "C_kwDOAAsO6NoAKGY1MjE3NzkyZWQwZGJmMTMyMTc0MjUwZWE4MWNhMmUzZGQ3YjYwZjE", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-04T15:10:14Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-04T15:10:14Z"}, "message": "Simplify panicking mechanism of thread::scope.\n\nIt now panic!()s on its own, rather than resume_unwind'ing the panic\npayload from the thread. Using resume_unwind skips the panic_handler,\nmeaning that the main thread would never have a panic handler run, which\ncan get confusing.", "tree": {"sha": "eeb605e67aeae16205eba190089b16c677aac667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb605e67aeae16205eba190089b16c677aac667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5217792ed0dbf132174250ea81ca2e3dd7b60f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5217792ed0dbf132174250ea81ca2e3dd7b60f1", "html_url": "https://github.com/rust-lang/rust/commit/f5217792ed0dbf132174250ea81ca2e3dd7b60f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5217792ed0dbf132174250ea81ca2e3dd7b60f1/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da33da161bf01093bc87e0cdff317d40bd648974", "url": "https://api.github.com/repos/rust-lang/rust/commits/da33da161bf01093bc87e0cdff317d40bd648974", "html_url": "https://github.com/rust-lang/rust/commit/da33da161bf01093bc87e0cdff317d40bd648974"}], "stats": {"total": 53, "additions": 22, "deletions": 31}, "files": [{"sha": "88dabfa8d22b8be6ce00c7af079e032efdf58b55", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5217792ed0dbf132174250ea81ca2e3dd7b60f1/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5217792ed0dbf132174250ea81ca2e3dd7b60f1/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=f5217792ed0dbf132174250ea81ca2e3dd7b60f1", "patch": "@@ -1286,16 +1286,13 @@ unsafe impl<'scope, T: Sync> Sync for Packet<'scope, T> {}\n \n impl<'scope, T> Drop for Packet<'scope, T> {\n     fn drop(&mut self) {\n+        // Book-keeping so the scope knows when it's done.\n         if let Some(scope) = self.scope {\n             // If this packet was for a thread that ran in a scope, the thread\n-            // panicked, and nobody consumed the panic payload, we put the\n-            // panic payload in the scope so it can re-throw it, if it didn't\n-            // already capture any panic yet.\n-            if let Some(Err(e)) = self.result.get_mut().take() {\n-                scope.panic_payload.lock().unwrap().get_or_insert(e);\n-            }\n-            // Book-keeping so the scope knows when it's done.\n-            scope.decrement_n_running_threads();\n+            // panicked, and nobody consumed the panic payload, we make sure\n+            // the scope function will panic.\n+            let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));\n+            scope.decrement_n_running_threads(unhandled_panic);\n         }\n     }\n }"}, {"sha": "f9b056dcd4658bb7cd5e90fdacd594c7e01f315b", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f5217792ed0dbf132174250ea81ca2e3dd7b60f1/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5217792ed0dbf132174250ea81ca2e3dd7b60f1/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=f5217792ed0dbf132174250ea81ca2e3dd7b60f1", "patch": "@@ -1,11 +1,10 @@\n use super::{current, park, Builder, JoinInner, Result, Thread};\n-use crate::any::Any;\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-use crate::sync::{Arc, Mutex};\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use crate::sync::Arc;\n \n /// A scope to spawn scoped threads in.\n ///\n@@ -22,8 +21,8 @@ pub struct ScopedJoinHandle<'scope, T>(JoinInner<'scope, T>);\n \n pub(super) struct ScopeData {\n     n_running_threads: AtomicUsize,\n+    a_thread_panicked: AtomicBool,\n     main_thread: Thread,\n-    pub(super) panic_payload: Mutex<Option<Box<dyn Any + Send>>>,\n }\n \n impl ScopeData {\n@@ -32,11 +31,14 @@ impl ScopeData {\n         // chance it overflows to 0, which would result in unsoundness.\n         if self.n_running_threads.fetch_add(1, Ordering::Relaxed) == usize::MAX / 2 {\n             // This can only reasonably happen by mem::forget()'ing many many ScopedJoinHandles.\n-            self.decrement_n_running_threads();\n+            self.decrement_n_running_threads(false);\n             panic!(\"too many running threads in thread scope\");\n         }\n     }\n-    pub(super) fn decrement_n_running_threads(&self) {\n+    pub(super) fn decrement_n_running_threads(&self, panic: bool) {\n+        if panic {\n+            self.a_thread_panicked.store(true, Ordering::Relaxed);\n+        }\n         if self.n_running_threads.fetch_sub(1, Ordering::Release) == 1 {\n             self.main_thread.unpark();\n         }\n@@ -89,15 +91,16 @@ impl ScopeData {\n /// a.push(4);\n /// assert_eq!(x, a.len());\n /// ```\n+#[track_caller]\n pub fn scope<'env, F, T>(f: F) -> T\n where\n     F: FnOnce(&Scope<'env>) -> T,\n {\n-    let mut scope = Scope {\n+    let scope = Scope {\n         data: ScopeData {\n             n_running_threads: AtomicUsize::new(0),\n             main_thread: current(),\n-            panic_payload: Mutex::new(None),\n+            a_thread_panicked: AtomicBool::new(false),\n         },\n         env: PhantomData,\n     };\n@@ -110,21 +113,11 @@ where\n         park();\n     }\n \n-    // Throw any panic from `f` or from any panicked thread, or the return value of `f` otherwise.\n+    // Throw any panic from `f`, or the return value of `f` if no thread panicked.\n     match result {\n-        Err(e) => {\n-            // `f` itself panicked.\n-            resume_unwind(e);\n-        }\n-        Ok(result) => {\n-            if let Some(panic_payload) = scope.data.panic_payload.get_mut().unwrap().take() {\n-                // A thread panicked.\n-                resume_unwind(panic_payload);\n-            } else {\n-                // Nothing panicked.\n-                result\n-            }\n-        }\n+        Err(e) => resume_unwind(e),\n+        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) => panic!(\"a thread panicked\"),\n+        Ok(result) => result,\n     }\n }\n \n@@ -293,7 +286,8 @@ impl<'env> fmt::Debug for Scope<'env> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Scope\")\n             .field(\"n_running_threads\", &self.data.n_running_threads.load(Ordering::Relaxed))\n-            .field(\"panic_payload\", &self.data.panic_payload)\n+            .field(\"a_thread_panicked\", &self.data.a_thread_panicked)\n+            .field(\"main_thread\", &self.data.main_thread)\n             .finish_non_exhaustive()\n     }\n }"}]}