{"sha": "d4f9ec566249f88845c88c8b897097a262b4e0af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZjllYzU2NjI0OWY4ODg0NWM4OGM4Yjg5NzA5N2EyNjJiNGUwYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-08T08:21:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-08T08:21:44Z"}, "message": "Auto merge of #21565 - kmcallister:poison, r=alexcrichton\n\nI needed these to implement efficient poisoning in [seqloq](https://github.com/kmcallister/seqloq/tree/poison).", "tree": {"sha": "0b19bfaf039394010d7d95783b572cd1dfbe76ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b19bfaf039394010d7d95783b572cd1dfbe76ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4f9ec566249f88845c88c8b897097a262b4e0af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f9ec566249f88845c88c8b897097a262b4e0af", "html_url": "https://github.com/rust-lang/rust/commit/d4f9ec566249f88845c88c8b897097a262b4e0af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4f9ec566249f88845c88c8b897097a262b4e0af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdaf3a4393927ddfba071cfbfe86d95b68e7ae3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdaf3a4393927ddfba071cfbfe86d95b68e7ae3e", "html_url": "https://github.com/rust-lang/rust/commit/cdaf3a4393927ddfba071cfbfe86d95b68e7ae3e"}, {"sha": "7324c2cf4f09d44d1bde8c37716de9eca4aac565", "url": "https://api.github.com/repos/rust-lang/rust/commits/7324c2cf4f09d44d1bde8c37716de9eca4aac565", "html_url": "https://github.com/rust-lang/rust/commit/7324c2cf4f09d44d1bde8c37716de9eca4aac565"}], "stats": {"total": 52, "additions": 40, "deletions": 12}, "files": [{"sha": "d4d722cab3d929288aaea0d17989036cf21592f2", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=d4f9ec566249f88845c88c8b897097a262b4e0af", "patch": "@@ -16,7 +16,7 @@ use sys::time::SteadyTime;\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use time::Duration;\n-use sync::{mutex, MutexGuard};\n+use sync::{mutex, MutexGuard, PoisonError};\n \n /// A Condition Variable\n ///\n@@ -228,7 +228,7 @@ impl StaticCondvar {\n             mutex::guard_poison(&guard).get()\n         };\n         if poisoned {\n-            Err(poison::new_poison_error(guard))\n+            Err(PoisonError::new(guard))\n         } else {\n             Ok(guard)\n         }\n@@ -249,7 +249,7 @@ impl StaticCondvar {\n             (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n-            Err(poison::new_poison_error((guard, success)))\n+            Err(PoisonError::new((guard, success)))\n         } else {\n             Ok((guard, success))\n         }\n@@ -276,23 +276,23 @@ impl StaticCondvar {\n         while !f(guard_result\n                     .as_mut()\n                     .map(|g| &mut **g)\n-                    .map_err(|e| poison::new_poison_error(&mut **e.get_mut()))) {\n+                    .map_err(|e| PoisonError::new(&mut **e.get_mut()))) {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n             let (new_guard_result, no_timeout) = match self.wait_timeout(guard, dur - consumed) {\n                 Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n                 Err(err) => {\n                     let (new_guard, no_timeout) = err.into_inner();\n-                    (Err(poison::new_poison_error(new_guard)), no_timeout)\n+                    (Err(PoisonError::new(new_guard)), no_timeout)\n                 }\n             };\n             guard_result = new_guard_result;\n             if !no_timeout {\n                 let result = f(guard_result\n                                     .as_mut()\n                                     .map(|g| &mut **g)\n-                                    .map_err(|e| poison::new_poison_error(&mut **e.get_mut())));\n+                                    .map_err(|e| PoisonError::new(&mut **e.get_mut())));\n                 return poison::map_result(guard_result, |g| (g, result));\n             }\n         }"}, {"sha": "74692c1273c2790130597171adfc86a679cd6e8f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=d4f9ec566249f88845c88c8b897097a262b4e0af", "patch": "@@ -228,6 +228,17 @@ impl<T: Send> Mutex<T> {\n             Err(TryLockError::WouldBlock)\n         }\n     }\n+\n+    /// Determine whether the lock is poisoned.\n+    ///\n+    /// If another thread is active, the lock can still become poisoned at any\n+    /// time.  You should not trust a `false` value for program correctness\n+    /// without additional synchronization.\n+    #[inline]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_poisoned(&self) -> bool {\n+        self.inner.poison.get()\n+    }\n }\n \n #[unsafe_destructor]\n@@ -458,12 +469,14 @@ mod test {\n     #[test]\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1));\n+        assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n         let _ = Thread::scoped(move|| {\n             let lock = arc2.lock().unwrap();\n             assert_eq!(*lock, 2);\n         }).join();\n         assert!(arc.lock().is_err());\n+        assert!(arc.is_poisoned());\n     }\n \n     #[test]"}, {"sha": "a93bd31f5ae38ab58d59ad9569807ca33d747729", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=d4f9ec566249f88845c88c8b897097a262b4e0af", "patch": "@@ -23,7 +23,7 @@ impl Flag {\n     pub fn borrow(&self) -> LockResult<Guard> {\n         let ret = Guard { panicking: Thread::panicking() };\n         if unsafe { *self.failed.get() } {\n-            Err(new_poison_error(ret))\n+            Err(PoisonError::new(ret))\n         } else {\n             Ok(ret)\n         }\n@@ -110,6 +110,12 @@ impl<T> Error for PoisonError<T> {\n }\n \n impl<T> PoisonError<T> {\n+    /// Create a `PoisonError`.\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn new(guard: T) -> PoisonError<T> {\n+        PoisonError { guard: guard }\n+    }\n+\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n     #[unstable(feature = \"std_misc\")]\n@@ -171,15 +177,11 @@ impl<T> Error for TryLockError<T> {\n     }\n }\n \n-pub fn new_poison_error<T>(guard: T) -> PoisonError<T> {\n-    PoisonError { guard: guard }\n-}\n-\n pub fn map_result<T, U, F>(result: LockResult<T>, f: F)\n                            -> LockResult<U>\n                            where F: FnOnce(T) -> U {\n     match result {\n         Ok(t) => Ok(f(t)),\n-        Err(PoisonError { guard }) => Err(new_poison_error(f(guard)))\n+        Err(PoisonError { guard }) => Err(PoisonError::new(f(guard)))\n     }\n }"}, {"sha": "c4f1f2ccadddd034038a3e62c77d3e991c642e14", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f9ec566249f88845c88c8b897097a262b4e0af/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=d4f9ec566249f88845c88c8b897097a262b4e0af", "patch": "@@ -237,6 +237,17 @@ impl<T: Send + Sync> RwLock<T> {\n             Err(TryLockError::WouldBlock)\n         }\n     }\n+\n+    /// Determine whether the lock is poisoned.\n+    ///\n+    /// If another thread is active, the lock can still become poisoned at any\n+    /// time.  You should not trust a `false` value for program correctness\n+    /// without additional synchronization.\n+    #[inline]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_poisoned(&self) -> bool {\n+        self.inner.poison.get()\n+    }\n }\n \n #[unsafe_destructor]\n@@ -451,12 +462,14 @@ mod tests {\n     #[test]\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RwLock::new(1));\n+        assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::scoped(move|| {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n         assert!(arc.write().is_err());\n+        assert!(arc.is_poisoned());\n     }\n \n     #[test]"}]}