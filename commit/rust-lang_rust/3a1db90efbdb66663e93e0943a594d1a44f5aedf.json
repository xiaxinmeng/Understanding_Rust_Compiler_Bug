{"sha": "3a1db90efbdb66663e93e0943a594d1a44f5aedf", "node_id": "C_kwDOAAsO6NoAKDNhMWRiOTBlZmJkYjY2NjYzZTkzZTA5NDNhNTk0ZDFhNDRmNWFlZGY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-19T09:42:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-19T09:42:14Z"}, "message": "Rollup merge of #91278 - SparrowLii:place, r=spastorino\n\nUse iterator instead of recursion in `codegen_place`\n\nThis PR fixes the FIXME in `codegen_place` about using iterator instead of recursion when processing the `projection` field in `mir::PlaceRef`. At the same time, it also reduces the right drift.", "tree": {"sha": "5f3928fe5542bfde5560ba96a02bdac4b8c8f224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f3928fe5542bfde5560ba96a02bdac4b8c8f224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a1db90efbdb66663e93e0943a594d1a44f5aedf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh59z2CRBK7hj4Ov3rIwAAtgAIAAU+IjDsRTLFV8nVfflDq+iz\niF+tX6/wQtGJgQjXY/ZNpQXVFdOBLFAObRplQS6wtNu9tdNznuDbkxShPs9F8X28\nQH76YpekI1ouQZndiXnM0nvFm1vkGDUD5GDSOrfZHuVwyYhYgEl9ROCh0k5pF23e\nhj3ws4Z2LJhUy/hw1tA1ZZetX3AR62TMaqV6/rtUjHiowNvILFSClH2MfMnzZLIq\nGUP+BzY+tGI1B+C2/G+cfJQhsFXGURolFu4fqWuj/x60W+qEUYMQm36UBw1GbZW8\nz8pOJNOVoMiLy/gUQgGP9oFh4Hy/7GfUKBWxRvCUw4hu0Z6tTlJ465+H40sr+KA=\n=vaDG\n-----END PGP SIGNATURE-----\n", "payload": "tree 5f3928fe5542bfde5560ba96a02bdac4b8c8f224\nparent 2a4381d8eaad4f9f0eb5a4e624e7b154640690f1\nparent 61ff847203d6491f13782b0f6e461b593afc7a0d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642585334 +0100\ncommitter GitHub <noreply@github.com> 1642585334 +0100\n\nRollup merge of #91278 - SparrowLii:place, r=spastorino\n\nUse iterator instead of recursion in `codegen_place`\n\nThis PR fixes the FIXME in `codegen_place` about using iterator instead of recursion when processing the `projection` field in `mir::PlaceRef`. At the same time, it also reduces the right drift.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1db90efbdb66663e93e0943a594d1a44f5aedf", "html_url": "https://github.com/rust-lang/rust/commit/3a1db90efbdb66663e93e0943a594d1a44f5aedf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a1db90efbdb66663e93e0943a594d1a44f5aedf/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a4381d8eaad4f9f0eb5a4e624e7b154640690f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4381d8eaad4f9f0eb5a4e624e7b154640690f1", "html_url": "https://github.com/rust-lang/rust/commit/2a4381d8eaad4f9f0eb5a4e624e7b154640690f1"}, {"sha": "61ff847203d6491f13782b0f6e461b593afc7a0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/61ff847203d6491f13782b0f6e461b593afc7a0d", "html_url": "https://github.com/rust-lang/rust/commit/61ff847203d6491f13782b0f6e461b593afc7a0d"}], "stats": {"total": 143, "additions": 67, "deletions": 76}, "files": [{"sha": "c21d19a62279ff4aa35435c1ac392d63378b905c", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db90efbdb66663e93e0943a594d1a44f5aedf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db90efbdb66663e93e0943a594d1a44f5aedf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=3a1db90efbdb66663e93e0943a594d1a44f5aedf", "patch": "@@ -429,87 +429,78 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        let result = match place_ref {\n-            mir::PlaceRef { local, projection: [] } => match self.locals[local] {\n-                LocalRef::Place(place) => {\n-                    return place;\n-                }\n-                LocalRef::UnsizedPlace(place) => {\n-                    return bx.load_operand(place).deref(cx);\n-                }\n-                LocalRef::Operand(..) => {\n+        let mut base = 0;\n+        let mut cg_base = match self.locals[place_ref.local] {\n+            LocalRef::Place(place) => place,\n+            LocalRef::UnsizedPlace(place) => bx.load_operand(place).deref(cx),\n+            LocalRef::Operand(..) => {\n+                if let Some(elem) = place_ref\n+                    .projection\n+                    .iter()\n+                    .enumerate()\n+                    .find(|elem| matches!(elem.1, mir::ProjectionElem::Deref))\n+                {\n+                    base = elem.0 + 1;\n+                    self.codegen_consume(\n+                        bx,\n+                        mir::PlaceRef { projection: &place_ref.projection[..elem.0], ..place_ref },\n+                    )\n+                    .deref(bx.cx())\n+                } else {\n                     bug!(\"using operand local {:?} as place\", place_ref);\n                 }\n-            },\n-            mir::PlaceRef { local, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n-                // Load the pointer from its location.\n-                self.codegen_consume(bx, mir::PlaceRef { local, projection: proj_base })\n-                    .deref(bx.cx())\n             }\n-            mir::PlaceRef { local, projection: &[ref proj_base @ .., elem] } => {\n-                // FIXME turn this recursion into iteration\n-                let cg_base =\n-                    self.codegen_place(bx, mir::PlaceRef { local, projection: proj_base });\n-\n-                match elem {\n-                    mir::ProjectionElem::Deref => bug!(),\n-                    mir::ProjectionElem::Field(ref field, _) => {\n-                        cg_base.project_field(bx, field.index())\n-                    }\n-                    mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::from(index));\n-                        let index = self.codegen_operand(bx, index);\n-                        let llindex = index.immediate();\n-                        cg_base.project_index(bx, llindex)\n-                    }\n-                    mir::ProjectionElem::ConstantIndex {\n-                        offset,\n-                        from_end: false,\n-                        min_length: _,\n-                    } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n-                        cg_base.project_index(bx, lloffset)\n-                    }\n-                    mir::ProjectionElem::ConstantIndex {\n-                        offset,\n-                        from_end: true,\n-                        min_length: _,\n-                    } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n-                        let lllen = cg_base.len(bx.cx());\n-                        let llindex = bx.sub(lllen, lloffset);\n-                        cg_base.project_index(bx, llindex)\n-                    }\n-                    mir::ProjectionElem::Subslice { from, to, from_end } => {\n-                        let mut subslice =\n-                            cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n-                        let projected_ty =\n-                            PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n-                        subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n-\n-                        if subslice.layout.is_unsized() {\n-                            assert!(from_end, \"slice subslices should be `from_end`\");\n-                            subslice.llextra = Some(bx.sub(\n-                                cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((from as u64) + (to as u64)),\n-                            ));\n-                        }\n-\n-                        // Cast the place pointer type to the new\n-                        // array or slice type (`*[%_; new_len]`).\n-                        subslice.llval = bx.pointercast(\n-                            subslice.llval,\n-                            bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n-                        );\n-\n-                        subslice\n+        };\n+        for elem in place_ref.projection[base..].iter() {\n+            cg_base = match elem.clone() {\n+                mir::ProjectionElem::Deref => bx.load_operand(cg_base).deref(bx.cx()),\n+                mir::ProjectionElem::Field(ref field, _) => {\n+                    cg_base.project_field(bx, field.index())\n+                }\n+                mir::ProjectionElem::Index(index) => {\n+                    let index = &mir::Operand::Copy(mir::Place::from(index));\n+                    let index = self.codegen_operand(bx, index);\n+                    let llindex = index.immediate();\n+                    cg_base.project_index(bx, llindex)\n+                }\n+                mir::ProjectionElem::ConstantIndex { offset, from_end: false, min_length: _ } => {\n+                    let lloffset = bx.cx().const_usize(offset as u64);\n+                    cg_base.project_index(bx, lloffset)\n+                }\n+                mir::ProjectionElem::ConstantIndex { offset, from_end: true, min_length: _ } => {\n+                    let lloffset = bx.cx().const_usize(offset as u64);\n+                    let lllen = cg_base.len(bx.cx());\n+                    let llindex = bx.sub(lllen, lloffset);\n+                    cg_base.project_index(bx, llindex)\n+                }\n+                mir::ProjectionElem::Subslice { from, to, from_end } => {\n+                    let mut subslice = cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n+                    let projected_ty =\n+                        PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem.clone()).ty;\n+                    subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n+\n+                    if subslice.layout.is_unsized() {\n+                        assert!(from_end, \"slice subslices should be `from_end`\");\n+                        subslice.llextra = Some(bx.sub(\n+                            cg_base.llextra.unwrap(),\n+                            bx.cx().const_usize((from as u64) + (to as u64)),\n+                        ));\n                     }\n-                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n+\n+                    // Cast the place pointer type to the new\n+                    // array or slice type (`*[%_; new_len]`).\n+                    subslice.llval = bx.pointercast(\n+                        subslice.llval,\n+                        bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n+                    );\n+\n+                    subslice\n                 }\n-            }\n-        };\n-        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, result);\n-        result\n+                mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n+            };\n+        }\n+        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, cg_base);\n+        cg_base\n     }\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {"}]}