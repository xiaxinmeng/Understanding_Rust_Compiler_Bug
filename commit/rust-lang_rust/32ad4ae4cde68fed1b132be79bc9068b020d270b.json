{"sha": "32ad4ae4cde68fed1b132be79bc9068b020d270b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYWQ0YWU0Y2RlNjhmZWQxYjEzMmJlNzliYzkwNjhiMDIwZDI3MGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-14T03:08:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-14T19:36:55Z"}, "message": "librustc: Require the #[derivable] attribute, remove the significance of \"impl Foo : Bar;\", and allow only a subset of methods in a trait to be derived. r=brson", "tree": {"sha": "174cee72ef970f110f1cf22a190641b0c834f264", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/174cee72ef970f110f1cf22a190641b0c834f264"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32ad4ae4cde68fed1b132be79bc9068b020d270b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32ad4ae4cde68fed1b132be79bc9068b020d270b", "html_url": "https://github.com/rust-lang/rust/commit/32ad4ae4cde68fed1b132be79bc9068b020d270b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32ad4ae4cde68fed1b132be79bc9068b020d270b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e14ada4f6782f1379abe498b2b2d9681f489e26", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e14ada4f6782f1379abe498b2b2d9681f489e26", "html_url": "https://github.com/rust-lang/rust/commit/3e14ada4f6782f1379abe498b2b2d9681f489e26"}], "stats": {"total": 607, "additions": 335, "deletions": 272}, "files": [{"sha": "da3247de3b118675683c54c7fa493936e14d70d1", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -83,9 +83,9 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n fn fold_item_underscore(cx: ctxt, item: ast::item_,\n                         fld: fold::ast_fold) -> ast::item_ {\n     let item = match item {\n-        ast::item_impl(a, b, c, Some(methods)) => {\n+        ast::item_impl(a, b, c, methods) => {\n             let methods = methods.filter(|m| method_in_cfg(cx, *m) );\n-            ast::item_impl(a, b, c, Some(methods))\n+            ast::item_impl(a, b, c, methods)\n         }\n         ast::item_trait(a, b, ref methods) => {\n             let methods = methods.filter(|m| trait_method_in_cfg(cx, m) );"}, {"sha": "98c6688f03cd1bc160163f46d4d668b5508110fd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -715,7 +715,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, opt_trait, ty, methods_opt) => {\n+      item_impl(tps, opt_trait, ty, methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -732,13 +732,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n             }\n             _ => {}\n         }\n-        for methods_opt.each |methods| {\n-            for methods.each |m| {\n-                ebml_w.start_tag(tag_item_impl_method);\n-                let method_def_id = local_def(m.id);\n-                ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n-                ebml_w.end_tag();\n-            }\n+        for methods.each |m| {\n+            ebml_w.start_tag(tag_item_impl_method);\n+            let method_def_id = local_def(m.id);\n+            ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n+            ebml_w.end_tag();\n         }\n         do opt_trait.iter() |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait);\n@@ -748,13 +746,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n \n         let impl_path = vec::append_one(path,\n                                         ast_map::path_name(item.ident));\n-        for methods_opt.each |methods| {\n-            for methods.each |m| {\n-                index.push({val: m.id, pos: ebml_w.writer.tell()});\n-                encode_info_for_method(ecx, ebml_w, impl_path,\n-                                       should_inline(m.attrs), item.id, *m,\n-                                       vec::append(tps, m.tps));\n-            }\n+        for methods.each |m| {\n+            index.push({val: m.id, pos: ebml_w.writer.tell()});\n+            encode_info_for_method(ecx, ebml_w, impl_path,\n+                                   should_inline(m.attrs), item.id, *m,\n+                                   vec::append(tps, m.tps));\n         }\n       }\n       item_trait(tps, traits, ms) => {"}, {"sha": "4d435bea7a264f359269411f82ddf5a7550955b5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1223,7 +1223,7 @@ impl Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_impl(_, trait_ref_opt, ty, methods_opt) => {\n+            item_impl(_, trait_ref_opt, ty, methods) => {\n                 // If this implements an anonymous trait and it has static\n                 // methods, then add all the static methods within to a new\n                 // module, if the type was defined within this module.\n@@ -1234,12 +1234,10 @@ impl Resolver {\n \n                 // Bail out early if there are no static methods.\n                 let mut has_static_methods = false;\n-                for methods_opt.each |methods| {\n-                    for methods.each |method| {\n-                        match method.self_ty.node {\n-                            sty_static => has_static_methods = true,\n-                            _ => {}\n-                        }\n+                for methods.each |method| {\n+                    match method.self_ty.node {\n+                        sty_static => has_static_methods = true,\n+                        _ => {}\n                     }\n                 }\n \n@@ -1266,26 +1264,24 @@ impl Resolver {\n                             name_bindings.get_module());\n \n                         // For each static method...\n-                        for methods_opt.each |methods| {\n-                            for methods.each |method| {\n-                                match method.self_ty.node {\n-                                    sty_static => {\n-                                        // Add the static method to the\n-                                        // module.\n-                                        let ident = method.ident;\n-                                        let (method_name_bindings, _) =\n-                                            self.add_child(\n-                                                ident,\n-                                                new_parent,\n-                                                ForbidDuplicateValues,\n-                                                method.span);\n-                                        let def = def_fn(local_def(method.id),\n-                                                         method.purity);\n-                                        method_name_bindings.define_value(\n-                                            Public, def, method.span);\n-                                    }\n-                                    _ => {}\n+                        for methods.each |method| {\n+                            match method.self_ty.node {\n+                                sty_static => {\n+                                    // Add the static method to the\n+                                    // module.\n+                                    let ident = method.ident;\n+                                    let (method_name_bindings, _) =\n+                                        self.add_child(\n+                                            ident,\n+                                            new_parent,\n+                                            ForbidDuplicateValues,\n+                                            method.span);\n+                                    let def = def_fn(local_def(method.id),\n+                                                     method.purity);\n+                                    method_name_bindings.define_value(\n+                                        Public, def, method.span);\n                                 }\n+                                _ => {}\n                             }\n                         }\n                     }\n@@ -3553,14 +3549,16 @@ impl Resolver {\n                 }\n             }\n \n-            item_impl(type_parameters, implemented_traits, self_type,\n-                      methods_opt) => {\n+            item_impl(type_parameters,\n+                      implemented_traits,\n+                      self_type,\n+                      methods) => {\n                 self.resolve_implementation(item.id,\n                                             item.span,\n                                             type_parameters,\n                                             implemented_traits,\n                                             self_type,\n-                                            methods_opt,\n+                                            methods,\n                                             visitor);\n             }\n \n@@ -3988,7 +3986,7 @@ impl Resolver {\n                               type_parameters: ~[ty_param],\n                               opt_trait_reference: Option<@trait_ref>,\n                               self_type: @Ty,\n-                              opt_methods: Option<~[@method]>,\n+                              methods: ~[@method],\n                               visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = type_parameters.len();\n@@ -4027,16 +4025,15 @@ impl Resolver {\n             // Resolve the self type.\n             self.resolve_type(self_type, visitor);\n \n-            for opt_methods.each |methods| {\n-                for methods.each |method| {\n-                    // We also need a new scope for the method-specific\n-                    // type parameters.\n-                    self.resolve_method(MethodRibKind(\n-                        id,\n-                        Provided(method.id)),\n-                        *method,\n-                        outer_type_parameter_count,\n-                        visitor);\n+            for methods.each |method| {\n+                // We also need a new scope for the method-specific\n+                // type parameters.\n+                self.resolve_method(MethodRibKind(\n+                    id,\n+                    Provided(method.id)),\n+                    *method,\n+                    outer_type_parameter_count,\n+                    visitor);\n /*\n                     let borrowed_type_parameters = &method.tps;\n                     self.resolve_function(MethodRibKind(\n@@ -4053,7 +4050,6 @@ impl Resolver {\n                                           NoCaptureClause,\n                                           visitor);\n */\n-                }\n             }\n \n             // Restore the original trait references."}, {"sha": "c14bc6772b4ee7644666ef3a22a8f89ac6685310", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1854,17 +1854,13 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _, _, ms_opt) => {\n-        match ms_opt {\n-            None => {\n-                deriving::trans_deriving_impl(ccx, *path, item.ident, tps,\n-                                              item.id);\n-            }\n-            Some(ms) => {\n-                meth::trans_impl(ccx, *path, item.ident, ms, tps, None,\n-                                 item.id);\n-            }\n-        }\n+      ast::item_impl(tps, _, _, ms) => {\n+        // This call will do nothing if there are no derivable methods.\n+        deriving::trans_deriving_impl(ccx, *path, item.ident, tps,\n+                                      item.id);\n+\n+        meth::trans_impl(ccx, *path, item.ident, ms, tps, None,\n+                         item.id);\n       }\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);"}, {"sha": "7fe4a0b0e4620a3ebf66fe78e19b4a22c24c8854", "filename": "src/librustc/middle/trans/deriving.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -53,37 +53,43 @@ impl DerivingKind {\n     }\n }\n \n-/// The main \"translation\" pass for automatically-derived impls. Generates\n-/// code for monomorphic methods only. Other methods will be generated when\n-/// they are invoked with specific type parameters; see\n+/// The main \"translation\" pass for the automatically-derived methods in\n+/// an impl. Generates code for monomorphic methods only. Other methods will\n+/// be generated when they are invoked with specific type parameters; see\n /// `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n-pub fn trans_deriving_impl(ccx: @crate_ctxt, _path: path, _name: ident,\n-                           tps: ~[ty_param], id: node_id) {\n+pub fn trans_deriving_impl(ccx: @crate_ctxt,\n+                           _path: path,\n+                           _name: ident,\n+                           tps: ~[ty_param],\n+                           id: node_id) {\n     let _icx = ccx.insn_ctxt(\"deriving::trans_deriving_impl\");\n     if tps.len() > 0 { return; }\n \n     let impl_def_id = local_def(id);\n     let self_ty = ty::lookup_item_type(ccx.tcx, impl_def_id);\n-    let method_dids = ccx.tcx.automatically_derived_methods_for_impl.get(\n-        impl_def_id);\n-\n-    for method_dids.each |method_did| {\n-        let kind = DerivingKind::of_item(ccx, *method_did);\n-        let llfn = get_item_val(ccx, method_did.node);\n-        match ty::get(self_ty.ty).sty {\n-            ty::ty_class(*) => {\n-                trans_deriving_struct_method(ccx, llfn, impl_def_id,\n-                                             self_ty.ty, kind);\n-            }\n-            ty::ty_enum(*) => {\n-                trans_deriving_enum_method(ccx, llfn, impl_def_id,\n-                                           self_ty.ty, kind);\n-            }\n-            _ => {\n-                ccx.tcx.sess.bug(~\"translation of non-struct deriving \\\n-                                   method\");\n+\n+    match ccx.tcx.automatically_derived_methods_for_impl.find(impl_def_id) {\n+        Some(copy method_dids) => {\n+            for method_dids.each |method_did| {\n+                let kind = DerivingKind::of_item(ccx, *method_did);\n+                let llfn = get_item_val(ccx, method_did.node);\n+                match ty::get(self_ty.ty).sty {\n+                    ty::ty_class(*) => {\n+                        trans_deriving_struct_method(ccx, llfn, impl_def_id,\n+                                                     self_ty.ty, kind);\n+                    }\n+                    ty::ty_enum(*) => {\n+                        trans_deriving_enum_method(ccx, llfn, impl_def_id,\n+                                                   self_ty.ty, kind);\n+                    }\n+                    _ => {\n+                        ccx.tcx.sess.bug(~\"translation of non-struct \\\n+                                           deriving method\");\n+                    }\n+                }\n             }\n         }\n+        None => {}  // Nothing to do.\n     }\n }\n "}, {"sha": "c64c8554718fa7beb47e932faed04ea96a8b4fe9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -306,8 +306,7 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(impl_id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, _, _, Some(ms)), _},\n-                             _) => {\n+          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n             method_from_methods(ms, name)\n           }\n           ast_map::node_item(@{node:"}, {"sha": "a99ef96b2544a80e2732dc919402f914615bf601", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -90,14 +90,12 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             traverse_inline_body(cx, blk);\n         }\n       }\n-      item_impl(tps, _, _, ms_opt) => {\n-        for ms_opt.each |ms| {\n-            for vec::each(*ms) |m| {\n-                if tps.len() > 0u || m.tps.len() > 0u ||\n-                   attr::find_inline_attr(m.attrs) != attr::ia_none {\n-                    cx.rmap.insert(m.id, ());\n-                    traverse_inline_body(cx, m.body);\n-                }\n+      item_impl(tps, _, _, ms) => {\n+        for vec::each(ms) |m| {\n+            if tps.len() > 0u || m.tps.len() > 0u ||\n+               attr::find_inline_attr(m.attrs) != attr::ia_none {\n+                cx.rmap.insert(m.id, ());\n+                traverse_inline_body(cx, m.body);\n             }\n         }\n       }"}, {"sha": "938f6c34ea061883aabae54368e07d4887371861", "filename": "src/librustc/middle/typeck/check.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -498,15 +498,13 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_fn(decl, _, _, body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n-      ast::item_impl(_, _, ty, ms_opt) => {\n+      ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n-        for ms_opt.each |ms| {\n-            for ms.each |m| {\n-                check_method(ccx, *m, self_ty, local_def(it.id));\n-            }\n+        for ms.each |m| {\n+            check_method(ccx, *m, self_ty, local_def(it.id));\n         }\n       }\n       ast::item_trait(_, _, trait_methods) => {"}, {"sha": "9fc7814422f8f717e624224f15fcfbec7eddd9c9", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 77, "deletions": 29, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -25,6 +25,7 @@ use syntax::ast::{item_trait, item_ty, local_crate, method, node_id};\n use syntax::ast::{trait_ref};\n use syntax::ast_map::node_item;\n use syntax::ast_util::{def_id_of_def, dummy_sp};\n+use syntax::attr;\n use syntax::codemap::span;\n use syntax::visit::{default_simple_visitor, default_visitor};\n use syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n@@ -613,14 +614,67 @@ impl CoherenceChecker {\n         return trait_id;\n     }\n \n+    /// Returns true if the method has been marked with the #[derivable]\n+    /// attribute and false otherwise.\n+    fn method_is_derivable(method_def_id: ast::def_id) -> bool {\n+        if method_def_id.crate == local_crate {\n+            match self.crate_context.tcx.items.find(method_def_id.node) {\n+                Some(ast_map::node_trait_method(trait_method, _, _)) => {\n+                    match *trait_method {\n+                        ast::required(ty_method) => {\n+                            attr::attrs_contains_name(ty_method.attrs,\n+                                                      ~\"derivable\")\n+                        }\n+                        ast::provided(method) => {\n+                            attr::attrs_contains_name(method.attrs,\n+                                                      ~\"derivable\")\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    self.crate_context.tcx.sess.bug(~\"method_is_derivable(): \\\n+                                                      def ID passed in \\\n+                                                      wasn't a trait method\")\n+                }\n+            }\n+        } else {\n+            false   // XXX: Unimplemented.\n+        }\n+    }\n+\n     fn add_automatically_derived_methods_from_trait(\n             all_methods: &mut ~[@MethodInfo],\n             trait_did: def_id,\n             self_ty: ty::t,\n-            impl_did: def_id) {\n+            impl_did: def_id,\n+            trait_ref_span: span) {\n         let tcx = self.crate_context.tcx;\n+\n+        // Make a set of all the method names that this implementation and\n+        // trait provided so that we don't try to automatically derive\n+        // implementations for them.\n+        let mut provided_names = send_map::linear::LinearMap();\n+        for uint::range(0, all_methods.len()) |i| {\n+            provided_names.insert(all_methods[i].ident, ());\n+        }\n+        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+            provided_names.insert(*ident, ());\n+        }\n+\n         let new_method_dids = dvec::DVec();\n         for (*ty::trait_methods(tcx, trait_did)).each |method| {\n+            // Check to see whether we need to derive this method. We need to\n+            // derive a method only if and only if neither the trait nor the\n+            // implementation we're considering provided a body.\n+            if provided_names.contains_key(&method.ident) { loop; }\n+\n+            if !self.method_is_derivable(method.def_id) {\n+                tcx.sess.span_err(trait_ref_span,\n+                                  fmt!(\"missing method `%s`\",\n+                                       tcx.sess.str_of(method.ident)));\n+                loop;\n+            }\n+\n             // Generate a def ID for each node.\n             let new_def_id = local_def(tcx.sess.next_node_id());\n             let method_info = @{\n@@ -656,8 +710,10 @@ impl CoherenceChecker {\n         }\n \n         let new_method_dids = @dvec::unwrap(move new_method_dids);\n-        tcx.automatically_derived_methods_for_impl.insert(impl_did,\n-                                                          new_method_dids);\n+        if new_method_dids.len() > 0 {\n+            tcx.automatically_derived_methods_for_impl.insert(\n+                impl_did, new_method_dids);\n+        }\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n@@ -674,36 +730,28 @@ impl CoherenceChecker {\n         }\n \n         match item.node {\n-            item_impl(_, trait_refs, _, ast_methods_opt) => {\n+            item_impl(_, trait_refs, _, ast_methods) => {\n                 let mut methods = ~[];\n+                for ast_methods.each |ast_method| {\n+                    methods.push(method_to_MethodInfo(*ast_method));\n+                }\n \n-                match ast_methods_opt {\n-                    Some(ast_methods) => {\n-                        for ast_methods.each |ast_method| {\n-                            methods.push(method_to_MethodInfo(*ast_method));\n-                        }\n-                    }\n-                    None => {\n-                        // This is a \"deriving\" impl. For each trait,\n-                        // collect all the \"required\" methods and add\n-                        // them to the Impl structure.\n-                        let tcx = self.crate_context.tcx;\n-                        let self_ty = ty::lookup_item_type(\n-                            tcx, local_def(item.id));\n-                        for trait_refs.each |trait_ref| {\n-                            let trait_did =\n-                                self.trait_ref_to_trait_def_id(\n-                                    *trait_ref);\n-                            self.add_automatically_derived_methods_from_trait(\n-                                    &mut methods,\n-                                    trait_did,\n-                                    self_ty.ty,\n-                                    local_def(item.id));\n-                        }\n-                    }\n+                // Now search for methods that need to be automatically\n+                // derived.\n+                let tcx = self.crate_context.tcx;\n+                let self_ty = ty::lookup_item_type(tcx, local_def(item.id));\n+                for trait_refs.each |trait_ref| {\n+                    let trait_did =\n+                        self.trait_ref_to_trait_def_id(*trait_ref);\n+                    self.add_automatically_derived_methods_from_trait(\n+                            &mut methods,\n+                            trait_did,\n+                            self_ty.ty,\n+                            local_def(item.id),\n+                            trait_ref.path.span);\n                 }\n \n-                // For each trait that the impl implements, see what\n+                // For each trait that the impl implements, see which\n                 // methods are provided.  For each of those methods,\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait."}, {"sha": "4faf34b3078ce877a18a2c1334b8471c928414eb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -451,24 +451,10 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n             }\n             None => {\n                 // If we couldn't find an implementation for trait_m in\n-                // the impl, then see if there was a default\n-                // implementation in the trait itself.  If not, raise a\n-                // \"missing method\" error.\n-\n-                let provided_methods = ty::provided_trait_methods(tcx, did);\n-                match vec::find(provided_methods, |provided_method|\n-                                *provided_method == trait_m.ident) {\n-                    Some(_) => {\n-                        // If there's a provided method with the name we\n-                        // want, then we're fine; nothing else to do.\n-                    }\n-                    None => {\n-                        tcx.sess.span_err(\n-                            a_trait_ty.path.span,\n-                            fmt!(\"missing method `%s`\",\n-                                 tcx.sess.str_of(trait_m.ident)));\n-                    }\n-                }\n+                // the impl, then either this method has a default\n+                // implementation or we're using the trait-provided\n+                // version. Either way, we handle this later, during the\n+                // coherence phase.\n             }\n         } // match\n     } // |trait_m|\n@@ -532,7 +518,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         get_enum_variant_types(ccx, tpt.ty, enum_definition.variants,\n                                ty_params, rp);\n       }\n-      ast::item_impl(tps, trait_ref, selfty, ms_opt) => {\n+      ast::item_impl(tps, trait_ref, selfty, ms) => {\n         let i_bounds = ty_param_bounds(ccx, tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n@@ -541,21 +527,9 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                            region_param: rp,\n                            ty: selfty});\n \n-        match ms_opt {\n-            Some(ref ms) => {\n-                let cms = convert_methods(ccx, *ms, rp, i_bounds);\n-                for trait_ref.each |t| {\n-                    check_methods_against_trait(ccx, tps, rp, selfty, *t,\n-                                                cms);\n-                }\n-            }\n-            None => {\n-                // We still need to instantiate the trait ref here so that\n-                // metadata encoding will find the type.\n-                for trait_ref.each |trait_ref| {\n-                    let _ = instantiate_trait_ref(ccx, *trait_ref, rp);\n-                }\n-            }\n+        let cms = convert_methods(ccx, ms, rp, i_bounds);\n+        for trait_ref.each |t| {\n+            check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n         }\n       }\n       ast::item_trait(tps, supertraits, trait_methods) => {"}, {"sha": "197a06a1d972e06f7c743a6a46cc6ef58bc99d99", "filename": "src/librustc/middle/typeck/deriving.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -251,33 +251,40 @@ impl DerivingChecker {\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n                 match item.node {\n-                    item_impl(_, Some(trait_ref), _, None) => {\n-                        // XXX: This does not handle generic impls.\n-                        let superty = ty::lookup_item_type(\n-                            tcx, local_def(item.id)).ty;\n-                        match ty::get(superty).sty {\n-                            ty_enum(def_id, ref substs) => {\n-                                self.check_deriving_for_enum(\n-                                    def_id,\n-                                    substs,\n-                                    trait_ref,\n-                                    item.id,\n-                                    item.span);\n-                            }\n-                            ty_class(def_id, ref substs) => {\n-                                self.check_deriving_for_struct(\n-                                    def_id,\n-                                    substs,\n-                                    trait_ref,\n-                                    item.id,\n-                                    item.span);\n-                            }\n-                            _ => {\n-                                tcx.sess.span_err(item.span,\n-                                                  ~\"only enums and structs \\\n-                                                    may have implementations \\\n-                                                    automatically derived \\\n-                                                    for them\");\n+                    item_impl(_, Some(trait_ref), _, _) => {\n+                        // Determine whether there were any automatically-\n+                        // derived methods in this implementation.\n+                        let impl_did = local_def(item.id);\n+                        if tcx.automatically_derived_methods_for_impl.\n+                                contains_key(impl_did) {\n+                            // XXX: This does not handle generic impls.\n+                            let superty = ty::lookup_item_type(\n+                                tcx, local_def(item.id)).ty;\n+                            match ty::get(superty).sty {\n+                                ty_enum(def_id, ref substs) => {\n+                                    self.check_deriving_for_enum(\n+                                        def_id,\n+                                        substs,\n+                                        trait_ref,\n+                                        item.id,\n+                                        item.span);\n+                                }\n+                                ty_class(def_id, ref substs) => {\n+                                    self.check_deriving_for_struct(\n+                                        def_id,\n+                                        substs,\n+                                        trait_ref,\n+                                        item.id,\n+                                        item.span);\n+                                }\n+                                _ => {\n+                                    tcx.sess.span_err(item.span,\n+                                                      ~\"only enums and \\\n+                                                        structs may have \\\n+                                                        implementations \\\n+                                                        automatically \\\n+                                                        derived for them\");\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "da90dccc228bb400931774dd4deb6f076bc01cc7", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -221,17 +221,12 @@ fn merge_method_attrs(\n             })\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, methods_opt), _\n+            node: ast::item_impl(_, _, _, methods), _\n           }, _) => {\n-            match methods_opt {\n-                None => ~[],\n-                Some(methods) => {\n-                    vec::map(methods, |method| {\n-                        (to_str(method.ident),\n-                         attr_parser::parse_desc(method.attrs))\n-                    })\n-                }\n-            }\n+            vec::map(methods, |method| {\n+                (to_str(method.ident),\n+                 attr_parser::parse_desc(method.attrs))\n+            })\n           }\n           _ => fail ~\"unexpected item\"\n         }"}, {"sha": "7b34a327bee248f29d74ba9bfcb27d8f062d989c", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -258,25 +258,20 @@ fn should_extract_trait_methods() {\n \n fn impldoc_from_impl(\n     itemdoc: doc::ItemDoc,\n-    methods_opt: Option<~[@ast::method]>\n+    methods: ~[@ast::method]\n ) -> doc::ImplDoc {\n     {\n         item: itemdoc,\n         trait_types: ~[],\n         self_ty: None,\n-        methods: match methods_opt {\n-            None => ~[],\n-            Some(methods) => {\n-                do vec::map(methods) |method| {\n-                    {\n-                        name: to_str(method.ident),\n-                        brief: None,\n-                        desc: None,\n-                        sections: ~[],\n-                        sig: None,\n-                        implementation: doc::Provided,\n-                    }\n-                }\n+        methods: do vec::map(methods) |method| {\n+            {\n+                name: to_str(method.ident),\n+                brief: None,\n+                desc: None,\n+                sections: ~[],\n+                sig: None,\n+                implementation: doc::Provided,\n             }\n         }\n     }"}, {"sha": "08ad3ea3ecf4c16a883c269134ce3a1de4014f2d", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -207,25 +207,20 @@ fn get_method_sig(\n             }\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, methods_opt), _\n+            node: ast::item_impl(_, _, _, methods), _\n           }, _) => {\n-            match methods_opt {\n-                None => fail ~\"no methods in this impl\",\n-                Some(methods) => {\n-                    match vec::find(methods, |method| {\n-                        to_str(method.ident) == method_name\n-                    }) {\n-                        Some(method) => {\n-                            Some(pprust::fun_to_str(\n-                                method.decl,\n-                                method.ident,\n-                                method.tps,\n-                                extract::interner()\n-                            ))\n-                        }\n-                        None => fail ~\"method not found\"\n-                    }\n+            match vec::find(methods, |method| {\n+                to_str(method.ident) == method_name\n+            }) {\n+                Some(method) => {\n+                    Some(pprust::fun_to_str(\n+                        method.decl,\n+                        method.ident,\n+                        method.tps,\n+                        extract::interner()\n+                    ))\n                 }\n+                None => fail ~\"method not found\"\n             }\n           }\n           _ => fail ~\"get_method_sig: item ID not bound to trait or impl\""}, {"sha": "148600d8d21e0d39000f78afe3b0d4995440e675", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1517,7 +1517,7 @@ enum item_ {\n     item_impl(~[ty_param],\n               Option<@trait_ref>, /* (optional) trait this impl implements */\n               @Ty, /* self */\n-              Option<~[@method]>),\n+              ~[@method]),\n     item_mac(mac),\n }\n "}, {"sha": "0d7b1f1e5c4060efd65183f17fe95ef4bd8e5f0e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -203,12 +203,10 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n-      item_impl(_, _, _, ms_opt) => {\n+      item_impl(_, _, _, ms) => {\n         let impl_did = ast_util::local_def(i.id);\n-        for ms_opt.each |ms| {\n-            for ms.each |m| {\n-                map_method(impl_did, extend(cx, i.ident), *m, cx);\n-            }\n+        for ms.each |m| {\n+            map_method(impl_did, extend(cx, i.ident), *m, cx);\n         }\n       }\n       item_enum(enum_definition, _) => {"}, {"sha": "f9fece0b5cbef4551168f9a478df4a9be97e7f48", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -398,7 +398,7 @@ fn mk_impl(\n         ident: ast::token::special_idents::clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, Some(~[f(ty)])),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n         vis: ast::public,\n         span: span,\n     }"}, {"sha": "4d51ecded015e347eab34d48e5d1b84f0f659840", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -249,13 +249,11 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             let struct_def = fold_struct_def(struct_def, fld);\n               item_class(struct_def, /* FIXME (#2543) */ copy typms)\n           }\n-          item_impl(tps, ifce, ty, ref methods_opt) => {\n+          item_impl(tps, ifce, ty, ref methods) => {\n               item_impl(fold_ty_params(tps, fld),\n                         ifce.map(|p| fold_trait_ref(*p, fld)),\n                         fld.fold_ty(ty),\n-                        option::map(methods_opt,\n-                                    |methods| vec::map(\n-                                        *methods, |x| fld.fold_method(*x))))\n+                        vec::map(*methods, |x| fld.fold_method(*x)))\n           }\n           item_trait(tps, traits, methods) => {\n               let methods = do methods.map |method| {"}, {"sha": "49c3d38ce554be7428e37204a639fa19f39d8bfd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -2687,19 +2687,15 @@ impl Parser {\n             None\n         };\n \n-        let meths_opt;\n-        if self.eat(token::SEMI) {\n-            meths_opt = None;\n-        } else {\n-            let mut meths = ~[];\n+        let mut meths = ~[];\n+        if !self.eat(token::SEMI) {\n             self.expect(token::LBRACE);\n             while !self.eat(token::RBRACE) {\n                 meths.push(self.parse_method());\n             }\n-            meths_opt = Some(move meths);\n         }\n \n-        (ident, item_impl(tps, opt_trait, ty, meths_opt), None)\n+        (ident, item_impl(tps, opt_trait, ty, meths), None)\n     }\n \n     // Instantiates ident <i> with references to <typarams> as arguments."}, {"sha": "267f0e7d5f2a1475e4ad3b318455bfc3c980b99f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -520,7 +520,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_struct(s, struct_def, tps, item.ident, item.span);\n       }\n \n-      ast::item_impl(tps, opt_trait, ty, methods_opt) => {\n+      ast::item_impl(tps, opt_trait, ty, methods) => {\n         head(s, visibility_qualified(item.vis, ~\"impl\"));\n         if tps.is_not_empty() {\n             print_type_params(s, tps);\n@@ -537,17 +537,14 @@ fn print_item(s: ps, &&item: @ast::item) {\n         };\n         space(s.s);\n \n-        match methods_opt {\n-            None => {\n-                word(s.s, ~\";\");\n-            }\n-            Some(methods) => {\n-                bopen(s);\n-                for methods.each |meth| {\n-                   print_method(s, *meth);\n-                }\n-                bclose(s, item.span);\n+        if methods.len() == 0 {\n+            word(s.s, ~\";\");\n+        } else {\n+            bopen(s);\n+            for methods.each |meth| {\n+               print_method(s, *meth);\n             }\n+            bclose(s, item.span);\n         }\n       }\n       ast::item_trait(tps, traits, methods) => {"}, {"sha": "3bc8c7b94209c8c7e0cf7668a6e3c553cf709be9", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -142,16 +142,14 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n         visit_enum_def(enum_definition, tps, e, v);\n       }\n-      item_impl(tps, traits, ty, methods_opt) => {\n+      item_impl(tps, traits, ty, methods) => {\n         v.visit_ty_params(tps, e, v);\n         for traits.each |p| {\n             visit_path(p.path, e, v);\n         }\n         v.visit_ty(ty, e, v);\n-        for methods_opt.each |methods| {\n-            for methods.each |m| {\n-                visit_method_helper(*m, e, v)\n-            }\n+        for methods.each |m| {\n+            visit_method_helper(*m, e, v)\n         }\n       }\n       item_class(struct_def, tps) => {"}, {"sha": "eb103a48df967003eb823cb639ab016492e82b93", "filename": "src/test/compile-fail/enum-deriving-incomplete.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Fcompile-fail%2Fenum-deriving-incomplete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Fcompile-fail%2Fenum-deriving-incomplete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-deriving-incomplete.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1,4 +1,5 @@\n trait MyEq {\n+    #[derivable]\n     pure fn eq(other: &self) -> bool;\n }\n "}, {"sha": "140c915c57dbbf22ff7b21db5c28e9e1075e9442", "filename": "src/test/compile-fail/missing-derivable-attr.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -0,0 +1,17 @@\n+trait MyEq {\n+    pure fn eq(other: &self) -> bool;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl int : MyEq {\n+    pure fn eq(other: &int) -> bool { self == *other }\n+}\n+\n+impl A : MyEq;  //~ ERROR missing method\n+\n+fn main() {\n+}\n+"}, {"sha": "a45b7df3a2afe9cfb40f08a83b29f98f241d1326", "filename": "src/test/run-pass/deriving-generic-bounded.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1,4 +1,5 @@\n trait MyEq {\n+    #[derivable]\n     pure fn eq(other: &self) -> bool;\n }\n "}, {"sha": "20fe5a35cd3ed2f9bb35c77e40ecd576a903b4f6", "filename": "src/test/run-pass/deriving-one-method.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-one-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-one-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-one-method.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -0,0 +1,25 @@\n+trait MyEq {\n+    #[derivable]\n+    pure fn eq(other: &self) -> bool;\n+    pure fn ne(other: &self) -> bool;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl int : MyEq {\n+    pure fn eq(other: &int) -> bool { self == *other }\n+    pure fn ne(other: &int) -> bool { self != *other }\n+}\n+\n+impl A : MyEq {\n+    pure fn ne(other: &A) -> bool { !self.eq(other) }\n+}\n+\n+fn main() {\n+    let a = A { x: 1 };\n+    assert a.eq(&a);\n+    assert !a.ne(&a);\n+}\n+"}, {"sha": "5b030e4db18af275ff974720d865bde9f469e88d", "filename": "src/test/run-pass/deriving-override.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-override.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -0,0 +1,26 @@\n+trait MyEq {\n+    #[derivable]\n+    pure fn eq(other: &self) -> bool;\n+    #[derivable]\n+    pure fn ne(other: &self) -> bool;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl int : MyEq {\n+    pure fn eq(other: &int) -> bool { self == *other }\n+    pure fn ne(other: &int) -> bool { self != *other }\n+}\n+\n+impl A : MyEq {\n+    pure fn ne(other: &A) -> bool { !self.eq(other) }\n+}\n+\n+fn main() {\n+    let a = A { x: 1 };\n+    assert a.eq(&a);\n+    assert !a.ne(&a);\n+}\n+"}, {"sha": "385bb9a3b95db549b2eff85945b88270a28f1546", "filename": "src/test/run-pass/deriving-returning-nil.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1,4 +1,5 @@\n trait Show {\n+    #[derivable]\n     fn show();\n }\n "}, {"sha": "60c51a73ddb940264cd7e73f577f1dd70a125e55", "filename": "src/test/run-pass/deriving-simple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fderiving-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-simple.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1,4 +1,5 @@\n trait MyEq {\n+    #[derivable]\n     pure fn eq(other: &self) -> bool;\n }\n "}, {"sha": "b075f1b1c6ad430aa31d164a907453ba2080d8e3", "filename": "src/test/run-pass/enum-deriving-simple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ad4ae4cde68fed1b132be79bc9068b020d270b/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-deriving-simple.rs?ref=32ad4ae4cde68fed1b132be79bc9068b020d270b", "patch": "@@ -1,4 +1,5 @@\n trait MyEq {\n+    #[derivable]\n     pure fn eq(other: &self) -> bool;\n }\n "}]}