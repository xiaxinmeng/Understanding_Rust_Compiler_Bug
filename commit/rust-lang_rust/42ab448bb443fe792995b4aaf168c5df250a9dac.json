{"sha": "42ab448bb443fe792995b4aaf168c5df250a9dac", "node_id": "C_kwDOAAsO6NoAKDQyYWI0NDhiYjQ0M2ZlNzkyOTk1YjRhYWYxNjhjNWRmMjUwYTlkYWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-05T20:58:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-05T20:58:57Z"}, "message": "Rollup merge of #95585 - compiler-errors:ref-clone, r=estebank\n\nExplain why `&T` is cloned when `T` is not `Clone`\n\nFixes #95535", "tree": {"sha": "f9dc7c394bbd0124e6a3ba9a80bbfac96e82e2f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9dc7c394bbd0124e6a3ba9a80bbfac96e82e2f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42ab448bb443fe792995b4aaf168c5df250a9dac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiTK2RCRBK7hj4Ov3rIwAA1lMIAKTrchPEoON/gCRhEEva+ImL\nc7FfMMFCU6ato2tlLkkQTxqp2FloE8IwR4CUzGvt6i9XaZmfhl7Ta4YAzFFni+E4\nVPqHtJjNj0BqwEIrsXb9pd0twDm5BBRXrDCUnIxw0UOOPjpcfuMC64epG6g1Didi\nLFGV9bPA3au+po8TJjREWVH+pnEGN5faSj15+HK59dkQsHeJDUHVNZpJbgxiIebJ\nkj7CSDYU7ogM2V7vEN7JRlTLj+9oUjA2SLxQ9x3Qn8bxM1mI6m/94PVihjP6eDii\n9pZ19fhovrXfZdmZF2IBsjHs2vG3fX7dlYcD+SWZOZdSKyim1ZbcZzH0Tuj+8EQ=\n=n+Bg\n-----END PGP SIGNATURE-----\n", "payload": "tree f9dc7c394bbd0124e6a3ba9a80bbfac96e82e2f2\nparent e597d06144f356f58cf16a15ac7f21bc0d4d3628\nparent d12689c022d56d63c03a73925054c95d060e34c4\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649192337 +0200\ncommitter GitHub <noreply@github.com> 1649192337 +0200\n\nRollup merge of #95585 - compiler-errors:ref-clone, r=estebank\n\nExplain why `&T` is cloned when `T` is not `Clone`\n\nFixes #95535\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42ab448bb443fe792995b4aaf168c5df250a9dac", "html_url": "https://github.com/rust-lang/rust/commit/42ab448bb443fe792995b4aaf168c5df250a9dac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42ab448bb443fe792995b4aaf168c5df250a9dac/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e597d06144f356f58cf16a15ac7f21bc0d4d3628", "url": "https://api.github.com/repos/rust-lang/rust/commits/e597d06144f356f58cf16a15ac7f21bc0d4d3628", "html_url": "https://github.com/rust-lang/rust/commit/e597d06144f356f58cf16a15ac7f21bc0d4d3628"}, {"sha": "d12689c022d56d63c03a73925054c95d060e34c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d12689c022d56d63c03a73925054c95d060e34c4", "html_url": "https://github.com/rust-lang/rust/commit/d12689c022d56d63c03a73925054c95d060e34c4"}], "stats": {"total": 92, "additions": 86, "deletions": 6}, "files": [{"sha": "83e535b3c32477f22d2523ecada2657c0cefa16c", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42ab448bb443fe792995b4aaf168c5df250a9dac/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ab448bb443fe792995b4aaf168c5df250a9dac/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=42ab448bb443fe792995b4aaf168c5df250a9dac", "patch": "@@ -40,6 +40,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n         self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected);\n+        self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.report_closure_inferred_return_type(err, expected);\n@@ -630,7 +631,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MachineApplicable,\n                                     true,\n                                 ));\n-\n                     }\n                 }\n                 _ => {}"}, {"sha": "93a0900c7e80d93300c554ce9b3b9ecee62ba658", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/42ab448bb443fe792995b4aaf168c5df250a9dac/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ab448bb443fe792995b4aaf168c5df250a9dac/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=42ab448bb443fe792995b4aaf168c5df250a9dac", "patch": "@@ -2,8 +2,6 @@ use super::FnCtxt;\n use crate::astconv::AstConv;\n \n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_span::{self, Span};\n-\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -13,12 +11,14 @@ use rustc_hir::{\n     WherePredicate,\n };\n use rustc_infer::infer::{self, TyCtxtInferExt};\n-\n+use rustc_infer::traits;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, Ty};\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, Binder, ToPredicate, Ty};\n use rustc_span::symbol::{kw, sym};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n \n-use rustc_middle::ty::subst::GenericArgKind;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -846,4 +846,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Stmt(Stmt { kind: StmtKind::Local(..), .. }))\n     }\n+\n+    /// Suggest that `&T` was cloned instead of `T` because `T` does not implement `Clone`,\n+    /// which is a side-effect of autoref.\n+    pub(crate) fn note_type_is_not_clone(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expected_ty: Ty<'tcx>,\n+        found_ty: Ty<'tcx>,\n+        expr: &hir::Expr<'_>,\n+    ) {\n+        let hir::ExprKind::MethodCall(segment, &[ref callee_expr], _) = expr.kind else { return; };\n+        let Some(clone_trait_did) = self.tcx.lang_items().clone_trait() else { return; };\n+        let ty::Ref(_, pointee_ty, _) = found_ty.kind() else { return };\n+        let results = self.typeck_results.borrow();\n+        // First, look for a `Clone::clone` call\n+        if segment.ident.name == sym::clone\n+            && results.type_dependent_def_id(expr.hir_id).map_or(\n+                false,\n+                |did| {\n+                    self.tcx.associated_item(did).container\n+                        == ty::AssocItemContainer::TraitContainer(clone_trait_did)\n+                },\n+            )\n+            // If that clone call hasn't already dereferenced the self type (i.e. don't give this\n+            // diagnostic in cases where we have `(&&T).clone()` and we expect `T`).\n+            && !results.expr_adjustments(callee_expr).iter().any(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(..)))\n+            // Check that we're in fact trying to clone into the expected type\n+            && self.can_coerce(*pointee_ty, expected_ty)\n+            // And the expected type doesn't implement `Clone`\n+            && !self.predicate_must_hold_considering_regions(&traits::Obligation {\n+                cause: traits::ObligationCause::dummy(),\n+                param_env: self.param_env,\n+                recursion_depth: 0,\n+                predicate: ty::Binder::dummy(ty::TraitRef {\n+                    def_id: clone_trait_did,\n+                    substs: self.tcx.mk_substs([expected_ty.into()].iter()),\n+                })\n+                .without_const()\n+                .to_predicate(self.tcx),\n+            })\n+        {\n+            diag.span_note(\n+                callee_expr.span,\n+                &format!(\n+                    \"`{expected_ty}` does not implement `Clone`, so `{found_ty}` was cloned instead\"\n+                ),\n+            );\n+        }\n+    }\n }"}, {"sha": "9279e4c3901db303674d35d8ea5f23d980296d3d", "filename": "src/test/ui/typeck/explain_clone_autoref.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42ab448bb443fe792995b4aaf168c5df250a9dac/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ab448bb443fe792995b4aaf168c5df250a9dac/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.rs?ref=42ab448bb443fe792995b4aaf168c5df250a9dac", "patch": "@@ -0,0 +1,13 @@\n+struct NotClone;\n+\n+fn main() {\n+    clone_thing(&NotClone);\n+}\n+\n+fn clone_thing(nc: &NotClone) -> NotClone {\n+    //~^ NOTE expected `NotClone` because of return type\n+    nc.clone()\n+    //~^ ERROR mismatched type\n+    //~| NOTE `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead\n+    //~| NOTE expected struct `NotClone`, found `&NotClone`\n+}"}, {"sha": "faac680ea19318f02e674ec0e5ddb67ad34cf9eb", "filename": "src/test/ui/typeck/explain_clone_autoref.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42ab448bb443fe792995b4aaf168c5df250a9dac/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ab448bb443fe792995b4aaf168c5df250a9dac/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.stderr?ref=42ab448bb443fe792995b4aaf168c5df250a9dac", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/explain_clone_autoref.rs:9:5\n+   |\n+LL | fn clone_thing(nc: &NotClone) -> NotClone {\n+   |                                  -------- expected `NotClone` because of return type\n+LL |\n+LL |     nc.clone()\n+   |     ^^^^^^^^^^ expected struct `NotClone`, found `&NotClone`\n+   |\n+note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead\n+  --> $DIR/explain_clone_autoref.rs:9:5\n+   |\n+LL |     nc.clone()\n+   |     ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}