{"sha": "1b6a1e98a887d0c698db09d521bc68bc3a47207d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNmExZTk4YTg4N2QwYzY5OGRiMDlkNTIxYmM2OGJjM2E0NzIwN2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T04:13:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T04:18:34Z"}, "message": "Finalize the Seek API\n\nThis adopts the rules posted in #10432:\n\n1. If a seek position is negative, then an error is generated\n2. Seeks beyond the end-of-file are allowed. Future writes will fill the gap\n   with data and future reads will return errors.\n3. Seeks within the bounds of a file are fine.\n\nCloses #10432", "tree": {"sha": "89c938ee16389f8c05cf7aa0a39a9b964c98ce44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89c938ee16389f8c05cf7aa0a39a9b964c98ce44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b6a1e98a887d0c698db09d521bc68bc3a47207d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b6a1e98a887d0c698db09d521bc68bc3a47207d", "html_url": "https://github.com/rust-lang/rust/commit/1b6a1e98a887d0c698db09d521bc68bc3a47207d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b6a1e98a887d0c698db09d521bc68bc3a47207d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c967e70414cad67e4cd28a9fd2cc267ccf85da9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c967e70414cad67e4cd28a9fd2cc267ccf85da9", "html_url": "https://github.com/rust-lang/rust/commit/4c967e70414cad67e4cd28a9fd2cc267ccf85da9"}], "stats": {"total": 111, "additions": 80, "deletions": 31}, "files": [{"sha": "ff61ef15fa519e2a768f55a18a6387c470720993", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 73, "deletions": 26, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1b6a1e98a887d0c698db09d521bc68bc3a47207d/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b6a1e98a887d0c698db09d521bc68bc3a47207d/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=1b6a1e98a887d0c698db09d521bc68bc3a47207d", "patch": "@@ -10,7 +10,6 @@\n \n //! Readers and Writers for in-memory buffers\n \n-use cmp::max;\n use cmp::min;\n use container::Container;\n use option::None;\n@@ -20,6 +19,25 @@ use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use vec;\n use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n \n+fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+    // compute offset as signed and clamp to prevent overflow\n+    let pos = match seek {\n+        SeekSet => 0,\n+        SeekEnd => end,\n+        SeekCur => cur,\n+    } as i64;\n+\n+    if offset + pos < 0 {\n+        Err(IoError {\n+            kind: io::InvalidInput,\n+            desc: \"invalid seek to a negative offset\",\n+            detail: None\n+        })\n+    } else {\n+        Ok((offset + pos) as u64)\n+    }\n+}\n+\n /// Writes to an owned, growable byte vector\n ///\n /// # Example\n@@ -92,19 +110,11 @@ impl Writer for MemWriter {\n     }\n }\n \n-// FIXME(#10432)\n impl Seek for MemWriter {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        // compute offset as signed and clamp to prevent overflow\n-        let offset = match style {\n-            SeekSet => { 0 }\n-            SeekEnd => { self.buf.len() }\n-            SeekCur => { self.pos }\n-        } as i64;\n-\n-        self.pos = max(0, offset+pos) as uint;\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n         Ok(())\n     }\n }\n@@ -139,7 +149,7 @@ impl MemReader {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n-    pub fn eof(&self) -> bool { self.pos == self.buf.len() }\n+    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n     /// `MemReader`.\n@@ -172,7 +182,11 @@ impl Reader for MemReader {\n \n impl Seek for MemReader {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n+        Ok(())\n+    }\n }\n \n impl Buffer for MemReader {\n@@ -236,24 +250,15 @@ impl<'a> Writer for BufWriter<'a> {\n     }\n }\n \n-// FIXME(#10432)\n impl<'a> Seek for BufWriter<'a> {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        // compute offset as signed and clamp to prevent overflow\n-        let offset = match style {\n-            SeekSet => { 0 }\n-            SeekEnd => { self.buf.len() }\n-            SeekCur => { self.pos }\n-        } as i64;\n-\n-        self.pos = max(0, offset+pos) as uint;\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n         Ok(())\n     }\n }\n \n-\n /// Reads from a fixed-size byte slice\n ///\n /// # Example\n@@ -284,7 +289,7 @@ impl<'a> BufReader<'a> {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n-    pub fn eof(&self) -> bool { self.pos == self.buf.len() }\n+    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n }\n \n impl<'a> Reader for BufReader<'a> {\n@@ -307,7 +312,11 @@ impl<'a> Reader for BufReader<'a> {\n \n impl<'a> Seek for BufReader<'a> {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n+        Ok(())\n+    }\n }\n \n impl<'a> Buffer for BufReader<'a> {\n@@ -506,4 +515,42 @@ mod test {\n             Err(..) => {}\n         }\n     }\n+\n+    #[test]\n+    fn seek_past_end() {\n+        let buf = [0xff];\n+        let mut r = BufReader::new(buf);\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.read(&mut []).is_err());\n+\n+        let mut r = MemReader::new(~[10]);\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.read(&mut []).is_err());\n+\n+        let mut r = MemWriter::new();\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.write([3]).is_ok());\n+\n+        let mut buf = [0];\n+        let mut r = BufWriter::new(buf);\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.write([3]).is_err());\n+    }\n+\n+    #[test]\n+    fn seek_before_0() {\n+        let buf = [0xff];\n+        let mut r = BufReader::new(buf);\n+        assert!(r.seek(-1, SeekSet).is_err());\n+\n+        let mut r = MemReader::new(~[10]);\n+        assert!(r.seek(-1, SeekSet).is_err());\n+\n+        let mut r = MemWriter::new();\n+        assert!(r.seek(-1, SeekSet).is_err());\n+\n+        let mut buf = [0];\n+        let mut r = BufWriter::new(buf);\n+        assert!(r.seek(-1, SeekSet).is_err());\n+    }\n }"}, {"sha": "41f7e555755df04193153e854e7761d25a91e31c", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b6a1e98a887d0c698db09d521bc68bc3a47207d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b6a1e98a887d0c698db09d521bc68bc3a47207d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1b6a1e98a887d0c698db09d521bc68bc3a47207d", "patch": "@@ -1192,19 +1192,21 @@ pub enum SeekStyle {\n     SeekCur,\n }\n \n-/// # FIXME\n-/// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n     /// Return position of file cursor in the stream\n     fn tell(&self) -> IoResult<u64>;\n \n     /// Seek to an offset in a stream\n     ///\n-    /// A successful seek clears the EOF indicator.\n+    /// A successful seek clears the EOF indicator. Seeking beyond EOF is\n+    /// allowed, but seeking before position 0 is not allowed.\n     ///\n-    /// # FIXME\n+    /// # Errors\n     ///\n-    /// * What is the behavior when seeking past the end of a stream?\n+    /// * Seeking to a negative offset is considered an error\n+    /// * Seeking past the end of the stream does not modify the underlying\n+    ///   stream, but the next write may cause the previous data to be filled in\n+    ///   with a bit pattern.\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n }\n "}]}