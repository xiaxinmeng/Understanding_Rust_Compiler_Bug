{"sha": "c44e93086d5476e8649d45b27ace321c66b05a39", "node_id": "C_kwDOAAsO6NoAKGM0NGU5MzA4NmQ1NDc2ZTg2NDlkNDViMjdhY2UzMjFjNjZiMDVhMzk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-31T16:11:28Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-11-30T21:55:06Z"}, "message": "Move report_elision_failure in diagnostics.rs.", "tree": {"sha": "27cbdfdbfcc649ecf9a5a8b83ad4ca11495e955c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27cbdfdbfcc649ecf9a5a8b83ad4ca11495e955c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c44e93086d5476e8649d45b27ace321c66b05a39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c44e93086d5476e8649d45b27ace321c66b05a39", "html_url": "https://github.com/rust-lang/rust/commit/c44e93086d5476e8649d45b27ace321c66b05a39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c44e93086d5476e8649d45b27ace321c66b05a39/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "207c80f105282245d93024c95ac408c622f70114", "url": "https://api.github.com/repos/rust-lang/rust/commits/207c80f105282245d93024c95ac408c622f70114", "html_url": "https://github.com/rust-lang/rust/commit/207c80f105282245d93024c95ac408c622f70114"}], "stats": {"total": 165, "additions": 83, "deletions": 82}, "files": [{"sha": "8c917fc466daa171c93082dc3cd371fa2382355f", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c44e93086d5476e8649d45b27ace321c66b05a39/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44e93086d5476e8649d45b27ace321c66b05a39/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=c44e93086d5476e8649d45b27ace321c66b05a39", "patch": "@@ -1871,6 +1871,85 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err.emit();\n     }\n \n+    /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n+    crate fn report_elision_failure(\n+        &mut self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        params: &[ElisionFailureInfo],\n+    ) -> bool {\n+        let mut m = String::new();\n+        let len = params.len();\n+\n+        let elided_params: Vec<_> =\n+            params.iter().cloned().filter(|info| info.lifetime_count > 0).collect();\n+\n+        let elided_len = elided_params.len();\n+\n+        for (i, info) in elided_params.into_iter().enumerate() {\n+            let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n+                info;\n+\n+            db.span_label(span, \"\");\n+            let help_name = if let Some(ident) =\n+                parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n+            {\n+                format!(\"`{}`\", ident)\n+            } else {\n+                format!(\"argument {}\", index + 1)\n+            };\n+\n+            m.push_str(\n+                &(if n == 1 {\n+                    help_name\n+                } else {\n+                    format!(\n+                        \"one of {}'s {} {}lifetimes\",\n+                        help_name,\n+                        n,\n+                        if have_bound_regions { \"free \" } else { \"\" }\n+                    )\n+                })[..],\n+            );\n+\n+            if elided_len == 2 && i == 0 {\n+                m.push_str(\" or \");\n+            } else if i + 2 == elided_len {\n+                m.push_str(\", or \");\n+            } else if i != elided_len - 1 {\n+                m.push_str(\", \");\n+            }\n+        }\n+\n+        if len == 0 {\n+            db.help(\n+                \"this function's return type contains a borrowed value, \\\n+                 but there is no value for it to be borrowed from\",\n+            );\n+            true\n+        } else if elided_len == 0 {\n+            db.help(\n+                \"this function's return type contains a borrowed value with \\\n+                 an elided lifetime, but the lifetime cannot be derived from \\\n+                 the arguments\",\n+            );\n+            true\n+        } else if elided_len == 1 {\n+            db.help(&format!(\n+                \"this function's return type contains a borrowed value, \\\n+                 but the signature does not say which {} it is borrowed from\",\n+                m\n+            ));\n+            false\n+        } else {\n+            db.help(&format!(\n+                \"this function's return type contains a borrowed value, \\\n+                 but the signature does not say whether it is borrowed from {}\",\n+                m\n+            ));\n+            false\n+        }\n+    }\n+\n     // FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n     // generics. We are disallowing this until we can decide on how we want to handle non-'static\n     // lifetimes in const generics. See issue #74052 for discussion."}, {"sha": "a377ea0b18f026c6e52f985e0d821a2b4c80c751", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 82, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c44e93086d5476e8649d45b27ace321c66b05a39/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44e93086d5476e8649d45b27ace321c66b05a39/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=c44e93086d5476e8649d45b27ace321c66b05a39", "patch": "@@ -357,11 +357,11 @@ enum Elide {\n #[derive(Clone, Debug)]\n crate struct ElisionFailureInfo {\n     /// Where we can find the argument pattern.\n-    parent: Option<hir::BodyId>,\n+    crate parent: Option<hir::BodyId>,\n     /// The index of the argument in the original definition.\n-    index: usize,\n-    lifetime_count: usize,\n-    have_bound_regions: bool,\n+    crate index: usize,\n+    crate lifetime_count: usize,\n+    crate have_bound_regions: bool,\n     crate span: Span,\n }\n \n@@ -3166,84 +3166,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_elision_failure(\n-        &mut self,\n-        db: &mut DiagnosticBuilder<'_>,\n-        params: &[ElisionFailureInfo],\n-    ) -> bool /* add `'static` lifetime to lifetime list */ {\n-        let mut m = String::new();\n-        let len = params.len();\n-\n-        let elided_params: Vec<_> =\n-            params.iter().cloned().filter(|info| info.lifetime_count > 0).collect();\n-\n-        let elided_len = elided_params.len();\n-\n-        for (i, info) in elided_params.into_iter().enumerate() {\n-            let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n-                info;\n-\n-            db.span_label(span, \"\");\n-            let help_name = if let Some(ident) =\n-                parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n-            {\n-                format!(\"`{}`\", ident)\n-            } else {\n-                format!(\"argument {}\", index + 1)\n-            };\n-\n-            m.push_str(\n-                &(if n == 1 {\n-                    help_name\n-                } else {\n-                    format!(\n-                        \"one of {}'s {} {}lifetimes\",\n-                        help_name,\n-                        n,\n-                        if have_bound_regions { \"free \" } else { \"\" }\n-                    )\n-                })[..],\n-            );\n-\n-            if elided_len == 2 && i == 0 {\n-                m.push_str(\" or \");\n-            } else if i + 2 == elided_len {\n-                m.push_str(\", or \");\n-            } else if i != elided_len - 1 {\n-                m.push_str(\", \");\n-            }\n-        }\n-\n-        if len == 0 {\n-            db.help(\n-                \"this function's return type contains a borrowed value, \\\n-                 but there is no value for it to be borrowed from\",\n-            );\n-            true\n-        } else if elided_len == 0 {\n-            db.help(\n-                \"this function's return type contains a borrowed value with \\\n-                 an elided lifetime, but the lifetime cannot be derived from \\\n-                 the arguments\",\n-            );\n-            true\n-        } else if elided_len == 1 {\n-            db.help(&format!(\n-                \"this function's return type contains a borrowed value, \\\n-                 but the signature does not say which {} it is borrowed from\",\n-                m\n-            ));\n-            false\n-        } else {\n-            db.help(&format!(\n-                \"this function's return type contains a borrowed value, \\\n-                 but the signature does not say whether it is borrowed from {}\",\n-                m\n-            ));\n-            false\n-        }\n-    }\n-\n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;"}]}