{"sha": "7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZjE0MmY3OGI4MmIwYjJhZTA4YjUyY2NiNmE2ZTE1YzAyNzBjMzg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-02T00:28:37Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-03T12:14:35Z"}, "message": "Avoid many `cmt` allocations.\n\n`cmt` is a ref-counted wrapper around `cmt_` The use of refcounting\nkeeps `cmt` handling simple, but a lot of `cmt` instances are very\nshort-lived, and heap-allocating the short-lived ones takes up time.\n\nThis patch changes things in the following ways.\n\n- Most of the functions that produced `cmt` instances now produce `cmt_`\n  instances. The `Rc::new` calls that occurred within those functions\n  now occur at their call sites (but only when necessary, which isn't\n  that often).\n\n- Many of the functions that took `cmt` arguments now take `&cmt_`\n  arguments. This includes all the methods in the `Delegate` trait.\n\nAs a result, the vast majority of the heap allocations are avoided. In\nan extreme case, the number of calls to malloc in tuple-stress drops\nfrom 9.9M to 7.9M, a drop of 20%. And the compile times for many runs of\ncoercions, deep-vector, and tuple-stress drop by 1--2%.", "tree": {"sha": "8c2bde3dcd85a2b9bbb49d281966cb52c47cb5c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c2bde3dcd85a2b9bbb49d281966cb52c47cb5c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "html_url": "https://github.com/rust-lang/rust/commit/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f76f6fbdea497c3cb536e33387f405cc74b99b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/f76f6fbdea497c3cb536e33387f405cc74b99b76", "html_url": "https://github.com/rust-lang/rust/commit/f76f6fbdea497c3cb536e33387f405cc74b99b76"}], "stats": {"total": 417, "additions": 208, "deletions": 209}, "files": [{"sha": "725fcf1e6463b988fe11f84fff449b0d86b29cbd", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -28,6 +28,7 @@ use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -44,7 +45,7 @@ pub trait Delegate<'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n+               cmt: &mc::cmt_<'tcx>,\n                mode: ConsumeMode);\n \n     // The value found at `cmt` has been determined to match the\n@@ -61,22 +62,22 @@ pub trait Delegate<'tcx> {\n     // called on a subpart of an input passed to `matched_pat).\n     fn matched_pat(&mut self,\n                    matched_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: MatchMode);\n \n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n                    consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: ConsumeMode);\n \n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n@@ -90,7 +91,7 @@ pub trait Delegate<'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n+              assignee_cmt: &mc::cmt_<'tcx>,\n               mode: MutateMode);\n }\n \n@@ -316,11 +317,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(region::Scope::Node(body.value.hir_id.local_id)));\n-            let arg_cmt = self.mc.cat_rvalue(\n+            let arg_cmt = Rc::new(self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n                 fn_body_scope_r, // Args live only as long as the fn body.\n-                arg_ty);\n+                arg_ty));\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n         }\n@@ -335,11 +336,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn delegate_consume(&mut self,\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n-                        cmt: mc::cmt<'tcx>) {\n+                        cmt: &mc::cmt_<'tcx>) {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(&self.mc, self.param_env, &cmt, DirectRefMove);\n+        let mode = copy_or_move(&self.mc, self.param_env, cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -353,7 +354,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.id, expr.span, cmt);\n+        self.delegate_consume(expr.id, expr.span, &cmt);\n         self.walk_expr(expr);\n     }\n \n@@ -362,7 +363,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                    expr: &hir::Expr,\n                    mode: MutateMode) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n+        self.delegate.mutate(assignment_expr.id, assignment_expr.span, &cmt, mode);\n         self.walk_expr(expr);\n     }\n \n@@ -375,7 +376,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n+        self.delegate.borrow(expr.id, expr.span, &cmt, r, bk, cause);\n \n         self.walk_expr(expr)\n     }\n@@ -435,7 +436,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n+                let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n                 let r = self.tcx().types.re_empty;\n                 self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n \n@@ -619,7 +620,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n                 self.walk_expr(&expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(&expr));\n+                let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n                 self.walk_irrefutable_pat(init_cmt, &local.pat);\n             }\n         }\n@@ -652,7 +653,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(&with_expr));\n+        let with_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&with_expr)));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -671,7 +672,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             with_field.name,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+                        self.delegate_consume(with_expr.id, with_expr.span, &cmt_field);\n                     }\n                 }\n             }\n@@ -710,7 +711,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.id, expr.span, cmt.clone());\n+                    self.delegate_consume(expr.id, expr.span, &cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -722,12 +723,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n-                                         deref.region, bk, AutoRef);\n+                    self.delegate.borrow(expr.id, expr.span, &cmt, deref.region, bk, AutoRef);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n-                    self.walk_autoref(expr, cmt.clone(), autoref);\n+                    self.walk_autoref(expr, &cmt, autoref);\n                 }\n             }\n             cmt = return_if_err!(self.mc.cat_expr_adjusted(expr, cmt, &adjustment));\n@@ -739,7 +739,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// after all relevant autoderefs have occurred.\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n-                    cmt_base: mc::cmt<'tcx>,\n+                    cmt_base: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n         debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n                expr.id,\n@@ -852,7 +852,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = Def::Local(canonical_id);\n-                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                if let Ok(ref binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n \n@@ -861,13 +861,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     ty::BindByReference(m) => {\n                         if let ty::TyRef(r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n+                            delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n                     ty::BindByValue(..) => {\n                         let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n-                        delegate.consume_pat(pat, cmt_pat, mode);\n+                        delegate.consume_pat(pat, &cmt_pat, mode);\n                     }\n                 }\n             }\n@@ -891,12 +891,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n-                    delegate.matched_pat(pat, downcast_cmt, match_mode);\n+                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n                 Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n-                    delegate.matched_pat(pat, cmt_pat, match_mode);\n+                    delegate.matched_pat(pat, &cmt_pat, match_mode);\n                 }\n                 _ => {}\n             }\n@@ -924,12 +924,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n+                        self.delegate.consume(closure_expr.id, freevar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n                         self.delegate.borrow(closure_expr.id,\n                                              fn_decl_span,\n-                                             cmt_var,\n+                                             &cmt_var,\n                                              upvar_borrow.region,\n                                              upvar_borrow.kind,\n                                              ClosureCapture(freevar.span));\n@@ -943,7 +943,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar: &hir::Freevar)\n-                        -> mc::McResult<mc::cmt<'tcx>> {\n+                        -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_hir_id = self.tcx().hir.node_to_hir_id(upvar.var_id());\n@@ -954,7 +954,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n fn copy_or_move<'a, 'gcx, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                 param_env: ty::ParamEnv<'tcx>,\n-                                cmt: &mc::cmt<'tcx>,\n+                                cmt: &mc::cmt_<'tcx>,\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {"}, {"sha": "f40a41cd299247cf15e9836eebf5bd25223251a0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -572,13 +572,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'gcx, 'tcx>(mc: &MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                   expr: &hir::Expr,\n                                   adjustments: &[adjustment::Adjustment<'tcx>])\n-                                   -> McResult<cmt<'tcx>> {\n+                                   -> McResult<cmt_<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -591,32 +591,32 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n-                             previous: cmt<'tcx>,\n+                             previous: cmt_<'tcx>,\n                              adjustment: &adjustment::Adjustment<'tcx>)\n-                             -> McResult<cmt<'tcx>> {\n+                             -> McResult<cmt_<'tcx>> {\n         self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n     fn cat_expr_adjusted_with<F>(&self, expr: &hir::Expr,\n                                  previous: F,\n                                  adjustment: &adjustment::Adjustment<'tcx>)\n-                                 -> McResult<cmt<'tcx>>\n-        where F: FnOnce() -> McResult<cmt<'tcx>>\n+                                 -> McResult<cmt_<'tcx>>\n+        where F: FnOnce() -> McResult<cmt_<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n         let target = self.resolve_type_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n-                let base = if let Some(deref) = overloaded {\n+                let base = Rc::new(if let Some(deref) = overloaded {\n                     let ref_ty = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n                     self.cat_rvalue_node(expr.id, expr.span, ref_ty)\n                 } else {\n                     previous()?\n-                };\n+                });\n                 self.cat_deref(expr, base, false)\n             }\n \n@@ -633,7 +633,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -642,13 +642,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             if self.tables.is_method_call(expr) {\n                 self.cat_overloaded_place(expr, e_base, false)\n             } else {\n-                let base_cmt = self.cat_expr(&e_base)?;\n+                let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n                 self.cat_deref(expr, base_cmt, false)\n             }\n           }\n \n           hir::ExprField(ref base, f_name) => {\n-            let base_cmt = self.cat_expr(&base)?;\n+            let base_cmt = Rc::new(self.cat_expr(&base)?);\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n                    expr,\n@@ -666,7 +666,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // dereferencing.\n                 self.cat_overloaded_place(expr, base, true)\n             } else {\n-                let base_cmt = self.cat_expr(&base)?;\n+                let base_cmt = Rc::new(self.cat_expr(&base)?);\n                 self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n             }\n           }\n@@ -701,7 +701,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: Def)\n-                   -> McResult<cmt<'tcx>> {\n+                   -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_def: id={} expr={:?} def={:?}\",\n                id, expr_ty, def);\n \n@@ -718,29 +718,29 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     return Ok(self.cat_rvalue_node(id, span, expr_ty));\n                 }\n             }\n-              Ok(Rc::new(cmt_ {\n+              Ok(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:Categorization::StaticItem,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n-              }))\n+              })\n           }\n \n           Def::Upvar(var_id, _, fn_node_id) => {\n               self.cat_upvar(id, span, var_id, fn_node_id)\n           }\n \n           Def::Local(vid) => {\n-            Ok(Rc::new(cmt_ {\n+            Ok(cmt_ {\n                 id,\n                 span,\n                 cat: Categorization::Local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                 ty: expr_ty,\n                 note: NoteNone\n-            }))\n+            })\n           }\n \n           def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n@@ -754,7 +754,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId)\n-                 -> McResult<cmt<'tcx>>\n+                 -> McResult<cmt_<'tcx>>\n     {\n         let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n \n@@ -861,7 +861,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let ret = Rc::new(cmt_result);\n+        let ret = cmt_result;\n         debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n@@ -938,7 +938,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            id: ast::NodeId,\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n-                           -> cmt<'tcx> {\n+                           -> cmt_<'tcx> {\n         let hir_id = self.tcx.hir.node_to_hir_id(id);\n         let promotable = self.rvalue_promotable_map.as_ref().map(|m| m.contains(&hir_id.local_id))\n                                                             .unwrap_or(false);\n@@ -966,15 +966,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region<'tcx>,\n-                      expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n+                      expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n+        let ret = cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:Categorization::Rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_rvalue ret {:?}\", ret);\n         ret\n     }\n@@ -985,15 +985,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                  f_index: usize,\n                                  f_name: Name,\n                                  f_ty: Ty<'tcx>)\n-                                 -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n+                                 -> cmt_<'tcx> {\n+        let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_index, f_name))),\n             ty: f_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n@@ -1002,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                              expr: &hir::Expr,\n                              base: &hir::Expr,\n                              implicit: bool)\n-                             -> McResult<cmt<'tcx>> {\n+                             -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_overloaded_place: implicit={}\", implicit);\n \n         // Reconstruct the output assuming it's a reference with the\n@@ -1022,15 +1022,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             mutbl,\n         });\n \n-        let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n+        let base_cmt = Rc::new(self.cat_rvalue_node(expr.id, expr.span, ref_ty));\n         self.cat_deref(expr, base_cmt, implicit)\n     }\n \n     pub fn cat_deref<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n                                  implicit: bool)\n-                                 -> McResult<cmt<'tcx>> {\n+                                 -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n \n         let base_cmt_ty = base_cmt.ty;\n@@ -1052,15 +1052,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n             ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n         };\n-        let ret = Rc::new(cmt_ {\n+        let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             // For unique ptrs, we inherit mutability from the owning reference.\n             mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n             cat: Categorization::Deref(base_cmt, ptr),\n             ty: deref_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_deref ret {:?}\", ret);\n         Ok(ret)\n     }\n@@ -1070,7 +1070,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                              base_cmt: cmt<'tcx>,\n                              element_ty: Ty<'tcx>,\n                              context: InteriorOffsetKind)\n-                             -> McResult<cmt<'tcx>> {\n+                             -> McResult<cmt_<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -1089,8 +1089,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         //! - `base_cmt`: the cmt of `elt`\n \n         let interior_elem = InteriorElement(context);\n-        let ret =\n-            self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n+        let ret = self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n         debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n     }\n@@ -1100,15 +1099,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                         base_cmt: cmt<'tcx>,\n                                         interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n-                                        -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n+                                        -> cmt_<'tcx> {\n+        let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: Categorization::Interior(base_cmt, interior),\n             ty: interior_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_imm_interior ret={:?}\", ret);\n         ret\n     }\n@@ -1232,7 +1231,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         .get(pat.hir_id)\n                         .map(|v| v.len())\n                         .unwrap_or(0) {\n-            cmt = self.cat_deref(pat, cmt, true /* implicit */)?;\n+            cmt = Rc::new(self.cat_deref(pat, cmt, true /* implicit */)?);\n         }\n         let cmt = cmt; // lose mutability\n \n@@ -1279,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n+                let subcmt = Rc::new(self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1302,7 +1301,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for fp in field_pats {\n                 let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n                 let f_index = self.tcx.field_index(fp.node.id, self.tables);\n-                let cmt_field = self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty);\n+                let cmt_field =\n+                    Rc::new(self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty));\n                 self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n             }\n           }\n@@ -1320,7 +1320,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n+                let subcmt = Rc::new(self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1329,7 +1329,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, false)?;\n+            let subcmt = Rc::new(self.cat_deref(pat, cmt, false)?);\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n@@ -1342,7 +1342,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 }\n             };\n             let context = InteriorOffsetKind::Pattern;\n-            let elt_cmt = self.cat_index(pat, cmt, element_ty, context)?;\n+            let elt_cmt = Rc::new(self.cat_index(pat, cmt, element_ty, context)?);\n             for before_pat in before {\n                 self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n             }\n@@ -1379,7 +1379,7 @@ pub enum AliasableReason {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    pub fn guarantor(&self) -> cmt<'tcx> {\n+    pub fn guarantor(&self) -> cmt_<'tcx> {\n         //! Returns `self` after stripping away any derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1392,7 +1392,7 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Deref(_, BorrowedPtr(..)) |\n             Categorization::Deref(_, Implicit(..)) |\n             Categorization::Upvar(..) => {\n-                Rc::new((*self).clone())\n+                (*self).clone()\n             }\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) |\n@@ -1442,16 +1442,17 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    // Digs down through one or two layers of deref and grabs the cmt\n-    // for the upvar if a note indicates there is one.\n-    pub fn upvar(&self) -> Option<cmt<'tcx>> {\n+    // Digs down through one or two layers of deref and grabs the\n+    // Categorization of the cmt for the upvar if a note indicates there is\n+    // one.\n+    pub fn upvar_cat(&self) -> Option<&Categorization<'tcx>> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n                     Categorization::Deref(ref inner, _) => {\n                         match inner.cat {\n-                            Categorization::Deref(ref inner, _) => inner.clone(),\n-                            Categorization::Upvar(..) => inner.clone(),\n+                            Categorization::Deref(ref inner, _) => &inner.cat,\n+                            Categorization::Upvar(..) => &inner.cat,\n                             _ => bug!()\n                         }\n                     }\n@@ -1462,7 +1463,6 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-\n     pub fn descriptive_string(&self, tcx: TyCtxt) -> String {\n         match self.cat {\n             Categorization::StaticItem => {\n@@ -1479,8 +1479,7 @@ impl<'tcx> cmt_<'tcx> {\n                 }\n             }\n             Categorization::Deref(_, pk) => {\n-                let upvar = self.upvar();\n-                match upvar.as_ref().map(|i| &i.cat) {\n+                match self.upvar_cat() {\n                     Some(&Categorization::Upvar(ref var)) => {\n                         var.to_string()\n                     }"}, {"sha": "79baf0ec15178299d10b17b186fff0c7dabdc17f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n+               cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n@@ -110,12 +110,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n \n     fn matched_pat(&mut self,\n                    _matched_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n+                   _cmt: &mc::cmt_,\n                    _mode: euv::MatchMode) { }\n \n     fn consume_pat(&mut self,\n                    consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n                consume_pat,\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                bk, loan_cause);\n \n         let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n-        if let Some(lp) = opt_loan_path(&cmt) {\n+        if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n@@ -155,13 +155,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n+              assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n                assignment_id, assignee_cmt);\n \n-        if let Some(lp) = opt_loan_path(&assignee_cmt) {\n+        if let Some(lp) = opt_loan_path(assignee_cmt) {\n             match mode {\n                 MutateMode::Init | MutateMode::JustWrite => {\n                     // In a case like `path = 1`, then path does not\n@@ -363,10 +363,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn check_for_loans_across_yields(&self,\n-                                         cmt: mc::cmt<'tcx>,\n+                                         cmt: &mc::cmt_<'tcx>,\n                                          loan_region: ty::Region<'tcx>,\n                                          borrow_span: Span) {\n-        pub fn borrow_of_local_data<'tcx>(cmt: &mc::cmt<'tcx>) -> bool {\n+        pub fn borrow_of_local_data<'tcx>(cmt: &mc::cmt_<'tcx>) -> bool {\n             match cmt.cat {\n                 // Borrows of static items is allowed\n                 Categorization::StaticItem => false,\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        if !borrow_of_local_data(&cmt) {\n+        if !borrow_of_local_data(cmt) {\n             return;\n         }\n \n@@ -649,9 +649,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn consume_common(&self,\n                       id: hir::ItemLocalId,\n                       span: Span,\n-                      cmt: mc::cmt<'tcx>,\n+                      cmt: &mc::cmt_<'tcx>,\n                       mode: euv::ConsumeMode) {\n-        if let Some(lp) = opt_loan_path(&cmt) {\n+        if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match mode {\n                 euv::Copy => {\n                     self.check_for_copy_of_frozen_path(id, span, &lp);\n@@ -876,11 +876,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_assignment(&self,\n                         assignment_id: hir::ItemLocalId,\n                         assignment_span: Span,\n-                        assignee_cmt: mc::cmt<'tcx>) {\n+                        assignee_cmt: &mc::cmt_<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n         // Check that we don't invalidate any outstanding loans\n-        if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n+        if let Some(loan_path) = opt_loan_path(assignee_cmt) {\n             let scope = region::Scope::Node(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n         if let Categorization::Local(local_id) = assignee_cmt.cat {\n-            let lp = opt_loan_path(&assignee_cmt).unwrap();\n+            let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n                     let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);"}, {"sha": "ac905d6de5d3c0a300dfbd32bde3b06bac21611d", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -26,10 +26,10 @@ use syntax_pos::Span;\n use rustc::hir::*;\n use rustc::hir::map::Node::*;\n \n-struct GatherMoveInfo<'tcx> {\n+struct GatherMoveInfo<'c, 'tcx: 'c> {\n     id: hir::ItemLocalId,\n     kind: MoveKind,\n-    cmt: mc::cmt<'tcx>,\n+    cmt: &'c mc::cmt_<'tcx>,\n     span_path_opt: Option<MovePlace<'tcx>>\n }\n \n@@ -87,7 +87,7 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_data: &MoveData<'tcx>,\n                                        move_error_collector: &mut MoveErrorCollector<'tcx>,\n                                        move_expr_id: hir::ItemLocalId,\n-                                       cmt: mc::cmt<'tcx>,\n+                                       cmt: &mc::cmt_<'tcx>,\n                                        move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n         euv::DirectRefMove | euv::PatBindingMove => MoveExpr,\n@@ -102,11 +102,11 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData<'tcx>,\n-                                      move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                      move_pat: &hir::Pat,\n-                                      cmt: mc::cmt<'tcx>) {\n+pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                              move_data: &MoveData<'tcx>,\n+                                              move_error_collector: &mut MoveErrorCollector<'tcx>,\n+                                              move_pat: &hir::Pat,\n+                                              cmt: &'c mc::cmt_<'tcx>) {\n     let source = get_pattern_source(bccx.tcx,move_pat);\n     let pat_span_path_opt = match move_pat.node {\n         PatKind::Binding(_, _, ref path1, _) => {\n@@ -132,18 +132,17 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+fn gather_move<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                         move_info: GatherMoveInfo<'tcx>) {\n+                         move_info: GatherMoveInfo<'c, 'tcx>) {\n     debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n \n-    let potentially_illegal_move =\n-                check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n+    let potentially_illegal_move = check_and_get_illegal_move_origin(bccx, move_info.cmt);\n     if let Some(illegal_move_origin) = potentially_illegal_move {\n         debug!(\"illegal_move_origin={:?}\", illegal_move_origin);\n-        let error = MoveError::with_move_info(illegal_move_origin,\n+        let error = MoveError::with_move_info(Rc::new(illegal_move_origin),\n                                               move_info.span_path_opt);\n         move_error_collector.add_error(error);\n         return;\n@@ -177,8 +176,8 @@ pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n // (keep in sync with move_error::report_cannot_move_out_of )\n fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                               cmt: &mc::cmt<'tcx>)\n-                                               -> Option<mc::cmt<'tcx>> {\n+                                               cmt: &mc::cmt_<'tcx>)\n+                                               -> Option<mc::cmt_<'tcx>> {\n     match cmt.cat {\n         Categorization::Deref(_, mc::BorrowedPtr(..)) |\n         Categorization::Deref(_, mc::Implicit(..)) |"}, {"sha": "6d73500d318020a65eb4f3b9b7454e1a69f04fe5", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -27,7 +27,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     item_scope: region::Scope,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n-                                    cmt: mc::cmt<'tcx>,\n+                                    cmt: &'a mc::cmt_<'tcx>,\n                                     loan_region: ty::Region<'tcx>,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n@@ -41,8 +41,8 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                          span,\n                                          cause,\n                                          loan_region,\n-                                         cmt_original: cmt.clone()};\n-    ctxt.check(&cmt, None)\n+                                         cmt_original: cmt};\n+    ctxt.check(cmt, None)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -57,12 +57,11 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     span: Span,\n     cause: euv::LoanCause,\n     loan_region: ty::Region<'tcx>,\n-    cmt_original: mc::cmt<'tcx>\n+    cmt_original: &'a mc::cmt_<'tcx>\n }\n \n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n-\n-    fn check(&self, cmt: &mc::cmt<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n+    fn check(&self, cmt: &mc::cmt_<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the\n         //! \"guarantor\".  Reports an error if `self.loan_region` is\n         //! larger than scope of `cmt`.\n@@ -102,7 +101,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn scope(&self, cmt: &mc::cmt<'tcx>) -> ty::Region<'tcx> {\n+    fn scope(&self, cmt: &mc::cmt_<'tcx>) -> ty::Region<'tcx> {\n         //! Returns the maximal region scope for the which the\n         //! place `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -136,7 +135,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n     }\n \n     fn report_error(&self, code: bckerr_code<'tcx>) {\n-        self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n+        self.bccx.report(BckError { cmt: self.cmt_original,\n                                     span: self.span,\n                                     cause: BorrowViolation(self.cause),\n                                     code: code });"}, {"sha": "a74eba3995518b5d149f480f118c9de4e45a670c", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n+               cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n \n     fn matched_pat(&mut self,\n                    matched_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: euv::MatchMode) {\n         debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n                matched_pat,\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n \n     fn consume_pat(&mut self,\n                    consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n                consume_pat,\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n+              assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n     {\n         self.guarantee_assignment_valid(assignment_id,\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 borrow_span: Span,\n                                 loan_cause: AliasableViolationKind,\n-                                cmt: mc::cmt<'tcx>,\n+                                cmt: &mc::cmt_<'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n \n@@ -206,7 +206,7 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                               borrow_span: Span,\n                               cause: AliasableViolationKind,\n-                              cmt: mc::cmt<'tcx>,\n+                              cmt: &mc::cmt_<'tcx>,\n                               req_kind: ty::BorrowKind)\n                               -> Result<(),()> {\n     debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n@@ -246,10 +246,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     fn guarantee_assignment_valid(&mut self,\n                                   assignment_id: ast::NodeId,\n                                   assignment_span: Span,\n-                                  cmt: mc::cmt<'tcx>,\n+                                  cmt: &mc::cmt_<'tcx>,\n                                   mode: euv::MutateMode) {\n \n-        let opt_lp = opt_loan_path(&cmt);\n+        let opt_lp = opt_loan_path(cmt);\n         debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n                assignment_id, cmt, opt_lp);\n \n@@ -259,14 +259,14 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         } else {\n             // Check that we don't allow assignments to non-mutable data.\n             if check_mutability(self.bccx, assignment_span, MutabilityViolation,\n-                                cmt.clone(), ty::MutBorrow).is_err() {\n+                                cmt, ty::MutBorrow).is_err() {\n                 return; // reported an error, no sense in reporting more.\n             }\n         }\n \n         // Check that we don't allow assignments to aliasable data\n         if check_aliasability(self.bccx, assignment_span, MutabilityViolation,\n-                              cmt.clone(), ty::MutBorrow).is_err() {\n+                              cmt, ty::MutBorrow).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n@@ -300,7 +300,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     fn guarantee_valid(&mut self,\n                        borrow_id: hir::ItemLocalId,\n                        borrow_span: Span,\n-                       cmt: mc::cmt<'tcx>,\n+                       cmt: &mc::cmt_<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n@@ -320,28 +320,26 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub,\n-                                        borrow_span, cause, cmt.clone(), loan_region,\n-                                        req_kind).is_err() {\n+                                        borrow_span, cause, cmt, loan_region, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n         if check_mutability(self.bccx, borrow_span, BorrowViolation(cause),\n-                            cmt.clone(), req_kind).is_err() {\n+                            cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n         if check_aliasability(self.bccx, borrow_span, BorrowViolation(cause),\n-                              cmt.clone(), req_kind).is_err() {\n+                              cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n-            self.bccx, borrow_span, cause,\n-            cmt.clone(), loan_region);\n+            self.bccx, borrow_span, cause, &cmt, loan_region);\n \n         debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n "}, {"sha": "0b90127cc7e1e526e2cd82800b3db691cca4f58b", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -30,7 +30,7 @@ pub enum RestrictionResult<'tcx> {\n pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n-                                      cmt: mc::cmt<'tcx>,\n+                                      cmt: &mc::cmt_<'tcx>,\n                                       loan_region: ty::Region<'tcx>)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n@@ -55,7 +55,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n-                cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n+                cmt: &mc::cmt_<'tcx>) -> RestrictionResult<'tcx> {\n         debug!(\"restrict(cmt={:?})\", cmt);\n \n         let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n-                self.restrict(cmt_base)\n+                self.restrict(&cmt_base)\n             }\n \n             Categorization::Interior(cmt_base, interior) => {\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 };\n                 let interior = interior.cleaned();\n                 let base_ty = cmt_base.ty;\n-                let result = self.restrict(cmt_base);\n+                let result = self.restrict(&cmt_base);\n                 // Borrowing one union field automatically borrows all its fields.\n                 match base_ty.sty {\n                     ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         //\n                         // Eventually we should make these non-special and\n                         // just rely on Deref<T> implementation.\n-                        let result = self.restrict(cmt_base);\n+                        let result = self.restrict(&cmt_base);\n                         self.extend(result, &cmt, LpDeref(pk))\n                     }\n                     mc::Implicit(bk, lt) | mc::BorrowedPtr(bk, lt) => {\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                 BckError {\n                                     span: self.span,\n                                     cause: BorrowViolation(self.cause),\n-                                    cmt: cmt_base,\n+                                    cmt: &cmt_base,\n                                     code: err_borrowed_pointer_too_short(\n                                         self.loan_region, lt)});\n                             return RestrictionResult::Safe;\n@@ -169,7 +169,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                 // The referent can be aliased after the\n                                 // references lifetime ends (by a newly-unfrozen\n                                 // borrow).\n-                                let result = self.restrict(cmt_base);\n+                                let result = self.restrict(&cmt_base);\n                                 self.extend(result, &cmt, LpDeref(pk))\n                             }\n                         }\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n \n     fn extend(&self,\n               result: RestrictionResult<'tcx>,\n-              cmt: &mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               elem: LoanPathElem<'tcx>) -> RestrictionResult<'tcx> {\n         match result {\n             RestrictionResult::Safe => RestrictionResult::Safe,"}, {"sha": "98235b2920fdfb8250a41b405a72143d35c69474", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n \n // Avoid \"cannot borrow immutable field `self.x` as mutable\" as that implies that a field *can* be\n // mutable independently of the struct it belongs to. (#35937)\n-pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n+pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt_<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n     let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n \n     match cmt.cat {\n@@ -545,7 +545,7 @@ pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt<'tcx>) -> (Option<Rc<LoanPath<\n /// the method `compute()` found in `gather_loans::restrictions`,\n /// which allows it to share common loan path pieces as it\n /// traverses the CMT.\n-pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n+pub fn opt_loan_path<'tcx>(cmt: &mc::cmt_<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n     opt_loan_path_is_field(cmt).0\n }\n \n@@ -564,10 +564,10 @@ pub enum bckerr_code<'tcx> {\n // Combination of an error code and the categorization of the expression\n // that caused it\n #[derive(Debug, PartialEq)]\n-pub struct BckError<'tcx> {\n+pub struct BckError<'c, 'tcx: 'c> {\n     span: Span,\n     cause: AliasableViolationKind,\n-    cmt: mc::cmt<'tcx>,\n+    cmt: &'c mc::cmt_<'tcx>,\n     code: bckerr_code<'tcx>\n }\n \n@@ -599,7 +599,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         region_rels.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn report(&self, err: BckError<'tcx>) {\n+    pub fn report(&self, err: BckError<'a, 'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n             (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n@@ -800,7 +800,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    fn report_bckerr(&self, err: &BckError<'tcx>) {\n+    fn report_bckerr(&self, err: &BckError<'a, 'tcx>) {\n         let error_span = err.span.clone();\n \n         match err.code {\n@@ -1011,7 +1011,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 db.emit();\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n-                let descr = self.cmt_to_path_or_string(&err.cmt);\n+                let descr = self.cmt_to_path_or_string(err.cmt);\n                 let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n@@ -1042,7 +1042,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                          span: Span,\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason,\n-                                         cmt: mc::cmt<'tcx>) {\n+                                         cmt: &mc::cmt_<'tcx>) {\n         let mut is_closure = false;\n         let prefix = match kind {\n             MutabilityViolation => {\n@@ -1240,7 +1240,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn report_out_of_scope_escaping_closure_capture(&self,\n-                                                    err: &BckError<'tcx>,\n+                                                    err: &BckError<'a, 'tcx>,\n                                                     capture_span: Span)\n     {\n         let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n@@ -1274,18 +1274,18 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'tcx>,\n+    fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'a, 'tcx>,\n                                     error_span: &Span) {\n         match err.cmt.note {\n             mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n                 // If this is an `Fn` closure, it simply can't mutate upvars.\n                 // If it's an `FnMut` closure, the original variable was declared immutable.\n                 // We need to determine which is the case here.\n-                let kind = match err.cmt.upvar().unwrap().cat {\n+                let kind = match err.cmt.upvar_cat().unwrap() {\n                     Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n                     _ => bug!()\n                 };\n-                if kind == ty::ClosureKind::Fn {\n+                if *kind == ty::ClosureKind::Fn {\n                     let closure_node_id =\n                         self.tcx.hir.local_def_id_to_node_id(upvar_id.closure_expr_id);\n                     db.span_help(self.tcx.hir.span(closure_node_id),\n@@ -1389,7 +1389,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         cmt.descriptive_string(self.tcx)\n     }\n \n-    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt<'tcx>) -> String {\n+    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         match opt_loan_path(cmt) {\n             Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n             None => self.cmt_to_string(cmt),"}, {"sha": "77bcd88cecb6ed0e6f362e6c8501f0126d0a8465", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -17,7 +17,7 @@ use super::{Pattern, PatternContext, PatternError, PatternKind};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization::{cmt};\n+use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -573,13 +573,13 @@ struct MutationChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n-    fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n-    fn consume(&mut self, _: ast::NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n-    fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n+    fn matched_pat(&mut self, _: &Pat, _: &cmt_, _: euv::MatchMode) {}\n+    fn consume(&mut self, _: ast::NodeId, _: Span, _: &cmt_, _: ConsumeMode) {}\n+    fn consume_pat(&mut self, _: &Pat, _: &cmt_, _: ConsumeMode) {}\n     fn borrow(&mut self,\n               _: ast::NodeId,\n               span: Span,\n-              _: cmt,\n+              _: &cmt_,\n               _: ty::Region<'tcx>,\n               kind:ty:: BorrowKind,\n               _: LoanCause) {\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n         }\n     }\n     fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n-    fn mutate(&mut self, _: ast::NodeId, span: Span, _: cmt, mode: MutateMode) {\n+    fn mutate(&mut self, _: ast::NodeId, span: Span, _: &cmt_, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")"}, {"sha": "3a577341f7e01b5230494a7bb68d701ddbacaa4e", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -468,13 +468,13 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,\n-               _cmt: mc::cmt,\n+               _cmt: &mc::cmt_,\n                _mode: euv::ConsumeMode) {}\n \n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               _loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause) {\n@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n             _ => {}\n         }\n \n-        let mut cur = &cmt;\n+        let mut cur = cmt;\n         loop {\n             match cur.cat {\n                 Categorization::Rvalue(..) => {\n@@ -521,11 +521,11 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn mutate(&mut self,\n               _assignment_id: ast::NodeId,\n               _assignment_span: Span,\n-              _assignee_cmt: mc::cmt,\n+              _assignee_cmt: &mc::cmt_,\n               _mode: euv::MutateMode) {\n     }\n \n-    fn matched_pat(&mut self, _: &hir::Pat, _: mc::cmt, _: euv::MatchMode) {}\n+    fn matched_pat(&mut self, _: &hir::Pat, _: &mc::cmt_, _: euv::MatchMode) {}\n \n-    fn consume_pat(&mut self, _consume_pat: &hir::Pat, _cmt: mc::cmt, _mode: euv::ConsumeMode) {}\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, _cmt: &mc::cmt_, _mode: euv::ConsumeMode) {}\n }"}, {"sha": "e7e70a19e496b61b3bbeb7887d2e676f278a6d75", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -96,6 +96,7 @@ use rustc::ty::adjustment;\n \n use std::mem;\n use std::ops::Deref;\n+use std::rc::Rc;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -513,7 +514,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // the adjusted form if there is an adjustment.\n         match cmt_result {\n             Ok(head_cmt) => {\n-                self.check_safety_of_rvalue_destructor_if_necessary(head_cmt, expr.span);\n+                self.check_safety_of_rvalue_destructor_if_necessary(&head_cmt, expr.span);\n             }\n             Err(..) => {\n                 self.tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n@@ -799,7 +800,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt<'tcx>> {\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt_<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -814,7 +815,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n-        self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n+        self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n \n         let expr_region = self.tcx.mk_region(ty::ReScope(\n             region::Scope::Node(expr.hir_id.local_id)));\n@@ -837,7 +838,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 });\n \n                 self.link_region(expr.span, deref.region,\n-                                 ty::BorrowKind::from_mutbl(deref.mutbl), cmt.clone());\n+                                 ty::BorrowKind::from_mutbl(deref.mutbl), &cmt);\n \n                 // Specialized version of constrain_call.\n                 self.type_must_outlive(infer::CallRcvr(expr.span),\n@@ -847,7 +848,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n-                self.link_autoref(expr, cmt.clone(), autoref);\n+                self.link_autoref(expr, &cmt, autoref);\n \n                 // Require that the resulting region encompasses\n                 // the current node.\n@@ -878,7 +879,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n-                                                     cmt: mc::cmt<'tcx>,\n+                                                     cmt: &mc::cmt_<'tcx>,\n                                                      span: Span) {\n         match cmt.cat {\n             Categorization::Rvalue(region) => {\n@@ -980,7 +981,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n-        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, cmt);\n+        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, &cmt);\n     }\n \n     /// Computes the guarantors for any ref bindings in a `let` and\n@@ -992,7 +993,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             None => { return; }\n             Some(ref expr) => &**expr,\n         };\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n+        let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr))));\n         self.link_pattern(discr_cmt, &local.pat);\n     }\n \n@@ -1001,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n+        let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(discr))));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n             for root_pat in &arm.pats {\n@@ -1019,7 +1020,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_ty = self.node_ty(arg.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = self.with_mc(|mc| {\n-                mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n+                Rc::new(mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty))\n             });\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n@@ -1044,7 +1045,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                                .expect(\"missing binding mode\");\n                         if let ty::BindByReference(mutbl) = bm {\n                             self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                            mutbl, sub_cmt);\n+                                                            mutbl, &sub_cmt);\n                         }\n                     }\n                     _ => {}\n@@ -1057,15 +1058,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// autoref'd.\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n-                    expr_cmt: mc::cmt<'tcx>,\n+                    expr_cmt: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n-                self.link_region(expr.span, r,\n-                                 ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n+                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n@@ -1081,15 +1081,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   id: hir::HirId,\n                                   mutbl: hir::Mutability,\n-                                  cmt_borrowed: mc::cmt<'tcx>) {\n+                                  cmt_borrowed: &mc::cmt_<'tcx>) {\n         debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n         if let ty::TyRef(r, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n-            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl),\n-                             cmt_borrowed);\n+            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n     }\n \n@@ -1101,27 +1100,27 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                    span: Span,\n                    borrow_region: ty::Region<'tcx>,\n                    borrow_kind: ty::BorrowKind,\n-                   borrow_cmt: mc::cmt<'tcx>) {\n-        let mut borrow_cmt = borrow_cmt;\n-        let mut borrow_kind = borrow_kind;\n-\n+                   borrow_cmt: &mc::cmt_<'tcx>) {\n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n         self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n+        let mut borrow_kind = borrow_kind;\n+        let mut borrow_cmt_cat = borrow_cmt.cat.clone();\n+\n         loop {\n             debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n                    borrow_region,\n                    borrow_kind,\n                    borrow_cmt);\n-            match borrow_cmt.cat.clone() {\n+            match borrow_cmt_cat {\n                 Categorization::Deref(ref_cmt, mc::Implicit(ref_kind, ref_region)) |\n                 Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n                     match self.link_reborrowed_region(span,\n                                                       borrow_region, borrow_kind,\n                                                       ref_cmt, ref_region, ref_kind,\n                                                       borrow_cmt.note) {\n                         Some((c, k)) => {\n-                            borrow_cmt = c;\n+                            borrow_cmt_cat = c.cat.clone();\n                             borrow_kind = k;\n                         }\n                         None => {\n@@ -1135,7 +1134,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 Categorization::Interior(cmt_base, _) => {\n                     // Borrowing interior or owned data requires the base\n                     // to be valid and borrowable in the same fashion.\n-                    borrow_cmt = cmt_base;\n+                    borrow_cmt_cat = cmt_base.cat.clone();\n                     borrow_kind = borrow_kind;\n                 }\n "}, {"sha": "58dc5839578f783df3620713d481e0f52154c955", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=7cf142f78b82b0b2ae08b52ccb6a6e15c0270c38", "patch": "@@ -298,7 +298,8 @@ struct InferBorrowKind<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: &mc::cmt_<'tcx>,\n+                                            mode: euv::ConsumeMode) {\n         debug!(\n             \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n             cmt,\n@@ -377,7 +378,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: &mc::cmt_<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n@@ -386,7 +387,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             Categorization::Downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n-                self.adjust_upvar_borrow_kind_for_mut(base);\n+                self.adjust_upvar_borrow_kind_for_mut(&base);\n             }\n \n             Categorization::Deref(base, mc::BorrowedPtr(..)) |\n@@ -396,7 +397,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n                     // necessarily *mutable*\n-                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                    self.adjust_upvar_borrow_kind_for_unique(&base);\n                 }\n             }\n \n@@ -410,7 +411,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: mc::cmt<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: &mc::cmt_<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n@@ -419,15 +420,15 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             Categorization::Downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n-                self.adjust_upvar_borrow_kind_for_unique(base);\n+                self.adjust_upvar_borrow_kind_for_unique(&base);\n             }\n \n             Categorization::Deref(base, mc::BorrowedPtr(..)) |\n             Categorization::Deref(base, mc::Implicit(..)) => {\n                 if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n-                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                    self.adjust_upvar_borrow_kind_for_unique(&base);\n                 }\n             }\n \n@@ -439,7 +440,9 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&mut self, cmt: mc::cmt<'tcx>, borrow_kind: ty::BorrowKind) -> bool {\n+    fn try_adjust_upvar_deref(&mut self, cmt: &mc::cmt_<'tcx>, borrow_kind: ty::BorrowKind)\n+                              -> bool\n+    {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -581,17 +584,19 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         &mut self,\n         _consume_id: ast::NodeId,\n         _consume_span: Span,\n-        cmt: mc::cmt<'tcx>,\n+        cmt: &mc::cmt_<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: mc::cmt<'tcx>, _mode: euv::MatchMode) {\n+    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: &mc::cmt_<'tcx>,\n+                   _mode: euv::MatchMode) {\n     }\n \n-    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: &mc::cmt_<'tcx>,\n+                   mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n@@ -600,7 +605,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         &mut self,\n         borrow_id: ast::NodeId,\n         _borrow_span: Span,\n-        cmt: mc::cmt<'tcx>,\n+        cmt: &mc::cmt_<'tcx>,\n         _loan_region: ty::Region<'tcx>,\n         bk: ty::BorrowKind,\n         _loan_cause: euv::LoanCause,\n@@ -629,7 +634,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         &mut self,\n         _assignment_id: ast::NodeId,\n         _assignment_span: Span,\n-        assignee_cmt: mc::cmt<'tcx>,\n+        assignee_cmt: &mc::cmt_<'tcx>,\n         _mode: euv::MutateMode,\n     ) {\n         debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);"}]}