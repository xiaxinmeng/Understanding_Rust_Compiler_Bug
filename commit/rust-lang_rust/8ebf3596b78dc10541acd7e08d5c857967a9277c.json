{"sha": "8ebf3596b78dc10541acd7e08d5c857967a9277c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYmYzNTk2Yjc4ZGMxMDU0MWFjZDdlMDhkNWM4NTc5NjdhOTI3N2M=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2020-09-11T15:05:10Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2020-09-11T15:05:10Z"}, "message": "Complete trait impl immediately after type/const/fn", "tree": {"sha": "c0d727a8fb6ca07d4d455d67843e6ab0230bea82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0d727a8fb6ca07d4d455d67843e6ab0230bea82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ebf3596b78dc10541acd7e08d5c857967a9277c", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl9bkiYACgkQztOS3gxI\nPQDX0RAAmX7dERBo20+tHAdPGN0+G5eJv7JJafDDleY5Og9K+pMH7yuhq1a5yBkY\nLGyB7YGHh5wWmavjW0+JMai6ZXCpWaWrG5dF9ndfJ7ubx+Mt3XFxgEuvVIDysrLu\nZNf/N3Rhx+VNFaREuki3f0Bute5X2QZAbW4N1ItWwtg0KBMN4nQQRD/C22uz80Yi\nVOGqm4AQsPEvNE1S4OEgx0eBsTyAVuzjy6pTaNKuoX759Wh8knLpJyS6FkzEAZ6T\nibDVdusWryFQDTqS7viPMJASJT88WeF0GNrKYtpuea52muR4C7tbyXS6WS71N+jT\nBxEDOz/7o3VTUNzwN2IAOPRWToZeQI2W0U2Prk7WlOBG7IyMv8LvMGij7PLVGUbI\nAUCxfkNlYhp1YODRLl/BTE+b0AU/af8uJxWwWfIreGVCEu150WK0IY8mDasKeqiF\nqCCPxQ0ifoPS2aoj1D6XqgFBihsWbh8wkGIu/YaInkeQ64F1KrP08VR1QDWRweHK\nSi5aFgQPPIvF9+0RLfcL22XU/ToKEKDnI7PkXVN9cghlg7QH+V33Xnt6dJMfTdgu\ngt/81JSAlq4Ho6761gavl2jFFKWL6zP714TUk52lmQOSiUlgrgusZlxw0E030qlG\nmprBhX4E3EXbT7M8Bq7cc9EvtSBuRbNe5sua6XbgM/lCIE1q+bI=\n=yIsn\n-----END PGP SIGNATURE-----", "payload": "tree c0d727a8fb6ca07d4d455d67843e6ab0230bea82\nparent 4f1167d8ddac9d392f034341e6bc032b51014918\nauthor oxalica <oxalicc@pm.me> 1599836710 +0800\ncommitter oxalica <oxalicc@pm.me> 1599836710 +0800\n\nComplete trait impl immediately after type/const/fn\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebf3596b78dc10541acd7e08d5c857967a9277c", "html_url": "https://github.com/rust-lang/rust/commit/8ebf3596b78dc10541acd7e08d5c857967a9277c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ebf3596b78dc10541acd7e08d5c857967a9277c/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f1167d8ddac9d392f034341e6bc032b51014918", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1167d8ddac9d392f034341e6bc032b51014918", "html_url": "https://github.com/rust-lang/rust/commit/4f1167d8ddac9d392f034341e6bc032b51014918"}], "stats": {"total": 175, "additions": 119, "deletions": 56}, "files": [{"sha": "bff2603b82ec4e0adecc11cc9e56dc4433e3a994", "filename": "crates/ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 119, "deletions": 56, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf3596b78dc10541acd7e08d5c857967a9277c/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf3596b78dc10541acd7e08d5c857967a9277c/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=8ebf3596b78dc10541acd7e08d5c857967a9277c", "patch": "@@ -46,76 +46,76 @@ use crate::{\n     display::function_declaration,\n };\n \n+#[derive(Debug, PartialEq, Eq)]\n+enum ImplCompletionKind {\n+    All,\n+    Fn,\n+    TypeAlias,\n+    Const,\n+}\n+\n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some((trigger, impl_def)) = completion_match(ctx) {\n-        match trigger.kind() {\n-            SyntaxKind::NAME_REF => get_missing_assoc_items(&ctx.sema, &impl_def)\n-                .into_iter()\n-                .for_each(|item| match item {\n-                    hir::AssocItem::Function(fn_item) => {\n-                        add_function_impl(&trigger, acc, ctx, fn_item)\n-                    }\n-                    hir::AssocItem::TypeAlias(type_item) => {\n-                        add_type_alias_impl(&trigger, acc, ctx, type_item)\n-                    }\n-                    hir::AssocItem::Const(const_item) => {\n-                        add_const_impl(&trigger, acc, ctx, const_item)\n-                    }\n-                }),\n-\n-            SyntaxKind::FN => {\n-                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n-                    .into_iter()\n-                    .filter_map(|item| match item {\n-                        hir::AssocItem::Function(fn_item) => Some(fn_item),\n-                        _ => None,\n-                    })\n-                {\n-                    add_function_impl(&trigger, acc, ctx, missing_fn);\n-                }\n+    if let Some((kind, trigger, impl_def)) = completion_match(ctx) {\n+        get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| match item {\n+            hir::AssocItem::Function(fn_item)\n+                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Fn =>\n+            {\n+                add_function_impl(&trigger, acc, ctx, fn_item)\n             }\n-\n-            SyntaxKind::TYPE_ALIAS => {\n-                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n-                    .into_iter()\n-                    .filter_map(|item| match item {\n-                        hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n-                        _ => None,\n-                    })\n-                {\n-                    add_type_alias_impl(&trigger, acc, ctx, missing_fn);\n-                }\n+            hir::AssocItem::TypeAlias(type_item)\n+                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::TypeAlias =>\n+            {\n+                add_type_alias_impl(&trigger, acc, ctx, type_item)\n             }\n-\n-            SyntaxKind::CONST => {\n-                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n-                    .into_iter()\n-                    .filter_map(|item| match item {\n-                        hir::AssocItem::Const(const_item) => Some(const_item),\n-                        _ => None,\n-                    })\n-                {\n-                    add_const_impl(&trigger, acc, ctx, missing_fn);\n-                }\n+            hir::AssocItem::Const(const_item)\n+                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Const =>\n+            {\n+                add_const_impl(&trigger, acc, ctx, const_item)\n             }\n-\n             _ => {}\n-        }\n+        });\n     }\n }\n \n-fn completion_match(ctx: &CompletionContext) -> Option<(SyntaxNode, Impl)> {\n-    let (trigger, impl_def_offset) = ctx.token.ancestors().find_map(|p| match p.kind() {\n-        SyntaxKind::FN | SyntaxKind::TYPE_ALIAS | SyntaxKind::CONST | SyntaxKind::BLOCK_EXPR => {\n-            Some((p, 2))\n+fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, SyntaxNode, Impl)> {\n+    let mut token = ctx.token.clone();\n+    // For keywork without name like `impl .. { fn <|> }`, the current position is inside\n+    // the whitespace token, which is outside `FN` syntax node.\n+    // We need to follow the previous token in this case.\n+    if token.kind() == SyntaxKind::WHITESPACE {\n+        token = token.prev_token()?;\n+    }\n+\n+    let (kind, trigger, impl_def_offset) = token.ancestors().find_map(|p| match p.kind() {\n+        // `const` can be a modifier of an item, so the `const` token may be inside another item syntax node.\n+        // Eg. `impl .. { const <|> fn bar() .. }`\n+        SyntaxKind::FN | SyntaxKind::TYPE_ALIAS | SyntaxKind::CONST\n+            if token.kind() == SyntaxKind::CONST_KW =>\n+        {\n+            Some((ImplCompletionKind::Const, p, 2))\n         }\n-        SyntaxKind::NAME_REF => Some((p, 5)),\n+        SyntaxKind::FN => Some((ImplCompletionKind::Fn, p, 2)),\n+        SyntaxKind::TYPE_ALIAS => Some((ImplCompletionKind::TypeAlias, p, 2)),\n+        SyntaxKind::CONST => Some((ImplCompletionKind::Const, p, 2)),\n+        // `impl .. { const <|> }` is parsed as:\n+        // IMPL\n+        //   ASSOC_ITEM_LIST\n+        //     ERROR\n+        //       CONST_KW <- token\n+        //     WHITESPACE <- ctx.token\n+        SyntaxKind::ERROR\n+            if p.first_token().map_or(false, |t| t.kind() == SyntaxKind::CONST_KW) =>\n+        {\n+            Some((ImplCompletionKind::Const, p, 2))\n+        }\n+        SyntaxKind::NAME_REF => Some((ImplCompletionKind::All, p, 5)),\n         _ => None,\n     })?;\n+\n     let impl_def = (0..impl_def_offset - 1)\n         .try_fold(trigger.parent()?, |t, _| t.parent())\n         .and_then(ast::Impl::cast)?;\n-    Some((trigger, impl_def))\n+    Some((kind, trigger, impl_def))\n }\n \n fn add_function_impl(\n@@ -485,4 +485,67 @@ impl Test for () {\n \",\n         );\n     }\n+\n+    #[test]\n+    fn complete_without_name() {\n+        let test = |completion: &str, hint: &str, completed: &str, next_sibling: &str| {\n+            println!(\n+                \"completion='{}', hint='{}', next_sibling='{}'\",\n+                completion, hint, next_sibling\n+            );\n+\n+            check_edit(\n+                completion,\n+                &format!(\n+                    r#\"\n+trait Test {{\n+    type Foo;\n+    const CONST: u16;\n+    fn bar();\n+}}\n+struct T;\n+\n+impl Test for T {{\n+    {}\n+    {}\n+}}\n+\"#,\n+                    hint, next_sibling\n+                ),\n+                &format!(\n+                    r#\"\n+trait Test {{\n+    type Foo;\n+    const CONST: u16;\n+    fn bar();\n+}}\n+struct T;\n+\n+impl Test for T {{\n+    {}\n+    {}\n+}}\n+\"#,\n+                    completed, next_sibling\n+                ),\n+            )\n+        };\n+\n+        // Enumerate some possible next siblings.\n+        for next_sibling in &[\n+            \"\",\n+            \"fn other_fn() {}\", // `const <|> fn` -> `const fn`\n+            \"type OtherType = i32;\",\n+            \"const OTHER_CONST: i32 = 0;\",\n+            \"async fn other_fn() {}\",\n+            \"unsafe fn other_fn() {}\",\n+            \"default fn other_fn() {}\",\n+            \"default type OtherType = i32;\",\n+            \"default const OTHER_CONST: i32 = 0;\",\n+        ] {\n+            test(\"bar\", \"fn <|>\", \"fn bar() {\\n    $0\\n}\", next_sibling);\n+            test(\"Foo\", \"type <|>\", \"type Foo = \", next_sibling);\n+            test(\"CONST\", \"const <|>\", \"const CONST: u16 = \", next_sibling);\n+        }\n+    }\n }"}]}