{"sha": "8acadb17c2d679291aa94e94af8cc96513cab830", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhY2FkYjE3YzJkNjc5MjkxYWE5NGU5NGFmOGNjOTY1MTNjYWI4MzA=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-07T18:53:08Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-08T01:22:27Z"}, "message": "Work on debugging race conditions.\n\nPorts and channels have been moved to the kernel pool, since they've\nbeen known to outlive their associated task. This probably isn't the\nright thing to do, the life cycle needs fixed instead.\n\nSome refactorying in memory_region.cpp. Added a helper function to\nincrement and decrement the allocation counter. This makes it easier\nto switch between atomic and non-atomic increments. Using atomic\nincrements for now, although this still does not fix the problem.", "tree": {"sha": "4bf732a0c5c6857382fb63310aad9961190fdf52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bf732a0c5c6857382fb63310aad9961190fdf52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8acadb17c2d679291aa94e94af8cc96513cab830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8acadb17c2d679291aa94e94af8cc96513cab830", "html_url": "https://github.com/rust-lang/rust/commit/8acadb17c2d679291aa94e94af8cc96513cab830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8acadb17c2d679291aa94e94af8cc96513cab830/comments", "author": null, "committer": null, "parents": [{"sha": "dcd2563a3a7662d03ab33b67c92652e6e24c5af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd2563a3a7662d03ab33b67c92652e6e24c5af1", "html_url": "https://github.com/rust-lang/rust/commit/dcd2563a3a7662d03ab33b67c92652e6e24c5af1"}], "stats": {"total": 125, "additions": 90, "deletions": 35}, "files": [{"sha": "809ac81f716bbb304f72864b3de9a642d0e30056", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -19,8 +19,18 @@ memory_region::memory_region(memory_region *parent) :\n     // Nop.\n }\n \n+void memory_region::add_alloc() {\n+    //_live_allocations++;\n+    sync::increment(_live_allocations);\n+}\n+\n+void memory_region::dec_alloc() {\n+    //_live_allocations--;\n+    sync::decrement(_live_allocations);\n+}\n+\n void memory_region::free(void *mem) {\n-    // printf(\"free: ptr 0x%\" PRIxPTR\"\\n\", (uintptr_t) mem);\n+    // printf(\"free: ptr 0x%\" PRIxPTR\" region=%p\\n\", (uintptr_t) mem, this);\n     if (!mem) { return; }\n     if (_synchronized) { _lock.lock(); }\n #ifdef TRACK_ALLOCATIONS\n@@ -33,7 +43,7 @@ void memory_region::free(void *mem) {\n     if (_live_allocations < 1) {\n         _srv->fatal(\"live_allocs < 1\", __FILE__, __LINE__, \"\");\n     }\n-    _live_allocations--;\n+    dec_alloc();\n     _srv->free(mem);\n     if (_synchronized) { _lock.unlock(); }\n }\n@@ -42,7 +52,7 @@ void *\n memory_region::realloc(void *mem, size_t size) {\n     if (_synchronized) { _lock.lock(); }\n     if (!mem) {\n-        _live_allocations++;\n+        add_alloc();\n     }\n     void *newMem = _srv->realloc(mem, size);\n #ifdef TRACK_ALLOCATIONS\n@@ -59,20 +69,21 @@ memory_region::realloc(void *mem, size_t size) {\n void *\n memory_region::malloc(size_t size) {\n     if (_synchronized) { _lock.lock(); }\n-    _live_allocations++;\n+    add_alloc();\n     void *mem = _srv->malloc(size);\n #ifdef TRACK_ALLOCATIONS\n     _allocation_list.append(mem);\n #endif\n-    // printf(\"malloc: ptr 0x%\" PRIxPTR \"\\n\", (uintptr_t) mem);\n+    // printf(\"malloc: ptr 0x%\" PRIxPTR \" region=%p\\n\", \n+    //        (uintptr_t) mem, this);\n     if (_synchronized) { _lock.unlock(); }\n     return mem;\n }\n \n void *\n memory_region::calloc(size_t size) {\n     if (_synchronized) { _lock.lock(); }\n-    _live_allocations++;\n+    add_alloc();\n     void *mem = _srv->malloc(size);\n     memset(mem, 0, size);\n #ifdef TRACK_ALLOCATIONS"}, {"sha": "36b2e1a4164055635c378e2542c586d3558397b0", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -22,6 +22,9 @@ class memory_region {\n     const bool _detailed_leaks;\n     const bool _synchronized;\n     lock_and_signal _lock;\n+\n+    void add_alloc();\n+    void dec_alloc();\n public:\n     memory_region(rust_srv *srv, bool synchronized);\n     memory_region(memory_region *parent);"}, {"sha": "141d60a3e9c1c06fe26b55e0f9d9d0cbcbf9375c", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -6,11 +6,12 @@\n  */\n rust_chan::rust_chan(rust_task *task,\n                      maybe_proxy<rust_port> *port,\n-                     size_t unit_sz) :\n-                     ref_count(1),\n-                     task(task),\n-                     port(port),\n-                     buffer(task, unit_sz) {\n+                     size_t unit_sz) \n+    : ref_count(1),\n+      kernel(task->kernel),\n+      task(task),\n+      port(port),\n+      buffer(task, unit_sz) {\n     ++task->ref_count;\n     if (port) {\n         associate(port);\n@@ -87,6 +88,7 @@ void rust_chan::send(void *sptr) {\n         buffer.dequeue(NULL);\n     } else {\n         rust_port *target_port = port->referent();\n+        scoped_lock right(target_port->lock);\n         if (target_port->task->blocked_on(target_port)) {\n             DLOG(sched, comm, \"dequeued in rendezvous_ptr\");\n             buffer.dequeue(target_port->task->rendezvous_ptr);\n@@ -114,7 +116,7 @@ rust_chan *rust_chan::clone(maybe_proxy<rust_task> *target) {\n         port = proxy;\n         target_task = target->as_proxy()->handle()->referent();\n     }\n-    return new (target_task) rust_chan(target_task, port, unit_sz);\n+    return new (target_task->kernel) rust_chan(target_task, port, unit_sz);\n }\n \n /**"}, {"sha": "752667b8a3c68952b59f6057609e021ef31fe6f4", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -1,14 +1,15 @@\n #ifndef RUST_CHAN_H\n #define RUST_CHAN_H\n \n-class rust_chan : public task_owned<rust_chan>,\n+class rust_chan : public kernel_owned<rust_chan>,\n                   public rust_cond {\n public:\n     RUST_REFCOUNTED_WITH_DTOR(rust_chan, destroy())\n     rust_chan(rust_task *task, maybe_proxy<rust_port> *port, size_t unit_sz);\n \n     ~rust_chan();\n \n+    rust_kernel *kernel;\n     rust_task *task;\n     maybe_proxy<rust_port> *port;\n     size_t idx;"}, {"sha": "0aebda859f88fd83856b4cf4aa9707d0ee921bcd", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -1,16 +1,16 @@\n #include \"rust_internal.h\"\n #include \"rust_port.h\"\n \n-rust_port::rust_port(rust_task *task, size_t unit_sz) :\n-                     maybe_proxy<rust_port>(this), task(task),\n-                     unit_sz(unit_sz), writers(task), chans(task) {\n+rust_port::rust_port(rust_task *task, size_t unit_sz) \n+    : maybe_proxy<rust_port>(this), kernel(task->kernel), task(task),\n+      unit_sz(unit_sz), writers(task), chans(task) {\n \n     LOG(task, comm,\n         \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n         PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n \n     // Allocate a remote channel, for remote channel data.\n-    remote_channel = new (task) rust_chan(task, this, unit_sz);\n+    remote_channel = new (task->kernel) rust_chan(task, this, unit_sz);\n }\n \n rust_port::~rust_port() {"}, {"sha": "301422cc765da64c5d2f693e6ff6f0b213d013a3", "filename": "src/rt/rust_port.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_port.h", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_port.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.h?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -2,9 +2,10 @@\n #define RUST_PORT_H\n \n class rust_port : public maybe_proxy<rust_port>,\n-                  public task_owned<rust_port> {\n+                  public kernel_owned<rust_port> {\n \n public:\n+    rust_kernel *kernel;\n     rust_task *task;\n     size_t unit_sz;\n     ptr_vec<rust_token> writers;\n@@ -13,6 +14,8 @@ class rust_port : public maybe_proxy<rust_port>,\n     // Data sent to this port from remote tasks is buffered in this channel.\n     rust_chan *remote_channel;\n \n+    lock_and_signal lock;\n+\n     rust_port(rust_task *task, size_t unit_sz);\n     ~rust_port();\n     void log_state();"}, {"sha": "6c7ab5540021690673b523983dec9d237bfe3ca1", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -401,6 +401,7 @@ rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n \n void\n rust_task::block(rust_cond *on, const char* name) {\n+    scoped_lock with(lock);\n     LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n     A(sched, cond == NULL, \"Cannot block an already blocked task.\");\n@@ -413,6 +414,7 @@ rust_task::block(rust_cond *on, const char* name) {\n \n void\n rust_task::wakeup(rust_cond *from) {\n+    scoped_lock with(lock);\n     A(sched, cond != NULL, \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n@@ -430,6 +432,7 @@ rust_task::wakeup(rust_cond *from) {\n \n void\n rust_task::die() {\n+    scoped_lock with(lock);\n     transition(&sched->running_tasks, &sched->dead_tasks);\n }\n "}, {"sha": "c20eae7ece85a2fb379726abc88526daeb885d7a", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -89,6 +89,8 @@ rust_task : public maybe_proxy<rust_task>,\n \n     wakeup_callback *_on_wakeup;\n \n+    lock_and_signal lock;\n+\n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n     rust_task(rust_scheduler *sched,\n               rust_task_list *state,"}, {"sha": "383e856f69a65a8fb3a1f67c378404180599130f", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -92,7 +92,9 @@ upcall_new_port(rust_task *task, size_t unit_sz) {\n     LOG_UPCALL_ENTRY(task);\n     LOG(task, comm, \"upcall_new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n         (uintptr_t) task, task->name, unit_sz);\n-    return new (task) rust_port(task, unit_sz);\n+    // take a reference on behalf of the port\n+    task->ref();\n+    return new (task->kernel) rust_port(task, unit_sz);\n }\n \n extern \"C\" CDECL void\n@@ -101,6 +103,9 @@ upcall_del_port(rust_task *task, rust_port *port) {\n     LOG(task, comm, \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     I(task->sched, !port->ref_count);\n     delete port;\n+\n+    // FIXME: We shouldn't ever directly manipulate the ref count.\n+    --task->ref_count;\n }\n \n /**\n@@ -114,7 +119,7 @@ upcall_new_chan(rust_task *task, rust_port *port) {\n         \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n         (uintptr_t) task, task->name, port);\n     I(sched, port);\n-    return new (task) rust_chan(task, port, port->unit_sz);\n+    return new (task->kernel) rust_chan(task, port, port->unit_sz);\n }\n \n /**\n@@ -138,6 +143,8 @@ extern \"C\" CDECL\n void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n \n+    I(task->sched, chan->task == task);\n+\n     LOG(task, comm, \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n     chan->destroy();\n }\n@@ -183,25 +190,27 @@ upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n \n extern \"C\" CDECL void\n upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n-    LOG_UPCALL_ENTRY(task);\n+    {\n+        scoped_lock with(port->lock);\n+        LOG_UPCALL_ENTRY(task);\n     \n-    LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n-        \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n-        (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n-        port->chans.length());\n+        LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n+            \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n+            (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n+            port->chans.length());\n     \n-    if (port->receive(dptr)) {\n-        return;\n-    }\n+        if (port->receive(dptr)) {\n+            return;\n+        }\n     \n-    // No data was buffered on any incoming channel, so block this task on the\n-    // port. Remember the rendezvous location so that any sender task can\n-    // write to it before waking up this task.\n+        // No data was buffered on any incoming channel, so block this task on\n+        // the port. Remember the rendezvous location so that any sender task\n+        // can write to it before waking up this task.\n     \n-    LOG(task, comm, \"<=== waiting for rendezvous data ===\");\n-    task->rendezvous_ptr = dptr;\n-    task->block(port, \"waiting for rendezvous data\");\n-\n+        LOG(task, comm, \"<=== waiting for rendezvous data ===\");\n+        task->rendezvous_ptr = dptr;\n+        task->block(port, \"waiting for rendezvous data\");\n+    }\n     task->yield(3);\n }\n "}, {"sha": "360fff1fabda555e26050db0865ce697100da1af", "filename": "src/rt/sync/sync.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Fsync%2Fsync.h", "raw_url": "https://github.com/rust-lang/rust/raw/8acadb17c2d679291aa94e94af8cc96513cab830/src%2Frt%2Fsync%2Fsync.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fsync.h?ref=8acadb17c2d679291aa94e94af8cc96513cab830", "patch": "@@ -1,3 +1,4 @@\n+// -*- c++-mode -*-\n #ifndef SYNC_H\n #define SYNC_H\n \n@@ -10,6 +11,26 @@ class sync {\n         T oldValue, T newValue) {\n         return __sync_bool_compare_and_swap(address, oldValue, newValue);\n     }\n+    \n+    template <class T>\n+    static T increment(T *address) {\n+        return __sync_add_and_fetch(address, 1);\n+    }\n+\n+    template <class T>\n+    static T decrement(T *address) {\n+        return __sync_sub_and_fetch(address, 1);\n+    }    \n+\n+    template <class T>\n+    static T increment(T &address) {\n+        return __sync_add_and_fetch(&address, 1);\n+    }\n+\n+    template <class T>\n+    static T decrement(T &address) {\n+        return __sync_sub_and_fetch(&address, 1);\n+    }    \n };\n \n /**"}]}