{"sha": "3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZjcyNGQwYzEyMmYwOGNjYmIzYTlmNzdjYjBhZDg4OGQ4YmViZjA=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-11-19T12:55:55Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-01-31T16:37:17Z"}, "message": "Bundle and document 6 BTreeMap navigation algorithms", "tree": {"sha": "82c1d3061d319c2dfd7cdc992291d500dab7153e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82c1d3061d319c2dfd7cdc992291d500dab7153e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "html_url": "https://github.com/rust-lang/rust/commit/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecde10fc283530db0db42e2c3e2e3132e809b139", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecde10fc283530db0db42e2c3e2e3132e809b139", "html_url": "https://github.com/rust-lang/rust/commit/ecde10fc283530db0db42e2c3e2e3132e809b139"}], "stats": {"total": 550, "additions": 314, "deletions": 236}, "files": [{"sha": "8eabc1773042f5e2d176ae640585bb2cbf18818d", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 42, "deletions": 236, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "patch": "@@ -6,10 +6,11 @@ use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, intrinsics, mem, ptr};\n+use core::{fmt, mem, ptr};\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n+use super::unwrap_unchecked;\n \n use Entry::*;\n use UnderflowResult::*;\n@@ -645,7 +646,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = first_leaf_edge(self.root.as_ref());\n+        let front = self.root.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -706,7 +707,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = last_leaf_edge(self.root.as_ref());\n+        let back = self.root.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -1073,7 +1074,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n+        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1113,7 +1114,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 open_node.push(key, value, right_tree);\n \n                 // Go down to the right-most leaf again.\n-                cur_node = last_leaf_edge(open_node.forget_type()).into_node();\n+                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n             }\n \n             self.length += 1;\n@@ -1411,10 +1412,8 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe {\n-                let (k, v) = self.range.next_unchecked();\n-                Some((k, v)) // coerce k from `&mut K` to `&K`\n-            }\n+            let (k, v) = unsafe { self.range.next_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n \n@@ -1434,7 +1433,8 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe { Some(self.range.next_back_unchecked()) }\n+            let (k, v) = unsafe { self.range.next_back_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n }\n@@ -1460,7 +1460,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter { front: first_leaf_edge(root1), back: last_leaf_edge(root2), length: len }\n+        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n     }\n }\n \n@@ -1475,9 +1475,9 @@ impl<K, V> Drop for IntoIter<K, V> {\n             }\n \n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n-                let mut cur_node = first_parent.into_node();\n-                while let Some(parent) = cur_node.deallocate_and_ascend() {\n-                    cur_node = parent.into_node()\n+                let mut cur_internal_node = first_parent.into_node();\n+                while let Some(parent) = cur_internal_node.deallocate_and_ascend() {\n+                    cur_internal_node = parent.into_node()\n                 }\n             }\n         }\n@@ -1490,37 +1490,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n \n     fn next(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n-            return None;\n+            None\n         } else {\n             self.length -= 1;\n-        }\n-\n-        let handle = unsafe { ptr::read(&self.front) };\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                self.front = kv.right_edge();\n-                return Some((k, v));\n-            }\n-            Err(last_edge) => unsafe {\n-                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            },\n-        };\n-\n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return Some((k, v));\n-                }\n-                Err(last_edge) => unsafe {\n-                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                },\n-            }\n+            Some(unsafe { self.front.next_unchecked() })\n         }\n     }\n \n@@ -1533,37 +1506,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n-            return None;\n+            None\n         } else {\n             self.length -= 1;\n-        }\n-\n-        let handle = unsafe { ptr::read(&self.back) };\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                self.back = kv.left_edge();\n-                return Some((k, v));\n-            }\n-            Err(last_edge) => unsafe {\n-                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            },\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return Some((k, v));\n-                }\n-                Err(last_edge) => unsafe {\n-                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                },\n-            }\n+            Some(unsafe { self.back.next_back_unchecked() })\n         }\n     }\n }\n@@ -1665,7 +1611,7 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n+        if self.is_empty() { None } else { unsafe { Some(self.next_unchecked()) } }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n@@ -1708,73 +1654,25 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n impl<'a, K, V> Range<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let handle = self.front;\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                let ret = kv.into_kv();\n-                self.front = kv.right_edge();\n-                return ret;\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n+    fn is_empty(&self) -> bool {\n+        self.front == self.back\n+    }\n \n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    let ret = kv.into_kv();\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return ret;\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        self.front.next_unchecked()\n     }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n     }\n }\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let handle = self.back;\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                let ret = kv.into_kv();\n-                self.back = kv.left_edge();\n-                return ret;\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    let ret = kv.into_kv();\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return ret;\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+        self.back.next_back_unchecked()\n     }\n }\n \n@@ -1796,10 +1694,8 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n         if self.is_empty() {\n             None\n         } else {\n-            unsafe {\n-                let (k, v) = self.next_unchecked();\n-                Some((k, v)) // coerce k from `&mut K` to `&K`\n-            }\n+            let (k, v) = unsafe { self.next_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n \n@@ -1814,81 +1710,28 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let handle = ptr::read(&self.front);\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                self.front = ptr::read(&kv).right_edge();\n-                // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                // so we have to do this last.\n-                return kv.into_kv_mut();\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n-                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                    // so we have to do this last.\n-                    return kv.into_kv_mut();\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+        self.front.next_unchecked()\n     }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.is_empty() { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let (k, v) = unsafe { self.next_back_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n+        }\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n-        let handle = ptr::read(&self.back);\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                self.back = ptr::read(&kv).left_edge();\n-                // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                // so we have to do this last.\n-                let (k, v) = kv.into_kv_mut();\n-                return (k, v); // coerce k from `&mut K` to `&K`\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    self.back = last_leaf_edge(ptr::read(&kv).left_edge().descend());\n-                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                    // so we have to do this last.\n-                    let (k, v) = kv.into_kv_mut();\n-                    return (k, v); // coerce k from `&mut K` to `&K`\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        self.back.next_back_unchecked()\n     }\n }\n \n@@ -1987,32 +1830,6 @@ where\n     }\n }\n \n-fn first_leaf_edge<BorrowType, K, V>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n-    loop {\n-        match node.force() {\n-            Leaf(leaf) => return leaf.first_edge(),\n-            Internal(internal) => {\n-                node = internal.first_edge().descend();\n-            }\n-        }\n-    }\n-}\n-\n-fn last_leaf_edge<BorrowType, K, V>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n-    loop {\n-        match node.force() {\n-            Leaf(leaf) => return leaf.last_edge(),\n-            Internal(internal) => {\n-                node = internal.last_edge().descend();\n-            }\n-        }\n-    }\n-}\n-\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -2116,17 +1933,6 @@ where\n     }\n }\n \n-#[inline(always)]\n-unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n-    val.unwrap_or_else(|| {\n-        if cfg!(debug_assertions) {\n-            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n-        } else {\n-            intrinsics::unreachable();\n-        }\n-    })\n-}\n-\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2153,8 +1959,8 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n-                front: first_leaf_edge(self.root.as_ref()),\n-                back: last_leaf_edge(self.root.as_ref()),\n+                front: self.root.as_ref().first_leaf_edge(),\n+                back: self.root.as_ref().last_leaf_edge(),\n             },\n             length: self.length,\n         }\n@@ -2187,8 +1993,8 @@ impl<K, V> BTreeMap<K, V> {\n         let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n             range: RangeMut {\n-                front: first_leaf_edge(root1),\n-                back: last_leaf_edge(root2),\n+                front: root1.first_leaf_edge(),\n+                back: root2.last_leaf_edge(),\n                 _marker: PhantomData,\n             },\n             length: self.length,\n@@ -2691,7 +2497,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = first_leaf_edge(internal.right_edge().descend()).right_kv().ok();\n+                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();"}, {"sha": "fb5825ee21a9e4459551e269026ae2208a59168c", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "patch": "@@ -1,4 +1,5 @@\n pub mod map;\n+mod navigate;\n mod node;\n mod search;\n pub mod set;\n@@ -11,3 +12,14 @@ trait Recover<Q: ?Sized> {\n     fn take(&mut self, key: &Q) -> Option<Self::Key>;\n     fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n }\n+\n+#[inline(always)]\n+pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n+    val.unwrap_or_else(|| {\n+        if cfg!(debug_assertions) {\n+            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n+        } else {\n+            core::intrinsics::unreachable();\n+        }\n+    })\n+}"}, {"sha": "653218972314f374e0cc87bc3d513b74eacbcfc4", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "patch": "@@ -0,0 +1,244 @@\n+use core::ptr;\n+\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::unwrap_unchecked;\n+\n+macro_rules! def_next {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into an immutable tree, returns a handle to the next\n+        /// leaf edge and references to the key and value between these edges.\n+        /// Unsafe because the caller must ensure that the given leaf edge has a successor.\n+        unsafe fn $name <'a, K: 'a, V: 'a>(\n+            leaf_edge: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>, &'a K, &'a V) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let (k, v) = leaf_kv.into_kv();\n+                    let next_leaf_edge = leaf_kv.$next_edge();\n+                    return (next_leaf_edge, k, v);\n+                }\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    unwrap_unchecked(next_level)\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let (k, v) = internal_kv.into_kv();\n+                        let next_internal_edge = internal_kv.$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, k, v);\n+                    }\n+                    Err(last_edge) => {\n+                        let next_level = last_edge.into_node().ascend().ok();\n+                        unwrap_unchecked(next_level)\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! def_next_mut {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into a mutable tree, returns handles to the next\n+        /// leaf edge and to the KV between these edges.\n+        /// Unsafe for two reasons:\n+        /// - the caller must ensure that the given leaf edge has a successor;\n+        /// - both returned handles represent mutable references into the same tree\n+        ///   that can easily invalidate each other, even on immutable use.\n+        unsafe fn $name <'a, K: 'a, V: 'a>(\n+            leaf_edge: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+              Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let next_leaf_edge = ptr::read(&leaf_kv).$next_edge();\n+                    return (next_leaf_edge, leaf_kv.forget_node_type());\n+                }\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    unwrap_unchecked(next_level)\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let next_internal_edge = ptr::read(&internal_kv).$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, internal_kv.forget_node_type());\n+                    }\n+                    Err(last_edge) => {\n+                        let next_level = last_edge.into_node().ascend().ok();\n+                        unwrap_unchecked(next_level)\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! def_next_dealloc {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into an owned tree, returns a handle to the next\n+        /// leaf edge and the key and value between these edges, while deallocating\n+        /// any node left behind.\n+        /// Unsafe for two reasons:\n+        /// - the caller must ensure that the given leaf edge has a successor;\n+        /// - the node pointed at by the given handle, and its ancestors, may be deallocated,\n+        ///   while the reference to those nodes in the surviving ancestors is left dangling;\n+        ///   thus using the returned handle is dangerous.\n+        unsafe fn $name <K, V>(\n+            leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let k = ptr::read(leaf_kv.reborrow().into_kv().0);\n+                    let v = ptr::read(leaf_kv.reborrow().into_kv().1);\n+                    let next_leaf_edge = leaf_kv.$next_edge();\n+                    return (next_leaf_edge, k, v);\n+                }\n+                Err(last_edge) => {\n+                    unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let k = ptr::read(internal_kv.reborrow().into_kv().0);\n+                        let v = ptr::read(internal_kv.reborrow().into_kv().1);\n+                        let next_internal_edge = internal_kv.$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, k, v);\n+                    }\n+                    Err(last_edge) => {\n+                        unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+def_next! {unsafe fn next_unchecked: right_kv right_edge first_leaf_edge}\n+def_next! {unsafe fn next_back_unchecked: left_kv left_edge last_leaf_edge}\n+def_next_mut! {unsafe fn next_unchecked_mut: right_kv right_edge first_leaf_edge}\n+def_next_mut! {unsafe fn next_back_unchecked_mut: left_kv left_edge last_leaf_edge}\n+def_next_dealloc! {unsafe fn next_unchecked_deallocating: right_kv right_edge first_leaf_edge}\n+def_next_dealloc! {unsafe fn next_back_unchecked_deallocating: left_kv left_edge last_leaf_edge}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let (next_edge, k, v) = next_unchecked(*self);\n+        *self = next_edge;\n+        (k, v)\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let (next_edge, k, v) = next_back_unchecked(*self);\n+        *self = next_edge;\n+        (k, v)\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe for two reasons:\n+    /// - The caller must ensure that the leaf edge is not the last one in the tree.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        let (next_edge, kv) = next_unchecked_mut(ptr::read(self));\n+        *self = next_edge;\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf and returns references to the\n+    /// key and value in between.\n+    /// Unsafe for two reasons:\n+    /// - The caller must ensure that the leaf edge is not the first one in the tree.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        let (next_edge, kv) = next_back_unchecked_mut(ptr::read(self));\n+        *self = next_edge;\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n+    }\n+}\n+\n+impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n+    /// in between, while deallocating any node left behind.\n+    /// Unsafe for three reasons:\n+    /// - The caller must ensure that the leaf edge is not the last one in the tree\n+    ///   and is not a handle previously resulting from counterpart `next_back_unchecked`.\n+    /// - If the leaf edge is the last edge of a node, that node and possibly ancestors\n+    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n+    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n+    ///   It is, however, safe to call this method again on the updated handle.\n+    ///   if the two preconditions above hold.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n+        let (next_edge, k, v) = next_unchecked_deallocating(ptr::read(self));\n+        *self = next_edge;\n+        (k, v)\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf edge and returns the key\n+    /// and value in between, while deallocating any node left behind.\n+    /// Unsafe for three reasons:\n+    /// - The caller must ensure that the leaf edge is not the first one in the tree\n+    ///   and is not a handle previously resulting from counterpart `next_unchecked`.\n+    /// - If the lead edge is the first edge of a node, that node and possibly ancestors\n+    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n+    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n+    ///   It is, however, safe to call this method again on the updated handle.\n+    ///   if the two preconditions above hold.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n+        let (next_edge, k, v) = next_back_unchecked_deallocating(ptr::read(self));\n+        *self = next_edge;\n+        (k, v)\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Returns the leftmost leaf edge in or underneath a node - in other words, the edge\n+    /// you need first when navigating forward (or last when navigating backward).\n+    #[inline]\n+    pub fn first_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        let mut node = self;\n+        loop {\n+            match node.force() {\n+                Leaf(leaf) => return leaf.first_edge(),\n+                Internal(internal) => node = internal.first_edge().descend(),\n+            }\n+        }\n+    }\n+\n+    /// Returns the rightmost leaf edge in or underneath a node - in other words, the edge\n+    /// you need last when navigating forward (or first when navigating backward).\n+    #[inline]\n+    pub fn last_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        let mut node = self;\n+        loop {\n+            match node.force() {\n+                Leaf(leaf) => return leaf.last_edge(),\n+                Internal(internal) => node = internal.last_edge().descend(),\n+            }\n+        }\n+    }\n+}"}, {"sha": "e4123c9a20b196f83f030c0fd981423a7c6894de", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "patch": "@@ -1418,6 +1418,22 @@ unsafe fn move_edges<K, V>(\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n \n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n impl<BorrowType, K, V, HandleType>\n     Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType>\n {"}]}