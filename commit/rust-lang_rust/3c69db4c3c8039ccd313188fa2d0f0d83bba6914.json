{"sha": "3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNjlkYjRjM2M4MDM5Y2NkMzEzMTg4ZmEyZDBmMGQ4M2JiYTY5MTQ=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-06-11T23:21:46Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-06-12T18:07:16Z"}, "message": "Cleanup: rename middle::ty::sty and its variants.\n\nUse camel-case naming, and use names which actually make sense in modern Rust.", "tree": {"sha": "ff2c5c96ed81f5a94187601a8426c0f5a496dcde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff2c5c96ed81f5a94187601a8426c0f5a496dcde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "html_url": "https://github.com/rust-lang/rust/commit/3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0da58cc361577d63afdcb84945a9f011970301e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da58cc361577d63afdcb84945a9f011970301e3", "html_url": "https://github.com/rust-lang/rust/commit/0da58cc361577d63afdcb84945a9f011970301e3"}], "stats": {"total": 2723, "additions": 1385, "deletions": 1338}, "files": [{"sha": "5a79ef203b4b39162e63d05b7d2bd5f9ea68464e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -719,7 +719,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n         let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n-            ty::ty_bare_fn(_, ref f) =>\n+            ty::TyBareFn(_, ref f) =>\n                 (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n             _ => { // Nullary or struct enum variant.\n                 let mut arg_names = Vec::new();"}, {"sha": "ad650fcfb11442a1299b29fea4766529fde75ce0", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -28,7 +28,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::parse::token;\n \n-// Compact string representation for Ty values. API ty_str &\n+// Compact string representation for Ty values. API TyStr &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n "}, {"sha": "8f78e97c4bb40f7b62bd25629b4b673d97b3cca3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -41,7 +41,7 @@ pub struct ctxt<'a, 'tcx: 'a> {\n     pub abbrevs: &'a abbrev_map<'tcx>\n }\n \n-// Compact string representation for Ty values. API ty_str & parse_from_str.\n+// Compact string representation for Ty values. API TyStr & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n pub struct ty_abbrev {\n@@ -60,9 +60,9 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     let pos = w.mark_stable_position();\n \n     match t.sty {\n-        ty::ty_bool => mywrite!(w, \"b\"),\n-        ty::ty_char => mywrite!(w, \"c\"),\n-        ty::ty_int(t) => {\n+        ty::TyBool => mywrite!(w, \"b\"),\n+        ty::TyChar => mywrite!(w, \"c\"),\n+        ty::TyInt(t) => {\n             match t {\n                 ast::TyIs => mywrite!(w, \"is\"),\n                 ast::TyI8 => mywrite!(w, \"MB\"),\n@@ -71,7 +71,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n                 ast::TyI64 => mywrite!(w, \"MD\")\n             }\n         }\n-        ty::ty_uint(t) => {\n+        ty::TyUint(t) => {\n             match t {\n                 ast::TyUs => mywrite!(w, \"us\"),\n                 ast::TyU8 => mywrite!(w, \"Mb\"),\n@@ -80,37 +80,37 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n                 ast::TyU64 => mywrite!(w, \"Md\")\n             }\n         }\n-        ty::ty_float(t) => {\n+        ty::TyFloat(t) => {\n             match t {\n                 ast::TyF32 => mywrite!(w, \"Mf\"),\n                 ast::TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n-        ty::ty_enum(def, substs) => {\n+        ty::TyEnum(def, substs) => {\n             mywrite!(w, \"t[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_trait(box ty::TyTrait { ref principal,\n+        ty::TyTrait(box ty::TraitTy { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n             enc_trait_ref(w, cx, principal.0);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_tup(ref ts) => {\n+        ty::TyTuple(ref ts) => {\n             mywrite!(w, \"T[\");\n             for t in ts { enc_ty(w, cx, *t); }\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n-        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n-        ty::ty_rptr(r, mt) => {\n+        ty::TyBox(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n+        ty::TyRawPtr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n+        ty::TyRef(r, mt) => {\n             mywrite!(w, \"&\");\n             enc_region(w, cx, *r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_vec(t, sz) => {\n+        ty::TyArray(t, sz) => {\n             mywrite!(w, \"V\");\n             enc_ty(w, cx, t);\n             mywrite!(w, \"/\");\n@@ -119,40 +119,40 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n                 None => mywrite!(w, \"|\"),\n             }\n         }\n-        ty::ty_str => {\n+        ty::TyStr => {\n             mywrite!(w, \"v\");\n         }\n-        ty::ty_bare_fn(Some(def_id), f) => {\n+        ty::TyBareFn(Some(def_id), f) => {\n             mywrite!(w, \"F\");\n             mywrite!(w, \"{}|\", (cx.ds)(def_id));\n             enc_bare_fn_ty(w, cx, f);\n         }\n-        ty::ty_bare_fn(None, f) => {\n+        ty::TyBareFn(None, f) => {\n             mywrite!(w, \"G\");\n             enc_bare_fn_ty(w, cx, f);\n         }\n-        ty::ty_infer(_) => {\n+        ty::TyInfer(_) => {\n             cx.diag.handler().bug(\"cannot encode inference variable types\");\n         }\n-        ty::ty_param(ParamTy {space, idx, name}) => {\n+        ty::TyParam(ParamTy {space, idx, name}) => {\n             mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), token::get_name(name))\n         }\n-        ty::ty_struct(def, substs) => {\n+        ty::TyStruct(def, substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_closure(def, substs) => {\n+        ty::TyClosure(def, substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_projection(ref data) => {\n+        ty::TyProjection(ref data) => {\n             mywrite!(w, \"P[\");\n             enc_trait_ref(w, cx, data.trait_ref);\n             mywrite!(w, \"{}]\", token::get_name(data.item_name));\n         }\n-        ty::ty_err => {\n+        ty::TyError => {\n             mywrite!(w, \"e\");\n         }\n     }"}, {"sha": "34088d5f13ee705c0e02dc94db9772f89b4dc15b", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -61,16 +61,16 @@ impl<'tcx> CastTy<'tcx> {\n     pub fn from_ty(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n                    -> Option<CastTy<'tcx>> {\n         match t.sty {\n-            ty::ty_bool => Some(CastTy::Int(IntTy::Bool)),\n-            ty::ty_char => Some(CastTy::Int(IntTy::Char)),\n-            ty::ty_int(_) => Some(CastTy::Int(IntTy::I)),\n-            ty::ty_uint(u) => Some(CastTy::Int(IntTy::U(u))),\n-            ty::ty_float(_) => Some(CastTy::Float),\n-            ty::ty_enum(..) if ty::type_is_c_like_enum(\n+            ty::TyBool => Some(CastTy::Int(IntTy::Bool)),\n+            ty::TyChar => Some(CastTy::Int(IntTy::Char)),\n+            ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n+            ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n+            ty::TyFloat(_) => Some(CastTy::Float),\n+            ty::TyEnum(..) if ty::type_is_c_like_enum(\n                 tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n-            ty::ty_ptr(ref mt) => Some(CastTy::Ptr(mt)),\n-            ty::ty_rptr(_, ref mt) => Some(CastTy::RPtr(mt)),\n-            ty::ty_bare_fn(..) => Some(CastTy::FnPtr),\n+            ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n+            ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n+            ty::TyBareFn(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }\n     }"}, {"sha": "2d27e9d2ed62c1fa7794e1d658c8d668f4a70ac1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.visit_expr(&**element);\n                 // The count is checked elsewhere (typeck).\n                 let count = match node_ty.sty {\n-                    ty::ty_vec(_, Some(n)) => n,\n+                    ty::TyArray(_, Some(n)) => n,\n                     _ => unreachable!()\n                 };\n                 // [element; 0] is always zero-sized.\n@@ -454,7 +454,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 visit::walk_expr(self, ex);\n                 let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n                 match node_ty.sty {\n-                    ty::ty_uint(_) | ty::ty_int(_) if div_or_rem => {\n+                    ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n                         if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n                             match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n                                 Ok(_) => {}\n@@ -529,8 +529,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n-        ty::ty_struct(did, _) |\n-        ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n+        ty::TyStruct(did, _) |\n+        ty::TyEnum(did, _) if ty::has_dtor(v.tcx, did) => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n@@ -562,7 +562,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         }\n         ast::ExprUnary(op, ref inner) => {\n             match ty::node_id_to_type(v.tcx, inner.id).sty {\n-                ty::ty_ptr(_) => {\n+                ty::TyRawPtr(_) => {\n                     assert!(op == ast::UnDeref);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n@@ -576,7 +576,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         }\n         ast::ExprBinary(op, ref lhs, _) => {\n             match ty::node_id_to_type(v.tcx, lhs.id).sty {\n-                ty::ty_ptr(_) => {\n+                ty::TyRawPtr(_) => {\n                     assert!(op.node == ast::BiEq || op.node == ast::BiNe ||\n                             op.node == ast::BiLe || op.node == ast::BiLt ||\n                             op.node == ast::BiGe || op.node == ast::BiGt);\n@@ -612,7 +612,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStruct(_)) => {\n-                    if let ty::ty_bare_fn(..) = node_ty.sty {\n+                    if let ty::TyBareFn(..) = node_ty.sty {\n                         // Count the function pointer.\n                         v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n@@ -854,7 +854,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                         // Mutable slices are the only `&mut` allowed in globals,\n                         // but only in `static mut`, nowhere else.\n                         match cmt.ty.sty {\n-                            ty::ty_vec(_, _) => break,\n+                            ty::TyArray(_, _) => break,\n                             _ => {}\n                         }\n                     }"}, {"sha": "f3ba9148ba61cf68db83d61076d40491872981fc", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -234,7 +234,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = ty::pat_ty(cx.tcx, p);\n-                if let ty::ty_enum(def_id, _) = pat_ty.sty {\n+                if let ty::TyEnum(def_id, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n                         if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n@@ -506,9 +506,9 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n-        ty::ty_tup(_) => ast::PatTup(pats.collect()),\n+        ty::TyTuple(_) => ast::PatTup(pats.collect()),\n \n-        ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n+        ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n                 &Variant(vid) =>\n                     (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n@@ -535,23 +535,23 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             }\n         }\n \n-        ty::ty_rptr(_, ty::mt { ty, mutbl }) => {\n+        ty::TyRef(_, ty::mt { ty, mutbl }) => {\n             match ty.sty {\n-               ty::ty_vec(_, Some(n)) => match ctor {\n+               ty::TyArray(_, Some(n)) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n                         ast::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::ty_vec(_, None) => match ctor {\n+                ty::TyArray(_, None) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n                         ast::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::ty_str => ast::PatWild(ast::PatWildSingle),\n+                ty::TyStr => ast::PatWild(ast::PatWildSingle),\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n@@ -560,7 +560,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             }\n         }\n \n-        ty::ty_vec(_, Some(len)) => {\n+        ty::TyArray(_, Some(len)) => {\n             assert_eq!(pats_len, len);\n             ast::PatVec(pats.collect(), None, vec![])\n         }\n@@ -597,16 +597,16 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: usize) -> Vec<Constructor> {\n     match left_ty.sty {\n-        ty::ty_bool =>\n+        ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n-        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n-            ty::ty_vec(_, None) =>\n+        ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n+            ty::TyArray(_, None) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n             _ => vec!(Single)\n         },\n \n-        ty::ty_enum(eid, _) =>\n+        ty::TyEnum(eid, _) =>\n             ty::enum_variants(cx.tcx, eid)\n                 .iter()\n                 .map(|va| Variant(va.id))\n@@ -779,7 +779,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n         ast::PatVec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n-                ty::ty_vec(_, Some(_)) => vec!(Single),\n+                ty::TyArray(_, Some(_)) => vec!(Single),\n                 _                      => if slice.is_some() {\n                     range_inclusive(before.len() + after.len(), max_slice_length)\n                         .map(|length| Slice(length))\n@@ -804,25 +804,25 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     match ty.sty {\n-        ty::ty_tup(ref fs) => fs.len(),\n-        ty::ty_uniq(_) => 1,\n-        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n-            ty::ty_vec(_, None) => match *ctor {\n+        ty::TyTuple(ref fs) => fs.len(),\n+        ty::TyBox(_) => 1,\n+        ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n+            ty::TyArray(_, None) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0,\n                 _ => unreachable!()\n             },\n-            ty::ty_str => 0,\n+            ty::TyStr => 0,\n             _ => 1\n         },\n-        ty::ty_enum(eid, _) => {\n+        ty::TyEnum(eid, _) => {\n             match *ctor {\n                 Variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n-        ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-        ty::ty_vec(_, Some(n)) => n,\n+        ty::TyStruct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n+        ty::TyArray(_, Some(n)) => n,\n         _ => 0\n     }\n }"}, {"sha": "f64765f909028051214d15e1406f3c5cf514a789", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -732,11 +732,11 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n     // bindings so that isize/usize is mapped to a type with an\n     // inherently known bitwidth.\n     let expr_int_type = ety.and_then(|ty| {\n-        if let ty::ty_int(t) = ty.sty {\n+        if let ty::TyInt(t) = ty.sty {\n             Some(IntTy::from(tcx, t)) } else { None }\n     });\n     let expr_uint_type = ety.and_then(|ty| {\n-        if let ty::ty_uint(t) = ty.sty {\n+        if let ty::TyUint(t) = ty.sty {\n             Some(UintTy::from(tcx, t)) } else { None }\n     });\n \n@@ -1093,33 +1093,33 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult\n \n     // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n     match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::ty_int(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, const_int, i64),\n-        (&ty::ty_int(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, const_int, i64),\n-        (&ty::ty_int(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n+        (&ty::TyInt(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, const_int, i64),\n+        (&ty::TyInt(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, const_int, i64),\n+        (&ty::TyInt(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n \n-        (&ty::ty_uint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, const_uint, u64),\n-        (&ty::ty_uint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, const_uint, u64),\n-        (&ty::ty_uint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n+        (&ty::TyUint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, const_uint, u64),\n+        (&ty::TyUint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, const_uint, u64),\n+        (&ty::TyUint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n \n         _ => {}\n     }\n \n     match ty.sty {\n-        ty::ty_int(ast::TyIs) => unreachable!(),\n-        ty::ty_uint(ast::TyUs) => unreachable!(),\n+        ty::TyInt(ast::TyIs) => unreachable!(),\n+        ty::TyUint(ast::TyUs) => unreachable!(),\n \n-        ty::ty_int(ast::TyI8) => convert_val!(i8, const_int, i64),\n-        ty::ty_int(ast::TyI16) => convert_val!(i16, const_int, i64),\n-        ty::ty_int(ast::TyI32) => convert_val!(i32, const_int, i64),\n-        ty::ty_int(ast::TyI64) => convert_val!(i64, const_int, i64),\n+        ty::TyInt(ast::TyI8) => convert_val!(i8, const_int, i64),\n+        ty::TyInt(ast::TyI16) => convert_val!(i16, const_int, i64),\n+        ty::TyInt(ast::TyI32) => convert_val!(i32, const_int, i64),\n+        ty::TyInt(ast::TyI64) => convert_val!(i64, const_int, i64),\n \n-        ty::ty_uint(ast::TyU8) => convert_val!(u8, const_uint, u64),\n-        ty::ty_uint(ast::TyU16) => convert_val!(u16, const_uint, u64),\n-        ty::ty_uint(ast::TyU32) => convert_val!(u32, const_uint, u64),\n-        ty::ty_uint(ast::TyU64) => convert_val!(u64, const_uint, u64),\n+        ty::TyUint(ast::TyU8) => convert_val!(u8, const_uint, u64),\n+        ty::TyUint(ast::TyU16) => convert_val!(u16, const_uint, u64),\n+        ty::TyUint(ast::TyU32) => convert_val!(u32, const_uint, u64),\n+        ty::TyUint(ast::TyU64) => convert_val!(u64, const_uint, u64),\n \n-        ty::ty_float(ast::TyF32) => convert_val!(f32, const_float, f64),\n-        ty::ty_float(ast::TyF64) => convert_val!(f64, const_float, f64),\n+        ty::TyFloat(ast::TyF32) => convert_val!(f32, const_float, f64),\n+        ty::TyFloat(ast::TyF64) => convert_val!(f64, const_float, f64),\n         _ => Err(ErrKind::CannotCast),\n     }\n }\n@@ -1135,7 +1135,7 @@ fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> const_val {\n         ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => const_int(n as i64),\n         ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n             match ty_hint.map(|ty| &ty.sty) {\n-                Some(&ty::ty_uint(_)) => const_uint(n),\n+                Some(&ty::TyUint(_)) => const_uint(n),\n                 _ => const_int(n as i64)\n             }\n         }"}, {"sha": "5068836b557739b2456461e695832f38d99ac365", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n         match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n-            ty::ty_struct(id, _) => {\n+            ty::TyStruct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields.iter()\n                     .find(|field| field.name == name).unwrap().id;\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n         match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n-            ty::ty_struct(id, _) => {\n+            ty::TyStruct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields[idx].id;\n                 self.live_symbols.insert(field_id.node);"}, {"sha": "d23c8a4bc1e0d43bba465eb4932a03c5faf92a7a", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -31,7 +31,7 @@ enum UnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::ty_bare_fn(_, ref f) => f.unsafety == ast::Unsafety::Unsafe,\n+        ty::TyBareFn(_, ref f) => f.unsafety == ast::Unsafety::Unsafe,\n         _ => false,\n     }\n }\n@@ -69,11 +69,11 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_string(self.tcx, base_type));\n         match base_type.sty {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => if ty::ty_str == ty.sty {\n+            ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => if ty::TyStr == ty.sty {\n                 span_err!(self.tcx.sess, e.span, E0134,\n                           \"modification of string types is not allowed\");\n             },\n-            ty::ty_str => {\n+            ty::TyStr => {\n                 span_err!(self.tcx.sess, e.span, E0135,\n                           \"modification of string types is not allowed\");\n             }\n@@ -161,7 +161,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n-                if let ty::ty_ptr(_) = base_type.sty {\n+                if let ty::TyRawPtr(_) = base_type.sty {\n                     self.require_unsafe(expr.span, \"dereference of raw pointer\")\n                 }\n             }"}, {"sha": "3c9a4def5c856ae9fcb6d4861c1796fe262e1d91", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -622,10 +622,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n         match callee_ty.sty {\n-            ty::ty_bare_fn(..) => {\n+            ty::TyBareFn(..) => {\n                 self.consume_expr(callee);\n             }\n-            ty::ty_err => { }\n+            ty::TyError => { }\n             _ => {\n                 let overloaded_call_type =\n                     match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n@@ -740,7 +740,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // Select just those fields of the `with`\n         // expression that will actually be used\n         let with_fields = match with_cmt.ty.sty {\n-            ty::ty_struct(did, substs) => {\n+            ty::TyStruct(did, substs) => {\n                 ty::struct_fields(self.tcx(), did, substs)\n             }\n             _ => {\n@@ -826,7 +826,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     let self_ty = ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap();\n \n                     let (m, r) = match self_ty.sty {\n-                        ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                        ty::TyRef(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 &format!(\"bad overloaded deref type {}\",\n                                     method_ty.repr(self.tcx())))"}, {"sha": "ee792989ccf1be477297e10320a57da04ee36828", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -48,51 +48,51 @@ pub fn simplify_type(tcx: &ty::ctxt,\n                      -> Option<SimplifiedType>\n {\n     match ty.sty {\n-        ty::ty_bool => Some(BoolSimplifiedType),\n-        ty::ty_char => Some(CharSimplifiedType),\n-        ty::ty_int(int_type) => Some(IntSimplifiedType(int_type)),\n-        ty::ty_uint(uint_type) => Some(UintSimplifiedType(uint_type)),\n-        ty::ty_float(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::ty_enum(def_id, _) => Some(EnumSimplifiedType(def_id)),\n-        ty::ty_str => Some(StrSimplifiedType),\n-        ty::ty_vec(..) => Some(VecSimplifiedType),\n-        ty::ty_ptr(_) => Some(PtrSimplifiedType),\n-        ty::ty_trait(ref trait_info) => {\n+        ty::TyBool => Some(BoolSimplifiedType),\n+        ty::TyChar => Some(CharSimplifiedType),\n+        ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n+        ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n+        ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n+        ty::TyEnum(def_id, _) => Some(EnumSimplifiedType(def_id)),\n+        ty::TyStr => Some(StrSimplifiedType),\n+        ty::TyArray(..) => Some(VecSimplifiedType),\n+        ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n+        ty::TyTrait(ref trait_info) => {\n             Some(TraitSimplifiedType(trait_info.principal_def_id()))\n         }\n-        ty::ty_struct(def_id, _) => {\n+        ty::TyStruct(def_id, _) => {\n             Some(StructSimplifiedType(def_id))\n         }\n-        ty::ty_rptr(_, mt) => {\n+        ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n             // view of possibly unifying\n             simplify_type(tcx, mt.ty, can_simplify_params)\n         }\n-        ty::ty_uniq(_) => {\n+        ty::TyBox(_) => {\n             // treat like we would treat `Box`\n             let def_id = tcx.lang_items.owned_box().unwrap();\n             Some(StructSimplifiedType(def_id))\n         }\n-        ty::ty_closure(def_id, _) => {\n+        ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n-        ty::ty_tup(ref tys) => {\n+        ty::TyTuple(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::ty_bare_fn(_, ref f) => {\n+        ty::TyBareFn(_, ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n-        ty::ty_projection(_) => {\n+        ty::TyProjection(_) => {\n             None\n         }\n-        ty::ty_param(_) => {\n+        ty::TyParam(_) => {\n             if can_simplify_params {\n                 Some(ParameterSimplifiedType)\n             } else {\n                 None\n             }\n         }\n-        ty::ty_infer(_) | ty::ty_err => None,\n+        ty::TyInfer(_) | ty::TyError => None,\n     }\n }"}, {"sha": "367d5efb54b3f4e8f8ae9b218df4391c58901b9e", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -88,61 +88,61 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::ty_bool |\n-            ty::ty_char |\n-            ty::ty_int(..) |\n-            ty::ty_uint(..) |\n-            ty::ty_float(..) |\n-            ty::ty_bare_fn(..) |\n-            ty::ty_err |\n-            ty::ty_str => {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(..) |\n+            ty::TyUint(..) |\n+            ty::TyFloat(..) |\n+            ty::TyBareFn(..) |\n+            ty::TyError |\n+            ty::TyStr => {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::ty_closure(def_id, substs) => {\n+            ty::TyClosure(def_id, substs) => {\n                 let &(r_a, opt_ty) = self.stack.last().unwrap();\n                 self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));\n             }\n \n-            ty::ty_trait(ref t) => {\n+            ty::TyTrait(ref t) => {\n                 let required_region_bounds =\n                     object_region_bounds(self.tcx(), &t.principal, t.bounds.builtin_bounds);\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n-            ty::ty_enum(def_id, substs) |\n-            ty::ty_struct(def_id, substs) => {\n+            ty::TyEnum(def_id, substs) |\n+            ty::TyStruct(def_id, substs) => {\n                 let item_scheme = ty::lookup_item_type(self.tcx(), def_id);\n                 self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n-            ty::ty_vec(t, _) |\n-            ty::ty_ptr(ty::mt { ty: t, .. }) |\n-            ty::ty_uniq(t) => {\n+            ty::TyArray(t, _) |\n+            ty::TyRawPtr(ty::mt { ty: t, .. }) |\n+            ty::TyBox(t) => {\n                 self.accumulate_from_ty(t)\n             }\n \n-            ty::ty_rptr(r_b, mt) => {\n+            ty::TyRef(r_b, mt) => {\n                 self.accumulate_from_rptr(ty, *r_b, mt.ty);\n             }\n \n-            ty::ty_param(p) => {\n+            ty::TyParam(p) => {\n                 self.push_param_constraint_from_top(p);\n             }\n \n-            ty::ty_projection(ref data) => {\n+            ty::TyProjection(ref data) => {\n                 // `<T as TraitRef<..>>::Name`\n \n                 self.push_projection_constraint_from_top(data);\n             }\n \n-            ty::ty_tup(ref tuptys) => {\n+            ty::TyTuple(ref tuptys) => {\n                 for &tupty in tuptys {\n                     self.accumulate_from_ty(tupty);\n                 }\n             }\n \n-            ty::ty_infer(_) => {\n+            ty::TyInfer(_) => {\n                 // This should not happen, BUT:\n                 //\n                 //   Currently we uncover region relationships on"}, {"sha": "1ab01453c0f1a68f6b12d2a359c5aa81d9a44d2a", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -81,17 +81,17 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, BiTo, b_id);\n                 Ok(a)\n             }\n \n-            (&ty::ty_infer(TyVar(a_id)), _) => {\n+            (&ty::TyInfer(TyVar(a_id)), _) => {\n                 try!(self.fields.instantiate(b, BiTo, a_id));\n                 Ok(a)\n             }\n \n-            (_, &ty::ty_infer(TyVar(b_id))) => {\n+            (_, &ty::TyInfer(TyVar(b_id))) => {\n                 try!(self.fields.instantiate(a, BiTo, b_id));\n                 Ok(a)\n             }"}, {"sha": "864e9ed0b978f2b6f40874005f126af735210595", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -70,44 +70,44 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n \n     match (&a.sty, &b.sty) {\n         // Relate integral variables to other types\n-        (&ty::ty_infer(ty::IntVar(a_id)), &ty::ty_infer(ty::IntVar(b_id))) => {\n+        (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n             try!(infcx.int_unification_table\n                       .borrow_mut()\n                       .unify_var_var(a_id, b_id)\n                       .map_err(|e| int_unification_error(a_is_expected, e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_int(v)) => {\n+        (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n             unify_integral_variable(infcx, a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_int(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+        (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n             unify_integral_variable(infcx, !a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_uint(v)) => {\n+        (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n             unify_integral_variable(infcx, a_is_expected, v_id, UintType(v))\n         }\n-        (&ty::ty_uint(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+        (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n             unify_integral_variable(infcx, !a_is_expected, v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n-        (&ty::ty_infer(ty::FloatVar(a_id)), &ty::ty_infer(ty::FloatVar(b_id))) => {\n+        (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n             try!(infcx.float_unification_table\n                       .borrow_mut()\n                       .unify_var_var(a_id, b_id)\n                       .map_err(|e| float_unification_error(relation.a_is_expected(), e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(ty::FloatVar(v_id)), &ty::ty_float(v)) => {\n+        (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n             unify_float_variable(infcx, a_is_expected, v_id, v)\n         }\n-        (&ty::ty_float(v), &ty::ty_infer(ty::FloatVar(v_id))) => {\n+        (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n             unify_float_variable(infcx, !a_is_expected, v_id, v)\n         }\n \n         // All other cases of inference are errors\n-        (&ty::ty_infer(_), _) |\n-        (_, &ty::ty_infer(_)) => {\n+        (&ty::TyInfer(_), _) |\n+        (_, &ty::TyInfer(_)) => {\n             Err(ty::terr_sorts(ty_relate::expected_found(relation, &a, &b)))\n         }\n \n@@ -262,7 +262,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n \n     /// Attempts to generalize `ty` for the type variable `for_vid`.  This checks for cycle -- that\n     /// is, whether the type `ty` references `for_vid`. If `make_region_vars` is true, it will also\n-    /// replace all regions with fresh variables. Returns `ty_err` in the case of a cycle, `Ok`\n+    /// replace all regions with fresh variables. Returns `TyError` in the case of a cycle, `Ok`\n     /// otherwise.\n     fn generalize(&self,\n                   ty: Ty<'tcx>,\n@@ -308,7 +308,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         // (In particular, you could have something like `$0 = Box<$1>`\n         //  where `$1` has already been instantiated with `Box<$0>`)\n         match t.sty {\n-            ty::ty_infer(ty::TyVar(vid)) => {\n+            ty::TyInfer(ty::TyVar(vid)) => {\n                 if vid == self.for_vid {\n                     self.cycle_detected = true;\n                     self.tcx().types.err"}, {"sha": "da0bca890422329ef76004ec331f4447b3c10498", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -53,17 +53,17 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n                 Ok(a)\n             }\n \n-            (&ty::ty_infer(TyVar(a_id)), _) => {\n+            (&ty::TyInfer(TyVar(a_id)), _) => {\n                 try!(self.fields.instantiate(b, EqTo, a_id));\n                 Ok(a)\n             }\n \n-            (_, &ty::ty_infer(TyVar(b_id))) => {\n+            (_, &ty::TyInfer(TyVar(b_id))) => {\n                 try!(self.fields.instantiate(a, EqTo, b_id));\n                 Ok(a)\n             }"}, {"sha": "6eb4fcce8873a676f5e8092446bf242447c95367", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -111,14 +111,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         match t.sty {\n-            ty::ty_infer(ty::TyVar(v)) => {\n+            ty::TyInfer(ty::TyVar(v)) => {\n                 self.freshen(\n                     self.infcx.type_variables.borrow().probe(v),\n                     ty::TyVar(v),\n                     ty::FreshTy)\n             }\n \n-            ty::ty_infer(ty::IntVar(v)) => {\n+            ty::TyInfer(ty::IntVar(v)) => {\n                 self.freshen(\n                     self.infcx.int_unification_table.borrow_mut()\n                                                     .probe(v)\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     ty::FreshIntTy)\n             }\n \n-            ty::ty_infer(ty::FloatVar(v)) => {\n+            ty::TyInfer(ty::FloatVar(v)) => {\n                 self.freshen(\n                     self.infcx.float_unification_table.borrow_mut()\n                                                       .probe(v)\n@@ -136,9 +136,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     ty::FreshFloatTy)\n             }\n \n-            ty::ty_infer(ty::FreshTy(c)) |\n-            ty::ty_infer(ty::FreshIntTy(c)) |\n-            ty::ty_infer(ty::FreshFloatTy(c)) => {\n+            ty::TyInfer(ty::FreshTy(c)) |\n+            ty::TyInfer(ty::FreshIntTy(c)) |\n+            ty::TyInfer(ty::FreshFloatTy(c)) => {\n                 if c >= self.freshen_count {\n                     tcx.sess.bug(\n                         &format!(\"Encountered a freshend type with id {} \\\n@@ -149,25 +149,25 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 t\n             }\n \n-            ty::ty_bool |\n-            ty::ty_char |\n-            ty::ty_int(..) |\n-            ty::ty_uint(..) |\n-            ty::ty_float(..) |\n-            ty::ty_enum(..) |\n-            ty::ty_uniq(..) |\n-            ty::ty_str |\n-            ty::ty_err |\n-            ty::ty_vec(..) |\n-            ty::ty_ptr(..) |\n-            ty::ty_rptr(..) |\n-            ty::ty_bare_fn(..) |\n-            ty::ty_trait(..) |\n-            ty::ty_struct(..) |\n-            ty::ty_closure(..) |\n-            ty::ty_tup(..) |\n-            ty::ty_projection(..) |\n-            ty::ty_param(..) => {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(..) |\n+            ty::TyUint(..) |\n+            ty::TyFloat(..) |\n+            ty::TyEnum(..) |\n+            ty::TyBox(..) |\n+            ty::TyStr |\n+            ty::TyError |\n+            ty::TyArray(..) |\n+            ty::TyRawPtr(..) |\n+            ty::TyRef(..) |\n+            ty::TyBareFn(..) |\n+            ty::TyTrait(..) |\n+            ty::TyStruct(..) |\n+            ty::TyClosure(..) |\n+            ty::TyTuple(..) |\n+            ty::TyProjection(..) |\n+            ty::TyParam(..) => {\n                 ty_fold::super_fold_ty(self, t)\n             }\n         }"}, {"sha": "d634b8231ebb32a177e2d2450a595dc46af15e84", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -64,15 +64,15 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n     let a = infcx.type_variables.borrow().replace_if_possible(a);\n     let b = infcx.type_variables.borrow().replace_if_possible(b);\n     match (&a.sty, &b.sty) {\n-        (&ty::ty_infer(TyVar(..)), &ty::ty_infer(TyVar(..)))\n+        (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n             let v = infcx.next_diverging_ty_var();\n             try!(this.relate_bound(v, a, b));\n             Ok(v)\n         }\n \n-        (&ty::ty_infer(TyVar(..)), _) |\n-        (_, &ty::ty_infer(TyVar(..))) => {\n+        (&ty::TyInfer(TyVar(..)), _) |\n+        (_, &ty::TyInfer(TyVar(..))) => {\n             let v = infcx.next_ty_var();\n             try!(this.relate_bound(v, a, b));\n             Ok(v)"}, {"sha": "c0e3a5e89610e3f38f3d39d811a76e9324bb8856", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -440,7 +440,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty.sty {\n-            ty::ty_infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false\n         }\n     }\n@@ -452,14 +452,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty) -> UnconstrainedNumeric {\n         use middle::ty::UnconstrainedNumeric::{Neither, UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n-            ty::ty_infer(ty::IntVar(vid)) => {\n+            ty::TyInfer(ty::IntVar(vid)) => {\n                 if self.int_unification_table.borrow_mut().has_value(vid) {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             },\n-            ty::ty_infer(ty::FloatVar(vid)) => {\n+            ty::TyInfer(ty::FloatVar(vid)) => {\n                 if self.float_unification_table.borrow_mut().has_value(vid) {\n                     Neither\n                 } else {\n@@ -878,7 +878,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n-            ty::ty_infer(ty::TyVar(v)) => {\n+            ty::TyInfer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n@@ -894,15 +894,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .unwrap_or(typ)\n             }\n \n-            ty::ty_infer(ty::IntVar(v)) => {\n+            ty::TyInfer(ty::IntVar(v)) => {\n                 self.int_unification_table\n                     .borrow_mut()\n                     .probe(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n-            ty::ty_infer(ty::FloatVar(v)) => {\n+            ty::TyInfer(ty::FloatVar(v)) => {\n                 self.float_unification_table\n                     .borrow_mut()\n                     .probe(v)\n@@ -945,13 +945,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is ty_err (the special\n+    // An invariant is that anytime the expected or actual type is TyError (the special\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n     // The following four methods -- type_error_message_str, type_error_message_str_with_expected,\n     // type_error_message, and report_mismatched_types -- implement this logic.\n-    // They check if either the actual or expected type is ty_err, and don't print the error\n+    // They check if either the actual or expected type is TyError, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n-        // Don't report an error if actual type is ty_err.\n+        // Don't report an error if actual type is TyError.\n         if ty::type_is_error(actual_ty) {\n             return;\n         }"}, {"sha": "62e56d2e2d7d362fba17aa91e1242386a35b8762", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -81,19 +81,19 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {\n-                ty::ty_infer(ty::TyVar(vid)) => {\n+                ty::TyInfer(ty::TyVar(vid)) => {\n                     self.err = Some(unresolved_ty(vid));\n                     self.tcx().types.err\n                 }\n-                ty::ty_infer(ty::IntVar(vid)) => {\n+                ty::TyInfer(ty::IntVar(vid)) => {\n                     self.err = Some(unresolved_int_ty(vid));\n                     self.tcx().types.err\n                 }\n-                ty::ty_infer(ty::FloatVar(vid)) => {\n+                ty::TyInfer(ty::FloatVar(vid)) => {\n                     self.err = Some(unresolved_float_ty(vid));\n                     self.tcx().types.err\n                 }\n-                ty::ty_infer(_) => {\n+                ty::TyInfer(_) => {\n                     self.infcx.tcx.sess.bug(\n                         &format!(\"Unexpected type in full type resolver: {}\",\n                                 t.repr(self.infcx.tcx)));"}, {"sha": "9d6854eba4369d8254a5e29b4975616ec61bf5e6", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -57,24 +57,24 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n                 infcx.type_variables\n                     .borrow_mut()\n                     .relate_vars(a_id, SubtypeOf, b_id);\n                 Ok(a)\n             }\n-            (&ty::ty_infer(TyVar(a_id)), _) => {\n+            (&ty::TyInfer(TyVar(a_id)), _) => {\n                 try!(self.fields\n                          .switch_expected()\n                          .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n-            (_, &ty::ty_infer(TyVar(b_id))) => {\n+            (_, &ty::TyInfer(TyVar(b_id))) => {\n                 try!(self.fields.instantiate(a, SubtypeOf, b_id));\n                 Ok(a)\n             }\n \n-            (&ty::ty_err, _) | (_, &ty::ty_err) => {\n+            (&ty::TyError, _) | (_, &ty::TyError) => {\n                 Ok(self.tcx().types.err)\n             }\n "}, {"sha": "6f1de3ee63597cf24f94a0b08951f5d13ae08062", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     pub fn replace_if_possible(&self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::ty_infer(ty::TyVar(v)) => {\n+            ty::TyInfer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n                     None => t,\n                     Some(u) => u"}, {"sha": "f76cfebf7b997319427f9a1c622f2cab1572c675", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -12,7 +12,7 @@ use ast_map::NodeForeignItem;\n use metadata::csearch;\n use middle::def::DefFn;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n-use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n+use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n use middle::ty::{self, Ty};\n use util::ppaux::Repr;\n \n@@ -54,7 +54,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n-            ty::ty_bare_fn(_, ref bfty) => bfty.abi == RustIntrinsic,\n+            ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n         if def_id.krate == ast::LOCAL_CRATE {\n@@ -256,7 +256,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n                     let typ = ty::node_id_to_type(self.tcx, expr.id);\n                     match typ.sty {\n-                        ty_bare_fn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        TyBareFn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n                                 let from = bare_fn_ty.sig.0.inputs[0];\n                                 self.check_transmute(expr.span, from, to, expr.id);"}, {"sha": "9bcc251725c002cc58476ae2b2e661c3b17cd4e0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -1498,7 +1498,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_closure(closure_def_id, substs) =>\n+            ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),"}, {"sha": "d099b71c3f2aebda0a4f8815c39946c5cfdc17fa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -212,25 +212,25 @@ type DerefKindContext = Option<InteriorOffsetKind>;\n // pointer adjustment).\n fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n     match t.sty {\n-        ty::ty_uniq(_) => {\n+        ty::TyBox(_) => {\n             Ok(deref_ptr(Unique))\n         }\n \n-        ty::ty_rptr(r, mt) => {\n+        ty::TyRef(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n             Ok(deref_ptr(BorrowedPtr(kind, *r)))\n         }\n \n-        ty::ty_ptr(ref mt) => {\n+        ty::TyRawPtr(ref mt) => {\n             Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n         }\n \n-        ty::ty_enum(..) |\n-        ty::ty_struct(..) => { // newtype\n+        ty::TyEnum(..) |\n+        ty::TyStruct(..) => { // newtype\n             Ok(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::ty_vec(_, _) | ty::ty_str => {\n+        ty::TyArray(_, _) | ty::TyStr => {\n             // no deref of indexed content without supplying InteriorOffsetKind\n             if let Some(context) = context {\n                 Ok(deref_interior(InteriorElement(context, element_kind(t))))\n@@ -523,7 +523,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // The index method always returns an `&T`, so\n                     // dereference it to find the result type.\n                     let elem_ty = match ret_ty.sty {\n-                        ty::ty_rptr(_, mt) => mt.ty,\n+                        ty::TyRef(_, mt) => mt.ty,\n                         _ => {\n                             debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n                                    ret_ty.repr(self.tcx()));\n@@ -621,7 +621,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           def::DefUpvar(var_id, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n-                  ty::ty_closure(closure_id, _) => {\n+                  ty::TyClosure(closure_id, _) => {\n                       match self.typer.closure_kind(closure_id) {\n                           Some(kind) => {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n@@ -791,7 +791,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // that the above is actually immutable and\n         // has a ref type.  However, nothing should\n         // actually look at the type, so we can get\n-        // away with stuffing a `ty_err` in there\n+        // away with stuffing a `TyError` in there\n         // instead of bothering to construct a proper\n         // one.\n         let cmt_result = cmt_ {\n@@ -843,7 +843,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n         let qualif = match expr_ty.sty {\n-            ty::ty_vec(_, Some(0)) => qualif,\n+            ty::TyArray(_, Some(0)) => qualif,\n             _ => check_const::ConstQualif::NOT_CONST\n         };\n \n@@ -1129,8 +1129,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           slice_ty: Ty)\n                           -> (ast::Mutability, ty::Region) {\n             match slice_ty.sty {\n-                ty::ty_rptr(r, ref mt) => match mt.ty.sty {\n-                    ty::ty_vec(_, None) => (mt.mutbl, *r),\n+                ty::TyRef(r, ref mt) => match mt.ty.sty {\n+                    ty::TyArray(_, None) => (mt.mutbl, *r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n \n@@ -1667,12 +1667,12 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n \n fn element_kind(t: Ty) -> ElementKind {\n     match t.sty {\n-        ty::ty_rptr(_, ty::mt{ty, ..}) |\n-        ty::ty_uniq(ty) => match ty.sty {\n-            ty::ty_vec(_, None) => VecElement,\n+        ty::TyRef(_, ty::mt{ty, ..}) |\n+        ty::TyBox(ty) => match ty.sty {\n+            ty::TyArray(_, None) => VecElement,\n             _ => OtherElement\n         },\n-        ty::ty_vec(..) => VecElement,\n+        ty::TyArray(..) => VecElement,\n         _ => OtherElement\n     }\n }"}, {"sha": "861fa97d50bf2002946280d9a00d00ff58cc1328", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -387,7 +387,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match ty::expr_ty_adjusted(tcx, base_e).sty {\n-                ty::ty_struct(did, _) => {\n+                ty::TyStruct(did, _) => {\n                     ty::lookup_struct_fields(tcx, did)\n                         .iter()\n                         .find(|f| f.name == field.node.name)\n@@ -404,7 +404,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match ty::expr_ty_adjusted(tcx, base_e).sty {\n-                ty::ty_struct(did, _) => {\n+                ty::TyStruct(did, _) => {\n                     ty::lookup_struct_fields(tcx, did)\n                         .get(field.node)\n                         .unwrap_or_else(|| {\n@@ -413,7 +413,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                         })\n                         .id\n                 }\n-                ty::ty_tup(..) => return,\n+                ty::TyTuple(..) => return,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: unnamed field access on \\\n                                         something other than a tuple or struct\")\n@@ -422,7 +422,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprStruct(_, ref expr_fields, _) => {\n             let type_ = ty::expr_ty(tcx, e);\n             match type_.sty {\n-                ty::ty_struct(did, _) => {\n+                ty::TyStruct(did, _) => {\n                     let struct_fields = ty::lookup_struct_fields(tcx, did);\n                     // check the stability of each field that appears\n                     // in the construction expression.\n@@ -445,7 +445,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                 // we don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n                 // a bug to have construct one.\n-                ty::ty_enum(..) => return,\n+                ty::TyEnum(..) => return,\n                 _ => {\n                     tcx.sess.span_bug(e.span,\n                                       &format!(\"stability::check_expr: struct construction \\\n@@ -478,7 +478,7 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     if is_internal(tcx, pat.span) { return; }\n \n     let did = match ty::pat_ty_opt(tcx, pat) {\n-        Some(&ty::TyS { sty: ty::ty_struct(did, _), .. }) => did,\n+        Some(&ty::TyS { sty: ty::TyStruct(did, _), .. }) => did,\n         Some(_) | None => return,\n     };\n     let struct_fields = ty::lookup_struct_fields(tcx, did);"}, {"sha": "75af3366397ddc10f1b8bd1814b9256e23b84847", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         self.ty_stack_depth += 1;\n \n         let t1 = match t.sty {\n-            ty::ty_param(p) => {\n+            ty::TyParam(p) => {\n                 self.ty_for_param(p, t)\n             }\n             _ => {"}, {"sha": "ae2454013e8fbf78522a7f210d71cd94b373a0b6", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -265,7 +265,7 @@ fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // FIXME(#20590) straighten story about projection types\n-        ty::ty_projection(..) | ty::ty_param(..) => true,\n+        ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n@@ -279,11 +279,11 @@ fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, infer_is_local: InferIs\n fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n {\n     match ty.sty {\n-        ty::ty_uniq(..) | ty::ty_rptr(..) =>\n+        ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::ty_enum(def_id, _) | ty::ty_struct(def_id, _) =>\n+        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) =>\n             ty::has_attr(tcx, def_id, \"fundamental\"),\n-        ty::ty_trait(ref data) =>\n+        ty::TyTrait(ref data) =>\n             ty::has_attr(tcx, data.principal_def_id(), \"fundamental\"),\n         _ =>\n             false\n@@ -298,42 +298,42 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n \n     match ty.sty {\n-        ty::ty_bool |\n-        ty::ty_char |\n-        ty::ty_int(..) |\n-        ty::ty_uint(..) |\n-        ty::ty_float(..) |\n-        ty::ty_str(..) |\n-        ty::ty_bare_fn(..) |\n-        ty::ty_vec(..) |\n-        ty::ty_ptr(..) |\n-        ty::ty_rptr(..) |\n-        ty::ty_tup(..) |\n-        ty::ty_param(..) |\n-        ty::ty_projection(..) => {\n+        ty::TyBool |\n+        ty::TyChar |\n+        ty::TyInt(..) |\n+        ty::TyUint(..) |\n+        ty::TyFloat(..) |\n+        ty::TyStr(..) |\n+        ty::TyBareFn(..) |\n+        ty::TyArray(..) |\n+        ty::TyRawPtr(..) |\n+        ty::TyRef(..) |\n+        ty::TyTuple(..) |\n+        ty::TyParam(..) |\n+        ty::TyProjection(..) => {\n             false\n         }\n \n-        ty::ty_infer(..) => {\n+        ty::TyInfer(..) => {\n             infer_is_local.0\n         }\n \n-        ty::ty_enum(def_id, _) |\n-        ty::ty_struct(def_id, _) => {\n+        ty::TyEnum(def_id, _) |\n+        ty::TyStruct(def_id, _) => {\n             def_id.krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_uniq(_) => { // Box<T>\n+        ty::TyBox(_) => { // Box<T>\n             let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n             krate == Some(ast::LOCAL_CRATE)\n         }\n \n-        ty::ty_trait(ref tt) => {\n+        ty::TyTrait(ref tt) => {\n             tt.principal_def_id().krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_closure(..) |\n-        ty::ty_err => {\n+        ty::TyClosure(..) |\n+        ty::TyError => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n                         ty.repr(tcx)))"}, {"sha": "2d65c5dd626c9dfcfef98dab49d06f9757064b05", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -60,10 +60,10 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-    // The ty_err created by normalize_to_error can end up being unified\n+    // The TyError created by normalize_to_error can end up being unified\n     // into all obligations: for example, if our obligation is something\n     // like `$X = <() as Foo<$X>>::Out` and () does not implement Foo<_>,\n-    // then $X will be unified with ty_err, but the error still needs to be\n+    // then $X will be unified with TyError, but the error still needs to be\n     // reported.\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n         span_err!(infcx.tcx.sess, obligation.cause.span, E0271,"}, {"sha": "cf8e391bf54566771180ee9bdf2c3d10a844f64b", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -308,15 +308,15 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let mut error = false;\n     ty::maybe_walk_ty(ty, |ty| {\n         match ty.sty {\n-            ty::ty_param(ref param_ty) => {\n+            ty::TyParam(ref param_ty) => {\n                 if param_ty.space == SelfSpace {\n                     error = true;\n                 }\n \n                 false // no contained types to walk\n             }\n \n-            ty::ty_projection(ref data) => {\n+            ty::TyProjection(ref data) => {\n                 // This is a projected type `<Foo as SomeTrait>::X`.\n \n                 // Compute supertraits of current trait lazily.\n@@ -367,7 +367,7 @@ impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n \n fn is_self<'tcx>(ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::ty_param(ref data) => data.space == subst::SelfSpace,\n+        ty::TyParam(ref data) => data.space == subst::SelfSpace,\n         _ => false,\n     }\n }"}, {"sha": "1631a33588ce2020455a389c78b193bb0a71c84b", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -153,7 +153,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::ty_closure(closure_def_id, substs) => {\n+        ty::TyClosure(closure_def_id, substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) =\n@@ -261,7 +261,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n \n         let ty = ty_fold::super_fold_ty(self, ty);\n         match ty.sty {\n-            ty::ty_projection(ref data) if !data.has_escaping_regions() => { // (*)\n+            ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because\n@@ -408,11 +408,11 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     }\n }\n \n-/// in various error cases, we just set ty_err and return an obligation\n+/// in various error cases, we just set TyError and return an obligation\n /// that, when fulfilled, will lead to an error.\n ///\n-/// FIXME: the ty_err created here can enter the obligation we create,\n-/// leading to error messages involving ty_err.\n+/// FIXME: the TyError created here can enter the obligation we create,\n+/// leading to error messages involving TyError.\n fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,\n@@ -554,8 +554,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n {\n     // Check whether the self-type is itself a projection.\n     let trait_ref = match obligation_trait_ref.self_ty().sty {\n-        ty::ty_projection(ref data) => data.trait_ref.clone(),\n-        ty::ty_infer(ty::TyVar(_)) => {\n+        ty::TyProjection(ref data) => data.trait_ref.clone(),\n+        ty::TyInfer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n             candidate_set.ambiguous = true;\n@@ -625,7 +625,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n            object_ty.repr(infcx.tcx));\n     let data = match object_ty.sty {\n-        ty::ty_trait(ref data) => data,\n+        ty::TyTrait(ref data) => data,\n         _ => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n@@ -883,7 +883,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n                     // definition for the associated type. This error\n                     // ought to be reported by the type checker method\n                     // `check_impl_items_against_trait`, so here we\n-                    // just return ty_err.\n+                    // just return TyError.\n                     return (selcx.tcx().types.err, vec!());\n                 }\n             }"}, {"sha": "ba5f0686f4822d2136be20a8e0af75d0180c9c32", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -350,7 +350,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // lifetimes can appear inside the self-type.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_closure(id, ref substs) => (id, substs.clone()),\n+            ty::TyClosure(id, ref substs) => (id, substs.clone()),\n             _ => { return; }\n         };\n         assert!(!substs.has_escaping_regions());\n@@ -950,8 +950,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n         let trait_def_id = match poly_trait_predicate.0.trait_ref.self_ty().sty {\n-            ty::ty_projection(ref data) => data.trait_ref.def_id,\n-            ty::ty_infer(ty::TyVar(_)) => {\n+            ty::TyProjection(ref data) => data.trait_ref.def_id,\n+            ty::TyInfer(ty::TyVar(_)) => {\n                 // If the self-type is an inference variable, then it MAY wind up\n                 // being a projected type, so induce an ambiguity.\n                 //\n@@ -994,7 +994,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_map.repr(self.tcx()));\n \n         let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n-            ty::ty_projection(ref data) => &data.trait_ref,\n+            ty::TyProjection(ref data) => &data.trait_ref,\n             _ => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n@@ -1134,8 +1134,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_closure(id, substs) => (id, substs),\n-            ty::ty_infer(ty::TyVar(_)) => {\n+            ty::TyClosure(id, substs) => (id, substs),\n+            ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -1179,13 +1179,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // ok to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         match self_ty.sty {\n-            ty::ty_infer(ty::TyVar(_)) => {\n+            ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::ty_bare_fn(_, &ty::BareFnTy {\n+            ty::TyBareFn(_, &ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -1241,7 +1241,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         if ty::trait_has_default_impl(self.tcx(), def_id) {\n             match self_ty.sty {\n-                ty::ty_trait(..) => {\n+                ty::TyTrait(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. For most traits, this means we\n                     // conservatively say nothing; a candidate may be\n@@ -1255,8 +1255,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         candidates.vec.push(DefaultImplObjectCandidate(def_id));\n                     }\n                 }\n-                ty::ty_param(..) |\n-                ty::ty_projection(..) => {\n+                ty::TyParam(..) |\n+                ty::TyProjection(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1271,7 +1271,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // for an example of a test case that exercises\n                     // this path.\n                 }\n-                ty::ty_infer(ty::TyVar(_)) => {\n+                ty::TyInfer(ty::TyVar(_)) => {\n                     // the defaulted impl might apply, we don't know\n                     candidates.ambiguous = true;\n                 }\n@@ -1325,7 +1325,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let (self_ty, _) =\n                 self.infcx().skolemize_late_bound_regions(&bound_self_ty, snapshot);\n             let poly_trait_ref = match self_ty.sty {\n-                ty::ty_trait(ref data) => {\n+                ty::TyTrait(ref data) => {\n                     match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n                         Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n                             if data.bounds.builtin_bounds.contains(&bound) {\n@@ -1340,7 +1340,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n                 }\n-                ty::ty_infer(ty::TyVar(_)) => {\n+                ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n                     candidates.ambiguous = true; // could wind up being an object type\n                     return Ok(());\n@@ -1399,7 +1399,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n                 // Upcasts permit two things:\n                 //\n                 // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n@@ -1416,23 +1416,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::ty_trait(_)) => true,\n+            (_, &ty::TyTrait(_)) => true,\n \n             // Ambiguous handling is below T -> Trait, because inference\n             // variables can still implement Unsize<Trait> and nested\n             // obligations will have the final say (likely deferred).\n-            (&ty::ty_infer(ty::TyVar(_)), _) |\n-            (_, &ty::ty_infer(ty::TyVar(_))) => {\n+            (&ty::TyInfer(ty::TyVar(_)), _) |\n+            (_, &ty::TyInfer(ty::TyVar(_))) => {\n                 debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n                 candidates.ambiguous = true;\n                 false\n             }\n \n             // [T; n] -> [T].\n-            (&ty::ty_vec(_, Some(_)), &ty::ty_vec(_, None)) => true,\n+            (&ty::TyArray(_, Some(_)), &ty::TyArray(_, None)) => true,\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::ty_struct(def_id_a, _), &ty::ty_struct(def_id_b, _)) => {\n+            (&ty::TyStruct(def_id_a, _), &ty::TyStruct(def_id_b, _)) => {\n                 def_id_a == def_id_b\n             }\n \n@@ -1579,19 +1579,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n-            ty::ty_infer(ty::IntVar(_)) |\n-            ty::ty_infer(ty::FloatVar(_)) |\n-            ty::ty_uint(_) |\n-            ty::ty_int(_) |\n-            ty::ty_bool |\n-            ty::ty_float(_) |\n-            ty::ty_bare_fn(..) |\n-            ty::ty_char => {\n+            ty::TyInfer(ty::IntVar(_)) |\n+            ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyUint(_) |\n+            ty::TyInt(_) |\n+            ty::TyBool |\n+            ty::TyFloat(_) |\n+            ty::TyBareFn(..) |\n+            ty::TyChar => {\n                 // safe for everything\n                 ok_if(Vec::new())\n             }\n \n-            ty::ty_uniq(_) => {  // Box<T>\n+            ty::TyBox(_) => {  // Box<T>\n                 match bound {\n                     ty::BoundCopy => Err(Unimplemented),\n \n@@ -1603,7 +1603,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_ptr(..) => {     // *const T, *mut T\n+            ty::TyRawPtr(..) => {     // *const T, *mut T\n                 match bound {\n                     ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n \n@@ -1613,7 +1613,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_trait(ref data) => {\n+            ty::TyTrait(ref data) => {\n                 match bound {\n                     ty::BoundSized => Err(Unimplemented),\n                     ty::BoundCopy => {\n@@ -1641,7 +1641,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_rptr(_, ty::mt { ty: _, mutbl }) => {\n+            ty::TyRef(_, ty::mt { ty: _, mutbl }) => {\n                 // &mut T or &T\n                 match bound {\n                     ty::BoundCopy => {\n@@ -1662,7 +1662,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_vec(element_ty, ref len) => {\n+            ty::TyArray(element_ty, ref len) => {\n                 // [T; n] and [T]\n                 match bound {\n                     ty::BoundCopy => {\n@@ -1689,7 +1689,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_str => {\n+            ty::TyStr => {\n                 // Equivalent to [u8]\n                 match bound {\n                     ty::BoundSync | ty::BoundSend => {\n@@ -1701,9 +1701,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            ty::ty_tup(ref tys) => ok_if(tys.clone()),\n+            ty::TyTuple(ref tys) => ok_if(tys.clone()),\n \n-            ty::ty_closure(def_id, substs) => {\n+            ty::TyClosure(def_id, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1738,15 +1738,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_struct(def_id, substs) => {\n+            ty::TyStruct(def_id, substs) => {\n                 let types: Vec<Ty> =\n                     ty::struct_fields(self.tcx(), def_id, substs).iter()\n                                                                  .map(|f| f.mt.ty)\n                                                                  .collect();\n                 nominal(bound, types)\n             }\n \n-            ty::ty_enum(def_id, substs) => {\n+            ty::TyEnum(def_id, substs) => {\n                 let types: Vec<Ty> =\n                     ty::substd_enum_variants(self.tcx(), def_id, substs)\n                     .iter()\n@@ -1756,27 +1756,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nominal(bound, types)\n             }\n \n-            ty::ty_projection(_) | ty::ty_param(_) => {\n+            ty::TyProjection(_) | ty::TyParam(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n                 // us that it does, and that case is handled by\n                 // `assemble_candidates_from_caller_bounds()`.\n                 Ok(ParameterBuiltin)\n             }\n \n-            ty::ty_infer(ty::TyVar(_)) => {\n+            ty::TyInfer(ty::TyVar(_)) => {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_err => ok_if(Vec::new()),\n+            ty::TyError => ok_if(Vec::new()),\n \n-            ty::ty_infer(ty::FreshTy(_))\n-            | ty::ty_infer(ty::FreshIntTy(_))\n-            | ty::ty_infer(ty::FreshFloatTy(_)) => {\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n@@ -1820,51 +1820,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// ```\n     fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Option<Vec<Ty<'tcx>>> {\n         match t.sty {\n-            ty::ty_uint(_) |\n-            ty::ty_int(_) |\n-            ty::ty_bool |\n-            ty::ty_float(_) |\n-            ty::ty_bare_fn(..) |\n-            ty::ty_str |\n-            ty::ty_err |\n-            ty::ty_infer(ty::IntVar(_)) |\n-            ty::ty_infer(ty::FloatVar(_)) |\n-            ty::ty_char => {\n+            ty::TyUint(_) |\n+            ty::TyInt(_) |\n+            ty::TyBool |\n+            ty::TyFloat(_) |\n+            ty::TyBareFn(..) |\n+            ty::TyStr |\n+            ty::TyError |\n+            ty::TyInfer(ty::IntVar(_)) |\n+            ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyChar => {\n                 Some(Vec::new())\n             }\n \n-            ty::ty_trait(..) |\n-            ty::ty_param(..) |\n-            ty::ty_projection(..) |\n-            ty::ty_infer(ty::TyVar(_)) |\n-            ty::ty_infer(ty::FreshTy(_)) |\n-            ty::ty_infer(ty::FreshIntTy(_)) |\n-            ty::ty_infer(ty::FreshFloatTy(_)) => {\n+            ty::TyTrait(..) |\n+            ty::TyParam(..) |\n+            ty::TyProjection(..) |\n+            ty::TyInfer(ty::TyVar(_)) |\n+            ty::TyInfer(ty::FreshTy(_)) |\n+            ty::TyInfer(ty::FreshIntTy(_)) |\n+            ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble constituent types of unexpected type: {}\",\n                         t.repr(self.tcx())));\n             }\n \n-            ty::ty_uniq(referent_ty) => {  // Box<T>\n+            ty::TyBox(referent_ty) => {  // Box<T>\n                 Some(vec![referent_ty])\n             }\n \n-            ty::ty_ptr(ty::mt { ty: element_ty, ..}) |\n-            ty::ty_rptr(_, ty::mt { ty: element_ty, ..}) => {\n+            ty::TyRawPtr(ty::mt { ty: element_ty, ..}) |\n+            ty::TyRef(_, ty::mt { ty: element_ty, ..}) => {\n                 Some(vec![element_ty])\n             },\n \n-            ty::ty_vec(element_ty, _) => {\n+            ty::TyArray(element_ty, _) => {\n                 Some(vec![element_ty])\n             }\n \n-            ty::ty_tup(ref tys) => {\n+            ty::TyTuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n                 Some(tys.clone())\n             }\n \n-            ty::ty_closure(def_id, substs) => {\n+            ty::TyClosure(def_id, substs) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {\n@@ -1878,19 +1878,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::ty_struct(def_id, substs)\n+            ty::TyStruct(def_id, substs)\n                 if Some(def_id) == self.tcx().lang_items.phantom_data() =>\n             {\n                 Some(substs.types.get_slice(TypeSpace).to_vec())\n             }\n \n-            ty::ty_struct(def_id, substs) => {\n+            ty::TyStruct(def_id, substs) => {\n                 Some(ty::struct_fields(self.tcx(), def_id, substs).iter()\n                      .map(|f| f.mt.ty)\n                      .collect())\n             }\n \n-            ty::ty_enum(def_id, substs) => {\n+            ty::TyEnum(def_id, substs) => {\n                 Some(ty::substd_enum_variants(self.tcx(), def_id, substs)\n                      .iter()\n                      .flat_map(|variant| &variant.args)\n@@ -2169,7 +2169,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // OK to skip binder, it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self_ty.sty {\n-            ty::ty_trait(ref data) => {\n+            ty::TyTrait(ref data) => {\n                 // OK to skip the binder, it is reintroduced below\n                 let input_types = data.principal.skip_binder().substs.types.get_slice(TypeSpace);\n                 let assoc_types = data.bounds.projection_bounds\n@@ -2299,7 +2299,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // case that results. -nmatsakis\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::ty_trait(ref data) => {\n+            ty::TyTrait(ref data) => {\n                 data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n@@ -2437,7 +2437,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n                 let bounds = ty::ExistentialBounds {\n                     region_bound: data_b.bounds.region_bound,\n@@ -2463,7 +2463,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::ty_trait(ref data)) => {\n+            (_, &ty::TyTrait(ref data)) => {\n                 let object_did = data.principal_def_id();\n                 if !object_safety::is_object_safe(tcx, object_did) {\n                     return Err(TraitNotObjectSafe(object_did));\n@@ -2510,15 +2510,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // [T; n] -> [T].\n-            (&ty::ty_vec(a, Some(_)), &ty::ty_vec(b, None)) => {\n+            (&ty::TyArray(a, Some(_)), &ty::TyArray(b, None)) => {\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, a, b).is_err() {\n                     return Err(Unimplemented);\n                 }\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::ty_struct(def_id, substs_a), &ty::ty_struct(_, substs_b)) => {\n+            (&ty::TyStruct(def_id, substs_a), &ty::TyStruct(_, substs_b)) => {\n                 let fields = ty::lookup_struct_fields(tcx, def_id).iter().map(|f| {\n                     ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n                 }).collect::<Vec<_>>();\n@@ -2531,7 +2531,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 };\n                 let mut ty_params = vec![];\n                 ty::walk_ty(field, |ty| {\n-                    if let ty::ty_param(p) = ty.sty {\n+                    if let ty::TyParam(p) = ty.sty {\n                         assert!(p.space == TypeSpace);\n                         let idx = p.idx as usize;\n                         if !ty_params.contains(&idx) {\n@@ -2544,7 +2544,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 // Replace type parameters used in unsizing with\n-                // ty_err and ensure they do not affect any other fields.\n+                // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n                 let mut new_substs = substs_a.clone();"}, {"sha": "42bc399e822b943281ba9a96eff8a0f8584f4dfe", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 357, "deletions": 308, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -30,7 +30,7 @@ pub use self::ImplOrTraitItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::ImplOrTraitItem::*;\n pub use self::BoundRegion::*;\n-pub use self::sty::*;\n+pub use self::TypeVariants::*;\n pub use self::IntVarValue::*;\n pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n@@ -844,6 +844,7 @@ macro_rules! sty_debug_print {\n     ($ctxt: expr, $($variant: ident),*) => {{\n         // curious inner module to allow variant names to be used as\n         // variable names.\n+        #[allow(non_snake_case)]\n         mod inner {\n             use middle::ty;\n             #[derive(Copy, Clone)]\n@@ -864,9 +865,9 @@ macro_rules! sty_debug_print {\n \n                 for (_, t) in tcx.interner.borrow().iter() {\n                     let variant = match t.sty {\n-                        ty::ty_bool | ty::ty_char | ty::ty_int(..) | ty::ty_uint(..) |\n-                            ty::ty_float(..) | ty::ty_str => continue,\n-                        ty::ty_err => /* unimportant */ continue,\n+                        ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n+                            ty::TyFloat(..) | ty::TyStr => continue,\n+                        ty::TyError => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n                     let region = t.flags.get().intersects(ty::TypeFlags::HAS_RE_INFER);\n@@ -905,8 +906,8 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn print_debug_stats(&self) {\n         sty_debug_print!(\n             self,\n-            ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_trait,\n-            ty_struct, ty_closure, ty_tup, ty_param, ty_infer, ty_projection);\n+            TyEnum, TyBox, TyArray, TyRawPtr, TyRef, TyBareFn, TyTrait,\n+            TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -917,7 +918,7 @@ impl<'tcx> ctxt<'tcx> {\n \n #[derive(Debug)]\n pub struct TyS<'tcx> {\n-    pub sty: sty<'tcx>,\n+    pub sty: TypeVariants<'tcx>,\n     pub flags: Cell<TypeFlags>,\n \n     // the maximal depth of any bound regions appearing in this type.\n@@ -967,8 +968,8 @@ impl<'tcx> Hash for InternedTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n-    fn borrow<'a>(&'a self) -> &'a sty<'tcx> {\n+impl<'tcx> Borrow<TypeVariants<'tcx>> for InternedTy<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a TypeVariants<'tcx> {\n         &self.ty.sty\n     }\n }\n@@ -1335,53 +1336,101 @@ pub enum BoundRegion {\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum sty<'tcx> {\n-    ty_bool,\n-    ty_char,\n-    ty_int(ast::IntTy),\n-    ty_uint(ast::UintTy),\n-    ty_float(ast::FloatTy),\n-    /// Substs here, possibly against intuition, *may* contain `ty_param`s.\n+pub enum TypeVariants<'tcx> {\n+    /// The primitive boolean type. Written as `bool`.\n+    TyBool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point).  Written as `char`.\n+    TyChar,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    TyInt(ast::IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    TyUint(ast::UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    TyFloat(ast::FloatTy),\n+\n+    /// An enumerated type, defined with `enum`.\n+    ///\n+    /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n-    /// variables. This happens when the `ty_enum` corresponds to an enum\n-    /// definition and not a concrete use of it. To get the correct `ty_enum`\n+    /// variables. This happens when the `TyEnum` corresponds to an enum\n+    /// definition and not a concrete use of it. To get the correct `TyEnum`\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n-    /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n+    /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n     /// well.\n-    ty_enum(DefId, &'tcx Substs<'tcx>),\n-    ty_uniq(Ty<'tcx>),\n-    ty_str,\n-    ty_vec(Ty<'tcx>, Option<usize>), // Second field is length.\n-    ty_ptr(mt<'tcx>),\n-    ty_rptr(&'tcx Region, mt<'tcx>),\n+    TyEnum(DefId, &'tcx Substs<'tcx>),\n+\n+    /// A structure type, defined with `struct`.\n+    ///\n+    /// See warning about substitutions for enumerated types.\n+    TyStruct(DefId, &'tcx Substs<'tcx>),\n+\n+    /// `Box<T>`; this is nominally a struct in the documentation, but is\n+    /// special-cased internally. For example, it is possible to implicitly\n+    /// move the contents of a box out of that box, and methods of any type\n+    /// can have type `Box<Self>`.\n+    TyBox(Ty<'tcx>),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    TyStr,\n+\n+    /// An array with the given length, or the pointee\n+    /// of an array slice.  Written as `[T; n]`, or `[T]`.\n+    /// FIXME: It probably makes sense to separate these.\n+    TyArray(Ty<'tcx>, Option<usize>),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    TyRawPtr(mt<'tcx>),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&a mut T` or `&'a T`.\n+    TyRef(&'tcx Region, mt<'tcx>),\n+\n+    /// If the def-id is Some(_), then this is the type of a specific\n+    /// fn item. Otherwise, if None(_), it a fn pointer type.\n+    ///\n+    /// FIXME: Conflating function pointers and the type of a\n+    /// function is probably a terrible idea; a function pointer is a\n+    /// value with a specific type, but a function can be polymorphic\n+    /// or dynamically dispatched.\n+    TyBareFn(Option<DefId>, &'tcx BareFnTy<'tcx>),\n+\n+    /// A trait, defined with `trait`.\n+    TyTrait(Box<TraitTy<'tcx>>),\n \n-    // If the def-id is Some(_), then this is the type of a specific\n-    // fn item. Otherwise, if None(_), it a fn pointer type.\n-    ty_bare_fn(Option<DefId>, &'tcx BareFnTy<'tcx>),\n+    /// The anonymous type of a closure. Used to represent the type of\n+    /// `|a| a`.\n+    TyClosure(DefId, &'tcx Substs<'tcx>),\n \n-    ty_trait(Box<TyTrait<'tcx>>),\n-    ty_struct(DefId, &'tcx Substs<'tcx>),\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    TyTuple(Vec<Ty<'tcx>>),\n \n-    ty_closure(DefId, &'tcx Substs<'tcx>),\n+    /// The projection of an associated type.  For example,\n+    /// `<T as Trait<..>>::N`.\n+    TyProjection(ProjectionTy<'tcx>),\n \n-    ty_tup(Vec<Ty<'tcx>>),\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    TyParam(ParamTy),\n \n-    ty_projection(ProjectionTy<'tcx>),\n-    ty_param(ParamTy), // type parameter\n+    /// A type variable used during type-checking.\n+    TyInfer(InferTy),\n \n-    ty_infer(InferTy), // something used only during inference/typeck\n-    ty_err, // Also only used during inference/typeck, to represent\n-            // the type of an erroneous expression (helps cut down\n-            // on non-useful type error messages)\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    TyError,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TyTrait<'tcx> {\n+pub struct TraitTy<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n     pub bounds: ExistentialBounds<'tcx>,\n }\n \n-impl<'tcx> TyTrait<'tcx> {\n+impl<'tcx> TraitTy<'tcx> {\n     pub fn principal_def_id(&self) -> ast::DefId {\n         self.principal.0.def_id\n     }\n@@ -2695,21 +2744,21 @@ impl<'tcx> CommonTypes<'tcx> {\n            -> CommonTypes<'tcx>\n     {\n         CommonTypes {\n-            bool: intern_ty(arena, interner, ty_bool),\n-            char: intern_ty(arena, interner, ty_char),\n-            err: intern_ty(arena, interner, ty_err),\n-            isize: intern_ty(arena, interner, ty_int(ast::TyIs)),\n-            i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n-            i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n-            i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n-            i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n-            usize: intern_ty(arena, interner, ty_uint(ast::TyUs)),\n-            u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n-            u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n-            u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n-            u64: intern_ty(arena, interner, ty_uint(ast::TyU64)),\n-            f32: intern_ty(arena, interner, ty_float(ast::TyF32)),\n-            f64: intern_ty(arena, interner, ty_float(ast::TyF64)),\n+            bool: intern_ty(arena, interner, TyBool),\n+            char: intern_ty(arena, interner, TyChar),\n+            err: intern_ty(arena, interner, TyError),\n+            isize: intern_ty(arena, interner, TyInt(ast::TyIs)),\n+            i8: intern_ty(arena, interner, TyInt(ast::TyI8)),\n+            i16: intern_ty(arena, interner, TyInt(ast::TyI16)),\n+            i32: intern_ty(arena, interner, TyInt(ast::TyI32)),\n+            i64: intern_ty(arena, interner, TyInt(ast::TyI64)),\n+            usize: intern_ty(arena, interner, TyUint(ast::TyUs)),\n+            u8: intern_ty(arena, interner, TyUint(ast::TyU8)),\n+            u16: intern_ty(arena, interner, TyUint(ast::TyU16)),\n+            u32: intern_ty(arena, interner, TyUint(ast::TyU32)),\n+            u64: intern_ty(arena, interner, TyUint(ast::TyU64)),\n+            f32: intern_ty(arena, interner, TyFloat(ast::TyF32)),\n+            f64: intern_ty(arena, interner, TyFloat(ast::TyF64)),\n         }\n     }\n }\n@@ -2865,14 +2914,14 @@ impl<'tcx> ctxt<'tcx> {\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n-pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: sty<'tcx>) -> Ty<'tcx> {\n+pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n     let mut interner = cx.interner.borrow_mut();\n     intern_ty(&cx.arenas.type_, &mut *interner, st)\n }\n \n fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n                    interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>,\n-                   st: sty<'tcx>)\n+                   st: TypeVariants<'tcx>)\n                    -> Ty<'tcx>\n {\n     match interner.get(&st) {\n@@ -2908,7 +2957,7 @@ impl FlagComputation {\n         FlagComputation { flags: TypeFlags::empty(), depth: 0 }\n     }\n \n-    fn for_sty(st: &sty) -> FlagComputation {\n+    fn for_sty(st: &TypeVariants) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_sty(st);\n         result\n@@ -2938,54 +2987,54 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_sty(&mut self, st: &sty) {\n+    fn add_sty(&mut self, st: &TypeVariants) {\n         match st {\n-            &ty_bool |\n-            &ty_char |\n-            &ty_int(_) |\n-            &ty_float(_) |\n-            &ty_uint(_) |\n-            &ty_str => {\n+            &TyBool |\n+            &TyChar |\n+            &TyInt(_) |\n+            &TyFloat(_) |\n+            &TyUint(_) |\n+            &TyStr => {\n             }\n \n-            // You might think that we could just return ty_err for\n-            // any type containing ty_err as a component, and get\n+            // You might think that we could just return TyError for\n+            // any type containing TyError as a component, and get\n             // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n             // the exception of function types that return bot).\n             // But doing so caused sporadic memory corruption, and\n             // neither I (tjc) nor nmatsakis could figure out why,\n             // so we're doing it this way.\n-            &ty_err => {\n+            &TyError => {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty_param(ref p) => {\n+            &TyParam(ref p) => {\n                 if p.space == subst::SelfSpace {\n                     self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n                     self.add_flags(TypeFlags::HAS_PARAMS);\n                 }\n             }\n \n-            &ty_closure(_, substs) => {\n+            &TyClosure(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_substs(substs);\n             }\n \n-            &ty_infer(_) => {\n+            &TyInfer(_) => {\n                 self.add_flags(TypeFlags::HAS_TY_INFER)\n             }\n \n-            &ty_enum(_, substs) | &ty_struct(_, substs) => {\n+            &TyEnum(_, substs) | &TyStruct(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n-            &ty_projection(ref data) => {\n+            &TyProjection(ref data) => {\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n-            &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n+            &TyTrait(box TraitTy { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_substs(principal.0.substs);\n                 for projection_bound in &bounds.projection_bounds {\n@@ -2998,24 +3047,24 @@ impl FlagComputation {\n                 self.add_bounds(bounds);\n             }\n \n-            &ty_uniq(tt) | &ty_vec(tt, _) => {\n+            &TyBox(tt) | &TyArray(tt, _) => {\n                 self.add_ty(tt)\n             }\n \n-            &ty_ptr(ref m) => {\n+            &TyRawPtr(ref m) => {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty_rptr(r, ref m) => {\n+            &TyRef(r, ref m) => {\n                 self.add_region(*r);\n                 self.add_ty(m.ty);\n             }\n \n-            &ty_tup(ref ts) => {\n+            &TyTuple(ref ts) => {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty_bare_fn(_, ref f) => {\n+            &TyBareFn(_, ref f) => {\n                 self.add_fn_sig(&f.sig);\n             }\n         }\n@@ -3108,28 +3157,28 @@ pub fn mk_mach_float<'tcx>(tcx: &ctxt<'tcx>, tm: ast::FloatTy) -> Ty<'tcx> {\n }\n \n pub fn mk_str<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, ty_str)\n+    mk_t(cx, TyStr)\n }\n \n pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, m: ast::Mutability) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n-                ty: mk_t(cx, ty_str),\n+                ty: mk_t(cx, TyStr),\n                 mutbl: m\n             })\n }\n \n pub fn mk_enum<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, ty_enum(did, substs))\n+    mk_t(cx, TyEnum(did, substs))\n }\n \n-pub fn mk_uniq<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_uniq(ty)) }\n+pub fn mk_uniq<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, TyBox(ty)) }\n \n-pub fn mk_ptr<'tcx>(cx: &ctxt<'tcx>, tm: mt<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_ptr(tm)) }\n+pub fn mk_ptr<'tcx>(cx: &ctxt<'tcx>, tm: mt<'tcx>) -> Ty<'tcx> { mk_t(cx, TyRawPtr(tm)) }\n \n pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, ty_rptr(r, tm))\n+    mk_t(cx, TyRef(r, tm))\n }\n \n pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -3152,7 +3201,7 @@ pub fn mk_nil_ptr<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n }\n \n pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<usize>) -> Ty<'tcx> {\n-    mk_t(cx, ty_vec(ty, sz))\n+    mk_t(cx, TyArray(ty, sz))\n }\n \n pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n@@ -3164,21 +3213,21 @@ pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx\n }\n \n pub fn mk_tup<'tcx>(cx: &ctxt<'tcx>, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n-    mk_t(cx, ty_tup(ts))\n+    mk_t(cx, TyTuple(ts))\n }\n \n pub fn mk_nil<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_tup(cx, Vec::new())\n }\n \n pub fn mk_bool<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, ty_bool)\n+    mk_t(cx, TyBool)\n }\n \n pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>,\n                         opt_def_id: Option<ast::DefId>,\n                         fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, ty_bare_fn(opt_def_id, fty))\n+    mk_t(cx, TyBareFn(opt_def_id, fty))\n }\n \n pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n@@ -3206,11 +3255,11 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n {\n     assert!(bound_list_is_sorted(&bounds.projection_bounds));\n \n-    let inner = box TyTrait {\n+    let inner = box TraitTy {\n         principal: principal,\n         bounds: bounds\n     };\n-    mk_t(cx, ty_trait(inner))\n+    mk_t(cx, TyTrait(inner))\n }\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n@@ -3229,18 +3278,18 @@ pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n                            -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n     let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n-    mk_t(cx, ty_projection(inner))\n+    mk_t(cx, TyProjection(inner))\n }\n \n pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n                        substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, ty_struct(struct_id, substs))\n+    mk_t(cx, TyStruct(struct_id, substs))\n }\n \n pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &'tcx Substs<'tcx>)\n                         -> Ty<'tcx> {\n-    mk_t(cx, ty_closure(closure_id, substs))\n+    mk_t(cx, TyClosure(closure_id, substs))\n }\n \n pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n@@ -3256,14 +3305,14 @@ pub fn mk_float_var<'tcx>(cx: &ctxt<'tcx>, v: FloatVid) -> Ty<'tcx> {\n }\n \n pub fn mk_infer<'tcx>(cx: &ctxt<'tcx>, it: InferTy) -> Ty<'tcx> {\n-    mk_t(cx, ty_infer(it))\n+    mk_t(cx, TyInfer(it))\n }\n \n pub fn mk_param<'tcx>(cx: &ctxt<'tcx>,\n                       space: subst::ParamSpace,\n                       index: u32,\n                       name: ast::Name) -> Ty<'tcx> {\n-    mk_t(cx, ty_param(ParamTy { space: space, idx: index, name: name }))\n+    mk_t(cx, TyParam(ParamTy { space: space, idx: index, name: name }))\n }\n \n pub fn mk_self_type<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n@@ -3298,14 +3347,14 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n         match self.sty {\n-            ty::ty_param(ref d) => Some(d.clone()),\n+            ty::TyParam(ref d) => Some(d.clone()),\n             _ => None,\n         }\n     }\n \n     pub fn is_param(&self, space: ParamSpace, index: u32) -> bool {\n         match self.sty {\n-            ty::ty_param(ref data) => data.space == space && data.idx == index,\n+            ty::TyParam(ref data) => data.space == space && data.idx == index,\n             _ => false,\n         }\n     }\n@@ -3395,7 +3444,7 @@ impl<'tcx> ParamBounds<'tcx> {\n \n pub fn type_is_nil(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_tup(ref tys) => tys.is_empty(),\n+        TyTuple(ref tys) => tys.is_empty(),\n         _ => false\n     }\n }\n@@ -3414,24 +3463,24 @@ pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n \n pub fn type_is_ty_var(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_infer(TyVar(_)) => true,\n+        TyInfer(TyVar(_)) => true,\n         _ => false\n     }\n }\n \n-pub fn type_is_bool(ty: Ty) -> bool { ty.sty == ty_bool }\n+pub fn type_is_bool(ty: Ty) -> bool { ty.sty == TyBool }\n \n pub fn type_is_self(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_param(ref p) => p.space == subst::SelfSpace,\n+        TyParam(ref p) => p.space == subst::SelfSpace,\n         _ => false\n     }\n }\n \n fn type_is_slice(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_ptr(mt) | ty_rptr(_, mt) => match mt.ty.sty {\n-            ty_vec(_, None) | ty_str => true,\n+        TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n+            TyArray(_, None) | TyStr => true,\n             _ => false,\n         },\n         _ => false\n@@ -3440,10 +3489,10 @@ fn type_is_slice(ty: Ty) -> bool {\n \n pub fn type_is_vec(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_vec(..) => true,\n-        ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..}) |\n-        ty_uniq(ty) => match ty.sty {\n-            ty_vec(_, None) => true,\n+        TyArray(..) => true,\n+        TyRawPtr(mt{ty, ..}) | TyRef(_, mt{ty, ..}) |\n+        TyBox(ty) => match ty.sty {\n+            TyArray(_, None) => true,\n             _ => false\n         },\n         _ => false\n@@ -3452,31 +3501,31 @@ pub fn type_is_vec(ty: Ty) -> bool {\n \n pub fn type_is_structural(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_struct(..) | ty_tup(_) | ty_enum(..) |\n-      ty_vec(_, Some(_)) | ty_closure(..) => true,\n+      TyStruct(..) | TyTuple(_) | TyEnum(..) |\n+      TyArray(_, Some(_)) | TyClosure(..) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n \n pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty_struct(did, _) => lookup_simd(cx, did),\n+        TyStruct(did, _) => lookup_simd(cx, did),\n         _ => false\n     }\n }\n \n pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n-        ty_vec(ty, _) => ty,\n-        ty_str => mk_mach_uint(cx, ast::TyU8),\n+        TyArray(ty, _) => ty,\n+        TyStr => mk_mach_uint(cx, ast::TyU8),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                  ty_to_string(cx, ty))),\n     }\n }\n \n pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n-        ty_struct(did, substs) => {\n+        TyStruct(did, substs) => {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n         }\n@@ -3486,7 +3535,7 @@ pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n \n pub fn simd_size(cx: &ctxt, ty: Ty) -> usize {\n     match ty.sty {\n-        ty_struct(did, _) => {\n+        TyStruct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n             fields.len()\n         }\n@@ -3496,44 +3545,44 @@ pub fn simd_size(cx: &ctxt, ty: Ty) -> usize {\n \n pub fn type_is_region_ptr(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_rptr(..) => true,\n+        TyRef(..) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_unsafe_ptr(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_ptr(_) => return true,\n+      TyRawPtr(_) => return true,\n       _ => return false\n     }\n }\n \n pub fn type_is_unique(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_uniq(_) => true,\n+        TyBox(_) => true,\n         _ => false\n     }\n }\n \n /*\n  A scalar type is one that denotes an atomic datum, with no sub-components.\n- (A ty_ptr is scalar because it represents a non-managed pointer, so its\n+ (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n  contents are abstract to rustc.)\n */\n pub fn type_is_scalar(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n-      ty_bare_fn(..) | ty_ptr(_) => true,\n+      TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n+      TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n+      TyBareFn(..) | TyRawPtr(_) => true,\n       _ => false\n     }\n }\n \n /// Returns true if this type is a floating point type and false otherwise.\n pub fn type_is_floating_point(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_float(_) |\n-        ty_infer(FloatVar(_)) =>\n+        TyFloat(_) |\n+        TyInfer(FloatVar(_)) =>\n             true,\n \n         _ =>\n@@ -3738,51 +3787,51 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n         let result = match ty.sty {\n             // usize and isize are ffi-unsafe\n-            ty_uint(ast::TyUs) | ty_int(ast::TyIs) => {\n+            TyUint(ast::TyUs) | TyInt(ast::TyIs) => {\n                 TC::ReachesFfiUnsafe\n             }\n \n             // Scalar and unique types are sendable, and durable\n-            ty_infer(ty::FreshIntTy(_)) | ty_infer(ty::FreshFloatTy(_)) |\n-            ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(..) | ty::ty_char => {\n+            TyInfer(ty::FreshIntTy(_)) | TyInfer(ty::FreshFloatTy(_)) |\n+            TyBool | TyInt(_) | TyUint(_) | TyFloat(_) |\n+            TyBareFn(..) | ty::TyChar => {\n                 TC::None\n             }\n \n-            ty_uniq(typ) => {\n+            TyBox(typ) => {\n                 TC::ReachesFfiUnsafe | match typ.sty {\n-                    ty_str => TC::OwnsOwned,\n+                    TyStr => TC::OwnsOwned,\n                     _ => tc_ty(cx, typ, cache).owned_pointer(),\n                 }\n             }\n \n-            ty_trait(box TyTrait { ref bounds, .. }) => {\n+            TyTrait(box TraitTy { ref bounds, .. }) => {\n                 object_contents(bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n             }\n \n-            ty_ptr(ref mt) => {\n+            TyRawPtr(ref mt) => {\n                 tc_ty(cx, mt.ty, cache).unsafe_pointer()\n             }\n \n-            ty_rptr(r, ref mt) => {\n+            TyRef(r, ref mt) => {\n                 TC::ReachesFfiUnsafe | match mt.ty.sty {\n-                    ty_str => borrowed_contents(*r, ast::MutImmutable),\n-                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r,\n+                    TyStr => borrowed_contents(*r, ast::MutImmutable),\n+                    TyArray(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r,\n                                                                                       mt.mutbl)),\n                     _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r, mt.mutbl)),\n                 }\n             }\n \n-            ty_vec(ty, Some(_)) => {\n+            TyArray(ty, Some(_)) => {\n                 tc_ty(cx, ty, cache)\n             }\n \n-            ty_vec(ty, None) => {\n+            TyArray(ty, None) => {\n                 tc_ty(cx, ty, cache) | TC::Nonsized\n             }\n-            ty_str => TC::Nonsized,\n+            TyStr => TC::Nonsized,\n \n-            ty_struct(did, substs) => {\n+            TyStruct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n                     TypeContents::union(&flds[..],\n@@ -3798,19 +3847,19 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_closure(did, substs) => {\n+            TyClosure(did, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                 let param_env = ty::empty_parameter_environment(cx);\n                 let upvars = closure_upvars(&param_env, did, substs).unwrap();\n                 TypeContents::union(&upvars, |f| tc_ty(cx, &f.ty, cache))\n             }\n \n-            ty_tup(ref tys) => {\n+            TyTuple(ref tys) => {\n                 TypeContents::union(&tys[..],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n-            ty_enum(did, substs) => {\n+            TyEnum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n                     TypeContents::union(&variants[..], |variant| {\n@@ -3852,7 +3901,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n                                 if variants[data_idx].args.len() == 1 {\n                                     match variants[data_idx].args[0].sty {\n-                                        ty_bare_fn(..) => { res = res - TC::ReachesFfiUnsafe; }\n+                                        TyBareFn(..) => { res = res - TC::ReachesFfiUnsafe; }\n                                         _ => { }\n                                     }\n                                 }\n@@ -3865,13 +3914,13 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_projection(..) |\n-            ty_param(_) => {\n+            TyProjection(..) |\n+            TyParam(_) => {\n                 TC::All\n             }\n \n-            ty_infer(_) |\n-            ty_err => {\n+            TyInfer(_) |\n+            TyError => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n             }\n         };\n@@ -3963,18 +4012,18 @@ pub fn type_moves_by_default<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n \n     // Fast-path for primitive types\n     let result = match ty.sty {\n-        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n-        ty_ptr(..) | ty_bare_fn(..) | ty_rptr(_, mt {\n+        TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+        TyRawPtr(..) | TyBareFn(..) | TyRef(_, mt {\n             mutbl: ast::MutImmutable, ..\n         }) => Some(false),\n \n-        ty_str | ty_uniq(..) | ty_rptr(_, mt {\n+        TyStr | TyBox(..) | TyRef(_, mt {\n             mutbl: ast::MutMutable, ..\n         }) => Some(true),\n \n-        ty_vec(..) | ty_trait(..) | ty_tup(..) |\n-        ty_closure(..) | ty_enum(..) | ty_struct(..) |\n-        ty_projection(..) | ty_param(..) | ty_infer(..) | ty_err => None\n+        TyArray(..) | TyTrait(..) | TyTuple(..) |\n+        TyClosure(..) | TyEnum(..) | TyStruct(..) |\n+        TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n     }.unwrap_or_else(|| !type_impls_bound(Some(param_env),\n                                           param_env.tcx,\n                                           ty,\n@@ -4015,14 +4064,14 @@ fn type_is_sized_uncached<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'t\n \n     // Fast-path for primitive types\n     let result = match ty.sty {\n-        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n-        ty_uniq(..) | ty_ptr(..) | ty_rptr(..) | ty_bare_fn(..) |\n-        ty_vec(_, Some(..)) | ty_tup(..) | ty_closure(..) => Some(true),\n+        TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+        TyBox(..) | TyRawPtr(..) | TyRef(..) | TyBareFn(..) |\n+        TyArray(_, Some(..)) | TyTuple(..) | TyClosure(..) => Some(true),\n \n-        ty_str | ty_trait(..) | ty_vec(_, None) => Some(false),\n+        TyStr | TyTrait(..) | TyArray(_, None) => Some(false),\n \n-        ty_enum(..) | ty_struct(..) | ty_projection(..) | ty_param(..) |\n-        ty_infer(..) | ty_err => None\n+        TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n+        TyInfer(..) | TyError => None\n     }.unwrap_or_else(|| type_impls_bound(param_env, tcx, ty, ty::BoundSized, span));\n \n     if !type_has_params(ty) && !type_has_self(ty) {\n@@ -4067,65 +4116,65 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             // fixed length vectors need special treatment compared to\n             // normal vectors, since they don't necessarily have the\n             // possibility to have length zero.\n-            ty_vec(_, Some(0)) => false, // don't need no contents\n-            ty_vec(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n-\n-            ty_bool |\n-            ty_char |\n-            ty_int(_) |\n-            ty_uint(_) |\n-            ty_float(_) |\n-            ty_str |\n-            ty_bare_fn(..) |\n-            ty_param(_) |\n-            ty_projection(_) |\n-            ty_vec(_, None) => {\n+            TyArray(_, Some(0)) => false, // don't need no contents\n+            TyArray(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n+\n+            TyBool |\n+            TyChar |\n+            TyInt(_) |\n+            TyUint(_) |\n+            TyFloat(_) |\n+            TyStr |\n+            TyBareFn(..) |\n+            TyParam(_) |\n+            TyProjection(_) |\n+            TyArray(_, None) => {\n                 false\n             }\n-            ty_uniq(typ) => {\n+            TyBox(typ) => {\n                 type_requires(cx, seen, r_ty, typ)\n             }\n-            ty_rptr(_, ref mt) => {\n+            TyRef(_, ref mt) => {\n                 type_requires(cx, seen, r_ty, mt.ty)\n             }\n \n-            ty_ptr(..) => {\n+            TyRawPtr(..) => {\n                 false           // unsafe ptrs can always be NULL\n             }\n \n-            ty_trait(..) => {\n+            TyTrait(..) => {\n                 false\n             }\n \n-            ty_struct(ref did, _) if seen.contains(did) => {\n+            TyStruct(ref did, _) if seen.contains(did) => {\n                 false\n             }\n \n-            ty_struct(did, substs) => {\n+            TyStruct(did, substs) => {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n                 let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n                 seen.pop().unwrap();\n                 r\n             }\n \n-            ty_err |\n-            ty_infer(_) |\n-            ty_closure(..) => {\n+            TyError |\n+            TyInfer(_) |\n+            TyClosure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // inference by-products or closure types\n                 cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n             }\n \n-            ty_tup(ref ts) => {\n+            TyTuple(ref ts) => {\n                 ts.iter().any(|ty| type_requires(cx, seen, r_ty, *ty))\n             }\n \n-            ty_enum(ref did, _) if seen.contains(did) => {\n+            TyEnum(ref did, _) if seen.contains(did) => {\n                 false\n             }\n \n-            ty_enum(did, substs) => {\n+            TyEnum(did, substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n                 let r = !vs.is_empty() && vs.iter().all(|variant| {\n@@ -4184,27 +4233,27 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                                        seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                        -> Representability {\n         match ty.sty {\n-            ty_tup(ref ts) => {\n+            TyTuple(ref ts) => {\n                 find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n-            ty_vec(ty, Some(_)) => {\n+            TyArray(ty, Some(_)) => {\n                 is_type_structurally_recursive(cx, sp, seen, ty)\n             }\n-            ty_struct(did, substs) => {\n+            TyStruct(did, substs) => {\n                 let fields = struct_fields(cx, did, substs);\n                 find_nonrepresentable(cx, sp, seen, fields.iter().map(|f| f.mt.ty))\n             }\n-            ty_enum(did, substs) => {\n+            TyEnum(did, substs) => {\n                 let vs = enum_variants(cx, did);\n                 let iter = vs.iter()\n                     .flat_map(|variant| &variant.args)\n                     .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_closure(..) => {\n+            TyClosure(..) => {\n                 // this check is run on type definitions, so we don't expect\n                 // to see closure types\n                 cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n@@ -4215,7 +4264,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n     fn same_struct_or_enum_def_id(ty: Ty, did: DefId) -> bool {\n         match ty.sty {\n-            ty_struct(ty_did, _) | ty_enum(ty_did, _) => {\n+            TyStruct(ty_did, _) | TyEnum(ty_did, _) => {\n                  ty_did == did\n             }\n             _ => false\n@@ -4224,8 +4273,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n     fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match (&a.sty, &b.sty) {\n-            (&ty_struct(did_a, ref substs_a), &ty_struct(did_b, ref substs_b)) |\n-            (&ty_enum(did_a, ref substs_a), &ty_enum(did_b, ref substs_b)) => {\n+            (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n+            (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n                 if did_a != did_b {\n                     return false;\n                 }\n@@ -4252,7 +4301,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                ::util::ppaux::ty_to_string(cx, ty));\n \n         match ty.sty {\n-            ty_struct(did, _) | ty_enum(did, _) => {\n+            TyStruct(did, _) | TyEnum(did, _) => {\n                 {\n                     // Iterate through stack of previously seen types.\n                     let mut iter = seen.iter();\n@@ -4325,58 +4374,58 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n pub fn type_is_trait(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_trait(..) => true,\n+        TyTrait(..) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_integral(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) => true,\n+      TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_fresh(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(FreshTy(_)) => true,\n-      ty_infer(FreshIntTy(_)) => true,\n-      ty_infer(FreshFloatTy(_)) => true,\n+      TyInfer(FreshTy(_)) => true,\n+      TyInfer(FreshIntTy(_)) => true,\n+      TyInfer(FreshFloatTy(_)) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_uint(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(IntVar(_)) | ty_uint(ast::TyUs) => true,\n+      TyInfer(IntVar(_)) | TyUint(ast::TyUs) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_char(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_char => true,\n+        TyChar => true,\n         _ => false\n     }\n }\n \n pub fn type_is_bare_fn(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_bare_fn(..) => true,\n+        TyBareFn(..) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_bare_fn_item(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_bare_fn(Some(_), _) => true,\n+        TyBareFn(Some(_), _) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_fp(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(FloatVar(_)) | ty_float(_) => true,\n+      TyInfer(FloatVar(_)) | TyFloat(_) => true,\n       _ => false\n     }\n }\n@@ -4387,15 +4436,15 @@ pub fn type_is_numeric(ty: Ty) -> bool {\n \n pub fn type_is_signed(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_int(_) => true,\n+      TyInt(_) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_machine(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_int(ast::TyIs) | ty_uint(ast::TyUs) => false,\n-        ty_int(..) | ty_uint(..) | ty_float(..) => true,\n+        TyInt(ast::TyIs) | TyUint(ast::TyUs) => false,\n+        TyInt(..) | TyUint(..) | TyFloat(..) => true,\n         _ => false\n     }\n }\n@@ -4404,7 +4453,7 @@ pub fn type_is_machine(ty: Ty) -> bool {\n // constructors\n pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty_enum(did, _) => {\n+        TyEnum(did, _) => {\n             let variants = enum_variants(cx, did);\n             if variants.is_empty() {\n                 false\n@@ -4422,30 +4471,30 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n     match ty.sty {\n-        ty_uniq(ty) => {\n+        TyBox(ty) => {\n             Some(mt {\n                 ty: ty,\n                 mutbl: ast::MutImmutable,\n             })\n         },\n-        ty_rptr(_, mt) => Some(mt),\n-        ty_ptr(mt) if explicit => Some(mt),\n+        TyRef(_, mt) => Some(mt),\n+        TyRawPtr(mt) if explicit => Some(mt),\n         _ => None\n     }\n }\n \n pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n-        ty_uniq(ty) => ty,\n-        ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n+        TyBox(ty) => ty,\n+        TyRef(_, mt) | TyRawPtr(mt) => mt.ty,\n         _ => ty\n     }\n }\n \n // Returns the type of ty[i]\n pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.sty {\n-        ty_vec(ty, _) => Some(ty),\n+        TyArray(ty, _) => Some(ty),\n         _ => None\n     }\n }\n@@ -4455,8 +4504,8 @@ pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n // which can't actually be indexed.\n pub fn array_element_ty<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.sty {\n-        ty_vec(ty, _) => Some(ty),\n-        ty_str => Some(tcx.types.u8),\n+        TyArray(ty, _) => Some(ty),\n+        TyStr => Some(tcx.types.u8),\n         _ => None\n     }\n }\n@@ -4469,19 +4518,19 @@ pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                                    variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n-        (&ty_tup(ref v), None) => v.get(i).cloned(),\n+        (&TyTuple(ref v), None) => v.get(i).cloned(),\n \n \n-        (&ty_struct(def_id, substs), None) => lookup_struct_fields(cx, def_id)\n+        (&TyStruct(def_id, substs), None) => lookup_struct_fields(cx, def_id)\n             .get(i)\n             .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),\n \n-        (&ty_enum(def_id, substs), Some(variant_def_id)) => {\n+        (&TyEnum(def_id, substs), Some(variant_def_id)) => {\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n             variant_info.args.get(i).map(|t|t.subst(cx, substs))\n         }\n \n-        (&ty_enum(def_id, substs), None) => {\n+        (&TyEnum(def_id, substs), None) => {\n             assert!(enum_is_univariant(cx, def_id));\n             let enum_variants = enum_variants(cx, def_id);\n             let variant_info = &(*enum_variants)[0];\n@@ -4500,12 +4549,12 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                               variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n-        (&ty_struct(def_id, substs), None) => {\n+        (&TyStruct(def_id, substs), None) => {\n             let r = lookup_struct_fields(cx, def_id);\n             r.iter().find(|f| f.name == n)\n                 .map(|&f| lookup_field_type(cx, def_id, f.id, substs))\n         }\n-        (&ty_enum(def_id, substs), Some(variant_def_id)) => {\n+        (&TyEnum(def_id, substs), Some(variant_def_id)) => {\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n             variant_info.arg_names.as_ref()\n                 .expect(\"must have struct enum variant if accessing a named fields\")\n@@ -4542,7 +4591,7 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n \n pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => f.sig.0.variadic,\n+        TyBareFn(_, ref f) => f.sig.0.variadic,\n         ref s => {\n             panic!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n         }\n@@ -4551,7 +4600,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n \n pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => &f.sig,\n+        TyBareFn(_, ref f) => &f.sig,\n         ref s => {\n             panic!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n         }\n@@ -4561,7 +4610,7 @@ pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n /// Returns the ABI of the given function.\n pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => f.abi,\n+        TyBareFn(_, ref f) => f.abi,\n         _ => panic!(\"ty_fn_abi() called on non-fn type\"),\n     }\n }\n@@ -4573,7 +4622,7 @@ pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n \n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => f.sig.output(),\n+        TyBareFn(_, ref f) => f.sig.output(),\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n@@ -4582,7 +4631,7 @@ pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n \n pub fn is_fn_ty(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(..) => true,\n+        TyBareFn(..) => true,\n         _ => false\n     }\n }\n@@ -4591,7 +4640,7 @@ pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: Ty) -> Region {\n     match ty.sty {\n-        ty_rptr(r, _) => *r,\n+        TyRef(r, _) => *r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -4706,7 +4755,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                           -> Ty<'tcx> where\n     F: FnMut(MethodCall) -> Option<Ty<'tcx>>,\n {\n-    if let ty_err = unadjusted_ty.sty {\n+    if let TyError = unadjusted_ty.sty {\n         return unadjusted_ty;\n     }\n \n@@ -4715,7 +4764,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n             match *adjustment {\n                AdjustReifyFnPointer => {\n                     match unadjusted_ty.sty {\n-                        ty::ty_bare_fn(Some(_), b) => {\n+                        ty::TyBareFn(Some(_), b) => {\n                             ty::mk_bare_fn(cx, None, b)\n                         }\n                         _ => {\n@@ -4728,7 +4777,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n \n                AdjustUnsafeFnPointer => {\n                     match unadjusted_ty.sty {\n-                        ty::ty_bare_fn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n+                        ty::TyBareFn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n                         ref b => {\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n@@ -4862,7 +4911,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefStruct(_) => {\n                     match tcx.node_types.borrow().get(&expr.id) {\n                         Some(ty) => match ty.sty {\n-                            ty_bare_fn(..) => RvalueDatumExpr,\n+                            TyBareFn(..) => RvalueDatumExpr,\n                             _ => RvalueDpsExpr\n                         },\n                         // See ExprCast below for why types might be missing.\n@@ -5006,43 +5055,43 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n \n pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n     match ty.sty {\n-        ty_bool | ty_char | ty_int(_) |\n-        ty_uint(_) | ty_float(_) | ty_str => {\n+        TyBool | TyChar | TyInt(_) |\n+        TyUint(_) | TyFloat(_) | TyStr => {\n             ::util::ppaux::ty_to_string(cx, ty)\n         }\n-        ty_tup(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, ty),\n-\n-        ty_enum(id, _) => format!(\"enum `{}`\", item_path_str(cx, id)),\n-        ty_uniq(_) => \"box\".to_string(),\n-        ty_vec(_, Some(n)) => format!(\"array of {} elements\", n),\n-        ty_vec(_, None) => \"slice\".to_string(),\n-        ty_ptr(_) => \"*-ptr\".to_string(),\n-        ty_rptr(_, _) => \"&-ptr\".to_string(),\n-        ty_bare_fn(Some(_), _) => format!(\"fn item\"),\n-        ty_bare_fn(None, _) => \"fn pointer\".to_string(),\n-        ty_trait(ref inner) => {\n+        TyTuple(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, ty),\n+\n+        TyEnum(id, _) => format!(\"enum `{}`\", item_path_str(cx, id)),\n+        TyBox(_) => \"box\".to_string(),\n+        TyArray(_, Some(n)) => format!(\"array of {} elements\", n),\n+        TyArray(_, None) => \"slice\".to_string(),\n+        TyRawPtr(_) => \"*-ptr\".to_string(),\n+        TyRef(_, _) => \"&-ptr\".to_string(),\n+        TyBareFn(Some(_), _) => format!(\"fn item\"),\n+        TyBareFn(None, _) => \"fn pointer\".to_string(),\n+        TyTrait(ref inner) => {\n             format!(\"trait {}\", item_path_str(cx, inner.principal_def_id()))\n         }\n-        ty_struct(id, _) => {\n+        TyStruct(id, _) => {\n             format!(\"struct `{}`\", item_path_str(cx, id))\n         }\n-        ty_closure(..) => \"closure\".to_string(),\n-        ty_tup(_) => \"tuple\".to_string(),\n-        ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n-        ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n-        ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n-        ty_infer(FreshTy(_)) => \"skolemized type\".to_string(),\n-        ty_infer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n-        ty_infer(FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n-        ty_projection(_) => \"associated type\".to_string(),\n-        ty_param(ref p) => {\n+        TyClosure(..) => \"closure\".to_string(),\n+        TyTuple(_) => \"tuple\".to_string(),\n+        TyInfer(TyVar(_)) => \"inferred type\".to_string(),\n+        TyInfer(IntVar(_)) => \"integral variable\".to_string(),\n+        TyInfer(FloatVar(_)) => \"floating-point variable\".to_string(),\n+        TyInfer(FreshTy(_)) => \"skolemized type\".to_string(),\n+        TyInfer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+        TyInfer(FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+        TyProjection(_) => \"associated type\".to_string(),\n+        TyParam(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n             } else {\n                 \"type parameter\".to_string()\n             }\n         }\n-        ty_err => \"type error\".to_string(),\n+        TyError => \"type error\".to_string(),\n     }\n }\n \n@@ -5463,11 +5512,11 @@ pub fn try_add_builtin_trait(\n \n pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n     match ty.sty {\n-        ty_trait(ref tt) =>\n+        TyTrait(ref tt) =>\n             Some(tt.principal_def_id()),\n-        ty_struct(id, _) |\n-        ty_enum(id, _) |\n-        ty_closure(id, _) =>\n+        TyStruct(id, _) |\n+        TyEnum(id, _) |\n+        TyClosure(id, _) =>\n             Some(id),\n         _ =>\n             None\n@@ -5621,7 +5670,7 @@ pub fn enum_is_univariant(cx: &ctxt, id: ast::DefId) -> bool {\n \n pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n     match ty.sty {\n-       ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n+       TyEnum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n }\n@@ -6102,7 +6151,7 @@ pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n /// if not a structure at all. Corresponds to the only possible unsized\n /// field, and its type can be used to determine unsizing strategy.\n pub fn struct_tail<'tcx>(cx: &ctxt<'tcx>, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-    while let ty_struct(def_id, substs) = ty.sty {\n+    while let TyStruct(def_id, substs) = ty.sty {\n         match struct_fields(cx, def_id, substs).last() {\n             Some(f) => ty = f.mt.ty,\n             None => break\n@@ -6121,7 +6170,7 @@ pub fn struct_lockstep_tails<'tcx>(cx: &ctxt<'tcx>,\n                                    target: Ty<'tcx>)\n                                    -> (Ty<'tcx>, Ty<'tcx>) {\n     let (mut a, mut b) = (source, target);\n-    while let (&ty_struct(a_did, a_substs), &ty_struct(b_did, b_substs)) = (&a.sty, &b.sty) {\n+    while let (&TyStruct(a_did, a_substs), &TyStruct(b_did, b_substs)) = (&a.sty, &b.sty) {\n         if a_did != b_did {\n             continue;\n         }\n@@ -6553,55 +6602,55 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n         };\n         maybe_walk_ty(ty, |ty| {\n             match ty.sty {\n-                ty_bool => byte!(2),\n-                ty_char => byte!(3),\n-                ty_int(i) => {\n+                TyBool => byte!(2),\n+                TyChar => byte!(3),\n+                TyInt(i) => {\n                     byte!(4);\n                     hash!(i);\n                 }\n-                ty_uint(u) => {\n+                TyUint(u) => {\n                     byte!(5);\n                     hash!(u);\n                 }\n-                ty_float(f) => {\n+                TyFloat(f) => {\n                     byte!(6);\n                     hash!(f);\n                 }\n-                ty_str => {\n+                TyStr => {\n                     byte!(7);\n                 }\n-                ty_enum(d, _) => {\n+                TyEnum(d, _) => {\n                     byte!(8);\n                     did(state, d);\n                 }\n-                ty_uniq(_) => {\n+                TyBox(_) => {\n                     byte!(9);\n                 }\n-                ty_vec(_, Some(n)) => {\n+                TyArray(_, Some(n)) => {\n                     byte!(10);\n                     n.hash(state);\n                 }\n-                ty_vec(_, None) => {\n+                TyArray(_, None) => {\n                     byte!(11);\n                 }\n-                ty_ptr(m) => {\n+                TyRawPtr(m) => {\n                     byte!(12);\n                     mt(state, m);\n                 }\n-                ty_rptr(r, m) => {\n+                TyRef(r, m) => {\n                     byte!(13);\n                     region(state, *r);\n                     mt(state, m);\n                 }\n-                ty_bare_fn(opt_def_id, ref b) => {\n+                TyBareFn(opt_def_id, ref b) => {\n                     byte!(14);\n                     hash!(opt_def_id);\n                     hash!(b.unsafety);\n                     hash!(b.abi);\n                     fn_sig(state, &b.sig);\n                     return false;\n                 }\n-                ty_trait(ref data) => {\n+                TyTrait(ref data) => {\n                     byte!(17);\n                     did(state, data.principal_def_id());\n                     hash!(data.bounds);\n@@ -6613,27 +6662,27 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n \n                     return false;\n                 }\n-                ty_struct(d, _) => {\n+                TyStruct(d, _) => {\n                     byte!(18);\n                     did(state, d);\n                 }\n-                ty_tup(ref inner) => {\n+                TyTuple(ref inner) => {\n                     byte!(19);\n                     hash!(inner.len());\n                 }\n-                ty_param(p) => {\n+                TyParam(p) => {\n                     byte!(20);\n                     hash!(p.space);\n                     hash!(p.idx);\n                     hash!(token::get_name(p.name));\n                 }\n-                ty_infer(_) => unreachable!(),\n-                ty_err => byte!(21),\n-                ty_closure(d, _) => {\n+                TyInfer(_) => unreachable!(),\n+                TyError => byte!(21),\n+                TyClosure(d, _) => {\n                     byte!(22);\n                     did(state, d);\n                 }\n-                ty_projection(ref data) => {\n+                TyProjection(ref data) => {\n                     byte!(23);\n                     did(state, data.trait_ref.def_id);\n                     hash!(token::get_name(data.item_name));\n@@ -6897,34 +6946,34 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                                     ty: Ty) {\n     walk_ty(ty, |ty| {\n         match ty.sty {\n-            ty_rptr(region, _) => {\n+            TyRef(region, _) => {\n                 accumulator.push(*region)\n             }\n-            ty_trait(ref t) => {\n+            TyTrait(ref t) => {\n                 accumulator.push_all(t.principal.0.substs.regions().as_slice());\n             }\n-            ty_enum(_, substs) |\n-            ty_struct(_, substs) => {\n+            TyEnum(_, substs) |\n+            TyStruct(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n-            ty_closure(_, substs) => {\n+            TyClosure(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n-            ty_bool |\n-            ty_char |\n-            ty_int(_) |\n-            ty_uint(_) |\n-            ty_float(_) |\n-            ty_uniq(_) |\n-            ty_str |\n-            ty_vec(_, _) |\n-            ty_ptr(_) |\n-            ty_bare_fn(..) |\n-            ty_tup(_) |\n-            ty_projection(_) |\n-            ty_param(_) |\n-            ty_infer(_) |\n-            ty_err => {\n+            TyBool |\n+            TyChar |\n+            TyInt(_) |\n+            TyUint(_) |\n+            TyFloat(_) |\n+            TyBox(_) |\n+            TyStr |\n+            TyArray(_, _) |\n+            TyRawPtr(_) |\n+            TyBareFn(..) |\n+            TyTuple(_) |\n+            TyProjection(_) |\n+            TyParam(_) |\n+            TyInfer(_) |\n+            TyError => {\n             }\n         }\n     });\n@@ -7136,9 +7185,9 @@ impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TyTrait<'tcx> {\n+impl<'tcx> Repr<'tcx> for TraitTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TyTrait({},{})\",\n+        format!(\"TraitTy({},{})\",\n                 self.principal.repr(tcx),\n                 self.bounds.repr(tcx))\n     }\n@@ -7196,7 +7245,7 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n     let tcx = param_env.tcx;\n \n     let did = match self_type.sty {\n-        ty::ty_struct(struct_did, substs) => {\n+        ty::TyStruct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n             for field in &fields {\n                 if type_moves_by_default(param_env, span, field.mt.ty) {\n@@ -7205,7 +7254,7 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n             }\n             struct_did\n         }\n-        ty::ty_enum(enum_did, substs) => {\n+        ty::TyEnum(enum_did, substs) => {\n             let enum_variants = ty::enum_variants(tcx, enum_did);\n             for variant in enum_variants.iter() {\n                 for variant_arg_type in &variant.args {"}, {"sha": "40d5dab15a4938e0efe8d46202b643ba9df90c02", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -590,51 +590,51 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                 ty: Ty<'tcx>)\n                                                 -> Ty<'tcx> {\n     let sty = match ty.sty {\n-        ty::ty_uniq(typ) => {\n-            ty::ty_uniq(typ.fold_with(this))\n+        ty::TyBox(typ) => {\n+            ty::TyBox(typ.fold_with(this))\n         }\n-        ty::ty_ptr(ref tm) => {\n-            ty::ty_ptr(tm.fold_with(this))\n+        ty::TyRawPtr(ref tm) => {\n+            ty::TyRawPtr(tm.fold_with(this))\n         }\n-        ty::ty_vec(typ, sz) => {\n-            ty::ty_vec(typ.fold_with(this), sz)\n+        ty::TyArray(typ, sz) => {\n+            ty::TyArray(typ.fold_with(this), sz)\n         }\n-        ty::ty_enum(tid, ref substs) => {\n+        ty::TyEnum(tid, ref substs) => {\n             let substs = substs.fold_with(this);\n-            ty::ty_enum(tid, this.tcx().mk_substs(substs))\n+            ty::TyEnum(tid, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-            ty::ty_trait(box ty::TyTrait {\n+        ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n+            ty::TyTrait(box ty::TraitTy {\n                 principal: principal.fold_with(this),\n                 bounds: bounds.fold_with(this),\n             })\n         }\n-        ty::ty_tup(ref ts) => {\n-            ty::ty_tup(ts.fold_with(this))\n+        ty::TyTuple(ref ts) => {\n+            ty::TyTuple(ts.fold_with(this))\n         }\n-        ty::ty_bare_fn(opt_def_id, ref f) => {\n+        ty::TyBareFn(opt_def_id, ref f) => {\n             let bfn = f.fold_with(this);\n-            ty::ty_bare_fn(opt_def_id, this.tcx().mk_bare_fn(bfn))\n+            ty::TyBareFn(opt_def_id, this.tcx().mk_bare_fn(bfn))\n         }\n-        ty::ty_rptr(r, ref tm) => {\n+        ty::TyRef(r, ref tm) => {\n             let r = r.fold_with(this);\n-            ty::ty_rptr(this.tcx().mk_region(r), tm.fold_with(this))\n+            ty::TyRef(this.tcx().mk_region(r), tm.fold_with(this))\n         }\n-        ty::ty_struct(did, ref substs) => {\n+        ty::TyStruct(did, ref substs) => {\n             let substs = substs.fold_with(this);\n-            ty::ty_struct(did, this.tcx().mk_substs(substs))\n+            ty::TyStruct(did, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_closure(did, ref substs) => {\n+        ty::TyClosure(did, ref substs) => {\n             let s = substs.fold_with(this);\n-            ty::ty_closure(did, this.tcx().mk_substs(s))\n+            ty::TyClosure(did, this.tcx().mk_substs(s))\n         }\n-        ty::ty_projection(ref data) => {\n-            ty::ty_projection(data.fold_with(this))\n+        ty::TyProjection(ref data) => {\n+            ty::TyProjection(data.fold_with(this))\n         }\n-        ty::ty_bool | ty::ty_char | ty::ty_str |\n-        ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-        ty::ty_err | ty::ty_infer(_) |\n-        ty::ty_param(..) => {\n+        ty::TyBool | ty::TyChar | ty::TyStr |\n+        ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n+        ty::TyError | ty::TyInfer(_) |\n+        ty::TyParam(..) => {\n             ty.sty.clone()\n         }\n     };"}, {"sha": "241a27aa0cd79533f57c6f763362c656aaba820e", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -66,18 +66,18 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n         if a == b { return Ok(a); }\n \n         match (&a.sty, &b.sty) {\n-            (_, &ty::ty_infer(ty::FreshTy(_))) |\n-            (_, &ty::ty_infer(ty::FreshIntTy(_))) |\n-            (_, &ty::ty_infer(ty::FreshFloatTy(_))) => {\n+            (_, &ty::TyInfer(ty::FreshTy(_))) |\n+            (_, &ty::TyInfer(ty::FreshIntTy(_))) |\n+            (_, &ty::TyInfer(ty::FreshFloatTy(_))) => {\n                 Ok(a)\n             }\n \n-            (&ty::ty_infer(_), _) |\n-            (_, &ty::ty_infer(_)) => {\n+            (&ty::TyInfer(_), _) |\n+            (_, &ty::TyInfer(_)) => {\n                 Err(ty::terr_sorts(ty_relate::expected_found(self, &a, &b)))\n             }\n \n-            (&ty::ty_err, _) | (_, &ty::ty_err) => {\n+            (&ty::TyError, _) | (_, &ty::TyError) => {\n                 Ok(self.tcx().types.err)\n             }\n "}, {"sha": "c79fe7f5ad10a837068f581b36ffbff5576c0031", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -438,87 +438,87 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n     let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     match (a_sty, b_sty) {\n-        (&ty::ty_infer(_), _) |\n-        (_, &ty::ty_infer(_)) =>\n+        (&ty::TyInfer(_), _) |\n+        (_, &ty::TyInfer(_)) =>\n         {\n             // The caller should handle these cases!\n             tcx.sess.bug(\"var types encountered in super_relate_tys\")\n         }\n \n-        (&ty::ty_err, _) | (_, &ty::ty_err) =>\n+        (&ty::TyError, _) | (_, &ty::TyError) =>\n         {\n             Ok(tcx.types.err)\n         }\n \n-        (&ty::ty_char, _) |\n-        (&ty::ty_bool, _) |\n-        (&ty::ty_int(_), _) |\n-        (&ty::ty_uint(_), _) |\n-        (&ty::ty_float(_), _) |\n-        (&ty::ty_str, _)\n+        (&ty::TyChar, _) |\n+        (&ty::TyBool, _) |\n+        (&ty::TyInt(_), _) |\n+        (&ty::TyUint(_), _) |\n+        (&ty::TyFloat(_), _) |\n+        (&ty::TyStr, _)\n             if a == b =>\n         {\n             Ok(a)\n         }\n \n-        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p))\n+        (&ty::TyParam(ref a_p), &ty::TyParam(ref b_p))\n             if a_p.idx == b_p.idx && a_p.space == b_p.space =>\n         {\n             Ok(a)\n         }\n \n-        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n+        (&ty::TyEnum(a_id, a_substs), &ty::TyEnum(b_id, b_substs))\n             if a_id == b_id =>\n         {\n             let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n             Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) =>\n+        (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n         {\n             let principal = try!(relation.relate(&a_.principal, &b_.principal));\n             let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n             Ok(ty::mk_trait(tcx, principal, bounds))\n         }\n \n-        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n+        (&ty::TyStruct(a_id, a_substs), &ty::TyStruct(b_id, b_substs))\n             if a_id == b_id =>\n         {\n             let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::ty_closure(a_id, a_substs),\n-         &ty::ty_closure(b_id, b_substs))\n+        (&ty::TyClosure(a_id, a_substs),\n+         &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>\n         {\n-            // All ty_closure types with the same id represent\n+            // All TyClosure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n             Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) =>\n+        (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n         {\n             let typ = try!(relation.relate(&a_inner, &b_inner));\n             Ok(ty::mk_uniq(tcx, typ))\n         }\n \n-        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) =>\n+        (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n         {\n             let mt = try!(relation.relate(a_mt, b_mt));\n             Ok(ty::mk_ptr(tcx, mt))\n         }\n \n-        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) =>\n+        (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n         {\n             let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n             let mt = try!(relation.relate(a_mt, b_mt));\n             Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n         }\n \n-        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) =>\n+        (&ty::TyArray(a_t, Some(sz_a)), &ty::TyArray(b_t, Some(sz_b))) =>\n         {\n             let t = try!(relation.relate(&a_t, &b_t));\n             if sz_a == sz_b {\n@@ -528,13 +528,13 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::ty_vec(a_t, None), &ty::ty_vec(b_t, None)) =>\n+        (&ty::TyArray(a_t, None), &ty::TyArray(b_t, None)) =>\n         {\n             let t = try!(relation.relate(&a_t, &b_t));\n             Ok(ty::mk_vec(tcx, t, None))\n         }\n \n-        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) =>\n+        (&ty::TyTuple(ref as_), &ty::TyTuple(ref bs)) =>\n         {\n             if as_.len() == bs.len() {\n                 let ts = try!(as_.iter().zip(bs)\n@@ -549,14 +549,14 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n+        (&ty::TyBareFn(a_opt_def_id, a_fty), &ty::TyBareFn(b_opt_def_id, b_fty))\n             if a_opt_def_id == b_opt_def_id =>\n         {\n             let fty = try!(relation.relate(a_fty, b_fty));\n             Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n         }\n \n-        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) =>\n+        (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n         {\n             let projection_ty = try!(relation.relate(a_data, b_data));\n             Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))"}, {"sha": "50118ed6e9fa7a24875a81f4aeec0000f8e63b1e", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -68,33 +68,33 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n \n fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n-        ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-        ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n+        ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n+        ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyError => {\n         }\n-        ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n+        ty::TyBox(ty) | ty::TyArray(ty, _) => {\n             stack.push(ty);\n         }\n-        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n+        ty::TyRawPtr(ref mt) | ty::TyRef(_, ref mt) => {\n             stack.push(mt.ty);\n         }\n-        ty::ty_projection(ref data) => {\n+        ty::TyProjection(ref data) => {\n             push_reversed(stack, data.trait_ref.substs.types.as_slice());\n         }\n-        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+        ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n             push_reversed(stack, principal.substs().types.as_slice());\n             push_reversed(stack, &bounds.projection_bounds.iter().map(|pred| {\n                 pred.0.ty\n             }).collect::<Vec<_>>());\n         }\n-        ty::ty_enum(_, ref substs) |\n-        ty::ty_struct(_, ref substs) |\n-        ty::ty_closure(_, ref substs) => {\n+        ty::TyEnum(_, ref substs) |\n+        ty::TyStruct(_, ref substs) |\n+        ty::TyClosure(_, ref substs) => {\n             push_reversed(stack, substs.types.as_slice());\n         }\n-        ty::ty_tup(ref ts) => {\n+        ty::TyTuple(ref ts) => {\n             push_reversed(stack, ts);\n         }\n-        ty::ty_bare_fn(_, ref ft) => {\n+        ty::TyBareFn(_, ref ft) => {\n             push_sig_subtypes(stack, &ft.sig);\n         }\n     }"}, {"sha": "5d68c9d9b28f3a7bf821d40b41c438865cb5cff2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -19,11 +19,11 @@ use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, Ty, ParamTy};\n-use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n-use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn};\n-use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup};\n-use middle::ty::ty_closure;\n-use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n+use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n+use middle::ty::{TyError, TyStr, TyArray, TyFloat, TyBareFn};\n+use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n+use middle::ty::TyClosure;\n+use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable};\n \n@@ -363,24 +363,24 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n     // pretty print the structural type representation:\n     match typ.sty {\n-        ty_bool => \"bool\".to_string(),\n-        ty_char => \"char\".to_string(),\n-        ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n-        ty_uint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n-        ty_float(t) => ast_util::float_ty_to_string(t).to_string(),\n-        ty_uniq(typ) => format!(\"Box<{}>\", ty_to_string(cx, typ)),\n-        ty_ptr(ref tm) => {\n+        TyBool => \"bool\".to_string(),\n+        TyChar => \"char\".to_string(),\n+        TyInt(t) => ast_util::int_ty_to_string(t, None).to_string(),\n+        TyUint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n+        TyFloat(t) => ast_util::float_ty_to_string(t).to_string(),\n+        TyBox(typ) => format!(\"Box<{}>\", ty_to_string(cx, typ)),\n+        TyRawPtr(ref tm) => {\n             format!(\"*{} {}\", match tm.mutbl {\n                 ast::MutMutable => \"mut\",\n                 ast::MutImmutable => \"const\",\n             }, ty_to_string(cx, tm.ty))\n         }\n-        ty_rptr(r, ref tm) => {\n+        TyRef(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n             buf.push_str(&mt_to_string(cx, tm));\n             buf\n         }\n-        ty_tup(ref elems) => {\n+        TyTuple(ref elems) => {\n             let strs = elems\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n@@ -390,28 +390,28 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n         }\n-        ty_bare_fn(opt_def_id, ref f) => {\n+        TyBareFn(opt_def_id, ref f) => {\n             bare_fn_to_string(cx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n         }\n-        ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n-        ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => param_ty.user_string(cx),\n-        ty_enum(did, substs) | ty_struct(did, substs) => {\n+        TyInfer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n+        TyError => \"[type error]\".to_string(),\n+        TyParam(ref param_ty) => param_ty.user_string(cx),\n+        TyEnum(did, substs) | TyStruct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             parameterized(cx, &base, substs, did, &[],\n                           || ty::lookup_item_type(cx, did).generics)\n         }\n-        ty_trait(ref data) => {\n+        TyTrait(ref data) => {\n             data.user_string(cx)\n         }\n-        ty::ty_projection(ref data) => {\n+        ty::TyProjection(ref data) => {\n             format!(\"<{} as {}>::{}\",\n                     data.trait_ref.self_ty().user_string(cx),\n                     data.trait_ref.user_string(cx),\n                     data.item_name.user_string(cx))\n         }\n-        ty_str => \"str\".to_string(),\n-        ty_closure(ref did, substs) => {\n+        TyStr => \"str\".to_string(),\n+        TyClosure(ref did, substs) => {\n             let closure_tys = cx.closure_tys.borrow();\n             closure_tys.get(did).map(|closure_type| {\n                 closure_to_string(cx, &closure_type.subst(cx, substs), did)\n@@ -431,7 +431,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 }\n             })\n         }\n-        ty_vec(t, sz) => {\n+        TyArray(t, sz) => {\n             let inner_str = ty_to_string(cx, t);\n             match sz {\n                 Some(n) => format!(\"[{}; {}]\", inner_str, n),\n@@ -701,9 +701,9 @@ impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n+impl<'tcx> UserString<'tcx> for ty::TraitTy<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let &ty::TyTrait { ref principal, ref bounds } = self;\n+        let &ty::TraitTy { ref principal, ref bounds } = self;\n \n         let mut components = vec![];\n "}, {"sha": "90bc918c4b197704b4b12e14b47ec1d866695c4f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -752,7 +752,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::ty_struct(def_id, _) | ty::ty_enum(def_id, _) => {\n+                    ty::TyStruct(def_id, _) | ty::TyEnum(def_id, _) => {\n                         if ty::has_dtor(self.tcx(), def_id) {\n                             // In the case where the owner implements drop, then\n                             // the path must be initialized to prevent a case of"}, {"sha": "a70b1dfe187e41e7aced65c34d449f501f6cd8dc", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -339,7 +339,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n     };\n \n     match (&parent_ty.sty, enum_variant_info) {\n-        (&ty::ty_tup(ref v), None) => {\n+        (&ty::TyTuple(ref v), None) => {\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n@@ -354,7 +354,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::ty_struct(def_id, ref _substs), None) => {\n+        (&ty::TyStruct(def_id, ref _substs), None) => {\n             let fields = ty::lookup_struct_fields(tcx, def_id);\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n@@ -378,7 +378,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::ty_enum(enum_def_id, substs), ref enum_variant_info) => {\n+        (&ty::TyEnum(enum_def_id, substs), ref enum_variant_info) => {\n             let variant_info = {\n                 let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);\n                 match *enum_variant_info {"}, {"sha": "43877d592ae15ab9805d1466307be65139575ef7", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -179,7 +179,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorField(_)) |\n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n-                ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n+                ty::TyStruct(did, _) | ty::TyEnum(did, _) => {\n                     if ty::has_dtor(bccx.tcx, did) {\n                         Some(cmt.clone())\n                     } else {"}, {"sha": "d16e0fdc19fead5d855a2268824be4b98ee8ae35", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -137,8 +137,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::ty_struct(did, _) |\n-                ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n+                ty::TyStruct(did, _) |\n+                ty::TyEnum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\"}, {"sha": "4091351b5a5c4fd205da88def926c637cce8a023", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -656,7 +656,7 @@ fn glb_bound_free_infer() {\n         // `&'_ isize`\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n-            ty::ty_rptr(..) => { }\n+            ty::TyRef(..) => { }\n             _ => { panic!(\"t_resolve1={}\", t_resolve1.repr(env.infcx.tcx)); }\n         }\n     })"}, {"sha": "cc1924071606d64160d07f022eedf57419f2806e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -145,7 +145,7 @@ impl LintPass for TypeLimits {\n                     _ => {\n                         let t = ty::expr_ty(cx.tcx, &**expr);\n                         match t.sty {\n-                            ty::ty_uint(_) => {\n+                            ty::TyUint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int variable may \\\n                                              be unintentional\");\n@@ -170,8 +170,8 @@ impl LintPass for TypeLimits {\n \n                 if is_shift_binop(binop.node) {\n                     let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n-                        ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n-                        ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n+                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n+                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None\n                     };\n \n@@ -195,7 +195,7 @@ impl LintPass for TypeLimits {\n             },\n             ast::ExprLit(ref lit) => {\n                 match ty::expr_ty(cx.tcx, e).sty {\n-                    ty::ty_int(t) => {\n+                    ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n@@ -219,7 +219,7 @@ impl LintPass for TypeLimits {\n                             _ => panic!()\n                         };\n                     },\n-                    ty::ty_uint(t) => {\n+                    ty::TyUint(t) => {\n                         let uint_type = if let ast::TyUs = t {\n                             cx.sess().target.uint_type\n                         } else {\n@@ -236,7 +236,7 @@ impl LintPass for TypeLimits {\n                                          &*format!(\"literal out of range for {:?}\", t));\n                         }\n                     },\n-                    ty::ty_float(t) => {\n+                    ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n@@ -345,7 +345,7 @@ impl LintPass for TypeLimits {\n                 binop\n             };\n             match ty::expr_ty(tcx, expr).sty {\n-                ty::ty_int(int_ty) => {\n+                ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n                         ast::ExprLit(ref li) => match li.node {\n@@ -359,7 +359,7 @@ impl LintPass for TypeLimits {\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n-                ty::ty_uint(uint_ty) => {\n+                ty::TyUint(uint_ty) => {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n                         ast::ExprLit(ref li) => match li.node {\n@@ -486,7 +486,7 @@ impl BoxPointers {\n         let mut n_uniq: usize = 0;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match t.sty {\n-                ty::ty_uniq(_) => {\n+                ty::TyBox(_) => {\n                     n_uniq += 1;\n                 }\n                 _ => ()\n@@ -591,8 +591,8 @@ impl LintPass for RawPointerDerive {\n                 }\n \n                 match ty::node_id_to_type(cx.tcx, item.id).sty {\n-                    ty::ty_enum(did, _) => did,\n-                    ty::ty_struct(did, _) => did,\n+                    ty::TyEnum(did, _) => did,\n+                    ty::TyStruct(did, _) => did,\n                     _ => return,\n                 }\n             }\n@@ -736,10 +736,10 @@ impl LintPass for UnusedResults {\n \n         let t = ty::expr_ty(cx.tcx, expr);\n         let warned = match t.sty {\n-            ty::ty_tup(ref tys) if tys.is_empty() => return,\n-            ty::ty_bool => return,\n-            ty::ty_struct(did, _) |\n-            ty::ty_enum(did, _) => {\n+            ty::TyTuple(ref tys) if tys.is_empty() => return,\n+            ty::TyBool => return,\n+            ty::TyStruct(did, _) |\n+            ty::TyEnum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n                         check_must_use(cx, &it.attrs, s.span)\n@@ -2162,7 +2162,7 @@ impl LintPass for MutableTransmutes {\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n-            Some((&ty::ty_rptr(_, from_mt), &ty::ty_rptr(_, to_mt))) => {\n+            Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {\n                 if to_mt.mutbl == ast::Mutability::MutMutable\n                     && from_mt.mutbl == ast::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n@@ -2172,7 +2172,7 @@ impl LintPass for MutableTransmutes {\n         }\n \n         fn get_transmute_from_to<'a, 'tcx>(cx: &Context<'a, 'tcx>, expr: &ast::Expr)\n-            -> Option<(&'tcx ty::sty<'tcx>, &'tcx ty::sty<'tcx>)> {\n+            -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n                 ast::ExprPath(..) => (),\n                 _ => return None\n@@ -2183,7 +2183,7 @@ impl LintPass for MutableTransmutes {\n                 }\n                 let typ = ty::node_id_to_type(cx.tcx, expr.id);\n                 match typ.sty {\n-                    ty::ty_bare_fn(_, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n+                    ty::TyBareFn(_, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         if let ty::FnConverging(to) = bare_fn.sig.0.output {\n                             let from = bare_fn.sig.0.inputs[0];\n                             return Some((&from.sty, &to.sty));\n@@ -2197,7 +2197,7 @@ impl LintPass for MutableTransmutes {\n \n         fn def_id_is_transmute(cx: &Context, def_id: DefId) -> bool {\n             match ty::lookup_item_type(cx.tcx, def_id).ty.sty {\n-                ty::ty_bare_fn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n+                ty::TyBareFn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n             }\n             ty::with_path(cx.tcx, def_id, |path| match path.last() {\n@@ -2260,9 +2260,9 @@ impl LintPass for DropWithReprExtern {\n                 };\n \n             match dtor_self_type.sty {\n-                ty::ty_enum(self_type_did, _) |\n-                ty::ty_struct(self_type_did, _) |\n-                ty::ty_closure(self_type_did, _) => {\n+                ty::TyEnum(self_type_did, _) |\n+                ty::TyStruct(self_type_did, _) |\n+                ty::TyClosure(self_type_did, _) => {\n                     let hints = ty::lookup_repr_hints(ctx.tcx, self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n                         ty::ty_dtor(ctx.tcx, self_type_did).has_drop_flag() {"}, {"sha": "cae93baaf74be2392a75bae5990834711f22a893", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -711,10 +711,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n         let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n         let struct_desc = match struct_type.sty {\n-            ty::ty_struct(_, _) =>\n+            ty::TyStruct(_, _) =>\n                 format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n             // struct variant fields have inherited visibility\n-            ty::ty_enum(..) => return,\n+            ty::TyEnum(..) => return,\n             _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n         };\n         let msg = match name {\n@@ -893,12 +893,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n-                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                if let ty::TyStruct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n                     self.check_field(expr.span, id, NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n-                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                if let ty::TyStruct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n                     self.check_field(expr.span, id, UnnamedField(idx.node));\n                 }\n             }\n@@ -918,7 +918,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n                 match ty::expr_ty(self.tcx, expr).sty {\n-                    ty::ty_struct(ctor_id, _) => {\n+                    ty::TyStruct(ctor_id, _) => {\n                         // RFC 736: ensure all unmentioned fields are visible.\n                         // Rather than computing the set of unmentioned fields\n                         // (i.e. `all_fields - fields`), just check them all.\n@@ -928,7 +928,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                              NamedField(field.name));\n                         }\n                     }\n-                    ty::ty_enum(_, _) => {\n+                    ty::TyEnum(_, _) => {\n                         match self.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n@@ -995,13 +995,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n                 match ty::pat_ty(self.tcx, pattern).sty {\n-                    ty::ty_struct(id, _) => {\n+                    ty::TyStruct(id, _) => {\n                         for field in fields {\n                             self.check_field(pattern.span, id,\n                                              NamedField(field.node.ident.name));\n                         }\n                     }\n-                    ty::ty_enum(_, _) => {\n+                    ty::TyEnum(_, _) => {\n                         match self.tcx.def_map.borrow().get(&pattern.id).map(|d| d.full_def()) {\n                             Some(def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields {\n@@ -1026,15 +1026,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n                 match ty::pat_ty(self.tcx, pattern).sty {\n-                    ty::ty_struct(id, _) => {\n+                    ty::TyStruct(id, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             if let ast::PatWild(..) = field.node {\n                                 continue\n                             }\n                             self.check_field(field.span, id, UnnamedField(i));\n                         }\n                     }\n-                    ty::ty_enum(..) => {\n+                    ty::TyEnum(..) => {\n                         // enum fields have no privacy at this time\n                     }\n                     _ => {}"}, {"sha": "36901ff0967118d3a81bbee9c5936dae955dd431", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -903,7 +903,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n         let struct_def = match *ty {\n-            ty::ty_struct(def_id, _) => {\n+            ty::TyStruct(def_id, _) => {\n                 let sub_span = self.span.span_for_last_ident(path.span);\n                 self.fmt.ref_str(recorder::StructRef,\n                                  path.span,\n@@ -1316,7 +1316,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n                 match *ty {\n-                    ty::ty_struct(def_id, _) => {\n+                    ty::TyStruct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n@@ -1330,7 +1330,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                             }\n                         }\n                     }\n-                    ty::ty_tup(_) => {}\n+                    ty::TyTuple(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n                                             &format!(\"Expected struct or tuple \\\n                                                       type, found {:?}\", ty)),"}, {"sha": "096ee7ad7b30d0bdea3ec002c97616c9668fae7c", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -223,7 +223,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprField(ref sub_ex, ident) => {\n                 let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &sub_ex).sty;\n                 match *ty {\n-                    ty::ty_struct(def_id, _) => {\n+                    ty::TyStruct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in &fields {\n                             if f.name == ident.node.name {"}, {"sha": "bcf5922fb3de7fdf3e9aee265a105a5525926245", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -850,10 +850,10 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n \n     match rhs_t.sty {\n-        ty::ty_rptr(_, mt) => match mt.ty.sty {\n-            ty::ty_str => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n-            ty::ty_vec(ty, _) => match ty.sty {\n-                ty::ty_uint(ast::TyU8) => {\n+        ty::TyRef(_, mt) => match mt.ty.sty {\n+            ty::TyStr => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n+            ty::TyArray(ty, _) => match ty.sty {\n+                ty::TyUint(ast::TyU8) => {\n                     // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n                     let pat_len = val_ty(rhs).element_type().array_length();\n@@ -1092,7 +1092,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         ).collect();\n \n         match left_ty.sty {\n-            ty::ty_struct(def_id, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n+            ty::TyStruct(def_id, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n                 // The last field is technically unsized but\n                 // since we can only ever match that field behind\n                 // a reference we construct a fat ptr here.\n@@ -1116,7 +1116,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Some(vec!(Load(bcx, val)))\n     } else {\n         match left_ty.sty {\n-            ty::ty_vec(_, Some(n)) => {\n+            ty::TyArray(_, Some(n)) => {\n                 let args = extract_vec_elems(bcx, left_ty, n, 0, val);\n                 Some(args.vals)\n             }"}, {"sha": "977b2b69c4685eb9976649e592695e085309435d", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -206,10 +206,10 @@ fn dtor_active(flag: u8) -> bool {\n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n-        ty::ty_tup(ref elems) => {\n+        ty::TyTuple(ref elems) => {\n             Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n-        ty::ty_struct(def_id, substs) => {\n+        ty::TyStruct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n             let mut ftys = fields.iter().map(|field| {\n                 let fty = ty::lookup_field_type(cx.tcx(), def_id, field.id, substs);\n@@ -223,13 +223,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n-        ty::ty_closure(def_id, substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n         }\n-        ty::ty_enum(def_id, substs) => {\n+        ty::TyEnum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n             let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).get(0)\n                 .unwrap_or(&attr::ReprAny);\n@@ -400,28 +400,28 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     mut path: DiscrField) -> Option<DiscrField> {\n     match ty.sty {\n         // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n-        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !type_is_sized(tcx, ty) => {\n+        ty::TyRef(_, ty::mt { ty, .. }) | ty::TyBox(ty) if !type_is_sized(tcx, ty) => {\n             path.push(FAT_PTR_ADDR);\n             Some(path)\n         },\n \n         // Regular thin pointer: &T/&mut T/Box<T>\n-        ty::ty_rptr(..) | ty::ty_uniq(..) => Some(path),\n+        ty::TyRef(..) | ty::TyBox(..) => Some(path),\n \n         // Functions are just pointers\n-        ty::ty_bare_fn(..) => Some(path),\n+        ty::TyBareFn(..) => Some(path),\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n-        ty::ty_struct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n+        ty::TyStruct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n             let nonzero_fields = ty::lookup_struct_fields(tcx, did);\n             assert_eq!(nonzero_fields.len(), 1);\n             let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n-                ty::ty_ptr(ty::mt { ty, .. }) if !type_is_sized(tcx, ty) => {\n+                ty::TyRawPtr(ty::mt { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n                     Some(path)\n                 },\n-                ty::ty_ptr(..) | ty::ty_int(..) | ty::ty_uint(..) => {\n+                ty::TyRawPtr(..) | ty::TyInt(..) | ty::TyUint(..) => {\n                     path.push(0);\n                     Some(path)\n                 },\n@@ -431,7 +431,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n-        ty::ty_struct(def_id, substs) => {\n+        ty::TyStruct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(tcx, def_id);\n             for (j, field) in fields.iter().enumerate() {\n                 let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);\n@@ -445,7 +445,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the upvars of this struct is non-zero\n         // Let's recurse and find out!\n-        ty::ty_closure(def_id, substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(tcx);\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n@@ -460,7 +460,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         },\n \n         // Can we use one of the fields in this tuple?\n-        ty::ty_tup(ref tys) => {\n+        ty::TyTuple(ref tys) => {\n             for (j, &ty) in tys.iter().enumerate() {\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n                     fpath.push(j);\n@@ -472,7 +472,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Is this a fixed-size array of something non-zero\n         // with at least one element?\n-        ty::ty_vec(ety, Some(d)) if d > 0 => {\n+        ty::TyArray(ety, Some(d)) if d > 0 => {\n             if let Some(mut vpath) = find_discr_field_candidate(tcx, ety, path) {\n                 vpath.push(0);\n                 Some(vpath)"}, {"sha": "d4ce17cc7b54f5d14a6ad5a057dbcbde84c5f052", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -128,8 +128,8 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n \n     let function_type;\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n-        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::ty_closure(closure_did, substs) => {\n+        ty::TyBareFn(_, ref f) => (&f.sig, f.abi, None),\n+        ty::TyClosure(closure_did, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n@@ -146,23 +146,23 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_type.sty {\n-        ty::ty_closure(..) => {\n+        ty::TyClosure(..) => {\n             assert!(abi == abi::RustCall);\n \n             match fn_sig.inputs[0].sty {\n-                ty::ty_tup(ref inputs) => {\n+                ty::TyTuple(ref inputs) => {\n                     let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n                     full_inputs.push_all(inputs);\n                     full_inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n-        ty::ty_bare_fn(..) if abi == abi::RustCall => {\n+        ty::TyBareFn(..) if abi == abi::RustCall => {\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n             match fn_sig.inputs[1].sty {\n-                ty::ty_tup(ref t_in) => {\n+                ty::TyTuple(ref t_in) => {\n                     inputs.push_all(&t_in[..]);\n                     inputs\n                 }\n@@ -198,7 +198,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             match ret_ty.sty {\n                 // `Box` pointer return values never alias because ownership\n                 // is transferred\n-                ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n+                ty::TyBox(it) if common::type_is_sized(ccx.tcx(), it) => {\n                     attrs.ret(llvm::Attribute::NoAlias);\n                 }\n                 _ => {}\n@@ -207,15 +207,15 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // We can also mark the return value as `dereferenceable` in certain cases\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n-                ty::ty_rptr(_, ty::mt { ty: inner, .. })\n-                | ty::ty_uniq(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n+                ty::TyRef(_, ty::mt { ty: inner, .. })\n+                | ty::TyBox(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n                     let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n                     attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n                 }\n                 _ => {}\n             }\n \n-            if let ty::ty_bool = ret_ty.sty {\n+            if let ty::TyBool = ret_ty.sty {\n                 attrs.ret(llvm::Attribute::ZExt);\n             }\n         }\n@@ -235,12 +235,12 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                      .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n \n-            ty::ty_bool => {\n+            ty::TyBool => {\n                 attrs.arg(idx, llvm::Attribute::ZExt);\n             }\n \n             // `Box` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(inner) => {\n+            ty::TyBox(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n \n                 attrs.arg(idx, llvm::Attribute::NoAlias)\n@@ -252,7 +252,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n             // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on\n             // memory dependencies rather than pointer equality\n-            ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n+            ty::TyRef(b, mt) if mt.mutbl == ast::MutMutable ||\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n \n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n@@ -270,15 +270,15 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n+            ty::TyRef(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n                 attrs.arg(idx, llvm::Attribute::NoCapture)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n             // & pointer parameters are also never null and we know exactly how\n             // many bytes we can dereference\n-            ty::ty_rptr(_, mt) => {\n+            ty::TyRef(_, mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n                 attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n             }"}, {"sha": "cdb036bc6a9ab86b84356b05c25ce7f0ac230b17", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -320,7 +320,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         debug_loc: DebugLoc)\n                                         -> ValueRef {\n     match t.sty {\n-        ty::ty_tup(ref tys) if tys.is_empty() => {\n+        ty::TyTuple(ref tys) if tys.is_empty() => {\n             // We don't need to do actual comparisons for nil.\n             // () == () holds but () < () does not.\n             match op {\n@@ -330,16 +330,16 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\")\n             }\n         }\n-        ty::ty_bare_fn(..) | ty::ty_bool | ty::ty_uint(_) | ty::ty_char => {\n+        ty::TyBareFn(..) | ty::TyBool | ty::TyUint(_) | ty::TyChar => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n         }\n-        ty::ty_ptr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n+        ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n         }\n-        ty::ty_int(_) => {\n+        ty::TyInt(_) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n         }\n-        ty::ty_float(_) => {\n+        ty::TyFloat(_) => {\n             FCmp(bcx, bin_op_to_fcmp_predicate(bcx.ccx(), op), lhs, rhs, debug_loc)\n         }\n         // Should never get here, because t is scalar.\n@@ -355,16 +355,16 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       debug_loc: DebugLoc)\n                                       -> ValueRef {\n     let signed = match t.sty {\n-        ty::ty_float(_) => {\n+        ty::TyFloat(_) => {\n             // The comparison operators for floating point vectors are challenging.\n             // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n             // then bitcast to a floating point vector, the result will be `-NaN`\n             // for each truth value. Because of this they are unsupported.\n             bcx.sess().bug(\"compare_simd_types: comparison operators \\\n                             not supported for floating point SIMD types\")\n         },\n-        ty::ty_uint(_) => false,\n-        ty::ty_int(_) => true,\n+        ty::TyUint(_) => false,\n+        ty::TyInt(_) => true,\n         _ => bcx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n     };\n \n@@ -416,7 +416,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n \n     let mut cx = cx;\n     match t.sty {\n-      ty::ty_struct(..) => {\n+      ty::TyStruct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n@@ -435,7 +435,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_closure(def_id, substs) => {\n+      ty::TyClosure(def_id, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let typer = common::NormalizingClosureTyper::new(cx.tcx());\n           let upvars = typer.closure_upvars(def_id, substs).unwrap();\n@@ -444,23 +444,23 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               cx = f(cx, llupvar, upvar.ty);\n           }\n       }\n-      ty::ty_vec(_, Some(n)) => {\n+      ty::TyArray(_, Some(n)) => {\n         let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n-      ty::ty_vec(_, None) | ty::ty_str => {\n+      ty::TyArray(_, None) | ty::TyStr => {\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n       }\n-      ty::ty_tup(ref args) => {\n+      ty::TyTuple(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {\n               let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n-      ty::ty_enum(tid, substs) => {\n+      ty::TyEnum(tid, substs) => {\n           let fcx = cx.fcx;\n           let ccx = fcx.ccx;\n \n@@ -574,7 +574,7 @@ fn cast_shift_rhs<F, G>(op: ast::BinOp_,\n pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                               val_t: Ty<'tcx>) -> (Type, u64) {\n     match val_t.sty {\n-        ty::ty_int(t) => {\n+        ty::TyInt(t) => {\n             let llty = Type::int_from_ty(cx.ccx(), t);\n             let min = match t {\n                 ast::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n@@ -608,15 +608,15 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     let debug_loc = call_info.debug_loc();\n \n     let (is_zero, is_signed) = match rhs_t.sty {\n-        ty::ty_int(t) => {\n+        ty::TyInt(t) => {\n             let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), true)\n         }\n-        ty::ty_uint(t) => {\n+        ty::TyUint(t) => {\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n-        ty::ty_struct(_, _) if type_is_simd(cx.tcx(), rhs_t) => {\n+        ty::TyStruct(_, _) if type_is_simd(cx.tcx(), rhs_t) => {\n             let mut res = C_bool(cx.ccx(), false);\n             for i in 0 .. simd_size(cx.tcx(), rhs_t) {\n                 res = Or(cx, res,\n@@ -665,7 +665,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match t.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => {\n+        ty::TyBareFn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n                     get_extern_rust_fn(ccx, t, &name[..], did)\n@@ -1317,7 +1317,7 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n \n         // This is the last argument. Tuple it.\n         match arg_ty.sty {\n-            ty::ty_tup(ref tupled_arg_tys) => {\n+            ty::TyTuple(ref tupled_arg_tys) => {\n                 let tuple_args_scope_id = cleanup::CustomScope(arg_scope);\n                 let tuple =\n                     unpack_datum!(bcx,\n@@ -1660,7 +1660,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => {\n+        ty::TyBareFn(_, ref bft) => {\n             ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n         }\n         _ => ccx.sess().bug(\n@@ -1738,7 +1738,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => {\n+        ty::TyBareFn(_, ref bft) => {\n             ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n         }\n         _ => ccx.sess().bug(\n@@ -2108,7 +2108,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_id: ast::NodeId,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n-    if let ty::ty_bare_fn(_, ref f) = node_type.sty {\n+    if let ty::TyBareFn(_, ref f) = node_type.sty {\n         if f.abi != Rust && f.abi != RustCall {\n             ccx.sess().span_bug(sp, &format!(\"only the `{}` or `{}` calling conventions are valid \\\n                                               for this function; `{}` was specified\",\n@@ -2464,7 +2464,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n \n     let sym = exported_name(ccx, id, mty, &attrs);\n \n-    if let ty::ty_bare_fn(_, ref f) = mty.sty {\n+    if let ty::TyBareFn(_, ref f) = mty.sty {\n         let llfn = if f.abi == Rust || f.abi == RustCall {\n             register_fn(ccx, span, sym, id, mty)\n         } else {"}, {"sha": "0aeb4046dc64ce9aafdfce1de0d6665059b07fb4", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -107,7 +107,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                 -> Callee<'blk, 'tcx> {\n         let DatumBlock { bcx, datum, .. } = expr::trans(bcx, expr);\n         match datum.ty.sty {\n-            ty::ty_bare_fn(..) => {\n+            ty::TyBareFn(..) => {\n                 let llval = datum.to_llscalarish(bcx);\n                 return Callee {\n                     bcx: bcx,\n@@ -156,7 +156,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n-                ty::ty_bare_fn(_, ref f) => f.abi == synabi::RustIntrinsic,\n+                ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n                 let substs = common::node_id_substs(bcx.ccx(),\n@@ -299,7 +299,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n     let (opt_def_id, sig) =\n         match bare_fn_ty.sty {\n-            ty::ty_bare_fn(opt_def_id,\n+            ty::TyBareFn(opt_def_id,\n                            &ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                            abi: synabi::Rust,\n                                            ref sig }) => {\n@@ -621,7 +621,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n         Some(method) => match method.origin {\n             ty::MethodTraitObject(_) => match method.ty.sty {\n-                ty::ty_bare_fn(_, ref fty) => {\n+                ty::TyBareFn(_, ref fty) => {\n                     ty::mk_bare_fn(bcx.tcx(), None, meth::opaque_method_ty(bcx.tcx(), fty))\n                 }\n                 _ => method.ty\n@@ -699,7 +699,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n+        ty::TyBareFn(_, ref f) => {\n             let output = ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output());\n             (f.abi, output)\n         }\n@@ -943,7 +943,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     let tuple_type = common::node_id_type(bcx, tuple_expr.id);\n \n     match tuple_type.sty {\n-        ty::ty_tup(ref field_types) => {\n+        ty::TyTuple(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n                                             expr::trans(bcx, &**tuple_expr));\n             let tuple_lvalue_datum =\n@@ -1002,7 +1002,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n     // Now untuple the rest of the arguments.\n     let tuple_type = arg_tys[1];\n     match tuple_type.sty {\n-        ty::ty_tup(ref field_types) => {\n+        ty::TyTuple(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n                 let arg_datum =\n                     unpack_datum!(bcx, expr::trans(bcx, arg_exprs[i + 1]));"}, {"sha": "27080966fcb45377c6435bfd96cdd3f84a79315b", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -143,7 +143,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_closure(_, substs) => &substs.types,\n+        ty::TyClosure(_, substs) => &substs.types,\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {\n@@ -421,7 +421,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // the remaining arguments will be packed up in a tuple.\n     let input_tys = match sig.inputs[1].sty {\n-        ty::ty_tup(ref tys) => &**tys,\n+        ty::TyTuple(ref tys) => &**tys,\n         _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n                                       closure_def_id={}\",\n                                      closure_def_id.repr(tcx)))"}, {"sha": "7fe879dad0a721f8dc78870defb13d8b56d6d5f2", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -125,9 +125,9 @@ pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::ty_ptr(ty::mt{ty, ..}) |\n-        ty::ty_rptr(_, ty::mt{ty, ..}) |\n-        ty::ty_uniq(ty) => {\n+        ty::TyRawPtr(ty::mt{ty, ..}) |\n+        ty::TyRef(_, ty::mt{ty, ..}) |\n+        ty::TyBox(ty) => {\n             !type_is_sized(cx, ty)\n         }\n         _ => {\n@@ -158,10 +158,10 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n         let mut needs_unwind_cleanup = false;\n         ty::maybe_walk_ty(ty, |ty| {\n             needs_unwind_cleanup |= match ty.sty {\n-                ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n-                ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n+                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) |\n+                ty::TyFloat(_) | ty::TyTuple(_) | ty::TyRawPtr(_) => false,\n \n-                ty::ty_enum(did, substs) =>\n+                ty::TyEnum(did, substs) =>\n                     ty::enum_variants(tcx, did).iter().any(|v|\n                         v.args.iter().any(|&aty| {\n                             let t = aty.subst(tcx, substs);\n@@ -218,7 +218,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::ty_struct(def_id, substs) => {\n+        ty::TyStruct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(ccx.tcx(), def_id);\n             fields.len() == 1 && {\n                 let ty = ty::lookup_field_type(ccx.tcx(), def_id, fields[0].id, substs);\n@@ -246,8 +246,8 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         return false;\n     }\n     match ty.sty {\n-        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) | ty::ty_vec(_, Some(_)) |\n-        ty::ty_closure(..) => {\n+        ty::TyStruct(..) | ty::TyEnum(..) | ty::TyTuple(..) | ty::TyArray(_, Some(_)) |\n+        ty::TyClosure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }"}, {"sha": "50dbeafa7e1735b53608898061b88f70d38b13d1", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -59,10 +59,10 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n             let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match lit_int_ty.sty {\n-                ty::ty_int(t) => {\n+                ty::TyInt(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n                 }\n-                ty::ty_uint(t) => {\n+                ty::TyUint(t) => {\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n@@ -77,7 +77,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match lit_float_ty.sty {\n-                ty::ty_float(t) => {\n+                ty::TyFloat(t) => {\n                     C_floating(&fs, Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n@@ -392,15 +392,15 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n         if let ast::ExprLit(_) = inner_e.node { return; }\n \n         let result = match t.sty {\n-            ty::ty_int(int_type) => {\n+            ty::TyInt(int_type) => {\n                 let input = match const_to_opt_int(te) {\n                     Some(v) => v,\n                     None => return,\n                 };\n                 const_int_checked_neg(\n                     input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n             }\n-            ty::ty_uint(uint_type) => {\n+            ty::TyUint(uint_type) => {\n                 let input = match const_to_opt_uint(te) {\n                     Some(v) => v,\n                     None => return,\n@@ -423,7 +423,7 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n     let b = if let ast::ExprBinary(b, _, _) = e.node { b } else { return };\n \n     let result = match t.sty {\n-        ty::ty_int(int_type) => {\n+        ty::TyInt(int_type) => {\n             let (lhs, rhs) = match (const_to_opt_int(te1),\n                                     const_to_opt_int(te2)) {\n                 (Some(v1), Some(v2)) => (v1, v2),\n@@ -442,7 +442,7 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n                 _ => return,\n             }\n         }\n-        ty::ty_uint(uint_type) => {\n+        ty::TyUint(uint_type) => {\n             let (lhs, rhs) = match (const_to_opt_uint(te1),\n                                     const_to_opt_uint(te2)) {\n                 (Some(v1), Some(v2)) => (v1, v2),\n@@ -609,13 +609,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                           \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match bt.sty {\n-                  ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_vec(_, None) | ty::ty_str => {\n+                  ty::TyArray(_, Some(u)) => (bv, C_uint(cx, u)),\n+                  ty::TyArray(_, None) | ty::TyStr => {\n                       let e1 = const_get_elt(cx, bv, &[0]);\n                       (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n                   }\n-                  ty::ty_rptr(_, mt) => match mt.ty.sty {\n-                      ty::ty_vec(_, Some(u)) => {\n+                  ty::TyRef(_, mt) => match mt.ty.sty {\n+                      ty::TyArray(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n@@ -631,8 +631,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match bt.sty {\n-                  ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n-                      ty::ty_str => {\n+                  ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => match ty.sty {\n+                      ty::TyStr => {\n                           assert!(len > 0);\n                           len - 1\n                       }\n@@ -842,7 +842,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     }\n                 }\n                 def::DefStruct(_) => {\n-                    if let ty::ty_bare_fn(..) = ety.sty {\n+                    if let ty::TyBareFn(..) = ety.sty {\n                         // Tuple struct.\n                         expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {"}, {"sha": "551ccfb6650d05c06cecb81fea316ac67b16b854", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -171,26 +171,26 @@ impl<'tcx> TypeMap<'tcx> {\n         unique_type_id.push('{');\n \n         match type_.sty {\n-            ty::ty_bool     |\n-            ty::ty_char     |\n-            ty::ty_str      |\n-            ty::ty_int(_)   |\n-            ty::ty_uint(_)  |\n-            ty::ty_float(_) => {\n+            ty::TyBool     |\n+            ty::TyChar     |\n+            ty::TyStr      |\n+            ty::TyInt(_)   |\n+            ty::TyUint(_)  |\n+            ty::TyFloat(_) => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::ty_enum(def_id, substs) => {\n+            ty::TyEnum(def_id, substs) => {\n                 unique_type_id.push_str(\"enum \");\n                 from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n             },\n-            ty::ty_struct(def_id, substs) => {\n+            ty::TyStruct(def_id, substs) => {\n                 unique_type_id.push_str(\"struct \");\n                 from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n             },\n-            ty::ty_tup(ref component_types) if component_types.is_empty() => {\n+            ty::TyTuple(ref component_types) if component_types.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::ty_tup(ref component_types) => {\n+            ty::TyTuple(ref component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n                 for &component_type in component_types {\n                     let component_type_id =\n@@ -200,13 +200,13 @@ impl<'tcx> TypeMap<'tcx> {\n                     unique_type_id.push_str(&component_type_id[..]);\n                 }\n             },\n-            ty::ty_uniq(inner_type) => {\n+            ty::TyBox(inner_type) => {\n                 unique_type_id.push_str(\"box \");\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);\n             },\n-            ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+            ty::TyRawPtr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n@@ -216,7 +216,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);\n             },\n-            ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+            ty::TyRef(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n@@ -226,7 +226,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);\n             },\n-            ty::ty_vec(inner_type, optional_length) => {\n+            ty::TyArray(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n                         unique_type_id.push_str(&format!(\"[{}]\", len));\n@@ -240,7 +240,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);\n             },\n-            ty::ty_trait(ref trait_data) => {\n+            ty::TyTrait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n \n                 let principal =\n@@ -253,7 +253,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        principal.substs,\n                                        &mut unique_type_id);\n             },\n-            ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            ty::TyBareFn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n                 if unsafety == ast::Unsafety::Unsafe {\n                     unique_type_id.push_str(\"unsafe \");\n                 }\n@@ -289,7 +289,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::ty_closure(def_id, substs) => {\n+            ty::TyClosure(def_id, substs) => {\n                 let typer = NormalizingClosureTyper::new(cx.tcx());\n                 let closure_ty = typer.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -635,7 +635,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // return type\n     signature_metadata.push(match signature.output {\n         ty::FnConverging(ret_ty) => match ret_ty.sty {\n-            ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n+            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n         },\n         ty::FnDiverging => diverging_type_metadata(cx)\n@@ -674,7 +674,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::ty_trait(ref data) => data.principal_def_id(),\n+        ty::TyTrait(ref data) => data.principal_def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n@@ -742,39 +742,39 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let sty = &t.sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n-        ty::ty_bool     |\n-        ty::ty_char     |\n-        ty::ty_int(_)   |\n-        ty::ty_uint(_)  |\n-        ty::ty_float(_) => {\n+        ty::TyBool     |\n+        ty::TyChar     |\n+        ty::TyInt(_)   |\n+        ty::TyUint(_)  |\n+        ty::TyFloat(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::ty_tup(ref elements) if elements.is_empty() => {\n+        ty::TyTuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::ty_enum(def_id, _) => {\n+        ty::TyEnum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n         }\n-        ty::ty_vec(typ, len) => {\n+        ty::TyArray(typ, len) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, len.map(|x| x as u64), usage_site_span)\n         }\n-        ty::ty_str => {\n+        ty::TyStr => {\n             fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n         }\n-        ty::ty_trait(..) => {\n+        ty::TyTrait(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n         }\n-        ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+        ty::TyBox(ty) | ty::TyRawPtr(ty::mt{ty, ..}) | ty::TyRef(_, ty::mt{ty, ..}) => {\n             match ty.sty {\n-                ty::ty_vec(typ, None) => {\n+                ty::TyArray(typ, None) => {\n                     vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n                 }\n-                ty::ty_str => {\n+                ty::TyStr => {\n                     vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n                 }\n-                ty::ty_trait(..) => {\n+                ty::TyTrait(..) => {\n                     MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                         false)\n@@ -794,23 +794,23 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::ty_bare_fn(_, ref barefnty) => {\n+        ty::TyBareFn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n-        ty::ty_closure(def_id, substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let sig = typer.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n-        ty::ty_struct(def_id, substs) => {\n+        ty::TyStruct(def_id, substs) => {\n             prepare_struct_metadata(cx,\n                                     t,\n                                     def_id,\n                                     substs,\n                                     unique_type_id,\n                                     usage_site_span).finalize(cx)\n         }\n-        ty::ty_tup(ref elements) => {\n+        ty::TyTuple(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &elements[..],\n@@ -936,25 +936,25 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n-        ty::ty_tup(ref elements) if elements.is_empty() =>\n+        ty::TyTuple(ref elements) if elements.is_empty() =>\n             (\"()\".to_string(), DW_ATE_unsigned),\n-        ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n-        ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n-        ty::ty_int(int_ty) => match int_ty {\n+        ty::TyBool => (\"bool\".to_string(), DW_ATE_boolean),\n+        ty::TyChar => (\"char\".to_string(), DW_ATE_unsigned_char),\n+        ty::TyInt(int_ty) => match int_ty {\n             ast::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n             ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n             ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n             ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n             ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n         },\n-        ty::ty_uint(uint_ty) => match uint_ty {\n+        ty::TyUint(uint_ty) => match uint_ty {\n             ast::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n             ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n             ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n             ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n             ast::TyU64 => (\"u64\".to_string(), DW_ATE_unsigned)\n         },\n-        ty::ty_float(float_ty) => match float_ty {\n+        ty::TyFloat(float_ty) => match float_ty {\n             ast::TyF32 => (\"f32\".to_string(), DW_ATE_float),\n             ast::TyF64 => (\"f64\".to_string(), DW_ATE_float),\n         },\n@@ -1179,7 +1179,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n \n     // The `Ty` values returned by `ty::struct_fields` can still contain\n-    // `ty_projection` variants, so normalize those away.\n+    // `TyProjection` variants, so normalize those away.\n     for field in &mut fields {\n         field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n     }"}, {"sha": "153170913ed7e48ce4e893295fa3f5129b5b19ed", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -40,27 +40,27 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                           qualified: bool,\n                                           output: &mut String) {\n     match t.sty {\n-        ty::ty_bool              => output.push_str(\"bool\"),\n-        ty::ty_char              => output.push_str(\"char\"),\n-        ty::ty_str               => output.push_str(\"str\"),\n-        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n-        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n-        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n-        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n-        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n-        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n-        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n-        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n-        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n-        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n-        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n-        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n-        ty::ty_struct(def_id, substs) |\n-        ty::ty_enum(def_id, substs) => {\n+        ty::TyBool              => output.push_str(\"bool\"),\n+        ty::TyChar              => output.push_str(\"char\"),\n+        ty::TyStr               => output.push_str(\"str\"),\n+        ty::TyInt(ast::TyIs)     => output.push_str(\"isize\"),\n+        ty::TyInt(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::TyUs)    => output.push_str(\"usize\"),\n+        ty::TyUint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::TyStruct(def_id, substs) |\n+        ty::TyEnum(def_id, substs) => {\n             push_item_name(cx, def_id, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n-        ty::ty_tup(ref component_types) => {\n+        ty::TyTuple(ref component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n@@ -72,12 +72,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n             output.push(')');\n         },\n-        ty::ty_uniq(inner_type) => {\n+        ty::TyBox(inner_type) => {\n             output.push_str(\"Box<\");\n             push_debuginfo_type_name(cx, inner_type, true, output);\n             output.push('>');\n         },\n-        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+        ty::TyRawPtr(ty::mt { ty: inner_type, mutbl } ) => {\n             output.push('*');\n             match mutbl {\n                 ast::MutImmutable => output.push_str(\"const \"),\n@@ -86,15 +86,15 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n-        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+        ty::TyRef(_, ty::mt { ty: inner_type, mutbl }) => {\n             output.push('&');\n             if mutbl == ast::MutMutable {\n                 output.push_str(\"mut \");\n             }\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n-        ty::ty_vec(inner_type, optional_length) => {\n+        ty::TyArray(inner_type, optional_length) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n \n@@ -107,12 +107,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(']');\n         },\n-        ty::ty_trait(ref trait_data) => {\n+        ty::TyTrait(ref trait_data) => {\n             let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n             push_item_name(cx, principal.def_id, false, output);\n             push_type_params(cx, principal.substs, output);\n         },\n-        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+        ty::TyBareFn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }\n@@ -156,13 +156,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         },\n-        ty::ty_closure(..) => {\n+        ty::TyClosure(..) => {\n             output.push_str(\"closure\");\n         }\n-        ty::ty_err |\n-        ty::ty_infer(_) |\n-        ty::ty_projection(..) |\n-        ty::ty_param(_) => {\n+        ty::TyError |\n+        ty::TyInfer(_) |\n+        ty::TyProjection(..) |\n+        ty::TyParam(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n         }"}, {"sha": "935925e5a8fc6f3fd12c1bbf47ab6fb552072bbb", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -114,10 +114,10 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n \n     let function_type; // placeholder so that the memory ownership works out ok\n     let (sig, abi, env) = match fn_type.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n+        ty::TyBareFn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::ty_closure(closure_did, substs) => {\n+        ty::TyClosure(closure_did, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);"}, {"sha": "9fda58db5d27eddc702cc65cc6502ff22ab87ada", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -313,14 +313,14 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 -> ValueRef {\n     let (source, target) = ty::struct_lockstep_tails(ccx.tcx(), source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::ty_vec(_, Some(len)), &ty::ty_vec(_, None)) => C_uint(ccx, len),\n-        (&ty::ty_trait(_), &ty::ty_trait(_)) => {\n+        (&ty::TyArray(_, Some(len)), &ty::TyArray(_, None)) => C_uint(ccx, len),\n+        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::ty_trait(box ty::TyTrait { ref principal, .. })) => {\n+        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n             // Note that we preserve binding levels here:\n             let substs = principal.0.substs.with_self_ty(source).erase_regions();\n             let substs = ccx.tcx().mk_substs(substs);\n@@ -369,7 +369,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // a different region or mutability, but we don't care here).\n                 match datum.ty.sty {\n                     // Don't skip a conversion from Box<T> to &T, etc.\n-                    ty::ty_rptr(..) => {\n+                    ty::TyRef(..) => {\n                         let method_call = MethodCall::autoderef(expr.id, 0);\n                         if bcx.tcx().method_map.borrow().contains_key(&method_call) {\n                             // Don't skip an overloaded deref.\n@@ -442,10 +442,10 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            target.to_string(bcx.ccx()));\n \n     match (&source.ty.sty, &target.ty.sty) {\n-        (&ty::ty_uniq(a), &ty::ty_uniq(b)) |\n-        (&ty::ty_rptr(_, ty::mt { ty: a, .. }), &ty::ty_rptr(_, ty::mt { ty: b, .. })) |\n-        (&ty::ty_rptr(_, ty::mt { ty: a, .. }), &ty::ty_ptr(ty::mt { ty: b, .. })) |\n-        (&ty::ty_ptr(ty::mt { ty: a, .. }), &ty::ty_ptr(ty::mt { ty: b, .. })) => {\n+        (&ty::TyBox(a), &ty::TyBox(b)) |\n+        (&ty::TyRef(_, ty::mt { ty: a, .. }), &ty::TyRef(_, ty::mt { ty: b, .. })) |\n+        (&ty::TyRef(_, ty::mt { ty: a, .. }), &ty::TyRawPtr(ty::mt { ty: b, .. })) |\n+        (&ty::TyRawPtr(ty::mt { ty: a, .. }), &ty::TyRawPtr(ty::mt { ty: b, .. })) => {\n             let (inner_source, inner_target) = (a, b);\n \n             let (base, old_info) = if !type_is_sized(bcx.tcx(), inner_source) {\n@@ -479,8 +479,8 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         // This can be extended to enums and tuples in the future.\n-        // (&ty::ty_enum(def_id_a, _), &ty::ty_enum(def_id_b, _)) |\n-        (&ty::ty_struct(def_id_a, _), &ty::ty_struct(def_id_b, _)) => {\n+        // (&ty::TyEnum(def_id_a, _), &ty::TyEnum(def_id_b, _)) |\n+        (&ty::TyStruct(def_id_a, _), &ty::TyStruct(def_id_b, _)) => {\n             assert_eq!(def_id_a, def_id_b);\n \n             // The target is already by-ref because it's to be written to.\n@@ -657,7 +657,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, &**contents);\n             match box_ty.sty {\n-                ty::ty_uniq(..) => {\n+                ty::TyBox(..) => {\n                     trans_uniq_expr(bcx, expr, box_ty, &**contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n@@ -1245,7 +1245,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n-                ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n+                ty::TyStruct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }\n@@ -1339,17 +1339,17 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n     F: FnOnce(ty::Disr, &[ty::field<'tcx>]) -> R,\n {\n     match ty.sty {\n-        ty::ty_struct(did, substs) => {\n+        ty::TyStruct(did, substs) => {\n             let fields = struct_fields(tcx, did, substs);\n             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n             op(0, &fields[..])\n         }\n \n-        ty::ty_tup(ref v) => {\n+        ty::TyTuple(ref v) => {\n             op(0, &tup_fields(&v[..]))\n         }\n \n-        ty::ty_enum(_, substs) => {\n+        ty::TyEnum(_, substs) => {\n             // We want the *variant* ID here, not the enum ID.\n             match node_id_opt {\n                 None => {\n@@ -2253,7 +2253,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let r = match datum.ty.sty {\n-        ty::ty_uniq(content_ty) => {\n+        ty::TyBox(content_ty) => {\n             // Make sure we have an lvalue datum here to get the\n             // proper cleanups scheduled\n             let datum = unpack_datum!(\n@@ -2274,8 +2274,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n-        ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n+        ty::TyRawPtr(ty::mt { ty: content_ty, .. }) |\n+        ty::TyRef(_, ty::mt { ty: content_ty, .. }) => {\n             if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = datum.to_llscalarish(bcx);\n \n@@ -2347,61 +2347,61 @@ impl OverflowOpViaIntrinsic {\n     fn to_intrinsic_name(&self, tcx: &ty::ctxt, ty: Ty) -> &'static str {\n         use syntax::ast::IntTy::*;\n         use syntax::ast::UintTy::*;\n-        use middle::ty::{ty_int, ty_uint};\n+        use middle::ty::{TyInt, TyUint};\n \n         let new_sty = match ty.sty {\n-            ty_int(TyIs) => match &tcx.sess.target.target.target_pointer_width[..] {\n-                \"32\" => ty_int(TyI32),\n-                \"64\" => ty_int(TyI64),\n+            TyInt(TyIs) => match &tcx.sess.target.target.target_pointer_width[..] {\n+                \"32\" => TyInt(TyI32),\n+                \"64\" => TyInt(TyI64),\n                 _ => panic!(\"unsupported target word size\")\n             },\n-            ty_uint(TyUs) => match &tcx.sess.target.target.target_pointer_width[..] {\n-                \"32\" => ty_uint(TyU32),\n-                \"64\" => ty_uint(TyU64),\n+            TyUint(TyUs) => match &tcx.sess.target.target.target_pointer_width[..] {\n+                \"32\" => TyUint(TyU32),\n+                \"64\" => TyUint(TyU64),\n                 _ => panic!(\"unsupported target word size\")\n             },\n-            ref t @ ty_uint(_) | ref t @ ty_int(_) => t.clone(),\n+            ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n             _ => panic!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n                         *self)\n         };\n \n         match *self {\n             OverflowOpViaIntrinsic::Add => match new_sty {\n-                ty_int(TyI8) => \"llvm.sadd.with.overflow.i8\",\n-                ty_int(TyI16) => \"llvm.sadd.with.overflow.i16\",\n-                ty_int(TyI32) => \"llvm.sadd.with.overflow.i32\",\n-                ty_int(TyI64) => \"llvm.sadd.with.overflow.i64\",\n+                TyInt(TyI8) => \"llvm.sadd.with.overflow.i8\",\n+                TyInt(TyI16) => \"llvm.sadd.with.overflow.i16\",\n+                TyInt(TyI32) => \"llvm.sadd.with.overflow.i32\",\n+                TyInt(TyI64) => \"llvm.sadd.with.overflow.i64\",\n \n-                ty_uint(TyU8) => \"llvm.uadd.with.overflow.i8\",\n-                ty_uint(TyU16) => \"llvm.uadd.with.overflow.i16\",\n-                ty_uint(TyU32) => \"llvm.uadd.with.overflow.i32\",\n-                ty_uint(TyU64) => \"llvm.uadd.with.overflow.i64\",\n+                TyUint(TyU8) => \"llvm.uadd.with.overflow.i8\",\n+                TyUint(TyU16) => \"llvm.uadd.with.overflow.i16\",\n+                TyUint(TyU32) => \"llvm.uadd.with.overflow.i32\",\n+                TyUint(TyU64) => \"llvm.uadd.with.overflow.i64\",\n \n                 _ => unreachable!(),\n             },\n             OverflowOpViaIntrinsic::Sub => match new_sty {\n-                ty_int(TyI8) => \"llvm.ssub.with.overflow.i8\",\n-                ty_int(TyI16) => \"llvm.ssub.with.overflow.i16\",\n-                ty_int(TyI32) => \"llvm.ssub.with.overflow.i32\",\n-                ty_int(TyI64) => \"llvm.ssub.with.overflow.i64\",\n+                TyInt(TyI8) => \"llvm.ssub.with.overflow.i8\",\n+                TyInt(TyI16) => \"llvm.ssub.with.overflow.i16\",\n+                TyInt(TyI32) => \"llvm.ssub.with.overflow.i32\",\n+                TyInt(TyI64) => \"llvm.ssub.with.overflow.i64\",\n \n-                ty_uint(TyU8) => \"llvm.usub.with.overflow.i8\",\n-                ty_uint(TyU16) => \"llvm.usub.with.overflow.i16\",\n-                ty_uint(TyU32) => \"llvm.usub.with.overflow.i32\",\n-                ty_uint(TyU64) => \"llvm.usub.with.overflow.i64\",\n+                TyUint(TyU8) => \"llvm.usub.with.overflow.i8\",\n+                TyUint(TyU16) => \"llvm.usub.with.overflow.i16\",\n+                TyUint(TyU32) => \"llvm.usub.with.overflow.i32\",\n+                TyUint(TyU64) => \"llvm.usub.with.overflow.i64\",\n \n                 _ => unreachable!(),\n             },\n             OverflowOpViaIntrinsic::Mul => match new_sty {\n-                ty_int(TyI8) => \"llvm.smul.with.overflow.i8\",\n-                ty_int(TyI16) => \"llvm.smul.with.overflow.i16\",\n-                ty_int(TyI32) => \"llvm.smul.with.overflow.i32\",\n-                ty_int(TyI64) => \"llvm.smul.with.overflow.i64\",\n-\n-                ty_uint(TyU8) => \"llvm.umul.with.overflow.i8\",\n-                ty_uint(TyU16) => \"llvm.umul.with.overflow.i16\",\n-                ty_uint(TyU32) => \"llvm.umul.with.overflow.i32\",\n-                ty_uint(TyU64) => \"llvm.umul.with.overflow.i64\",\n+                TyInt(TyI8) => \"llvm.smul.with.overflow.i8\",\n+                TyInt(TyI16) => \"llvm.smul.with.overflow.i16\",\n+                TyInt(TyI32) => \"llvm.smul.with.overflow.i32\",\n+                TyInt(TyI64) => \"llvm.smul.with.overflow.i64\",\n+\n+                TyUint(TyU8) => \"llvm.umul.with.overflow.i8\",\n+                TyUint(TyU16) => \"llvm.umul.with.overflow.i16\",\n+                TyUint(TyU32) => \"llvm.umul.with.overflow.i32\",\n+                TyUint(TyU64) => \"llvm.umul.with.overflow.i64\",\n \n                 _ => unreachable!(),\n             },"}, {"sha": "9ad6df5a6aba12e65ab9cba01c0bdba21b399673", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -129,7 +129,7 @@ pub fn register_static(ccx: &CrateContext,\n                 }\n             };\n             let llty2 = match ty.sty {\n-                ty::ty_ptr(ref mt) => type_of::type_of(ccx, mt.ty),\n+                ty::TyRawPtr(ref mt) => type_of::type_of(ccx, mt.ty),\n                 _ => {\n                     ccx.sess().span_fatal(foreign_item.span,\n                                           \"must have type `*T` or `*mut T`\");\n@@ -243,7 +243,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n+        ty::TyBareFn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n@@ -474,7 +474,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                     match ty.sty {\n-                        ty::ty_bare_fn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n+                        ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n                         _ => ccx.tcx().sess.span_bug(foreign_item.span,\n                                                      \"foreign fn's sty isn't a bare_fn_ty?\")\n                     }\n@@ -526,7 +526,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tys = foreign_types_for_fn_ty(ccx, t);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let cconv = match t.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => {\n+        ty::TyBareFn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n@@ -550,7 +550,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let cconv = match t.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => {\n+        ty::TyBareFn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n@@ -606,7 +606,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n-            ty::ty_bare_fn(_, ref f) => {\n+            ty::TyBareFn(_, ref f) => {\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n@@ -926,7 +926,7 @@ fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => &fn_ty.sig,\n+        ty::TyBareFn(_, ref fn_ty) => &fn_ty.sig,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);"}, {"sha": "da1409a8f3db53749e16c04e2be383653a4a17b8", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -114,7 +114,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return tcx.types.i8;\n     }\n     match t.sty {\n-        ty::ty_uniq(typ) if !type_needs_drop(tcx, typ)\n+        ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n             // `Box<ZeroSizeType>` does not allocate.\n@@ -398,7 +398,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n         return (size, align);\n     }\n     match t.sty {\n-        ty::ty_struct(id, substs) => {\n+        ty::TyStruct(id, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n@@ -427,15 +427,15 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n                                unsized_align);\n             (size, align)\n         }\n-        ty::ty_trait(..) => {\n+        ty::TyTrait(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n             let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n             let size_ptr = GEPi(bcx, info, &[1]);\n             let align_ptr = GEPi(bcx, info, &[2]);\n             (Load(bcx, size_ptr), Load(bcx, align_ptr))\n         }\n-        ty::ty_vec(_, None) | ty::ty_str => {\n+        ty::TyArray(_, None) | ty::TyStr => {\n             let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n@@ -466,10 +466,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n     let dropped_pattern = C_integral(inttype, adt::dtor_done_usize(bcx.fcx.ccx) as u64, false);\n \n     match t.sty {\n-        ty::ty_uniq(content_ty) => {\n-            // Support for ty_uniq is built-in and its drop glue is\n+        ty::TyBox(content_ty) => {\n+            // Support for TyBox is built-in and its drop glue is\n             // special. It may move to library and have Drop impl. As\n-            // a safe-guard, assert ty_uniq not used with TyContents.\n+            // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n@@ -505,7 +505,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 })\n             }\n         }\n-        ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n+        ty::TyStruct(did, substs) | ty::TyEnum(did, substs) => {\n             let tcx = bcx.tcx();\n             match (ty::ty_dtor(tcx, did), skip_dtor) {\n                 (ty::TraitDtor(dtor, true), false) => {\n@@ -534,7 +534,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 }\n             }\n         }\n-        ty::ty_trait(..) => {\n+        ty::TyTrait(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any."}, {"sha": "419ab1bb05d6e143ddf9066166e0d3c5403c0793", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -163,7 +163,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_intrinsic_call\");\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n+        ty::TyBareFn(_, ref f) => {\n             ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n         }\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n@@ -755,7 +755,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"discriminant_value\") => {\n             let val_ty = substs.types.get(FnSpace, 0);\n             match val_ty.sty {\n-                ty::ty_enum(..) => {\n+                ty::TyEnum(..) => {\n                     let repr = adt::represent_type(ccx, *val_ty);\n                     adt::trans_get_discr(bcx, &*repr, llargs[0], Some(llret_ty))\n                 }"}, {"sha": "0dc1cca85fb2c87606698558052c99ba41c6a6d2", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -493,7 +493,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n+        ty::TyBareFn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n             let fake_sig =\n                 ty::Binder(ty::FnSig {\n                     inputs: f.sig.0.inputs[1..].to_vec(),\n@@ -563,7 +563,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let object_trait_ref =\n         match object_ty.sty {\n-            ty::ty_trait(ref data) => {\n+            ty::TyTrait(ref data) => {\n                 data.principal_trait_ref_with_self_ty(tcx, object_ty)\n             }\n             _ => {\n@@ -624,7 +624,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             RustCall => {\n                 // unpack the tuple to extract the input type arguments:\n                 match sig.inputs[1].sty {\n-                    ty::ty_tup(ref tys) => &**tys,\n+                    ty::TyTuple(ref tys) => &**tys,\n                     _ => {\n                         bcx.sess().bug(\n                             &format!(\"rust-call expects a tuple not {}\","}, {"sha": "18c123cec28c2170ff1826fbd860f74dec66f59c", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -310,15 +310,15 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     match vec_ty.sty {\n-        ty::ty_vec(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n-        ty::ty_vec(_, None) | ty::ty_str => {\n+        ty::TyArray(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n+        ty::TyArray(_, None) | ty::TyStr => {\n             let base = Load(bcx, expr::get_dataptr(bcx, llval));\n             let len = Load(bcx, expr::get_len(bcx, llval));\n             (base, len)\n         }\n \n         // Only used for pattern matching.\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+        ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => {\n             let inner = if type_is_sized(bcx.tcx(), ty) {\n                 Load(bcx, llval)\n             } else {"}, {"sha": "0356bade22da65a43d9a035c0ce4116eed9517c1", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -79,7 +79,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     match inputs[inputs.len() - 1].sty {\n-        ty::ty_tup(ref tupled_arguments) => {\n+        ty::TyTuple(ref tupled_arguments) => {\n             debug!(\"untuple_arguments_if_necessary(): untupling arguments\");\n             for &tupled_argument in tupled_arguments {\n                 result.push(tupled_argument);\n@@ -147,7 +147,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>) -> Type {\n     match fty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n+        ty::TyBareFn(_, ref f) => {\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n@@ -184,39 +184,39 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n-        ty::ty_bool => Type::bool(cx),\n-        ty::ty_char => Type::char(cx),\n-        ty::ty_int(t) => Type::int_from_ty(cx, t),\n-        ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-        ty::ty_float(t) => Type::float_from_ty(cx, t),\n+        ty::TyBool => Type::bool(cx),\n+        ty::TyChar => Type::char(cx),\n+        ty::TyInt(t) => Type::int_from_ty(cx, t),\n+        ty::TyUint(t) => Type::uint_from_ty(cx, t),\n+        ty::TyFloat(t) => Type::float_from_ty(cx, t),\n \n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n+        ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) | ty::TyRawPtr(ty::mt{ty, ..}) => {\n             if type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n                 Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n             }\n         }\n \n-        ty::ty_bare_fn(..) => Type::i8p(cx),\n+        ty::TyBareFn(..) => Type::i8p(cx),\n \n-        ty::ty_vec(ty, Some(size)) => {\n+        ty::TyArray(ty, Some(size)) => {\n             let llty = sizing_type_of(cx, ty);\n             let size = size as u64;\n             ensure_array_fits_in_address_space(cx, llty, size, t);\n             Type::array(&llty, size)\n         }\n \n-        ty::ty_tup(ref tys) if tys.is_empty() => {\n+        ty::TyTuple(ref tys) if tys.is_empty() => {\n             Type::nil(cx)\n         }\n \n-        ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_closure(..) => {\n+        ty::TyTuple(..) | ty::TyEnum(..) | ty::TyClosure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &*repr, false)\n         }\n \n-        ty::ty_struct(..) => {\n+        ty::TyStruct(..) => {\n             if ty::type_is_simd(cx.tcx(), t) {\n                 let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n                 let n = ty::simd_size(cx.tcx(), t) as u64;\n@@ -228,11 +228,11 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n+        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError(..) => {\n             cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n                                   ppaux::ty_to_string(cx.tcx(), t)))\n         }\n-        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => unreachable!()\n+        ty::TyArray(_, None) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n@@ -323,12 +323,12 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     }\n \n     let mut llty = match t.sty {\n-      ty::ty_bool => Type::bool(cx),\n-      ty::ty_char => Type::char(cx),\n-      ty::ty_int(t) => Type::int_from_ty(cx, t),\n-      ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-      ty::ty_float(t) => Type::float_from_ty(cx, t),\n-      ty::ty_enum(did, ref substs) => {\n+      ty::TyBool => Type::bool(cx),\n+      ty::TyChar => Type::char(cx),\n+      ty::TyInt(t) => Type::int_from_ty(cx, t),\n+      ty::TyUint(t) => Type::uint_from_ty(cx, t),\n+      ty::TyFloat(t) => Type::float_from_ty(cx, t),\n+      ty::TyEnum(did, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n@@ -338,7 +338,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let name = llvm_type_name(cx, did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n-      ty::ty_closure(..) => {\n+      ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n@@ -349,20 +349,20 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           adt::incomplete_type_of(cx, &*repr, \"closure\")\n       }\n \n-      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n+      ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) | ty::TyRawPtr(ty::mt{ty, ..}) => {\n           if !type_is_sized(cx.tcx(), ty) {\n-              if let ty::ty_str = ty.sty {\n+              if let ty::TyStr = ty.sty {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n                   let unsized_part = ty::struct_tail(cx.tcx(), ty);\n                   let info_ty = match unsized_part.sty {\n-                      ty::ty_str | ty::ty_vec(..) => {\n+                      ty::TyStr | ty::TyArray(..) => {\n                           Type::uint_from_ty(cx, ast::TyUs)\n                       }\n-                      ty::ty_trait(_) => Type::vtable_ptr(cx),\n+                      ty::TyTrait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\\n                                    struct_tail: {} for ty={}\",\n                                   unsized_part.repr(cx.tcx()), ty.repr(cx.tcx()))\n@@ -374,7 +374,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n       }\n \n-      ty::ty_vec(ty, Some(size)) => {\n+      ty::TyArray(ty, Some(size)) => {\n           let size = size as u64;\n           let llty = in_memory_type_of(cx, ty);\n           ensure_array_fits_in_address_space(cx, llty, size, t);\n@@ -385,18 +385,18 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       // traits have the type of u8. This is so that the data pointer inside\n       // fat pointers is of the right type (e.g. for array accesses), even\n       // when taking the address of an unsized field in a struct.\n-      ty::ty_vec(ty, None) => in_memory_type_of(cx, ty),\n-      ty::ty_str | ty::ty_trait(..) => Type::i8(cx),\n+      ty::TyArray(ty, None) => in_memory_type_of(cx, ty),\n+      ty::TyStr | ty::TyTrait(..) => Type::i8(cx),\n \n-      ty::ty_bare_fn(..) => {\n+      ty::TyBareFn(..) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n       }\n-      ty::ty_tup(ref tys) if tys.is_empty() => Type::nil(cx),\n-      ty::ty_tup(..) => {\n+      ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n+      ty::TyTuple(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &*repr)\n       }\n-      ty::ty_struct(did, ref substs) => {\n+      ty::TyStruct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n               let llet = in_memory_type_of(cx, ty::simd_type(cx.tcx(), t));\n               let n = ty::simd_size(cx.tcx(), t) as u64;\n@@ -413,10 +413,10 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n       }\n \n-      ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n-      ty::ty_projection(..) => cx.sess().bug(\"type_of with ty_projection\"),\n-      ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n-      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n+      ty::TyInfer(..) => cx.sess().bug(\"type_of with TyInfer\"),\n+      ty::TyProjection(..) => cx.sess().bug(\"type_of with TyProjection\"),\n+      ty::TyParam(..) => cx.sess().bug(\"type_of with ty_param\"),\n+      ty::TyError(..) => cx.sess().bug(\"type_of with TyError\"),\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\",\n@@ -428,7 +428,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_closure(..)\n+        ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n                 if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);"}, {"sha": "cb3d5bd9bf932e7b16309b080a632ceb14f90961", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -1040,7 +1040,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n                           bounds: ty::ExistentialBounds<'tcx>)\n                           -> Ty<'tcx> {\n     let tcx = this.tcx();\n-    let object = ty::TyTrait {\n+    let object = ty::TraitTy {\n         principal: principal,\n         bounds: bounds\n     };\n@@ -1224,8 +1224,8 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 _ => unreachable!()\n             }\n         }\n-        (&ty::ty_param(_), def::DefTyParam(..)) |\n-        (&ty::ty_param(_), def::DefSelfTy(Some(_), None)) => {\n+        (&ty::TyParam(_), def::DefTyParam(..)) |\n+        (&ty::TyParam(_), def::DefSelfTy(Some(_), None)) => {\n             // A type parameter or Self, we need to find the associated item from\n             // a bound.\n             let ty_param_node_id = ty_path_def.local_node_id();\n@@ -1471,7 +1471,7 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let mut def = *def;\n     // If any associated type segments remain, attempt to resolve them.\n     for segment in assoc_segments {\n-        if ty.sty == ty::ty_err {\n+        if ty.sty == ty::TyError {\n             break;\n         }\n         // This is pretty bad (it will fail except for T::A and Self::A).\n@@ -1529,7 +1529,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         ast::TyRptr(ref region, ref mt) => {\n             let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-            debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n+            debug!(\"TyRef r={}\", r.repr(this.tcx()));\n             let rscope1 =\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n@@ -1583,7 +1583,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                 &path.segments[..base_ty_end],\n                                                 &path.segments[base_ty_end..]);\n \n-            if path_res.depth != 0 && ty.sty != ty::ty_err {\n+            if path_res.depth != 0 && ty.sty != ty::TyError {\n                 // Write back the new resolution.\n                 tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n                     base_def: def,\n@@ -1853,8 +1853,8 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n                 ty::ByValueExplicitSelfCategory\n             } else {\n                 match explicit_type.sty {\n-                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(*r, mt.mutbl),\n-                    ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n+                    ty::TyRef(r, mt) => ty::ByReferenceExplicitSelfCategory(*r, mt.mutbl),\n+                    ty::TyBox(_) => ty::ByBoxExplicitSelfCategory,\n                     _ => ty::ByValueExplicitSelfCategory,\n                 }\n             }\n@@ -1863,8 +1863,8 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n \n     fn count_modifiers(ty: Ty) -> usize {\n         match ty.sty {\n-            ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n-            ty::ty_uniq(t) => count_modifiers(t) + 1,\n+            ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n+            ty::TyBox(t) => count_modifiers(t) + 1,\n             _ => 0,\n         }\n     }"}, {"sha": "3df93ee7dbff1618f88bcd92fdbd23b04994c768", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -58,8 +58,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             if let ast::ExprLit(ref lt) = lt.node {\n                 if let ast::LitBinary(_) = lt.node {\n                     let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n-                    if let ty::ty_rptr(_, mt) = expected_ty.sty {\n-                        if let ty::ty_vec(_, None) = mt.ty.sty {\n+                    if let ty::TyRef(_, mt) = expected_ty.sty {\n+                        if let ty::TyArray(_, None) = mt.ty.sty {\n                             pat_ty = ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n                                 ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n                         }\n@@ -293,7 +293,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n             let pat_ty = match expected_ty.sty {\n-                ty::ty_vec(_, Some(size)) => ty::mk_vec(tcx, inner_ty, Some({\n+                ty::TyArray(_, Some(size)) => ty::mk_vec(tcx, inner_ty, Some({\n                     let min_len = before.len() + after.len();\n                     match *slice {\n                         Some(_) => cmp::max(min_len, size),\n@@ -413,7 +413,7 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     if pat_is_binding(&tcx.def_map, inner) {\n         let expected = fcx.infcx().shallow_resolve(expected);\n         ty::deref(expected, true).map_or(true, |mt| match mt.ty.sty {\n-            ty::ty_trait(_) => {\n+            ty::TyTrait(_) => {\n                 // This is \"x = SomeTrait\" being reduced from\n                 // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                 span_err!(tcx.sess, span, E0033,\n@@ -558,9 +558,9 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         _ => {\n             let def_type = ty::lookup_item_type(tcx, def.def_id());\n             match def_type.ty.sty {\n-                ty::ty_struct(struct_def_id, _) =>\n+                ty::TyStruct(struct_def_id, _) =>\n                     (struct_def_id, struct_def_id),\n-                ty::ty_enum(enum_def_id, _)\n+                ty::TyEnum(enum_def_id, _)\n                     if def == def::DefVariant(enum_def_id, def.def_id(), true) =>\n                     (enum_def_id, def.def_id()),\n                 _ => {\n@@ -662,7 +662,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n-        ty::ty_enum(enum_def_id, expected_substs)\n+        ty::TyEnum(enum_def_id, expected_substs)\n             if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n         {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n@@ -671,7 +671,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                          .collect(),\n              \"variant\")\n         }\n-        ty::ty_struct(struct_def_id, expected_substs) => {\n+        ty::TyStruct(struct_def_id, expected_substs) => {\n             let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n             (struct_fields.iter()\n                           .map(|field| fcx.instantiate_type_scheme(pat.span,"}, {"sha": "aa2433a362a704098ac2000e786edb4f17d90127", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -127,12 +127,12 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n-        ty::ty_bare_fn(..) => {\n+        ty::TyBareFn(..) => {\n             fcx.write_autoderef_adjustment(callee_expr.id, autoderefs);\n             return Some(CallStep::Builtin);\n         }\n \n-        ty::ty_closure(def_id, substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we\n@@ -165,7 +165,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // over the top. The simplest fix by far is to just ignore\n         // this case and deref again, so we wind up with\n         // `FnMut::call_mut(&mut *x, ())`.\n-        ty::ty_rptr(..) if autoderefs == 0 => {\n+        ty::TyRef(..) if autoderefs == 0 => {\n             return None;\n         }\n \n@@ -222,7 +222,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let error_fn_sig;\n \n     let fn_sig = match callee_ty.sty {\n-        ty::ty_bare_fn(_, &ty::BareFnTy {ref sig, ..}) => {\n+        ty::TyBareFn(_, &ty::BareFnTy {ref sig, ..}) => {\n             sig\n         }\n         _ => {"}, {"sha": "04a357b6c115decb404719338b6a64d4fd16b8af", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -74,17 +74,17 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         t: Ty<'tcx>)\n                         -> Option<UnsizeKind<'tcx>> {\n     match t.sty {\n-        ty::ty_vec(_, None) | ty::ty_str => Some(UnsizeKind::Length),\n-        ty::ty_trait(_) => Some(UnsizeKind::Vtable),\n-        ty::ty_struct(did, substs) => {\n+        ty::TyArray(_, None) | ty::TyStr => Some(UnsizeKind::Length),\n+        ty::TyTrait(_) => Some(UnsizeKind::Vtable),\n+        ty::TyStruct(did, substs) => {\n             match ty::struct_fields(fcx.tcx(), did, substs).pop() {\n                 None => None,\n                 Some(f) => unsize_kind(fcx, f.mt.ty)\n             }\n         }\n         // We should really try to normalize here.\n-        ty::ty_projection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n-        ty::ty_param(ref p) => Some(UnsizeKind::OfParam(p)),\n+        ty::TyProjection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n+        ty::TyParam(ref p) => Some(UnsizeKind::OfParam(p)),\n         _ => None\n     }\n }\n@@ -337,7 +337,7 @@ impl<'tcx> CastCheck<'tcx> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == ast::MutImmutable && m_cast.mutbl == ast::MutImmutable {\n-            if let ty::ty_vec(ety, Some(_)) = m_expr.ty.sty {\n+            if let ty::TyArray(ety, Some(_)) = m_expr.ty.sty {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n                 // vector elements instead of the original values."}, {"sha": "cac0a86124ee330a8ac5972bfd48b7cdecb5a537", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -107,7 +107,7 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n            expected_ty.repr(fcx.tcx()));\n \n     match expected_ty.sty {\n-        ty::ty_trait(ref object_type) => {\n+        ty::TyTrait(ref object_type) => {\n             let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n                                                                          fcx.tcx().types.err);\n             let sig = proj_bounds.iter()\n@@ -116,7 +116,7 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n             let kind = fcx.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n             (sig, kind)\n         }\n-        ty::ty_infer(ty::TyVar(vid)) => {\n+        ty::TyInfer(ty::TyVar(vid)) => {\n             deduce_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n@@ -214,7 +214,7 @@ fn deduce_sig_from_projection<'a,'tcx>(\n     debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n     let input_tys = match arg_param_ty.sty {\n-        ty::ty_tup(ref tys) => { (*tys).clone() }\n+        ty::TyTuple(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n     debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr(tcx));\n@@ -244,7 +244,7 @@ fn self_type_matches_expected_vid<'a,'tcx>(\n            trait_ref.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()));\n     match self_ty.sty {\n-        ty::ty_infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n+        ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n         _ => None,\n     }\n }"}, {"sha": "91b31bd0bc9572deb31c3595bd801bca96a1ea07", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -121,13 +121,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match b.sty {\n-            ty::ty_ptr(mt_b) => {\n+            ty::TyRawPtr(mt_b) => {\n                 return self.unpack_actual_value(a, |a| {\n                     self.coerce_unsafe_ptr(a, b, mt_b.mutbl)\n                 });\n             }\n \n-            ty::ty_rptr(_, mt_b) => {\n+            ty::TyRef(_, mt_b) => {\n                 return self.unpack_actual_value(a, |a| {\n                     self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl)\n                 });\n@@ -138,13 +138,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(a, |a| {\n             match a.sty {\n-                ty::ty_bare_fn(Some(_), a_f) => {\n+                ty::TyBareFn(Some(_), a_f) => {\n                     // Function items are coercible to any closure\n                     // type; function pointers are not (that would\n                     // require double indirection).\n                     self.coerce_from_fn_item(a, a_f, b)\n                 }\n-                ty::ty_bare_fn(None, a_f) => {\n+                ty::TyBareFn(None, a_f) => {\n                     // We permit coercion of fn pointers to drop the\n                     // unsafe qualifier.\n                     self.coerce_from_fn_pointer(a, a_f, b)\n@@ -177,7 +177,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // yield.\n \n         match a.sty {\n-            ty::ty_rptr(_, mt_a) => {\n+            ty::TyRef(_, mt_a) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n             }\n             _ => return self.subtype(a, b)\n@@ -258,15 +258,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n         let (source, reborrow) = match (&source.sty, &target.sty) {\n-            (&ty::ty_rptr(_, mt_a), &ty::ty_rptr(_, mt_b)) => {\n+            (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                 let region = self.tcx().mk_region(r_borrow);\n                 (mt_a.ty, Some(ty::AutoPtr(region, mt_b.mutbl)))\n             }\n-            (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) => {\n+            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n                 (mt_a.ty, Some(ty::AutoUnsafe(mt_b.mutbl)))\n             }\n@@ -355,7 +355,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             debug!(\"coerce_from_fn_pointer(a={}, b={})\",\n                    a.repr(self.tcx()), b.repr(self.tcx()));\n \n-            if let ty::ty_bare_fn(None, fn_ty_b) = b.sty {\n+            if let ty::TyBareFn(None, fn_ty_b) = b.sty {\n                 match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n                     (ast::Unsafety::Normal, ast::Unsafety::Unsafe) => {\n                         let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n@@ -384,7 +384,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                    a.repr(self.tcx()), b.repr(self.tcx()));\n \n             match b.sty {\n-                ty::ty_bare_fn(None, _) => {\n+                ty::TyBareFn(None, _) => {\n                     let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n                     Ok(Some(ty::AdjustReifyFnPointer))\n@@ -404,7 +404,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                b.repr(self.tcx()));\n \n         let mt_a = match a.sty {\n-            ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n+            ty::TyRef(_, mt) | ty::TyRawPtr(mt) => mt,\n             _ => {\n                 return self.subtype(a, b);\n             }"}, {"sha": "6e6231dec324be395ae4cd7ea2f04f38b9e421c6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -41,9 +41,9 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n                          ty: ref dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n     let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n     match dtor_self_type.sty {\n-        ty::ty_enum(self_type_did, self_to_impl_substs) |\n-        ty::ty_struct(self_type_did, self_to_impl_substs) |\n-        ty::ty_closure(self_type_did, self_to_impl_substs) => {\n+        ty::TyEnum(self_type_did, self_to_impl_substs) |\n+        ty::TyStruct(self_type_did, self_to_impl_substs) |\n+        ty::TyClosure(self_type_did, self_to_impl_substs) => {\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,\n@@ -366,7 +366,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         // with `T`, the type it represents as owned by the\n         // surrounding context, before doing further analysis.\n         let (typ, xref_depth) = match typ.sty {\n-            ty::ty_struct(struct_did, substs) => {\n+            ty::TyStruct(struct_did, substs) => {\n                 if opt_phantom_data_def_id == Some(struct_did) {\n                     let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n                     let tp_def = item_type.generics.types\n@@ -380,11 +380,11 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                 }\n             }\n \n-            // Note: When ty_uniq is removed from compiler, the\n+            // Note: When TyBox is removed from compiler, the\n             // definition of `Box<T>` must carry a PhantomData that\n             // puts us into the previous case.\n-            ty::ty_uniq(new_typ) => {\n-                debug!(\"replacing ty_uniq {} with {}\",\n+            ty::TyBox(new_typ) => {\n+                debug!(\"replacing TyBox {} with {}\",\n                        typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n                 (new_typ, xref_depth_orig + 1)\n             }\n@@ -395,14 +395,14 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         };\n \n         let dtor_kind = match typ.sty {\n-            ty::ty_enum(def_id, _) |\n-            ty::ty_struct(def_id, _) => {\n+            ty::TyEnum(def_id, _) |\n+            ty::TyStruct(def_id, _) => {\n                 match destructor_for_type.get(&def_id) {\n                     Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n                     None => DtorKind::PureRecur,\n                 }\n             }\n-            ty::ty_trait(ref ty_trait) => {\n+            ty::TyTrait(ref ty_trait) => {\n                 DtorKind::Unknown(ty_trait.bounds.clone())\n             }\n             _ => DtorKind::PureRecur,\n@@ -466,7 +466,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             // destructor.\n \n             match typ.sty {\n-                ty::ty_struct(struct_did, substs) => {\n+                ty::TyStruct(struct_did, substs) => {\n                     debug!(\"typ: {} is struct; traverse structure and not type-expression\",\n                            typ.repr(rcx.tcx()));\n                     // Don't recurse; we extract type's substructure,\n@@ -496,7 +496,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     }\n                 }\n \n-                ty::ty_enum(enum_did, substs) => {\n+                ty::TyEnum(enum_did, substs) => {\n                     debug!(\"typ: {} is enum; traverse structure and not type-expression\",\n                            typ.repr(rcx.tcx()));\n                     // Don't recurse; we extract type's substructure,\n@@ -526,7 +526,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     }\n                 }\n \n-                ty::ty_rptr(..) | ty::ty_ptr(_) | ty::ty_bare_fn(..) => {\n+                ty::TyRef(..) | ty::TyRawPtr(_) | ty::TyBareFn(..) => {\n                     // Don't recurse, since references, pointers,\n                     // and bare functions don't own instances\n                     // of the types appearing within them."}, {"sha": "bd482a4c787f1216a2978c1d5f3ef87fb2ebfa2e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -296,7 +296,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n-        F: FnMut(&mut ConfirmContext<'a, 'tcx>, Ty<'tcx>, &ty::TyTrait<'tcx>) -> R,\n+        F: FnMut(&mut ConfirmContext<'a, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n@@ -311,7 +311,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                               NoPreference,\n                                               |ty, _| {\n             match ty.sty {\n-                ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n+                ty::TyTrait(ref data) => Some(closure(self, ty, &**data)),\n                 _ => None,\n             }\n         });\n@@ -456,12 +456,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn fixup_derefs_on_method_receiver_if_necessary(&self,\n                                                     method_callee: &MethodCallee) {\n         let sig = match method_callee.ty.sty {\n-            ty::ty_bare_fn(_, ref f) => f.sig.clone(),\n+            ty::TyBareFn(_, ref f) => f.sig.clone(),\n             _ => return,\n         };\n \n         match sig.0.inputs[0].sty {\n-            ty::ty_rptr(_, ty::mt {\n+            ty::TyRef(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,\n             }) => {}"}, {"sha": "bb620c6ecd895334be44a675b72c52df4fea9b10", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -254,7 +254,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     // Trait method is fn(&self) or fn(&mut self), need an\n                     // autoref. Pull the region etc out of the type of first argument.\n                     match transformed_self_ty.sty {\n-                        ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n+                        ty::TyRef(region, ty::mt { mutbl, ty: _ }) => {\n                             fcx.write_adjustment(self_expr.id,\n                                 ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,"}, {"sha": "e7fd6f7834ad14a44273232a9d320b4d35ab40e7", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -202,15 +202,15 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     });\n \n     match final_ty.sty {\n-        ty::ty_vec(elem_ty, Some(_)) => {\n+        ty::TyArray(elem_ty, Some(_)) => {\n             let slice_ty = ty::mk_vec(fcx.tcx(), elem_ty, None);\n             steps.push(CandidateStep {\n                 self_ty: slice_ty,\n                 autoderefs: dereferences,\n                 unsize: true\n             });\n         }\n-        ty::ty_err => return None,\n+        ty::TyError => return None,\n         _ => (),\n     }\n \n@@ -270,88 +270,88 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                self_ty.repr(self.tcx()));\n \n         match self_ty.sty {\n-            ty::ty_trait(box ref data) => {\n+            ty::TyTrait(box ref data) => {\n                 self.assemble_inherent_candidates_from_object(self_ty, data);\n                 self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n             }\n-            ty::ty_enum(did, _) |\n-            ty::ty_struct(did, _) |\n-            ty::ty_closure(did, _) => {\n+            ty::TyEnum(did, _) |\n+            ty::TyStruct(did, _) |\n+            ty::TyClosure(did, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n-            ty::ty_uniq(_) => {\n+            ty::TyBox(_) => {\n                 if let Some(box_did) = self.tcx().lang_items.owned_box() {\n                     self.assemble_inherent_impl_candidates_for_type(box_did);\n                 }\n             }\n-            ty::ty_param(p) => {\n+            ty::TyParam(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n-            ty::ty_char => {\n+            ty::TyChar => {\n                 let lang_def_id = self.tcx().lang_items.char_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_str => {\n+            ty::TyStr => {\n                 let lang_def_id = self.tcx().lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_vec(_, None) => {\n+            ty::TyArray(_, None) => {\n                 let lang_def_id = self.tcx().lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n+            ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n                 let lang_def_id = self.tcx().lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n+            ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n                 let lang_def_id = self.tcx().lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_int(ast::TyI8) => {\n+            ty::TyInt(ast::TyI8) => {\n                 let lang_def_id = self.tcx().lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_int(ast::TyI16) => {\n+            ty::TyInt(ast::TyI16) => {\n                 let lang_def_id = self.tcx().lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_int(ast::TyI32) => {\n+            ty::TyInt(ast::TyI32) => {\n                 let lang_def_id = self.tcx().lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_int(ast::TyI64) => {\n+            ty::TyInt(ast::TyI64) => {\n                 let lang_def_id = self.tcx().lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_int(ast::TyIs) => {\n+            ty::TyInt(ast::TyIs) => {\n                 let lang_def_id = self.tcx().lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_uint(ast::TyU8) => {\n+            ty::TyUint(ast::TyU8) => {\n                 let lang_def_id = self.tcx().lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_uint(ast::TyU16) => {\n+            ty::TyUint(ast::TyU16) => {\n                 let lang_def_id = self.tcx().lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_uint(ast::TyU32) => {\n+            ty::TyUint(ast::TyU32) => {\n                 let lang_def_id = self.tcx().lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_uint(ast::TyU64) => {\n+            ty::TyUint(ast::TyU64) => {\n                 let lang_def_id = self.tcx().lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_uint(ast::TyUs) => {\n+            ty::TyUint(ast::TyUs) => {\n                 let lang_def_id = self.tcx().lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_float(ast::TyF32) => {\n+            ty::TyFloat(ast::TyF32) => {\n                 let lang_def_id = self.tcx().lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_float(ast::TyF64) => {\n+            ty::TyFloat(ast::TyF64) => {\n                 let lang_def_id = self.tcx().lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -413,7 +413,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n-                                                data: &ty::TyTrait<'tcx>) {\n+                                                data: &ty::TraitTy<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n                self_ty.repr(self.tcx()));\n \n@@ -460,7 +460,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 match *predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n                         match trait_predicate.0.trait_ref.self_ty().sty {\n-                            ty::ty_param(ref p) if *p == param_ty => {\n+                            ty::TyParam(ref p) if *p == param_ty => {\n                                 Some(trait_predicate.to_poly_trait_ref())\n                             }\n                             _ => None\n@@ -702,7 +702,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n             let closure_def_id = match step.self_ty.sty {\n-                ty::ty_closure(a, _) => a,\n+                ty::TyClosure(a, _) => a,\n                 _ => continue,\n             };\n \n@@ -759,7 +759,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                    step.repr(self.tcx()));\n \n             let projection_trait_ref = match step.self_ty.sty {\n-                ty::ty_projection(ref data) => &data.trait_ref,\n+                ty::TyProjection(ref data) => &data.trait_ref,\n                 _ => continue,\n             };\n \n@@ -924,7 +924,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             pick.autoderefs = step.autoderefs;\n \n             // Insert a `&*` or `&mut *` if this is a reference type:\n-            if let ty::ty_rptr(_, mt) = step.self_ty.sty {\n+            if let ty::TyRef(_, mt) = step.self_ty.sty {\n                 pick.autoderefs += 1;\n                 pick.autoref = Some(mt.mutbl);\n             }"}, {"sha": "8a48ef543ccc13c639fd791775dd47a52df13753", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -61,7 +61,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None);\n \n             // If the item has the name of a field, give a help note\n-            if let (&ty::ty_struct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n+            if let (&ty::TyStruct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n                 let fields = ty::lookup_struct_fields(cx, did);\n                 if fields.iter().any(|f| f.name == item_name) {\n                     cx.sess.span_note(span,\n@@ -238,11 +238,11 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rcvr_expr: Option<&ast::Expr>) -> bool {\n     fn is_local(ty: Ty) -> bool {\n         match ty.sty {\n-            ty::ty_enum(did, _) | ty::ty_struct(did, _) => ast_util::is_local(did),\n+            ty::TyEnum(did, _) | ty::TyStruct(did, _) => ast_util::is_local(did),\n \n-            ty::ty_trait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n+            ty::TyTrait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n \n-            ty::ty_param(_) => true,\n+            ty::TyParam(_) => true,\n \n             // everything else (primitive types etc.) is effectively\n             // non-local (there are \"edge\" cases, e.g. (LocalType,), but"}, {"sha": "8493715aa4bc3733cf9a2f25edb77f84d9537dfb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -506,7 +506,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n {\n     match raw_fty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => {\n+        ty::TyBareFn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n \n             // Compute the fty from point of view of inside fn.\n@@ -1142,7 +1142,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n     }, t_expr, None);\n     match t_expr.sty {\n-        ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n+        ty::TyRef(_, ty::mt { mutbl: mt, .. }) => {\n             let mtstr = match mt {\n                 ast::MutMutable => \"mut \",\n                 ast::MutImmutable => \"\"\n@@ -1164,7 +1164,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                            mtstr, tstr);\n             }\n         }\n-        ty::ty_uniq(..) => {\n+        ty::TyBox(..) => {\n             match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                 Ok(s) => {\n                     fcx.tcx().sess.span_suggestion(t_span,\n@@ -1920,8 +1920,8 @@ impl LvaluePreference {\n /// Whether `autoderef` requires types to resolve.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum UnresolvedTypeAction {\n-    /// Produce an error and return `ty_err` whenever a type cannot\n-    /// be resolved (i.e. it is `ty_infer`).\n+    /// Produce an error and return `TyError` whenever a type cannot\n+    /// be resolved (i.e. it is `TyInfer`).\n     Error,\n     /// Go on without emitting any errors, and return the unresolved\n     /// type. Useful for probing, e.g. in coercions.\n@@ -2096,7 +2096,7 @@ fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // After we have fully autoderef'd, if the resulting type is [T; n], then\n     // do a final unsized coercion to yield [T].\n-    if let ty::ty_vec(element_ty, Some(_)) = ty.sty {\n+    if let ty::TyArray(element_ty, Some(_)) = ty.sty {\n         let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n         try_index_step(fcx, MethodCall::expr(expr.id), expr, base_expr,\n                        adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n@@ -2134,7 +2134,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // First, try built-in indexing.\n     match (ty::index(adjusted_ty), &index_ty.sty) {\n-        (Some(ty), &ty::ty_uint(ast::TyUs)) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n+        (Some(ty), &ty::TyUint(ast::TyUs)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n             assert!(!unsize);\n@@ -2212,7 +2212,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::FnConverging(fcx.tcx().types.err)\n     } else {\n         match method_fn_ty.sty {\n-            ty::ty_bare_fn(_, ref fty) => {\n+            ty::TyBareFn(_, ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 let expected_arg_tys = expected_types_for_fn_args(fcx,\n                                                                   sp,\n@@ -2260,7 +2260,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let formal_tys = if tuple_arguments == TupleArguments {\n         let tuple_type = structurally_resolved_type(fcx, sp, fn_inputs[0]);\n         match tuple_type.sty {\n-            ty::ty_tup(ref arg_types) => {\n+            ty::TyTuple(ref arg_types) => {\n                 if arg_types.len() != args.len() {\n                     span_err!(tcx.sess, sp, E0057,\n                         \"this function takes {} parameter{} but {} parameter{} supplied\",\n@@ -2273,7 +2273,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 } else {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::ty_tup(ref tys) => &**tys,\n+                            ty::TyTuple(ref tys) => &**tys,\n                             _ => &[]\n                         },\n                         None => &[]\n@@ -2391,21 +2391,21 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n                                                     fcx.expr_ty(&**arg));\n             match arg_ty.sty {\n-                ty::ty_float(ast::TyF32) => {\n+                ty::TyFloat(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n                                            |t| {\n                         format!(\"can't pass an {} to variadic \\\n                                  function, cast to c_double\", t)\n                     }, arg_ty, None);\n                 }\n-                ty::ty_int(ast::TyI8) | ty::ty_int(ast::TyI16) | ty::ty_bool => {\n+                ty::TyInt(ast::TyI8) | ty::TyInt(ast::TyI16) | ty::TyBool => {\n                     fcx.type_error_message(arg.span, |t| {\n                         format!(\"can't pass {} to variadic \\\n                                  function, cast to c_int\",\n                                        t)\n                     }, arg_ty, None);\n                 }\n-                ty::ty_uint(ast::TyU8) | ty::ty_uint(ast::TyU16) => {\n+                ty::TyUint(ast::TyU8) | ty::TyUint(ast::TyU16) => {\n                     fcx.type_error_message(arg.span, |t| {\n                         format!(\"can't pass {} to variadic \\\n                                  function, cast to c_uint\",\n@@ -2455,10 +2455,10 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n-                    ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n-                    ty::ty_char => Some(tcx.types.u8),\n-                    ty::ty_ptr(..) => Some(tcx.types.usize),\n-                    ty::ty_bare_fn(..) => Some(tcx.types.usize),\n+                    ty::TyInt(_) | ty::TyUint(_) => Some(ty),\n+                    ty::TyChar => Some(tcx.types.u8),\n+                    ty::TyRawPtr(..) => Some(tcx.types.usize),\n+                    ty::TyBareFn(..) => Some(tcx.types.usize),\n                     _ => None\n                 }\n             });\n@@ -2469,7 +2469,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ast::LitFloatUnsuffixed(_) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n-                    ty::ty_float(_) => Some(ty),\n+                    ty::TyFloat(_) => Some(ty),\n                     _ => None\n                 }\n             });\n@@ -2621,7 +2621,7 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// strict, _|_ can appear in the type of an expression that does not,\n /// itself, diverge: for example, fn() -> _|_.)\n /// Note that inspecting a type's structure *directly* may expose the fact\n-/// that there are actually multiple representations for `ty_err`, so avoid\n+/// that there are actually multiple representations for `TyError`, so avoid\n /// that when err needs to be handled differently.\n fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                         expr: &'tcx ast::Expr,\n@@ -2746,7 +2746,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n                 match base_t.sty {\n-                    ty::ty_struct(base_id, substs) => {\n+                    ty::TyStruct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n                         fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n@@ -2787,7 +2787,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             actual)\n                 },\n                 expr_t, None);\n-            if let ty::ty_struct(did, _) = expr_t.sty {\n+            if let ty::TyStruct(did, _) = expr_t.sty {\n                 suggest_field_names(did, field, tcx, vec![]);\n             }\n         }\n@@ -2848,7 +2848,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n                 match base_t.sty {\n-                    ty::ty_struct(base_id, substs) => {\n+                    ty::TyStruct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -2859,7 +2859,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             None\n                         }\n                     }\n-                    ty::ty_tup(ref v) => {\n+                    ty::TyTuple(ref v) => {\n                         tuple_like = true;\n                         if idx.node < v.len() { Some(v[idx.node]) } else { None }\n                     }\n@@ -3138,7 +3138,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expected_inner = expected.to_option(fcx).map_or(NoExpectation, |ty| {\n             match unop {\n                 ast::UnUniq => match ty.sty {\n-                    ty::ty_uniq(ty) => {\n+                    ty::TyBox(ty) => {\n                         Expectation::rvalue_hint(ty)\n                     }\n                     _ => {\n@@ -3188,7 +3188,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n-                         oprnd_t.sty == ty::ty_bool) {\n+                         oprnd_t.sty == ty::TyBool) {\n                         oprnd_t = op::check_user_unop(fcx, \"!\", \"not\",\n                                                       tcx.lang_items.not_trait(),\n                                                       expr, &**oprnd, oprnd_t, unop);\n@@ -3203,7 +3203,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                       tcx.lang_items.neg_trait(),\n                                                       expr, &**oprnd, oprnd_t, unop);\n                     }\n-                    if let ty::ty_uint(_) = oprnd_t.sty {\n+                    if let ty::TyUint(_) = oprnd_t.sty {\n                         if !tcx.sess.features.borrow().negate_unsigned {\n                             feature_gate::emit_feature_err(\n                                 &tcx.sess.parse_sess.span_diagnostic,\n@@ -3220,7 +3220,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n         let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n-                ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => {\n+                ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n                     if ty::expr_is_lval(fcx.tcx(), &**oprnd) {\n                         // Lvalues may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n@@ -3453,7 +3453,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprVec(ref args) => {\n         let uty = expected.to_option(fcx).and_then(|uty| {\n             match uty.sty {\n-                ty::ty_vec(ty, _) => Some(ty),\n+                ty::TyArray(ty, _) => Some(ty),\n                 _ => None\n             }\n         });\n@@ -3483,7 +3483,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let uty = match expected {\n             ExpectHasType(uty) => {\n                 match uty.sty {\n-                    ty::ty_vec(ty, _) => Some(ty),\n+                    ty::TyArray(ty, _) => Some(ty),\n                     _ => None\n                 }\n             }\n@@ -3522,7 +3522,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprTup(ref elts) => {\n         let flds = expected.only_has_type(fcx).and_then(|ty| {\n             match ty.sty {\n-                ty::ty_tup(ref flds) => Some(&flds[..]),\n+                ty::TyTuple(ref flds) => Some(&flds[..]),\n                 _ => None\n             }\n         });\n@@ -3573,7 +3573,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Verify that this was actually a struct.\n                 let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n                 match typ.ty.sty {\n-                    ty::ty_struct(struct_did, _) => {\n+                    ty::TyStruct(struct_did, _) => {\n                         check_struct_constructor(fcx,\n                                                  id,\n                                                  expr.span,\n@@ -3863,7 +3863,7 @@ impl<'tcx> Expectation<'tcx> {\n     /// for examples of where this comes up,.\n     fn rvalue_hint(ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match ty.sty {\n-            ty::ty_vec(_, None) | ty::ty_trait(..) => {\n+            ty::TyArray(_, None) | ty::TyTrait(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n             _ => ExpectHasType(ty)\n@@ -4213,7 +4213,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n         return;\n     }\n     match t.sty {\n-        ty::ty_struct(did, substs) => {\n+        ty::TyStruct(did, substs) => {\n             let fields = ty::lookup_struct_fields(tcx, did);\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -4959,7 +4959,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     ty::walk_ty(ty, |t| {\n             match t.sty {\n-                ty::ty_param(ParamTy {idx, ..}) => {\n+                ty::TyParam(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n                     tps_used[idx as usize] = true;\n                 }"}, {"sha": "2b2cb31836c02dc521ee2d180bc88336e1552fae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -669,7 +669,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n-            if let ty::ty_rptr(r_ptr, _) = base_ty.sty {\n+            if let ty::TyRef(r_ptr, _) = base_ty.sty {\n                 mk_subregion_due_to_dereference(\n                     rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), *r_ptr);\n             }\n@@ -762,23 +762,23 @@ fn constrain_cast(rcx: &mut Rcx,\n                from_ty.repr(rcx.tcx()),\n                to_ty.repr(rcx.tcx()));\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::ty_rptr(from_r, ref from_mt),\n-            /*To:  */  &ty::ty_rptr(to_r, ref to_mt)) => {\n+            /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n+            /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n                 rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n                 walk_cast(rcx, cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::ty_trait(box ty::TyTrait { ref bounds, .. })) => {\n+            /*To:  */  &ty::TyTrait(box ty::TraitTy { ref bounds, .. })) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 type_must_outlive(rcx, infer::RelateObjectBound(cast_expr.span),\n                                   from_ty, bounds.region_bound);\n             }\n \n-            /*From:*/ (&ty::ty_uniq(from_referent_ty),\n-            /*To:  */  &ty::ty_uniq(to_referent_ty)) => {\n+            /*From:*/ (&ty::TyBox(from_referent_ty),\n+            /*To:  */  &ty::TyBox(to_referent_ty)) => {\n                 walk_cast(rcx, cast_expr, from_referent_ty, to_referent_ty);\n             }\n \n@@ -801,7 +801,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     _callee_expr: &ast::Expr) {\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     match callee_ty.sty {\n-        ty::ty_bare_fn(..) => { }\n+        ty::TyBareFn(..) => { }\n         _ => {\n             // this should not happen, but it does if the program is\n             // erroneous\n@@ -899,7 +899,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     ty::no_late_bound_regions(rcx.tcx(), fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n-                    ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                    ty::TyRef(r, ref m) => (m.mutbl, r),\n                     _ => {\n                         rcx.tcx().sess.span_bug(\n                             deref_expr.span,\n@@ -935,7 +935,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n             None => derefd_ty\n         };\n \n-        if let ty::ty_rptr(r_ptr, _) =  derefd_ty.sty {\n+        if let ty::TyRef(r_ptr, _) =  derefd_ty.sty {\n             mk_subregion_due_to_dereference(rcx, deref_expr.span,\n                                             r_deref_expr, *r_ptr);\n         }\n@@ -995,9 +995,9 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n     let r_index_expr = ty::ReScope(CodeExtent::from_node_id(index_expr.id));\n-    if let ty::ty_rptr(r_ptr, mt) = indexed_ty.sty {\n+    if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n         match mt.ty.sty {\n-            ty::ty_vec(_, None) | ty::ty_str => {\n+            ty::TyArray(_, None) | ty::TyStr => {\n                 rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n                                 r_index_expr, *r_ptr);\n             }"}, {"sha": "cf324ef97e7fe39150bd16f42ea68ab0ecec1e6f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -403,7 +403,7 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n         match &ty.sty {\n-            &ty::sty::ty_param(_) => true,\n+            &ty::TyParam(_) => true,\n             _ => false\n         }\n     }\n@@ -568,8 +568,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         }\n \n         match t.sty{\n-            ty::ty_struct(type_id, substs) |\n-            ty::ty_enum(type_id, substs) => {\n+            ty::TyStruct(type_id, substs) |\n+            ty::TyEnum(type_id, substs) => {\n                 let type_predicates = ty::lookup_predicates(self.fcx.tcx(), type_id);\n                 let bounds = self.fcx.instantiate_bounds(self.span, substs,\n                                                          &type_predicates);"}, {"sha": "5a6cf7cccfd33ac8bea9fe5602f817f32d48f849", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -22,12 +22,12 @@ use middle::traits;\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n-use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n-use middle::ty::{ty_param, TypeScheme, ty_ptr};\n-use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int};\n-use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n-use middle::ty::ty_projection;\n+use middle::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n+use middle::ty::{TyParam, TypeScheme, TyRawPtr};\n+use middle::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n+use middle::ty::{TyStr, TyArray, TyFloat, TyInfer, TyInt};\n+use middle::ty::{TyUint, TyClosure, TyBox, TyBareFn};\n+use middle::ty::TyProjection;\n use middle::ty;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n@@ -56,27 +56,27 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n                                   ty: Ty<'tcx>)\n                                   -> Option<DefId> {\n     match ty.sty {\n-        ty_enum(def_id, _) |\n-        ty_struct(def_id, _) => {\n+        TyEnum(def_id, _) |\n+        TyStruct(def_id, _) => {\n             Some(def_id)\n         }\n \n-        ty_trait(ref t) => {\n+        TyTrait(ref t) => {\n             Some(t.principal_def_id())\n         }\n \n-        ty_uniq(_) => {\n+        TyBox(_) => {\n             inference_context.tcx.lang_items.owned_box()\n         }\n \n-        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n-        ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_tup(..) |\n-        ty_param(..) | ty_err |\n-        ty_ptr(_) | ty_rptr(_, _) | ty_projection(..) => {\n+        TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+        TyStr(..) | TyArray(..) | TyBareFn(..) | TyTuple(..) |\n+        TyParam(..) | TyError |\n+        TyRawPtr(_) | TyRef(_, _) | TyProjection(..) => {\n             None\n         }\n \n-        ty_infer(..) | ty_closure(..) => {\n+        TyInfer(..) | TyClosure(..) => {\n             // `ty` comes from a user declaration so we should only expect types\n             // that the user can type\n             inference_context.tcx.sess.span_bug(\n@@ -315,9 +315,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let self_type = ty::lookup_item_type(tcx, impl_did);\n             match self_type.ty.sty {\n-                ty::ty_enum(type_def_id, _) |\n-                ty::ty_struct(type_def_id, _) |\n-                ty::ty_closure(type_def_id, _) => {\n+                ty::TyEnum(type_def_id, _) |\n+                ty::TyStruct(type_def_id, _) |\n+                ty::TyClosure(type_def_id, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());\n@@ -465,19 +465,19 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 (mt_a.ty, mt_b.ty, unsize_trait, None)\n             };\n             let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-                (&ty::ty_uniq(a), &ty::ty_uniq(b)) => (a, b, unsize_trait, None),\n+                (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n \n-                (&ty::ty_rptr(r_a, mt_a), &ty::ty_rptr(r_b, mt_b)) => {\n+                (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                     infer::mk_subr(&infcx, infer::RelateObjectBound(span), *r_b, *r_a);\n                     check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_rptr(tcx, r_b, ty))\n                 }\n \n-                (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) |\n-                (&ty::ty_ptr(mt_a), &ty::ty_ptr(mt_b)) => {\n+                (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+                (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n                     check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_ptr(tcx, ty))\n                 }\n \n-                (&ty::ty_struct(def_id_a, substs_a), &ty::ty_struct(def_id_b, substs_b)) => {\n+                (&ty::TyStruct(def_id_a, substs_a), &ty::TyStruct(def_id_b, substs_b)) => {\n                     if def_id_a != def_id_b {\n                         let source_path = ty::item_path_str(tcx, def_id_a);\n                         let target_path = ty::item_path_str(tcx, def_id_b);"}, {"sha": "da01d4669f8e7244e5ba26ff74dfad2681c2bf5c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -69,129 +69,129 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n                 match self_ty.sty {\n-                    ty::ty_enum(def_id, _) |\n-                    ty::ty_struct(def_id, _) => {\n+                    ty::TyEnum(def_id, _) |\n+                    ty::TyStruct(def_id, _) => {\n                         self.check_def_id(item, def_id);\n                     }\n-                    ty::ty_trait(ref data) => {\n+                    ty::TyTrait(ref data) => {\n                         self.check_def_id(item, data.principal_def_id());\n                     }\n-                    ty::ty_uniq(..) => {\n+                    ty::TyBox(..) => {\n                         self.check_def_id(item, self.tcx.lang_items.owned_box().unwrap());\n                     }\n-                    ty::ty_char => {\n+                    ty::TyChar => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.char_impl(),\n                                                   \"char\",\n                                                   \"char\",\n                                                   item.span);\n                     }\n-                    ty::ty_str => {\n+                    ty::TyStr => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.str_impl(),\n                                                   \"str\",\n                                                   \"str\",\n                                                   item.span);\n                     }\n-                    ty::ty_vec(_, None) => {\n+                    ty::TyArray(_, None) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.slice_impl(),\n                                                   \"slice\",\n                                                   \"[T]\",\n                                                   item.span);\n                     }\n-                    ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n+                    ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.const_ptr_impl(),\n                                                   \"const_ptr\",\n                                                   \"*const T\",\n                                                   item.span);\n                     }\n-                    ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n+                    ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.mut_ptr_impl(),\n                                                   \"mut_ptr\",\n                                                   \"*mut T\",\n                                                   item.span);\n                     }\n-                    ty::ty_int(ast::TyI8) => {\n+                    ty::TyInt(ast::TyI8) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i8_impl(),\n                                                   \"i8\",\n                                                   \"i8\",\n                                                   item.span);\n                     }\n-                    ty::ty_int(ast::TyI16) => {\n+                    ty::TyInt(ast::TyI16) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i16_impl(),\n                                                   \"i16\",\n                                                   \"i16\",\n                                                   item.span);\n                     }\n-                    ty::ty_int(ast::TyI32) => {\n+                    ty::TyInt(ast::TyI32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i32_impl(),\n                                                   \"i32\",\n                                                   \"i32\",\n                                                   item.span);\n                     }\n-                    ty::ty_int(ast::TyI64) => {\n+                    ty::TyInt(ast::TyI64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i64_impl(),\n                                                   \"i64\",\n                                                   \"i64\",\n                                                   item.span);\n                     }\n-                    ty::ty_int(ast::TyIs) => {\n+                    ty::TyInt(ast::TyIs) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n                                                   \"isize\",\n                                                   \"isize\",\n                                                   item.span);\n                     }\n-                    ty::ty_uint(ast::TyU8) => {\n+                    ty::TyUint(ast::TyU8) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u8_impl(),\n                                                   \"u8\",\n                                                   \"u8\",\n                                                   item.span);\n                     }\n-                    ty::ty_uint(ast::TyU16) => {\n+                    ty::TyUint(ast::TyU16) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u16_impl(),\n                                                   \"u16\",\n                                                   \"u16\",\n                                                   item.span);\n                     }\n-                    ty::ty_uint(ast::TyU32) => {\n+                    ty::TyUint(ast::TyU32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u32_impl(),\n                                                   \"u32\",\n                                                   \"u32\",\n                                                   item.span);\n                     }\n-                    ty::ty_uint(ast::TyU64) => {\n+                    ty::TyUint(ast::TyU64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u64_impl(),\n                                                   \"u64\",\n                                                   \"u64\",\n                                                   item.span);\n                     }\n-                    ty::ty_uint(ast::TyUs) => {\n+                    ty::TyUint(ast::TyUs) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),\n                                                   \"usize\",\n                                                   \"usize\",\n                                                   item.span);\n                     }\n-                    ty::ty_float(ast::TyF32) => {\n+                    ty::TyFloat(ast::TyF32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.f32_impl(),\n                                                   \"f32\",\n                                                   \"f32\",\n                                                   item.span);\n                     }\n-                    ty::ty_float(ast::TyF64) => {\n+                    ty::TyFloat(ast::TyF64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.f64_impl(),\n                                                   \"f64\",\n@@ -275,9 +275,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::ty_struct(self_def_id, _) | ty::ty_enum(self_def_id, _) =>\n+                        ty::TyStruct(self_def_id, _) | ty::TyEnum(self_def_id, _) =>\n                             Some(self_def_id),\n-                        ty::ty_uniq(..) =>\n+                        ty::TyBox(..) =>\n                             self.tcx.lang_items.owned_box(),\n                         _ =>\n                             None"}, {"sha": "7564f7862fcd952c3ac9e34d59a28835b78f6686", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -198,7 +198,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let trait_ref = ty::impl_trait_ref(self.tcx, impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match trait_ref.self_ty().sty {\n-                    ty::ty_trait(ref data) => {\n+                    ty::TyTrait(ref data) => {\n                         // This is something like impl Trait1 for Trait2. Illegal\n                         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n "}, {"sha": "aabd33d9c1d3a76d84dfd7ef59c00708798abef2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -1882,7 +1882,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n             ty::walk_ty(ty, |t| {\n                 match t.sty {\n-                    ty::ty_param(p) => if p.idx > cur_idx {\n+                    ty::TyParam(p) => if p.idx > cur_idx {\n                         span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n@@ -2174,8 +2174,8 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n         let typ = ccx.icx(&method_type.predicates).to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n-            ty::ty_rptr(_, tm) => tm.ty,\n-            ty::ty_uniq(typ) => typ,\n+            ty::TyRef(_, tm) => tm.ty,\n+            ty::TyBox(typ) => typ,\n             _ => typ,\n         };\n "}, {"sha": "09539931c34465f9ef78fa6922a6d8d3e71e7580", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -40,14 +40,14 @@ pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>) -> Vec<Par\n \n fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n     match ty.sty {\n-        ty::ty_param(ref d) =>\n+        ty::TyParam(ref d) =>\n             vec![Parameter::Type(d.clone())],\n-        ty::ty_rptr(region, _) =>\n+        ty::TyRef(region, _) =>\n             parameters_for_region(region).into_iter().collect(),\n-        ty::ty_struct(_, substs) |\n-        ty::ty_enum(_, substs) =>\n+        ty::TyStruct(_, substs) |\n+        ty::TyEnum(_, substs) =>\n             parameters_for_regions_in_substs(substs),\n-        ty::ty_trait(ref data) =>\n+        ty::TyTrait(ref data) =>\n             parameters_for_regions_in_substs(&data.principal.skip_binder().substs),\n         _ =>\n             vec![],"}, {"sha": "67101a69b5709a130613fe35d05a8ffdb0f59f1b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -212,7 +212,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match main_t.sty {\n-        ty::ty_bare_fn(..) => {\n+        ty::TyBareFn(..) => {\n             match tcx.map.find(main_id) {\n                 Some(ast_map::NodeItem(it)) => {\n                     match it.node {\n@@ -259,7 +259,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match start_t.sty {\n-        ty::ty_bare_fn(..) => {\n+        ty::TyBareFn(..) => {\n             match tcx.map.find(start_id) {\n                 Some(ast_map::NodeItem(it)) => {\n                     match it.node {"}, {"sha": "c17e3038a8b2d813b5437aee967de91c471c571d", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -873,39 +873,39 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                variance);\n \n         match ty.sty {\n-            ty::ty_bool |\n-            ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n-            ty::ty_float(_) | ty::ty_str => {\n+            ty::TyBool |\n+            ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n+            ty::TyFloat(_) | ty::TyStr => {\n                 /* leaf type -- noop */\n             }\n \n-            ty::ty_closure(..) => {\n+            ty::TyClosure(..) => {\n                 self.tcx().sess.bug(\"Unexpected closure type in variance computation\");\n             }\n \n-            ty::ty_rptr(region, ref mt) => {\n+            ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(generics, *region, contra);\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::ty_uniq(typ) | ty::ty_vec(typ, _) => {\n+            ty::TyBox(typ) | ty::TyArray(typ, _) => {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n \n \n-            ty::ty_ptr(ref mt) => {\n+            ty::TyRawPtr(ref mt) => {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::ty_tup(ref subtys) => {\n+            ty::TyTuple(ref subtys) => {\n                 for &subty in subtys {\n                     self.add_constraints_from_ty(generics, subty, variance);\n                 }\n             }\n \n-            ty::ty_enum(def_id, substs) |\n-            ty::ty_struct(def_id, substs) => {\n+            ty::TyEnum(def_id, substs) |\n+            ty::TyStruct(def_id, substs) => {\n                 let item_type = ty::lookup_item_type(self.tcx(), def_id);\n \n                 // All type parameters on enums and structs should be\n@@ -924,7 +924,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     variance);\n             }\n \n-            ty::ty_projection(ref data) => {\n+            ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n                 let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n                 self.add_constraints_from_substs(\n@@ -936,7 +936,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     variance);\n             }\n \n-            ty::ty_trait(ref data) => {\n+            ty::TyTrait(ref data) => {\n                 let poly_trait_ref =\n                     data.principal_trait_ref_with_self_ty(self.tcx(),\n                                                           self.tcx().types.err);\n@@ -955,7 +955,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::ty_param(ref data) => {\n+            ty::TyParam(ref data) => {\n                 let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.get(&def_id.node) {\n@@ -970,16 +970,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::ty_bare_fn(_, &ty::BareFnTy { ref sig, .. }) => {\n+            ty::TyBareFn(_, &ty::BareFnTy { ref sig, .. }) => {\n                 self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n-            ty::ty_err => {\n+            ty::TyError => {\n                 // we encounter this when walking the trait references for object\n-                // types, where we use ty_err as the Self type\n+                // types, where we use TyError as the Self type\n             }\n \n-            ty::ty_infer(..) => {\n+            ty::TyInfer(..) => {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\","}, {"sha": "53063c6247efb8e21ab16f359e89e74624305659", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -167,7 +167,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n     let t = ty::lookup_item_type(tcx, did);\n     let (decl, style, abi) = match t.ty.sty {\n-        ty::ty_bare_fn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n+        ty::TyBareFn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n     let predicates = ty::lookup_predicates(tcx, did);\n@@ -204,7 +204,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n     let t = ty::lookup_item_type(tcx, did);\n     let predicates = ty::lookup_predicates(tcx, did);\n     match t.ty.sty {\n-        ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n+        ty::TyEnum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,"}, {"sha": "920902e19c8232ed31f1caa28ded118be18e6c82", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -579,7 +579,6 @@ impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBound\n \n fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n                         bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n-    use rustc::middle::ty::sty;\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n@@ -591,7 +590,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n         (Some(did), Some(ref tcx)) if tcx.lang_items.fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n-                sty::ty_tup(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n                     return PathParameters::AngleBracketed {\n                         lifetimes: lifetimes,\n@@ -603,7 +602,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n             // match types[1].sty {\n-            //     sty::ty_tup(ref v) if v.is_empty() => None, // -> ()\n+            //     ty::TyTuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n             PathParameters::Parenthesized {\n@@ -691,11 +690,10 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         // collect any late bound regions\n         let mut late_bounds = vec![];\n         for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace) {\n-            use rustc::middle::ty::{Region, sty};\n-            if let sty::ty_tup(ref ts) = ty_s.sty {\n+            if let ty::TyTuple(ref ts) = ty_s.sty {\n                 for &ty_s in ts {\n-                    if let sty::ty_rptr(ref reg, _) = ty_s.sty {\n-                        if let &Region::ReLateBound(_, _) = *reg {\n+                    if let ty::TyRef(ref reg, _) = ty_s.sty {\n+                        if let &ty::Region::ReLateBound(_, _) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n                                 late_bounds.push(lt)\n@@ -1326,7 +1324,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n                     ty::ByValueExplicitSelfCategory => SelfValue,\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n                         match self.fty.sig.0.inputs[0].sty {\n-                            ty::ty_rptr(r, mt) => {\n+                            ty::TyRef(r, mt) => {\n                                 SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n                             }\n                             _ => unreachable!(),\n@@ -1633,37 +1631,37 @@ impl Clean<Type> for ast::Ty {\n impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match self.sty {\n-            ty::ty_bool => Primitive(Bool),\n-            ty::ty_char => Primitive(Char),\n-            ty::ty_int(ast::TyIs) => Primitive(Isize),\n-            ty::ty_int(ast::TyI8) => Primitive(I8),\n-            ty::ty_int(ast::TyI16) => Primitive(I16),\n-            ty::ty_int(ast::TyI32) => Primitive(I32),\n-            ty::ty_int(ast::TyI64) => Primitive(I64),\n-            ty::ty_uint(ast::TyUs) => Primitive(Usize),\n-            ty::ty_uint(ast::TyU8) => Primitive(U8),\n-            ty::ty_uint(ast::TyU16) => Primitive(U16),\n-            ty::ty_uint(ast::TyU32) => Primitive(U32),\n-            ty::ty_uint(ast::TyU64) => Primitive(U64),\n-            ty::ty_float(ast::TyF32) => Primitive(F32),\n-            ty::ty_float(ast::TyF64) => Primitive(F64),\n-            ty::ty_str => Primitive(Str),\n-            ty::ty_uniq(t) => {\n+            ty::TyBool => Primitive(Bool),\n+            ty::TyChar => Primitive(Char),\n+            ty::TyInt(ast::TyIs) => Primitive(Isize),\n+            ty::TyInt(ast::TyI8) => Primitive(I8),\n+            ty::TyInt(ast::TyI16) => Primitive(I16),\n+            ty::TyInt(ast::TyI32) => Primitive(I32),\n+            ty::TyInt(ast::TyI64) => Primitive(I64),\n+            ty::TyUint(ast::TyUs) => Primitive(Usize),\n+            ty::TyUint(ast::TyU8) => Primitive(U8),\n+            ty::TyUint(ast::TyU16) => Primitive(U16),\n+            ty::TyUint(ast::TyU32) => Primitive(U32),\n+            ty::TyUint(ast::TyU64) => Primitive(U64),\n+            ty::TyFloat(ast::TyF32) => Primitive(F32),\n+            ty::TyFloat(ast::TyF64) => Primitive(F64),\n+            ty::TyStr => Primitive(Str),\n+            ty::TyBox(t) => {\n                 let box_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.owned_box()\n                 });\n                 lang_struct(cx, box_did, t, \"Box\", Unique)\n             }\n-            ty::ty_vec(ty, None) => Vector(box ty.clean(cx)),\n-            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(cx),\n+            ty::TyArray(ty, None) => Vector(box ty.clean(cx)),\n+            ty::TyArray(ty, Some(i)) => FixedVector(box ty.clean(cx),\n                                                    format!(\"{}\", i)),\n-            ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n-            ty::ty_rptr(r, mt) => BorrowedRef {\n+            ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n+            ty::TyRef(r, mt) => BorrowedRef {\n                 lifetime: r.clean(cx),\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::ty_bare_fn(_, ref fty) => BareFunction(box BareFunctionDecl {\n+            ty::TyBareFn(_, ref fty) => BareFunction(box BareFunctionDecl {\n                 unsafety: fty.unsafety,\n                 generics: Generics {\n                     lifetimes: Vec::new(),\n@@ -1673,12 +1671,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n-            ty::ty_struct(did, substs) |\n-            ty::ty_enum(did, substs) => {\n+            ty::TyStruct(did, substs) |\n+            ty::TyEnum(did, substs) => {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {\n-                    ty::ty_struct(..) => TypeStruct,\n+                    ty::TyStruct(..) => TypeStruct,\n                     _ => TypeEnum,\n                 };\n                 let path = external_path(cx, &fqn.last().unwrap().to_string(),\n@@ -1691,7 +1689,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+            ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n                 let did = principal.def_id();\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n@@ -1706,16 +1704,16 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n+            ty::TyTuple(ref t) => Tuple(t.clean(cx)),\n \n-            ty::ty_projection(ref data) => data.clean(cx),\n+            ty::TyProjection(ref data) => data.clean(cx),\n \n-            ty::ty_param(ref p) => Generic(token::get_name(p.name).to_string()),\n+            ty::TyParam(ref p) => Generic(token::get_name(p.name).to_string()),\n \n-            ty::ty_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::TyClosure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n-            ty::ty_infer(..) => panic!(\"ty_infer\"),\n-            ty::ty_err => panic!(\"ty_err\"),\n+            ty::TyInfer(..) => panic!(\"TyInfer\"),\n+            ty::TyError => panic!(\"TyError\"),\n         }\n     }\n }"}, {"sha": "7d82e79f949110d03efc1396b2845685c8b4393c", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -34,54 +34,54 @@ pub mod testtypes {\n \n     // Skipping ty_bot\n \n-    // Tests ty_bool\n+    // Tests TyBool\n     pub type FooBool = bool;\n \n-    // Tests ty_char\n+    // Tests TyChar\n     pub type FooChar = char;\n \n-    // Tests ty_int (does not test all variants of IntTy)\n+    // Tests TyInt (does not test all variants of IntTy)\n     pub type FooInt = isize;\n \n-    // Tests ty_uint (does not test all variants of UintTy)\n+    // Tests TyUint (does not test all variants of UintTy)\n     pub type FooUint = usize;\n \n-    // Tests ty_float (does not test all variants of FloatTy)\n+    // Tests TyFloat (does not test all variants of FloatTy)\n     pub type FooFloat = f64;\n \n-    // For ty_str, what kind of string should I use? &'static str? String? Raw str?\n+    // For TyStr, what kind of string should I use? &'static str? String? Raw str?\n \n-    // Tests ty_enum\n+    // Tests TyEnum\n     pub enum FooEnum {\n         VarA(usize),\n         VarB(usize, usize)\n     }\n \n-    // Tests ty_uniq (of u8)\n+    // Tests TyBox (of u8)\n     pub type FooUniq = Box<u8>;\n \n-    // As with ty_str, what type should be used for ty_vec?\n+    // As with TyStr, what type should be used for TyArray?\n \n-    // Tests ty_ptr\n+    // Tests TyRawPtr\n     pub type FooPtr = *const u8;\n \n-    // Skipping ty_rptr\n+    // Skipping TyRef\n \n-    // Skipping ty_bare_fn (how do you get a bare function type, rather than proc or closure?)\n+    // Skipping TyBareFn (how do you get a bare function type, rather than proc or closure?)\n \n-    // Tests ty_trait\n+    // Tests TyTrait\n     pub trait FooTrait {\n         fn foo_method(&self) -> usize;\n         fn foo_static_method() -> usize;\n     }\n \n-    // Tests ty_struct\n+    // Tests TyStruct\n     pub struct FooStruct {\n         pub pub_foo_field: usize,\n         foo_field: usize\n     }\n \n-    // Tests ty_tup\n+    // Tests TyTuple\n     pub type FooTuple = (u8, i8, bool);\n \n     // Skipping ty_param\n@@ -90,7 +90,7 @@ pub mod testtypes {\n \n     // Skipping ty_self\n \n-    // Skipping ty_infer\n+    // Skipping TyInfer\n \n-    // Skipping ty_err\n+    // Skipping TyError\n }"}, {"sha": "30c45fc766a12863ade944eedf964604d6aaacb8", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c69db4c3c8039ccd313188fa2d0f0d83bba6914/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=3c69db4c3c8039ccd313188fa2d0f0d83bba6914", "patch": "@@ -12,7 +12,7 @@\n //\n //    error: internal compiler error: get_unique_type_id_of_type() -\n //    unexpected type: closure,\n-//    ty_closure(syntax::ast::DefId{krate: 0, node: 66},\n+//    TyClosure(syntax::ast::DefId{krate: 0, node: 66},\n //    ReScope(63))\n //\n // This is a regression test for issue #17021."}]}