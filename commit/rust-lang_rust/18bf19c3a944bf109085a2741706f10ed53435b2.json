{"sha": "18bf19c3a944bf109085a2741706f10ed53435b2", "node_id": "C_kwDOAAsO6NoAKDE4YmYxOWMzYTk0NGJmMTA5MDg1YTI3NDE3MDZmMTBlZDUzNDM1YjI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T20:33:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-27T20:33:35Z"}, "message": "Rollup merge of #106064 - lukas-code:outlives-macro, r=cjgillot\n\nPartially fix `explicit_outlives_requirements` lint in macros\n\nShow the suggestion if and only if the bounds are from the same source context.\n\nfixes https://github.com/rust-lang/rust/issues/106044\nfixes https://github.com/rust-lang/rust/issues/106063", "tree": {"sha": "6f039b373263bf6c8055d219d2235b2398397eca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f039b373263bf6c8055d219d2235b2398397eca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18bf19c3a944bf109085a2741706f10ed53435b2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjq1afCRBK7hj4Ov3rIwAAuBwIAFWzmNv0ePG4LhOJadldkitM\nNlHZMTMsiKVWEZl4kQUehdvuCTyK1ik27xG5xUMd4WdEdxu10VYmSWMy6k+22eDg\nd5oNtAv6Q0MlLXm+ErKdMnyifjjAW2JtnjkwxYa3TEtwQk1alnexMcVYzUo/lzZN\n8VwDbghxIJHP88nGY4VmXFNuFT8pvqBGNy3VdNL0C7h5rSqJ2NiGUKpZcKOISxWN\nyQJEDhlMeukY10kWz4IGpnuST078k+/HM6qyQYdtnfXJLCn2M6M7LsHujkcNWA8+\noXudr+W4SD/lGlm4GgPJMJjXdN9ZtG50UIAyt8s1LAs6SfaJNzeXx/znes6qdgU=\n=evt/\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f039b373263bf6c8055d219d2235b2398397eca\nparent 3fba7b452381f6f807dab4f5970a4b67957c0564\nparent 1eba6c404fa3e64607fc3826214bd61ae10fa5bb\nauthor Michael Goulet <michael@errs.io> 1672173215 -0800\ncommitter GitHub <noreply@github.com> 1672173215 -0800\n\nRollup merge of #106064 - lukas-code:outlives-macro, r=cjgillot\n\nPartially fix `explicit_outlives_requirements` lint in macros\n\nShow the suggestion if and only if the bounds are from the same source context.\n\nfixes https://github.com/rust-lang/rust/issues/106044\nfixes https://github.com/rust-lang/rust/issues/106063\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18bf19c3a944bf109085a2741706f10ed53435b2", "html_url": "https://github.com/rust-lang/rust/commit/18bf19c3a944bf109085a2741706f10ed53435b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18bf19c3a944bf109085a2741706f10ed53435b2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fba7b452381f6f807dab4f5970a4b67957c0564", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fba7b452381f6f807dab4f5970a4b67957c0564", "html_url": "https://github.com/rust-lang/rust/commit/3fba7b452381f6f807dab4f5970a4b67957c0564"}, {"sha": "1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "html_url": "https://github.com/rust-lang/rust/commit/1eba6c404fa3e64607fc3826214bd61ae10fa5bb"}], "stats": {"total": 546, "additions": 458, "deletions": 88}, "files": [{"sha": "b6b242bfc27fcc371e6bb19e93bbcd91d1e7faec", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -1316,6 +1316,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 param.id,\n                 &param.kind,\n                 &param.bounds,\n+                param.colon_span,\n+                generics.span,\n                 itctx,\n                 PredicateOrigin::GenericParam,\n             )\n@@ -1365,6 +1367,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: &GenericParamKind,\n         bounds: &[GenericBound],\n+        colon_span: Option<Span>,\n+        parent_span: Span,\n         itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n@@ -1377,21 +1381,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n-        let span = bounds\n-            .iter()\n-            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n-                let bound_span = bound.span();\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound_span.can_be_used_for_suggestions() {\n-                    None\n-                } else if let Some(span) = span {\n-                    Some(span.to(bound_span))\n-                } else {\n-                    Some(bound_span)\n-                }\n-            })\n-            .unwrap_or(param_span.shrink_to_hi());\n+\n+        // Reconstruct the span of the entire predicate from the individual generic bounds.\n+        let span_start = colon_span.unwrap_or_else(|| param_span.shrink_to_hi());\n+        let span = bounds.iter().fold(span_start, |span_accum, bound| {\n+            match bound.span().find_ancestor_inside(parent_span) {\n+                Some(bound_span) => span_accum.to(bound_span),\n+                None => span_accum,\n+            }\n+        });\n+        let span = self.lower_span(span);\n+\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {"}, {"sha": "1fbc45a58e5687917a14a2e0a655aeeaaf6b571b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -2245,14 +2245,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> (hir::GenericParam<'hir>, Option<hir::WherePredicate<'hir>>, hir::TyKind<'hir>) {\n         // Add a definition for the in-band `Param`.\n         let def_id = self.local_def_id(node_id);\n+        let span = self.lower_span(span);\n \n         // Set the name to `impl Bound1 + Bound2`.\n         let param = hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             def_id,\n             name: ParamName::Plain(self.lower_ident(ident)),\n             pure_wrt_drop: false,\n-            span: self.lower_span(span),\n+            span,\n             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n             colon_span: None,\n         };\n@@ -2262,6 +2263,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             node_id,\n             &GenericParamKind::Type { default: None },\n             bounds,\n+            /* colon_span */ None,\n+            span,\n             &ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n@@ -2271,7 +2274,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ty = hir::TyKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n-                span: self.lower_span(span),\n+                span,\n                 res,\n                 segments:\n                     arena_vec![self; hir::PathSegment::new(self.lower_ident(ident), hir_id, res)],"}, {"sha": "cdb901b7f8603b65329e31ff6e14e7385db6c222", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -2184,30 +2184,36 @@ impl ExplicitOutlivesRequirements {\n         tcx: TyCtxt<'tcx>,\n         bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n+        predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         bounds\n             .iter()\n             .enumerate()\n             .filter_map(|(i, bound)| {\n-                if let hir::GenericBound::Outlives(lifetime) = bound {\n-                    let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r {\n-                                ebr.def_id == def_id\n-                            } else {\n-                                false\n-                            }\n-                        }),\n-                        _ => false,\n-                    };\n-                    is_inferred.then_some((i, bound.span()))\n-                } else {\n-                    None\n+                let hir::GenericBound::Outlives(lifetime) = bound else {\n+                    return None;\n+                };\n+\n+                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n+                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                        .iter()\n+                        .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n+                    _ => false,\n+                };\n+\n+                if !is_inferred {\n+                    return None;\n                 }\n+\n+                let span = bound.span().find_ancestor_inside(predicate_span)?;\n+                if in_external_macro(tcx.sess, span) {\n+                    return None;\n+                }\n+\n+                Some((i, span))\n             })\n-            .filter(|(_, span)| !in_external_macro(tcx.sess, *span))\n             .collect()\n     }\n \n@@ -2273,9 +2279,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let def_id = item.owner_id.def_id;\n-        if let hir::ItemKind::Struct(_, ref hir_generics)\n-        | hir::ItemKind::Enum(_, ref hir_generics)\n-        | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n+        if let hir::ItemKind::Struct(_, hir_generics)\n+        | hir::ItemKind::Enum(_, hir_generics)\n+        | hir::ItemKind::Union(_, hir_generics) = item.kind\n         {\n             let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n             if inferred_outlives.is_empty() {\n@@ -2290,53 +2296,58 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             let mut dropped_predicate_count = 0;\n             let num_predicates = hir_generics.predicates.len();\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n-                let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n-                    hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(region_def_id)) =\n-                            cx.tcx.named_region(predicate.lifetime.hir_id)\n-                        {\n-                            (\n-                                Self::lifetimes_outliving_lifetime(\n-                                    inferred_outlives,\n-                                    region_def_id,\n-                                ),\n-                                &predicate.bounds,\n-                                predicate.span,\n-                                predicate.in_where_clause,\n-                            )\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-                    hir::WherePredicate::BoundPredicate(predicate) => {\n-                        // FIXME we can also infer bounds on associated types,\n-                        // and should check for them here.\n-                        match predicate.bounded_ty.kind {\n-                            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                                let Res::Def(DefKind::TyParam, def_id) = path.res else {\n-                                    continue\n-                                };\n-                                let index = ty_generics.param_def_id_to_index[&def_id];\n+                let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n+                    match where_predicate {\n+                        hir::WherePredicate::RegionPredicate(predicate) => {\n+                            if let Some(Region::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            {\n                                 (\n-                                    Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                    Self::lifetimes_outliving_lifetime(\n+                                        inferred_outlives,\n+                                        region_def_id,\n+                                    ),\n                                     &predicate.bounds,\n                                     predicate.span,\n-                                    predicate.origin == PredicateOrigin::WhereClause,\n+                                    predicate.in_where_clause,\n                                 )\n-                            }\n-                            _ => {\n+                            } else {\n                                 continue;\n                             }\n                         }\n-                    }\n-                    _ => continue,\n-                };\n+                        hir::WherePredicate::BoundPredicate(predicate) => {\n+                            // FIXME we can also infer bounds on associated types,\n+                            // and should check for them here.\n+                            match predicate.bounded_ty.kind {\n+                                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n+                                    let Res::Def(DefKind::TyParam, def_id) = path.res else {\n+                                    continue;\n+                                };\n+                                    let index = ty_generics.param_def_id_to_index[&def_id];\n+                                    (\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        &predicate.bounds,\n+                                        predicate.span,\n+                                        predicate.origin == PredicateOrigin::WhereClause,\n+                                    )\n+                                }\n+                                _ => {\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                        _ => continue,\n+                    };\n                 if relevant_lifetimes.is_empty() {\n                     continue;\n                 }\n \n-                let bound_spans =\n-                    self.collect_outlives_bound_spans(cx.tcx, bounds, &relevant_lifetimes);\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx.tcx,\n+                    bounds,\n+                    &relevant_lifetimes,\n+                    predicate_span,\n+                );\n                 bound_count += bound_spans.len();\n \n                 let drop_predicate = bound_spans.len() == bounds.len();\n@@ -2345,15 +2356,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 }\n \n                 if drop_predicate && !in_where_clause {\n-                    lint_spans.push(span);\n+                    lint_spans.push(predicate_span);\n                 } else if drop_predicate && i + 1 < num_predicates {\n                     // If all the bounds on a predicate were inferable and there are\n                     // further predicates, we want to eat the trailing comma.\n                     let next_predicate_span = hir_generics.predicates[i + 1].span();\n-                    where_lint_spans.push(span.to(next_predicate_span.shrink_to_lo()));\n+                    where_lint_spans.push(predicate_span.to(next_predicate_span.shrink_to_lo()));\n                 } else {\n                     where_lint_spans.extend(self.consolidate_outlives_bound_spans(\n-                        span.shrink_to_lo(),\n+                        predicate_span.shrink_to_lo(),\n                         bounds,\n                         bound_spans,\n                     ));\n@@ -2374,24 +2385,35 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     } else {\n                         hir_generics.span.shrink_to_hi().to(where_span)\n                     };\n-                lint_spans.push(full_where_span);\n+\n+                // Due to macro expansions, the `full_where_span` might not actually contain all predicates.\n+                if where_lint_spans.iter().all(|&sp| full_where_span.contains(sp)) {\n+                    lint_spans.push(full_where_span);\n+                } else {\n+                    lint_spans.extend(where_lint_spans);\n+                }\n             } else {\n                 lint_spans.extend(where_lint_spans);\n             }\n \n             if !lint_spans.is_empty() {\n+                // Do not automatically delete outlives requirements from macros.\n+                let applicability = if lint_spans.iter().all(|sp| sp.can_be_used_for_suggestions())\n+                {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+\n                 cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n                     fluent::lint_builtin_explicit_outlives,\n                     |lint| {\n                         lint.set_arg(\"count\", bound_count).multipart_suggestion(\n                             fluent::suggestion,\n-                            lint_spans\n-                                .into_iter()\n-                                .map(|span| (span, String::new()))\n-                                .collect::<Vec<_>>(),\n-                            Applicability::MachineApplicable,\n+                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                            applicability,\n                         )\n                     },\n                 );"}, {"sha": "bee4b0a2332b55022ef570f0a6cb102b93de9b92", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -796,6 +796,9 @@ impl Span {\n \n     /// Returns a `Span` that would enclose both `self` and `end`.\n     ///\n+    /// Note that this can also be used to extend the span \"backwards\":\n+    /// `start.to(end)` and `end.to(start)` return the same `Span`.\n+    ///\n     /// ```text\n     ///     ____             ___\n     ///     self lorem ipsum end"}, {"sha": "8cdb08e81b907510778ca216879214f4a7df3990", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.fixed", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -0,0 +1,137 @@\n+// edition:2018\n+// aux-build:edition-lint-infer-outlives-macro.rs\n+// run-rustfix\n+\n+#![deny(explicit_outlives_requirements)]\n+#![allow(dead_code)]\n+\n+#[macro_use]\n+extern crate edition_lint_infer_outlives_macro;\n+\n+// Test that the lint does not fire if the predicate is from the local crate,\n+// but all the bounds are from an external macro.\n+macro_rules! make_foo {\n+    ($a:tt) => {\n+        struct Foo<$a, 'b: $a> {\n+            foo: &$a &'b (),\n+        }\n+\n+        struct FooWhere<$a, 'b> where 'b: $a {\n+            foo: &$a &'b (),\n+        }\n+    }\n+}\n+\n+gimme_a! {make_foo!}\n+\n+struct Bar<'a, 'b> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+struct BarWhere<'a, 'b> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+// Test that the lint *does* fire if the predicate is contained in a local macro.\n+mod everything_inside {\n+    macro_rules! m {\n+        ('b: 'a) => {\n+            struct Foo<'a, 'b>(&'a &'b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, 'b>(&'a &'b ()) ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        };\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod inner_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: 'a) => {\n+            struct Foo<'a, $b>(&'a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, $b>(&'a &$b ()) ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, $b>(&'a &$b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod outer_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ('b: $a:lifetime) => {\n+            struct Foo<$a, 'b: $a>(&$a &'b ());\n+            struct Bar<$a, 'b>(&$a &'b ()) where 'b: $a;\n+            struct Baz<$a, 'b>(&$a &'b ()) where (): Sized, 'b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod both_lifetimes_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: $a:lifetime) => {\n+            struct Foo<$a, $b: $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b: $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_inner {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+// FIXME: These should be consistent.\n+mod everything_outside_with_tt_outer {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:tt) => {\n+            struct Foo<$a, $b >(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_both {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:tt) => {\n+            struct Foo<$a, $b >(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+fn main() {}"}, {"sha": "647906c2dc228366e713dc40217f98e907d5a8b1", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.rs", "status": "modified", "additions": 114, "deletions": 5, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -1,18 +1,22 @@\n // edition:2018\n // aux-build:edition-lint-infer-outlives-macro.rs\n-\n-// Test that the lint does not fire if the where predicate\n-// is from the local crate, but all the bounds are from an\n-// external macro.\n+// run-rustfix\n \n #![deny(explicit_outlives_requirements)]\n+#![allow(dead_code)]\n \n #[macro_use]\n extern crate edition_lint_infer_outlives_macro;\n \n+// Test that the lint does not fire if the predicate is from the local crate,\n+// but all the bounds are from an external macro.\n macro_rules! make_foo {\n     ($a:tt) => {\n-        struct Foo<$a, 'b> where 'b: $a {\n+        struct Foo<$a, 'b: $a> {\n+            foo: &$a &'b (),\n+        }\n+\n+        struct FooWhere<$a, 'b> where 'b: $a {\n             foo: &$a &'b (),\n         }\n     }\n@@ -25,4 +29,109 @@ struct Bar<'a, 'b: 'a> {\n     bar: &'a &'b (),\n }\n \n+struct BarWhere<'a, 'b> where 'b: 'a {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+// Test that the lint *does* fire if the predicate is contained in a local macro.\n+mod everything_inside {\n+    macro_rules! m {\n+        ('b: 'a) => {\n+            struct Foo<'a, 'b: 'a>(&'a &'b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, 'b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        };\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod inner_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: 'a) => {\n+            struct Foo<'a, $b: 'a>(&'a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, $b>(&'a &$b ()) where $b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, $b>(&'a &$b ()) where (): Sized, $b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod outer_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ('b: $a:lifetime) => {\n+            struct Foo<$a, 'b: $a>(&$a &'b ());\n+            struct Bar<$a, 'b>(&$a &'b ()) where 'b: $a;\n+            struct Baz<$a, 'b>(&$a &'b ()) where (): Sized, 'b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod both_lifetimes_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: $a:lifetime) => {\n+            struct Foo<$a, $b: $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b: $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_inner {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+// FIXME: These should be consistent.\n+mod everything_outside_with_tt_outer {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:tt) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_both {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:tt) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n fn main() {}"}, {"sha": "734ae687978936e022a177b7be164aee75d60f4a", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.stderr", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/18bf19c3a944bf109085a2741706f10ed53435b2/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18bf19c3a944bf109085a2741706f10ed53435b2/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr?ref=18bf19c3a944bf109085a2741706f10ed53435b2", "patch": "@@ -1,14 +1,110 @@\n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:23:18\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:27:18\n    |\n LL | struct Bar<'a, 'b: 'a> {\n    |                  ^^^^ help: remove this bound\n    |\n note: the lint level is defined here\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:8:9\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:5:9\n    |\n LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:32:24\n+   |\n+LL | struct BarWhere<'a, 'b> where 'b: 'a {\n+   |                        ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:41:30\n+   |\n+LL |             struct Foo<'a, 'b: 'a>(&'a &'b ());\n+   |                              ^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:43:44\n+   |\n+LL |             struct Bar<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+   |                                            ^^^^^^^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:45:61\n+   |\n+LL |             struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, 'b: 'a;\n+   |                                                             ^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:55:30\n+   |\n+LL |             struct Foo<'a, $b: 'a>(&'a &$b ());\n+   |                              ^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:57:44\n+   |\n+LL |             struct Bar<'a, $b>(&'a &$b ()) where $b: 'a;\n+   |                                            ^^^^^^^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:59:61\n+   |\n+LL |             struct Baz<'a, $b>(&'a &$b ()) where (): Sized, $b: 'a;\n+   |                                                             ^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:114:31\n+   |\n+LL |             struct Foo<$a, $b $colon $a>(&$a &$b ());\n+   |                               ^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:126:31\n+   |\n+LL |             struct Foo<$a, $b $colon $a>(&$a &$b ());\n+   |                               ^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:128:50\n+   |\n+LL |             struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+   |                                                  ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:130:61\n+   |\n+LL |             struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+   |                                                             ^^^^^^^^^^^^ help: remove this bound\n+\n+error: aborting due to 12 previous errors\n "}]}