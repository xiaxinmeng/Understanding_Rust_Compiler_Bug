{"sha": "c267821742ab7f9207a8e594d53150ad41ad0d7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNjc4MjE3NDJhYjdmOTIwN2E4ZTU5NGQ1MzE1MGFkNDFhZDBkN2I=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-01-20T01:56:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-01-20T02:04:25Z"}, "message": "rustc: \";\" to \",\" in enums", "tree": {"sha": "19af34d604ea21cd82bfd51df40427edc6daf22e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19af34d604ea21cd82bfd51df40427edc6daf22e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c267821742ab7f9207a8e594d53150ad41ad0d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c267821742ab7f9207a8e594d53150ad41ad0d7b", "html_url": "https://github.com/rust-lang/rust/commit/c267821742ab7f9207a8e594d53150ad41ad0d7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c267821742ab7f9207a8e594d53150ad41ad0d7b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "194d8e3bd55021a2f0e6d61c2bdc2c0b2017f58f", "url": "https://api.github.com/repos/rust-lang/rust/commits/194d8e3bd55021a2f0e6d61c2bdc2c0b2017f58f", "html_url": "https://github.com/rust-lang/rust/commit/194d8e3bd55021a2f0e6d61c2bdc2c0b2017f58f"}], "stats": {"total": 900, "additions": 450, "deletions": 450}, "files": [{"sha": "f8253a0152277d01ac60d852553609e3da14c4ae", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -23,12 +23,12 @@ import lib::llvm::False;\n import util::filesearch;\n \n enum output_type {\n-    output_type_none;\n-    output_type_bitcode;\n-    output_type_assembly;\n-    output_type_llvm_assembly;\n-    output_type_object;\n-    output_type_exe;\n+    output_type_none,\n+    output_type_bitcode,\n+    output_type_assembly,\n+    output_type_llvm_assembly,\n+    output_type_object,\n+    output_type_exe,\n }\n \n fn llvm_err(sess: session, msg: str) unsafe {"}, {"sha": "0694a357f1b42f529b16671ed528c1ee9eed871c", "filename": "src/comp/driver/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdiagnostic.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -108,10 +108,10 @@ fn mk_handler(cm: codemap::codemap,\n }\n \n enum level {\n-    fatal;\n-    error;\n-    warning;\n-    note;\n+    fatal,\n+    error,\n+    warning,\n+    note,\n }\n \n fn diagnosticstr(lvl: level) -> str {"}, {"sha": "be303c5aaa07c549032685b69a7e63a6f37a9e7c", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -18,7 +18,7 @@ import option::{some, none};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n \n-enum pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n+enum pp_mode { ppm_normal, ppm_expanded, ppm_typed, ppm_identified, }\n \n fn default_configuration(sess: session, argv0: str, input: str) ->\n    ast::crate_cfg {\n@@ -131,11 +131,11 @@ fn inject_libcore_reference(sess: session,\n }\n \n enum compile_upto {\n-    cu_parse;\n-    cu_expand;\n-    cu_typeck;\n-    cu_no_trans;\n-    cu_everything;\n+    cu_parse,\n+    cu_expand,\n+    cu_typeck,\n+    cu_no_trans,\n+    cu_everything,\n }\n \n fn compile_upto(sess: session, cfg: ast::crate_cfg,"}, {"sha": "4ab6b3491ad191e88859388fb3c61f51519ad81e", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -128,8 +128,8 @@ bug and need to present an error.\n */\n fn monitor(f: fn~(diagnostic::emitter)) {\n     enum monitor_msg {\n-        fatal;\n-        done;\n+        fatal,\n+        done,\n     };\n \n     let p = comm::port();"}, {"sha": "29da628fa12aa24c640de5baaeaf29b6ba3d99af", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -10,11 +10,11 @@ import util::filesearch;\n import back::target_strs;\n import middle::lint;\n \n-enum os { os_win32; os_macos; os_linux; os_freebsd; }\n+enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n-enum arch { arch_x86; arch_x86_64; arch_arm; }\n+enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n-enum crate_type { bin_crate; lib_crate; unknown_crate; }\n+enum crate_type { bin_crate, lib_crate, unknown_crate, }\n \n type config =\n     {os: os,"}, {"sha": "44076ab60b89fc28fabadb081916a0edd8f9a0ab", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -40,7 +40,7 @@ type crate_metadata = @{name: str,\n // other modules to access the cstore's private data. This could also be\n // achieved with an obj, but at the expense of a vtable. Not sure if this is a\n // good pattern or not.\n-enum cstore { private(cstore_private); }\n+enum cstore { private(cstore_private), }\n \n type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,"}, {"sha": "131ca9dd67e51e2ad290f3ed1ad77a92eb570b1f", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -25,7 +25,7 @@ type ctxt =\n // Whatever format you choose should not contain pipe characters.\n type ty_abbrev = {pos: uint, len: uint, s: @str};\n \n-enum abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n+enum abbrev_ctxt { ac_no_abbrevs, ac_use_abbrevs(hashmap<ty::t, ty_abbrev>), }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     alt cx.abbrevs {"}, {"sha": "d2c75bc182e5899509e383569eae5bf8a827aae0", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -15,13 +15,13 @@ import pat_util::*;\n // getting input from one, to be more precise). It is a pass that checks\n // whether aliases are used in a safe way.\n \n-enum copied { not_allowed; copied; not_copied; }\n-enum invalid_reason { overwritten; val_taken; }\n+enum copied { not_allowed, copied, not_copied, }\n+enum invalid_reason { overwritten, val_taken, }\n type invalid = {reason: invalid_reason,\n                 node_id: node_id,\n                 sp: span, path: @ast::path};\n \n-enum unsafe_ty { contains(ty::t); mut_contains(ty::t); }\n+enum unsafe_ty { contains(ty::t), mut_contains(ty::t), }\n \n type binding = @{node_id: node_id,\n                  span: span,\n@@ -46,7 +46,7 @@ fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n           mutable copied: not_copied};\n }\n \n-enum local_info { local(uint); }\n+enum local_info { local(uint), }\n \n type copy_map = std::map::hashmap<node_id, ()>;\n type ref_map = std::map::hashmap<node_id, node_id>;"}, {"sha": "58c6bfc29142a66d9c00a3ec3507f9ae3893f623", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -5,15 +5,15 @@ import syntax::ast_util;\n import syntax::{visit, codemap};\n \n enum ast_node {\n-    node_item(@item);\n-    node_native_item(@native_item);\n-    node_method(@method);\n-    node_expr(@expr);\n+    node_item(@item),\n+    node_native_item(@native_item),\n+    node_method(@method),\n+    node_expr(@expr),\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n-    node_arg(arg, uint);\n-    node_local(uint);\n-    node_res_ctor(@item);\n+    node_arg(arg, uint),\n+    node_local(uint),\n+    node_res_ctor(@item),\n }\n \n type map = std::map::map<node_id, ast_node>;"}, {"sha": "c32623b30b1e9da71e106ef0cfd15c3d338015c3", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -13,10 +13,10 @@ export cap_drop;\n export cap_ref;\n \n enum capture_mode {\n-    cap_copy; //< Copy the value into the closure.\n-    cap_move; //< Move the value into the closure.\n-    cap_drop; //< Drop value after creating closure.\n-    cap_ref;  //< Reference directly from parent stack frame (block fn).\n+    cap_copy, //< Copy the value into the closure.\n+    cap_move, //< Move the value into the closure.\n+    cap_drop, //< Drop value after creating closure.\n+    cap_ref,  //< Reference directly from parent stack frame (block fn).\n }\n \n type capture_var = {"}, {"sha": "cfde53fa820b5dca3c07ad95b94df177a887f09f", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -109,14 +109,14 @@ type retval_md = {id: ast::node_id};\n type metadata_cache = hashmap<int, [debug_metadata]>;\n \n enum debug_metadata {\n-    file_metadata(@metadata<file_md>);\n-    compile_unit_metadata(@metadata<compile_unit_md>);\n-    subprogram_metadata(@metadata<subprogram_md>);\n-    local_var_metadata(@metadata<local_var_md>);\n-    tydesc_metadata(@metadata<tydesc_md>);\n-    block_metadata(@metadata<block_md>);\n-    argument_metadata(@metadata<argument_md>);\n-    retval_metadata(@metadata<retval_md>);\n+    file_metadata(@metadata<file_md>),\n+    compile_unit_metadata(@metadata<compile_unit_md>),\n+    subprogram_metadata(@metadata<subprogram_md>),\n+    local_var_metadata(@metadata<local_var_md>),\n+    tydesc_metadata(@metadata<tydesc_md>),\n+    block_metadata(@metadata<block_md>),\n+    argument_metadata(@metadata<argument_md>),\n+    retval_metadata(@metadata<retval_md>),\n }\n \n fn cast_safely<T: copy, U>(val: T) -> U unsafe {"}, {"sha": "60b8bfd9879146d2d797b1edab0d02a5274b759d", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -26,8 +26,8 @@ import std::list;\n // Marks expr_paths that are last uses.\n type last_uses = std::map::hashmap<node_id, ()>;\n \n-enum seen { unset; seen(node_id); }\n-enum block_type { func; loop; }\n+enum seen { unset, seen(node_id), }\n+enum block_type { func, loop, }\n \n type set = [{def: node_id, exprs: list<node_id>}];\n type bl = @{type: block_type, mutable second: bool, mutable exits: [set]};"}, {"sha": "e81759061ae75f3bd24b06291ef6cf922291c6f5", "filename": "src/comp/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flint.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -5,7 +5,7 @@ import syntax::{ast, visit};\n type crate_ctxt = {tcx: ty::ctxt};\n \n enum option {\n-    ctypes;\n+    ctypes,\n }\n \n fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {"}, {"sha": "f97b1eda673bb54fc4ebc17f6d0a09fdd1b47755", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -5,7 +5,7 @@ import syntax::visit;\n import syntax::ast_util;\n import driver::session::session;\n \n-enum deref_t { unbox; field; index; }\n+enum deref_t { unbox, field, index, }\n \n type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n \n@@ -121,7 +121,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) -> mut_map {\n     ret cx.mut_map;\n }\n \n-enum msg { msg_assign; msg_move_out; msg_mut_ref; }\n+enum msg { msg_assign, msg_move_out, msg_mut_ref, }\n \n fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span, alt msg {"}, {"sha": "34fb2a86630be180bbb891d132c5e10f0649fbb9", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -31,36 +31,36 @@ export _impl, iscopes, method_info;\n // them, storing the resulting def in the AST nodes.\n \n enum scope {\n-    scope_crate;\n-    scope_item(@ast::item);\n-    scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]);\n-    scope_fn_expr(ast::fn_decl, node_id, [ast::ty_param]);\n-    scope_native_item(@ast::native_item);\n-    scope_loop(@ast::local); // there's only 1 decl per loop.\n-    scope_block(ast::blk, @mutable uint, @mutable uint);\n-    scope_arm(ast::arm);\n-    scope_method(ast::node_id, [ast::ty_param]);\n+    scope_crate,\n+    scope_item(@ast::item),\n+    scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]),\n+    scope_fn_expr(ast::fn_decl, node_id, [ast::ty_param]),\n+    scope_native_item(@ast::native_item),\n+    scope_loop(@ast::local), // there's only 1 decl per loop.\n+    scope_block(ast::blk, @mutable uint, @mutable uint),\n+    scope_arm(ast::arm),\n+    scope_method(ast::node_id, [ast::ty_param]),\n }\n \n type scopes = list<scope>;\n \n enum import_state {\n-    todo(ast::node_id, ast::ident, @[ast::ident], codemap::span, scopes);\n-    is_glob(@[ast::ident], scopes, codemap::span);\n-    resolving(span);\n+    todo(ast::node_id, ast::ident, @[ast::ident], codemap::span, scopes),\n+    is_glob(@[ast::ident], scopes, codemap::span),\n+    resolving(span),\n     resolved(option::t<def>, /* value */\n              option::t<def>, /* type */\n              option::t<def>, /* module */\n              @[@_impl], /* impls */\n              /* used for reporting unused import warning */\n-             ast::ident, codemap::span);\n+             ast::ident, codemap::span),\n }\n \n enum glob_import_state {\n-    glob_resolving(span);\n+    glob_resolving(span),\n     glob_resolved(option::t<def>,  /* value */\n                   option::t<def>,  /* type */\n-                  option::t<def>); /* module */\n+                  option::t<def>), /* module */\n }\n \n type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n@@ -99,11 +99,11 @@ fn new_exp_hash() -> exp_map {\n }\n \n enum mod_index_entry {\n-    mie_view_item(@ast::view_item);\n-    mie_import_ident(node_id, codemap::span);\n-    mie_item(@ast::item);\n-    mie_native_item(@ast::native_item);\n-    mie_tag_variant(/* enum item */@ast::item, /* variant index */uint);\n+    mie_view_item(@ast::view_item),\n+    mie_import_ident(node_id, codemap::span),\n+    mie_item(@ast::item),\n+    mie_native_item(@ast::native_item),\n+    mie_tag_variant(/* enum item */@ast::item, /* variant index */uint),\n }\n \n type mod_index = hashmap<ident, list<mod_index_entry>>;\n@@ -151,14 +151,14 @@ type env =\n \n // Used to distinguish between lookups from outside and from inside modules,\n // since export restrictions should only be applied for the former.\n-enum dir { inside; outside; }\n+enum dir { inside, outside, }\n \n // There are two types of ns_value enum: \"definitely a enum\";\n // and \"any value\". This is so that lookup can behave differently\n // when looking up a variable name that's not yet in scope to check\n // if it's already bound to a enum.\n-enum namespace { ns_val(ns_value_type); ns_type; ns_module; }\n-enum ns_value_type { ns_a_tag; ns_any_value; }\n+enum namespace { ns_val(ns_value_type), ns_type, ns_module, }\n+enum ns_value_type { ns_a_tag, ns_any_value, }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -749,7 +749,7 @@ fn ns_name(ns: namespace) -> str {\n     }\n }\n \n-enum ctxt { in_mod(def); in_scope(scopes); }\n+enum ctxt { in_mod(def), in_scope(scopes), }\n \n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option::t<scope> {"}, {"sha": "de1dddb923bf5ae258dddb124bb4fd762eb77139", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -230,7 +230,7 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     ret {size: max_size, align: max_align};\n }\n \n-enum tag_kind { tk_unit; tk_enum; tk_complex; }\n+enum tag_kind { tk_unit, tk_enum, tk_complex, }\n \n fn tag_kind(ccx: @crate_ctxt, did: ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);"}, {"sha": "fd81bb72d4870dd24549fb1e6f1edde7a923a3fb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -1470,7 +1470,7 @@ fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n \n \n // Used only for creating scalar comparison glue.\n-enum scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n+enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n \n fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n@@ -1938,7 +1938,7 @@ fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     ret call_memmove(bcx, dst, src, llsz).bcx;\n }\n \n-enum copy_action { INIT; DROP_EXISTING; }\n+enum copy_action { INIT, DROP_EXISTING, }\n \n // These are the types that are passed by pointer.\n fn type_is_structural_or_param(tcx: ty::ctxt, t: ty::t) -> bool {\n@@ -2331,9 +2331,9 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n }\n \n enum dest {\n-    by_val(@mutable ValueRef);\n-    save_in(ValueRef);\n-    ignore;\n+    by_val(@mutable ValueRef),\n+    save_in(ValueRef),\n+    ignore,\n }\n \n fn empty_dest_cell() -> @mutable ValueRef {\n@@ -2496,17 +2496,17 @@ type generic_info = {\n };\n \n enum lval_kind {\n-    temporary; //< Temporary value passed by value if of immediate type\n-    owned;     //< Non-temporary value passed by pointer\n-    owned_imm; //< Non-temporary value passed by value\n+    temporary, //< Temporary value passed by value if of immediate type\n+    owned,     //< Non-temporary value passed by pointer\n+    owned_imm, //< Non-temporary value passed by value\n }\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n enum callee_env {\n-    null_env;\n-    is_closure;\n-    self_env(ValueRef);\n-    dict_env(ValueRef, ValueRef);\n+    null_env,\n+    is_closure,\n+    self_env(ValueRef),\n+    dict_env(ValueRef, ValueRef),\n }\n type lval_maybe_callee = {bcx: @block_ctxt,\n                           val: ValueRef,\n@@ -2896,7 +2896,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     check (type_has_static_size(ccx, t_out));\n     let ll_t_out = type_of(ccx, e.span, t_out);\n \n-    enum kind { pointer; integral; float; tag_; other; }\n+    enum kind { pointer, integral, float, tag_, other, }\n     fn t_kind(tcx: ty::ctxt, t: ty::t) -> kind {\n         ret if ty::type_is_fp(tcx, t) {\n                 float\n@@ -4415,7 +4415,7 @@ fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n     RetVoid(ret_cx);\n }\n \n-enum self_arg { impl_self(ty::t); no_self; }\n+enum self_arg { impl_self(ty::t), no_self, }\n \n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be"}, {"sha": "816c82de1e2b4ff47a1b4c0d1852004dbdafbfc6", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -19,7 +19,7 @@ import trans_common::*;\n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n enum opt {\n-    lit(@ast::expr);\n+    lit(@ast::expr),\n     var(/* disr val */int, /* variant dids */{tg: def_id, var: def_id});\n     range(@ast::expr, @ast::expr);\n }\n@@ -36,8 +36,8 @@ fn opt_eq(a: opt, b: opt) -> bool {\n }\n \n enum opt_result {\n-    single_result(result);\n-    range_result(result, result);\n+    single_result(result),\n+    range_result(result, result),\n }\n fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n@@ -473,7 +473,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     // Decide what kind of branch we need\n     let opts = get_options(ccx, m, col);\n-    enum branch_kind { no_branch; single; switch; compare; }\n+    enum branch_kind { no_branch, single, switch, compare, }\n     let kind = no_branch;\n     let test_val = val;\n     if vec::len(opts) > 0u {"}, {"sha": "fcfb4f5244ea915e15de0ac4a61981f8ef438525", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -111,16 +111,16 @@ import trans::{\n \n enum environment_value {\n     // Evaluate expr and store result in env (used for bind).\n-    env_expr(@ast::expr);\n+    env_expr(@ast::expr),\n \n     // Copy the value from this llvm ValueRef into the environment.\n-    env_copy(ValueRef, ty::t, lval_kind);\n+    env_copy(ValueRef, ty::t, lval_kind),\n \n     // Move the value from this llvm ValueRef into the environment.\n-    env_move(ValueRef, ty::t, lval_kind);\n+    env_move(ValueRef, ty::t, lval_kind),\n \n     // Access by reference (used for blocks).\n-    env_ref(ValueRef, ty::t, lval_kind);\n+    env_ref(ValueRef, ty::t, lval_kind),\n }\n \n fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {"}, {"sha": "64ac02e31251ed4433f2c7ae93dd693866081938", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -33,9 +33,9 @@ fn new_namegen() -> namegen {\n type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n \n enum tydesc_kind {\n-    tk_static; // Static (monomorphic) type descriptor\n-    tk_param; // Type parameter.\n-    tk_derived; // Derived from a typaram or another derived tydesc.\n+    tk_static, // Static (monomorphic) type descriptor\n+    tk_param, // Type parameter.\n+    tk_derived, // Derived from a typaram or another derived tydesc.\n }\n \n type tydesc_info =\n@@ -131,7 +131,7 @@ type local_ctxt =\n // Types used for llself.\n type val_self_pair = {v: ValueRef, t: ty::t};\n \n-enum local_val { local_mem(ValueRef); local_imm(ValueRef); }\n+enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n type fn_ty_param = {desc: ValueRef, dicts: option::t<[ValueRef]>};\n \n@@ -243,8 +243,8 @@ type fn_ctxt =\n      lcx: @local_ctxt};\n \n enum cleanup {\n-    clean(fn@(@block_ctxt) -> @block_ctxt);\n-    clean_temp(ValueRef, fn@(@block_ctxt) -> @block_ctxt);\n+    clean(fn@(@block_ctxt) -> @block_ctxt),\n+    clean_temp(ValueRef, fn@(@block_ctxt) -> @block_ctxt),\n }\n \n fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n@@ -388,7 +388,7 @@ type block_ctxt =\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-enum check in rustboot gets upset.\n-enum block_parent { parent_none; parent_some(@block_ctxt); }\n+enum block_parent { parent_none, parent_some(@block_ctxt), }\n \n type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n@@ -886,8 +886,8 @@ pure fn type_is_tup_like(cx: @block_ctxt, t: ty::t) -> bool {\n \n // Used to identify cached dictionaries\n enum dict_param {\n-    dict_param_dict(dict_id);\n-    dict_param_ty(ty::t);\n+    dict_param_dict(dict_id),\n+    dict_param_ty(ty::t),\n }\n type dict_id = @{def: ast::def_id, params: [dict_param]};\n fn hash_dict_id(&&dp: dict_id) -> uint {"}, {"sha": "c6af04460ff86603c19d1bdc6c33af4f71902244", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -23,11 +23,11 @@ import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n // Used to communicate which operands should be invalidated\n // to helper functions\n enum oper_type {\n-    oper_move;\n-    oper_swap;\n-    oper_assign;\n-    oper_assign_op;\n-    oper_pure;\n+    oper_move,\n+    oper_swap,\n+    oper_assign,\n+    oper_assign_op,\n+    oper_pure,\n }\n \n /* logging funs */\n@@ -199,11 +199,11 @@ type pred_args = spanned<pred_args_>;\n type constr_arg_use = spanned<constr_arg_general_<inst>>;\n \n enum constraint {\n-    cinit(uint, span, ident);\n+    cinit(uint, span, ident),\n \n     // FIXME: really only want it to be mutable during collect_locals.\n     // freeze it after that.\n-    cpred(@path, @mutable [pred_args]);\n+    cpred(@path, @mutable [pred_args]),\n }\n \n // An ninit variant has a node_id because it refers to a local var.\n@@ -212,8 +212,8 @@ enum constraint {\n // FIXME: would be nice to give both a def_id field,\n // and give ninit a constraint saying it's local.\n enum tsconstr {\n-    ninit(node_id, ident);\n-    npred(@path, def_id, [@constr_arg_use]);\n+    ninit(node_id, ident),\n+    npred(@path, def_id, [@constr_arg_use]),\n }\n \n type sp_constr = spanned<tsconstr>;\n@@ -780,7 +780,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n     ret rslt;\n }\n \n-enum if_ty { if_check; plain_if; }\n+enum if_ty { if_check, plain_if, }\n \n fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n    def_id {"}, {"sha": "37cc22edf3b2d5100f7017b7387d1b704246adde", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -30,7 +30,7 @@ export to_str;\n */\n \n type t = {uncertain: bitv::t, val: bitv::t, nbits: uint};\n-enum trit { ttrue; tfalse; dont_care; }\n+enum trit { ttrue, tfalse, dont_care, }\n \n fn create_tritv(len: uint) -> t {\n     ret {uncertain: bitv::create(len, true),"}, {"sha": "b7751fc235e04f39f27bfe251650ab181b4ce824", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -236,10 +236,10 @@ type raw_t = {struct: sty,\n type t = uint;\n \n enum closure_kind {\n-    ck_any;\n-    ck_block;\n-    ck_box;\n-    ck_uniq;\n+    ck_any,\n+    ck_block,\n+    ck_box,\n+    ck_uniq,\n }\n \n type fn_ty = {proto: ast::proto,\n@@ -251,34 +251,34 @@ type fn_ty = {proto: ast::proto,\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast::rs as well.\n enum sty {\n-    ty_nil;\n-    ty_bot;\n-    ty_bool;\n-    ty_int(ast::int_ty);\n-    ty_uint(ast::uint_ty);\n-    ty_float(ast::float_ty);\n-    ty_str;\n-    ty_tag(def_id, [t]);\n-    ty_box(mt);\n-    ty_uniq(mt);\n-    ty_vec(mt);\n-    ty_ptr(mt);\n-    ty_rec([field]);\n-    ty_fn(fn_ty);\n-    ty_native_fn([arg], t);\n-    ty_iface(def_id, [t]);\n-    ty_res(def_id, t, [t]);\n-    ty_tup([t]);\n-    ty_var(int); // type variable\n-\n-    ty_param(uint, def_id); // fn/enum type param\n-\n-    ty_type; // type_desc*\n-    ty_send_type; // type_desc* that has been cloned into exchange heap\n-    ty_native(def_id);\n-    ty_constr(t, [@type_constr]);\n-    ty_opaque_closure_ptr(closure_kind); // ptr to env for fn, fn@, fn~\n-    ty_named(t, @str);\n+    ty_nil,\n+    ty_bot,\n+    ty_bool,\n+    ty_int(ast::int_ty),\n+    ty_uint(ast::uint_ty),\n+    ty_float(ast::float_ty),\n+    ty_str,\n+    ty_tag(def_id, [t]),\n+    ty_box(mt),\n+    ty_uniq(mt),\n+    ty_vec(mt),\n+    ty_ptr(mt),\n+    ty_rec([field]),\n+    ty_fn(fn_ty),\n+    ty_native_fn([arg], t),\n+    ty_iface(def_id, [t]),\n+    ty_res(def_id, t, [t]),\n+    ty_tup([t]),\n+    ty_var(int), // type variable\n+\n+    ty_param(uint, def_id), // fn/enum type param\n+\n+    ty_type, // type_desc*\n+    ty_send_type, // type_desc* that has been cloned into exchange heap\n+    ty_native(def_id),\n+    ty_constr(t, [@type_constr]),\n+    ty_opaque_closure_ptr(closure_kind), // ptr to env for fn, fn@, fn~\n+    ty_named(t, @str),\n }\n \n // In the middle end, constraints have a def_id attached, referring\n@@ -289,24 +289,24 @@ type constr = constr_general<uint>;\n \n // Data structures used in type unification\n enum type_err {\n-    terr_mismatch;\n-    terr_ret_style_mismatch(ast::ret_style, ast::ret_style);\n-    terr_box_mutability;\n-    terr_vec_mutability;\n-    terr_tuple_size(uint, uint);\n-    terr_record_size(uint, uint);\n-    terr_record_mutability;\n-    terr_record_fields(ast::ident, ast::ident);\n-    terr_arg_count;\n-    terr_mode_mismatch(mode, mode);\n-    terr_constr_len(uint, uint);\n-    terr_constr_mismatch(@type_constr, @type_constr);\n+    terr_mismatch,\n+    terr_ret_style_mismatch(ast::ret_style, ast::ret_style),\n+    terr_box_mutability,\n+    terr_vec_mutability,\n+    terr_tuple_size(uint, uint),\n+    terr_record_size(uint, uint),\n+    terr_record_mutability,\n+    terr_record_fields(ast::ident, ast::ident),\n+    terr_arg_count,\n+    terr_mode_mismatch(mode, mode),\n+    terr_constr_len(uint, uint),\n+    terr_constr_mismatch(@type_constr, @type_constr),\n }\n \n enum param_bound {\n-    bound_copy;\n-    bound_send;\n-    bound_iface(t);\n+    bound_copy,\n+    bound_send,\n+    bound_iface(t),\n }\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n@@ -713,9 +713,9 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n }\n \n enum fold_mode {\n-    fm_var(fn@(int) -> t);\n-    fm_param(fn@(uint, def_id) -> t);\n-    fm_general(fn@(t) -> t);\n+    fm_var(fn@(int) -> t),\n+    fm_param(fn@(uint, def_id) -> t),\n+    fm_general(fn@(t) -> t),\n }\n \n fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n@@ -973,7 +973,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     ret result;\n }\n \n-enum kind { kind_sendable; kind_copyable; kind_noncopyable; }\n+enum kind { kind_sendable, kind_copyable, kind_noncopyable, }\n \n // Using these query functons is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n@@ -1732,18 +1732,18 @@ mod unify {\n     export var_bindings;\n     export precise, in_bindings;\n \n-    enum result { ures_ok(t); ures_err(type_err); }\n-    enum union_result { unres_ok; unres_err(type_err); }\n+    enum result { ures_ok(t), ures_err(type_err), }\n+    enum union_result { unres_ok, unres_err(type_err), }\n     enum fixup_result {\n-        fix_ok(t); // fixup succeeded\n-        fix_err(int); // fixup failed because a type variable was unresolved\n+        fix_ok(t), // fixup succeeded\n+        fix_err(int), // fixup failed because a type variable was unresolved\n     }\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n     enum unify_style {\n-        precise;\n-        in_bindings(@var_bindings);\n+        precise,\n+        in_bindings(@var_bindings),\n     }\n     type ctxt = {st: unify_style, tcx: ty_ctxt};\n \n@@ -2043,11 +2043,11 @@ mod unify {\n     // Specifies the allowable subtyping between expected and actual types\n     enum variance {\n         // Actual may be a subtype of expected\n-        covariant;\n+        covariant,\n         // Actual may be a supertype of expected\n-        contravariant;\n+        contravariant,\n         // Actual must be the same type as expected\n-        invariant;\n+        invariant,\n     }\n \n     // The calculation for recursive variance"}, {"sha": "cfeddd46050c01a3a26a42573ce042505a1d1e56", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -24,28 +24,28 @@ export method_map, method_origin, method_static, method_param, method_iface;\n export dict_map, dict_res, dict_origin, dict_static, dict_param, dict_iface;\n \n enum method_origin {\n-    method_static(ast::def_id);\n+    method_static(ast::def_id),\n     // iface id, method num, param num, bound num\n-    method_param(ast::def_id, uint, uint, uint);\n-    method_iface(uint);\n+    method_param(ast::def_id, uint, uint, uint),\n+    method_iface(uint),\n }\n type method_map = hashmap<ast::node_id, method_origin>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n type dict_res = @[dict_origin];\n enum dict_origin {\n-    dict_static(ast::def_id, [ty::t], dict_res);\n+    dict_static(ast::def_id, [ty::t], dict_res),\n     // Param number, bound number\n-    dict_param(uint, uint);\n-    dict_iface(ast::def_id);\n+    dict_param(uint, uint),\n+    dict_iface(ast::def_id),\n }\n type dict_map = hashmap<ast::node_id, dict_res>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an impl\n enum self_info {\n-    self_impl(ty::t);\n+    self_impl(ty::t),\n }\n \n type crate_ctxt = {mutable self_infos: [self_info],\n@@ -231,7 +231,7 @@ fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n     }\n }\n \n-enum mode { m_collect; m_check; m_check_tyvar(@fn_ctxt); }\n+enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n \n fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)"}, {"sha": "0f7ba99301f5c6c5b884ea9792d16d7477420a89", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 171, "deletions": 171, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -25,29 +25,29 @@ const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n enum ty_param_bound {\n-    bound_copy;\n-    bound_send;\n-    bound_iface(@ty);\n+    bound_copy,\n+    bound_send,\n+    bound_iface(@ty),\n }\n \n type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n \n enum def {\n-    def_fn(def_id, purity);\n-    def_self(def_id);\n-    def_mod(def_id);\n-    def_native_mod(def_id);\n-    def_const(def_id);\n-    def_arg(def_id, mode);\n-    def_local(def_id, let_style);\n-    def_variant(def_id /* enum */, def_id /* variant */);\n-    def_ty(def_id);\n-    def_ty_param(def_id, uint);\n-    def_binding(def_id);\n-    def_use(def_id);\n-    def_native_ty(def_id);\n-    def_native_fn(def_id, purity);\n-    def_upvar(def_id, @def, node_id); // node_id == expr_fn or expr_fn_block\n+    def_fn(def_id, purity),\n+    def_self(def_id),\n+    def_mod(def_id),\n+    def_native_mod(def_id),\n+    def_const(def_id),\n+    def_arg(def_id, mode),\n+    def_local(def_id, let_style),\n+    def_variant(def_id /* enum */, def_id /* variant */),\n+    def_ty(def_id),\n+    def_ty_param(def_id, uint),\n+    def_binding(def_id),\n+    def_use(def_id),\n+    def_native_ty(def_id),\n+    def_native_fn(def_id, purity),\n+    def_upvar(def_id, @def, node_id), // node_id == expr_fn or expr_fn_block\n }\n \n // The set of meta_items that define the compilation environment of the crate,\n@@ -63,27 +63,27 @@ type crate_ =\n      config: crate_cfg};\n \n enum crate_directive_ {\n-    cdir_src_mod(ident, [attribute]);\n-    cdir_dir_mod(ident, [@crate_directive], [attribute]);\n+    cdir_src_mod(ident, [attribute]),\n+    cdir_dir_mod(ident, [@crate_directive], [attribute]),\n \n-    // NB: cdir_view_item is *not* processed by the rest of the compiler; the\n+    // NB: cdir_view_item is *not* processed by the rest of the compiler, the\n     // attached view_items are sunk into the crate's module during parsing,\n     // and processed (resolved, imported, etc.) there. This enum-variant\n     // exists only to preserve the view items in order in case we decide to\n     // pretty-print crates in the future.\n-    cdir_view_item(@view_item);\n+    cdir_view_item(@view_item),\n \n-    cdir_syntax(@path);\n+    cdir_syntax(@path),\n }\n \n type crate_directive = spanned<crate_directive_>;\n \n type meta_item = spanned<meta_item_>;\n \n enum meta_item_ {\n-    meta_word(ident);\n-    meta_list(ident, [@meta_item]);\n-    meta_name_value(ident, lit);\n+    meta_word(ident),\n+    meta_list(ident, [@meta_item]),\n+    meta_name_value(ident, lit),\n }\n \n type blk = spanned<blk_>;\n@@ -96,7 +96,7 @@ type pat = {id: node_id, node: pat_, span: span};\n type field_pat = {ident: ident, pat: @pat};\n \n enum pat_ {\n-    pat_wild;\n+    pat_wild,\n     // A pat_ident may either be a new bound variable,\n     // or a nullary enum (in which case the second field\n     // is none).\n@@ -107,24 +107,24 @@ enum pat_ {\n     // After the resolution phase, code should never pattern-\n     // match on a pat directly! Always call pat_util::normalize_pat --\n     // it turns any pat_idents that refer to nullary tags into pat_tags.\n-    pat_ident(@path, option::t<@pat>);\n-    pat_tag(@path, [@pat]);\n-    pat_rec([field_pat], bool);\n-    pat_tup([@pat]);\n-    pat_box(@pat);\n-    pat_uniq(@pat);\n-    pat_lit(@expr);\n-    pat_range(@expr, @expr);\n+    pat_ident(@path, option::t<@pat>),\n+    pat_tag(@path, [@pat]),\n+    pat_rec([field_pat], bool),\n+    pat_tup([@pat]),\n+    pat_box(@pat),\n+    pat_uniq(@pat),\n+    pat_lit(@expr),\n+    pat_range(@expr, @expr),\n }\n \n-enum mutability { mut; imm; maybe_mut; }\n+enum mutability { mut, imm, maybe_mut, }\n \n enum proto {\n-    proto_bare;    // native fn\n-    proto_any;     // fn\n-    proto_uniq;    // fn~\n-    proto_box;     // fn@\n-    proto_block;   // fn&\n+    proto_bare,    // native fn\n+    proto_any,     // fn\n+    proto_uniq,    // fn~\n+    proto_box,     // fn@\n+    proto_block,   // fn&\n }\n \n pure fn is_blockish(p: ast::proto) -> bool {\n@@ -135,48 +135,48 @@ pure fn is_blockish(p: ast::proto) -> bool {\n }\n \n enum binop {\n-    add;\n-    subtract;\n-    mul;\n-    div;\n-    rem;\n-    and;\n-    or;\n-    bitxor;\n-    bitand;\n-    bitor;\n-    lsl;\n-    lsr;\n-    asr;\n-    eq;\n-    lt;\n-    le;\n-    ne;\n-    ge;\n-    gt;\n+    add,\n+    subtract,\n+    mul,\n+    div,\n+    rem,\n+    and,\n+    or,\n+    bitxor,\n+    bitand,\n+    bitor,\n+    lsl,\n+    lsr,\n+    asr,\n+    eq,\n+    lt,\n+    le,\n+    ne,\n+    ge,\n+    gt,\n }\n \n enum unop {\n-    box(mutability);\n-    uniq(mutability);\n-    deref; not; neg;\n+    box(mutability),\n+    uniq(mutability),\n+    deref, not, neg,\n }\n \n-enum mode { by_ref; by_val; by_mut_ref; by_move; by_copy; mode_infer; }\n+enum mode { by_ref, by_val, by_mut_ref, by_move, by_copy, mode_infer, }\n \n type stmt = spanned<stmt_>;\n \n enum stmt_ {\n-    stmt_decl(@decl, node_id);\n+    stmt_decl(@decl, node_id),\n \n     // expr without trailing semi-colon (must have unit type):\n-    stmt_expr(@expr, node_id);\n+    stmt_expr(@expr, node_id),\n \n     // expr with trailing semi-colon (may have any type):\n-    stmt_semi(@expr, node_id);\n+    stmt_semi(@expr, node_id),\n }\n \n-enum init_op { init_assign; init_move; }\n+enum init_op { init_assign, init_move, }\n \n type initializer = {op: init_op, expr: @expr};\n \n@@ -187,71 +187,71 @@ type local = spanned<local_>;\n \n type decl = spanned<decl_>;\n \n-enum let_style { let_copy; let_ref; }\n+enum let_style { let_copy, let_ref, }\n \n-enum decl_ { decl_local([(let_style, @local)]); decl_item(@item); }\n+enum decl_ { decl_local([(let_style, @local)]), decl_item(@item), }\n \n type arm = {pats: [@pat], guard: option::t<@expr>, body: blk};\n \n type field_ = {mut: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n-enum blk_check_mode { default_blk; unchecked_blk; unsafe_blk; }\n+enum blk_check_mode { default_blk, unchecked_blk, unsafe_blk, }\n \n-enum expr_check_mode { claimed_expr; checked_expr; }\n+enum expr_check_mode { claimed_expr, checked_expr, }\n \n type expr = {id: node_id, node: expr_, span: span};\n \n enum expr_ {\n-    expr_vec([@expr], mutability);\n-    expr_rec([field], option::t<@expr>);\n-    expr_call(@expr, [@expr], bool);\n-    expr_tup([@expr]);\n-    expr_bind(@expr, [option::t<@expr>]);\n-    expr_binary(binop, @expr, @expr);\n-    expr_unary(unop, @expr);\n-    expr_lit(@lit);\n-    expr_cast(@expr, @ty);\n-    expr_if(@expr, blk, option::t<@expr>);\n-    expr_ternary(@expr, @expr, @expr);\n-    expr_while(@expr, blk);\n-    expr_for(@local, @expr, blk);\n-    expr_do_while(blk, @expr);\n-    expr_alt(@expr, [arm]);\n-    expr_fn(proto, fn_decl, blk, @capture_clause);\n-    expr_fn_block(fn_decl, blk);\n-    expr_block(blk);\n+    expr_vec([@expr], mutability),\n+    expr_rec([field], option::t<@expr>),\n+    expr_call(@expr, [@expr], bool),\n+    expr_tup([@expr]),\n+    expr_bind(@expr, [option::t<@expr>]),\n+    expr_binary(binop, @expr, @expr),\n+    expr_unary(unop, @expr),\n+    expr_lit(@lit),\n+    expr_cast(@expr, @ty),\n+    expr_if(@expr, blk, option::t<@expr>),\n+    expr_ternary(@expr, @expr, @expr),\n+    expr_while(@expr, blk),\n+    expr_for(@local, @expr, blk),\n+    expr_do_while(blk, @expr),\n+    expr_alt(@expr, [arm]),\n+    expr_fn(proto, fn_decl, blk, @capture_clause),\n+    expr_fn_block(fn_decl, blk),\n+    expr_block(blk),\n \n     /*\n      * FIXME: many of these @exprs should be constrained with\n      * is_lval once we have constrained types working.\n      */\n-    expr_copy(@expr);\n-    expr_move(@expr, @expr);\n-    expr_assign(@expr, @expr);\n-    expr_swap(@expr, @expr);\n-    expr_assign_op(binop, @expr, @expr);\n-    expr_field(@expr, ident, [@ty]);\n-    expr_index(@expr, @expr);\n-    expr_path(@path);\n-    expr_fail(option::t<@expr>);\n-    expr_break;\n-    expr_cont;\n-    expr_ret(option::t<@expr>);\n-    expr_be(@expr);\n-    expr_log(int, @expr, @expr);\n+    expr_copy(@expr),\n+    expr_move(@expr, @expr),\n+    expr_assign(@expr, @expr),\n+    expr_swap(@expr, @expr),\n+    expr_assign_op(binop, @expr, @expr),\n+    expr_field(@expr, ident, [@ty]),\n+    expr_index(@expr, @expr),\n+    expr_path(@path),\n+    expr_fail(option::t<@expr>),\n+    expr_break,\n+    expr_cont,\n+    expr_ret(option::t<@expr>),\n+    expr_be(@expr),\n+    expr_log(int, @expr, @expr),\n \n     /* just an assert, no significance to typestate */\n-    expr_assert(@expr);\n+    expr_assert(@expr),\n \n     /* preds that typestate is aware of */\n-    expr_check(expr_check_mode, @expr);\n+    expr_check(expr_check_mode, @expr),\n \n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */\n-    expr_if_check(@expr, blk, option::t<@expr>);\n-    expr_mac(mac);\n+    expr_if_check(@expr, blk, option::t<@expr>),\n+    expr_mac(mac),\n }\n \n type capture_item = {\n@@ -268,29 +268,29 @@ type capture_clause = {\n // Says whether this is a block the user marked as\n // \"unchecked\"\n enum blk_sort {\n-    blk_unchecked; // declared as \"exception to effect-checking rules\"\n-    blk_checked; // all typing rules apply\n+    blk_unchecked, // declared as \"exception to effect-checking rules\"\n+    blk_checked, // all typing rules apply\n }\n */\n \n type mac = spanned<mac_>;\n \n enum mac_ {\n-    mac_invoc(@path, @expr, option::t<str>);\n-    mac_embed_type(@ty);\n-    mac_embed_block(blk);\n-    mac_ellipsis;\n+    mac_invoc(@path, @expr, option::t<str>),\n+    mac_embed_type(@ty),\n+    mac_embed_block(blk),\n+    mac_ellipsis,\n }\n \n type lit = spanned<lit_>;\n \n enum lit_ {\n-    lit_str(str);\n-    lit_int(i64, int_ty);\n-    lit_uint(u64, uint_ty);\n-    lit_float(str, float_ty);\n-    lit_nil;\n-    lit_bool(bool);\n+    lit_str(str),\n+    lit_int(i64, int_ty),\n+    lit_uint(u64, uint_ty),\n+    lit_float(str, float_ty),\n+    lit_nil,\n+    lit_bool(bool),\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -303,46 +303,46 @@ type ty_field = spanned<ty_field_>;\n \n type ty_method = {ident: ident, decl: fn_decl, tps: [ty_param], span: span};\n \n-enum int_ty { ty_i; ty_char; ty_i8; ty_i16; ty_i32; ty_i64; }\n+enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n-enum uint_ty { ty_u; ty_u8; ty_u16; ty_u32; ty_u64; }\n+enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n-enum float_ty { ty_f; ty_f32; ty_f64; }\n+enum float_ty { ty_f, ty_f32, ty_f64, }\n \n type ty = spanned<ty_>;\n \n enum ty_ {\n-    ty_nil;\n-    ty_bot; /* return type of ! functions and type of\n+    ty_nil,\n+    ty_bot, /* return type of ! functions and type of\n              ret/fail/break/cont. there is no syntax\n              for this type. */\n \n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n-    ty_bool;\n-    ty_int(int_ty);\n-    ty_uint(uint_ty);\n-    ty_float(float_ty);\n-    ty_str;\n-    ty_box(mt);\n-    ty_uniq(mt);\n-    ty_vec(mt);\n-    ty_ptr(mt);\n-    ty_task;\n-    ty_port(@ty);\n-    ty_chan(@ty);\n-    ty_rec([ty_field]);\n-    ty_fn(proto, fn_decl);\n-    ty_tup([@ty]);\n-    ty_path(@path, node_id);\n-    ty_type;\n-    ty_constr(@ty, [@ty_constr]);\n-    ty_mac(mac);\n+    ty_bool,\n+    ty_int(int_ty),\n+    ty_uint(uint_ty),\n+    ty_float(float_ty),\n+    ty_str,\n+    ty_box(mt),\n+    ty_uniq(mt),\n+    ty_vec(mt),\n+    ty_ptr(mt),\n+    ty_task,\n+    ty_port(@ty),\n+    ty_chan(@ty),\n+    ty_rec([ty_field]),\n+    ty_fn(proto, fn_decl),\n+    ty_tup([@ty]),\n+    ty_path(@path, node_id),\n+    ty_type,\n+    ty_constr(@ty, [@ty_constr]),\n+    ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n     // nested in one.\n-    ty_infer;\n+    ty_infer,\n }\n \n \n@@ -354,7 +354,7 @@ so that the typestate pass doesn't have to map a function name onto its decl.\n So, the constr_arg type is parameterized: it's instantiated with uint for\n declarations, and ident for uses.\n */\n-enum constr_arg_general_<T> { carg_base; carg_ident(T); carg_lit(@lit); }\n+enum constr_arg_general_<T> { carg_base, carg_ident(T), carg_lit(@lit), }\n \n type fn_constr_arg = constr_arg_general_<uint>;\n type sp_constr_arg<T> = spanned<constr_arg_general_<T>>;\n@@ -390,15 +390,15 @@ type fn_decl =\n      constraints: [@constr]};\n \n enum purity {\n-    pure_fn; // declared with \"pure fn\"\n-    unsafe_fn; // declared with \"unsafe fn\"\n-    impure_fn; // declared with \"fn\"\n+    pure_fn, // declared with \"pure fn\"\n+    unsafe_fn, // declared with \"unsafe fn\"\n+    impure_fn, // declared with \"fn\"\n }\n \n enum ret_style {\n-    noreturn; // functions with return type _|_ that always\n+    noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n-    return_val; // everything else\n+    return_val, // everything else\n }\n \n type method = {ident: ident, tps: [ty_param], decl: fn_decl, body: blk,\n@@ -407,9 +407,9 @@ type method = {ident: ident, tps: [ty_param], decl: fn_decl, body: blk,\n type _mod = {view_items: [@view_item], items: [@item]};\n \n enum native_abi {\n-    native_abi_rust_intrinsic;\n-    native_abi_cdecl;\n-    native_abi_stdcall;\n+    native_abi_rust_intrinsic,\n+    native_abi_cdecl,\n+    native_abi_stdcall,\n }\n \n type native_mod =\n@@ -434,11 +434,11 @@ type import_ident_ = {name: ident, id: node_id};\n type import_ident = spanned<import_ident_>;\n \n enum view_item_ {\n-    view_item_use(ident, [@meta_item], node_id);\n-    view_item_import(ident, @simple_path, node_id);\n-    view_item_import_glob(@simple_path, node_id);\n-    view_item_import_from(@simple_path, [import_ident], node_id);\n-    view_item_export([ident], node_id);\n+    view_item_use(ident, [@meta_item], node_id),\n+    view_item_import(ident, @simple_path, node_id),\n+    view_item_import_glob(@simple_path, node_id),\n+    view_item_import_from(@simple_path, [import_ident], node_id),\n+    view_item_export([ident], node_id),\n }\n \n // Meta-data associated with an item\n@@ -448,25 +448,25 @@ type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-enum attr_style { attr_outer; attr_inner; }\n+enum attr_style { attr_outer, attr_inner, }\n \n type attribute_ = {style: attr_style, value: meta_item};\n \n type item = {ident: ident, attrs: [attribute],\n              id: node_id, node: item_, span: span};\n \n enum item_ {\n-    item_const(@ty, @expr);\n-    item_fn(fn_decl, [ty_param], blk);\n-    item_mod(_mod);\n-    item_native_mod(native_mod);\n-    item_ty(@ty, [ty_param]);\n-    item_tag([variant], [ty_param]);\n+    item_const(@ty, @expr),\n+    item_fn(fn_decl, [ty_param], blk),\n+    item_mod(_mod),\n+    item_native_mod(native_mod),\n+    item_ty(@ty, [ty_param]),\n+    item_tag([variant], [ty_param]),\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n-             node_id /* dtor id */, node_id /* ctor id */);\n-    item_iface([ty_param], [ty_method]);\n+             node_id /* dtor id */, node_id /* ctor id */),\n+    item_iface([ty_param], [ty_method]),\n     item_impl([ty_param], option::t<@ty> /* iface */,\n-              @ty /* self */, [@method]);\n+              @ty /* self */, [@method]),\n }\n \n type native_item =\n@@ -477,8 +477,8 @@ type native_item =\n      span: span};\n \n enum native_item_ {\n-    native_item_ty;\n-    native_item_fn(fn_decl, [ty_param]);\n+    native_item_ty,\n+    native_item_fn(fn_decl, [ty_param]),\n }\n \n //"}, {"sha": "24b9757a4f4089d418af8a451d4c5dc4dc22c9e8", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -202,10 +202,10 @@ fn ternary_to_if(e: @expr) -> @expr {\n // FIXME this doesn't handle big integer/float literals correctly (nor does\n // the rest of our literal handling)\n enum const_val {\n-    const_float(float);\n-    const_int(i64);\n-    const_uint(u64);\n-    const_str(str);\n+    const_float(float),\n+    const_int(i64),\n+    const_uint(u64),\n+    const_str(str),\n }\n \n // FIXME: issue #1417"}, {"sha": "367bd9a02fd25dd0c17aee837f5de9c83de478f4", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -68,8 +68,8 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n enum opt_span {\n \n     //hack (as opposed to option::t), to make `span` compile\n-    os_none;\n-    os_some(@span);\n+    os_none,\n+    os_some(@span),\n }\n type span = {lo: uint, hi: uint, expanded_from: opt_span};\n "}, {"sha": "50ff9932e7ebc1494b376ca2a83bfb1a69d8de2e", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -12,8 +12,8 @@ type macro_definer =\n     fn@(ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def;\n \n enum syntax_extension {\n-    normal(syntax_expander);\n-    macro_defining(macro_definer);\n+    normal(syntax_expander),\n+    macro_defining(macro_definer),\n }\n \n // A temporary hard-coded map of methods for expanding syntax extension"}, {"sha": "891a01495ac2d00923e3af1f90cd772fd498b66d", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -25,16 +25,16 @@ fn path_to_ident(pth: @path) -> option::t<ident> {\n type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n-enum arb_depth<T> { leaf(T); seq(@[arb_depth<T>], span); }\n+enum arb_depth<T> { leaf(T), seq(@[arb_depth<T>], span), }\n \n \n enum matchable {\n-    match_expr(@expr);\n-    match_path(@path);\n-    match_ident(ast::spanned<ident>);\n-    match_ty(@ty);\n-    match_block(ast::blk);\n-    match_exact; /* don't bind anything, just verify the AST traversal */\n+    match_expr(@expr),\n+    match_path(@path),\n+    match_ident(ast::spanned<ident>),\n+    match_ty(@ty),\n+    match_block(ast::blk),\n+    match_exact, /* don't bind anything, just verify the AST traversal */\n }\n \n /* for when given an incompatible bit of AST */"}, {"sha": "3dc1666b11e31ec24ff3f62c7996f447fc790d8e", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -511,10 +511,10 @@ fn next_token_inner(rdr: reader) -> token::token {\n }\n \n enum cmnt_style {\n-    isolated; // No code on either side of each line of the comment\n-    trailing; // Code exists to the left of the comment\n-    mixed; // Code before /* foo */ and after the comment\n-    blank_line; // Just a manual blank line \"\\n\\n\", for layout\n+    isolated, // No code on either side of each line of the comment\n+    trailing, // Code exists to the left of the comment\n+    mixed, // Code before /* foo */ and after the comment\n+    blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n type cmnt = {style: cmnt_style, lines: [str], pos: uint};"}, {"sha": "61b562480edfbafed7d4c183b0ce3fcd10733354", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -14,13 +14,13 @@ import lexer::reader;\n import driver::diagnostic;\n \n enum restriction {\n-    UNRESTRICTED;\n-    RESTRICT_STMT_EXPR;\n-    RESTRICT_NO_CALL_EXPRS;\n-    RESTRICT_NO_BAR_OP;\n+    UNRESTRICTED,\n+    RESTRICT_STMT_EXPR,\n+    RESTRICT_NO_CALL_EXPRS,\n+    RESTRICT_NO_BAR_OP,\n }\n \n-enum file_type { CRATE_FILE; SOURCE_FILE; }\n+enum file_type { CRATE_FILE, SOURCE_FILE, }\n \n type parse_sess = @{\n     cm: codemap::codemap,\n@@ -722,7 +722,7 @@ fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n // part of the AST, we wrap such expressions in the pexpr enum.  They\n // can then be converted to true expressions by a call to `to_expr()`.\n enum pexpr {\n-    pexpr(@ast::expr);\n+    pexpr(@ast::expr),\n }\n \n fn mk_pexpr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> pexpr {"}, {"sha": "0965697f8c8b3876b191443d2b0723a7e2993033", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -6,70 +6,70 @@ import lexer::reader;\n type str_num = uint;\n \n enum binop {\n-    PLUS;\n-    MINUS;\n-    STAR;\n-    SLASH;\n-    PERCENT;\n-    CARET;\n-    AND;\n-    OR;\n-    LSL;\n-    LSR;\n-    ASR;\n+    PLUS,\n+    MINUS,\n+    STAR,\n+    SLASH,\n+    PERCENT,\n+    CARET,\n+    AND,\n+    OR,\n+    LSL,\n+    LSR,\n+    ASR,\n }\n \n enum token {\n     /* Expression-operator symbols. */\n-    EQ;\n-    LT;\n-    LE;\n-    EQEQ;\n-    NE;\n-    GE;\n-    GT;\n-    ANDAND;\n-    OROR;\n-    NOT;\n-    TILDE;\n-    BINOP(binop);\n-    BINOPEQ(binop);\n+    EQ,\n+    LT,\n+    LE,\n+    EQEQ,\n+    NE,\n+    GE,\n+    GT,\n+    ANDAND,\n+    OROR,\n+    NOT,\n+    TILDE,\n+    BINOP(binop),\n+    BINOPEQ(binop),\n \n     /* Structural symbols */\n-    AT;\n-    DOT;\n-    ELLIPSIS;\n-    COMMA;\n-    SEMI;\n-    COLON;\n-    MOD_SEP;\n-    QUES;\n-    RARROW;\n-    LARROW;\n-    DARROW;\n-    LPAREN;\n-    RPAREN;\n-    LBRACKET;\n-    RBRACKET;\n-    LBRACE;\n-    RBRACE;\n-    POUND;\n-    POUND_LBRACE;\n-    POUND_LT;\n+    AT,\n+    DOT,\n+    ELLIPSIS,\n+    COMMA,\n+    SEMI,\n+    COLON,\n+    MOD_SEP,\n+    QUES,\n+    RARROW,\n+    LARROW,\n+    DARROW,\n+    LPAREN,\n+    RPAREN,\n+    LBRACKET,\n+    RBRACKET,\n+    LBRACE,\n+    RBRACE,\n+    POUND,\n+    POUND_LBRACE,\n+    POUND_LT,\n \n     /* Literals */\n-    LIT_INT(i64, ast::int_ty);\n-    LIT_UINT(u64, ast::uint_ty);\n-    LIT_FLOAT(str_num, ast::float_ty);\n-    LIT_STR(str_num);\n-    LIT_BOOL(bool);\n+    LIT_INT(i64, ast::int_ty),\n+    LIT_UINT(u64, ast::uint_ty),\n+    LIT_FLOAT(str_num, ast::float_ty),\n+    LIT_STR(str_num),\n+    LIT_BOOL(bool),\n \n     /* Name components */\n-    IDENT(str_num, bool);\n-    IDX(int);\n-    UNDERSCORE;\n-    BRACEQUOTE(str_num);\n-    EOF;\n+    IDENT(str_num, bool),\n+    IDX(int),\n+    UNDERSCORE,\n+    BRACEQUOTE(str_num),\n+    EOF,\n }\n \n fn binop_to_str(o: binop) -> str {"}, {"sha": "6a714158d3b4ab60d8542cc96898b5ff5b8682e7", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -55,13 +55,13 @@ import io::writer_util;\n  * line (which it can't) and so naturally place the content on its own line to\n  * avoid combining it with other lines and making matters even worse.\n  */\n-enum breaks { consistent; inconsistent; }\n+enum breaks { consistent, inconsistent, }\n \n type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-enum token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n+enum token { STRING(str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(t: token) -> str {\n     alt t {\n@@ -91,7 +91,7 @@ fn buf_str(toks: [mutable token], szs: [mutable int], left: uint, right: uint,\n     ret s;\n }\n \n-enum print_stack_break { fits; broken(breaks); }\n+enum print_stack_break { fits, broken(breaks), }\n \n type print_stack_elt = {offset: int, pbreak: print_stack_break};\n "}, {"sha": "2b62157593b3276ac10a16502559c77788046bdb", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -14,10 +14,10 @@ import driver::diagnostic;\n // The ps is stored here to prevent recursive type.\n // FIXME use a nominal enum instead\n enum ann_node {\n-    node_block(ps, ast::blk);\n-    node_item(ps, @ast::item);\n-    node_expr(ps, @ast::expr);\n-    node_pat(ps, @ast::pat);\n+    node_block(ps, ast::blk),\n+    node_item(ps, @ast::item),\n+    node_expr(ps, @ast::expr),\n+    node_pat(ps, @ast::pat),\n }\n type pp_ann = {pre: fn@(ann_node), post: fn@(ann_node)};\n \n@@ -565,7 +565,7 @@ fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: [ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs);\n }\n \n-enum embed_type { block_macro; block_block_fn; block_normal; }\n+enum embed_type { block_macro, block_block_fn, block_normal, }\n \n fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {"}, {"sha": "ddabc5e1c48e64e84386676fc6515dc01eecbbe7", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c267821742ab7f9207a8e594d53150ad41ad0d7b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=c267821742ab7f9207a8e594d53150ad41ad0d7b", "patch": "@@ -13,14 +13,14 @@ import codemap::span;\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n // hold functions that take visitors. A vt enum is used to break the cycle.\n-enum vt<E> { mk_vt(visitor<E>); }\n+enum vt<E> { mk_vt(visitor<E>), }\n \n enum fn_kind {\n-    fk_item_fn(ident, [ty_param]); //< an item declared with fn()\n-    fk_method(ident, [ty_param]);\n-    fk_res(ident, [ty_param]);\n-    fk_anon(proto);  //< an anonymous function like fn@(...)\n-    fk_fn_block;     //< a block {||...}\n+    fk_item_fn(ident, [ty_param]), //< an item declared with fn()\n+    fk_method(ident, [ty_param]),\n+    fk_res(ident, [ty_param]),\n+    fk_anon(proto),  //< an anonymous function like fn@(...)\n+    fk_fn_block,     //< a block {||...}\n }\n \n fn name_of_fn(fk: fn_kind) -> ident {"}]}