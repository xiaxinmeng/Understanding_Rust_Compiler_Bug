{"sha": "a2491ee4e6c74451371aee8f4a2a5786d7a35406", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNDkxZWU0ZTZjNzQ0NTEzNzFhZWU4ZjRhMmE1Nzg2ZDdhMzU0MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-14T08:03:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-14T08:03:01Z"}, "message": "Auto merge of #66403 - JohnTitor:rollup-7obuivl, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #66253 (Improve errors after re rebalance coherence)\n - #66264 (fix an ICE in macro's diagnostic message)\n - #66349 (expand source_util macros with def-site context)\n - #66351 (Tweak non-char/numeric in range pattern diagnostic)\n - #66360 (Fix link to Exten in Vec::set_len)\n - #66361 (parser: don't use `unreachable!()` in `fn unexpected`.)\n - #66363 (Improve error message in make_tests)\n - #66369 (compiletest: Obtain timestamps for common inputs only once)\n - #66372 (Fix broken links in Ipv4Addr::is_benchmarking docs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "276dc5a1368ab04c84a6387bf15bffab129aa5ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/276dc5a1368ab04c84a6387bf15bffab129aa5ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2491ee4e6c74451371aee8f4a2a5786d7a35406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2491ee4e6c74451371aee8f4a2a5786d7a35406", "html_url": "https://github.com/rust-lang/rust/commit/a2491ee4e6c74451371aee8f4a2a5786d7a35406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2491ee4e6c74451371aee8f4a2a5786d7a35406/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e380b797b22e5361a43b2b82f6278df17d89f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e380b797b22e5361a43b2b82f6278df17d89f3e", "html_url": "https://github.com/rust-lang/rust/commit/5e380b797b22e5361a43b2b82f6278df17d89f3e"}, {"sha": "d145d1e72c184177f40447c63b2813dcef729860", "url": "https://api.github.com/repos/rust-lang/rust/commits/d145d1e72c184177f40447c63b2813dcef729860", "html_url": "https://github.com/rust-lang/rust/commit/d145d1e72c184177f40447c63b2813dcef729860"}], "stats": {"total": 667, "additions": 430, "deletions": 237}, "files": [{"sha": "b1741f00507a42a7323388dacc133198fcaa83ac", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -861,7 +861,7 @@ impl<T> Vec<T> {\n     ///\n     /// [`truncate`]: #method.truncate\n     /// [`resize`]: #method.resize\n-    /// [`extend`]: #method.extend-1\n+    /// [`extend`]: ../../std/iter/trait.Extend.html#tymethod.extend\n     /// [`clear`]: #method.clear\n     ///\n     /// # Safety"}, {"sha": "778bba1eef68f099998fdf2858467ee1f62fa5d3", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -238,7 +238,7 @@ pub fn trait_ref_is_local_or_fundamental<'tcx>(\n \n pub enum OrphanCheckErr<'tcx> {\n     NonLocalInputType(Vec<(Ty<'tcx>, bool /* Is this the first input type? */)>),\n-    UncoveredTy(Ty<'tcx>),\n+    UncoveredTy(Ty<'tcx>, Option<Ty<'tcx>>),\n }\n \n /// Checks the coherence orphan rules. `impl_def_id` should be the\n@@ -402,7 +402,15 @@ fn orphan_check_trait_ref<'tcx>(\n             return Ok(());\n         } else if let ty::Param(_) = input_ty.kind {\n             debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n-            return Err(OrphanCheckErr::UncoveredTy(input_ty))\n+            let local_type = trait_ref\n+                .input_types()\n+                .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+                .filter(|ty| ty_is_non_local_constructor(tcx, ty, in_crate).is_none())\n+                .next();\n+\n+            debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n+\n+            return Err(OrphanCheckErr::UncoveredTy(input_ty, local_type))\n         }\n         if let Some(non_local_tys) = non_local_tys {\n             for input_ty in non_local_tys {"}, {"sha": "1f386b8bbbf547da4273958dbc37ae224db30ea4", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -1742,14 +1742,25 @@ impl<'a> Parser<'a> {\n     }\n \n     fn report_invalid_macro_expansion_item(&self) {\n+        let has_close_delim = self.sess.source_map()\n+            .span_to_snippet(self.prev_span)\n+            .map(|s| s.ends_with(\")\") || s.ends_with(\"]\"))\n+            .unwrap_or(false);\n+        let right_brace_span = if has_close_delim {\n+            // it's safe to peel off one character only when it has the close delim\n+            self.prev_span.with_lo(self.prev_span.hi() - BytePos(1))\n+        } else {\n+            self.sess.source_map().next_point(self.prev_span)\n+        };\n+\n         self.struct_span_err(\n             self.prev_span,\n             \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n         ).multipart_suggestion(\n             \"change the delimiters to curly braces\",\n             vec![\n-                (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), String::from(\" {\")),\n-                (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n+                (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), \"{\".to_string()),\n+                (right_brace_span, '}'.to_string()),\n             ],\n             Applicability::MaybeIncorrect,\n         ).span_suggestion("}, {"sha": "d5d8604be858d1599c6db20d9051244a94149f5f", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -443,7 +443,9 @@ impl<'a> Parser<'a> {\n     crate fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),\n-            Ok(_) => unreachable!(),\n+            // We can get `Ok(true)` from `recover_closing_delimiter`\n+            // which is called in `expected_one_of_not_found`.\n+            Ok(_) => FatalError.raise(),\n         }\n     }\n "}, {"sha": "9421dbc2b2c766cfd8183a7a511a1ebc2e0f546f", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -362,37 +362,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || ty.is_char()\n             || ty.references_error()\n         };\n-        let lhs_compat = numeric_or_char(lhs_ty);\n-        let rhs_compat = numeric_or_char(rhs_ty);\n-\n-        if !lhs_compat || !rhs_compat {\n-            let span = if !lhs_compat && !rhs_compat {\n-                span\n-            } else if !lhs_compat {\n-                begin.span\n-            } else {\n-                end.span\n-            };\n+        let lhs_fail = !numeric_or_char(lhs_ty);\n+        let rhs_fail = !numeric_or_char(rhs_ty);\n \n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                span,\n-                E0029,\n-                \"only char and numeric types are allowed in range patterns\"\n+        if lhs_fail || rhs_fail {\n+            self.emit_err_pat_range(\n+                span, begin.span, end.span, lhs_fail, rhs_fail, lhs_ty, rhs_ty\n             );\n-            err.span_label(span, \"ranges require char or numeric types\");\n-            err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n-            err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n-            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"In a match expression, only numbers and characters can be matched \\\n-                        against a range. This is because the compiler checks that the range \\\n-                        is non-empty at compile-time, and is unable to evaluate arbitrary \\\n-                        comparison functions. If you want to capture values of an orderable \\\n-                        type between two end-points, you can use a guard.\"\n-                    );\n-            }\n-            err.emit();\n             return None;\n         }\n \n@@ -406,6 +382,62 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(common_type)\n     }\n \n+    fn emit_err_pat_range(\n+        &self,\n+        span: Span,\n+        begin_span: Span,\n+        end_span: Span,\n+        lhs_fail: bool,\n+        rhs_fail: bool,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_ty: Ty<'tcx>,\n+    ) {\n+        let span = if lhs_fail && rhs_fail {\n+            span\n+        } else if lhs_fail {\n+            begin_span\n+        } else {\n+            end_span\n+        };\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0029,\n+            \"only char and numeric types are allowed in range patterns\"\n+        );\n+        let msg = |ty| {\n+            format!(\"this is of type `{}` but it should be `char` or numeric\", ty)\n+        };\n+        let mut one_side_err = |first_span, first_ty, second_span, second_ty: Ty<'_>| {\n+            err.span_label(first_span, &msg(first_ty));\n+            if !second_ty.references_error() {\n+                err.span_label(\n+                    second_span,\n+                    &format!(\"this is of type `{}`\", second_ty)\n+                );\n+            }\n+        };\n+        if lhs_fail && rhs_fail {\n+            err.span_label(begin_span, &msg(lhs_ty));\n+            err.span_label(end_span, &msg(rhs_ty));\n+        } else if lhs_fail {\n+            one_side_err(begin_span, lhs_ty, end_span, rhs_ty);\n+        } else {\n+            one_side_err(end_span, rhs_ty, begin_span, lhs_ty);\n+        }\n+        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"In a match expression, only numbers and characters can be matched \\\n+                    against a range. This is because the compiler checks that the range \\\n+                    is non-empty at compile-time, and is unable to evaluate arbitrary \\\n+                    comparison functions. If you want to capture values of an orderable \\\n+                    type between two end-points, you can use a guard.\"\n+                );\n+        }\n+        err.emit();\n+    }\n+\n     fn check_pat_ident(\n         &self,\n         pat: &Pat,"}, {"sha": "88fa09cc9366a39d3f9bc24f94c58f5dafe26577", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -77,30 +77,58 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                     err.emit();\n                     return;\n                 }\n-                Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n+                Err(traits::OrphanCheckErr::UncoveredTy(param_ty, local_type)) => {\n                     let mut sp = sp;\n                     for param in &generics.params {\n                         if param.name.ident().to_string() == param_ty.to_string() {\n                             sp = param.span;\n                         }\n                     }\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        sp,\n-                        E0210,\n-                        \"type parameter `{}` must be used as the type parameter for some local \\\n-                         type (e.g., `MyStruct<{}>`)\",\n-                        param_ty,\n-                        param_ty\n-                    );\n-                    err.span_label(sp, format!(\n-                        \"type parameter `{}` must be used as the type parameter for some local \\\n-                         type\",\n-                        param_ty,\n-                    ));\n-                    err.note(\"only traits defined in the current crate can be implemented for a \\\n-                              type parameter\");\n-                    err.emit();\n+\n+                    match local_type {\n+                        Some(local_type) => {\n+                            struct_span_err!(\n+                                self.tcx.sess,\n+                                sp,\n+                                E0210,\n+                                \"type parameter `{}` must be covered by another type \\\n+                                when it appears before the first local type (`{}`)\",\n+                                param_ty,\n+                                local_type\n+                            ).span_label(sp, format!(\n+                                \"type parameter `{}` must be covered by another type \\\n+                                when it appears before the first local type (`{}`)\",\n+                                param_ty,\n+                                local_type\n+                            )).note(\"implementing a foreign trait is only possible if at \\\n+                                    least one of the types for which is it implemented is local, \\\n+                                    and no uncovered type parameters appear before that first \\\n+                                    local type\"\n+                            ).note(\"in this case, 'before' refers to the following order: \\\n+                                    `impl<..> ForeignTrait<T1, ..., Tn> for T0`, \\\n+                                    where `T0` is the first and `Tn` is the last\"\n+                            ).emit();\n+                        }\n+                        None => {\n+                            struct_span_err!(\n+                                self.tcx.sess,\n+                                sp,\n+                                E0210,\n+                                \"type parameter `{}` must be used as the type parameter for some \\\n+                                local type (e.g., `MyStruct<{}>`)\",\n+                                param_ty,\n+                                param_ty\n+                            ).span_label(sp, format!(\n+                                \"type parameter `{}` must be used as the type parameter for some \\\n+                                local type\",\n+                                param_ty,\n+                            )).note(\"implementing a foreign trait is only possible if at \\\n+                                    least one of the types for which is it implemented is local\"\n+                            ).note(\"only traits defined in the current crate can be \\\n+                                    implemented for a type parameter\"\n+                            ).emit();\n+                        }\n+                    };\n                     return;\n                 }\n             }"}, {"sha": "02783f65df537550cc09bc23276e2ec627a83a8d", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -2114,8 +2114,13 @@ E0210: r##\"\n This error indicates a violation of one of Rust's orphan rules for trait\n implementations. The rule concerns the use of type parameters in an\n implementation of a foreign trait (a trait defined in another crate), and\n-states that type parameters must be \"covered\" by a local type. To understand\n-what this means, it is perhaps easiest to consider a few examples.\n+states that type parameters must be \"covered\" by a local type.\n+\n+When implementing a foreign trait for a foreign type,\n+the trait must have one or more type parameters.\n+A type local to your crate must appear before any use of any type parameters.\n+\n+To understand what this means, it is perhaps easier to consider a few examples.\n \n If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n following trait `impl` is an error:\n@@ -2173,12 +2178,18 @@ impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n \n where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\n are types. One of the types `T0, ..., Tn` must be a local type (this is another\n-orphan rule, see the explanation for E0117). Let `i` be the smallest integer\n-such that `Ti` is a local type. Then no type parameter can appear in any of the\n-`Tj` for `j < i`.\n+orphan rule, see the explanation for E0117).\n \n-For information on the design of the orphan rules, see [RFC 1023].\n+Both of the following must be true:\n+1. At least one of the types `T0..=Tn` must be a local type.\n+Let `Ti` be the first such type.\n+2. No uncovered type parameters `P1..=Pm` may appear in `T0..Ti`\n+(excluding `Ti`).\n+\n+For information on the design of the orphan rules,\n+see [RFC 2451] and [RFC 1023].\n \n+[RFC 2451]: https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html\n [RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n \"##,\n "}, {"sha": "e51a9b624498d16424c35261b28186897280fbfe", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -633,8 +633,8 @@ impl Ipv4Addr {\n     /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n     /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n     ///\n-    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n-    /// [errate 423]: https://www.rfc-editor.org/errata/eid423\n+    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n+    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n     /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples"}, {"sha": "3d27af2f210a5f259a8847275002851d3254ca43", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -21,6 +21,7 @@ use rustc_data_structures::sync::Lrc;\n /// line!(): expands to the current line number\n pub fn expand_line(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                    -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -32,6 +33,7 @@ pub fn expand_line(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n /* column!(): expands to the current column number */\n pub fn expand_column(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                   -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -45,6 +47,7 @@ pub fn expand_column(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n /// out if we wanted.\n pub fn expand_file(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                    -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -54,12 +57,14 @@ pub fn expand_file(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n \n pub fn expand_stringify(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                         -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     let s = pprust::tts_to_string(tts);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                   -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n@@ -72,6 +77,7 @@ pub fn expand_mod(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n /// unhygienically.\n pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                            -> Box<dyn base::MacResult+'cx> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n         None => return DummyResult::any(sp),\n@@ -125,6 +131,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                           -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n         None => return DummyResult::any(sp)\n@@ -156,6 +163,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n \n pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n                             -> Box<dyn base::MacResult+'static> {\n+    let sp = cx.with_def_site_ctxt(sp);\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n         None => return DummyResult::any(sp)"}, {"sha": "6ecfb2c5eb0e32f7e153e4ccb6cd2483c018ba9a", "filename": "src/test/ui/coherence/coherence-all-remote.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-all-remote.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-all-remote.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-all-remote.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for isize { }\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "d431c5f4b52519a66ca68dfb41eb9b90defce42a", "filename": "src/test/ui/coherence/coherence-bigint-param.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-bigint-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-bigint-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-bigint-param.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -1,10 +1,11 @@\n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`BigInt`)\n   --> $DIR/coherence-bigint-param.rs:8:6\n    |\n LL | impl<T> Remote1<BigInt> for T { }\n-   |      ^ type parameter `T` must be used as the type parameter for some local type\n+   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`BigInt`)\n    |\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to previous error\n "}, {"sha": "c00751a0f2338d97924baa57e3ce04a335a87377", "filename": "src/test/ui/coherence/coherence-cross-crate-conflict.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -13,6 +13,7 @@ error[E0210]: type parameter `A` must be used as the type parameter for some loc\n LL | impl<A> Foo for A {\n    |      ^ type parameter `A` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "2c3b4fc3ad2a86ec0de1874f81f271015aef5502", "filename": "src/test/ui/coherence/coherence-lone-type-parameter.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-lone-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-lone-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-lone-type-parameter.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote for T { }\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "8a951d407ca4668b49007c67f933c9746cf2c488", "filename": "src/test/ui/coherence/impl[t]-foreign-for-fundamental[t].stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote for Box<T> {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "c5759244eff498e594e69e27a8615c52ec697ee7", "filename": "src/test/ui/coherence/impl[t]-foreign[foreign]-for-fundamental[t].stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-fundamental%5Bt%5D.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<u32> for Box<T> {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -12,6 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<u32> for &'a T {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "e8663fd7d820d9078c050812a187168aba70effd", "filename": "src/test/ui/coherence/impl[t]-foreign[foreign]-for-t.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-t.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<u32> for T {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "639bee2b8ec74ee3892f5487137a6fffd35dd613", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]]-for-foreign.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-foreign.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<Box<T>> for u32 {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -12,6 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<&'a T> for u32 {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "0b6c81b53cd5ff7b26092668d1f8ad8b65a37125", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]]-for-fundamental[t].stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-fundamental%5Bt%5D.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<Box<T>> for &'a T {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -12,6 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<&'a T> for Box<T> {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "fe40490822e0f3183132f366b57001771b256b5d", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]]-for-t.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-t.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<Box<T>> for T {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -12,6 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<&'a T> for T {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "c9e3594cd342f3a58ec01eb72aaa2b767e736849", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]_local]-for-foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -8,11 +8,11 @@ use std::rc::Rc;\n struct Local;\n \n impl<T> Remote2<Box<T>, Local> for u32 {\n-    //~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+    //~^ ERROR type parameter `T` must be covered by another type\n }\n \n impl<'a, T> Remote2<&'a T, Local> for u32 {\n-    //~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+    //~^ ERROR type parameter `T` must be covered by another type\n }\n \n fn main() {}"}, {"sha": "1eaef59b3f8804095442669883e0a9a60cc0960f", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]_local]-for-foreign.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -1,18 +1,20 @@\n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   --> $DIR/impl[t]-foreign[fundamental[t]_local]-for-foreign.rs:10:6\n    |\n LL | impl<T> Remote2<Box<T>, Local> for u32 {\n-   |      ^ type parameter `T` must be used as the type parameter for some local type\n+   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   --> $DIR/impl[t]-foreign[fundamental[t]_local]-for-foreign.rs:14:10\n    |\n LL | impl<'a, T> Remote2<&'a T, Local> for u32 {\n-   |          ^ type parameter `T` must be used as the type parameter for some local type\n+   |          ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7709bd9c89b6f3420f010e1043972f6e72ee0dd3", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-fundamental[t].rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -8,11 +8,11 @@ use std::rc::Rc;\n struct Local;\n \n impl<T> Remote1<Local> for Box<T> {\n-    //~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+    //~^ ERROR type parameter `T` must be covered by another type\n }\n \n impl<T> Remote1<Local> for &T {\n-    //~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+    //~^ ERROR type parameter `T` must be covered by another type\n }\n \n fn main() {}"}, {"sha": "4d39186d494c996093d18443070f26ed63610ec0", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-fundamental[t].stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -1,18 +1,20 @@\n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   --> $DIR/impl[t]-foreign[local]-for-fundamental[t].rs:10:6\n    |\n LL | impl<T> Remote1<Local> for Box<T> {\n-   |      ^ type parameter `T` must be used as the type parameter for some local type\n+   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   --> $DIR/impl[t]-foreign[local]-for-fundamental[t].rs:14:6\n    |\n LL | impl<T> Remote1<Local> for &T {\n-   |      ^ type parameter `T` must be used as the type parameter for some local type\n+   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to 2 previous errors\n "}, {"sha": "eed3a4b5c235bac44d7ab494702ab91832b4f445", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-t.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -8,7 +8,7 @@ use std::rc::Rc;\n struct Local;\n \n impl<T> Remote1<Local> for T {\n-    //~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+    //~^ ERROR type parameter `T` must be covered by another type\n }\n \n fn main() {}"}, {"sha": "d74be4cec728df020dfc93bb3f800e3e6b243581", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-t.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -1,10 +1,11 @@\n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   --> $DIR/impl[t]-foreign[local]-for-t.rs:10:6\n    |\n LL | impl<T> Remote1<Local> for T {\n-   |      ^ type parameter `T` must be used as the type parameter for some local type\n+   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to previous error\n "}, {"sha": "b26feb4914c63830ffc5d9ec1c90d49954f705bf", "filename": "src/test/ui/coherence/impl[t]-foreign[t]-for-foreign.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-foreign.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for u32 {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "5e8cc552c98341ba94d48ac6eb107767aac80c45", "filename": "src/test/ui/coherence/impl[t]-foreign[t]-for-fundamental.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-fundamental.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-fundamental.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-fundamental.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for Box<T> {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `B` must be used as the type parameter for some local type (e.g., `MyStruct<B>`)\n@@ -12,6 +13,7 @@ error[E0210]: type parameter `B` must be used as the type parameter for some loc\n LL | impl<'a, A, B> Remote1<A> for &'a B {\n    |             ^ type parameter `B` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "d3226d33beec75eb2e85fa2187377a96cbc8b8b7", "filename": "src/test/ui/coherence/impl[t]-foreign[t]-for-t.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-t.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for T {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "ec146ca86f596e446a67ed524e3a381cd57a7c77", "filename": "src/test/ui/error-codes/E0029-teach.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Ferror-codes%2FE0029-teach.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Ferror-codes%2FE0029-teach.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0029-teach.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -2,10 +2,11 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/E0029-teach.rs:7:9\n    |\n LL |         \"hello\" ..= \"world\" => {}\n-   |         ^^^^^^^^^^^^^^^^^^^ ranges require char or numeric types\n+   |         -------^^^^^-------\n+   |         |           |\n+   |         |           this is of type `&'static str` but it should be `char` or numeric\n+   |         this is of type `&'static str` but it should be `char` or numeric\n    |\n-   = note: start type: &'static str\n-   = note: end type: &'static str\n    = note: In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.\n \n error: aborting due to previous error"}, {"sha": "e54722ae7b9b8c04276bc0ca3ebadaeba5c69068", "filename": "src/test/ui/error-codes/E0029.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Ferror-codes%2FE0029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Ferror-codes%2FE0029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0029.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -2,10 +2,10 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/E0029.rs:5:9\n    |\n LL |         \"hello\" ..= \"world\" => {}\n-   |         ^^^^^^^^^^^^^^^^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: &'static str\n-   = note: end type: &'static str\n+   |         -------^^^^^-------\n+   |         |           |\n+   |         |           this is of type `&'static str` but it should be `char` or numeric\n+   |         this is of type `&'static str` but it should be `char` or numeric\n \n error: aborting due to previous error\n "}, {"sha": "2a78cc8b2db26c451f65d6ef3a33df842255c9ae", "filename": "src/test/ui/error-codes/e0119/issue-28981.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -14,6 +14,7 @@ error[E0210]: type parameter `Foo` must be used as the type parameter for some l\n LL | impl<Foo> Deref for Foo { }\n    |      ^^^ type parameter `Foo` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "9f164822deacb5381667ca51a2f12aa9fb9dbb83", "filename": "src/test/ui/issues/issue-41974.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -21,6 +21,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Drop for T where T: A {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 3 previous errors"}, {"sha": "252d4cbf162415f67159b94f0a9a5af59cc4aeb6", "filename": "src/test/ui/match/match-range-fail.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -3,15 +3,16 @@ fn main() {\n         \"bar\" ..= \"foo\" => { }\n     };\n     //~^^ ERROR only char and numeric types are allowed in range\n-    //~| start type: &'static str\n-    //~| end type: &'static str\n \n     match \"wow\" {\n         10 ..= \"what\" => ()\n     };\n     //~^^ ERROR only char and numeric types are allowed in range\n-    //~| start type: {integer}\n-    //~| end type: &'static str\n+\n+    match \"wow\" {\n+        true ..= \"what\" => {}\n+    };\n+    //~^^ ERROR only char and numeric types are allowed in range\n \n     match 5 {\n         'c' ..= 100 => { }"}, {"sha": "25fa9c2f6182e8e58a47a1fe31dfc03bb16a98ba", "filename": "src/test/ui/match/match-range-fail.stderr", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -2,30 +2,38 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/match-range-fail.rs:3:9\n    |\n LL |         \"bar\" ..= \"foo\" => { }\n-   |         ^^^^^^^^^^^^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: &'static str\n-   = note: end type: &'static str\n+   |         -----^^^^^-----\n+   |         |         |\n+   |         |         this is of type `&'static str` but it should be `char` or numeric\n+   |         this is of type `&'static str` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/match-range-fail.rs:10:16\n+  --> $DIR/match-range-fail.rs:8:16\n    |\n LL |         10 ..= \"what\" => ()\n-   |                ^^^^^^ ranges require char or numeric types\n+   |         --     ^^^^^^ this is of type `&'static str` but it should be `char` or numeric\n+   |         |\n+   |         this is of type `{integer}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/match-range-fail.rs:13:9\n    |\n-   = note: start type: {integer}\n-   = note: end type: &'static str\n+LL |         true ..= \"what\" => {}\n+   |         ----^^^^^------\n+   |         |        |\n+   |         |        this is of type `&'static str` but it should be `char` or numeric\n+   |         this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/match-range-fail.rs:17:9\n+  --> $DIR/match-range-fail.rs:18:9\n    |\n LL |         'c' ..= 100 => { }\n    |         ^^^^^^^^^^^ expected integer, found char\n    |\n    = note: expected type `{integer}`\n               found type `char`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0029, E0308.\n For more information about an error, try `rustc --explain E0029`."}, {"sha": "c84d401898c91b5772d2142e9bda7854cb55901d", "filename": "src/test/ui/orphan-check-diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Forphan-check-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Forphan-check-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Forphan-check-diagnostics.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -4,6 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> RemoteTrait for T where T: LocalTrait {}\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "1730adfa91419bea63b3a67ca56972406eb972f5", "filename": "src/test/ui/parser/issue-66357-unexpected-unreachable.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -0,0 +1,14 @@\n+// The problem in #66357 was that the call trace:\n+//\n+// - parse_fn_block_decl\n+// - expect_or\n+// - unexpected\n+// - expect_one_of\n+// - expected_one_of_not_found\n+// - recover_closing_delimiter\n+//\n+// ended up bubbling up `Ok(true)` to `unexpected` which then used `unreachable!()`.\n+\n+fn f() { |[](* }\n+//~^ ERROR expected one of `,` or `:`, found `(`\n+//~| ERROR expected one of `)`, `-`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`"}, {"sha": "00d84e2afe353fcd3f84dfb16db0b90ca1296cf4", "filename": "src/test/ui/parser/issue-66357-unexpected-unreachable.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -0,0 +1,16 @@\n+error: expected one of `,` or `:`, found `(`\n+  --> $DIR/issue-66357-unexpected-unreachable.rs:12:13\n+   |\n+LL | fn f() { |[](* }\n+   |             ^ expected one of `,` or `:`\n+\n+error: expected one of `)`, `-`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`\n+  --> $DIR/issue-66357-unexpected-unreachable.rs:12:14\n+   |\n+LL | fn f() { |[](* }\n+   |             -^ help: `)` may belong here\n+   |             |\n+   |             unclosed delimiter\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f9019b78c8d3862e86de88406cf41688cec117d7", "filename": "src/test/ui/parser/macros-no-semicolon-items.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -6,8 +6,8 @@ LL | macro_rules! foo()\n    |\n help: change the delimiters to curly braces\n    |\n-LL | macro_rules! foo {}\n-   |                  ^^\n+LL | macro_rules! foo{}\n+   |                 ^^\n help: add a semicolon\n    |\n LL | macro_rules! foo();\n@@ -26,7 +26,7 @@ LL | | )\n    |\n help: change the delimiters to curly braces\n    |\n-LL | bar! {\n+LL | bar!{\n LL |     blah\n LL |     blah\n LL |     blah"}, {"sha": "689176b3eb75b76489f665a2b5a47d6b685ab046", "filename": "src/test/ui/parser/mbe_missing_right_paren.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -0,0 +1,3 @@\n+// ignore-tidy-trailing-newlines\n+// error-pattern: aborting due to 3 previous errors\n+macro_rules! abc(\u063c\n\\ No newline at end of file"}, {"sha": "4504fc0eb0004843cfd0f7a830b3dbb0225abcec", "filename": "src/test/ui/parser/mbe_missing_right_paren.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmbe_missing_right_paren.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -0,0 +1,31 @@\n+error: this file contains an un-closed delimiter\n+  --> $DIR/mbe_missing_right_paren.rs:3:19\n+   |\n+LL | macro_rules! abc(\u063c\n+   |                 - ^\n+   |                 |\n+   |                 un-closed delimiter\n+\n+error: macros that expand to items must be delimited with braces or followed by a semicolon\n+  --> $DIR/mbe_missing_right_paren.rs:3:17\n+   |\n+LL | macro_rules! abc(\u063c\n+   |                 ^^\n+   |\n+help: change the delimiters to curly braces\n+   |\n+LL | macro_rules! abc{\u063c}\n+   |                 ^ ^\n+help: add a semicolon\n+   |\n+LL | macro_rules! abc(\u063c;\n+   |                   ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/mbe_missing_right_paren.rs:3:1\n+   |\n+LL | macro_rules! abc(\u063c\n+   | ^^^^^^^^^^^^^^^^^^ missing tokens in macro arguments\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "160ab18e34a54a1657714a9558bbbe2f3499f377", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -401,19 +401,17 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:19:12\n    |\n LL |     if let true..Y = 0 {}\n-   |            ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: bool\n-   = note: end type: u8\n+   |            ^^^^  - this is of type `u8`\n+   |            |\n+   |            this is of type `bool` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:20:15\n    |\n LL |     if let X..true = 0 {}\n-   |               ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: u8\n-   = note: end type: bool\n+   |            -  ^^^^ this is of type `bool` but it should be `char` or numeric\n+   |            |\n+   |            this is of type `u8`\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:21:12\n@@ -437,19 +435,17 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:32:12\n    |\n LL |     if let true..=Y = 0 {}\n-   |            ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: bool\n-   = note: end type: u8\n+   |            ^^^^   - this is of type `u8`\n+   |            |\n+   |            this is of type `bool` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:33:16\n    |\n LL |     if let X..=true = 0 {}\n-   |                ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: u8\n-   = note: end type: bool\n+   |            -   ^^^^ this is of type `bool` but it should be `char` or numeric\n+   |            |\n+   |            this is of type `u8`\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:34:12\n@@ -473,19 +469,17 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:45:12\n    |\n LL |     if let true...Y = 0 {}\n-   |            ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: bool\n-   = note: end type: u8\n+   |            ^^^^   - this is of type `u8`\n+   |            |\n+   |            this is of type `bool` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:47:16\n    |\n LL |     if let X...true = 0 {}\n-   |                ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: u8\n-   = note: end type: bool\n+   |            -   ^^^^ this is of type `bool` but it should be `char` or numeric\n+   |            |\n+   |            this is of type `u8`\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:49:12\n@@ -509,10 +503,7 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:60:12\n    |\n LL |     if let true.. = 0 {}\n-   |            ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: bool\n-   = note: end type: [type error]\n+   |            ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:62:12\n@@ -527,10 +518,7 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:70:12\n    |\n LL |     if let true..= = 0 {}\n-   |            ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: bool\n-   = note: end type: [type error]\n+   |            ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:72:12\n@@ -545,10 +533,7 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:82:12\n    |\n LL |     if let true... = 0 {}\n-   |            ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: bool\n-   = note: end type: [type error]\n+   |            ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:85:12\n@@ -563,10 +548,7 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:94:14\n    |\n LL |     if let ..true = 0 {}\n-   |              ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: [type error]\n-   = note: end type: bool\n+   |              ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:96:12\n@@ -581,10 +563,7 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:104:15\n    |\n LL |     if let ..=true = 0 {}\n-   |               ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: [type error]\n-   = note: end type: bool\n+   |               ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:106:12\n@@ -599,10 +578,7 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:116:15\n    |\n LL |     if let ...true = 0 {}\n-   |               ^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: [type error]\n-   = note: end type: bool\n+   |               ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:119:12"}, {"sha": "78768d282e7c44c1825afdefe05fa288325adba9", "filename": "src/test/ui/pattern/patkind-litrange-no-expr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -7,11 +7,11 @@ LL |     Arith = 1 + 1,\n error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/patkind-litrange-no-expr.rs:20:13\n    |\n+LL |                 $( $value ..= 42 => Some($name::$variant), )* // PatKind::Range\n+   |                               -- this is of type `{integer}`\n+...\n LL |     Arith = 1 + 1,\n-   |             ^^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: {integer}\n-   = note: end type: {integer}\n+   |             ^^^^^ this is of type `_` but it should be `char` or numeric\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7a74a37021bdbe064fac8959030863db732bfc22", "filename": "src/test/ui/qualified/qualified-path-params.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -8,10 +8,9 @@ error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/qualified-path-params.rs:22:15\n    |\n LL |         0 ..= <S as Tr>::A::f::<u8> => {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: {integer}\n-   = note: end type: fn() {S::f::<u8>}\n+   |         -     ^^^^^^^^^^^^^^^^^^^^^ this is of type `fn() {S::f::<u8>}` but it should be `char` or numeric\n+   |         |\n+   |         this is of type `{integer}`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "15f8abd75d59a9c0061f3cb6cbf1fc065892c7e5", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 91, "deletions": 73, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2491ee4e6c74451371aee8f4a2a5786d7a35406/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=a2491ee4e6c74451371aee8f4a2a5786d7a35406", "patch": "@@ -574,22 +574,59 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n \n pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {:?}\", config.src_base.display());\n+    let inputs = common_inputs_stamp(config);\n     let mut tests = Vec::new();\n     collect_tests_from_dir(\n         config,\n         &config.src_base,\n         &config.src_base,\n         &PathBuf::new(),\n+        &inputs,\n         &mut tests,\n-    ).unwrap();\n+    ).expect(&format!(\"Could not read tests from {}\", config.src_base.display()));\n     tests\n }\n \n+/// Returns a stamp constructed from input files common to all test cases.\n+fn common_inputs_stamp(config: &Config) -> Stamp {\n+    let rust_src_dir = config\n+        .find_rust_src_root()\n+        .expect(\"Could not find Rust source root\");\n+\n+    let mut stamp = Stamp::from_path(&config.rustc_path);\n+\n+    // Relevant pretty printer files\n+    let pretty_printer_files = [\n+        \"src/etc/debugger_pretty_printers_common.py\",\n+        \"src/etc/gdb_load_rust_pretty_printers.py\",\n+        \"src/etc/gdb_rust_pretty_printing.py\",\n+        \"src/etc/lldb_batchmode.py\",\n+        \"src/etc/lldb_rust_formatters.py\",\n+    ];\n+    for file in &pretty_printer_files {\n+        let path = rust_src_dir.join(file);\n+        stamp.add_path(&path);\n+    }\n+\n+    stamp.add_dir(&config.run_lib_path);\n+\n+    if let Some(ref rustdoc_path) = config.rustdoc_path {\n+        stamp.add_path(&rustdoc_path);\n+        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n+    }\n+\n+    // Compiletest itself.\n+    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n+\n+    stamp\n+}\n+\n fn collect_tests_from_dir(\n     config: &Config,\n     base: &Path,\n     dir: &Path,\n     relative_dir_path: &Path,\n+    inputs: &Stamp,\n     tests: &mut Vec<test::TestDescAndFn>,\n ) -> io::Result<()> {\n     // Ignore directories that contain a file named `compiletest-ignore-dir`.\n@@ -602,7 +639,7 @@ fn collect_tests_from_dir(\n             file: dir.to_path_buf(),\n             relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n         };\n-        tests.extend(make_test(config, &paths));\n+        tests.extend(make_test(config, &paths, inputs));\n         return Ok(());\n     }\n \n@@ -627,12 +664,14 @@ fn collect_tests_from_dir(\n                 file: file_path,\n                 relative_dir: relative_dir_path.to_path_buf(),\n             };\n-            tests.extend(make_test(config, &paths))\n+            tests.extend(make_test(config, &paths, inputs))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(config, base, &file_path, &relative_file_path, tests)?;\n+                collect_tests_from_dir(\n+                    config, base, &file_path, &relative_file_path,\n+                    inputs, tests)?;\n             }\n         } else {\n             debug!(\"found other file/directory: {:?}\", file_path.display());\n@@ -655,7 +694,7 @@ pub fn is_test(file_name: &OsString) -> bool {\n     !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n }\n \n-pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAndFn> {\n+fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test::TestDescAndFn> {\n     let early_props = if config.mode == Mode::RunMake {\n         // Allow `ignore` directives to be in the Makefile.\n         EarlyProps::from_file(config, &testpaths.file.join(\"Makefile\"))\n@@ -685,19 +724,21 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAn\n     revisions\n         .into_iter()\n         .map(|revision| {\n-            // Debugging emscripten code doesn't make sense today\n             let ignore = early_props.ignore == Ignore::Ignore\n-                || !up_to_date(\n-                    config,\n-                    testpaths,\n-                    &early_props,\n-                    revision.map(|s| s.as_str()),\n-                )\n+                // Debugging emscripten code doesn't make sense today\n                 || ((config.mode == DebugInfoGdbLldb || config.mode == DebugInfoCdb ||\n                      config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n                     && config.target.contains(\"emscripten\"))\n                 || (config.mode == DebugInfoGdb && !early_props.ignore.can_run_gdb())\n-                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb());\n+                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb())\n+                // Ignore tests that already run and are up to date with respect to inputs.\n+                || is_up_to_date(\n+                    config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                    inputs,\n+                );\n             test::TestDescAndFn {\n                 desc: test::TestDesc {\n                     name: make_test_name(config, testpaths, revision),\n@@ -716,98 +757,75 @@ fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> Path\n     output_base_dir(config, testpaths, revision).join(\"stamp\")\n }\n \n-fn up_to_date(\n+fn is_up_to_date(\n     config: &Config,\n     testpaths: &TestPaths,\n     props: &EarlyProps,\n     revision: Option<&str>,\n+    inputs: &Stamp,\n ) -> bool {\n     let stamp_name = stamp(config, testpaths, revision);\n     // Check hash.\n     let contents = match fs::read_to_string(&stamp_name) {\n         Ok(f) => f,\n         Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n-        Err(_) => return true,\n+        Err(_) => return false,\n     };\n     let expected_hash = runtest::compute_stamp_hash(config);\n     if contents != expected_hash {\n-        return true;\n+        return false;\n     }\n \n     // Check timestamps.\n-    let rust_src_dir = config\n-        .find_rust_src_root()\n-        .expect(\"Could not find Rust source root\");\n-    let stamp = Stamp::from_path(&stamp_name);\n-    let mut inputs = vec![Stamp::from_path(&testpaths.file), Stamp::from_path(&config.rustc_path)];\n-    inputs.extend(\n-        props\n-            .aux\n-            .iter()\n-            .map(|aux| {\n-                Stamp::from_path(&testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux))\n-            }),\n-    );\n-    // Relevant pretty printer files\n-    let pretty_printer_files = [\n-        \"src/etc/debugger_pretty_printers_common.py\",\n-        \"src/etc/gdb_load_rust_pretty_printers.py\",\n-        \"src/etc/gdb_rust_pretty_printing.py\",\n-        \"src/etc/lldb_batchmode.py\",\n-        \"src/etc/lldb_rust_formatters.py\",\n-    ];\n-    inputs.extend(pretty_printer_files.iter().map(|pretty_printer_file| {\n-        Stamp::from_path(&rust_src_dir.join(pretty_printer_file))\n-    }));\n-    inputs.extend(Stamp::from_dir(&config.run_lib_path));\n-    if let Some(ref rustdoc_path) = config.rustdoc_path {\n-        inputs.push(Stamp::from_path(&rustdoc_path));\n-        inputs.push(Stamp::from_path(&rust_src_dir.join(\"src/etc/htmldocck.py\")));\n+    let mut inputs = inputs.clone();\n+    inputs.add_path(&testpaths.file);\n+\n+    for aux in &props.aux {\n+        let path = testpaths.file.parent()\n+            .unwrap()\n+            .join(\"auxiliary\")\n+            .join(aux);\n+        inputs.add_path(&path);\n     }\n \n     // UI test files.\n-    inputs.extend(UI_EXTENSIONS.iter().map(|extension| {\n+    for extension in UI_EXTENSIONS {\n         let path = &expected_output_path(testpaths, revision, &config.compare_mode, extension);\n-        Stamp::from_path(path)\n-    }));\n-\n-    // Compiletest itself.\n-    inputs.extend(Stamp::from_dir(&rust_src_dir.join(\"src/tools/compiletest/\")));\n+        inputs.add_path(path);\n+    }\n \n-    inputs.iter().any(|input| input > &stamp)\n+    inputs < Stamp::from_path(&stamp_name)\n }\n \n-#[derive(Debug, PartialEq, PartialOrd, Ord, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n struct Stamp {\n     time: SystemTime,\n-    file: PathBuf,\n }\n \n impl Stamp {\n-    fn from_path(p: &Path) -> Self {\n-        let time = fs::metadata(p)\n+    fn from_path(path: &Path) -> Self {\n+        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n+        stamp.add_path(path);\n+        stamp\n+    }\n+\n+    fn add_path(&mut self, path: &Path) {\n+        let modified = fs::metadata(path)\n             .and_then(|metadata| metadata.modified())\n             .unwrap_or(SystemTime::UNIX_EPOCH);\n-\n-        Stamp {\n-            time,\n-            file: p.into(),\n-        }\n+        self.time = self.time.max(modified);\n     }\n \n-    fn from_dir(path: &Path) -> impl Iterator<Item = Stamp> {\n-        WalkDir::new(path)\n-            .into_iter()\n-            .map(|entry| entry.unwrap())\n-            .filter(|entry| entry.file_type().is_file())\n-            .map(|entry| {\n-                let time = (|| -> io::Result<_> { entry.metadata()?.modified() })();\n-\n-                Stamp {\n-                    time: time.unwrap_or(SystemTime::UNIX_EPOCH),\n-                    file: entry.path().into(),\n-                }\n-            })\n+    fn add_dir(&mut self, path: &Path) {\n+        for entry in WalkDir::new(path) {\n+            let entry = entry.unwrap();\n+            if entry.file_type().is_file() {\n+                let modified = entry.metadata().ok()\n+                    .and_then(|metadata| metadata.modified().ok())\n+                    .unwrap_or(SystemTime::UNIX_EPOCH);\n+                self.time = self.time.max(modified);\n+            }\n+        }\n     }\n }\n "}]}