{"sha": "fd868d02d150ce5cd73fbe7f3aee06ca14333ac8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODY4ZDAyZDE1MGNlNWNkNzNmYmU3ZjNhZWUwNmNhMTQzMzNhYzg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-01-31T00:47:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-31T00:47:36Z"}, "message": "Rollup merge of #81484 - Kogia-sima:perf/optimize-udiv_1e19, r=nagisa\n\nOptimize decimal formatting of 128-bit integers\n\n## Description\n\nThis PR optimizes the `udivmod_1e19` function, which is used for formatting 128-bit integers, based on the algorithm provided in \\[1\\]. This optimization improves performance of formatting 128-bit integers, especially on 64-bit architectures. It also slightly reduces the output binary size.\n\n## Assembler comparison\n\nhttps://godbolt.org/z/YrG5zY\n\n## Performance\n\n#### previous results\n\n```\ntest fmt::write_u128_max                                        ... bench:         552 ns/iter (+/- 4)\ntest fmt::write_u128_min                                        ... bench:         125 ns/iter (+/- 2)\n```\n\n#### new results\n\n```\ntest fmt::write_u128_max                                        ... bench:         205 ns/iter (+/- 13)\ntest fmt::write_u128_min                                        ... bench:         129 ns/iter (+/- 5)\n```\n\n## Reference\n\n\\[1\\] T. Granlund and P. Montgomery, \u201cDivision by Invariant Integers Using Multiplication\u201d in Proc. of the SIGPLAN94 Conference on Programming Language Design and Implementation, 1994, pp. 61\u201372", "tree": {"sha": "1d43be785a8a630eb4bb3d4667e2de9e11073d08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d43be785a8a630eb4bb3d4667e2de9e11073d08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd868d02d150ce5cd73fbe7f3aee06ca14333ac8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgFf4oCRBK7hj4Ov3rIwAAdHIIALBKs8Y2xUJdU8Aw6vZM0yrY\nMVRmCcRmTPFI2porVIBv7Py52SfvPN7SE+vj4HR6bSKKTfQKjSqWbi+he/aSpteg\ntb419Fm/LLkOzmbqAYfT93qsZEHcmbjHM47hRenajnJsN/NIMvDwpISxfuEodShq\ngWdFS2GAAWBcJyvO4zrylb70Aq/VExLdG2RmAdhXlrjg6kyFhrWYxF8OMRQvstCX\nt8+Pligch/fvlzpQp7ZDREO8NZHlx1Ctp9fdoiWtyIlNjhvgINpq1vOc5PsHqhnR\nuK6E88Z8YO58vK+8dBQpmHHjvr5PG1XjXqnO3wC5DOBxWOxDr9NhNiNmDdSObOM=\n=mhOb\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d43be785a8a630eb4bb3d4667e2de9e11073d08\nparent 3e8ae5dcba4e5ad2f9a543df8da1ea679d84e4ce\nparent ada714d9ce80748d6820565135397e46662ace9b\nauthor Jonas Schievink <jonasschievink@gmail.com> 1612054056 +0100\ncommitter GitHub <noreply@github.com> 1612054056 +0100\n\nRollup merge of #81484 - Kogia-sima:perf/optimize-udiv_1e19, r=nagisa\n\nOptimize decimal formatting of 128-bit integers\n\n## Description\n\nThis PR optimizes the `udivmod_1e19` function, which is used for formatting 128-bit integers, based on the algorithm provided in \\[1\\]. This optimization improves performance of formatting 128-bit integers, especially on 64-bit architectures. It also slightly reduces the output binary size.\n\n## Assembler comparison\n\nhttps://godbolt.org/z/YrG5zY\n\n## Performance\n\n#### previous results\n\n```\ntest fmt::write_u128_max                                        ... bench:         552 ns/iter (+/- 4)\ntest fmt::write_u128_min                                        ... bench:         125 ns/iter (+/- 2)\n```\n\n#### new results\n\n```\ntest fmt::write_u128_max                                        ... bench:         205 ns/iter (+/- 13)\ntest fmt::write_u128_min                                        ... bench:         129 ns/iter (+/- 5)\n```\n\n## Reference\n\n\\[1\\] T. Granlund and P. Montgomery, \u201cDivision by Invariant Integers Using Multiplication\u201d in Proc. of the SIGPLAN94 Conference on Programming Language Design and Implementation, 1994, pp. 61\u201372\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd868d02d150ce5cd73fbe7f3aee06ca14333ac8", "html_url": "https://github.com/rust-lang/rust/commit/fd868d02d150ce5cd73fbe7f3aee06ca14333ac8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd868d02d150ce5cd73fbe7f3aee06ca14333ac8/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e8ae5dcba4e5ad2f9a543df8da1ea679d84e4ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e8ae5dcba4e5ad2f9a543df8da1ea679d84e4ce", "html_url": "https://github.com/rust-lang/rust/commit/3e8ae5dcba4e5ad2f9a543df8da1ea679d84e4ce"}, {"sha": "ada714d9ce80748d6820565135397e46662ace9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada714d9ce80748d6820565135397e46662ace9b", "html_url": "https://github.com/rust-lang/rust/commit/ada714d9ce80748d6820565135397e46662ace9b"}], "stats": {"total": 55, "additions": 36, "deletions": 19}, "files": [{"sha": "cdd731fdd4d4e34aa65ef93f84c86a9d6247777c", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fd868d02d150ce5cd73fbe7f3aee06ca14333ac8/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd868d02d150ce5cd73fbe7f3aee06ca14333ac8/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=fd868d02d150ce5cd73fbe7f3aee06ca14333ac8", "patch": "@@ -643,25 +643,42 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n }\n \n /// Partition of `n` into n > 1e19 and rem <= 1e19\n+///\n+/// Integer division algorithm is based on the following paper:\n+///\n+///   T. Granlund and P. Montgomery, \u201cDivision by Invariant Integers Using Multiplication\u201d\n+///   in Proc. of the SIGPLAN94 Conference on Programming Language Design and\n+///   Implementation, 1994, pp. 61\u201372\n+///\n fn udiv_1e19(n: u128) -> (u128, u64) {\n     const DIV: u64 = 1e19 as u64;\n-    let high = (n >> 64) as u64;\n-    if high == 0 {\n-        let low = n as u64;\n-        return ((low / DIV) as u128, low % DIV);\n-    }\n-    let sr = 65 - high.leading_zeros();\n-    let mut q = n << (128 - sr);\n-    let mut r = n >> sr;\n-    let mut carry = 0;\n-\n-    for _ in 0..sr {\n-        r = (r << 1) | (q >> 127);\n-        q = (q << 1) | carry as u128;\n-\n-        let s = (DIV as u128).wrapping_sub(r).wrapping_sub(1) as i128 >> 127;\n-        carry = (s & 1) as u64;\n-        r -= (DIV as u128) & s as u128;\n-    }\n-    ((q << 1) | carry as u128, r as u64)\n+    const FACTOR: u128 = 156927543384667019095894735580191660403;\n+\n+    let quot = if n < 1 << 83 {\n+        ((n >> 19) as u64 / (DIV >> 19)) as u128\n+    } else {\n+        u128_mulhi(n, FACTOR) >> 62\n+    };\n+\n+    let rem = (n - quot * DIV as u128) as u64;\n+    (quot, rem)\n+}\n+\n+/// Multiply unsigned 128 bit integers, return upper 128 bits of the result\n+#[inline]\n+fn u128_mulhi(x: u128, y: u128) -> u128 {\n+    let x_lo = x as u64;\n+    let x_hi = (x >> 64) as u64;\n+    let y_lo = y as u64;\n+    let y_hi = (y >> 64) as u64;\n+\n+    // handle possibility of overflow\n+    let carry = (x_lo as u128 * y_lo as u128) >> 64;\n+    let m = x_lo as u128 * y_hi as u128 + carry;\n+    let high1 = m >> 64;\n+\n+    let m_lo = m as u64;\n+    let high2 = (x_hi as u128 * y_lo as u128 + m_lo as u128) >> 64;\n+\n+    x_hi as u128 * y_hi as u128 + high1 + high2\n }"}]}