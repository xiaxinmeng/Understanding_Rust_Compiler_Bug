{"sha": "d77433386be3d5afa201cfd40dbaaa4d20dbbd80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NzQzMzM4NmJlM2Q1YWZhMjAxY2ZkNDBkYmFhYTRkMjBkYmJkODA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-24T23:07:36Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-24T23:19:38Z"}, "message": "hashmap: add find_mut method", "tree": {"sha": "063f43f9ba4cca32231afd9609f671cc66bd8e2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/063f43f9ba4cca32231afd9609f671cc66bd8e2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d77433386be3d5afa201cfd40dbaaa4d20dbbd80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d77433386be3d5afa201cfd40dbaaa4d20dbbd80", "html_url": "https://github.com/rust-lang/rust/commit/d77433386be3d5afa201cfd40dbaaa4d20dbbd80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d77433386be3d5afa201cfd40dbaaa4d20dbbd80/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "794814945674d27a4fb68aedcea86c39dd5ccd4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/794814945674d27a4fb68aedcea86c39dd5ccd4e", "html_url": "https://github.com/rust-lang/rust/commit/794814945674d27a4fb68aedcea86c39dd5ccd4e"}], "stats": {"total": 35, "additions": 34, "deletions": 1}, "files": [{"sha": "b980082a88c0cd19157a97dd6492b52499733b71", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d77433386be3d5afa201cfd40dbaaa4d20dbbd80/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77433386be3d5afa201cfd40dbaaa4d20dbbd80/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=d77433386be3d5afa201cfd40dbaaa4d20dbbd80", "patch": "@@ -24,6 +24,7 @@ pub mod linear {\n     use rand;\n     use uint;\n     use vec;\n+    use util::unreachable;\n \n     static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -192,6 +193,14 @@ pub mod linear {\n             }\n         }\n \n+        #[inline(always)]\n+        fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n+            match self.buckets[idx] {\n+                Some(ref mut bkt) => &mut bkt.value,\n+                None => unreachable()\n+            }\n+        }\n+\n         /// Inserts the key value pair into the buckets.\n         /// Assumes that there will be a bucket.\n         /// True if there was no previous entry with that key\n@@ -338,7 +347,7 @@ pub mod linear {\n             }\n         }\n \n-        /// Return the value corresponding to the key in the map\n+        /// Return a reference to the value corresponding to the key\n         fn find(&self, k: &K) -> Option<&'self V> {\n             match self.bucket_for_key(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n@@ -410,6 +419,17 @@ pub mod linear {\n             old_value\n         }\n \n+        /// Return a mutable reference to the value corresponding to the key\n+        fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n+            let idx = match self.bucket_for_key(k) {\n+                FoundEntry(idx) => idx,\n+                TableFull | FoundHole(_) => return None\n+            };\n+            unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+                Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n+            }\n+        }\n+\n         /// Return the value corresponding to the key in the map, or insert\n         /// and return the value if it doesn't exist.\n         fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n@@ -655,6 +675,19 @@ pub mod linear {\n             fail_unless!(*m.get(&2) == 4);\n         }\n \n+        #[test]\n+        fn test_find_mut() {\n+            let mut m = LinearMap::new();\n+            fail_unless!(m.insert(1, 12));\n+            fail_unless!(m.insert(2, 8));\n+            fail_unless!(m.insert(5, 14));\n+            let new = 100;\n+            match m.find_mut(&5) {\n+                None => fail!(), Some(x) => *x = new\n+            }\n+            assert_eq!(m.find(&5), Some(&new));\n+        }\n+\n         #[test]\n         pub fn test_insert_overwrite() {\n             let mut m = LinearMap::new();"}]}