{"sha": "93d2a4f82a83e05e798eda697e45f66ddb06026b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZDJhNGY4MmE4M2UwNWU3OThlZGE2OTdlNDVmNjZkZGIwNjAyNmI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T12:34:50Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T12:39:08Z"}, "message": "Add support for basic return-by-alias to trans\n\nIssue #918", "tree": {"sha": "83d042e62b163219172a7b07f5958336bd799779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83d042e62b163219172a7b07f5958336bd799779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93d2a4f82a83e05e798eda697e45f66ddb06026b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93d2a4f82a83e05e798eda697e45f66ddb06026b", "html_url": "https://github.com/rust-lang/rust/commit/93d2a4f82a83e05e798eda697e45f66ddb06026b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93d2a4f82a83e05e798eda697e45f66ddb06026b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a69ee79e0cc90a5d30d10d1d501cfd97cc97cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a69ee79e0cc90a5d30d10d1d501cfd97cc97cf0", "html_url": "https://github.com/rust-lang/rust/commit/9a69ee79e0cc90a5d30d10d1d501cfd97cc97cf0"}], "stats": {"total": 133, "additions": 75, "deletions": 58}, "files": [{"sha": "63cae740cc4ca4c1d492b26cce6a481ef89f17c8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=93d2a4f82a83e05e798eda697e45f66ddb06026b", "patch": "@@ -61,17 +61,18 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n \n // NB: must keep 4 fns in sync:\n //\n-//  - type_of_fn_full\n+//  - type_of_fn\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn type_of_fn_full(cx: @crate_ctxt, sp: span, proto: ast::proto,\n-                   is_method: bool, inputs: [ty::arg], output: ty::t,\n-                   ty_param_count: uint) -> TypeRef {\n+fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n+              is_method: bool, ret_ref: bool, inputs: [ty::arg],\n+              output: ty::t, ty_param_count: uint) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n-    atys += [T_ptr(type_of_inner(cx, sp, output))];\n+    let out_ty = T_ptr(type_of_inner(cx, sp, output));\n+    atys += [ret_ref ? T_ptr(out_ty) : out_ty];\n \n     // Arg 1: task pointer.\n     atys += [T_taskptr(*cx)];\n@@ -97,17 +98,13 @@ fn type_of_fn_full(cx: @crate_ctxt, sp: span, proto: ast::proto,\n     ret T_fn(atys, llvm::LLVMVoidType());\n }\n \n-fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto, inputs: [ty::arg],\n-              output: ty::t, ty_param_count: uint) -> TypeRef {\n-    ret type_of_fn_full(cx, sp, proto, false, inputs, output, ty_param_count);\n-}\n-\n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n                       ty_param_count: uint) -> TypeRef {\n+    let by_ref = ty::ty_fn_ret_style(cx.tcx, fty) == ast::return_ref;\n     ret type_of_fn(cx, sp, ty::ty_fn_proto(cx.tcx, fty),\n-                   ty::ty_fn_args(cx.tcx, fty), ty::ty_fn_ret(cx.tcx, fty),\n-                   ty_param_count);\n+                   false, by_ref, ty::ty_fn_args(cx.tcx, fty),\n+                   ty::ty_fn_ret(cx.tcx, fty), ty_param_count);\n }\n \n fn type_of_native_fn(cx: @crate_ctxt, sp: span, abi: ast::native_abi,\n@@ -2970,12 +2967,13 @@ fn trans_field(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n         vtbl = PointerCast(cx, vtbl, vtbl_type);\n \n         let v = GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n-        let fn_ty: ty::t = ty::method_ty_to_fn_ty(bcx_tcx(cx), methods[ix]);\n         let tcx = bcx_tcx(cx);\n+        let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, methods[ix]);\n+        let ret_ref = ty::ty_fn_ret_style(tcx, fn_ty) == ast::return_ref;\n         let ll_fn_ty =\n-            type_of_fn_full(bcx_ccx(cx), sp, ty::ty_fn_proto(tcx, fn_ty),\n-                            true, ty::ty_fn_args(tcx, fn_ty),\n-                            ty::ty_fn_ret(tcx, fn_ty), 0u);\n+            type_of_fn(bcx_ccx(cx), sp, ty::ty_fn_proto(tcx, fn_ty),\n+                       true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n+                       ty::ty_fn_ret(tcx, fn_ty), 0u);\n         v = PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty)));\n         let lvo = lval_mem(r.bcx, v);\n         ret {llobj: some::<ValueRef>(r.val), method_ty: some::<ty::t>(fn_ty)\n@@ -3513,26 +3511,28 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n \n // NB: must keep 4 fns in sync:\n //\n-//  - type_of_fn_full\n+//  - type_of_fn\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n               lliterbody: option::t<ValueRef>, es: [@ast::expr], fn_ty: ty::t)\n-   ->\n-   {bcx: @block_ctxt,\n-    args: [ValueRef],\n-    retslot: ValueRef,\n-    to_zero: [{v: ValueRef, t: ty::t}],\n-    to_revoke: [{v: ValueRef, t: ty::t}]} {\n+   -> {bcx: @block_ctxt,\n+       args: [ValueRef],\n+       retslot: ValueRef,\n+       to_zero: [{v: ValueRef, t: ty::t}],\n+       to_revoke: [{v: ValueRef, t: ty::t}],\n+       by_ref: bool} {\n \n     let args: [ty::arg] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n     let llargs: [ValueRef] = [];\n     let lltydescs: [ValueRef] = [];\n     let to_zero = [];\n     let to_revoke = [];\n \n+    let tcx = bcx_tcx(cx);\n     let bcx: @block_ctxt = cx;\n+    let by_ref = ty::ty_fn_ret_style(tcx, fn_ty) == ast::return_ref;\n     // Arg 0: Output pointer.\n \n     // FIXME: test case looks like\n@@ -3544,22 +3544,25 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n              args: [],\n              retslot: C_nil(),\n              to_zero: to_zero,\n-             to_revoke: to_revoke};\n+             to_revoke: to_revoke,\n+             by_ref: by_ref};\n     }\n-    let retty = ty::ty_fn_ret(bcx_tcx(cx), fn_ty);\n-    let llretslot_res = alloc_ty(bcx, retty);\n+    let retty = ty::ty_fn_ret(tcx, fn_ty);\n+    let llretslot_res = if by_ref {\n+        rslt(cx, alloca(cx, T_ptr(type_of_or_i8(cx, retty))))\n+    } else { alloc_ty(bcx, retty) };\n     bcx = llretslot_res.bcx;\n     let llretslot = llretslot_res.val;\n     alt gen {\n       some(g) {\n         lazily_emit_all_generic_info_tydesc_glues(cx, g);\n         lltydescs = g.tydescs;\n-        args = ty::ty_fn_args(bcx_tcx(cx), g.item_type);\n-        retty = ty::ty_fn_ret(bcx_tcx(cx), g.item_type);\n+        args = ty::ty_fn_args(tcx, g.item_type);\n+        retty = ty::ty_fn_ret(tcx, g.item_type);\n       }\n       _ { }\n     }\n-    if ty::type_contains_params(bcx_tcx(cx), retty) {\n+    if ty::type_contains_params(tcx, retty) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n@@ -3583,8 +3586,8 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n       none. { }\n       some(lli) {\n         let lli =\n-            if ty::type_contains_params(bcx_tcx(cx), retty) {\n-                let body_ty = ty::mk_iter_body_fn(bcx_tcx(cx), retty);\n+            if ty::type_contains_params(tcx, retty) {\n+                let body_ty = ty::mk_iter_body_fn(tcx, retty);\n                 let body_llty = type_of_inner(bcx_ccx(cx), cx.sp, body_ty);\n                 PointerCast(bcx, lli, T_ptr(body_llty))\n             } else { lli };\n@@ -3615,7 +3618,8 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n          args: llargs,\n          retslot: llretslot,\n          to_zero: to_zero,\n-         to_revoke: to_revoke};\n+         to_revoke: to_revoke,\n+         by_ref: by_ref};\n }\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n@@ -3686,11 +3690,16 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         alt lliterbody {\n           none. {\n             if !ty::type_is_nil(bcx_tcx(cx), ret_ty) {\n-                retval = load_if_immediate(bcx, llretslot, ret_ty);\n-                // Retval doesn't correspond to anything really tangible\n-                // in the frame, but it's a ref all the same, so we put a\n-                // note here to drop it when we're done in this scope.\n-                add_clean_temp(in_cx, retval, ret_ty);\n+                if args_res.by_ref {\n+                    let retptr = Load(bcx, llretslot);\n+                    retval = load_if_immediate(bcx, retptr, ret_ty);\n+                } else {\n+                    retval = load_if_immediate(bcx, llretslot, ret_ty);\n+                    // Retval doesn't correspond to anything really tangible\n+                    // in the frame, but it's a ref all the same, so we put a\n+                    // note here to drop it when we're done in this scope.\n+                    add_clean_temp(in_cx, retval, ret_ty);\n+                }\n             }\n           }\n           some(_) {\n@@ -4386,7 +4395,7 @@ fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n         bcx = lv.res.bcx;\n         if cx.fcx.ret_style == ast::return_ref {\n             assert lv.is_mem;\n-            Store(bcx, cx.fcx.llretptr, lv.res.val);\n+            Store(bcx, lv.res.val, cx.fcx.llretptr);\n         } else {\n             let is_local = alt x.node {\n               ast::expr_path(p) {\n@@ -4824,7 +4833,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n \n // NB: must keep 4 fns in sync:\n //\n-//  - type_of_fn_full\n+//  - type_of_fn\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n@@ -4864,7 +4873,7 @@ fn new_fn_ctxt(cx: @local_ctxt, sp: span, llfndecl: ValueRef) -> @fn_ctxt {\n \n // NB: must keep 4 fns in sync:\n //\n-//  - type_of_fn_full\n+//  - type_of_fn\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n@@ -5355,10 +5364,10 @@ fn decl_fn_and_pair_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n     let llfty =\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n-      ty::ty_fn(proto, inputs, output, _, _) {\n-        llfty =\n-            type_of_fn(ccx, sp, proto, inputs, output,\n-                       std::vec::len::<ast::ty_param>(ty_params));\n+      ty::ty_fn(proto, inputs, output, rs, _) {\n+        llfty = type_of_fn(ccx, sp, proto, false,\n+                           rs == ast::return_ref, inputs, output,\n+                           vec::len(ty_params));\n       }\n       _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n     }\n@@ -5396,9 +5405,8 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let vecarg_ty: ty::arg =\n             {mode: ast::by_ref,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n-        let llfty =\n-            type_of_fn(ccx, sp, ast::proto_fn, [vecarg_ty],\n-                       ty::mk_nil(ccx.tcx), 0u);\n+        let llfty = type_of_fn(ccx, sp, ast::proto_fn, false, false,\n+                               [vecarg_ty], ty::mk_nil(ccx.tcx), 0u);\n         let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n \n         let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n@@ -5499,7 +5507,8 @@ fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(abi, args, out) {\n-        ret type_of_fn(cx, sp, ast::proto_fn, args, out, ty_param_count);\n+        ret type_of_fn(cx, sp, ast::proto_fn, false, false, args, out,\n+                       ty_param_count);\n       }\n     }\n }"}, {"sha": "eb4192c4e9971c6b1feef22749e7ea246a9fda8f", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=93d2a4f82a83e05e798eda697e45f66ddb06026b", "patch": "@@ -33,7 +33,7 @@ import syntax::print::pprust::{expr_to_str, path_to_str};\n import bld = trans_build;\n \n // FIXME: These should probably be pulled in here too.\n-import trans::{type_of_fn_full, drop_ty};\n+import trans::{type_of_fn, drop_ty};\n \n obj namegen(mutable i: int) {\n     fn next(prefix: str) -> str { i += 1; ret prefix + int::str(i); }\n@@ -336,10 +336,9 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n     }\n \n     let params = csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n-    let f_t =\n-        trans::type_of_fn(ccx, sp, ast::proto_fn,\n-                          [{mode: ast::by_ref, ty: inner_t}],\n-                          ty::mk_nil(ccx.tcx), params);\n+    let f_t = type_of_fn(ccx, sp, ast::proto_fn, false, false,\n+                         [{mode: ast::by_ref, ty: inner_t}],\n+                         ty::mk_nil(ccx.tcx), params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.get_cstore(),\n                                                     did),"}, {"sha": "5f538c24ecae6237c1bd644fa17bbbfb153b62b2", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=93d2a4f82a83e05e798eda697e45f66ddb06026b", "patch": "@@ -880,9 +880,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n \n     let llfnty = T_nil();\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n-      ty::ty_fn(proto, inputs, output, _, _) {\n-        llfnty =\n-            type_of_fn_full(cx.ccx, m.span, proto, true, inputs, output,\n+      ty::ty_fn(proto, inputs, output, rs, _) {\n+        llfnty = type_of_fn(cx.ccx, m.span, proto, true,\n+                            rs == ast::return_ref, inputs, output,\n                             vec::len(ty_params));\n       }\n     }\n@@ -933,8 +933,8 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n \n fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n-    type_of_fn_full(ccx, sp, m.proto, true, m.inputs, m.output,\n-                    vec::len(tps))\n+    type_of_fn(ccx, sp, m.proto, true, m.cf == ast::return_ref,\n+               m.inputs, m.output, vec::len(tps))\n }\n \n //"}, {"sha": "dc9353dc2fd6950c346a509e9814e4f17b5cd2ba", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d2a4f82a83e05e798eda697e45f66ddb06026b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=93d2a4f82a83e05e798eda697e45f66ddb06026b", "patch": "@@ -118,6 +118,7 @@ export ty_fn;\n export ty_fn_abi;\n export ty_fn_proto;\n export ty_fn_ret;\n+export ty_fn_ret_style;\n export ty_int;\n export ty_str;\n export ty_vec;\n@@ -1609,6 +1610,14 @@ fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n     }\n }\n \n+fn ty_fn_ret_style(cx: ctxt, fty: t) -> ast::ret_style {\n+    alt struct(cx, fty) {\n+      ty::ty_fn(_, _, _, rs, _) { rs }\n+      ty::ty_native_fn(_, _, _) { ast::return_val }\n+      _ { cx.sess.bug(\"ty_fn_ret_style() called on non-fn type\"); }\n+    }\n+}\n+\n fn is_fn_ty(cx: ctxt, fty: t) -> bool {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, _, _, _) { ret true; }"}]}