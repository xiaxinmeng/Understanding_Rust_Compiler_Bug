{"sha": "874a130ca01eb8a915b3ba0898aaeff35578758a", "node_id": "C_kwDOAAsO6NoAKDg3NGExMzBjYTAxZWI4YTkxNWIzYmEwODk4YWFlZmYzNTU3ODc1OGE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T15:46:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-13T14:22:59Z"}, "message": "get rid of MemPlaceMeta::Poison\n\nMPlaceTy::dangling still exists, but now it is only called in places that\nactually conceptually allocate something new, so that's fine.", "tree": {"sha": "2c4b4bfb74a5d962c01c305cdc20c43ee389cc50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c4b4bfb74a5d962c01c305cdc20c43ee389cc50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/874a130ca01eb8a915b3ba0898aaeff35578758a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/874a130ca01eb8a915b3ba0898aaeff35578758a", "html_url": "https://github.com/rust-lang/rust/commit/874a130ca01eb8a915b3ba0898aaeff35578758a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/874a130ca01eb8a915b3ba0898aaeff35578758a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4e39400ef33198e2715973d1c67a1d3cee15e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4e39400ef33198e2715973d1c67a1d3cee15e7", "html_url": "https://github.com/rust-lang/rust/commit/ca4e39400ef33198e2715973d1c67a1d3cee15e7"}], "stats": {"total": 33, "additions": 12, "deletions": 21}, "files": [{"sha": "f03ceb54830c81272adacfe6163d22a32bd9decf", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=874a130ca01eb8a915b3ba0898aaeff35578758a", "patch": "@@ -165,6 +165,7 @@ pub(super) fn op_to_const<'tcx>(\n         Ok(ref mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Err(imm) => match *imm {\n+            _ if imm.layout.is_zst() => ConstValue::ZeroSized,\n             Immediate::Scalar(x) => match x {\n                 ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n                 ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),"}, {"sha": "edc4c13b6e8f60fec12060b33c249ba9db78df04", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=874a130ca01eb8a915b3ba0898aaeff35578758a", "patch": "@@ -147,7 +147,6 @@ pub(crate) fn deref_mir_constant<'tcx>(\n \n     let ty = match mplace.meta {\n         MemPlaceMeta::None => mplace.layout.ty,\n-        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_mir_constant`: {:#?}\", mplace),\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),"}, {"sha": "bacf5d5a59f2a095a59ee67c1e20de0de7f2fc3d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=874a130ca01eb8a915b3ba0898aaeff35578758a", "patch": "@@ -987,7 +987,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                             \" by {} ref {:?}:\",\n                             match mplace.meta {\n                                 MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n-                                MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n+                                MemPlaceMeta::None => String::new(),\n                             },\n                             mplace.ptr,\n                         )?;"}, {"sha": "84ecfbabad36930980dcda61ed5442c291682db9", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=874a130ca01eb8a915b3ba0898aaeff35578758a", "patch": "@@ -24,11 +24,6 @@ pub enum MemPlaceMeta<Tag: Provenance = AllocId> {\n     Meta(Scalar<Tag>),\n     /// `Sized` types or unsized `extern type`\n     None,\n-    /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n-    /// a ZST Operand without a backing allocation and being converted to an integer address. This\n-    /// should be impossible, because you can't take the address of an operand, but this is a second\n-    /// protection layer ensuring that we don't mess up.\n-    Poison,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -38,15 +33,16 @@ impl<Tag: Provenance> MemPlaceMeta<Tag> {\n     pub fn unwrap_meta(self) -> Scalar<Tag> {\n         match self {\n             Self::Meta(s) => s,\n-            Self::None | Self::Poison => {\n+            Self::None => {\n                 bug!(\"expected wide pointer extra data (e.g. slice length or trait object vtable)\")\n             }\n         }\n     }\n+\n     pub fn has_meta(self) -> bool {\n         match self {\n             Self::Meta(_) => true,\n-            Self::None | Self::Poison => false,\n+            Self::None => false,\n         }\n     }\n }\n@@ -163,10 +159,6 @@ impl<Tag: Provenance> MemPlace<Tag> {\n             MemPlaceMeta::Meta(meta) => {\n                 Immediate::ScalarPair(Scalar::from_maybe_pointer(self.ptr, cx).into(), meta.into())\n             }\n-            MemPlaceMeta::Poison => bug!(\n-                \"MPlaceTy::dangling may never be used to produce a \\\n-                place that will have the address of its pointee taken\"\n-            ),\n         }\n     }\n \n@@ -195,13 +187,13 @@ impl<Tag: Provenance> Place<Tag> {\n }\n \n impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n-    /// Produces a MemPlace that works for ZST but nothing else\n+    /// Produces a MemPlace that works for ZST but nothing else.\n     #[inline]\n     pub fn dangling(layout: TyAndLayout<'tcx>) -> Self {\n+        assert!(layout.is_zst());\n         let align = layout.align.abi;\n         let ptr = Pointer::from_addr(align.bytes()); // no provenance, absolute address\n-        // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n-        MPlaceTy { mplace: MemPlace { ptr, meta: MemPlaceMeta::Poison }, layout, align }\n+        MPlaceTy { mplace: MemPlace { ptr, meta: MemPlaceMeta::None }, layout, align }\n     }\n \n     #[inline]\n@@ -273,7 +265,6 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n             Operand::Indirect(mplace) => {\n                 Ok(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n             }\n-            Operand::Immediate(_) if self.layout.is_zst() => Ok(MPlaceTy::dangling(self.layout)),\n             Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n         }\n     }"}, {"sha": "9ff405b993944be4b0b9006d3059db326e88755e", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=874a130ca01eb8a915b3ba0898aaeff35578758a", "patch": "@@ -617,16 +617,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             place.to_ref(self),\n             self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         );\n-\n-        let ty = self.tcx.mk_unit(); // return type is ()\n-        let dest = MPlaceTy::dangling(self.layout_of(ty)?);\n+        let ret = MPlaceTy::dangling(self.layout_of(self.tcx.types.unit)?);\n \n         self.eval_fn_call(\n             FnVal::Instance(instance),\n             (Abi::Rust, fn_abi),\n             &[arg.into()],\n             false,\n-            &dest.into(),\n+            &ret.into(),\n             Some(target),\n             match unwind {\n                 Some(cleanup) => StackPopUnwind::Cleanup(cleanup),"}, {"sha": "eed52ca3eeaa63733284239a239c9df795c744b2", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a130ca01eb8a915b3ba0898aaeff35578758a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=874a130ca01eb8a915b3ba0898aaeff35578758a", "patch": "@@ -225,6 +225,8 @@ impl<Tag> Allocation<Tag> {\n \n     /// Try to create an Allocation of `size` bytes, failing if there is not enough memory\n     /// available to the compiler to do so.\n+    ///\n+    /// If `panic_on_fail` is true, this will never return `Err`.\n     pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n         let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).map_err(|_| {\n             // This results in an error that can happen non-deterministically, since the memory"}]}