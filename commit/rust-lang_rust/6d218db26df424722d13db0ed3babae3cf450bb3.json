{"sha": "6d218db26df424722d13db0ed3babae3cf450bb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjE4ZGIyNmRmNDI0NzIyZDEzZGIwZWQzYmFiYWUzY2Y0NTBiYjM=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-01-20T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-01-20T15:58:24Z"}, "message": "compiletest: Simplify multi-debugger support\n\nPrevious implementation used a single mode type to store various pieces\nof otherwise loosely related information:\n\n* Whether debuginfo mode is in use or not.\n* Which debuggers should run in general.\n* Which debuggers are enabled for particular test case.\n\nThe new implementation introduces a separation between those aspects.\nThere is a single debuginfo mode parametrized by a debugger type.\nThe debugger detection is performed first and a separate configuration\nis created for each detected debugger. The test cases are gathered\nindependently for each debugger which makes it trivial to implement\nsupport for `ignore` / `only` conditions.\n\nFunctional changes:\n\n* A single `debuginfo` entry point (rather than `debuginfo-cdb`, `debuginfo-gdb+lldb`, etc.).\n* Debugger name is included in the test name.\n* Test outputs are placed in per-debugger directory.\n* Fixed spurious hash mismatch. Previously, the config mode would change\n  from `DebugInfoGdbLldb` (when collecting tests) to `DebugInfoGdb` or\n  `DebugInfoLldb` (when running them) which would affect hash computation.\n* PYTHONPATH is additionally included in gdb hash.\n* lldb-python and lldb-python-dir are additionally included in lldb hash.", "tree": {"sha": "cfdf4adeb668ebf061ccbaf4194c9d8f86cd266a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfdf4adeb668ebf061ccbaf4194c9d8f86cd266a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d218db26df424722d13db0ed3babae3cf450bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d218db26df424722d13db0ed3babae3cf450bb3", "html_url": "https://github.com/rust-lang/rust/commit/6d218db26df424722d13db0ed3babae3cf450bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d218db26df424722d13db0ed3babae3cf450bb3/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900811e43047fc5593f39b0363373530b02c87e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/900811e43047fc5593f39b0363373530b02c87e0", "html_url": "https://github.com/rust-lang/rust/commit/900811e43047fc5593f39b0363373530b02c87e0"}], "stats": {"total": 497, "additions": 211, "deletions": 286}, "files": [{"sha": "a186c16f1aa71aac84f3f5c80abd46a39fa7f637", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6d218db26df424722d13db0ed3babae3cf450bb3", "patch": "@@ -957,14 +957,6 @@ impl Step for Compiletest {\n         }\n \n         if suite == \"debuginfo\" {\n-            let msvc = builder.config.build.contains(\"msvc\");\n-            if mode == \"debuginfo\" {\n-                return builder.ensure(Compiletest {\n-                    mode: if msvc { \"debuginfo-cdb\" } else { \"debuginfo-gdb+lldb\" },\n-                    ..self\n-                });\n-            }\n-\n             builder\n                 .ensure(dist::DebuggerScripts { sysroot: builder.sysroot(compiler), host: target });\n         }"}, {"sha": "9cc19060cbddc9d60153d00c2f904179e403a5e4", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=6d218db26df424722d13db0ed3babae3cf450bb3", "patch": "@@ -14,10 +14,7 @@ pub enum Mode {\n     RunFail,\n     RunPassValgrind,\n     Pretty,\n-    DebugInfoCdb,\n-    DebugInfoGdbLldb,\n-    DebugInfoGdb,\n-    DebugInfoLldb,\n+    DebugInfo,\n     Codegen,\n     Rustdoc,\n     CodegenUnits,\n@@ -32,13 +29,9 @@ pub enum Mode {\n impl Mode {\n     pub fn disambiguator(self) -> &'static str {\n         // Pretty-printing tests could run concurrently, and if they do,\n-        // they need to keep their output segregated. Same is true for debuginfo tests that\n-        // can be run on cdb, gdb, and lldb.\n+        // they need to keep their output segregated.\n         match self {\n             Pretty => \".pretty\",\n-            DebugInfoCdb => \".cdb\",\n-            DebugInfoGdb => \".gdb\",\n-            DebugInfoLldb => \".lldb\",\n             _ => \"\",\n         }\n     }\n@@ -52,10 +45,7 @@ impl FromStr for Mode {\n             \"run-fail\" => Ok(RunFail),\n             \"run-pass-valgrind\" => Ok(RunPassValgrind),\n             \"pretty\" => Ok(Pretty),\n-            \"debuginfo-cdb\" => Ok(DebugInfoCdb),\n-            \"debuginfo-gdb+lldb\" => Ok(DebugInfoGdbLldb),\n-            \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n-            \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n+            \"debuginfo\" => Ok(DebugInfo),\n             \"codegen\" => Ok(Codegen),\n             \"rustdoc\" => Ok(Rustdoc),\n             \"codegen-units\" => Ok(CodegenUnits),\n@@ -77,10 +67,7 @@ impl fmt::Display for Mode {\n             RunFail => \"run-fail\",\n             RunPassValgrind => \"run-pass-valgrind\",\n             Pretty => \"pretty\",\n-            DebugInfoCdb => \"debuginfo-cdb\",\n-            DebugInfoGdbLldb => \"debuginfo-gdb+lldb\",\n-            DebugInfoGdb => \"debuginfo-gdb\",\n-            DebugInfoLldb => \"debuginfo-lldb\",\n+            DebugInfo => \"debuginfo\",\n             Codegen => \"codegen\",\n             Rustdoc => \"rustdoc\",\n             CodegenUnits => \"codegen-units\",\n@@ -155,6 +142,29 @@ impl CompareMode {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum Debugger {\n+    Cdb,\n+    Gdb,\n+    Lldb,\n+}\n+\n+impl Debugger {\n+    fn to_str(&self) -> &'static str {\n+        match self {\n+            Debugger::Cdb => \"cdb\",\n+            Debugger::Gdb => \"gdb\",\n+            Debugger::Lldb => \"lldb\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Debugger {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.to_str(), f)\n+    }\n+}\n+\n /// Configuration for compiletest\n #[derive(Clone)]\n pub struct Config {\n@@ -208,6 +218,9 @@ pub struct Config {\n     /// The test mode, compile-fail, run-fail, ui\n     pub mode: Mode,\n \n+    /// The debugger to use in debuginfo mode. Unset otherwise.\n+    pub debugger: Option<Debugger>,\n+\n     /// Run ignored tests\n     pub run_ignored: bool,\n \n@@ -362,9 +375,11 @@ pub fn output_testname_unique(\n     revision: Option<&str>,\n ) -> PathBuf {\n     let mode = config.compare_mode.as_ref().map_or(\"\", |m| m.to_str());\n+    let debugger = config.debugger.as_ref().map_or(\"\", |m| m.to_str());\n     PathBuf::from(&testpaths.file.file_stem().unwrap())\n         .with_extra_extension(revision.unwrap_or(\"\"))\n         .with_extra_extension(mode)\n+        .with_extra_extension(debugger)\n }\n \n /// Absolute path to the directory where all output for the given"}, {"sha": "34f9ac037b4b836e807f635ab5f6e654810a878b", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 47, "deletions": 146, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=6d218db26df424722d13db0ed3babae3cf450bb3", "patch": "@@ -6,69 +6,26 @@ use std::path::{Path, PathBuf};\n \n use log::*;\n \n-use crate::common::{self, CompareMode, Config, FailMode, Mode, PassMode};\n+use crate::common::{CompareMode, Config, Debugger, FailMode, Mode, PassMode};\n use crate::extract_gdb_version;\n use crate::util;\n \n #[cfg(test)]\n mod tests;\n \n-/// Whether to ignore the test.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum Ignore {\n-    /// Runs it.\n-    Run,\n-    /// Ignore it totally.\n-    Ignore,\n-    /// Ignore only the gdb test, but run the lldb test.\n-    IgnoreGdb,\n-    /// Ignore only the lldb test, but run the gdb test.\n-    IgnoreLldb,\n-}\n-\n-impl Ignore {\n-    pub fn can_run_gdb(&self) -> bool {\n-        *self == Ignore::Run || *self == Ignore::IgnoreLldb\n-    }\n-\n-    pub fn can_run_lldb(&self) -> bool {\n-        *self == Ignore::Run || *self == Ignore::IgnoreGdb\n-    }\n-\n-    pub fn no_gdb(&self) -> Ignore {\n-        match *self {\n-            Ignore::Run => Ignore::IgnoreGdb,\n-            Ignore::IgnoreGdb => Ignore::IgnoreGdb,\n-            _ => Ignore::Ignore,\n-        }\n-    }\n-\n-    pub fn no_lldb(&self) -> Ignore {\n-        match *self {\n-            Ignore::Run => Ignore::IgnoreLldb,\n-            Ignore::IgnoreLldb => Ignore::IgnoreLldb,\n-            _ => Ignore::Ignore,\n-        }\n-    }\n-}\n-\n /// The result of parse_cfg_name_directive.\n #[derive(Clone, Copy, PartialEq, Debug)]\n enum ParsedNameDirective {\n     /// No match.\n     NoMatch,\n     /// Match.\n     Match,\n-    /// Mode was DebugInfoGdbLldb and this matched gdb.\n-    MatchGdb,\n-    /// Mode was DebugInfoGdbLldb and this matched lldb.\n-    MatchLldb,\n }\n \n /// Properties which must be known very early, before actually running\n /// the test.\n pub struct EarlyProps {\n-    pub ignore: Ignore,\n+    pub ignore: bool,\n     pub should_fail: bool,\n     pub aux: Vec<String>,\n     pub aux_crate: Vec<(String, String)>,\n@@ -78,84 +35,61 @@ pub struct EarlyProps {\n impl EarlyProps {\n     pub fn from_file(config: &Config, testfile: &Path) -> Self {\n         let mut props = EarlyProps {\n-            ignore: Ignore::Run,\n+            ignore: false,\n             should_fail: false,\n             aux: Vec::new(),\n             aux_crate: Vec::new(),\n             revisions: vec![],\n         };\n \n-        if config.mode == common::DebugInfoGdbLldb {\n-            if config.lldb_python_dir.is_none() {\n-                props.ignore = props.ignore.no_lldb();\n-            }\n-            if config.gdb_version.is_none() {\n-                props.ignore = props.ignore.no_gdb();\n-            }\n-        } else if config.mode == common::DebugInfoCdb {\n-            if config.cdb.is_none() {\n-                props.ignore = Ignore::Ignore;\n-            }\n-        }\n-\n         let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n         let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n \n         iter_header(testfile, None, &mut |ln| {\n             // we should check if any only-<platform> exists and if it exists\n             // and does not matches the current platform, skip the test\n-            if props.ignore != Ignore::Ignore {\n+            if !props.ignore {\n                 props.ignore = match config.parse_cfg_name_directive(ln, \"ignore\") {\n-                    ParsedNameDirective::Match => Ignore::Ignore,\n+                    ParsedNameDirective::Match => true,\n                     ParsedNameDirective::NoMatch => props.ignore,\n-                    ParsedNameDirective::MatchGdb => props.ignore.no_gdb(),\n-                    ParsedNameDirective::MatchLldb => props.ignore.no_lldb(),\n                 };\n \n                 if config.has_cfg_prefix(ln, \"only\") {\n                     props.ignore = match config.parse_cfg_name_directive(ln, \"only\") {\n                         ParsedNameDirective::Match => props.ignore,\n-                        ParsedNameDirective::NoMatch => Ignore::Ignore,\n-                        ParsedNameDirective::MatchLldb => props.ignore.no_gdb(),\n-                        ParsedNameDirective::MatchGdb => props.ignore.no_lldb(),\n+                        ParsedNameDirective::NoMatch => true,\n                     };\n                 }\n \n                 if ignore_llvm(config, ln) {\n-                    props.ignore = Ignore::Ignore;\n+                    props.ignore = true;\n                 }\n \n                 if config.run_clang_based_tests_with.is_none()\n                     && config.parse_needs_matching_clang(ln)\n                 {\n-                    props.ignore = Ignore::Ignore;\n+                    props.ignore = true;\n                 }\n \n                 if !rustc_has_profiler_support && config.parse_needs_profiler_support(ln) {\n-                    props.ignore = Ignore::Ignore;\n+                    props.ignore = true;\n                 }\n \n                 if !rustc_has_sanitizer_support && config.parse_needs_sanitizer_support(ln) {\n-                    props.ignore = Ignore::Ignore;\n+                    props.ignore = true;\n                 }\n \n                 if config.target == \"wasm32-unknown-unknown\" && config.parse_check_run_results(ln) {\n-                    props.ignore = Ignore::Ignore;\n+                    props.ignore = true;\n                 }\n-            }\n \n-            if (config.mode == common::DebugInfoGdb || config.mode == common::DebugInfoGdbLldb)\n-                && props.ignore.can_run_gdb()\n-                && ignore_gdb(config, ln)\n-            {\n-                props.ignore = props.ignore.no_gdb();\n-            }\n+                if config.debugger == Some(Debugger::Gdb) && ignore_gdb(config, ln) {\n+                    props.ignore = true;\n+                }\n \n-            if (config.mode == common::DebugInfoLldb || config.mode == common::DebugInfoGdbLldb)\n-                && props.ignore.can_run_lldb()\n-                && ignore_lldb(config, ln)\n-            {\n-                props.ignore = props.ignore.no_lldb();\n+                if config.debugger == Some(Debugger::Lldb) && ignore_lldb(config, ln) {\n+                    props.ignore = true;\n+                }\n             }\n \n             if let Some(s) = config.parse_aux_build(ln) {\n@@ -881,70 +815,37 @@ impl Config {\n     /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n     /// or `normalize-stderr-32bit`.\n     fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> ParsedNameDirective {\n-        if line.starts_with(prefix) && line.as_bytes().get(prefix.len()) == Some(&b'-') {\n-            let name = line[prefix.len() + 1..].split(&[':', ' '][..]).next().unwrap();\n-\n-            if name == \"test\" ||\n-                &self.target == name ||                             // triple\n-                util::matches_os(&self.target, name) ||             // target\n-                util::matches_env(&self.target, name) ||            // env\n-                name == util::get_arch(&self.target) ||             // architecture\n-                name == util::get_pointer_width(&self.target) ||    // pointer width\n-                name == self.stage_id.split('-').next().unwrap() || // stage\n-                (self.target != self.host && name == \"cross-compile\") ||\n-                match self.compare_mode {\n-                    Some(CompareMode::Nll) => name == \"compare-mode-nll\",\n-                    Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n-                    None => false,\n-                } ||\n-                (cfg!(debug_assertions) && name == \"debug\")\n-            {\n-                ParsedNameDirective::Match\n-            } else {\n-                match self.mode {\n-                    common::DebugInfoGdbLldb => {\n-                        if name == \"gdb\" {\n-                            ParsedNameDirective::MatchGdb\n-                        } else if name == \"lldb\" {\n-                            ParsedNameDirective::MatchLldb\n-                        } else {\n-                            ParsedNameDirective::NoMatch\n-                        }\n-                    }\n-                    common::DebugInfoCdb => {\n-                        if name == \"cdb\" {\n-                            ParsedNameDirective::Match\n-                        } else {\n-                            ParsedNameDirective::NoMatch\n-                        }\n-                    }\n-                    common::DebugInfoGdb => {\n-                        if name == \"gdb\" {\n-                            ParsedNameDirective::Match\n-                        } else {\n-                            ParsedNameDirective::NoMatch\n-                        }\n-                    }\n-                    common::DebugInfoLldb => {\n-                        if name == \"lldb\" {\n-                            ParsedNameDirective::Match\n-                        } else {\n-                            ParsedNameDirective::NoMatch\n-                        }\n-                    }\n-                    common::Pretty => {\n-                        if name == \"pretty\" {\n-                            ParsedNameDirective::Match\n-                        } else {\n-                            ParsedNameDirective::NoMatch\n-                        }\n-                    }\n-                    _ => ParsedNameDirective::NoMatch,\n-                }\n-            }\n-        } else {\n-            ParsedNameDirective::NoMatch\n+        if !line.as_bytes().starts_with(prefix.as_bytes()) {\n+            return ParsedNameDirective::NoMatch;\n+        }\n+        if line.as_bytes().get(prefix.len()) != Some(&b'-') {\n+            return ParsedNameDirective::NoMatch;\n         }\n+\n+        let name = line[prefix.len() + 1..].split(&[':', ' '][..]).next().unwrap();\n+\n+        let is_match = name == \"test\" ||\n+            &self.target == name ||                             // triple\n+            util::matches_os(&self.target, name) ||             // target\n+            util::matches_env(&self.target, name) ||            // env\n+            name == util::get_arch(&self.target) ||             // architecture\n+            name == util::get_pointer_width(&self.target) ||    // pointer width\n+            name == self.stage_id.split('-').next().unwrap() || // stage\n+            (self.target != self.host && name == \"cross-compile\") ||\n+            match self.compare_mode {\n+                Some(CompareMode::Nll) => name == \"compare-mode-nll\",\n+                Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n+                None => false,\n+            } ||\n+            (cfg!(debug_assertions) && name == \"debug\") ||\n+            match self.debugger {\n+                Some(Debugger::Cdb) => name == \"cdb\",\n+                Some(Debugger::Gdb) => name == \"gdb\",\n+                Some(Debugger::Lldb) => name == \"lldb\",\n+                None => false,\n+            };\n+\n+        if is_match { ParsedNameDirective::Match } else { ParsedNameDirective::NoMatch }\n     }\n \n     fn has_cfg_prefix(&self, line: &str, prefix: &str) -> bool {"}, {"sha": "0c8f4dd5eaaa11a34b0ede590ad9094b8f2c835b", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 102, "deletions": 87, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=6d218db26df424722d13db0ed3babae3cf450bb3", "patch": "@@ -8,9 +8,7 @@\n extern crate test;\n \n use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n-use crate::common::{CompareMode, PassMode};\n-use crate::common::{Config, TestPaths};\n-use crate::common::{DebugInfoCdb, DebugInfoGdb, DebugInfoGdbLldb, DebugInfoLldb, Mode, Pretty};\n+use crate::common::{CompareMode, Config, Debugger, Mode, PassMode, Pretty, TestPaths};\n use crate::util::logv;\n use env_logger;\n use getopts;\n@@ -26,7 +24,7 @@ use std::time::SystemTime;\n use test::ColorConfig;\n use walkdir::WalkDir;\n \n-use self::header::{EarlyProps, Ignore};\n+use self::header::EarlyProps;\n \n #[cfg(test)]\n mod tests;\n@@ -50,7 +48,7 @@ fn main() {\n     }\n \n     log_config(&config);\n-    run_tests(&config);\n+    run_tests(config);\n }\n \n pub fn parse_config(args: Vec<String>) -> Config {\n@@ -199,6 +197,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         build_base: opt_path(matches, \"build-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n         mode: matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\"),\n+        debugger: None,\n         run_ignored,\n         filter: matches.free.first().cloned(),\n         filter_exact: matches.opt_present(\"exact\"),\n@@ -293,61 +292,7 @@ pub fn opt_str2(maybestr: Option<String>) -> String {\n     }\n }\n \n-pub fn run_tests(config: &Config) {\n-    if config.target.contains(\"android\") {\n-        if config.mode == DebugInfoGdb || config.mode == DebugInfoGdbLldb {\n-            println!(\n-                \"{} debug-info test uses tcp 5039 port.\\\n-                 please reserve it\",\n-                config.target\n-            );\n-\n-            // android debug-info test uses remote debugger so, we test 1 thread\n-            // at once as they're all sharing the same TCP port to communicate\n-            // over.\n-            //\n-            // we should figure out how to lift this restriction! (run them all\n-            // on different ports allocated dynamically).\n-            env::set_var(\"RUST_TEST_THREADS\", \"1\");\n-        }\n-    }\n-\n-    match config.mode {\n-        // Note that we don't need to emit the gdb warning when\n-        // DebugInfoGdbLldb, so it is ok to list that here.\n-        DebugInfoGdbLldb | DebugInfoLldb => {\n-            if let Some(lldb_version) = config.lldb_version.as_ref() {\n-                if is_blacklisted_lldb_version(&lldb_version[..]) {\n-                    println!(\n-                        \"WARNING: The used version of LLDB ({}) has a \\\n-                         known issue that breaks debuginfo tests. See \\\n-                         issue #32520 for more information. Skipping all \\\n-                         LLDB-based tests!\",\n-                        lldb_version\n-                    );\n-                    return;\n-                }\n-            }\n-\n-            // Some older versions of LLDB seem to have problems with multiple\n-            // instances running in parallel, so only run one test thread at a\n-            // time.\n-            env::set_var(\"RUST_TEST_THREADS\", \"1\");\n-        }\n-\n-        DebugInfoGdb => {\n-            if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n-                println!(\n-                    \"WARNING: debuginfo tests are not available when \\\n-                     testing with remote\"\n-                );\n-                return;\n-            }\n-        }\n-\n-        DebugInfoCdb | _ => { /* proceed */ }\n-    }\n-\n+pub fn run_tests(config: Config) {\n     // FIXME(#33435) Avoid spurious failures in codegen-units/partitioning tests.\n     if let Mode::CodegenUnits = config.mode {\n         let _ = fs::remove_dir_all(\"tmp/partitioning-tests\");\n@@ -366,8 +311,6 @@ pub fn run_tests(config: &Config) {\n         }\n     }\n \n-    let opts = test_opts(config);\n-    let tests = make_tests(config);\n     // sadly osx needs some file descriptor limits raised for running tests in\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n@@ -381,6 +324,25 @@ pub fn run_tests(config: &Config) {\n     // Let tests know which target they're running as\n     env::set_var(\"TARGET\", &config.target);\n \n+    let opts = test_opts(&config);\n+\n+    let mut configs = Vec::new();\n+    if let Mode::DebugInfo = config.mode {\n+        // Debugging emscripten code doesn't make sense today\n+        if !config.target.contains(\"emscripten\") {\n+            configs.extend(configure_cdb(&config));\n+            configs.extend(configure_gdb(&config));\n+            configs.extend(configure_lldb(&config));\n+        }\n+    } else {\n+        configs.push(config);\n+    };\n+\n+    let mut tests = Vec::new();\n+    for c in &configs {\n+        make_tests(c, &mut tests);\n+    }\n+\n     let res = test::run_tests_console(&opts, tests);\n     match res {\n         Ok(true) => {}\n@@ -391,6 +353,72 @@ pub fn run_tests(config: &Config) {\n     }\n }\n \n+fn configure_cdb(config: &Config) -> Option<Config> {\n+    if config.cdb.is_none() {\n+        return None;\n+    }\n+\n+    Some(Config { debugger: Some(Debugger::Cdb), ..config.clone() })\n+}\n+\n+fn configure_gdb(config: &Config) -> Option<Config> {\n+    if config.gdb_version.is_none() {\n+        return None;\n+    }\n+\n+    if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n+        println!(\n+            \"WARNING: debuginfo tests are not available when \\\n+             testing with remote\"\n+        );\n+        return None;\n+    }\n+\n+    if config.target.contains(\"android\") {\n+        println!(\n+            \"{} debug-info test uses tcp 5039 port.\\\n+             please reserve it\",\n+            config.target\n+        );\n+\n+        // android debug-info test uses remote debugger so, we test 1 thread\n+        // at once as they're all sharing the same TCP port to communicate\n+        // over.\n+        //\n+        // we should figure out how to lift this restriction! (run them all\n+        // on different ports allocated dynamically).\n+        env::set_var(\"RUST_TEST_THREADS\", \"1\");\n+    }\n+\n+    Some(Config { debugger: Some(Debugger::Gdb), ..config.clone() })\n+}\n+\n+fn configure_lldb(config: &Config) -> Option<Config> {\n+    if config.lldb_python_dir.is_none() {\n+        return None;\n+    }\n+\n+    if let Some(lldb_version) = config.lldb_version.as_ref() {\n+        if is_blacklisted_lldb_version(&lldb_version) {\n+            println!(\n+                \"WARNING: The used version of LLDB ({}) has a \\\n+                 known issue that breaks debuginfo tests. See \\\n+                 issue #32520 for more information. Skipping all \\\n+                 LLDB-based tests!\",\n+                lldb_version\n+            );\n+            return None;\n+        }\n+    }\n+\n+    // Some older versions of LLDB seem to have problems with multiple\n+    // instances running in parallel, so only run one test thread at a\n+    // time.\n+    env::set_var(\"RUST_TEST_THREADS\", \"1\");\n+\n+    Some(Config { debugger: Some(Debugger::Lldb), ..config.clone() })\n+}\n+\n pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n         exclude_should_panic: false,\n@@ -415,20 +443,18 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n+pub fn make_tests(config: &Config, tests: &mut Vec<test::TestDescAndFn>) {\n     debug!(\"making tests from {:?}\", config.src_base.display());\n     let inputs = common_inputs_stamp(config);\n-    let mut tests = Vec::new();\n     collect_tests_from_dir(\n         config,\n         &config.src_base,\n         &config.src_base,\n         &PathBuf::new(),\n         &inputs,\n-        &mut tests,\n+        tests,\n     )\n     .expect(&format!(\"Could not read tests from {}\", config.src_base.display()));\n-    tests\n }\n \n /// Returns a stamp constructed from input files common to all test cases.\n@@ -570,13 +596,7 @@ fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test\n     revisions\n         .into_iter()\n         .map(|revision| {\n-            let ignore = early_props.ignore == Ignore::Ignore\n-                // Debugging emscripten code doesn't make sense today\n-                || ((config.mode == DebugInfoGdbLldb || config.mode == DebugInfoCdb ||\n-                     config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n-                    && config.target.contains(\"emscripten\"))\n-                || (config.mode == DebugInfoGdb && !early_props.ignore.can_run_gdb())\n-                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb())\n+            let ignore = early_props.ignore\n                 // Ignore tests that already run and are up to date with respect to inputs.\n                 || is_up_to_date(\n                     config,\n@@ -593,7 +613,7 @@ fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test\n                     allow_fail: false,\n                     test_type: test::TestType::Unknown,\n                 },\n-                testfn: make_test_closure(config, early_props.ignore, testpaths, revision),\n+                testfn: make_test_closure(config, testpaths, revision),\n             }\n         })\n         .collect()\n@@ -685,13 +705,19 @@ fn make_test_name(\n     let path = PathBuf::from(config.src_base.file_name().unwrap())\n         .join(&testpaths.relative_dir)\n         .join(&testpaths.file.file_name().unwrap());\n+    let debugger = match config.debugger {\n+        Some(d) => format!(\"-{}\", d),\n+        None => String::new(),\n+    };\n     let mode_suffix = match config.compare_mode {\n         Some(ref mode) => format!(\" ({})\", mode.to_str()),\n         None => String::new(),\n     };\n+\n     test::DynTestName(format!(\n-        \"[{}{}] {}{}\",\n+        \"[{}{}{}] {}{}\",\n         config.mode,\n+        debugger,\n         mode_suffix,\n         path.display(),\n         revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n@@ -700,21 +726,10 @@ fn make_test_name(\n \n fn make_test_closure(\n     config: &Config,\n-    ignore: Ignore,\n     testpaths: &TestPaths,\n     revision: Option<&String>,\n ) -> test::TestFn {\n-    let mut config = config.clone();\n-    if config.mode == DebugInfoGdbLldb {\n-        // If both gdb and lldb were ignored, then the test as a whole\n-        // would be ignored.\n-        if !ignore.can_run_gdb() {\n-            config.mode = DebugInfoLldb;\n-        } else if !ignore.can_run_lldb() {\n-            config.mode = DebugInfoGdb;\n-        }\n-    }\n-\n+    let config = config.clone();\n     let testpaths = testpaths.clone();\n     let revision = revision.cloned();\n     test::DynTestFn(Box::new(move || {"}, {"sha": "d1ee60d74e7e28a35f791cdb9304529b9aa30472", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d218db26df424722d13db0ed3babae3cf450bb3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=6d218db26df424722d13db0ed3babae3cf450bb3", "patch": "@@ -3,11 +3,10 @@\n use crate::common::{expected_output_path, UI_EXTENSIONS, UI_FIXED, UI_STDERR, UI_STDOUT};\n use crate::common::{output_base_dir, output_base_name, output_testname_unique};\n use crate::common::{Assembly, Incremental, JsDocTest, MirOpt, RunMake, Ui};\n-use crate::common::{Codegen, CodegenUnits, Rustdoc};\n+use crate::common::{Codegen, CodegenUnits, DebugInfo, Debugger, Rustdoc};\n use crate::common::{CompareMode, FailMode, PassMode};\n use crate::common::{CompileFail, Pretty, RunFail, RunPassValgrind};\n use crate::common::{Config, TestPaths};\n-use crate::common::{DebugInfoCdb, DebugInfoGdb, DebugInfoGdbLldb, DebugInfoLldb};\n use crate::common::{UI_RUN_STDERR, UI_RUN_STDOUT};\n use crate::errors::{self, Error, ErrorKind};\n use crate::header::TestProps;\n@@ -192,7 +191,7 @@ pub fn run(config: Config, testpaths: &TestPaths, revision: Option<&str>) {\n \n         _ => {\n             // android has its own gdb handling\n-            if config.mode == DebugInfoGdb && config.gdb.is_none() {\n+            if config.debugger == Some(Debugger::Gdb) && config.gdb.is_none() {\n                 panic!(\"gdb not available but debuginfo gdb debuginfo test requested\");\n             }\n         }\n@@ -234,21 +233,25 @@ pub fn compute_stamp_hash(config: &Config) -> String {\n     let mut hash = DefaultHasher::new();\n     config.stage_id.hash(&mut hash);\n \n-    if config.mode == DebugInfoCdb {\n-        config.cdb.hash(&mut hash);\n-    }\n+    match config.debugger {\n+        Some(Debugger::Cdb) => {\n+            config.cdb.hash(&mut hash);\n+        }\n \n-    if config.mode == DebugInfoGdb || config.mode == DebugInfoGdbLldb {\n-        match config.gdb {\n-            None => env::var_os(\"PATH\").hash(&mut hash),\n-            Some(ref s) if s.is_empty() => env::var_os(\"PATH\").hash(&mut hash),\n-            Some(ref s) => s.hash(&mut hash),\n-        };\n-    }\n+        Some(Debugger::Gdb) => {\n+            config.gdb.hash(&mut hash);\n+            env::var_os(\"PATH\").hash(&mut hash);\n+            env::var_os(\"PYTHONPATH\").hash(&mut hash);\n+        }\n \n-    if config.mode == DebugInfoLldb || config.mode == DebugInfoGdbLldb {\n-        env::var_os(\"PATH\").hash(&mut hash);\n-        env::var_os(\"PYTHONPATH\").hash(&mut hash);\n+        Some(Debugger::Lldb) => {\n+            config.lldb_python.hash(&mut hash);\n+            config.lldb_python_dir.hash(&mut hash);\n+            env::var_os(\"PATH\").hash(&mut hash);\n+            env::var_os(\"PYTHONPATH\").hash(&mut hash);\n+        }\n+\n+        None => {}\n     }\n \n     if let Ui = config.mode {\n@@ -309,13 +312,7 @@ impl<'test> TestCx<'test> {\n             RunFail => self.run_rfail_test(),\n             RunPassValgrind => self.run_valgrind_test(),\n             Pretty => self.run_pretty_test(),\n-            DebugInfoGdbLldb => {\n-                self.run_debuginfo_gdb_test();\n-                self.run_debuginfo_lldb_test();\n-            }\n-            DebugInfoCdb => self.run_debuginfo_cdb_test(),\n-            DebugInfoGdb => self.run_debuginfo_gdb_test(),\n-            DebugInfoLldb => self.run_debuginfo_lldb_test(),\n+            DebugInfo => self.run_debuginfo_test(),\n             Codegen => self.run_codegen_test(),\n             Rustdoc => self.run_rustdoc_test(),\n             CodegenUnits => self.run_codegen_units_test(),\n@@ -680,13 +677,20 @@ impl<'test> TestCx<'test> {\n         self.compose_and_run_compiler(rustc, Some(src))\n     }\n \n+    fn run_debuginfo_test(&self) {\n+        match self.config.debugger.unwrap() {\n+            Debugger::Cdb => self.run_debuginfo_cdb_test(),\n+            Debugger::Gdb => self.run_debuginfo_gdb_test(),\n+            Debugger::Lldb => self.run_debuginfo_lldb_test(),\n+        }\n+    }\n+\n     fn run_debuginfo_cdb_test(&self) {\n         assert!(self.revision.is_none(), \"revisions not relevant here\");\n \n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n-            mode: DebugInfoCdb,\n             ..self.config.clone()\n         };\n \n@@ -765,7 +769,6 @@ impl<'test> TestCx<'test> {\n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n-            mode: DebugInfoGdb,\n             ..self.config.clone()\n         };\n \n@@ -999,7 +1002,6 @@ impl<'test> TestCx<'test> {\n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n-            mode: DebugInfoLldb,\n             ..self.config.clone()\n         };\n \n@@ -1887,8 +1889,8 @@ impl<'test> TestCx<'test> {\n \n                 rustc.arg(dir_opt);\n             }\n-            RunFail | RunPassValgrind | Pretty | DebugInfoCdb | DebugInfoGdbLldb | DebugInfoGdb\n-            | DebugInfoLldb | Codegen | Rustdoc | RunMake | CodegenUnits | JsDocTest | Assembly => {\n+            RunFail | RunPassValgrind | Pretty | DebugInfo | Codegen | Rustdoc | RunMake\n+            | CodegenUnits | JsDocTest | Assembly => {\n                 // do not use JSON output\n             }\n         }"}]}