{"sha": "a6e188f8bf300f591e0b9de914bb655f171e9d66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZTE4OGY4YmYzMDBmNTkxZTBiOWRlOTE0YmI2NTVmMTcxZTlkNjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-22T19:55:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-22T19:55:26Z"}, "message": "rustc: Rename parser.err to parser.fatal", "tree": {"sha": "721004c7bf66d09d2cb4fdc9395748b36c2a3a7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/721004c7bf66d09d2cb4fdc9395748b36c2a3a7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6e188f8bf300f591e0b9de914bb655f171e9d66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e188f8bf300f591e0b9de914bb655f171e9d66", "html_url": "https://github.com/rust-lang/rust/commit/a6e188f8bf300f591e0b9de914bb655f171e9d66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6e188f8bf300f591e0b9de914bb655f171e9d66/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe0925678c76b3e96983806bd66edc1aa062c519", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe0925678c76b3e96983806bd66edc1aa062c519", "html_url": "https://github.com/rust-lang/rust/commit/fe0925678c76b3e96983806bd66edc1aa062c519"}], "stats": {"total": 58, "additions": 29, "deletions": 29}, "files": [{"sha": "94ea7e7b69c8739bde5a9ac6c8adae78f027ccd8", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a6e188f8bf300f591e0b9de914bb655f171e9d66/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6e188f8bf300f591e0b9de914bb655f171e9d66/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a6e188f8bf300f591e0b9de914bb655f171e9d66", "patch": "@@ -28,7 +28,7 @@ type parser =\n     obj {\n         fn peek() -> token::token ;\n         fn bump() ;\n-        fn err(str) -> !  ;\n+        fn fatal(str) -> !  ;\n         fn restrict(restriction) ;\n         fn get_restriction() -> restriction ;\n         fn get_file_type() -> file_type ;\n@@ -74,7 +74,7 @@ fn new_parser(session::session sess, eval::env env,\n             lo = rdr.get_mark_chpos();\n             hi = rdr.get_chpos();\n         }\n-        fn err(str m) -> ! { sess.span_fatal(rec(lo=lo, hi=hi), m); }\n+        fn fatal(str m) -> ! { sess.span_fatal(rec(lo=lo, hi=hi), m); }\n         fn restrict(restriction r) { res = r; }\n         fn get_restriction() -> restriction { ret res; }\n         fn get_session() -> session::session { ret sess; }\n@@ -164,7 +164,7 @@ fn bad_expr_word_table() -> hashmap[str, ()] {\n fn unexpected(&parser p, token::token t) -> ! {\n     let str s = \"unexpected token: \";\n     s += token::to_str(p.get_reader(), t);\n-    p.err(s);\n+    p.fatal(s);\n }\n \n fn expect(&parser p, token::token t) {\n@@ -175,7 +175,7 @@ fn expect(&parser p, token::token t) {\n         s += token::to_str(p.get_reader(), t);\n         s += \", found \";\n         s += token::to_str(p.get_reader(), p.peek());\n-        p.err(s);\n+        p.fatal(s);\n     }\n }\n \n@@ -186,7 +186,7 @@ fn spanned[T](uint lo, uint hi, &T node) -> common::spanned[T] {\n fn parse_ident(&parser p) -> ast::ident {\n     alt (p.peek()) {\n         case (token::IDENT(?i, _)) { p.bump(); ret p.get_str(i); }\n-        case (_) { p.err(\"expecting ident\"); fail; }\n+        case (_) { p.fatal(\"expecting ident\"); fail; }\n     }\n }\n \n@@ -209,12 +209,12 @@ fn parse_str_lit_or_env_ident(&parser p) -> ast::ident {\n                 eval::lookup(p.get_session(), p.get_env(), p.get_span(),\n                              p.get_str(i));\n             if (!eval::val_is_str(v)) {\n-                p.err(\"expecting string-valued variable\");\n+                p.fatal(\"expecting string-valued variable\");\n             }\n             p.bump();\n             ret eval::val_as_str(v);\n         }\n-        case (_) { p.err(\"expecting string literal\"); fail; }\n+        case (_) { p.fatal(\"expecting string literal\"); fail; }\n     }\n }\n \n@@ -239,7 +239,7 @@ fn eat_word(&parser p, &str word) -> bool {\n \n fn expect_word(&parser p, &str word) {\n     if (!eat_word(p, word)) {\n-        p.err(\"expecting \" + word + \", found \" +\n+        p.fatal(\"expecting \" + word + \", found \" +\n                   token::to_str(p.get_reader(), p.peek()));\n     }\n }\n@@ -249,7 +249,7 @@ fn check_bad_word(&parser p) {\n         case (token::IDENT(?sid, false)) {\n             auto w = p.get_str(sid);\n             if (p.get_bad_expr_words().contains_key(w)) {\n-                p.err(\"found \" + w + \" in expression position\");\n+                p.fatal(\"found \" + w + \" in expression position\");\n             }\n         }\n         case (_) { }\n@@ -436,7 +436,7 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n                                               ann));\n                 }\n                 case (_) {\n-                    p.err(\"type parameter instantiation only allowed for \" +\n+                    p.fatal(\"type parameter instantiation only allowed for \" +\n                           \"paths\");\n                 }\n             }\n@@ -572,7 +572,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         auto path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n-    } else { p.err(\"expecting type\"); t = ast::ty_nil; fail; }\n+    } else { p.fatal(\"expecting type\"); t = ast::ty_nil; fail; }\n     ret parse_ty_postfix(@spanned(lo, hi, t), p);\n }\n \n@@ -917,7 +917,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         if (/*check*/ast::is_call_expr(e)) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n-        } else { p.err(\"Non-call expression in tail call\"); }\n+        } else { p.fatal(\"Non-call expression in tail call\"); }\n     } else if (eat_word(p, \"port\")) {\n         expect(p, token::LPAREN);\n         expect(p, token::RPAREN);\n@@ -982,7 +982,7 @@ fn expand_syntax_ext(&parser p, common::span sp, &ast::path path,\n     assert (vec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n     alt (p.get_syntax_expanders().find(extname)) {\n-        case (none) { p.err(\"unknown syntax expander: '\" + extname + \"'\"); }\n+        case (none) { p.fatal(\"unknown syntax expander: '\" + extname + \"'\"); }\n         case (some(ext::x(?ext))) {\n             auto ext_cx = ext::mk_ctxt(p);\n             ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body));\n@@ -1313,7 +1313,7 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n             /* empty */\n \n         } else {\n-            p.err(\"expected 'case' or '}' when parsing 'alt' statement \" +\n+            p.fatal(\"expected 'case' or '}' when parsing 'alt' statement \" +\n                       \"but found \" + token::to_str(p.get_reader(), p.peek()));\n         }\n     }\n@@ -1391,7 +1391,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n                         ast::pat_bind(p.get_str(id), p.get_id());\n                 }\n                 case (?tok) {\n-                    p.err(\"expected identifier after '?' in pattern but \" +\n+                    p.fatal(\"expected identifier after '?' in pattern but \" +\n                               \"found \" + token::to_str(p.get_reader(), tok));\n                     fail;\n                 }\n@@ -1503,7 +1503,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n             alt (maybe_item) {\n                 case (got_item(_)) { /* fallthrough */ }\n                 case (_) {\n-                    ret p.err(\"expected item\");\n+                    ret p.fatal(\"expected item\");\n                 }\n             }\n         }\n@@ -1528,7 +1528,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n             }\n         }\n     }\n-    p.err(\"expected statement\");\n+    p.fatal(\"expected statement\");\n     fail;\n }\n \n@@ -1612,7 +1612,7 @@ fn parse_block(&parser p) -> ast::block {\n                             case (token::RBRACE) { expr = some(e); }\n                             case (?t) {\n                                 if (stmt_ends_with_semi(*stmt)) {\n-                                    p.err(\"expected ';' or '}' after \" +\n+                                    p.fatal(\"expected ';' or '}' after \" +\n                                               \"expression but found \" +\n                                               token::to_str(p.get_reader(),\n                                                             t));\n@@ -1798,7 +1798,7 @@ fn parse_mod_items(&parser p, token::token term,\n         alt (parse_item(p, attrs)) {\n             case (got_item(?i)) { vec::push(items, i); }\n             case (_) {\n-                p.err(\"expected item but found \" +\n+                p.fatal(\"expected item but found \" +\n                           token::to_str(p.get_reader(), p.peek()));\n             }\n         }\n@@ -1903,7 +1903,7 @@ fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n             abi = ast::native_abi_llvm;\n         } else if (str::eq(t, \"rust-intrinsic\")) {\n             abi = ast::native_abi_rust_intrinsic;\n-        } else { p.err(\"unsupported abi: \" + t); fail; }\n+        } else { p.fatal(\"unsupported abi: \" + t); fail; }\n     }\n     expect_word(p, \"mod\");\n     auto id = parse_ident(p);\n@@ -1971,7 +1971,7 @@ fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n             }\n             case (token::RBRACE) {/* empty */ }\n             case (_) {\n-                p.err(\"expected name of variant or '}' but found \" +\n+                p.fatal(\"expected name of variant or '}' but found \" +\n                           token::to_str(p.get_reader(), tok));\n             }\n         }\n@@ -2104,7 +2104,7 @@ fn parse_inner_attrs_and_next(&parser p) -> tup(vec[ast::attribute],\n fn parse_inner_attrs(&parser p) -> vec[ast::attribute] {\n     auto attrs_and_next = parse_inner_attrs_and_next(p);\n     if (vec::len(attrs_and_next._1) > 0u) {\n-        ret p.err(\"expected crate directive but found \" +\n+        ret p.fatal(\"expected crate directive but found \" +\n                   token::to_str(p.get_reader(), p.peek()));\n     }\n     ret attrs_and_next._0;\n@@ -2120,7 +2120,7 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n             p.bump();\n             ret @spanned(lo, hi, rec(key=ident, value=p.get_str(s)));\n         }\n-        case (_) { p.err(\"Metadata items must be string literals\"); }\n+        case (_) { p.fatal(\"Metadata items must be string literals\"); }\n     }\n     fail;\n }\n@@ -2158,10 +2158,10 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n         alt (p.peek()) {\n             case (token::SEMI) { p.bump(); break; }\n             case (token::MOD_SEP) {\n-                if (glob) { p.err(\"cannot path into a glob\"); }\n+                if (glob) { p.fatal(\"cannot path into a glob\"); }\n                 p.bump();\n             }\n-            case (_) { p.err(\"expecting '::' or ';'\"); }\n+            case (_) { p.fatal(\"expecting '::' or ';'\"); }\n         }\n         alt (p.peek()) {\n             case (token::IDENT(_, _)) { identifiers += [parse_ident(p)]; }\n@@ -2171,14 +2171,14 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n                 glob = true;\n                 p.bump();\n             }\n-            case (_) { p.err(\"expecting an identifier, or '*'\"); }\n+            case (_) { p.fatal(\"expecting an identifier, or '*'\"); }\n         }\n     }\n     auto hi = p.get_hi_pos();\n     auto import_decl;\n     alt (def_ident) {\n         case (some(?i)) {\n-            if (glob) { p.err(\"globbed imports can't be renamed\"); }\n+            if (glob) { p.fatal(\"globbed imports can't be renamed\"); }\n             import_decl =\n                 ast::view_item_import(i, identifiers, p.get_id());\n         }\n@@ -2204,7 +2204,7 @@ fn parse_full_import_name(&parser p, ast::ident def_ident) ->\n             p.bump();\n             ret parse_rest_import_name(p, p.get_str(i), some(def_ident));\n         }\n-        case (_) { p.err(\"expecting an identifier\"); }\n+        case (_) { p.fatal(\"expecting an identifier\"); }\n     }\n     fail;\n }\n@@ -2223,7 +2223,7 @@ fn parse_import(&parser p) -> @ast::view_item {\n                 }\n             }\n         }\n-        case (_) { p.err(\"expecting an identifier\"); }\n+        case (_) { p.fatal(\"expecting an identifier\"); }\n     }\n     fail;\n }"}]}