{"sha": "111e092481ec8a6e958f3f4d3e13eaccd844d99e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMWUwOTI0ODFlYzhhNmU5NThmM2Y0ZDNlMTNlYWNjZDg0NGQ5OWU=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-02-17T19:32:12Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-02-19T12:54:44Z"}, "message": "Change the format_args! macro expansion for temporaries\n\nCurrently, the format_args! macro and its downstream macros in turn\nexpand to series of let statements, one for each of its arguments, and\nthen the invocation of the macro function. If one or more of the\narguments are RefCell's, the enclosing statement for the temporary of\nthe let is the let itself, which leads to scope problem. This patch\nchanges let's to a match expression.\n\nCloses #12239.", "tree": {"sha": "670b34fbd74cd8fa89ca8e7dc466060a7beef4e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/670b34fbd74cd8fa89ca8e7dc466060a7beef4e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/111e092481ec8a6e958f3f4d3e13eaccd844d99e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/111e092481ec8a6e958f3f4d3e13eaccd844d99e", "html_url": "https://github.com/rust-lang/rust/commit/111e092481ec8a6e958f3f4d3e13eaccd844d99e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/111e092481ec8a6e958f3f4d3e13eaccd844d99e/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "html_url": "https://github.com/rust-lang/rust/commit/c4afcf44d2c70b2c176bdf283082a7bdd4be5826"}], "stats": {"total": 78, "additions": 65, "deletions": 13}, "files": [{"sha": "5bc3d047c9fdfcabd9a230aa4f6414c275cd4daf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=111e092481ec8a6e958f3f4d3e13eaccd844d99e", "patch": "@@ -4142,7 +4142,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n                                           .span_err(e.span,\n                                                     format!(\"expected \\\n                                                              constant: {}\",\n-                                                            (*err)));\n+                                                            *err));\n                                     }\n                                 },\n                                 None => {}"}, {"sha": "9c43af4f13aa7bac7c6ff554608c95863a925fac", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=111e092481ec8a6e958f3f4d3e13eaccd844d99e", "patch": "@@ -1303,15 +1303,15 @@ impl<'a> LookupContext<'a> {\n         self.tcx().sess.span_note(\n             span,\n             format!(\"candidate \\\\#{} is `{}`\",\n-                 (idx+1u),\n+                 idx+1u,\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             format!(\"candidate \\\\#{} derives from the bound `{}`\",\n-                 (idx+1u),\n+                 idx+1u,\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n@@ -1320,7 +1320,7 @@ impl<'a> LookupContext<'a> {\n             self.expr.span,\n             format!(\"candidate \\\\#{} derives from the type of the receiver, \\\n                   which is the trait `{}`\",\n-                 (idx+1u),\n+                 idx+1u,\n                  ty::item_path_str(self.tcx(), did)));\n     }\n "}, {"sha": "eab34b560605184ee1e427ed4cf3f995298a9923", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=111e092481ec8a6e958f3f4d3e13eaccd844d99e", "patch": "@@ -3551,7 +3551,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            ccx.tcx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n+                            ccx.tcx.sess.span_err(e.span, format!(\"expected constant: {}\", *err));\n                         }\n                     }\n                 },"}, {"sha": "4608fa649b58785630a60a0864b8f22064dd770c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=111e092481ec8a6e958f3f4d3e13eaccd844d99e", "patch": "@@ -49,11 +49,11 @@ pub fn note_and_explain_region(cx: ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, (*str), suffix));\n+            format!(\"{}{}{}\", prefix, *str, suffix));\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, (*str), suffix));\n+            format!(\"{}{}{}\", prefix, *str, suffix));\n       }\n     }\n }"}, {"sha": "db81731a47617d369b50e295b25e0619390e9882", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=111e092481ec8a6e958f3f4d3e13eaccd844d99e", "patch": "@@ -607,6 +607,8 @@ impl<'a> Context<'a> {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n+        let mut pats = ~[];\n+        let mut heads = ~[];\n \n         // First, declare all of our methods that are statics\n         for &method in self.method_statics.iter() {\n@@ -653,8 +655,8 @@ impl<'a> Context<'a> {\n             if self.arg_types[i].is_none() { continue } // error already generated\n \n             let name = self.ecx.ident_of(format!(\"__arg{}\", i));\n-            let e = self.ecx.expr_addr_of(e.span, e);\n-            lets.push(self.ecx.stmt_let(e.span, false, name, e));\n+            pats.push(self.ecx.pat_ident(e.span, name));\n+            heads.push(self.ecx.expr_addr_of(e.span, e));\n             locals.push(self.format_arg(e.span, Exact(i),\n                                         self.ecx.expr_ident(e.span, name)));\n         }\n@@ -664,8 +666,8 @@ impl<'a> Context<'a> {\n             }\n \n             let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n-            let e = self.ecx.expr_addr_of(e.span, e);\n-            lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n+            pats.push(self.ecx.pat_ident(e.span, lname));\n+            heads.push(self.ecx.expr_addr_of(e.span, e));\n             names[*self.name_positions.get(name)] =\n                 Some(self.format_arg(e.span,\n                                      Named((*name).clone()),\n@@ -706,8 +708,40 @@ impl<'a> Context<'a> {\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n         let result = self.ecx.expr_call(extra.span, extra, ~[\n                             self.ecx.expr_addr_of(extra.span, res)]);\n-        self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n-                                           Some(result)))\n+        let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n+                                                      Some(result)));\n+\n+        // Constructs an AST equivalent to:\n+        //\n+        //      match (&arg0, &arg1) {\n+        //          (tmp0, tmp1) => body\n+        //      }\n+        //\n+        // It was:\n+        //\n+        //      let tmp0 = &arg0;\n+        //      let tmp1 = &arg1;\n+        //      body\n+        //\n+        // Because of #11585 the new temporary lifetime rule, the enclosing\n+        // statements for these temporaries become the let's themselves.\n+        // If one or more of them are RefCell's, RefCell borrow() will also\n+        // end there; they don't last long enough for body to use them. The\n+        // match expression solves the scope problem.\n+        //\n+        // Note, it may also very well be transformed to:\n+        //\n+        //      match arg0 {\n+        //          ref tmp0 => {\n+        //              match arg1 => {\n+        //                  ref tmp1 => body } } }\n+        //\n+        // But the nested match expression is proved to perform not as well\n+        // as series of let's; the first approach does.\n+        let pat = self.ecx.pat(self.fmtsp, ast::PatTup(pats));\n+        let arm = self.ecx.arm(self.fmtsp, ~[pat], body);\n+        let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n+        self.ecx.expr_match(self.fmtsp, head, ~[arm])\n     }\n \n     fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)"}, {"sha": "6428d496382b12675f32e6bf74762de010da023c", "filename": "src/test/run-pass/format-ref-cell.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e092481ec8a6e958f3f4d3e13eaccd844d99e/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs?ref=111e092481ec8a6e958f3f4d3e13eaccd844d99e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+\n+pub fn main() {\n+    let name = RefCell::new(\"rust\");\n+    let what = RefCell::new(\"rocks\");\n+    let msg = format!(\"{name:?} {:?}\", what.borrow().get(), name=name.borrow().get());\n+    assert_eq!(msg, ~\"&\\\"rust\\\" &\\\"rocks\\\"\");\n+}"}]}