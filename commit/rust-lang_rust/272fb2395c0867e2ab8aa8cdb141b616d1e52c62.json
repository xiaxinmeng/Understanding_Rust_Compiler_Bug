{"sha": "272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "node_id": "C_kwDOAAsO6NoAKDI3MmZiMjM5NWMwODY3ZTJhYjhhYThjZGIxNDFiNjE2ZDFlNTJjNjI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-13T22:03:56Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-15T04:34:38Z"}, "message": "Don't use source-map when detecting struct field shorthand", "tree": {"sha": "cd999b3f3d9df0050413493f90ed00ce62c9f007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd999b3f3d9df0050413493f90ed00ce62c9f007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "html_url": "https://github.com/rust-lang/rust/commit/272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dae6dc6b97bcc7675b28f956d8aff2e27ede1a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dae6dc6b97bcc7675b28f956d8aff2e27ede1a4f", "html_url": "https://github.com/rust-lang/rust/commit/dae6dc6b97bcc7675b28f956d8aff2e27ede1a4f"}], "stats": {"total": 225, "additions": 104, "deletions": 121}, "files": [{"sha": "241dcbc64a676bb35fe307dec5c4ceee2f73784c", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 100, "deletions": 117, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n \n use super::method::probe;\n@@ -24,7 +24,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn demand_coerce(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// will be permitted if the diverges flag is currently \"always\".\n     pub fn demand_coerce_diag(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -338,67 +338,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 })\n                 .collect();\n \n-            if self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span) {\n-                if let Ok(code) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n-                    match &compatible_variants[..] {\n-                        [] => { /* No variants to format */ }\n-                        [variant] => {\n-                            // Just a single matching variant.\n-                            err.span_suggestion_verbose(\n-                                expr.span,\n-                                &format!(\"try wrapping the expression in `{}`\", variant),\n-                                format!(\"{}: {}({})\", code, variant, code),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        _ => {\n-                            // More than one matching variant.\n-                            err.span_suggestions(\n-                                expr.span,\n-                                &format!(\n-                                    \"try wrapping the expression in a variant of `{}`\",\n-                                    self.tcx.def_path_str(expected_adt.did)\n-                                ),\n-                                compatible_variants\n-                                    .into_iter()\n-                                    .map(|variant| format!(\"{}: {}({})\", code, variant, code)),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n-                } else {\n-                    /* Can't format this without a snippet */\n+            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                Some(ident) => format!(\"{}: \", ident),\n+                None => format!(\"\"),\n+            };\n+\n+            match &compatible_variants[..] {\n+                [] => { /* No variants to format */ }\n+                [variant] => {\n+                    // Just a single matching variant.\n+                    err.multipart_suggestion_verbose(\n+                        &format!(\"try wrapping the expression in `{}`\", variant),\n+                        vec![\n+                            (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n+                            (expr.span.shrink_to_hi(), \")\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-            } else {\n-                match &compatible_variants[..] {\n-                    [] => { /* No variants to format */ }\n-                    [variant] => {\n-                        // Just a single matching variant.\n-                        err.multipart_suggestion_verbose(\n-                            &format!(\"try wrapping the expression in `{}`\", variant),\n+                _ => {\n+                    // More than one matching variant.\n+                    err.multipart_suggestions(\n+                        &format!(\n+                            \"try wrapping the expression in a variant of `{}`\",\n+                            self.tcx.def_path_str(expected_adt.did)\n+                        ),\n+                        compatible_variants.into_iter().map(|variant| {\n                             vec![\n-                                (expr.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n                                 (expr.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {\n-                        // More than one matching variant.\n-                        err.multipart_suggestions(\n-                            &format!(\n-                                \"try wrapping the expression in a variant of `{}`\",\n-                                self.tcx.def_path_str(expected_adt.did)\n-                            ),\n-                            compatible_variants.into_iter().map(|variant| {\n-                                vec![\n-                                    (expr.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                    (expr.span.shrink_to_hi(), \")\".to_string()),\n-                                ]\n-                            }),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                            ]\n+                        }),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }\n@@ -520,33 +492,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn is_hir_id_from_struct_pattern_shorthand_field(\n+    crate fn maybe_get_struct_pattern_shorthand_field(\n         &self,\n-        hir_id: hir::HirId,\n-        sp: Span,\n-    ) -> bool {\n-        let sm = self.sess().source_map();\n-        let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-        if let Some(parent) = self.tcx.hir().find(parent_id) {\n-            // Account for fields\n-            if let Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) = parent\n-            {\n-                if let Ok(src) = sm.span_to_snippet(sp) {\n-                    for field in *fields {\n-                        if field.ident.as_str() == src && field.is_shorthand {\n-                            return true;\n-                        }\n+        expr: &hir::Expr<'_>,\n+    ) -> Option<Symbol> {\n+        let hir = self.tcx.hir();\n+        let local = match expr {\n+            hir::Expr {\n+                kind:\n+                    hir::ExprKind::Path(hir::QPath::Resolved(\n+                        None,\n+                        hir::Path {\n+                            res: hir::def::Res::Local(_),\n+                            segments: [hir::PathSegment { ident, .. }],\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            } => Some(ident),\n+            _ => None,\n+        }?;\n+\n+        match hir.find(hir.get_parent_node(expr.hir_id))? {\n+            Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) => {\n+                for field in *fields {\n+                    if field.ident.name == local.name && field.is_shorthand {\n+                        return Some(local.name);\n                     }\n                 }\n             }\n+            _ => {}\n         }\n-        false\n+\n+        None\n     }\n \n     /// If the given `HirId` corresponds to a block with a trailing expression, return that expression\n-    crate fn maybe_get_block_expr(&self, hir_id: hir::HirId) -> Option<&'tcx hir::Expr<'tcx>> {\n-        match self.tcx.hir().find(hir_id)? {\n-            Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, ..), .. }) => block.expr,\n+    crate fn maybe_get_block_expr(&self, expr: &hir::Expr<'tcx>) -> Option<&'tcx hir::Expr<'tcx>> {\n+        match expr {\n+            hir::Expr { kind: hir::ExprKind::Block(block, ..), .. } => block.expr,\n             _ => None,\n         }\n     }\n@@ -584,7 +568,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `&mut`!\".\n     pub fn check_ref(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(Span, &'static str, String, Applicability, bool /* verbose */)> {\n@@ -602,9 +586,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             s.strip_prefix(old).map(|stripped| new.to_string() + stripped)\n         };\n \n-        let is_struct_pat_shorthand_field =\n-            self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, sp);\n-\n         // `ExprKind::DropTemps` is semantically irrelevant for these suggestions.\n         let expr = expr.peel_drop_temps();\n \n@@ -698,11 +679,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 false,\n                             ));\n                         }\n-                        let field_name = if is_struct_pat_shorthand_field {\n-                            format!(\"{}: \", sugg_expr)\n-                        } else {\n-                            String::new()\n+\n+                        let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                            Some(ident) => format!(\"{}: \", ident),\n+                            None => format!(\"\"),\n                         };\n+\n                         if let Some(hir::Node::Expr(hir::Expr {\n                             kind: hir::ExprKind::Assign(left_expr, ..),\n                             ..\n@@ -732,14 +714,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             hir::Mutability::Mut => (\n                                 sp,\n                                 \"consider mutably borrowing here\",\n-                                format!(\"{}&mut {}\", field_name, sugg_expr),\n+                                format!(\"{}&mut {}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\",\n-                                format!(\"{}&{}\", field_name, sugg_expr),\n+                                format!(\"{}&{}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n@@ -883,32 +865,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n                             || checked_ty.is_box()\n                         {\n-                            if let Ok(code) = sm.span_to_snippet(expr.span) {\n-                                let message = if checked_ty.is_box() {\n-                                    \"consider unboxing the value\"\n-                                } else if checked_ty.is_region_ptr() {\n-                                    \"consider dereferencing the borrow\"\n-                                } else {\n-                                    \"consider dereferencing the type\"\n-                                };\n-                                let (span, suggestion) = if is_struct_pat_shorthand_field {\n-                                    (expr.span, format!(\"{}: *{}\", code, code))\n-                                } else if self.is_else_if_block(expr) {\n-                                    // Don't suggest nonsense like `else *if`\n-                                    return None;\n-                                } else if let Some(expr) = self.maybe_get_block_expr(expr.hir_id) {\n-                                    (expr.span.shrink_to_lo(), \"*\".to_string())\n-                                } else {\n-                                    (expr.span.shrink_to_lo(), \"*\".to_string())\n-                                };\n-                                return Some((\n-                                    span,\n-                                    message,\n-                                    suggestion,\n-                                    Applicability::MachineApplicable,\n-                                    true,\n-                                ));\n-                            }\n+                            let message = if checked_ty.is_box() {\n+                                \"consider unboxing the value\"\n+                            } else if checked_ty.is_region_ptr() {\n+                                \"consider dereferencing the borrow\"\n+                            } else {\n+                                \"consider dereferencing the type\"\n+                            };\n+                            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                                Some(ident) => format!(\"{}: \", ident),\n+                                None => format!(\"\"),\n+                            };\n+                            let (span, suggestion) = if self.is_else_if_block(expr) {\n+                                // Don't suggest nonsense like `else *if`\n+                                return None;\n+                            } else if let Some(expr) = self.maybe_get_block_expr(expr) {\n+                                // prefix should be empty here..\n+                                (expr.span.shrink_to_lo(), \"*\".to_string())\n+                            } else {\n+                                (expr.span.shrink_to_lo(), format!(\"{}*\", prefix))\n+                            };\n+                            return Some((\n+                                span,\n+                                message,\n+                                suggestion,\n+                                Applicability::MachineApplicable,\n+                                true,\n+                            ));\n                         }\n                     }\n                 }"}, {"sha": "473c848ad8f13eef6272278cd00d12bc9a362c36", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field =\n-                self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n+                self.maybe_get_struct_pattern_shorthand_field(expr).is_some();\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n                 if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {"}, {"sha": "0dfd8f5c128f6a0f614b4eb1c9f9da0944a80ed0", "filename": "src/test/ui/did_you_mean/compatible-variants.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr?ref=272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "patch": "@@ -143,7 +143,7 @@ LL |     let _ = Foo { bar };\n help: try wrapping the expression in `Some`\n    |\n LL |     let _ = Foo { bar: Some(bar) };\n-   |                   ~~~~~~~~~~~~~~\n+   |                   ++++++++++   +\n \n error: aborting due to 9 previous errors\n "}, {"sha": "28c9afaa52c2299dbe987b84268e7e12628e5719", "filename": "src/test/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/272fb2395c0867e2ab8aa8cdb141b616d1e52c62/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr?ref=272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "patch": "@@ -87,7 +87,7 @@ LL |     let r = R { i };\n help: consider dereferencing the borrow\n    |\n LL |     let r = R { i: *i };\n-   |                 ~~~~~\n+   |                 ++++\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:46:20"}]}