{"sha": "bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMWIwNGJhODViODIyMWJkZDdlYWExYWQ1NmEzMDY4NmU4YzU4NTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T06:02:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T06:02:21Z"}, "message": "Auto merge of #4570 - lzutao:call_site_toplevel_ref_arg, r=phansch\n\nFix macro expansion in toplevel_ref_arg lint\n\nchangelog: Fix macro expansion in toplevel_ref_arg lint", "tree": {"sha": "d985ab958297ca3dfebad9f14f1f35e07d30f52d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d985ab958297ca3dfebad9f14f1f35e07d30f52d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "html_url": "https://github.com/rust-lang/rust/commit/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1366629262e20560f86fe986999dc52a168ee768", "url": "https://api.github.com/repos/rust-lang/rust/commits/1366629262e20560f86fe986999dc52a168ee768", "html_url": "https://github.com/rust-lang/rust/commit/1366629262e20560f86fe986999dc52a168ee768"}, {"sha": "5639639d3530529d88b9e2ec5c9468f4fb7acec1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5639639d3530529d88b9e2ec5c9468f4fb7acec1", "html_url": "https://github.com/rust-lang/rust/commit/5639639d3530529d88b9e2ec5c9468f4fb7acec1"}], "stats": {"total": 93, "additions": 53, "deletions": 40}, "files": [{"sha": "980c4caf2c5e9712d81dd01d21d956b59ea2f043", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "patch": "@@ -261,60 +261,65 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if_chain! {\n-            if let StmtKind::Local(ref l) = s.node;\n-            if let PatKind::Binding(an, .., i, None) = l.pat.node;\n-            if let Some(ref init) = l.init;\n+            if let StmtKind::Local(ref local) = stmt.node;\n+            if let PatKind::Binding(an, .., name, None) = local.pat.node;\n+            if let Some(ref init) = local.init;\n             then {\n                 if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n-                    let sugg_init = Sugg::hir(cx, init, \"..\");\n-                    let (mutopt,initref) = if an == BindingAnnotation::RefMut {\n+                    let sugg_init = if init.span.from_expansion() {\n+                        Sugg::hir_with_macro_callsite(cx, init, \"..\")\n+                    } else {\n+                        Sugg::hir(cx, init, \"..\")\n+                    };\n+                    let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n                         (\"mut \", sugg_init.mut_addr())\n                     } else {\n                         (\"\", sugg_init.addr())\n                     };\n-                    let tyopt = if let Some(ref ty) = l.ty {\n+                    let tyopt = if let Some(ref ty) = local.ty {\n                         format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"_\"))\n                     } else {\n                         String::new()\n                     };\n-                    span_lint_hir_and_then(cx,\n+                    span_lint_hir_and_then(\n+                        cx,\n                         TOPLEVEL_REF_ARG,\n                         init.hir_id,\n-                        l.pat.span,\n+                        local.pat.span,\n                         \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n                         |db| {\n                             db.span_suggestion(\n-                                s.span,\n+                                stmt.span,\n                                 \"try\",\n                                 format!(\n                                     \"let {name}{tyopt} = {initref};\",\n-                                    name=snippet(cx, i.span, \"_\"),\n+                                    name=snippet(cx, name.span, \"_\"),\n                                     tyopt=tyopt,\n                                     initref=initref,\n                                 ),\n-                                Applicability::MachineApplicable, // snippet\n+                                Applicability::MachineApplicable,\n                             );\n                         }\n                     );\n                 }\n             }\n         };\n         if_chain! {\n-            if let StmtKind::Semi(ref expr) = s.node;\n+            if let StmtKind::Semi(ref expr) = stmt.node;\n             if let ExprKind::Binary(ref binop, ref a, ref b) = expr.node;\n             if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n                 span_lint_and_then(cx,\n                     SHORT_CIRCUIT_STATEMENT,\n-                    s.span,\n+                    stmt.span,\n                     \"boolean short circuit operator in statement may be clearer using an explicit test\",\n                     |db| {\n                         let sugg = if binop.node == BinOpKind::Or { !sugg } else { sugg };\n                         db.span_suggestion(\n-                            s.span,\n+                            stmt.span,\n                             \"replace it with\",\n                             format!(\n                                 \"if {} {{ {}; }}\","}, {"sha": "9438abbe330d5253c8ce3410e70e936fef5fd366", "filename": "tests/ui/toplevel_ref_arg.fixed", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/tests%2Fui%2Ftoplevel_ref_arg.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/tests%2Fui%2Ftoplevel_ref_arg.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftoplevel_ref_arg.fixed?ref=bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "patch": "@@ -1,25 +1,26 @@\n // run-rustfix\n \n #![warn(clippy::toplevel_ref_arg)]\n-#![allow(unused)]\n \n fn main() {\n     // Closures should not warn\n     let y = |ref x| println!(\"{:?}\", x);\n     y(1u8);\n \n-    let x = &1;\n+    let _x = &1;\n \n-    let y: &(&_, u8) = &(&1, 2);\n+    let _y: &(&_, u8) = &(&1, 2);\n \n-    let z = &(1 + 2);\n+    let _z = &(1 + 2);\n \n-    let z = &mut (1 + 2);\n+    let _z = &mut (1 + 2);\n \n     let (ref x, _) = (1, 2); // ok, not top level\n     println!(\"The answer is {}.\", x);\n \n+    let _x = &vec![1, 2, 3];\n+\n     // Make sure that allowing the lint works\n     #[allow(clippy::toplevel_ref_arg)]\n-    let ref mut x = 1_234_543;\n+    let ref mut _x = 1_234_543;\n }"}, {"sha": "ee630f12a601847ab0c78c014ca4c861ef6571f4", "filename": "tests/ui/toplevel_ref_arg.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/tests%2Fui%2Ftoplevel_ref_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/tests%2Fui%2Ftoplevel_ref_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftoplevel_ref_arg.rs?ref=bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "patch": "@@ -1,25 +1,26 @@\n // run-rustfix\n \n #![warn(clippy::toplevel_ref_arg)]\n-#![allow(unused)]\n \n fn main() {\n     // Closures should not warn\n     let y = |ref x| println!(\"{:?}\", x);\n     y(1u8);\n \n-    let ref x = 1;\n+    let ref _x = 1;\n \n-    let ref y: (&_, u8) = (&1, 2);\n+    let ref _y: (&_, u8) = (&1, 2);\n \n-    let ref z = 1 + 2;\n+    let ref _z = 1 + 2;\n \n-    let ref mut z = 1 + 2;\n+    let ref mut _z = 1 + 2;\n \n     let (ref x, _) = (1, 2); // ok, not top level\n     println!(\"The answer is {}.\", x);\n \n+    let ref _x = vec![1, 2, 3];\n+\n     // Make sure that allowing the lint works\n     #[allow(clippy::toplevel_ref_arg)]\n-    let ref mut x = 1_234_543;\n+    let ref mut _x = 1_234_543;\n }"}, {"sha": "19d69496709be158fc260cceb39ca02b4f21bcb4", "filename": "tests/ui/toplevel_ref_arg.stderr", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/tests%2Fui%2Ftoplevel_ref_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855/tests%2Fui%2Ftoplevel_ref_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftoplevel_ref_arg.stderr?ref=bc1b04ba85b8221bdd7eaa1ad56a30686e8c5855", "patch": "@@ -1,28 +1,34 @@\n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:11:9\n+  --> $DIR/toplevel_ref_arg.rs:10:9\n    |\n-LL |     let ref x = 1;\n-   |     ----^^^^^----- help: try: `let x = &1;`\n+LL |     let ref _x = 1;\n+   |     ----^^^^^^----- help: try: `let _x = &1;`\n    |\n    = note: `-D clippy::toplevel-ref-arg` implied by `-D warnings`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:13:9\n+  --> $DIR/toplevel_ref_arg.rs:12:9\n    |\n-LL |     let ref y: (&_, u8) = (&1, 2);\n-   |     ----^^^^^--------------------- help: try: `let y: &(&_, u8) = &(&1, 2);`\n+LL |     let ref _y: (&_, u8) = (&1, 2);\n+   |     ----^^^^^^--------------------- help: try: `let _y: &(&_, u8) = &(&1, 2);`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:15:9\n+  --> $DIR/toplevel_ref_arg.rs:14:9\n    |\n-LL |     let ref z = 1 + 2;\n-   |     ----^^^^^--------- help: try: `let z = &(1 + 2);`\n+LL |     let ref _z = 1 + 2;\n+   |     ----^^^^^^--------- help: try: `let _z = &(1 + 2);`\n \n error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n-  --> $DIR/toplevel_ref_arg.rs:17:9\n+  --> $DIR/toplevel_ref_arg.rs:16:9\n    |\n-LL |     let ref mut z = 1 + 2;\n-   |     ----^^^^^^^^^--------- help: try: `let z = &mut (1 + 2);`\n+LL |     let ref mut _z = 1 + 2;\n+   |     ----^^^^^^^^^^--------- help: try: `let _z = &mut (1 + 2);`\n \n-error: aborting due to 4 previous errors\n+error: `ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\n+  --> $DIR/toplevel_ref_arg.rs:21:9\n+   |\n+LL |     let ref _x = vec![1, 2, 3];\n+   |     ----^^^^^^----------------- help: try: `let _x = &vec![1, 2, 3];`\n+\n+error: aborting due to 5 previous errors\n "}]}