{"sha": "168ac5290e9d4a787e020735f96fa789060a8f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OGFjNTI5MGU5ZDRhNzg3ZTAyMDczNWY5NmZhNzg5MDYwYThmNzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T10:11:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:45:49Z"}, "message": "Move comparing of impl methods against trait from collect to check.\nThis code fits better in check because it is checking that the impl\nmatches the interface. This allows us to avoid the awkward constructions\nthat lazilly collect traits and so forth. It also permits us to make\nuse of the results of variance inference.", "tree": {"sha": "fe927d209d5b0cd6c967151a4679accc3679d965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe927d209d5b0cd6c967151a4679accc3679d965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/168ac5290e9d4a787e020735f96fa789060a8f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/168ac5290e9d4a787e020735f96fa789060a8f76", "html_url": "https://github.com/rust-lang/rust/commit/168ac5290e9d4a787e020735f96fa789060a8f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/168ac5290e9d4a787e020735f96fa789060a8f76/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d3f57ef0869805e0dde99cdce9548a587df7893", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3f57ef0869805e0dde99cdce9548a587df7893", "html_url": "https://github.com/rust-lang/rust/commit/9d3f57ef0869805e0dde99cdce9548a587df7893"}], "stats": {"total": 649, "additions": 325, "deletions": 324}, "files": [{"sha": "cf362384f3adeb6017d08d7bb59afa35f720ab76", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 322, "deletions": 1, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=168ac5290e9d4a787e020735f96fa789060a8f76", "patch": "@@ -603,7 +603,23 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         for m in ms.iter() {\n             check_method_body(ccx, &impl_tpt.generics, None, *m);\n         }\n-        vtable::resolve_impl(ccx, it);\n+\n+        match *opt_trait_ref {\n+            Some(ref ast_trait_ref) => {\n+                let impl_trait_ref =\n+                    ty::node_id_to_trait_ref(ccx.tcx, ast_trait_ref.ref_id);\n+                check_impl_methods_against_trait(ccx,\n+                                             it.span,\n+                                             &impl_tpt.generics,\n+                                             ast_trait_ref,\n+                                             impl_trait_ref,\n+                                             *ms);\n+                vtable::resolve_impl(ccx, it, &impl_tpt.generics,\n+                                     impl_trait_ref);\n+            }\n+            None => { }\n+        }\n+\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n@@ -707,6 +723,311 @@ fn check_method_body(ccx: @mut CrateCtxt,\n         param_env);\n }\n \n+fn check_impl_methods_against_trait(ccx: @mut CrateCtxt,\n+                                    impl_span: Span,\n+                                    impl_generics: &ty::Generics,\n+                                    ast_trait_ref: &ast::trait_ref,\n+                                    impl_trait_ref: &ty::TraitRef,\n+                                    impl_methods: &[@ast::method]) {\n+    // Locate trait methods\n+    let tcx = ccx.tcx;\n+    let trait_methods = ty::trait_methods(tcx, impl_trait_ref.def_id);\n+\n+    // Check existing impl methods to see if they are both present in trait\n+    // and compatible with trait signature\n+    for impl_method in impl_methods.iter() {\n+        let impl_method_def_id = local_def(impl_method.id);\n+        let impl_method_ty = ty::method(ccx.tcx, impl_method_def_id);\n+\n+        // If this is an impl of a trait method, find the corresponding\n+        // method definition in the trait.\n+        let opt_trait_method_ty =\n+            trait_methods.iter().\n+            find(|tm| tm.ident.name == impl_method_ty.ident.name);\n+        match opt_trait_method_ty {\n+            Some(trait_method_ty) => {\n+                compare_impl_method(ccx.tcx,\n+                                    impl_generics,\n+                                    impl_method_ty,\n+                                    impl_method.span,\n+                                    impl_method.body.id,\n+                                    *trait_method_ty,\n+                                    &impl_trait_ref.substs);\n+            }\n+            None => {\n+                tcx.sess.span_err(\n+                    impl_method.span,\n+                    format!(\"method `{}` is not a member of trait `{}`\",\n+                            tcx.sess.str_of(impl_method_ty.ident),\n+                            pprust::path_to_str(&ast_trait_ref.path,\n+                                                tcx.sess.intr())));\n+            }\n+        }\n+    }\n+\n+    // Check for missing methods from trait\n+    let provided_methods = ty::provided_trait_methods(tcx,\n+                                                      impl_trait_ref.def_id);\n+    let mut missing_methods = ~[];\n+    for trait_method in trait_methods.iter() {\n+        let is_implemented =\n+            impl_methods.iter().any(\n+                |m| m.ident.name == trait_method.ident.name);\n+        let is_provided =\n+            provided_methods.iter().any(\n+                |m| m.ident.name == trait_method.ident.name);\n+        if !is_implemented && !is_provided {\n+            missing_methods.push(\n+                format!(\"`{}`\", ccx.tcx.sess.str_of(trait_method.ident)));\n+        }\n+    }\n+\n+    if !missing_methods.is_empty() {\n+        tcx.sess.span_err(\n+            impl_span,\n+            format!(\"not all trait methods implemented, missing: {}\",\n+                    missing_methods.connect(\", \")));\n+    }\n+}\n+\n+/**\n+ * Checks that a method from an impl/class conforms to the signature of\n+ * the same method as declared in the trait.\n+ *\n+ * # Parameters\n+ *\n+ * - impl_generics: the generics declared on the impl itself (not the method!)\n+ * - impl_m: type of the method we are checking\n+ * - impl_m_span: span to use for reporting errors\n+ * - impl_m_body_id: id of the method body\n+ * - trait_m: the method in the trait\n+ * - trait_substs: the substitutions used on the type of the trait\n+ * - self_ty: the self type of the impl\n+ */\n+pub fn compare_impl_method(tcx: ty::ctxt,\n+                           impl_generics: &ty::Generics,\n+                           impl_m: @ty::Method,\n+                           impl_m_span: Span,\n+                           impl_m_body_id: ast::NodeId,\n+                           trait_m: &ty::Method,\n+                           trait_substs: &ty::substs) {\n+    debug!(\"compare_impl_method()\");\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    let impl_tps = impl_generics.type_param_defs.len();\n+\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n+        (&ast::sty_static, &ast::sty_static) => {}\n+        (&ast::sty_static, _) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+                        but not in the trait\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        pprust::explicit_self_to_str(&impl_m.explicit_self,\n+                                                     tcx.sess.intr())));\n+            return;\n+        }\n+        (_, &ast::sty_static) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+                        but not in the impl\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        pprust::explicit_self_to_str(&trait_m.explicit_self,\n+                                                     tcx.sess.intr())));\n+            return;\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n+        }\n+    }\n+\n+    let num_impl_m_type_params = impl_m.generics.type_param_defs.len();\n+    let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n+    if num_impl_m_type_params != num_trait_m_type_params {\n+        tcx.sess.span_err(\n+            impl_m_span,\n+            format!(\"method `{}` has {} type parameter(s), but its trait \\\n+                    declaration has {} type parameter(s)\",\n+                    tcx.sess.str_of(trait_m.ident),\n+                    num_impl_m_type_params,\n+                    num_trait_m_type_params));\n+        return;\n+    }\n+\n+    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n+        tcx.sess.span_err(\n+            impl_m_span,\n+            format!(\"method `{}` has {} parameter(s) \\\n+                    but the trait has {} parameter(s)\",\n+                    tcx.sess.str_of(trait_m.ident),\n+                    impl_m.fty.sig.inputs.len(),\n+                    trait_m.fty.sig.inputs.len()));\n+        return;\n+    }\n+\n+    for (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n+        // For each of the corresponding impl ty param's bounds...\n+        let impl_param_def = &impl_m.generics.type_param_defs[i];\n+\n+        // Check that the impl does not require any builtin-bounds\n+        // that the trait does not guarantee:\n+        let extra_bounds =\n+            impl_param_def.bounds.builtin_bounds -\n+            trait_param_def.bounds.builtin_bounds;\n+        if !extra_bounds.is_empty() {\n+           tcx.sess.span_err(\n+               impl_m_span,\n+               format!(\"in method `{}`, \\\n+                       type parameter {} requires `{}`, \\\n+                       which is not required by \\\n+                       the corresponding type parameter \\\n+                       in the trait declaration\",\n+                       tcx.sess.str_of(trait_m.ident),\n+                       i,\n+                       extra_bounds.user_string(tcx)));\n+           return;\n+        }\n+\n+        // FIXME(#2687)---we should be checking that the bounds of the\n+        // trait imply the bounds of the subtype, but it appears we\n+        // are...not checking this.\n+        if impl_param_def.bounds.trait_bounds.len() !=\n+            trait_param_def.bounds.trait_bounds.len()\n+        {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"in method `{}`, \\\n+                        type parameter {} has {} trait bound(s), but the \\\n+                        corresponding type parameter in \\\n+                        the trait declaration has {} trait bound(s)\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        i, impl_param_def.bounds.trait_bounds.len(),\n+                        trait_param_def.bounds.trait_bounds.len()));\n+            return;\n+        }\n+    }\n+\n+    // Create a substitution that maps the type parameters on the impl\n+    // to themselves and which replace any references to bound regions\n+    // in the self type with free regions.  So, for example, if the\n+    // impl type is \"&'self str\", then this would replace the self\n+    // type with a free region `self`.\n+    let dummy_impl_tps: ~[ty::t] =\n+        impl_generics.type_param_defs.iter().enumerate().\n+        map(|(i,t)| ty::mk_param(tcx, i, t.def_id)).\n+        collect();\n+    let dummy_method_tps: ~[ty::t] =\n+        impl_m.generics.type_param_defs.iter().enumerate().\n+        map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n+        collect();\n+    let dummy_impl_regions: OptVec<ty::Region> =\n+        impl_generics.region_param_defs.iter().\n+        map(|l| ty::re_free(ty::FreeRegion {\n+                scope_id: impl_m_body_id,\n+                bound_region: ty::br_named(l.def_id, l.ident)})).\n+        collect();\n+    let dummy_substs = ty::substs {\n+        tps: vec::append(dummy_impl_tps, dummy_method_tps),\n+        regions: ty::NonerasedRegions(dummy_impl_regions),\n+        self_ty: None };\n+\n+    // We are going to create a synthetic fn type that includes\n+    // both the method's self argument and its normal arguments.\n+    // So a method like `fn(&self, a: uint)` would be converted\n+    // into a function `fn(self: &T, a: uint)`.\n+    let mut trait_fn_args = ~[];\n+    let mut impl_fn_args = ~[];\n+\n+    // For both the trait and the impl, create an argument to\n+    // represent the self argument (unless this is a static method).\n+    // This argument will have the *transformed* self type.\n+    for &t in trait_m.transformed_self_ty.iter() {\n+        trait_fn_args.push(t);\n+    }\n+    for &t in impl_m.transformed_self_ty.iter() {\n+        impl_fn_args.push(t);\n+    }\n+\n+    // Add in the normal arguments.\n+    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n+    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n+\n+    // Create a bare fn type for trait/impl that includes self argument\n+    let trait_fty =\n+        ty::mk_bare_fn(tcx,\n+                       ty::BareFnTy {\n+                            purity: trait_m.fty.purity,\n+                            abis: trait_m.fty.abis,\n+                            sig: ty::FnSig {\n+                                binder_id: trait_m.fty.sig.binder_id,\n+                                inputs: trait_fn_args,\n+                                output: trait_m.fty.sig.output,\n+                                variadic: false\n+                            }\n+                        });\n+    let impl_fty =\n+        ty::mk_bare_fn(tcx,\n+                       ty::BareFnTy {\n+                            purity: impl_m.fty.purity,\n+                            abis: impl_m.fty.abis,\n+                            sig: ty::FnSig {\n+                                binder_id: impl_m.fty.sig.binder_id,\n+                                inputs: impl_fn_args,\n+                                output: impl_m.fty.sig.output,\n+                                variadic: false\n+                            }\n+                        });\n+\n+    // Perform substitutions so that the trait/impl methods are expressed\n+    // in terms of the same set of type/region parameters:\n+    // - replace trait type parameters with those from `trait_substs`,\n+    //   except with any reference to bound self replaced with `dummy_self_r`\n+    // - replace method parameters on the trait with fresh, dummy parameters\n+    //   that correspond to the parameters we will find on the impl\n+    // - replace self region with a fresh, dummy region\n+    let impl_fty = {\n+        debug!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n+        impl_fty.subst(tcx, &dummy_substs)\n+    };\n+    debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n+    let trait_fty = {\n+        let substs { regions: trait_regions,\n+                     tps: trait_tps,\n+                     self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n+        let substs = substs {\n+            regions: trait_regions,\n+            tps: vec::append(trait_tps, dummy_method_tps),\n+            self_ty: self_ty,\n+        };\n+        debug!(\"trait_fty (pre-subst): {} substs={}\",\n+               trait_fty.repr(tcx), substs.repr(tcx));\n+        trait_fty.subst(tcx, &substs)\n+    };\n+    debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n+\n+    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(impl_m_span),\n+                          impl_fty, trait_fty) {\n+        result::Ok(()) => {}\n+        result::Err(ref terr) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has an incompatible type: {}\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        ty::type_err_to_str(tcx, terr)));\n+            ty::note_and_explain_type_err(tcx, terr);\n+        }\n+    }\n+}\n+\n impl AstConv for FnCtxt {\n     fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n "}, {"sha": "bf00bee270943359215444504410f1a898bfc0e7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=168ac5290e9d4a787e020735f96fa789060a8f76", "patch": "@@ -536,33 +536,6 @@ impl CoherenceChecker {\n         return trait_id;\n     }\n \n-    // This check doesn't really have anything to do with coherence. It's\n-    // here for historical reasons\n-    pub fn check_trait_methods_are_implemented(\n-        &self,\n-        all_methods: &mut ~[@Method],\n-        trait_did: DefId,\n-        trait_ref_span: Span) {\n-\n-        let tcx = self.crate_context.tcx;\n-\n-        let mut provided_names = HashSet::new();\n-        // Implemented methods\n-        for elt in all_methods.iter() {\n-            provided_names.insert(elt.ident.name);\n-        }\n-\n-        let r = ty::trait_methods(tcx, trait_did);\n-        for method in r.iter() {\n-            debug!(\"checking for {}\", method.ident.repr(tcx));\n-            if provided_names.contains(&method.ident.name) { continue; }\n-\n-            tcx.sess.span_err(trait_ref_span,\n-                              format!(\"missing method `{}`\",\n-                                   tcx.sess.str_of(method.ident)));\n-        }\n-    }\n-\n     /// For coherence, when we have `impl Type`, we need to guarantee that\n     /// `Type` is \"local\" to the crate. For our purposes, this means that it\n     /// must precisely name some nominal type defined in this crate.\n@@ -617,17 +590,10 @@ impl CoherenceChecker {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n-                    let trait_did = ty_trait_ref.def_id;\n \n                     self.instantiate_default_methods(local_def(item.id),\n                                                      ty_trait_ref,\n                                                      &mut methods);\n-\n-                    // Check that we have implementations of every trait method\n-                    self.check_trait_methods_are_implemented(\n-                        &mut methods,\n-                        trait_did,\n-                        trait_ref.path.span);\n                 }\n \n                 return @Impl {"}, {"sha": "7cf004be5e2a5774a0d4a1f9d4c5e4d7162d9e58", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 286, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=168ac5290e9d4a787e020735f96fa789060a8f76", "patch": "@@ -411,290 +411,6 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     bounds\n }\n \n-/**\n- * Checks that a method from an impl/class conforms to the signature of\n- * the same method as declared in the trait.\n- *\n- * # Parameters\n- *\n- * - impl_tps: the type params declared on the impl itself (not the method!)\n- * - cm: info about the method we are checking\n- * - trait_m: the method in the trait\n- * - trait_substs: the substitutions used on the type of the trait\n- * - self_ty: the self type of the impl\n- */\n-pub fn compare_impl_method(tcx: ty::ctxt,\n-                           impl_tps: uint,\n-                           cm: &ConvertedMethod,\n-                           trait_m: &ty::Method,\n-                           trait_substs: &ty::substs,\n-                           self_ty: ty::t) {\n-    debug!(\"compare_impl_method()\");\n-    let infcx = infer::new_infer_ctxt(tcx);\n-\n-    let impl_m = &cm.mty;\n-\n-    // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n-    // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n-    // that the error messages you get out of this code are a bit more\n-    // inscrutable, particularly for cases where one method has no\n-    // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ast::sty_static, &ast::sty_static) => {}\n-        (&ast::sty_static, _) => {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n-                      but not in the trait\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n-            return;\n-        }\n-        (_, &ast::sty_static) => {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n-                      but not in the impl\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n-            return;\n-        }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n-    }\n-\n-    let num_impl_m_type_params = impl_m.generics.type_param_defs.len();\n-    let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n-    if num_impl_m_type_params != num_trait_m_type_params {\n-        tcx.sess.span_err(\n-            cm.span,\n-            format!(\"method `{}` has {} type {}, but its trait \\\n-                  declaration has {} type {}\",\n-                 tcx.sess.str_of(trait_m.ident),\n-                 num_impl_m_type_params,\n-                 pluralize(num_impl_m_type_params, ~\"parameter\"),\n-                 num_trait_m_type_params,\n-                 pluralize(num_trait_m_type_params, ~\"parameter\")));\n-        return;\n-    }\n-\n-    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n-        tcx.sess.span_err(\n-            cm.span,\n-            format!(\"method `{}` has {} parameter{} \\\n-                  but the trait has {}\",\n-                 tcx.sess.str_of(trait_m.ident),\n-                 impl_m.fty.sig.inputs.len(),\n-                 if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n-                 trait_m.fty.sig.inputs.len()));\n-        return;\n-    }\n-\n-    for (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n-        // For each of the corresponding impl ty param's bounds...\n-        let impl_param_def = &impl_m.generics.type_param_defs[i];\n-\n-        // Check that the impl does not require any builtin-bounds\n-        // that the trait does not guarantee:\n-        let extra_bounds =\n-            impl_param_def.bounds.builtin_bounds -\n-            trait_param_def.bounds.builtin_bounds;\n-        if !extra_bounds.is_empty() {\n-           tcx.sess.span_err(\n-               cm.span,\n-               format!(\"in method `{}`, \\\n-                     type parameter {} requires `{}`, \\\n-                     which is not required by \\\n-                     the corresponding type parameter \\\n-                     in the trait declaration\",\n-                    tcx.sess.str_of(trait_m.ident),\n-                    i,\n-                    extra_bounds.user_string(tcx)));\n-           return;\n-        }\n-\n-        // FIXME(#2687)---we should be checking that the bounds of the\n-        // trait imply the bounds of the subtype, but it appears we\n-        // are...not checking this.\n-        if impl_param_def.bounds.trait_bounds.len() !=\n-            trait_param_def.bounds.trait_bounds.len()\n-        {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"in method `{}`, \\\n-                      type parameter {} has {} trait {}, but the \\\n-                      corresponding type parameter in \\\n-                      the trait declaration has {} trait {}\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     i, impl_param_def.bounds.trait_bounds.len(),\n-                     pluralize(impl_param_def.bounds.trait_bounds.len(),\n-                               ~\"bound\"),\n-                     trait_param_def.bounds.trait_bounds.len(),\n-                     pluralize(trait_param_def.bounds.trait_bounds.len(),\n-                               ~\"bound\")));\n-            return;\n-        }\n-    }\n-\n-    // Replace any references to the self region in the self type with\n-    // a free region.  So, for example, if the impl type is\n-    // \"&'self str\", then this would replace the self type with a free\n-    // region `self`.\n-    let dummy_self_r = ty::re_free(ty::FreeRegion {scope_id: cm.body_id,\n-                                                   bound_region: ty::br_self});\n-    let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n-\n-    // We are going to create a synthetic fn type that includes\n-    // both the method's self argument and its normal arguments.\n-    // So a method like `fn(&self, a: uint)` would be converted\n-    // into a function `fn(self: &T, a: uint)`.\n-    let mut trait_fn_args = ~[];\n-    let mut impl_fn_args = ~[];\n-\n-    // For both the trait and the impl, create an argument to\n-    // represent the self argument (unless this is a static method).\n-    // This argument will have the *transformed* self type.\n-    for &t in trait_m.transformed_self_ty.iter() {\n-        trait_fn_args.push(t);\n-    }\n-    for &t in impl_m.transformed_self_ty.iter() {\n-        impl_fn_args.push(t);\n-    }\n-\n-    // Add in the normal arguments.\n-    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n-    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n-\n-    // Create a bare fn type for trait/impl that includes self argument\n-    let trait_fty =\n-        ty::mk_bare_fn(tcx,\n-                       ty::BareFnTy {\n-                            purity: trait_m.fty.purity,\n-                            abis: trait_m.fty.abis,\n-                            sig: ty::FnSig {\n-                                bound_lifetime_names:\n-                                    trait_m.fty\n-                                           .sig\n-                                           .bound_lifetime_names\n-                                           .clone(),\n-                                inputs: trait_fn_args,\n-                                output: trait_m.fty.sig.output,\n-                                variadic: false\n-                            }\n-                        });\n-    let impl_fty =\n-        ty::mk_bare_fn(tcx,\n-                       ty::BareFnTy {\n-                            purity: impl_m.fty.purity,\n-                            abis: impl_m.fty.abis,\n-                            sig: ty::FnSig {\n-                                bound_lifetime_names:\n-                                    impl_m.fty\n-                                          .sig\n-                                          .bound_lifetime_names\n-                                          .clone(),\n-                                    inputs: impl_fn_args,\n-                                    output: impl_m.fty.sig.output,\n-                                    variadic: false\n-                            }\n-                        });\n-\n-    // Perform substitutions so that the trait/impl methods are expressed\n-    // in terms of the same set of type/region parameters:\n-    // - replace trait type parameters with those from `trait_substs`,\n-    //   except with any reference to bound self replaced with `dummy_self_r`\n-    // - replace method parameters on the trait with fresh, dummy parameters\n-    //   that correspond to the parameters we will find on the impl\n-    // - replace self region with a fresh, dummy region\n-    let impl_fty = {\n-        debug!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n-        replace_bound_self(tcx, impl_fty, dummy_self_r)\n-    };\n-    debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n-    let trait_fty = {\n-        let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n-        let dummy_tps = do vec::from_fn(num_trait_m_type_params) |i| {\n-            ty::mk_param(tcx, i + impl_tps,\n-                         impl_m.generics.type_param_defs[i].def_id)\n-        };\n-        let trait_tps = trait_substs.tps.map(\n-            |t| replace_bound_self(tcx, *t, dummy_self_r));\n-        let substs = substs {\n-            regions: ty::NonerasedRegions(opt_vec::with(dummy_self_r)),\n-            self_ty: Some(self_ty),\n-            tps: vec::append(trait_tps, dummy_tps)\n-        };\n-        debug!(\"trait_fty (pre-subst): {} substs={}\",\n-               trait_fty.repr(tcx), substs.repr(tcx));\n-        ty::subst(tcx, &substs, trait_fty)\n-    };\n-    debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n-\n-    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n-                          impl_fty, trait_fty) {\n-        result::Ok(()) => {}\n-        result::Err(ref terr) => {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"method `{}` has an incompatible type: {}\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     ty::type_err_to_str(tcx, terr)));\n-            ty::note_and_explain_type_err(tcx, terr);\n-        }\n-    }\n-    return;\n-\n-    // Replaces bound references to the self region with `with_r`.\n-    fn replace_bound_self(tcx: ty::ctxt, ty: ty::t,\n-                          with_r: ty::Region) -> ty::t {\n-        do ty::fold_regions(tcx, ty) |r, _in_fn| {\n-            if r == ty::re_bound(ty::br_self) {with_r} else {r}\n-        }\n-    }\n-}\n-\n-pub fn check_methods_against_trait(ccx: &CrateCtxt,\n-                                   generics: &ast::Generics,\n-                                   rp: Option<ty::region_variance>,\n-                                   selfty: ty::t,\n-                                   a_trait_ty: &ast::trait_ref,\n-                                   impl_ms: &[ConvertedMethod])\n-{\n-    let tcx = ccx.tcx;\n-    let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp,\n-                                          generics, selfty);\n-\n-    if trait_ref.def_id.crate == ast::LOCAL_CRATE {\n-        ensure_trait_methods(ccx, trait_ref.def_id.node);\n-    }\n-\n-    // Check that each method we impl is a method on the trait\n-    // Trait methods we don't implement must be default methods, but if not\n-    // we'll catch it in coherence\n-    let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n-    for impl_m in impl_ms.iter() {\n-        match trait_ms.iter().find(|trait_m| trait_m.ident.name == impl_m.mty.ident.name) {\n-            Some(trait_m) => {\n-                let num_impl_tps = generics.ty_params.len();\n-                compare_impl_method(\n-                    ccx.tcx, num_impl_tps, impl_m, *trait_m,\n-                    &trait_ref.substs, selfty);\n-            }\n-            None => {\n-                // This method is not part of the trait\n-                tcx.sess.span_err(\n-                    impl_m.span,\n-                    format!(\"method `{}` is not a member of trait `{}`\",\n-                         tcx.sess.str_of(impl_m.mty.ident),\n-                         path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n-            }\n-        }\n-    }\n-} // fn\n-\n pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n                      v: &ast::struct_field) {\n@@ -849,8 +565,6 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                     \"cannot provide an explicit implementation \\\n                      for a builtin kind\");\n             }\n-\n-            check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n       ast::item_trait(ref generics, _, ref trait_methods) => {"}, {"sha": "ca97a8997689f87786d551c541d1718a0c2a2e50", "filename": "src/test/compile-fail/class-method-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs?ref=168ac5290e9d4a787e020735f96fa789060a8f76", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:missing method `eat`\n trait animal {\n   fn eat(&self);\n }\n@@ -18,6 +17,7 @@ struct cat {\n }\n \n impl animal for cat {\n+    //~^ ERROR not all trait methods implemented, missing: `eat`\n }\n \n fn cat(in_x : uint) -> cat {"}, {"sha": "1a649c8ad2f83128c3ae252b5e6888ec11c8f1b2", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=168ac5290e9d4a787e020735f96fa789060a8f76", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct thing(uint);\n-impl Ord for thing { //~ ERROR missing method `lt`\n+impl Ord for thing { //~ ERROR not all trait methods implemented, missing: `lt`\n     fn le(&self, other: &thing) -> bool { **self < **other }\n     fn ge(&self, other: &thing) -> bool { **self < **other }\n }"}, {"sha": "4e45f33fe9b141e4f5953ba76f3ecc98799bae8f", "filename": "src/test/compile-fail/missing-derivable-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168ac5290e9d4a787e020735f96fa789060a8f76/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs?ref=168ac5290e9d4a787e020735f96fa789060a8f76", "patch": "@@ -20,7 +20,7 @@ impl MyEq for int {\n     fn eq(&self, other: &int) -> bool { *self == *other }\n }\n \n-impl MyEq for A {}  //~ ERROR missing method\n+impl MyEq for A {}  //~ ERROR not all trait methods implemented, missing: `eq`\n \n fn main() {\n }"}]}