{"sha": "96bd50dd47b645efa52d1312b9cc32e507d9cd76", "node_id": "C_kwDOAAsO6NoAKDk2YmQ1MGRkNDdiNjQ1ZWZhNTJkMTMxMmI5Y2MzMmU1MDdkOWNkNzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-25T14:34:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-25T14:34:13Z"}, "message": "Auto merge of #109581 - matthiaskrgr:rollup-e8fi2vi, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #109355 (Fix bad suggestion for clone/is_some in field init shorthand)\n - #109484 (Bugfix: avoid panic on invalid json output from libtest)\n - #109539 (Refactor `find_*_stability` functions)\n - #109542 (rustdoc: clean up `storage.js`)\n - #109545 (Deeply check well-formedness of return-position `impl Trait` in trait)\n - #109568 (miri: fix raw pointer dyn receivers)\n - #109570 (Add GUI test for \"Auto-hide item methods' documentation\" setting)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a591c692bbd22b9139fe3fa615a6ab7912d76013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a591c692bbd22b9139fe3fa615a6ab7912d76013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96bd50dd47b645efa52d1312b9cc32e507d9cd76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96bd50dd47b645efa52d1312b9cc32e507d9cd76", "html_url": "https://github.com/rust-lang/rust/commit/96bd50dd47b645efa52d1312b9cc32e507d9cd76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96bd50dd47b645efa52d1312b9cc32e507d9cd76/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b72e896268bd741a2a2bb10028dca9e6f8d0ae63", "url": "https://api.github.com/repos/rust-lang/rust/commits/b72e896268bd741a2a2bb10028dca9e6f8d0ae63", "html_url": "https://github.com/rust-lang/rust/commit/b72e896268bd741a2a2bb10028dca9e6f8d0ae63"}, {"sha": "beac95a4ab97c119d944f7fb33884d736f18c0be", "url": "https://api.github.com/repos/rust-lang/rust/commits/beac95a4ab97c119d944f7fb33884d736f18c0be", "html_url": "https://github.com/rust-lang/rust/commit/beac95a4ab97c119d944f7fb33884d736f18c0be"}], "stats": {"total": 1069, "additions": 627, "deletions": 442}, "files": [{"sha": "a29e389953eb35aaa470ff87e4d35c87a81e3193", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 297, "deletions": 294, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -226,307 +226,95 @@ impl UnstableReason {\n     }\n }\n \n-/// Collects stability info from all stability attributes in `attrs`.\n-/// Returns `None` if no stability attributes are found.\n+/// Collects stability info from `stable`/`unstable`/`rustc_allowed_through_unstable_modules`\n+/// attributes in `attrs`.  Returns `None` if no stability attributes are found.\n pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-{\n-    find_stability_generic(sess, attrs.iter(), item_sp)\n-}\n-\n-fn find_stability_generic<'a, I>(\n-    sess: &Session,\n-    attrs_iter: I,\n-    item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-where\n-    I: Iterator<Item = &'a Attribute>,\n-{\n-    use StabilityLevel::*;\n-\n+) -> Option<(Stability, Span)> {\n     let mut stab: Option<(Stability, Span)> = None;\n-    let mut const_stab: Option<(ConstStability, Span)> = None;\n-    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n-    let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    'outer: for attr in attrs_iter {\n-        if ![\n-            sym::rustc_const_unstable,\n-            sym::rustc_const_stable,\n-            sym::unstable,\n-            sym::stable,\n-            sym::rustc_promotable,\n-            sym::rustc_allowed_through_unstable_modules,\n-            sym::rustc_default_body_unstable,\n-        ]\n-        .iter()\n-        .any(|&s| attr.has_name(s))\n-        {\n-            continue; // not a stability level\n-        }\n-\n-        let meta = attr.meta();\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_allowed_through_unstable_modules => allowed_through_unstable_modules = true,\n+            sym::unstable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n \n-        if attr.has_name(sym::rustc_promotable) {\n-            promotable = true;\n-        } else if attr.has_name(sym::rustc_allowed_through_unstable_modules) {\n-            allowed_through_unstable_modules = true;\n-        }\n-        // attributes with data\n-        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        meta.span,\n-                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n-                    );\n-                    return false;\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n                 }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n-                    false\n+            }\n+            sym::stable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-            };\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n \n-            let meta_name = meta.name_or_empty();\n-            match meta_name {\n-                sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n-                    if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_default_body_unstable && body_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n+    if allowed_through_unstable_modules {\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n+        }\n+    }\n \n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    let mut issue_num = None;\n-                    let mut is_soft = false;\n-                    let mut implied_by = None;\n-                    for meta in metas {\n-                        let Some(mi) = meta.meta_item() else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n-                            );\n-                            continue 'outer;\n-                        };\n-                        match mi.name_or_empty() {\n-                            sym::feature => {\n-                                if !get(mi, &mut feature) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::reason => {\n-                                if !get(mi, &mut reason) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::issue => {\n-                                if !get(mi, &mut issue) {\n-                                    continue 'outer;\n-                                }\n+    stab\n+}\n \n-                                // These unwraps are safe because `get` ensures the meta item\n-                                // is a name/value pair string literal.\n-                                issue_num = match issue.unwrap().as_str() {\n-                                    \"none\" => None,\n-                                    issue => match issue.parse::<NonZeroU32>() {\n-                                        Ok(num) => Some(num),\n-                                        Err(err) => {\n-                                            sess.emit_err(\n-                                                session_diagnostics::InvalidIssueString {\n-                                                    span: mi.span,\n-                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n-                                                        mi.name_value_literal_span().unwrap(),\n-                                                        err.kind(),\n-                                                    ),\n-                                                },\n-                                            );\n-                                            continue 'outer;\n-                                        }\n-                                    },\n-                                };\n-                            }\n-                            sym::soft => {\n-                                if !mi.is_word() {\n-                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n-                                        span: mi.span,\n-                                    });\n-                                }\n-                                is_soft = true;\n-                            }\n-                            sym::implied_by => {\n-                                if !get(mi, &mut implied_by) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            _ => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    meta.span(),\n-                                    AttrError::UnknownMetaItem(\n-                                        pprust::path_to_string(&mi.path),\n-                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n+/// Collects stability info from `rustc_const_stable`/`rustc_const_unstable`/`rustc_promotable`\n+/// attributes in `attrs`.  Returns `None` if no stability attributes are found.\n+pub fn find_const_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    item_sp: Span,\n+) -> Option<(ConstStability, Span)> {\n+    let mut const_stab: Option<(ConstStability, Span)> = None;\n+    let mut promotable = false;\n \n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(_)) => {\n-                            if !rustc_lexer::is_ident(feature.as_str()) {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    attr.span,\n-                                    AttrError::NonIdentFeature,\n-                                );\n-                                continue;\n-                            }\n-                            let level = Unstable {\n-                                reason: UnstableReason::from_opt_reason(reason),\n-                                issue: issue_num,\n-                                is_soft,\n-                                implied_by,\n-                            };\n-                            if sym::unstable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else if sym::rustc_const_unstable == meta_name {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            } else if sym::rustc_default_body_unstable == meta_name {\n-                                body_stab =\n-                                    Some((DefaultBodyStability { level, feature }, attr.span));\n-                            } else {\n-                                unreachable!(\"Unknown stability attribute {meta_name}\");\n-                            }\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n-                            continue;\n-                        }\n-                    }\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_promotable => promotable = true,\n+            sym::rustc_const_unstable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-                sym::rustc_const_stable | sym::stable => {\n-                    if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        match meta {\n-                            NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                sym::since => {\n-                                    if !get(mi, &mut since) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"since\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n-                                }\n-                            },\n-                            NestedMetaItem::Lit(lit) => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    lit.span,\n-                                    AttrError::UnsupportedLiteral(\n-                                        UnsupportedLiteralReason::Generic,\n-                                        false,\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                        since = Some(rust_version_symbol());\n-                    }\n \n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            let level = Stable { since, allowed_through_unstable_modules: false };\n-                            if sym::stable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            }\n-                        }\n-                        (None, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n-                            continue;\n-                        }\n-                    }\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n+                }\n+            }\n+            sym::rustc_const_stable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n                 }\n-                _ => unreachable!(),\n             }\n+            _ => {}\n         }\n     }\n \n@@ -538,22 +326,237 @@ where\n         }\n     }\n \n-    if allowed_through_unstable_modules {\n-        match &mut stab {\n-            Some((\n-                Stability {\n-                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n-                    ..\n-                },\n-                _,\n-            )) => *allowed_through_unstable_modules = true,\n+    const_stab\n+}\n+\n+/// Collects stability info from `rustc_default_body_unstable` attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_body_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+) -> Option<(DefaultBodyStability, Span)> {\n+    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n+\n+    for attr in attrs {\n+        if attr.has_name(sym::rustc_default_body_unstable) {\n+            if body_stab.is_some() {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                break;\n+            }\n+\n+            if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n+            }\n+        }\n+    }\n+\n+    body_stab\n+}\n+\n+/// Read the content of a `stable`/`rustc_const_stable` attribute, and return the feature name and\n+/// its stability information.\n+fn parse_stability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut since = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::since => {\n+                if !insert_or_error(mi, &mut since) {\n+                    return None;\n+                }\n+            }\n             _ => {\n-                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"since\"],\n+                    ),\n+                );\n+                return None;\n             }\n         }\n     }\n \n-    (stab, const_stab, body_stab)\n+    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n+        since = Some(rust_version_symbol());\n+    }\n+\n+    match (feature, since) {\n+        (Some(feature), Some(since)) => {\n+            let level = StabilityLevel::Stable { since, allowed_through_unstable_modules: false };\n+            Some((feature, level))\n+        }\n+        (None, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            None\n+        }\n+        _ => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+            None\n+        }\n+    }\n+}\n+\n+/// Read the content of a `unstable`/`rustc_const_unstable`/`rustc_default_body_unstable`\n+/// attribute, and return the feature name and its stability information.\n+fn parse_unstability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut reason = None;\n+    let mut issue = None;\n+    let mut issue_num = None;\n+    let mut is_soft = false;\n+    let mut implied_by = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::reason => {\n+                if !insert_or_error(mi, &mut reason) {\n+                    return None;\n+                }\n+            }\n+            sym::issue => {\n+                if !insert_or_error(mi, &mut issue) {\n+                    return None;\n+                }\n+\n+                // These unwraps are safe because `insert_or_error` ensures the meta item\n+                // is a name/value pair string literal.\n+                issue_num = match issue.unwrap().as_str() {\n+                    \"none\" => None,\n+                    issue => match issue.parse::<NonZeroU32>() {\n+                        Ok(num) => Some(num),\n+                        Err(err) => {\n+                            sess.emit_err(\n+                                session_diagnostics::InvalidIssueString {\n+                                    span: mi.span,\n+                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                        mi.name_value_literal_span().unwrap(),\n+                                        err.kind(),\n+                                    ),\n+                                },\n+                            );\n+                            return None;\n+                        }\n+                    },\n+                };\n+            }\n+            sym::soft => {\n+                if !mi.is_word() {\n+                    sess.emit_err(session_diagnostics::SoftNoArgs { span: mi.span });\n+                }\n+                is_soft = true;\n+            }\n+            sym::implied_by => {\n+                if !insert_or_error(mi, &mut implied_by) {\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"reason\", \"issue\", \"soft\", \"implied_by\"],\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+    }\n+\n+    match (feature, reason, issue) {\n+        (Some(feature), reason, Some(_)) => {\n+            if !rustc_lexer::is_ident(feature.as_str()) {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::NonIdentFeature);\n+                return None;\n+            }\n+            let level = StabilityLevel::Unstable {\n+                reason: UnstableReason::from_opt_reason(reason),\n+                issue: issue_num,\n+                is_soft,\n+                implied_by,\n+            };\n+            Some((feature, level))\n+        }\n+        (None, _, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            return None;\n+        }\n+        _ => {\n+            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n+            return None;\n+        }\n+    }\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {"}, {"sha": "fc83985eaca22fdc5596fc370081327353b70c23", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -539,7 +539,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let mut receiver = args[0].clone();\n                 let receiver_place = loop {\n                     match receiver.layout.ty.kind() {\n-                        ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,\n+                        ty::Ref(..) | ty::RawPtr(..) => {\n+                            // We do *not* use `deref_operand` here: we don't want to conceptually\n+                            // create a place that must be dereferenceable, since the receiver might\n+                            // be a raw pointer and (for `*const dyn Trait`) we don't need to\n+                            // actually access memory to resolve this method.\n+                            // Also see <https://github.com/rust-lang/miri/issues/2786>.\n+                            let val = self.read_immediate(&receiver)?;\n+                            break self.ref_to_mplace(&val)?;\n+                        }\n                         ty::Dynamic(.., ty::Dyn) => break receiver.assert_mem_place(), // no immediate unsized values\n                         ty::Dynamic(.., ty::DynStar) => {\n                             // Not clear how to handle this, so far we assume the receiver is always a pointer."}, {"sha": "caa2a201c758dbfae4dd1a6398ea05e264670b14", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -793,7 +793,9 @@ impl SyntaxExtension {\n                 )\n             })\n             .unwrap_or_else(|| (None, helper_attrs));\n-        let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n+        let stability = attr::find_stability(&sess, attrs, span);\n+        let const_stability = attr::find_const_stability(&sess, attrs, span);\n+        let body_stability = attr::find_body_stability(&sess, attrs);\n         if let Some((_, sp)) = const_stability {\n             sess.emit_err(errors::MacroConstStability {\n                 span: sp,"}, {"sha": "491bd04f346bd2b7d90ebbc0652c7d6dbe1edba6", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 72, "deletions": 33, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -1544,42 +1544,81 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     span: Span,\n ) {\n     let tcx = wfcx.tcx();\n-    if let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id())\n-        && assoc_item.container == ty::AssocItemContainer::TraitContainer\n-    {\n-        // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): Even with the new lowering\n-        // strategy, we can't just call `check_associated_item` on the new RPITITs,\n-        // because tests like `tests/ui/async-await/in-trait/implied-bounds.rs` will fail.\n-        // That's because we need to check that the bounds of the RPITIT hold using\n-        // the special substs that we create during opaque type lowering, otherwise we're\n-        // getting a bunch of early bound and free regions mixed up... Haven't looked too\n-        // deep into this, though.\n-        for arg in fn_output.walk() {\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                // RPITITs are always eagerly normalized into opaques, so always look for an\n-                // opaque here.\n-                && let ty::Alias(ty::Opaque, opaque_ty) = ty.kind()\n-                && let Some(opaque_def_id) = opaque_ty.def_id.as_local()\n-                && let opaque = tcx.hir().expect_item(opaque_def_id).expect_opaque_ty()\n-                && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n-                && source == fn_def_id\n+    let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id()) else {\n+        return;\n+    };\n+    if assoc_item.container != ty::AssocItemContainer::TraitContainer {\n+        return;\n+    }\n+    fn_output.visit_with(&mut ImplTraitInTraitFinder {\n+        wfcx,\n+        fn_def_id,\n+        depth: ty::INNERMOST,\n+        seen: FxHashSet::default(),\n+    });\n+}\n+\n+// FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): Even with the new lowering\n+// strategy, we can't just call `check_associated_item` on the new RPITITs,\n+// because tests like `tests/ui/async-await/in-trait/implied-bounds.rs` will fail.\n+// That's because we need to check that the bounds of the RPITIT hold using\n+// the special substs that we create during opaque type lowering, otherwise we're\n+// getting a bunch of early bound and free regions mixed up... Haven't looked too\n+// deep into this, though.\n+struct ImplTraitInTraitFinder<'a, 'tcx> {\n+    wfcx: &'a WfCheckingCtxt<'a, 'tcx>,\n+    fn_def_id: LocalDefId,\n+    depth: ty::DebruijnIndex,\n+    seen: FxHashSet<DefId>,\n+}\n+impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n+    type BreakTy = !;\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<!> {\n+        let tcx = self.wfcx.tcx();\n+        if let ty::Alias(ty::Opaque, unshifted_opaque_ty) = *ty.kind()\n+            && self.seen.insert(unshifted_opaque_ty.def_id)\n+            && let Some(opaque_def_id) = unshifted_opaque_ty.def_id.as_local()\n+            && let opaque = tcx.hir().expect_item(opaque_def_id).expect_opaque_ty()\n+            && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n+            && source == self.fn_def_id\n+        {\n+            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, depth| {\n+                if let ty::ReLateBound(index, bv) = re.kind() {\n+                    if depth != ty::INNERMOST {\n+                        return tcx.mk_re_error_with_message(\n+                            DUMMY_SP,\n+                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n+                        );\n+                    }\n+                    tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n+                } else {\n+                    re\n+                }\n+            });\n+            for (bound, bound_span) in tcx\n+                .bound_explicit_item_bounds(opaque_ty.def_id)\n+                .subst_iter_copied(tcx, opaque_ty.substs)\n             {\n-                let span = tcx.def_span(opaque_ty.def_id);\n-                let bounds = wfcx.tcx().explicit_item_bounds(opaque_ty.def_id);\n-                let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-                    let bound = ty::EarlyBinder(bound).subst(tcx, opaque_ty.substs);\n-                    let normalized_bound = wfcx.normalize(span, None, bound);\n-                    traits::wf::predicate_obligations(\n-                        wfcx.infcx,\n-                        wfcx.param_env,\n-                        wfcx.body_def_id,\n-                        normalized_bound,\n-                        bound_span,\n-                    )\n-                });\n-                wfcx.register_obligations(wf_obligations);\n+                let bound = self.wfcx.normalize(bound_span, None, bound);\n+                self.wfcx.register_obligations(traits::wf::predicate_obligations(\n+                    self.wfcx.infcx,\n+                    self.wfcx.param_env,\n+                    self.wfcx.body_def_id,\n+                    bound,\n+                    bound_span,\n+                ));\n+                // Set the debruijn index back to innermost here, since we already eagerly\n+                // shifted the substs that we use to generate these bounds. This is unfortunately\n+                // subtly different behavior than the `ImplTraitInTraitFinder` we use in `param_env`,\n+                // but that function doesn't actually need to normalize the bound it's visiting\n+                // (whereas we have to do so here)...\n+                let old_depth = std::mem::replace(&mut self.depth, ty::INNERMOST);\n+                bound.visit_with(self);\n+                self.depth = old_depth;\n             }\n         }\n+        ty.super_visit_with(self)\n     }\n }\n "}, {"sha": "5fda4e191c2a003f447f0016f6659295de62a002", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -983,13 +983,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n                 .must_apply_modulo_regions()\n           {\n-              diag.span_suggestion_verbose(\n-                  expr.span.shrink_to_hi(),\n-                  \"consider using clone here\",\n-                  \".clone()\",\n-                  Applicability::MachineApplicable,\n-              );\n-              return true;\n+            let suggestion = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                Some(ident) => format!(\": {}.clone()\", ident),\n+                None => \".clone()\".to_string()\n+            };\n+\n+            diag.span_suggestion_verbose(\n+                expr.span.shrink_to_hi(),\n+                \"consider using clone here\",\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n           }\n         false\n     }\n@@ -1150,13 +1155,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return false;\n         }\n \n-        diag.span_suggestion(\n+        let suggestion = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+            Some(ident) => format!(\": {}.is_some()\", ident),\n+            None => \".is_some()\".to_string(),\n+        };\n+\n+        diag.span_suggestion_verbose(\n             expr.span.shrink_to_hi(),\n             \"use `Option::is_some` to test if the `Option` has a value\",\n-            \".is_some()\",\n+            suggestion,\n             Applicability::MachineApplicable,\n         );\n-\n         true\n     }\n "}, {"sha": "4a1ba19c92064c714bfd5c3ca00cc4a0b3bfc101", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -159,7 +159,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab, body_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let stab = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item_sp);\n+        let body_stab = attr::find_body_stability(&self.tcx.sess, attrs);\n         let mut const_span = None;\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n@@ -742,8 +744,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 let features = self.tcx.features();\n                 if features.staged_api {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n-                    let (stab, const_stab, _) =\n-                        attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let stab = attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item.span);\n \n                     // If this impl block has an #[unstable] attribute, give an\n                     // error if all involved types and traits are stable, because"}, {"sha": "19019ad2c089dc0f73bbd65f320857f83aa674fe", "filename": "src/bootstrap/render_tests.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -100,18 +100,13 @@ impl<'a> Renderer<'a> {\n                 break;\n             }\n \n-            let trimmed = line.trim();\n-            if trimmed.starts_with(\"{\") && trimmed.ends_with(\"}\") {\n-                self.render_message(match serde_json::from_str(&trimmed) {\n-                    Ok(parsed) => parsed,\n-                    Err(err) => {\n-                        panic!(\"failed to parse libtest json output; error: {err}, line: {line:?}\");\n-                    }\n-                });\n-            } else {\n-                // Handle non-JSON output, for example when --nocapture is passed.\n-                print!(\"{line}\");\n-                let _ = std::io::stdout().flush();\n+            match serde_json::from_str(&line) {\n+                Ok(parsed) => self.render_message(parsed),\n+                Err(_err) => {\n+                    // Handle non-JSON output, for example when --nocapture is passed.\n+                    print!(\"{line}\");\n+                    let _ = std::io::stdout().flush();\n+                }\n             }\n         }\n     }"}, {"sha": "933a44c5aa78d77f46dcef4def1f7827eb2fcdae", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -87,21 +87,6 @@\n \tbox-sizing: border-box;\n }\n \n-/* This part handles the \"default\" theme being used depending on the system one. */\n-html {\n-\tcontent: \"\";\n-}\n-@media (prefers-color-scheme: light) {\n-\thtml {\n-\t\tcontent: \"light\";\n-\t}\n-}\n-@media (prefers-color-scheme: dark) {\n-\thtml {\n-\t\tcontent: \"dark\";\n-\t}\n-}\n-\n /* General structure and fonts */\n \n body {\n@@ -1538,7 +1523,7 @@ However, it's not needed with smaller screen width because the doc/code block is\n /*\n WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n If you update this line, then you also need to update the line with the same warning\n-in storage.js\n+in main.js\n */\n @media (max-width: 700px) {\n \t/* When linking to an item with an `id` (for instance, by clicking a link in the sidebar,"}, {"sha": "1487ebf9b0aa1a4c01f19ebc3f8f1b28e9afe9d4", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -4,6 +4,11 @@\n \n \"use strict\";\n \n+// WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n+// If you update this line, then you also need to update the media query with the same\n+// warning in rustdoc.css\n+window.RUSTDOC_MOBILE_BREAKPOINT = 700;\n+\n // Given a basename (e.g. \"storage\") and an extension (e.g. \".js\"), return a URL\n // for a resource under the root-path, with the resource-suffix.\n function resourcePath(basename, extension) {"}, {"sha": "8d82b5b78edbbee8dc5ee57e39fbe674e718b2ee", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 13, "deletions": 61, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -8,37 +8,22 @@\n const darkThemes = [\"dark\", \"ayu\"];\n window.currentTheme = document.getElementById(\"themeStyle\");\n \n-// WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n-// If you update this line, then you also need to update the media query with the same\n-// warning in rustdoc.css\n-window.RUSTDOC_MOBILE_BREAKPOINT = 700;\n-\n const settingsDataset = (function() {\n     const settingsElement = document.getElementById(\"default-settings\");\n-    if (settingsElement === null) {\n-        return null;\n-    }\n-    const dataset = settingsElement.dataset;\n-    if (dataset === undefined) {\n-        return null;\n-    }\n-    return dataset;\n+    return settingsElement && settingsElement.dataset ? settingsElement.dataset : null;\n })();\n \n function getSettingValue(settingName) {\n     const current = getCurrentValue(settingName);\n-    if (current !== null) {\n-        return current;\n-    }\n-    if (settingsDataset !== null) {\n+    if (current === null && settingsDataset !== null) {\n         // See the comment for `default_settings.into_iter()` etc. in\n         // `Options::from_matches` in `librustdoc/config.rs`.\n         const def = settingsDataset[settingName.replace(/-/g,\"_\")];\n         if (def !== undefined) {\n             return def;\n         }\n     }\n-    return null;\n+    return current;\n }\n \n const localStoredTheme = getSettingValue(\"theme\");\n@@ -49,18 +34,16 @@ function hasClass(elem, className) {\n }\n \n function addClass(elem, className) {\n-    if (!elem || !elem.classList) {\n-        return;\n+    if (elem && elem.classList) {\n+        elem.classList.add(className);\n     }\n-    elem.classList.add(className);\n }\n \n // eslint-disable-next-line no-unused-vars\n function removeClass(elem, className) {\n-    if (!elem || !elem.classList) {\n-        return;\n+    if (elem && elem.classList) {\n+        elem.classList.remove(className);\n     }\n-    elem.classList.remove(className);\n }\n \n /**\n@@ -127,11 +110,7 @@ function getCurrentValue(name) {\n // Rust to the JS. If there is no such element, return null.\n const getVar = (function getVar(name) {\n     const el = document.getElementById(\"rustdoc-vars\");\n-    if (el) {\n-        return el.attributes[\"data-\" + name].value;\n-    } else {\n-        return null;\n-    }\n+    return el ? el.attributes[\"data-\" + name].value : null;\n });\n \n function switchTheme(newThemeName, saveTheme) {\n@@ -158,6 +137,9 @@ function switchTheme(newThemeName, saveTheme) {\n }\n \n const updateTheme = (function() {\n+    // only listen to (prefers-color-scheme: dark) because light is the default\n+    const mql = window.matchMedia(\"(prefers-color-scheme: dark)\");\n+\n     /**\n      * Update the current theme to match whatever the current combination of\n      * * the preference for using the system theme\n@@ -177,7 +159,7 @@ const updateTheme = (function() {\n             const lightTheme = getSettingValue(\"preferred-light-theme\") || \"light\";\n             const darkTheme = getSettingValue(\"preferred-dark-theme\") || \"dark\";\n \n-            if (isDarkMode()) {\n+            if (mql.matches) {\n                 use(darkTheme, true);\n             } else {\n                 // prefers a light theme, or has no preference\n@@ -191,37 +173,7 @@ const updateTheme = (function() {\n         }\n     }\n \n-    // This is always updated below to a function () => bool.\n-    let isDarkMode;\n-\n-    // Determine the function for isDarkMode, and if we have\n-    // `window.matchMedia`, set up an event listener on the preferred color\n-    // scheme.\n-    //\n-    // Otherwise, fall back to the prefers-color-scheme value CSS captured in\n-    // the \"content\" property.\n-    if (window.matchMedia) {\n-        // only listen to (prefers-color-scheme: dark) because light is the default\n-        const mql = window.matchMedia(\"(prefers-color-scheme: dark)\");\n-\n-        isDarkMode = () => mql.matches;\n-\n-        if (mql.addEventListener) {\n-            mql.addEventListener(\"change\", updateTheme);\n-        } else {\n-            // This is deprecated, see:\n-            // https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/addListener\n-            mql.addListener(updateTheme);\n-        }\n-    } else {\n-        // fallback to the CSS computed value\n-        const cssContent = getComputedStyle(document.documentElement)\n-            .getPropertyValue(\"content\");\n-        // (Note: the double-quotes come from that this is a CSS value, which\n-        // might be a length, string, etc.)\n-        const cssColorScheme = cssContent || \"\\\"light\\\"\";\n-        isDarkMode = () => (cssColorScheme === \"\\\"dark\\\"\");\n-    }\n+    mql.addEventListener(\"change\", updateTheme);\n \n     return updateTheme;\n })();"}, {"sha": "fc58775a195e81914f8c0e09995bcfea87b12fb1", "filename": "src/tools/miri/tests/pass/dyn-arbitrary-self.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -123,8 +123,35 @@ fn pointers_and_wrappers() {\n     assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n }\n \n+fn raw_ptr_receiver() {\n+    use std::ptr;\n+\n+    trait Foo {\n+        fn foo(self: *const Self) -> &'static str;\n+    }\n+\n+    impl Foo for i32 {\n+        fn foo(self: *const Self) -> &'static str {\n+            \"I'm an i32!\"\n+        }\n+    }\n+\n+    impl Foo for u32 {\n+        fn foo(self: *const Self) -> &'static str {\n+            \"I'm a u32!\"\n+        }\n+    }\n+\n+    let null_i32 = ptr::null::<i32>() as *const dyn Foo;\n+    let null_u32 = ptr::null::<u32>() as *const dyn Foo;\n+\n+    assert_eq!(\"I'm an i32!\", null_i32.foo());\n+    assert_eq!(\"I'm a u32!\", null_u32.foo());\n+}\n+\n fn main() {\n     pin_box_dyn();\n     stdlib_pointers();\n     pointers_and_wrappers();\n+    raw_ptr_receiver();\n }"}, {"sha": "e34fee33bebbb42f9e747bca17cb1fe39ee07a3a", "filename": "tests/rustdoc-gui/setting-auto-hide-item-methods-docs.goml", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Frustdoc-gui%2Fsetting-auto-hide-item-methods-docs.goml", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Frustdoc-gui%2Fsetting-auto-hide-item-methods-docs.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsetting-auto-hide-item-methods-docs.goml?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -0,0 +1,48 @@\n+// This test ensures that the \"Auto-hide item methods' documentation\" setting is working as\n+// expected.\n+\n+define-function: (\n+    \"check-setting\",\n+    (storage_value, setting_attribute_value, toggle_attribute_value),\n+    block {\n+        assert-local-storage: {\"rustdoc-auto-hide-method-docs\": |storage_value|}\n+        click: \"#settings-menu\"\n+        wait-for: \"#settings\"\n+        assert-property: (\"#auto-hide-method-docs\", {\"checked\": |setting_attribute_value|})\n+        assert-attribute: (\".toggle.method-toggle\", {\"open\": |toggle_attribute_value|})\n+    }\n+)\n+\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/struct.Foo.html\"\n+\n+// We check that the setting is disabled by default.\n+call-function: (\"check-setting\", {\n+    \"storage_value\": null,\n+    \"setting_attribute_value\": \"false\",\n+    \"toggle_attribute_value\": \"\",\n+})\n+\n+// Now we change its value.\n+click: \"#auto-hide-method-docs\"\n+assert-local-storage: {\"rustdoc-auto-hide-method-docs\": \"true\"}\n+\n+// We check that the changes were applied as expected.\n+reload:\n+\n+call-function: (\"check-setting\", {\n+    \"storage_value\": \"true\",\n+    \"setting_attribute_value\": \"true\",\n+    \"toggle_attribute_value\": null,\n+})\n+\n+// And now we re-disable the setting.\n+click: \"#auto-hide-method-docs\"\n+assert-local-storage: {\"rustdoc-auto-hide-method-docs\": \"false\"}\n+\n+// And we check everything is back the way it was before.\n+reload:\n+call-function: (\"check-setting\", {\n+    \"storage_value\": \"false\",\n+    \"setting_attribute_value\": \"false\",\n+    \"toggle_attribute_value\": \"\",\n+})"}, {"sha": "1a70716123cfb08afb62f59f0ae2c9d8c3b15da1", "filename": "tests/ui/impl-trait/in-trait/wf-bounds.current.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.current.stderr?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:11:22\n+  --> $DIR/wf-bounds.rs:13:22\n    |\n LL |     fn nya() -> impl Wf<Vec<[u8]>>;\n    |                      ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n@@ -9,7 +9,7 @@ note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:14:23\n+  --> $DIR/wf-bounds.rs:16:23\n    |\n LL |     fn nya2() -> impl Wf<[u8]>;\n    |                       ^^^^^^^^ doesn't have a size known at compile-time\n@@ -18,13 +18,23 @@ LL |     fn nya2() -> impl Wf<[u8]>;\n note: required by a bound in `Wf`\n   --> $DIR/wf-bounds.rs:8:10\n    |\n-LL | trait Wf<T> {}\n+LL | trait Wf<T> {\n    |          ^ required by this bound in `Wf`\n help: consider relaxing the implicit `Sized` restriction\n    |\n-LL | trait Wf<T: ?Sized> {}\n+LL | trait Wf<T: ?Sized> {\n    |           ++++++++\n \n-error: aborting due to 2 previous errors\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/wf-bounds.rs:19:44\n+   |\n+LL |     fn nya3() -> impl Wf<(), Output = impl Wf<Vec<[u8]>>>;\n+   |                                            ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+note: required by a bound in `Vec`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "1a70716123cfb08afb62f59f0ae2c9d8c3b15da1", "filename": "tests/ui/impl-trait/in-trait/wf-bounds.next.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.next.stderr?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:11:22\n+  --> $DIR/wf-bounds.rs:13:22\n    |\n LL |     fn nya() -> impl Wf<Vec<[u8]>>;\n    |                      ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n@@ -9,7 +9,7 @@ note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:14:23\n+  --> $DIR/wf-bounds.rs:16:23\n    |\n LL |     fn nya2() -> impl Wf<[u8]>;\n    |                       ^^^^^^^^ doesn't have a size known at compile-time\n@@ -18,13 +18,23 @@ LL |     fn nya2() -> impl Wf<[u8]>;\n note: required by a bound in `Wf`\n   --> $DIR/wf-bounds.rs:8:10\n    |\n-LL | trait Wf<T> {}\n+LL | trait Wf<T> {\n    |          ^ required by this bound in `Wf`\n help: consider relaxing the implicit `Sized` restriction\n    |\n-LL | trait Wf<T: ?Sized> {}\n+LL | trait Wf<T: ?Sized> {\n    |           ++++++++\n \n-error: aborting due to 2 previous errors\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/wf-bounds.rs:19:44\n+   |\n+LL |     fn nya3() -> impl Wf<(), Output = impl Wf<Vec<[u8]>>>;\n+   |                                            ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+note: required by a bound in `Vec`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "1c9590bd853d122b1c24001392cce618941f3415", "filename": "tests/ui/impl-trait/in-trait/wf-bounds.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -5,14 +5,19 @@\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n \n-trait Wf<T> {}\n+trait Wf<T> {\n+    type Output;\n+}\n \n trait Uwu {\n     fn nya() -> impl Wf<Vec<[u8]>>;\n     //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n \n     fn nya2() -> impl Wf<[u8]>;\n     //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+\n+    fn nya3() -> impl Wf<(), Output = impl Wf<Vec<[u8]>>>;\n+    //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n }\n \n fn main() {}"}, {"sha": "9d15c4a8fcb9088579cb0b2f2accce92d56b495e", "filename": "tests/ui/suggestions/issue-108470.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fsuggestions%2Fissue-108470.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fsuggestions%2Fissue-108470.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-108470.fixed?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+struct Foo {\n+    t: Thing\n+}\n+\n+#[derive(Clone)]\n+struct Thing;\n+\n+fn test_clone() {\n+    let t = &Thing;\n+    let _f = Foo {\n+        t: t.clone() //~ ERROR mismatched types\n+    };\n+}\n+\n+struct Bar {\n+    t: bool\n+}\n+\n+fn test_is_some() {\n+    let t = Option::<i32>::Some(1);\n+    let _f = Bar {\n+        t: t.is_some() //~ ERROR mismatched types\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "bda39085d4db5d4ad68ce599eae27812e437042e", "filename": "tests/ui/suggestions/issue-108470.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fsuggestions%2Fissue-108470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fsuggestions%2Fissue-108470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-108470.rs?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+struct Foo {\n+    t: Thing\n+}\n+\n+#[derive(Clone)]\n+struct Thing;\n+\n+fn test_clone() {\n+    let t = &Thing;\n+    let _f = Foo {\n+        t //~ ERROR mismatched types\n+    };\n+}\n+\n+struct Bar {\n+    t: bool\n+}\n+\n+fn test_is_some() {\n+    let t = Option::<i32>::Some(1);\n+    let _f = Bar {\n+        t //~ ERROR mismatched types\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "4e561eca73426b04ee679d6ef814b1d7085a4c68", "filename": "tests/ui/suggestions/issue-108470.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fsuggestions%2Fissue-108470.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96bd50dd47b645efa52d1312b9cc32e507d9cd76/tests%2Fui%2Fsuggestions%2Fissue-108470.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-108470.stderr?ref=96bd50dd47b645efa52d1312b9cc32e507d9cd76", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-108470.rs:14:9\n+   |\n+LL |         t\n+   |         ^ expected `Thing`, found `&Thing`\n+   |\n+help: consider using clone here\n+   |\n+LL |         t: t.clone()\n+   |          +++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-108470.rs:25:9\n+   |\n+LL |         t\n+   |         ^ expected `bool`, found `Option<i32>`\n+   |\n+   = note: expected type `bool`\n+              found enum `Option<i32>`\n+help: use `Option::is_some` to test if the `Option` has a value\n+   |\n+LL |         t: t.is_some()\n+   |          +++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}