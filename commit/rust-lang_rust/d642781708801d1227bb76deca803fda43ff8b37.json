{"sha": "d642781708801d1227bb76deca803fda43ff8b37", "node_id": "C_kwDOAAsO6NoAKGQ2NDI3ODE3MDg4MDFkMTIyN2JiNzZkZWNhODAzZmRhNDNmZjhiMzc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-11T19:07:03Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-11T19:07:03Z"}, "message": "Make selfless `dyn AstConv` methods into toplevel functions", "tree": {"sha": "2e48f262f789cb76f4607d76db770b3ee1f970b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e48f262f789cb76f4607d76db770b3ee1f970b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d642781708801d1227bb76deca803fda43ff8b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d642781708801d1227bb76deca803fda43ff8b37", "html_url": "https://github.com/rust-lang/rust/commit/d642781708801d1227bb76deca803fda43ff8b37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d642781708801d1227bb76deca803fda43ff8b37/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89f1555824799432118c3be1e4c0fb17854a7bbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/89f1555824799432118c3be1e4c0fb17854a7bbd", "html_url": "https://github.com/rust-lang/rust/commit/89f1555824799432118c3be1e4c0fb17854a7bbd"}], "stats": {"total": 1165, "additions": 578, "deletions": 587}, "files": [{"sha": "ce3682a8f2d5cda48084a4566eb84e76ccb4e9c4", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 558, "deletions": 576, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=d642781708801d1227bb76deca803fda43ff8b37", "patch": "@@ -1,6 +1,6 @@\n use super::IsMethodCall;\n use crate::astconv::{\n-    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, GenericArgPosition,\n };\n use crate::errors::AssocTypeBindingNotAllowed;\n@@ -18,642 +18,624 @@ use rustc_session::lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS;\n use rustc_span::{symbol::kw, Span};\n use smallvec::SmallVec;\n \n-impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n-    /// Report an error that a generic argument did not match the generic parameter that was\n-    /// expected.\n-    fn generic_arg_mismatch_err(\n-        tcx: TyCtxt<'_>,\n-        arg: &GenericArg<'_>,\n-        param: &GenericParamDef,\n-        possible_ordering_error: bool,\n-        help: Option<&str>,\n-    ) {\n-        let sess = tcx.sess;\n-        let mut err = struct_span_err!(\n-            sess,\n-            arg.span(),\n-            E0747,\n-            \"{} provided when a {} was expected\",\n-            arg.descr(),\n-            param.kind.descr(),\n-        );\n-\n-        if let GenericParamDefKind::Const { .. } = param.kind {\n-            if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n-                err.help(\"const arguments cannot yet be inferred with `_`\");\n-                if sess.is_nightly_build() {\n-                    err.help(\n-                        \"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\",\n-                    );\n-                }\n+/// Report an error that a generic argument did not match the generic parameter that was\n+/// expected.\n+fn generic_arg_mismatch_err(\n+    tcx: TyCtxt<'_>,\n+    arg: &GenericArg<'_>,\n+    param: &GenericParamDef,\n+    possible_ordering_error: bool,\n+    help: Option<&str>,\n+) {\n+    let sess = tcx.sess;\n+    let mut err = struct_span_err!(\n+        sess,\n+        arg.span(),\n+        E0747,\n+        \"{} provided when a {} was expected\",\n+        arg.descr(),\n+        param.kind.descr(),\n+    );\n+\n+    if let GenericParamDefKind::Const { .. } = param.kind {\n+        if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n+            err.help(\"const arguments cannot yet be inferred with `_`\");\n+            if sess.is_nightly_build() {\n+                err.help(\"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\");\n             }\n         }\n+    }\n \n-        let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n-            let suggestions = vec![\n-                (arg.span().shrink_to_lo(), String::from(\"{ \")),\n-                (arg.span().shrink_to_hi(), String::from(\" }\")),\n-            ];\n-            err.multipart_suggestion(\n-                \"if this generic argument was intended as a const parameter, \\\n+    let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n+        let suggestions = vec![\n+            (arg.span().shrink_to_lo(), String::from(\"{ \")),\n+            (arg.span().shrink_to_hi(), String::from(\" }\")),\n+        ];\n+        err.multipart_suggestion(\n+            \"if this generic argument was intended as a const parameter, \\\n                  surround it with braces\",\n-                suggestions,\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-\n-        // Specific suggestion set for diagnostics\n-        match (arg, &param.kind) {\n-            (\n-                GenericArg::Type(hir::Ty {\n-                    kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n-                    ..\n-                }),\n-                GenericParamDefKind::Const { .. },\n-            ) => match path.res {\n-                Res::Err => {\n-                    add_braces_suggestion(arg, &mut err);\n-                    err.set_primary_message(\n-                        \"unresolved item provided when a constant was expected\",\n-                    )\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+\n+    // Specific suggestion set for diagnostics\n+    match (arg, &param.kind) {\n+        (\n+            GenericArg::Type(hir::Ty {\n+                kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n+                ..\n+            }),\n+            GenericParamDefKind::Const { .. },\n+        ) => match path.res {\n+            Res::Err => {\n+                add_braces_suggestion(arg, &mut err);\n+                err.set_primary_message(\"unresolved item provided when a constant was expected\")\n                     .emit();\n-                    return;\n-                }\n-                Res::Def(DefKind::TyParam, src_def_id) => {\n-                    if let Some(param_local_id) = param.def_id.as_local() {\n-                        let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.type_of(param.def_id);\n-                        if param_type.is_suggestable(tcx, false) {\n-                            err.span_suggestion(\n-                                tcx.def_span(src_def_id),\n-                                \"consider changing this type parameter to be a `const` generic\",\n-                                format!(\"const {}: {}\", param_name, param_type),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        };\n-                    }\n-                }\n-                _ => add_braces_suggestion(arg, &mut err),\n-            },\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) => add_braces_suggestion(arg, &mut err),\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n-                let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n-                if let Ok(snippet) = snippet {\n-                    err.span_suggestion(\n-                        arg.span(),\n-                        \"array type provided where a `usize` was expected, try\",\n-                        format!(\"{{ {} }}\", snippet),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                return;\n+            }\n+            Res::Def(DefKind::TyParam, src_def_id) => {\n+                if let Some(param_local_id) = param.def_id.as_local() {\n+                    let param_name = tcx.hir().ty_param_name(param_local_id);\n+                    let param_type = tcx.type_of(param.def_id);\n+                    if param_type.is_suggestable(tcx, false) {\n+                        err.span_suggestion(\n+                            tcx.def_span(src_def_id),\n+                            \"consider changing this type parameter to be a `const` generic\",\n+                            format!(\"const {}: {}\", param_name, param_type),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    };\n                 }\n             }\n-            (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n-                let body = tcx.hir().body(cnst.value.body);\n-                if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) =\n-                    body.value.kind\n-                {\n-                    if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n-                        err.help(&format!(\n-                            \"`{}` is a function item, not a type\",\n-                            tcx.item_name(id)\n-                        ));\n-                        err.help(\"function item types cannot be named directly\");\n-                    }\n+            _ => add_braces_suggestion(arg, &mut err),\n+        },\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) => add_braces_suggestion(arg, &mut err),\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n+            let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n+            if let Ok(snippet) = snippet {\n+                err.span_suggestion(\n+                    arg.span(),\n+                    \"array type provided where a `usize` was expected, try\",\n+                    format!(\"{{ {} }}\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n+            let body = tcx.hir().body(cnst.value.body);\n+            if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) = body.value.kind\n+            {\n+                if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n+                    err.help(&format!(\"`{}` is a function item, not a type\", tcx.item_name(id)));\n+                    err.help(\"function item types cannot be named directly\");\n                 }\n             }\n-            _ => {}\n         }\n+        _ => {}\n+    }\n \n-        let kind_ord = param.kind.to_ord();\n-        let arg_ord = arg.to_ord();\n+    let kind_ord = param.kind.to_ord();\n+    let arg_ord = arg.to_ord();\n \n-        // This note is only true when generic parameters are strictly ordered by their kind.\n-        if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n-            let (first, last) = if kind_ord < arg_ord {\n-                (param.kind.descr(), arg.descr())\n-            } else {\n-                (arg.descr(), param.kind.descr())\n-            };\n-            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-            if let Some(help) = help {\n-                err.help(help);\n-            }\n+    // This note is only true when generic parameters are strictly ordered by their kind.\n+    if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+        let (first, last) = if kind_ord < arg_ord {\n+            (param.kind.descr(), arg.descr())\n+        } else {\n+            (arg.descr(), param.kind.descr())\n+        };\n+        err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+        if let Some(help) = help {\n+            err.help(help);\n         }\n+    }\n+\n+    err.emit();\n+}\n \n-        err.emit();\n+/// Creates the relevant generic argument substitutions\n+/// corresponding to a set of generic parameters. This is a\n+/// rather complex function. Let us try to explain the role\n+/// of each of its parameters:\n+///\n+/// To start, we are given the `def_id` of the thing we are\n+/// creating the substitutions for, and a partial set of\n+/// substitutions `parent_substs`. In general, the substitutions\n+/// for an item begin with substitutions for all the \"parents\" of\n+/// that item -- e.g., for a method it might include the\n+/// parameters from the impl.\n+///\n+/// Therefore, the method begins by walking down these parents,\n+/// starting with the outermost parent and proceed inwards until\n+/// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n+/// first to see if the parent's substitutions are listed in there. If so,\n+/// we can append those and move on. Otherwise, it invokes the\n+/// three callback functions:\n+///\n+/// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n+///   generic arguments that were given to that parent from within\n+///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n+///   might refer to the trait `Foo`, and the arguments might be\n+///   `[T]`. The boolean value indicates whether to infer values\n+///   for arguments whose values were not explicitly provided.\n+/// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n+///   instantiate a `GenericArg`.\n+/// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n+///   creates a suitable inference variable.\n+pub fn create_substs_for_generic_args<'tcx, 'a>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    parent_substs: &[subst::GenericArg<'tcx>],\n+    has_self: bool,\n+    self_ty: Option<Ty<'tcx>>,\n+    arg_count: &GenericArgCountResult,\n+    ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n+) -> SubstsRef<'tcx> {\n+    // Collect the segments of the path; we need to substitute arguments\n+    // for parameters throughout the entire path (wherever there are\n+    // generic parameters).\n+    let mut parent_defs = tcx.generics_of(def_id);\n+    let count = parent_defs.count();\n+    let mut stack = vec![(def_id, parent_defs)];\n+    while let Some(def_id) = parent_defs.parent {\n+        parent_defs = tcx.generics_of(def_id);\n+        stack.push((def_id, parent_defs));\n     }\n \n-    /// Creates the relevant generic argument substitutions\n-    /// corresponding to a set of generic parameters. This is a\n-    /// rather complex function. Let us try to explain the role\n-    /// of each of its parameters:\n-    ///\n-    /// To start, we are given the `def_id` of the thing we are\n-    /// creating the substitutions for, and a partial set of\n-    /// substitutions `parent_substs`. In general, the substitutions\n-    /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- e.g., for a method it might include the\n-    /// parameters from the impl.\n-    ///\n-    /// Therefore, the method begins by walking down these parents,\n-    /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n-    /// first to see if the parent's substitutions are listed in there. If so,\n-    /// we can append those and move on. Otherwise, it invokes the\n-    /// three callback functions:\n-    ///\n-    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n-    ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n-    ///   might refer to the trait `Foo`, and the arguments might be\n-    ///   `[T]`. The boolean value indicates whether to infer values\n-    ///   for arguments whose values were not explicitly provided.\n-    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `GenericArg`.\n-    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n-    ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'a>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        parent_substs: &[subst::GenericArg<'tcx>],\n-        has_self: bool,\n-        self_ty: Option<Ty<'tcx>>,\n-        arg_count: &GenericArgCountResult,\n-        ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n-    ) -> SubstsRef<'tcx> {\n-        // Collect the segments of the path; we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n+    // We manually build up the substitution, rather than using convenience\n+    // methods in `subst.rs`, so that we can iterate over the arguments and\n+    // parameters in lock-step linearly, instead of trying to match each pair.\n+    let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n+    // Iterate over each segment of the path.\n+    while let Some((def_id, defs)) = stack.pop() {\n+        let mut params = defs.params.iter().peekable();\n+\n+        // If we have already computed substitutions for parents, we can use those directly.\n+        while let Some(&param) = params.peek() {\n+            if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                substs.push(kind);\n+                params.next();\n+            } else {\n+                break;\n+            }\n         }\n \n-        // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs`, so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter().peekable();\n-\n-            // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(&param) = params.peek() {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    substs.push(kind);\n-                    params.next();\n-                } else {\n-                    break;\n+        // `Self` is handled first, unless it's been handled in `parent_substs`.\n+        if has_self {\n+            if let Some(&param) = params.peek() {\n+                if param.index == 0 {\n+                    if let GenericParamDefKind::Type { .. } = param.kind {\n+                        substs.push(\n+                            self_ty\n+                                .map(|ty| ty.into())\n+                                .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n+                        );\n+                        params.next();\n+                    }\n                 }\n             }\n+        }\n \n-            // `Self` is handled first, unless it's been handled in `parent_substs`.\n-            if has_self {\n-                if let Some(&param) = params.peek() {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            substs.push(\n-                                self_ty\n-                                    .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n-                            );\n+        // Check whether this segment takes generic arguments and the user has provided any.\n+        let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n+\n+        let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n+        let mut args = args_iter.clone().peekable();\n+\n+        // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+        // If we later encounter a lifetime, we know that the arguments were provided in the\n+        // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+        // inferred, so we can use it for diagnostics later.\n+        let mut force_infer_lt = None;\n+\n+        loop {\n+            // We're going to iterate through the generic arguments that the user\n+            // provided, matching them with the generic parameters we expect.\n+            // Mismatches can occur as a result of elided lifetimes, or for malformed\n+            // input. We try to handle both sensibly.\n+            match (args.peek(), params.peek()) {\n+                (Some(&arg), Some(&param)) => {\n+                    match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                        (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                        | (\n+                            GenericArg::Type(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Type { .. },\n+                            _,\n+                        )\n+                        | (\n+                            GenericArg::Const(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Const { .. },\n+                            _,\n+                        ) => {\n+                            substs.push(ctx.provided_kind(param, arg));\n+                            args.next();\n                             params.next();\n                         }\n-                    }\n-                }\n-            }\n-\n-            // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n-\n-            let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n-            let mut args = args_iter.clone().peekable();\n-\n-            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n-            // If we later encounter a lifetime, we know that the arguments were provided in the\n-            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n-            // inferred, so we can use it for diagnostics later.\n-            let mut force_infer_lt = None;\n-\n-            loop {\n-                // We're going to iterate through the generic arguments that the user\n-                // provided, matching them with the generic parameters we expect.\n-                // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                // input. We try to handle both sensibly.\n-                match (args.peek(), params.peek()) {\n-                    (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n-                            | (\n-                                GenericArg::Type(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Type { .. },\n-                                _,\n-                            )\n-                            | (\n-                                GenericArg::Const(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Const { .. },\n-                                _,\n-                            ) => {\n-                                substs.push(ctx.provided_kind(param, arg));\n-                                args.next();\n-                                params.next();\n-                            }\n-                            (\n-                                GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n-                                GenericParamDefKind::Lifetime,\n-                                _,\n-                            ) => {\n-                                // We expected a lifetime argument, but got a type or const\n-                                // argument. That means we're inferring the lifetimes.\n-                                substs.push(ctx.inferred_kind(None, param, infer_args));\n-                                force_infer_lt = Some((arg, param));\n-                                params.next();\n-                            }\n-                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n-                                // We've come across a lifetime when we expected something else in\n-                                // the presence of explicit late bounds. This is most likely\n-                                // due to the presence of the explicit bound so we're just going to\n-                                // ignore it.\n-                                args.next();\n-                            }\n-                            (_, _, _) => {\n-                                // We expected one kind of parameter, but the user provided\n-                                // another. This is an error. However, if we already know that\n-                                // the arguments don't match up with the parameters, we won't issue\n-                                // an additional error, as the user already knows what's wrong.\n-                                if arg_count.correct.is_ok() {\n-                                    // We're going to iterate over the parameters to sort them out, and\n-                                    // show that order to the user as a possible order for the parameters\n-                                    let mut param_types_present = defs\n-                                        .params\n-                                        .iter()\n-                                        .map(|param| (param.kind.to_ord(), param.clone()))\n-                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n-                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n-                                    let (mut param_types_present, ordered_params): (\n-                                        Vec<ParamKindOrd>,\n-                                        Vec<GenericParamDef>,\n-                                    ) = param_types_present.into_iter().unzip();\n-                                    param_types_present.dedup();\n-\n-                                    Self::generic_arg_mismatch_err(\n-                                        tcx,\n-                                        arg,\n-                                        param,\n-                                        !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n-                                        Some(&format!(\n-                                            \"reorder the arguments: {}: `<{}>`\",\n-                                            param_types_present\n-                                                .into_iter()\n-                                                .map(|ord| format!(\"{}s\", ord))\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", then \"),\n-                                            ordered_params\n-                                                .into_iter()\n-                                                .filter_map(|param| {\n-                                                    if param.name == kw::SelfUpper {\n-                                                        None\n-                                                    } else {\n-                                                        Some(param.name.to_string())\n-                                                    }\n-                                                })\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", \")\n-                                        )),\n-                                    );\n-                                }\n-\n-                                // We've reported the error, but we want to make sure that this\n-                                // problem doesn't bubble down and create additional, irrelevant\n-                                // errors. In this case, we're simply going to ignore the argument\n-                                // and any following arguments. The rest of the parameters will be\n-                                // inferred.\n-                                while args.next().is_some() {}\n-                            }\n+                        (\n+                            GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n+                            GenericParamDefKind::Lifetime,\n+                            _,\n+                        ) => {\n+                            // We expected a lifetime argument, but got a type or const\n+                            // argument. That means we're inferring the lifetimes.\n+                            substs.push(ctx.inferred_kind(None, param, infer_args));\n+                            force_infer_lt = Some((arg, param));\n+                            params.next();\n                         }\n-                    }\n-\n-                    (Some(&arg), None) => {\n-                        // We should never be able to reach this point with well-formed input.\n-                        // There are three situations in which we can encounter this issue.\n-                        //\n-                        //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it.\n-                        //  2.  There are late-bound lifetime parameters present, yet the\n-                        //      lifetime arguments have also been explicitly specified by the\n-                        //      user.\n-                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                        //      after a type or const). We want to throw an error in this case.\n-\n-                        if arg_count.correct.is_ok()\n-                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                        {\n-                            let kind = arg.descr();\n-                            assert_eq!(kind, \"lifetime\");\n-                            let (provided_arg, param) =\n-                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n+                        (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                            // We've come across a lifetime when we expected something else in\n+                            // the presence of explicit late bounds. This is most likely\n+                            // due to the presence of the explicit bound so we're just going to\n+                            // ignore it.\n+                            args.next();\n                         }\n+                        (_, _, _) => {\n+                            // We expected one kind of parameter, but the user provided\n+                            // another. This is an error. However, if we already know that\n+                            // the arguments don't match up with the parameters, we won't issue\n+                            // an additional error, as the user already knows what's wrong.\n+                            if arg_count.correct.is_ok() {\n+                                // We're going to iterate over the parameters to sort them out, and\n+                                // show that order to the user as a possible order for the parameters\n+                                let mut param_types_present = defs\n+                                    .params\n+                                    .iter()\n+                                    .map(|param| (param.kind.to_ord(), param.clone()))\n+                                    .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                let (mut param_types_present, ordered_params): (\n+                                    Vec<ParamKindOrd>,\n+                                    Vec<GenericParamDef>,\n+                                ) = param_types_present.into_iter().unzip();\n+                                param_types_present.dedup();\n+\n+                                generic_arg_mismatch_err(\n+                                    tcx,\n+                                    arg,\n+                                    param,\n+                                    !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n+                                    Some(&format!(\n+                                        \"reorder the arguments: {}: `<{}>`\",\n+                                        param_types_present\n+                                            .into_iter()\n+                                            .map(|ord| format!(\"{}s\", ord))\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", then \"),\n+                                        ordered_params\n+                                            .into_iter()\n+                                            .filter_map(|param| {\n+                                                if param.name == kw::SelfUpper {\n+                                                    None\n+                                                } else {\n+                                                    Some(param.name.to_string())\n+                                                }\n+                                            })\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", \")\n+                                    )),\n+                                );\n+                            }\n \n-                        break;\n+                            // We've reported the error, but we want to make sure that this\n+                            // problem doesn't bubble down and create additional, irrelevant\n+                            // errors. In this case, we're simply going to ignore the argument\n+                            // and any following arguments. The rest of the parameters will be\n+                            // inferred.\n+                            while args.next().is_some() {}\n+                        }\n                     }\n+                }\n \n-                    (None, Some(&param)) => {\n-                        // If there are fewer arguments than parameters, it means\n-                        // we're inferring the remaining arguments.\n-                        substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n-                        params.next();\n+                (Some(&arg), None) => {\n+                    // We should never be able to reach this point with well-formed input.\n+                    // There are three situations in which we can encounter this issue.\n+                    //\n+                    //  1.  The number of arguments is incorrect. In this case, an error\n+                    //      will already have been emitted, and we can ignore it.\n+                    //  2.  There are late-bound lifetime parameters present, yet the\n+                    //      lifetime arguments have also been explicitly specified by the\n+                    //      user.\n+                    //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n+                    //      after a type or const). We want to throw an error in this case.\n+\n+                    if arg_count.correct.is_ok()\n+                        && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                    {\n+                        let kind = arg.descr();\n+                        assert_eq!(kind, \"lifetime\");\n+                        let (provided_arg, param) =\n+                            force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                        generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n                     }\n \n-                    (None, None) => break,\n+                    break;\n+                }\n+\n+                (None, Some(&param)) => {\n+                    // If there are fewer arguments than parameters, it means\n+                    // we're inferring the remaining arguments.\n+                    substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n+                    params.next();\n                 }\n+\n+                (None, None) => break,\n             }\n         }\n-\n-        tcx.intern_substs(&substs)\n     }\n \n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// Used specifically for function calls.\n-    pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        generics: &ty::Generics,\n-        seg: &hir::PathSegment<'_>,\n-        is_method_call: IsMethodCall,\n-    ) -> GenericArgCountResult {\n-        let empty_args = hir::GenericArgs::none();\n-        let gen_args = seg.args.unwrap_or(&empty_args);\n-        let gen_pos = if is_method_call == IsMethodCall::Yes {\n-            GenericArgPosition::MethodCall\n+    tcx.intern_substs(&substs)\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// Used specifically for function calls.\n+pub fn check_generic_arg_count_for_call(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    generics: &ty::Generics,\n+    seg: &hir::PathSegment<'_>,\n+    is_method_call: IsMethodCall,\n+) -> GenericArgCountResult {\n+    let empty_args = hir::GenericArgs::none();\n+    let gen_args = seg.args.unwrap_or(&empty_args);\n+    let gen_pos = if is_method_call == IsMethodCall::Yes {\n+        GenericArgPosition::MethodCall\n+    } else {\n+        GenericArgPosition::Value\n+    };\n+    let has_self = generics.parent.is_none() && generics.has_self;\n+\n+    check_generic_arg_count(\n+        tcx,\n+        span,\n+        def_id,\n+        seg,\n+        generics,\n+        gen_args,\n+        gen_pos,\n+        has_self,\n+        seg.infer_args,\n+    )\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// This is used both for datatypes and function calls.\n+#[instrument(skip(tcx, gen_pos), level = \"debug\")]\n+pub(crate) fn check_generic_arg_count(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    seg: &hir::PathSegment<'_>,\n+    gen_params: &ty::Generics,\n+    gen_args: &hir::GenericArgs<'_>,\n+    gen_pos: GenericArgPosition,\n+    has_self: bool,\n+    infer_args: bool,\n+) -> GenericArgCountResult {\n+    let default_counts = gen_params.own_defaults();\n+    let param_counts = gen_params.own_counts();\n+\n+    // Subtracting from param count to ensure type params synthesized from `impl Trait`\n+    // cannot be explicitly specified.\n+    let synth_type_param_count = gen_params\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. }))\n+        .count();\n+    let named_type_param_count = param_counts.types - has_self as usize - synth_type_param_count;\n+    let infer_lifetimes =\n+        (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n+\n+    if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n+            prohibit_assoc_ty_binding(tcx, b.span);\n+        }\n+\n+    let explicit_late_bound =\n+        prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n+\n+    let mut invalid_args = vec![];\n+\n+    let mut check_lifetime_args = |min_expected_args: usize,\n+                                   max_expected_args: usize,\n+                                   provided_args: usize,\n+                                   late_bounds_ignore: bool| {\n+        if (min_expected_args..=max_expected_args).contains(&provided_args) {\n+            return Ok(());\n+        }\n+\n+        if late_bounds_ignore {\n+            return Ok(());\n+        }\n+\n+        if provided_args > max_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[max_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+        };\n+\n+        let gen_args_info = if provided_args > min_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[min_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided_args - min_expected_args;\n+            GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n         } else {\n-            GenericArgPosition::Value\n+            let num_missing_args = min_expected_args - provided_args;\n+            GenericArgsInfo::MissingLifetimes { num_missing_args }\n         };\n-        let has_self = generics.parent.is_none() && generics.has_self;\n \n-        Self::check_generic_arg_count(\n+        let reported = WrongNumberOfGenericArgs::new(\n             tcx,\n-            span,\n-            def_id,\n+            gen_args_info,\n             seg,\n-            generics,\n+            gen_params,\n+            has_self as usize,\n             gen_args,\n-            gen_pos,\n-            has_self,\n-            seg.infer_args,\n+            def_id,\n         )\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// This is used both for datatypes and function calls.\n-    #[instrument(skip(tcx, gen_pos), level = \"debug\")]\n-    pub(crate) fn check_generic_arg_count(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        seg: &hir::PathSegment<'_>,\n-        gen_params: &ty::Generics,\n-        gen_args: &hir::GenericArgs<'_>,\n-        gen_pos: GenericArgPosition,\n-        has_self: bool,\n-        infer_args: bool,\n-    ) -> GenericArgCountResult {\n-        let default_counts = gen_params.own_defaults();\n-        let param_counts = gen_params.own_counts();\n-\n-        // Subtracting from param count to ensure type params synthesized from `impl Trait`\n-        // cannot be explicitly specified.\n-        let synth_type_param_count = gen_params\n-            .params\n-            .iter()\n-            .filter(|param| {\n-                matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. })\n-            })\n-            .count();\n-        let named_type_param_count =\n-            param_counts.types - has_self as usize - synth_type_param_count;\n-        let infer_lifetimes =\n-            (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n-\n-        if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n-            Self::prohibit_assoc_ty_binding(tcx, b.span);\n+        .diagnostic()\n+        .emit();\n+\n+        Err(reported)\n+    };\n+\n+    let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n+    let max_expected_lifetime_args = param_counts.lifetimes;\n+    let num_provided_lifetime_args = gen_args.num_lifetime_params();\n+\n+    let lifetimes_correct = check_lifetime_args(\n+        min_expected_lifetime_args,\n+        max_expected_lifetime_args,\n+        num_provided_lifetime_args,\n+        explicit_late_bound == ExplicitLateBound::Yes,\n+    );\n+\n+    let mut check_types_and_consts = |expected_min,\n+                                      expected_max,\n+                                      expected_max_with_synth,\n+                                      provided,\n+                                      params_offset,\n+                                      args_offset| {\n+        debug!(\n+            ?expected_min,\n+            ?expected_max,\n+            ?provided,\n+            ?params_offset,\n+            ?args_offset,\n+            \"check_types_and_consts\"\n+        );\n+        if (expected_min..=expected_max).contains(&provided) {\n+            return Ok(());\n         }\n \n-        let explicit_late_bound =\n-            Self::prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n-\n-        let mut invalid_args = vec![];\n+        let num_default_params = expected_max - expected_min;\n \n-        let mut check_lifetime_args =\n-            |min_expected_args: usize,\n-             max_expected_args: usize,\n-             provided_args: usize,\n-             late_bounds_ignore: bool| {\n-                if (min_expected_args..=max_expected_args).contains(&provided_args) {\n-                    return Ok(());\n-                }\n-\n-                if late_bounds_ignore {\n-                    return Ok(());\n-                }\n+        let gen_args_info = if provided > expected_max {\n+            invalid_args.extend(\n+                gen_args.args[args_offset + expected_max..args_offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided - expected_max;\n \n-                if provided_args > max_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[max_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                };\n-\n-                let gen_args_info = if provided_args > min_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[min_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                    let num_redundant_args = provided_args - min_expected_args;\n-                    GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n-                } else {\n-                    let num_missing_args = min_expected_args - provided_args;\n-                    GenericArgsInfo::MissingLifetimes { num_missing_args }\n-                };\n-\n-                let reported = WrongNumberOfGenericArgs::new(\n-                    tcx,\n-                    gen_args_info,\n-                    seg,\n-                    gen_params,\n-                    has_self as usize,\n-                    gen_args,\n-                    def_id,\n-                )\n-                .diagnostic()\n-                .emit();\n-\n-                Err(reported)\n-            };\n-\n-        let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n-        let max_expected_lifetime_args = param_counts.lifetimes;\n-        let num_provided_lifetime_args = gen_args.num_lifetime_params();\n-\n-        let lifetimes_correct = check_lifetime_args(\n-            min_expected_lifetime_args,\n-            max_expected_lifetime_args,\n-            num_provided_lifetime_args,\n-            explicit_late_bound == ExplicitLateBound::Yes,\n-        );\n+            // Provide extra note if synthetic arguments like `impl Trait` are specified.\n+            let synth_provided = provided <= expected_max_with_synth;\n \n-        let mut check_types_and_consts = |expected_min,\n-                                          expected_max,\n-                                          expected_max_with_synth,\n-                                          provided,\n-                                          params_offset,\n-                                          args_offset| {\n-            debug!(\n-                ?expected_min,\n-                ?expected_max,\n-                ?provided,\n-                ?params_offset,\n-                ?args_offset,\n-                \"check_types_and_consts\"\n-            );\n-            if (expected_min..=expected_max).contains(&provided) {\n-                return Ok(());\n+            GenericArgsInfo::ExcessTypesOrConsts {\n+                num_redundant_args,\n+                num_default_params,\n+                args_offset,\n+                synth_provided,\n             }\n+        } else {\n+            let num_missing_args = expected_max - provided;\n \n-            let num_default_params = expected_max - expected_min;\n-\n-            let gen_args_info = if provided > expected_max {\n-                invalid_args.extend(\n-                    gen_args.args[args_offset + expected_max..args_offset + provided]\n-                        .iter()\n-                        .map(|arg| arg.span()),\n-                );\n-                let num_redundant_args = provided - expected_max;\n+            GenericArgsInfo::MissingTypesOrConsts {\n+                num_missing_args,\n+                num_default_params,\n+                args_offset,\n+            }\n+        };\n \n-                // Provide extra note if synthetic arguments like `impl Trait` are specified.\n-                let synth_provided = provided <= expected_max_with_synth;\n+        debug!(?gen_args_info);\n \n-                GenericArgsInfo::ExcessTypesOrConsts {\n-                    num_redundant_args,\n-                    num_default_params,\n-                    args_offset,\n-                    synth_provided,\n-                }\n-            } else {\n-                let num_missing_args = expected_max - provided;\n+        let reported = WrongNumberOfGenericArgs::new(\n+            tcx,\n+            gen_args_info,\n+            seg,\n+            gen_params,\n+            params_offset,\n+            gen_args,\n+            def_id,\n+        )\n+        .diagnostic()\n+        .emit_unless(gen_args.has_err());\n \n-                GenericArgsInfo::MissingTypesOrConsts {\n-                    num_missing_args,\n-                    num_default_params,\n-                    args_offset,\n-                }\n-            };\n-\n-            debug!(?gen_args_info);\n-\n-            let reported = WrongNumberOfGenericArgs::new(\n-                tcx,\n-                gen_args_info,\n-                seg,\n-                gen_params,\n-                params_offset,\n-                gen_args,\n-                def_id,\n-            )\n-            .diagnostic()\n-            .emit_unless(gen_args.has_err());\n-\n-            Err(reported)\n-        };\n+        Err(reported)\n+    };\n \n-        let args_correct = {\n-            let expected_min = if infer_args {\n-                0\n-            } else {\n-                param_counts.consts + named_type_param_count\n-                    - default_counts.types\n-                    - default_counts.consts\n-            };\n-            debug!(?expected_min);\n-            debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n-\n-            check_types_and_consts(\n-                expected_min,\n-                param_counts.consts + named_type_param_count,\n-                param_counts.consts + named_type_param_count + synth_type_param_count,\n-                gen_args.num_generic_params(),\n-                param_counts.lifetimes + has_self as usize,\n-                gen_args.num_lifetime_params(),\n-            )\n+    let args_correct = {\n+        let expected_min = if infer_args {\n+            0\n+        } else {\n+            param_counts.consts + named_type_param_count\n+                - default_counts.types\n+                - default_counts.consts\n         };\n+        debug!(?expected_min);\n+        debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n+\n+        check_types_and_consts(\n+            expected_min,\n+            param_counts.consts + named_type_param_count,\n+            param_counts.consts + named_type_param_count + synth_type_param_count,\n+            gen_args.num_generic_params(),\n+            param_counts.lifetimes + has_self as usize,\n+            gen_args.num_lifetime_params(),\n+        )\n+    };\n \n-        GenericArgCountResult {\n-            explicit_late_bound,\n-            correct: lifetimes_correct.and(args_correct).map_err(|reported| {\n-                GenericArgCountMismatch { reported: Some(reported), invalid_args }\n-            }),\n-        }\n+    GenericArgCountResult {\n+        explicit_late_bound,\n+        correct: lifetimes_correct\n+            .and(args_correct)\n+            .map_err(|reported| GenericArgCountMismatch { reported: Some(reported), invalid_args }),\n     }\n+}\n \n-    /// Emits an error regarding forbidden type binding associations\n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n-    }\n+/// Emits an error regarding forbidden type binding associations\n+pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n+}\n \n-    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n-    /// are present. This is used both for datatypes and function calls.\n-    pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n-        tcx: TyCtxt<'_>,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-    ) -> ExplicitLateBound {\n-        let param_counts = def.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n-\n-        if infer_lifetimes {\n-            return ExplicitLateBound::No;\n-        }\n+/// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+/// are present. This is used both for datatypes and function calls.\n+pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n+    tcx: TyCtxt<'_>,\n+    def: &ty::Generics,\n+    args: &hir::GenericArgs<'_>,\n+    position: GenericArgPosition,\n+) -> ExplicitLateBound {\n+    let param_counts = def.own_counts();\n+    let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n+\n+    if infer_lifetimes {\n+        return ExplicitLateBound::No;\n+    }\n \n-        if let Some(span_late) = def.has_late_bound_regions {\n-            let msg = \"cannot specify lifetime arguments explicitly \\\n+    if let Some(span_late) = def.has_late_bound_regions {\n+        let msg = \"cannot specify lifetime arguments explicitly \\\n                        if late bound lifetime parameters are present\";\n-            let note = \"the late bound lifetime parameter is introduced here\";\n-            let span = args.args[0].span();\n-\n-            if position == GenericArgPosition::Value\n-                && args.num_lifetime_params() != param_counts.lifetimes\n-            {\n-                let mut err = tcx.sess.struct_span_err(span, msg);\n-                err.span_note(span_late, note);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(span);\n-                multispan.push_span_label(span_late, note);\n-                tcx.struct_span_lint_hir(\n-                    LATE_BOUND_LIFETIME_ARGUMENTS,\n-                    args.args[0].hir_id(),\n-                    multispan,\n-                    msg,\n-                    |lint| lint,\n-                );\n-            }\n-\n-            ExplicitLateBound::Yes\n+        let note = \"the late bound lifetime parameter is introduced here\";\n+        let span = args.args[0].span();\n+\n+        if position == GenericArgPosition::Value\n+            && args.num_lifetime_params() != param_counts.lifetimes\n+        {\n+            let mut err = tcx.sess.struct_span_err(span, msg);\n+            err.span_note(span_late, note);\n+            err.emit();\n         } else {\n-            ExplicitLateBound::No\n+            let mut multispan = MultiSpan::from_span(span);\n+            multispan.push_span_label(span_late, note);\n+            tcx.struct_span_lint_hir(\n+                LATE_BOUND_LIFETIME_ARGUMENTS,\n+                args.args[0].hir_id(),\n+                multispan,\n+                msg,\n+                |lint| lint,\n+            );\n         }\n+\n+        ExplicitLateBound::Yes\n+    } else {\n+        ExplicitLateBound::No\n     }\n }"}, {"sha": "9fa0e6e8eaa646d396ca2049b9fc69c59587862e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=d642781708801d1227bb76deca803fda43ff8b37", "patch": "@@ -3,8 +3,11 @@\n //! instance of `AstConv`.\n \n mod errors;\n-mod generics;\n+pub mod generics;\n \n+use crate::astconv::generics::{\n+    check_generic_arg_count, create_substs_for_generic_args, prohibit_assoc_ty_binding,\n+};\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n@@ -286,7 +289,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         substs\n@@ -356,7 +359,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none());\n         }\n \n-        let arg_count = Self::check_generic_arg_count(\n+        let arg_count = check_generic_arg_count(\n             tcx,\n             span,\n             def_id,\n@@ -531,7 +534,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             inferred_params: vec![],\n             infer_args,\n         };\n-        let substs = Self::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             tcx,\n             def_id,\n             parent_substs,\n@@ -617,7 +620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         args\n@@ -811,7 +814,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n@@ -2308,7 +2311,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let Some(b) = segment.args().bindings.first() {\n-                Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+                prohibit_assoc_ty_binding(self.tcx(), b.span);\n                 return true;\n             }\n         }"}, {"sha": "8570715b41e59060d6ad2cbbb6e6aec20162c267", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=d642781708801d1227bb76deca803fda43ff8b37", "patch": "@@ -10,6 +10,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{\n     AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, IsMethodCall, PathSeg,\n@@ -1067,7 +1070,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            let arg_count = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+            let arg_count = check_generic_arg_count_for_call(\n                 tcx,\n                 span,\n                 def_id,\n@@ -1233,7 +1236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let substs_raw = self_ctor_substs.unwrap_or_else(|| {\n-            <dyn AstConv<'_>>::create_substs_for_generic_args(\n+            create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[],"}, {"sha": "4a33a791e1b7f3b12db9c6e54ca541ab93b5c0fa", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d642781708801d1227bb76deca803fda43ff8b37/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=d642781708801d1227bb76deca803fda43ff8b37", "patch": "@@ -4,6 +4,9 @@ use crate::{callee, FnCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n@@ -331,7 +334,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // variables.\n         let generics = self.tcx.generics_of(pick.item.def_id);\n \n-        let arg_count_correct = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+        let arg_count_correct = check_generic_arg_count_for_call(\n             self.tcx,\n             self.span,\n             pick.item.def_id,\n@@ -398,7 +401,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             }\n         }\n \n-        let substs = <dyn AstConv<'_>>::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,"}]}