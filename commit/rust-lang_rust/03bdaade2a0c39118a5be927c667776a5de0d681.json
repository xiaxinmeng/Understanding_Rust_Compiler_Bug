{"sha": "03bdaade2a0c39118a5be927c667776a5de0d681", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYmRhYWRlMmEwYzM5MTE4YTViZTkyN2M2Njc3NzZhNWRlMGQ2ODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-27T23:06:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-27T23:06:58Z"}, "message": "Auto merge of #38022 - arthurprs:micro-opt-hm, r=bluss\n\nUse displacement instead of initial bucket in HashMap code\n\nUse displacement instead of initial bucket in HashMap code. It makes the code a bit cleaner and also saves a few instructions (handy since it'll be using some to do some sort of adaptive behavior soon).", "tree": {"sha": "132ab6db18a9ecfb2ec973731d3d3f73c028d9d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/132ab6db18a9ecfb2ec973731d3d3f73c028d9d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03bdaade2a0c39118a5be927c667776a5de0d681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03bdaade2a0c39118a5be927c667776a5de0d681", "html_url": "https://github.com/rust-lang/rust/commit/03bdaade2a0c39118a5be927c667776a5de0d681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03bdaade2a0c39118a5be927c667776a5de0d681/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ca50bd4d50b55456e88a8c3ad8fcc9798f57522", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca50bd4d50b55456e88a8c3ad8fcc9798f57522", "html_url": "https://github.com/rust-lang/rust/commit/9ca50bd4d50b55456e88a8c3ad8fcc9798f57522"}, {"sha": "178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "html_url": "https://github.com/rust-lang/rust/commit/178e29df7d2927641ddbadaaa92e1f1c17fa5c92"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "f102a1bf6307bff2080338b5bac48f6a3306763f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/03bdaade2a0c39118a5be927c667776a5de0d681/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bdaade2a0c39118a5be927c667776a5de0d681/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=03bdaade2a0c39118a5be927c667776a5de0d681", "patch": "@@ -371,9 +371,9 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n         return InternalEntry::TableIsEmpty;\n     }\n \n-    let size = table.size() as isize;\n+    let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index() as isize;\n+    let mut displacement = 0;\n \n     loop {\n         let full = match probe.peek() {\n@@ -387,15 +387,15 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n             Full(bucket) => bucket,\n         };\n \n-        let robin_ib = full.index() as isize - full.displacement() as isize;\n+        let probe_displacement = full.displacement();\n \n-        if ib < robin_ib {\n+        if probe_displacement < displacement {\n             // Found a luckier bucket than me.\n             // We can finish the search early if we hit any bucket\n             // with a lower distance to initial bucket than we've probed.\n             return InternalEntry::Vacant {\n                 hash: hash,\n-                elem: NeqElem(full, robin_ib as usize),\n+                elem: NeqElem(full, probe_displacement),\n             };\n         }\n \n@@ -406,9 +406,9 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n                 return InternalEntry::Occupied { elem: full };\n             }\n         }\n-\n+        displacement += 1;\n         probe = full.next();\n-        debug_assert!(probe.index() as isize != ib + size + 1);\n+        debug_assert!(displacement <= size);\n     }\n }\n \n@@ -431,12 +431,11 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n-/// also pass the position of that bucket's initial bucket so we don't have\n-/// to recalculate it.\n+/// also pass that bucket's displacement so we don't have to recalculate it.\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n-                                mut ib: usize,\n+                                mut displacement: usize,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n@@ -457,6 +456,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n         val = old_val;\n \n         loop {\n+            displacement += 1;\n             let probe = bucket.next();\n             debug_assert!(probe.index() != idx_end);\n \n@@ -476,13 +476,13 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                 Full(bucket) => bucket,\n             };\n \n-            let probe_ib = full_bucket.index() - full_bucket.displacement();\n+            let probe_displacement = full_bucket.displacement();\n \n             bucket = full_bucket;\n \n             // Robin hood! Steal the spot.\n-            if ib < probe_ib {\n-                ib = probe_ib;\n+            if probe_displacement < displacement {\n+                displacement = probe_displacement;\n                 break;\n             }\n         }\n@@ -520,13 +520,16 @@ impl<K, V, S> HashMap<K, V, S>\n         search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n     }\n \n-    // The caller should ensure that invariants by Robin Hood Hashing hold.\n+    // The caller should ensure that invariants by Robin Hood Hashing hold\n+    // and that there's space in the underlying table.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n         let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n-        let ib = buckets.index();\n+        // note that buckets.index() keeps increasing\n+        // even if the pointer wraps back to the first bucket.\n+        let limit_bucket = buckets.index() + raw_cap;\n \n-        while buckets.index() != ib + raw_cap {\n+        loop {\n             // We don't need to compare hashes for value swap.\n             // Not even DIBs for Robin Hood.\n             buckets = match buckets.peek() {\n@@ -537,8 +540,8 @@ impl<K, V, S> HashMap<K, V, S>\n                 Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n+            debug_assert!(buckets.index() < limit_bucket);\n         }\n-        panic!(\"Internal HashMap error: Out of space.\");\n     }\n }\n \n@@ -1959,7 +1962,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n-            NeqElem(bucket, ib) => robin_hood(bucket, ib, self.hash, self.key, value),\n+            NeqElem(bucket, disp) => robin_hood(bucket, disp, self.hash, self.key, value),\n             NoElem(bucket) => bucket.put(self.hash, self.key, value).into_mut_refs().1,\n         }\n     }"}]}