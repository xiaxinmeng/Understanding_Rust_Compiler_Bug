{"sha": "3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "node_id": "C_kwDOAAsO6NoAKDNlNTk2NTcyMmNhNDZiODJjYzY4Y2IxYWNkZGRmN2UxODdhNmVlMDI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-18T13:13:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-18T13:13:35Z"}, "message": "Rollup merge of #101162 - rajputrajat:master, r=davidtwco\n\nMigrate rustc_resolve to use SessionDiagnostic, part # 1\n\ncrate a somewhat on larger size, so plz allow some time to get it finished.", "tree": {"sha": "a668bca64fad76a42acd29499e480c216e30f37d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a668bca64fad76a42acd29499e480c216e30f37d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjd4T/CRBK7hj4Ov3rIwAA+ZYIACl0V3XK5i5sQ/pVMqHa4Q1z\nQHDA3qzmXI6aajoefgeXT6cez86KDhppE4wfBHLVekb/ydn+k3pe6F7oP4MCpqkT\nNHMmaDBrqMQvsU1uYkDuTo62/VK0BmaoFw/nt5GNblvpbNxrZTu99v4tv9ORo4u0\nnASWmxkUARgwpzfw3SkAvWmpQkjzk57xTSvwHscwIJRn+TT3nR3zSw8s0l/RsE79\no3Tlw84OiNReFkjgEsrUjlimTI4GQwhOXgxcLQdH8mw8CEU/zF0stpWDKjS0OqRW\n3PsI6m9PiJU+UN5UuiQZ+JfgEBSuGpV5iCIyo7s2FLFA7ral/fM2F1+f6zifWKQ=\n=FZzI\n-----END PGP SIGNATURE-----\n", "payload": "tree a668bca64fad76a42acd29499e480c216e30f37d\nparent 9d46c7a3e69966782e163877151c1f0cea8b630a\nparent 269ce369fee929cf72a75ddbd4f640fd544756d3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668777215 +0100\ncommitter GitHub <noreply@github.com> 1668777215 +0100\n\nRollup merge of #101162 - rajputrajat:master, r=davidtwco\n\nMigrate rustc_resolve to use SessionDiagnostic, part # 1\n\ncrate a somewhat on larger size, so plz allow some time to get it finished.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "html_url": "https://github.com/rust-lang/rust/commit/3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d46c7a3e69966782e163877151c1f0cea8b630a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d46c7a3e69966782e163877151c1f0cea8b630a", "html_url": "https://github.com/rust-lang/rust/commit/9d46c7a3e69966782e163877151c1f0cea8b630a"}, {"sha": "269ce369fee929cf72a75ddbd4f640fd544756d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/269ce369fee929cf72a75ddbd4f640fd544756d3", "html_url": "https://github.com/rust-lang/rust/commit/269ce369fee929cf72a75ddbd4f640fd544756d3"}], "stats": {"total": 1248, "additions": 885, "deletions": 363}, "files": [{"sha": "31edb773fc0ad1d8f51ad8ad7c3290638eb71527", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -4045,6 +4045,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_query_system\","}, {"sha": "817bb83ed786a6ed3a8267397b5bc0e958da03d1", "filename": "compiler/rustc_error_messages/locales/en-US/resolve.ftl", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fresolve.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fresolve.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fresolve.ftl?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -0,0 +1,211 @@\n+resolve_parent_module_reset_for_binding =\n+    parent module is reset for binding\n+\n+resolve_ampersand_used_without_explicit_lifetime_name =\n+    `&` without an explicit lifetime name cannot be used here\n+    .note = explicit lifetime name needed here\n+\n+resolve_underscore_lifetime_name_cannot_be_used_here =\n+    `'_` cannot be used here\n+    .note = `'_` is a reserved lifetime name\n+\n+resolve_crate_may_not_be_imported =\n+    `$crate` may not be imported\n+\n+resolve_crate_root_imports_must_be_named_explicitly =\n+    crate root imports need to be explicitly named: `use crate as name;`\n+\n+resolve_generic_params_from_outer_function =\n+    can't use generic parameters from outer function\n+    .label = use of generic parameter from outer function\n+    .suggestion = try using a local generic parameter instead\n+\n+resolve_self_type_implicitly_declared_by_impl =\n+    `Self` type implicitly declared here, by this `impl`\n+\n+resolve_cannot_use_self_type_here =\n+    can't use `Self` here\n+\n+resolve_use_a_type_here_instead =\n+    use a type here instead\n+\n+resolve_type_param_from_outer_fn =\n+    type parameter from outer function\n+\n+resolve_const_param_from_outer_fn =\n+    const parameter from outer function\n+\n+resolve_try_using_local_generic_parameter =\n+    try using a local generic parameter instead\n+\n+resolve_try_adding_local_generic_param_on_method =\n+    try adding a local generic parameter in this method instead\n+\n+resolve_help_try_using_local_generic_param =\n+    try using a local generic paramter instead\n+\n+resolve_name_is_already_used_as_generic_parameter =\n+    the name `{$name}` is already used for a generic parameter in this item's generic parameters\n+    .label = already used\n+    .first_use_of_name = first use of `{$name}`\n+\n+resolve_method_not_member_of_trait =\n+    method `{$method}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n+\n+resolve_associated_fn_with_similar_name_exists =\n+    there is an associated function with a similar name\n+\n+resolve_type_not_member_of_trait =\n+    type `{$type_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n+\n+resolve_associated_type_with_similar_name_exists =\n+    there is an associated type with a similar name\n+\n+resolve_const_not_member_of_trait =\n+    const `{$const_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n+\n+resolve_associated_const_with_similar_name_exists =\n+    there is an associated constant with a similar name\n+\n+resolve_variable_bound_with_different_mode =\n+    variable `{$variable_name}` is bound inconsistently across alternatives separated by `|`\n+    .label = bound in different ways\n+    .first_binding_span = first binding\n+\n+resolve_ident_bound_more_than_once_in_parameter_list =\n+    identifier `{$identifier}` is bound more than once in this parameter list\n+    .label = used as parameter more than once\n+\n+resolve_ident_bound_more_than_once_in_same_pattern =\n+    identifier `{$identifier}` is bound more than once in the same pattern\n+    .label = used in a pattern more than once\n+\n+resolve_undeclared_label =\n+    use of undeclared label `{$name}`\n+    .label = undeclared label `{$name}`\n+\n+resolve_label_with_similar_name_reachable =\n+    a label with a similar name is reachable\n+\n+resolve_try_using_similarly_named_label =\n+    try using similarly named label\n+\n+resolve_unreachable_label_with_similar_name_exists =\n+    a label with a similar name exists but is unreachable\n+\n+resolve_self_import_can_only_appear_once_in_the_list =\n+    `self` import can only appear once in an import list\n+    .label = can only appear once in an import list\n+\n+resolve_self_import_only_in_import_list_with_non_empty_prefix =\n+    `self` import can only appear in an import list with a non-empty prefix\n+    .label = can only appear in an import list with a non-empty prefix\n+\n+resolve_cannot_capture_dynamic_environment_in_fn_item =\n+    can't capture dynamic environment in a fn item\n+    .help = use the `|| {\"{\"} ... {\"}\"}` closure form instead\n+\n+resolve_attempt_to_use_non_constant_value_in_constant =\n+    attempt to use a non-constant value in a constant\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion =\n+    consider using `{$suggestion}` instead of `{$current}`\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion =\n+    non-constant value\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion =\n+    this would need to be a `{$suggestion}`\n+\n+resolve_self_imports_only_allowed_within =\n+    `self` imports are only allowed within a {\"{\"} {\"}\"} list\n+\n+resolve_self_imports_only_allowed_within_suggestion =\n+    consider importing the module directly\n+\n+resolve_self_imports_only_allowed_within_multipart_suggestion =\n+    alternatively, use the multi-path `use` syntax to import `self`\n+\n+resolve_binding_shadows_something_unacceptable =\n+    {$shadowing_binding}s cannot shadow {$shadowed_binding}s\n+    .label = cannot be named the same as {$article} {$shadowed_binding}\n+    .label_shadowed_binding = the {$shadowed_binding} `{$name}` is {$participle} here\n+\n+resolve_binding_shadows_something_unacceptable_suggestion =\n+    try specify the pattern arguments\n+\n+resolve_forward_declared_generic_param =\n+    generic parameters with a default cannot use forward declared identifiers\n+    .label = defaulted generic parameters cannot be forward declared\n+\n+resolve_param_in_ty_of_const_param =\n+    the type of const parameters must not depend on other generic parameters\n+    .label = the type must not depend on the parameter `{$name}`\n+\n+resolve_self_in_generic_param_default =\n+    generic parameters cannot use `Self` in their defaults\n+    .label = `Self` in generic parameter default\n+\n+resolve_param_in_non_trivial_anon_const =\n+    generic parameters may not be used in const operations\n+    .label = cannot perform const operation using `{$name}`\n+\n+resolve_param_in_non_trivial_anon_const_help =\n+    use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+\n+resolve_param_in_non_trivial_anon_const_sub_type =\n+    type parameters may not be used in const expressions\n+\n+resolve_param_in_non_trivial_anon_const_sub_non_type =\n+    const parameters may only be used as standalone arguments, i.e. `{$name}`\n+\n+resolve_unreachable_label =\n+    use of unreachable label `{$name}`\n+    .label = unreachable label `{$name}`\n+    .label_definition_span = unreachable label defined here\n+    .note = labels are unreachable through functions, closures, async blocks and modules\n+\n+resolve_unreachable_label_suggestion_use_similarly_named =\n+    try using similarly named label\n+\n+resolve_unreachable_label_similar_name_reachable =\n+    a label with a similar name is reachable\n+\n+resolve_unreachable_label_similar_name_unreachable =\n+    a label with a similar name exists but is also unreachable\n+\n+resolve_trait_impl_mismatch =\n+    item `{$name}` is an associated {$kind}, which doesn't match its trait `{$trait_path}`\n+    .label = does not match trait\n+    .label_trait_item = item in trait\n+\n+resolve_invalid_asm_sym =\n+    invalid `sym` operand\n+    .label = is a local variable\n+    .help = `sym` operands must refer to either a function or a static\n+\n+resolve_trait_impl_duplicate =\n+    duplicate definitions with name `{$name}`:\n+    .label = duplicate definition\n+    .old_span_label = previous definition here\n+    .trait_item_span = item in trait\n+\n+resolve_relative_2018 =\n+    relative paths are not supported in visibilities in 2018 edition or later\n+    .suggestion = try\n+\n+resolve_ancestor_only =\n+    visibilities can only be restricted to ancestor modules\n+\n+resolve_expected_found =\n+    expected module, found {$res} `{$path_str}`\n+    .label = not a module\n+\n+resolve_indeterminate =\n+    cannot determine resolution for the visibility\n+\n+resolve_module_only =\n+    visibility must resolve to a module"}, {"sha": "9c71f0906b5ec3fa976c8a2b585a5ee6d4f03ea0", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -63,6 +63,7 @@ fluent_messages! {\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     query_system => \"../locales/en-US/query_system.ftl\",\n+    resolve => \"../locales/en-US/resolve.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     session => \"../locales/en-US/session.ftl\",\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\","}, {"sha": "ee68344805f4c34534d23d21cb3674c06a6fcd24", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -211,6 +211,12 @@ impl IntoDiagnosticArg for DiagnosticSymbolList {\n     }\n }\n \n+impl<Id> IntoDiagnosticArg for hir::def::Res<Id> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.descr()))\n+    }\n+}\n+\n impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag;"}, {"sha": "8f14efd6b8315229e762030c0715145f996cbb70", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -19,6 +19,7 @@ rustc_expand = { path = \"../rustc_expand\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "a95607656ffca345f195369a78db399c89532b4f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 182, "deletions": 362, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -26,6 +26,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};\n \n+use crate::errors as errs;\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::late::{PatternSource, Rib};\n use crate::path_names_to_string;\n@@ -597,78 +598,41 @@ impl<'a> Resolver<'a> {\n \n                 err\n             }\n-            ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0403,\n-                    \"the name `{}` is already used for a generic \\\n-                     parameter in this item's generic parameters\",\n-                    name,\n-                );\n-                err.span_label(span, \"already used\");\n-                err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n-                err\n-            }\n+            ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => self\n+                .session\n+                .create_err(errs::NameAlreadyUsedInParameterList { span, first_use_span, name }),\n             ResolutionError::MethodNotMemberOfTrait(method, trait_, candidate) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::MethodNotMemberOfTrait {\n                     span,\n-                    E0407,\n-                    \"method `{}` is not a member of trait `{}`\",\n                     method,\n-                    trait_\n-                );\n-                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-                if let Some(candidate) = candidate {\n-                    err.span_suggestion(\n-                        method.span,\n-                        \"there is an associated function with a similar name\",\n-                        candidate.to_ident_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err\n+                    trait_,\n+                    sub: candidate.map(|c| errs::AssociatedFnWithSimilarNameExists {\n+                        span: method.span,\n+                        candidate: c,\n+                    }),\n+                })\n             }\n             ResolutionError::TypeNotMemberOfTrait(type_, trait_, candidate) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::TypeNotMemberOfTrait {\n                     span,\n-                    E0437,\n-                    \"type `{}` is not a member of trait `{}`\",\n                     type_,\n-                    trait_\n-                );\n-                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-                if let Some(candidate) = candidate {\n-                    err.span_suggestion(\n-                        type_.span,\n-                        \"there is an associated type with a similar name\",\n-                        candidate.to_ident_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err\n+                    trait_,\n+                    sub: candidate.map(|c| errs::AssociatedTypeWithSimilarNameExists {\n+                        span: type_.span,\n+                        candidate: c,\n+                    }),\n+                })\n             }\n             ResolutionError::ConstNotMemberOfTrait(const_, trait_, candidate) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::ConstNotMemberOfTrait {\n                     span,\n-                    E0438,\n-                    \"const `{}` is not a member of trait `{}`\",\n                     const_,\n-                    trait_\n-                );\n-                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-                if let Some(candidate) = candidate {\n-                    err.span_suggestion(\n-                        const_.span,\n-                        \"there is an associated constant with a similar name\",\n-                        candidate.to_ident_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err\n+                    trait_,\n+                    sub: candidate.map(|c| errs::AssociatedConstWithSimilarNameExists {\n+                        span: const_.span,\n+                        candidate: c,\n+                    }),\n+                })\n             }\n             ResolutionError::VariableNotBoundInPattern(binding_error, parent_scope) => {\n                 let BindingError { name, target, origin, could_be_path } = binding_error;\n@@ -730,128 +694,78 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name, first_binding_span) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0409,\n-                    \"variable `{}` is bound inconsistently across alternatives separated by `|`\",\n-                    variable_name\n-                );\n-                err.span_label(span, \"bound in different ways\");\n-                err.span_label(first_binding_span, \"first binding\");\n-                err\n-            }\n-            ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0415,\n-                    \"identifier `{}` is bound more than once in this parameter list\",\n-                    identifier\n-                );\n-                err.span_label(span, \"used as parameter more than once\");\n-                err\n-            }\n-            ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::VariableBoundWithDifferentMode {\n                     span,\n-                    E0416,\n-                    \"identifier `{}` is bound more than once in the same pattern\",\n-                    identifier\n-                );\n-                err.span_label(span, \"used in a pattern more than once\");\n-                err\n-            }\n+                    first_binding_span,\n+                    variable_name,\n+                })\n+            }\n+            ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => self\n+                .session\n+                .create_err(errs::IdentifierBoundMoreThanOnceInParameterList { span, identifier }),\n+            ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => self\n+                .session\n+                .create_err(errs::IdentifierBoundMoreThanOnceInSamePattern { span, identifier }),\n             ResolutionError::UndeclaredLabel { name, suggestion } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0426,\n-                    \"use of undeclared label `{}`\",\n-                    name\n-                );\n-\n-                err.span_label(span, format!(\"undeclared label `{}`\", name));\n-\n-                match suggestion {\n+                let ((sub_reachable, sub_reachable_suggestion), sub_unreachable) = match suggestion\n+                {\n                     // A reachable label with a similar name exists.\n-                    Some((ident, true)) => {\n-                        err.span_label(ident.span, \"a label with a similar name is reachable\");\n-                        err.span_suggestion(\n-                            span,\n-                            \"try using similarly named label\",\n-                            ident.name,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                    Some((ident, true)) => (\n+                        (\n+                            Some(errs::LabelWithSimilarNameReachable(ident.span)),\n+                            Some(errs::TryUsingSimilarlyNamedLabel {\n+                                span,\n+                                ident_name: ident.name,\n+                            }),\n+                        ),\n+                        None,\n+                    ),\n                     // An unreachable label with a similar name exists.\n-                    Some((ident, false)) => {\n-                        err.span_label(\n-                            ident.span,\n-                            \"a label with a similar name exists but is unreachable\",\n-                        );\n-                    }\n+                    Some((ident, false)) => (\n+                        (None, None),\n+                        Some(errs::UnreachableLabelWithSimilarNameExists {\n+                            ident_span: ident.span,\n+                        }),\n+                    ),\n                     // No similarly-named labels exist.\n-                    None => (),\n-                }\n-\n-                err\n+                    None => ((None, None), None),\n+                };\n+                self.session.create_err(errs::UndeclaredLabel {\n+                    span,\n+                    name,\n+                    sub_reachable,\n+                    sub_reachable_suggestion,\n+                    sub_unreachable,\n+                })\n             }\n             ResolutionError::SelfImportsOnlyAllowedWithin { root, span_with_rename } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0429,\n-                    \"{}\",\n-                    \"`self` imports are only allowed within a { } list\"\n-                );\n-\n                 // None of the suggestions below would help with a case like `use self`.\n-                if !root {\n+                let (suggestion, mpart_suggestion) = if root {\n+                    (None, None)\n+                } else {\n                     // use foo::bar::self        -> foo::bar\n                     // use foo::bar::self as abc -> foo::bar as abc\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider importing the module directly\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    let suggestion = errs::SelfImportsOnlyAllowedWithinSuggestion { span };\n \n                     // use foo::bar::self        -> foo::bar::{self}\n                     // use foo::bar::self as abc -> foo::bar::{self as abc}\n-                    let braces = vec![\n-                        (span_with_rename.shrink_to_lo(), \"{\".to_string()),\n-                        (span_with_rename.shrink_to_hi(), \"}\".to_string()),\n-                    ];\n-                    err.multipart_suggestion(\n-                        \"alternatively, use the multi-path `use` syntax to import `self`\",\n-                        braces,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                err\n+                    let mpart_suggestion = errs::SelfImportsOnlyAllowedWithinMultipartSuggestion {\n+                        multipart_start: span_with_rename.shrink_to_lo(),\n+                        multipart_end: span_with_rename.shrink_to_hi(),\n+                    };\n+                    (Some(suggestion), Some(mpart_suggestion))\n+                };\n+                self.session.create_err(errs::SelfImportsOnlyAllowedWithin {\n+                    span,\n+                    suggestion,\n+                    mpart_suggestion,\n+                })\n             }\n             ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0430,\n-                    \"`self` import can only appear once in an import list\"\n-                );\n-                err.span_label(span, \"can only appear once in an import list\");\n-                err\n+                self.session.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n             }\n             ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0431,\n-                    \"`self` import can only appear in an import list with \\\n-                                                a non-empty prefix\"\n-                );\n-                err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n-                err\n+                self.session.create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span })\n             }\n             ResolutionError::FailedToResolve { label, suggestion } => {\n                 let mut err =\n@@ -869,23 +783,9 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0434,\n-                    \"{}\",\n-                    \"can't capture dynamic environment in a fn item\"\n-                );\n-                err.help(\"use the `|| { ... }` closure form instead\");\n-                err\n+                self.session.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n             }\n-            ResolutionError::AttemptToUseNonConstantValueInConstant(ident, sugg, current) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0435,\n-                    \"attempt to use a non-constant value in a constant\"\n-                );\n+            ResolutionError::AttemptToUseNonConstantValueInConstant(ident, suggestion, current) => {\n                 // let foo =...\n                 //     ^^^ given this Span\n                 // ------- get this Span to have an applicable suggestion\n@@ -899,23 +799,34 @@ impl<'a> Resolver<'a> {\n                     .source_map()\n                     .span_extend_to_prev_str(ident.span, current, true, false);\n \n-                match sp {\n+                let ((with, with_label), without) = match sp {\n                     Some(sp) if !self.session.source_map().is_multiline(sp) => {\n                         let sp = sp.with_lo(BytePos(sp.lo().0 - (current.len() as u32)));\n-                        err.span_suggestion(\n-                            sp,\n-                            &format!(\"consider using `{}` instead of `{}`\", sugg, current),\n-                            format!(\"{} {}\", sugg, ident),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        err.span_label(span, \"non-constant value\");\n-                    }\n-                    _ => {\n-                        err.span_label(ident.span, &format!(\"this would need to be a `{}`\", sugg));\n+                        (\n+                        (Some(errs::AttemptToUseNonConstantValueInConstantWithSuggestion {\n+                                span: sp,\n+                                ident,\n+                                suggestion,\n+                                current,\n+                            }), Some(errs::AttemptToUseNonConstantValueInConstantLabelWithSuggestion {span})),\n+                            None,\n+                        )\n                     }\n-                }\n+                    _ => (\n+                        (None, None),\n+                        Some(errs::AttemptToUseNonConstantValueInConstantWithoutSuggestion {\n+                            ident_span: ident.span,\n+                            suggestion,\n+                        }),\n+                    ),\n+                };\n \n-                err\n+                self.session.create_err(errs::AttemptToUseNonConstantValueInConstant {\n+                    span,\n+                    with,\n+                    with_label,\n+                    without,\n+                })\n             }\n             ResolutionError::BindingShadowsSomethingUnacceptable {\n                 shadowing_binding,\n@@ -924,135 +835,80 @@ impl<'a> Resolver<'a> {\n                 article,\n                 shadowed_binding,\n                 shadowed_binding_span,\n-            } => {\n-                let shadowed_binding_descr = shadowed_binding.descr();\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0530,\n-                    \"{}s cannot shadow {}s\",\n-                    shadowing_binding.descr(),\n-                    shadowed_binding_descr,\n-                );\n-                err.span_label(\n-                    span,\n-                    format!(\"cannot be named the same as {} {}\", article, shadowed_binding_descr),\n-                );\n-                match (shadowing_binding, shadowed_binding) {\n+            } => self.session.create_err(errs::BindingShadowsSomethingUnacceptable {\n+                span,\n+                shadowing_binding,\n+                shadowed_binding,\n+                article,\n+                sub_suggestion: match (shadowing_binding, shadowed_binding) {\n                     (\n                         PatternSource::Match,\n                         Res::Def(DefKind::Ctor(CtorOf::Variant | CtorOf::Struct, CtorKind::Fn), _),\n-                    ) => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try specify the pattern arguments\",\n-                            format!(\"{}(..)\", name),\n-                            Applicability::Unspecified,\n-                        );\n-                    }\n-                    _ => (),\n-                }\n-                let msg =\n-                    format!(\"the {} `{}` is {} here\", shadowed_binding_descr, name, participle);\n-                err.span_label(shadowed_binding_span, msg);\n-                err\n-            }\n+                    ) => Some(errs::BindingShadowsSomethingUnacceptableSuggestion { span, name }),\n+                    _ => None,\n+                },\n+                shadowed_binding_span,\n+                participle,\n+                name,\n+            }),\n             ResolutionError::ForwardDeclaredGenericParam => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0128,\n-                    \"generic parameters with a default cannot use \\\n-                                                forward declared identifiers\"\n-                );\n-                err.span_label(span, \"defaulted generic parameters cannot be forward declared\");\n-                err\n+                self.session.create_err(errs::ForwardDeclaredGenericParam { span })\n             }\n             ResolutionError::ParamInTyOfConstParam(name) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0770,\n-                    \"the type of const parameters must not depend on other generic parameters\"\n-                );\n-                err.span_label(\n-                    span,\n-                    format!(\"the type must not depend on the parameter `{}`\", name),\n-                );\n-                err\n+                self.session.create_err(errs::ParamInTyOfConstParam { span, name })\n             }\n             ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n-                let mut err = self.session.struct_span_err(\n+                self.session.create_err(errs::ParamInNonTrivialAnonConst {\n                     span,\n-                    \"generic parameters may not be used in const operations\",\n-                );\n-                err.span_label(span, &format!(\"cannot perform const operation using `{}`\", name));\n-\n-                if is_type {\n-                    err.note(\"type parameters may not be used in const expressions\");\n-                } else {\n-                    err.help(&format!(\n-                        \"const parameters may only be used as standalone arguments, i.e. `{}`\",\n-                        name\n-                    ));\n-                }\n-\n-                if self.session.is_nightly_build() {\n-                    err.help(\n-                        \"use `#![feature(generic_const_exprs)]` to allow generic const expressions\",\n-                    );\n-                }\n-\n-                err\n+                    name,\n+                    sub_is_type: if is_type {\n+                        errs::ParamInNonTrivialAnonConstIsType::AType\n+                    } else {\n+                        errs::ParamInNonTrivialAnonConstIsType::NotAType { name }\n+                    },\n+                    help: self\n+                        .session\n+                        .is_nightly_build()\n+                        .then_some(errs::ParamInNonTrivialAnonConstHelp),\n+                })\n             }\n             ResolutionError::SelfInGenericParamDefault => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0735,\n-                    \"generic parameters cannot use `Self` in their defaults\"\n-                );\n-                err.span_label(span, \"`Self` in generic parameter default\");\n-                err\n+                self.session.create_err(errs::SelfInGenericParamDefault { span })\n             }\n             ResolutionError::UnreachableLabel { name, definition_span, suggestion } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                let ((sub_suggestion_label, sub_suggestion), sub_unreachable_label) =\n+                    match suggestion {\n+                        // A reachable label with a similar name exists.\n+                        Some((ident, true)) => (\n+                            (\n+                                Some(errs::UnreachableLabelSubLabel { ident_span: ident.span }),\n+                                Some(errs::UnreachableLabelSubSuggestion {\n+                                    span,\n+                                    // intentionally taking 'ident.name' instead of 'ident' itself, as this\n+                                    // could be used in suggestion context\n+                                    ident_name: ident.name,\n+                                }),\n+                            ),\n+                            None,\n+                        ),\n+                        // An unreachable label with a similar name exists.\n+                        Some((ident, false)) => (\n+                            (None, None),\n+                            Some(errs::UnreachableLabelSubLabelUnreachable {\n+                                ident_span: ident.span,\n+                            }),\n+                        ),\n+                        // No similarly-named labels exist.\n+                        None => ((None, None), None),\n+                    };\n+                self.session.create_err(errs::UnreachableLabel {\n                     span,\n-                    E0767,\n-                    \"use of unreachable label `{}`\",\n                     name,\n-                );\n-\n-                err.span_label(definition_span, \"unreachable label defined here\");\n-                err.span_label(span, format!(\"unreachable label `{}`\", name));\n-                err.note(\n-                    \"labels are unreachable through functions, closures, async blocks and modules\",\n-                );\n-\n-                match suggestion {\n-                    // A reachable label with a similar name exists.\n-                    Some((ident, true)) => {\n-                        err.span_label(ident.span, \"a label with a similar name is reachable\");\n-                        err.span_suggestion(\n-                            span,\n-                            \"try using similarly named label\",\n-                            ident.name,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    // An unreachable label with a similar name exists.\n-                    Some((ident, false)) => {\n-                        err.span_label(\n-                            ident.span,\n-                            \"a label with a similar name exists but is also unreachable\",\n-                        );\n-                    }\n-                    // No similarly-named labels exist.\n-                    None => (),\n-                }\n-\n-                err\n+                    definition_span,\n+                    sub_suggestion,\n+                    sub_suggestion_label,\n+                    sub_unreachable_label,\n+                })\n             }\n             ResolutionError::TraitImplMismatch {\n                 name,\n@@ -1073,25 +929,10 @@ impl<'a> Resolver<'a> {\n                 err.span_label(trait_item_span, \"item in trait\");\n                 err\n             }\n-            ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0201,\n-                    \"duplicate definitions with name `{}`:\",\n-                    name,\n-                );\n-                err.span_label(old_span, \"previous definition here\");\n-                err.span_label(trait_item_span, \"item in trait\");\n-                err.span_label(span, \"duplicate definition\");\n-                err\n-            }\n-            ResolutionError::InvalidAsmSym => {\n-                let mut err = self.session.struct_span_err(span, \"invalid `sym` operand\");\n-                err.span_label(span, \"is a local variable\");\n-                err.help(\"`sym` operands must refer to either a function or a static\");\n-                err\n-            }\n+            ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => self\n+                .session\n+                .create_err(errs::TraitImplDuplicate { span, name, trait_item_span, old_span }),\n+            ResolutionError::InvalidAsmSym => self.session.create_err(errs::InvalidAsmSym { span }),\n         }\n     }\n \n@@ -1101,48 +942,27 @@ impl<'a> Resolver<'a> {\n     ) -> ErrorGuaranteed {\n         match vis_resolution_error {\n             VisResolutionError::Relative2018(span, path) => {\n-                let mut err = self.session.struct_span_err(\n+                self.session.create_err(errs::Relative2018 {\n                     span,\n-                    \"relative paths are not supported in visibilities in 2018 edition or later\",\n-                );\n-                err.span_suggestion(\n-                    path.span,\n-                    \"try\",\n-                    format!(\"crate::{}\", pprust::path_to_string(&path)),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err\n+                    path_span: path.span,\n+                    // intentionally converting to String, as the text would also be used as\n+                    // in suggestion context\n+                    path_str: pprust::path_to_string(&path),\n+                })\n+            }\n+            VisResolutionError::AncestorOnly(span) => {\n+                self.session.create_err(errs::AncestorOnly(span))\n             }\n-            VisResolutionError::AncestorOnly(span) => struct_span_err!(\n-                self.session,\n-                span,\n-                E0742,\n-                \"visibilities can only be restricted to ancestor modules\"\n-            ),\n             VisResolutionError::FailedToResolve(span, label, suggestion) => {\n                 self.into_struct_error(span, ResolutionError::FailedToResolve { label, suggestion })\n             }\n             VisResolutionError::ExpectedFound(span, path_str, res) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0577,\n-                    \"expected module, found {} `{}`\",\n-                    res.descr(),\n-                    path_str\n-                );\n-                err.span_label(span, \"not a module\");\n-                err\n+                self.session.create_err(errs::ExpectedFound { span, res, path_str })\n             }\n-            VisResolutionError::Indeterminate(span) => struct_span_err!(\n-                self.session,\n-                span,\n-                E0578,\n-                \"cannot determine resolution for the visibility\"\n-            ),\n-            VisResolutionError::ModuleOnly(span) => {\n-                self.session.struct_span_err(span, \"visibility must resolve to a module\")\n+            VisResolutionError::Indeterminate(span) => {\n+                self.session.create_err(errs::Indeterminate(span))\n             }\n+            VisResolutionError::ModuleOnly(span) => self.session.create_err(errs::ModuleOnly(span)),\n         }\n         .emit()\n     }"}, {"sha": "2c442774667b2b21dc8c56b1cf3489c71c8cc6d8", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "added", "additions": 474, "deletions": 0, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -0,0 +1,474 @@\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::{\n+    symbol::{Ident, Symbol},\n+    Span,\n+};\n+\n+use crate::{late::PatternSource, Res};\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_parent_module_reset_for_binding, code = \"E0637\")]\n+pub(crate) struct ParentModuleResetForBinding;\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ampersand_used_without_explicit_lifetime_name, code = \"E0637\")]\n+#[note]\n+pub(crate) struct AmpersandUsedWithoutExplicitLifetimeName(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_underscore_lifetime_name_cannot_be_used_here, code = \"E0637\")]\n+#[note]\n+pub(crate) struct UnderscoreLifetimeNameCannotBeUsedHere(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_crate_may_not_be_imported)]\n+pub(crate) struct CrateMayNotBeImprted(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_crate_root_imports_must_be_named_explicitly)]\n+pub(crate) struct CrateRootNamesMustBeNamedExplicitly(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_crate_root_imports_must_be_named_explicitly)]\n+pub(crate) struct ResolutionError(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_name_is_already_used_as_generic_parameter, code = \"E0403\")]\n+pub(crate) struct NameAlreadyUsedInParameterList {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(first_use_of_name)]\n+    pub(crate) first_use_span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_method_not_member_of_trait, code = \"E0407\")]\n+pub(crate) struct MethodNotMemberOfTrait {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) method: Ident,\n+    pub(crate) trait_: String,\n+    #[subdiagnostic]\n+    pub(crate) sub: Option<AssociatedFnWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_associated_fn_with_similar_name_exists,\n+    code = \"{candidate}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedFnWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) candidate: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_type_not_member_of_trait, code = \"E0437\")]\n+pub(crate) struct TypeNotMemberOfTrait {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) type_: Ident,\n+    pub(crate) trait_: String,\n+    #[subdiagnostic]\n+    pub(crate) sub: Option<AssociatedTypeWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_associated_type_with_similar_name_exists,\n+    code = \"{candidate}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedTypeWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) candidate: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_const_not_member_of_trait, code = \"E0438\")]\n+pub(crate) struct ConstNotMemberOfTrait {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) const_: Ident,\n+    pub(crate) trait_: String,\n+    #[subdiagnostic]\n+    pub(crate) sub: Option<AssociatedConstWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_associated_const_with_similar_name_exists,\n+    code = \"{candidate}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedConstWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) candidate: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_variable_bound_with_different_mode, code = \"E0409\")]\n+pub(crate) struct VariableBoundWithDifferentMode {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(first_binding_span)]\n+    pub(crate) first_binding_span: Span,\n+    pub(crate) variable_name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ident_bound_more_than_once_in_parameter_list, code = \"E0415\")]\n+pub(crate) struct IdentifierBoundMoreThanOnceInParameterList {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) identifier: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ident_bound_more_than_once_in_same_pattern, code = \"E0416\")]\n+pub(crate) struct IdentifierBoundMoreThanOnceInSamePattern {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) identifier: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_undeclared_label, code = \"E0426\")]\n+pub(crate) struct UndeclaredLabel {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[subdiagnostic]\n+    pub(crate) sub_reachable: Option<LabelWithSimilarNameReachable>,\n+    #[subdiagnostic]\n+    pub(crate) sub_reachable_suggestion: Option<TryUsingSimilarlyNamedLabel>,\n+    #[subdiagnostic]\n+    pub(crate) sub_unreachable: Option<UnreachableLabelWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_label_with_similar_name_reachable)]\n+pub(crate) struct LabelWithSimilarNameReachable(#[primary_span] pub(crate) Span);\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_try_using_similarly_named_label,\n+    code = \"{ident_name}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct TryUsingSimilarlyNamedLabel {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident_name: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_unreachable_label_with_similar_name_exists)]\n+pub(crate) struct UnreachableLabelWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_import_can_only_appear_once_in_the_list, code = \"E0430\")]\n+pub(crate) struct SelfImportCanOnlyAppearOnceInTheList {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_import_only_in_import_list_with_non_empty_prefix, code = \"E0431\")]\n+pub(crate) struct SelfImportOnlyInImportListWithNonEmptyPrefix {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_cannot_capture_dynamic_environment_in_fn_item, code = \"E0434\")]\n+#[help]\n+pub(crate) struct CannotCaptureDynamicEnvironmentInFnItem {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_attempt_to_use_non_constant_value_in_constant, code = \"E0435\")]\n+pub(crate) struct AttemptToUseNonConstantValueInConstant<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub(crate) with: Option<AttemptToUseNonConstantValueInConstantWithSuggestion<'a>>,\n+    #[subdiagnostic]\n+    pub(crate) with_label: Option<AttemptToUseNonConstantValueInConstantLabelWithSuggestion>,\n+    #[subdiagnostic]\n+    pub(crate) without: Option<AttemptToUseNonConstantValueInConstantWithoutSuggestion<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion,\n+    code = \"{suggestion} {ident}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AttemptToUseNonConstantValueInConstantWithSuggestion<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident: Ident,\n+    pub(crate) suggestion: &'a str,\n+    pub(crate) current: &'a str,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion)]\n+pub(crate) struct AttemptToUseNonConstantValueInConstantLabelWithSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion)]\n+pub(crate) struct AttemptToUseNonConstantValueInConstantWithoutSuggestion<'a> {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+    pub(crate) suggestion: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_imports_only_allowed_within, code = \"E0429\")]\n+pub(crate) struct SelfImportsOnlyAllowedWithin {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub(crate) suggestion: Option<SelfImportsOnlyAllowedWithinSuggestion>,\n+    #[subdiagnostic]\n+    pub(crate) mpart_suggestion: Option<SelfImportsOnlyAllowedWithinMultipartSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_self_imports_only_allowed_within_suggestion,\n+    code = \"\",\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct SelfImportsOnlyAllowedWithinSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    resolve_self_imports_only_allowed_within_multipart_suggestion,\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct SelfImportsOnlyAllowedWithinMultipartSuggestion {\n+    #[suggestion_part(code = \"{{\")]\n+    pub(crate) multipart_start: Span,\n+    #[suggestion_part(code = \"}}\")]\n+    pub(crate) multipart_end: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_binding_shadows_something_unacceptable, code = \"E0530\")]\n+pub(crate) struct BindingShadowsSomethingUnacceptable<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) shadowing_binding: PatternSource,\n+    pub(crate) shadowed_binding: Res,\n+    pub(crate) article: &'a str,\n+    #[subdiagnostic]\n+    pub(crate) sub_suggestion: Option<BindingShadowsSomethingUnacceptableSuggestion>,\n+    #[label(label_shadowed_binding)]\n+    pub(crate) shadowed_binding_span: Span,\n+    pub(crate) participle: &'a str,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_binding_shadows_something_unacceptable_suggestion,\n+    code = \"{name}(..)\",\n+    applicability = \"unspecified\"\n+)]\n+pub(crate) struct BindingShadowsSomethingUnacceptableSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_forward_declared_generic_param, code = \"E0128\")]\n+pub(crate) struct ForwardDeclaredGenericParam {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_param_in_ty_of_const_param, code = \"E0770\")]\n+pub(crate) struct ParamInTyOfConstParam {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_in_generic_param_default, code = \"E0735\")]\n+pub(crate) struct SelfInGenericParamDefault {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_param_in_non_trivial_anon_const)]\n+pub(crate) struct ParamInNonTrivialAnonConst {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[subdiagnostic]\n+    pub(crate) sub_is_type: ParamInNonTrivialAnonConstIsType,\n+    #[subdiagnostic]\n+    pub(crate) help: Option<ParamInNonTrivialAnonConstHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(resolve_param_in_non_trivial_anon_const_help)]\n+pub(crate) struct ParamInNonTrivialAnonConstHelp;\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ParamInNonTrivialAnonConstIsType {\n+    #[note(resolve_param_in_non_trivial_anon_const_sub_type)]\n+    AType,\n+    #[help(resolve_param_in_non_trivial_anon_const_sub_non_type)]\n+    NotAType { name: Symbol },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_unreachable_label, code = \"E0767\")]\n+#[note]\n+pub(crate) struct UnreachableLabel {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[label(label_definition_span)]\n+    pub(crate) definition_span: Span,\n+    #[subdiagnostic]\n+    pub(crate) sub_suggestion: Option<UnreachableLabelSubSuggestion>,\n+    #[subdiagnostic]\n+    pub(crate) sub_suggestion_label: Option<UnreachableLabelSubLabel>,\n+    #[subdiagnostic]\n+    pub(crate) sub_unreachable_label: Option<UnreachableLabelSubLabelUnreachable>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_unreachable_label_suggestion_use_similarly_named,\n+    code = \"{ident_name}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct UnreachableLabelSubSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident_name: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_unreachable_label_similar_name_reachable)]\n+pub(crate) struct UnreachableLabelSubLabel {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_unreachable_label_similar_name_unreachable)]\n+pub(crate) struct UnreachableLabelSubLabelUnreachable {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_trait_impl_mismatch, code = \"{code}\")]\n+pub(crate) struct TraitImplMismatch {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    pub(crate) kind: String,\n+    #[label(label_trait_item)]\n+    pub(crate) trait_item_span: Span,\n+    pub(crate) trait_path: String,\n+    pub(crate) code: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_invalid_asm_sym)]\n+#[help]\n+pub(crate) struct InvalidAsmSym {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_trait_impl_duplicate, code = \"E0201\")]\n+pub(crate) struct TraitImplDuplicate {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(old_span_label)]\n+    pub(crate) old_span: Span,\n+    #[label(trait_item_span)]\n+    pub(crate) trait_item_span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_relative_2018)]\n+pub(crate) struct Relative2018 {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[suggestion(code = \"crate::{path_str}\", applicability = \"maybe-incorrect\")]\n+    pub(crate) path_span: Span,\n+    pub(crate) path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ancestor_only, code = \"E0742\")]\n+pub(crate) struct AncestorOnly(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_expected_found, code = \"E0577\")]\n+pub(crate) struct ExpectedFound {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) res: Res,\n+    pub(crate) path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_indeterminate, code = \"E0578\")]\n+pub(crate) struct Indeterminate(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_module_only)]\n+pub(crate) struct ModuleOnly(#[primary_span] pub(crate) Span);"}, {"sha": "809d40479a30f42413dc86865d106b92424526ab", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -16,7 +16,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::DiagnosticId;\n+use rustc_errors::{DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n@@ -31,6 +31,7 @@ use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n use std::assert_matches::debug_assert_matches;\n+use std::borrow::Cow;\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, swap, take};\n \n@@ -78,6 +79,12 @@ impl PatternSource {\n     }\n }\n \n+impl IntoDiagnosticArg for PatternSource {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.descr()))\n+    }\n+}\n+\n /// Denotes whether the context for the set of already bound bindings is a `Product`\n /// or `Or` context. This is used in e.g., `fresh_binding` and `resolve_pattern_inner`.\n /// See those functions for more information."}, {"sha": "f9ae3b58172725eefc65025acd2332026b3f7143", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5965722ca46b82cc68cb1acdddf7e187a6ee02/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=3e5965722ca46b82cc68cb1acdddf7e187a6ee02", "patch": "@@ -73,6 +73,7 @@ mod check_unused;\n mod def_collector;\n mod diagnostics;\n mod effective_visibilities;\n+mod errors;\n mod ident;\n mod imports;\n mod late;"}]}