{"sha": "de3b12d686eac1ea6159e098e64277fd83528d71", "node_id": "C_kwDOAAsO6NoAKGRlM2IxMmQ2ODZlYWMxZWE2MTU5ZTA5OGU2NDI3N2ZkODM1MjhkNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-09T14:33:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-09T14:33:17Z"}, "message": "Auto merge of #14299 - Veykril:local-search, r=Veykril\n\nfix: Fix search not searching bodies of attributed items\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/14229", "tree": {"sha": "8f7f117061b3da6bbf6b54ca488a3572637c2c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f7f117061b3da6bbf6b54ca488a3572637c2c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de3b12d686eac1ea6159e098e64277fd83528d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de3b12d686eac1ea6159e098e64277fd83528d71", "html_url": "https://github.com/rust-lang/rust/commit/de3b12d686eac1ea6159e098e64277fd83528d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de3b12d686eac1ea6159e098e64277fd83528d71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73873752045e41c275092067f730ea5f2b1d874", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73873752045e41c275092067f730ea5f2b1d874", "html_url": "https://github.com/rust-lang/rust/commit/a73873752045e41c275092067f730ea5f2b1d874"}, {"sha": "3427d36d0e47a5266feb2e501876c60584600974", "url": "https://api.github.com/repos/rust-lang/rust/commits/3427d36d0e47a5266feb2e501876c60584600974", "html_url": "https://github.com/rust-lang/rust/commit/3427d36d0e47a5266feb2e501876c60584600974"}], "stats": {"total": 66, "additions": 24, "deletions": 42}, "files": [{"sha": "39fc08ecdcfe3f7f7fed01c7b4ec1d99867a5928", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de3b12d686eac1ea6159e098e64277fd83528d71/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3b12d686eac1ea6159e098e64277fd83528d71/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=de3b12d686eac1ea6159e098e64277fd83528d71", "patch": "@@ -815,7 +815,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n     ///\n     /// For attributes and derives, this will point back to the attribute only.\n-    /// For the entire item `InFile::use original_file_range_full`.\n+    /// For the entire item use [`InFile::original_file_range_full`].\n     pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n@@ -830,6 +830,21 @@ impl<'a> InFile<&'a SyntaxNode> {\n         }\n     }\n \n+    /// Falls back to the macro call range if the node cannot be mapped up fully.\n+    pub fn original_file_range_full(self, db: &dyn db::AstDatabase) -> FileRange {\n+        match self.file_id.repr() {\n+            HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n+            HirFileIdRepr::MacroFile(mac_file) => {\n+                if let Some(res) = self.original_file_range_opt(db) {\n+                    return res;\n+                }\n+                // Fall back to whole macro call.\n+                let loc = db.lookup_intern_macro_call(mac_file.macro_call_id);\n+                loc.kind.original_call_range_with_body(db)\n+            }\n+        }\n+    }\n+\n     /// Attempts to map the syntax node back up its macro calls.\n     pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n         match ascend_node_border_tokens(db, self) {"}, {"sha": "12f5e4e2a23a85c000d7537172a8819927dcd8bb", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/de3b12d686eac1ea6159e098e64277fd83528d71/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3b12d686eac1ea6159e098e64277fd83528d71/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=de3b12d686eac1ea6159e098e64277fd83528d71", "patch": "@@ -244,14 +244,14 @@ impl Definition {\n                 DefWithBody::Variant(v) => v.source(db).map(|src| src.syntax().cloned()),\n             };\n             return match def {\n-                Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),\n+                Some(def) => SearchScope::file_range(def.as_ref().original_file_range_full(db)),\n                 None => SearchScope::single_file(file_id),\n             };\n         }\n \n         if let Definition::SelfType(impl_) = self {\n             return match impl_.source(db).map(|src| src.syntax().cloned()) {\n-                Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),\n+                Some(def) => SearchScope::file_range(def.as_ref().original_file_range_full(db)),\n                 None => SearchScope::single_file(file_id),\n             };\n         }\n@@ -268,7 +268,7 @@ impl Definition {\n                 hir::GenericDef::Const(it) => it.source(db).map(|src| src.syntax().cloned()),\n             };\n             return match def {\n-                Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),\n+                Some(def) => SearchScope::file_range(def.as_ref().original_file_range_full(db)),\n                 None => SearchScope::single_file(file_id),\n             };\n         }\n@@ -319,10 +319,6 @@ impl Definition {\n             sema,\n             scope: None,\n             include_self_kw_refs: None,\n-            local_repr: match self {\n-                Definition::Local(local) => Some(local),\n-                _ => None,\n-            },\n             search_self_mod: false,\n         }\n     }\n@@ -337,9 +333,6 @@ pub struct FindUsages<'a> {\n     assoc_item_container: Option<hir::AssocItemContainer>,\n     /// whether to search for the `Self` type of the definition\n     include_self_kw_refs: Option<hir::Type>,\n-    /// the local representative for the local definition we are searching for\n-    /// (this is required for finding all local declarations in a or-pattern)\n-    local_repr: Option<hir::Local>,\n     /// whether to search for the `self` module\n     search_self_mod: bool,\n }\n@@ -644,19 +637,6 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, name_ref) {\n-            Some(NameRefClass::Definition(def @ Definition::Local(local)))\n-                if matches!(\n-                    self.local_repr, Some(repr) if repr == local\n-                ) =>\n-            {\n-                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference = FileReference {\n-                    range,\n-                    name: ast::NameLike::NameRef(name_ref.clone()),\n-                    category: ReferenceCategory::new(&def, name_ref),\n-                };\n-                sink(file_id, reference)\n-            }\n             Some(NameRefClass::Definition(def))\n                 if self.def == def\n                     // is our def a trait assoc item? then we want to find all assoc items from trait impls of our trait\n@@ -701,14 +681,16 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n-                let field = Definition::Field(field);\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+\n+                let field = Definition::Field(field);\n+                let local = Definition::Local(local);\n                 let access = match self.def {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local) => {\n-                        ReferenceCategory::new(&Definition::Local(local), name_ref)\n+                    Definition::Local(_) if local == self.def => {\n+                        ReferenceCategory::new(&local, name_ref)\n                     }\n                     _ => return false,\n                 };\n@@ -752,21 +734,6 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n-                if matches!(\n-                    self.local_repr,\n-                    Some(repr) if local == repr\n-                ) {\n-                    let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n-                    let reference = FileReference {\n-                        range,\n-                        name: ast::NameLike::Name(name.clone()),\n-                        category: None,\n-                    };\n-                    return sink(file_id, reference);\n-                }\n-                false\n-            }\n             Some(NameClass::Definition(def)) if def != self.def => {\n                 match (&self.assoc_item_container, self.def) {\n                     // for type aliases we always want to reference the trait def and all the trait impl counterparts"}]}