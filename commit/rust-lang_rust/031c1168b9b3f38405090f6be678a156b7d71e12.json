{"sha": "031c1168b9b3f38405090f6be678a156b7d71e12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMWMxMTY4YjliM2YzODQwNTA5MGY2YmU2NzhhMTU2YjdkNzFlMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-05T19:33:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-05T19:33:55Z"}, "message": "Auto merge of #39567 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 12 pull requests\n\n- Successful merges: #39439, #39472, #39481, #39491, #39501, #39509, #39514, #39519, #39526, #39528, #39530, #39538\n- Failed merges:", "tree": {"sha": "38656a85859d0f1a9864ab07b3865b34b3bd4162", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38656a85859d0f1a9864ab07b3865b34b3bd4162"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/031c1168b9b3f38405090f6be678a156b7d71e12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/031c1168b9b3f38405090f6be678a156b7d71e12", "html_url": "https://github.com/rust-lang/rust/commit/031c1168b9b3f38405090f6be678a156b7d71e12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/031c1168b9b3f38405090f6be678a156b7d71e12/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc02736d59252fe408dd6c2f7e2c4b6f229e4443", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc02736d59252fe408dd6c2f7e2c4b6f229e4443", "html_url": "https://github.com/rust-lang/rust/commit/fc02736d59252fe408dd6c2f7e2c4b6f229e4443"}, {"sha": "a419dd1c013846754c0a3c8dae3842c2739864d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a419dd1c013846754c0a3c8dae3842c2739864d4", "html_url": "https://github.com/rust-lang/rust/commit/a419dd1c013846754c0a3c8dae3842c2739864d4"}], "stats": {"total": 1464, "additions": 871, "deletions": 593}, "files": [{"sha": "4ce80a5e849196477570805a41181710ed17d87f", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/configure", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -517,7 +517,7 @@ case $CFG_CPUTYPE in\n         CFG_OSTYPE=\"${CFG_OSTYPE}eabihf\"\n         ;;\n \n-    aarch64)\n+    aarch64 | arm64)\n         CFG_CPUTYPE=aarch64\n         ;;\n "}, {"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/aarch64-unknown-freebsd.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/mk%2Fcfg%2Faarch64-unknown-freebsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/mk%2Fcfg%2Faarch64-unknown-freebsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-unknown-freebsd.mk?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "27255b691009395eea81d67a3b9b217abea7b20f", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -379,6 +379,8 @@ def build_triple(self):\n             ostype += 'eabihf'\n         elif cputype == 'aarch64':\n             cputype = 'aarch64'\n+        elif cputype == 'arm64':\n+            cputype = 'aarch64'\n         elif cputype == 'mips':\n             if sys.byteorder == 'big':\n                 cputype = 'mips'"}, {"sha": "cb7852995f3b19e9f2f4fb761f0b68d519edbed4", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -41,6 +41,12 @@ fn main() {\n         return;\n     }\n \n+    if target.contains(\"android\") {\n+        println!(\"cargo:rustc-link-lib=gcc\");\n+    } else if !target.contains(\"windows\") && !target.contains(\"musl\") {\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+    }\n+\n     if let Some(jemalloc) = env::var_os(\"JEMALLOC_OVERRIDE\") {\n         let jemalloc = PathBuf::from(jemalloc);\n         println!(\"cargo:rustc-link-search=native={}\",\n@@ -66,11 +72,6 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=static=jemalloc_pic\");\n     }\n     println!(\"cargo:rustc-link-search=native={}/lib\", build_dir.display());\n-    if target.contains(\"android\") {\n-        println!(\"cargo:rustc-link-lib=gcc\");\n-    } else if !target.contains(\"windows\") && !target.contains(\"musl\") {\n-        println!(\"cargo:rustc-link-lib=pthread\");\n-    }\n     let src_dir = env::current_dir().unwrap().join(\"../jemalloc\");\n     rerun_if_changed_anything_in_dir(&src_dir);\n     let timestamp = build_dir.join(\"rustbuild.timestamp\");"}, {"sha": "2d6a9877219dcacac0a2fe31f6c4fe83193804e1", "filename": "src/libbacktrace/pecoff.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibbacktrace%2Fpecoff.c", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fpecoff.c?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -607,7 +607,9 @@ coff_add (struct backtrace_state *state, int descriptor,\n   //       against the upstream libbacktrace, that's what's going on.\n   uint32_t str_size;\n   off_t str_off;\n-  struct backtrace_view syms_view;\n+  // NOTE: upstream doesn't have `{0}`, this is a fix for Rust issue #39468.\n+  //       If syms_view is not initialized, then `free(syms_view.base)` may segfault later.\n+  struct backtrace_view syms_view = {0};\n   off_t syms_off;\n   size_t syms_size;\n   int syms_view_valid;"}, {"sha": "2ea953df8735729b6d02dbecf7453d1a07615d9d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -98,7 +98,7 @@\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n use alloc::boxed::Box;\n-use core::cmp::Ordering::{self, Greater};\n+use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n@@ -1089,7 +1089,7 @@ impl<T> [T] {\n     pub fn sort(&mut self)\n         where T: Ord\n     {\n-        self.sort_by(|a, b| a.cmp(b))\n+        merge_sort(self, |a, b| a.lt(b));\n     }\n \n     /// Sorts the slice using `f` to extract a key to compare elements by.\n@@ -1119,7 +1119,7 @@ impl<T> [T] {\n     pub fn sort_by_key<B, F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> B, B: Ord\n     {\n-        self.sort_by(|a, b| f(a).cmp(&f(b)))\n+        merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n     /// Sorts the slice using `compare` to compare elements.\n@@ -1149,10 +1149,10 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort_by<F>(&mut self, compare: F)\n+    pub fn sort_by<F>(&mut self, mut compare: F)\n         where F: FnMut(&T, &T) -> Ordering\n     {\n-        merge_sort(self, compare)\n+        merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n     /// Copies the elements from `src` into `self`.\n@@ -1355,10 +1355,10 @@ impl<T: Clone> ToOwned for [T] {\n /// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n ///\n /// This is the integral subroutine of insertion sort.\n-fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n-    where F: FnMut(&T, &T) -> Ordering\n+fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n {\n-    if v.len() >= 2 && compare(&v[0], &v[1]) == Greater {\n+    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n             // There are three ways to implement insertion here:\n             //\n@@ -1381,12 +1381,12 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n-            // 1. Protects integrity of `v` from panics in `compare`.\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n             // 2. Fills the remaining hole in `v` in the end.\n             //\n             // Panic safety:\n             //\n-            // If `compare` panics at any point during the process, `hole` will get dropped and\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n             let mut hole = InsertionHole {\n@@ -1396,7 +1396,7 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n-                if compare(&tmp.value, &v[i]) != Greater {\n+                if !is_less(&v[i], &tmp.value) {\n                     break;\n                 }\n                 ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n@@ -1432,8 +1432,8 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n ///\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n-unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n-    where F: FnMut(&T, &T) -> Ordering\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -1449,12 +1449,12 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n     // hole in `v`.\n     //\n     // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n-    // 1. Protects integrity of `v` from panics in `compare`.\n+    // 1. Protects integrity of `v` from panics in `is_less`.\n     // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n     //\n     // Panic safety:\n     //\n-    // If `compare` panics at any point during the process, `hole` will get dropped and fill the\n+    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n     // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n     // object it initially held exactly once.\n     let mut hole;\n@@ -1476,7 +1476,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n         while *left < hole.end && right < v_end {\n             // Consume the lesser side.\n             // If equal, prefer the left run to maintain stability.\n-            let to_copy = if compare(&**left, &*right) == Greater {\n+            let to_copy = if is_less(&*right, &**left) {\n                 get_and_increment(&mut right)\n             } else {\n                 get_and_increment(left)\n@@ -1500,7 +1500,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n         while v < *left && buf < *right {\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n-            let to_copy = if compare(&*left.offset(-1), &*right.offset(-1)) == Greater {\n+            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n                 decrement_and_get(left)\n             } else {\n                 decrement_and_get(right)\n@@ -1550,8 +1550,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n-fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n-    where F: FnMut(&T, &T) -> Ordering\n+fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n+    where F: FnMut(&T, &T) -> bool\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n     if size_of::<T>() == 0 {\n@@ -1565,7 +1565,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n     //\n     // Short runs are extended using insertion sort to span at least `min_run` elements, in order\n     // to improve performance.\n-    let (max_insertion, min_run) = if size_of::<T>() <= 16 {\n+    let (max_insertion, min_run) = if size_of::<T>() <= 2 * mem::size_of::<usize>() {\n         (64, 32)\n     } else {\n         (32, 16)\n@@ -1577,15 +1577,15 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n     if len <= max_insertion {\n         if len >= 2 {\n             for i in (0..len-1).rev() {\n-                insert_head(&mut v[i..], &mut compare);\n+                insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n         return;\n     }\n \n     // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n     // shallow copies of the contents of `v` without risking the dtors running on copies if\n-    // `compare` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n     // which will always have length at most `len / 2`.\n     let mut buf = Vec::with_capacity(len / 2);\n \n@@ -1600,14 +1600,18 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n         let mut start = end - 1;\n         if start > 0 {\n             start -= 1;\n-            if compare(&v[start], &v[start + 1]) == Greater {\n-                while start > 0 && compare(&v[start - 1], &v[start]) == Greater {\n-                    start -= 1;\n-                }\n-                v[start..end].reverse();\n-            } else {\n-                while start > 0 && compare(&v[start - 1], &v[start]) != Greater {\n-                    start -= 1;\n+            unsafe {\n+                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n+                    while start > 0 && is_less(v.get_unchecked(start),\n+                                               v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n+                    v[start..end].reverse();\n+                } else {\n+                    while start > 0 && !is_less(v.get_unchecked(start),\n+                                                v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n                 }\n             }\n         }\n@@ -1616,7 +1620,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n         // merge sort on short sequences, so this significantly improves performance.\n         while start > 0 && end - start < min_run {\n             start -= 1;\n-            insert_head(&mut v[start..end], &mut compare);\n+            insert_head(&mut v[start..end], &mut is_less);\n         }\n \n         // Push this run onto the stack.\n@@ -1632,7 +1636,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n             let right = runs[r];\n             unsafe {\n                 merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut compare);\n+                      &mut is_less);\n             }\n             runs[r] = Run {\n                 start: left.start,"}, {"sha": "b9dec6be7b8853b9401c6089b6455e049bec145a", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -1429,18 +1429,15 @@ mod bench {\n     fn sort_large_random_expensive(b: &mut Bencher) {\n         let len = 10000;\n         b.iter(|| {\n+            let mut v = gen_random(len);\n             let mut count = 0;\n-            let cmp = move |a: &u64, b: &u64| {\n+            v.sort_by(|a: &u64, b: &u64| {\n                 count += 1;\n                 if count % 1_000_000_000 == 0 {\n                     panic!(\"should not happen\");\n                 }\n                 (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n-            };\n-\n-            let mut v = gen_random(len);\n-            v.sort_by(cmp);\n-\n+            });\n             black_box(count);\n         });\n         b.bytes = len as u64 * mem::size_of::<u64>() as u64;"}, {"sha": "482d70895ff89235307cc6e2cb858fef839e4b53", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -544,8 +544,7 @@ pub mod reimpls {\n         const MD1 : u32 = MANTISSA_DIGITS + 1;\n         const MD2 : u32 = MANTISSA_DIGITS + 2;\n \n-        // SNAP: replace this with !0u128\n-        let negn :u128 = !0;\n+        let negn = !0u128;\n \n         if sd > MANTISSA_DIGITS {\n             a = match sd {\n@@ -579,8 +578,7 @@ pub mod reimpls {\n         const MD1 : u32 = MANTISSA_DIGITS + 1;\n         const MD2 : u32 = MANTISSA_DIGITS + 2;\n \n-        // SNAP: replace this with !0u128\n-        let negn :u128 = !0;\n+        let negn = !0u128;\n \n         if sd > MANTISSA_DIGITS {\n             a = match sd {\n@@ -652,17 +650,17 @@ pub mod reimpls {\n         }\n \n         #[export_name=\"__fixunssfti\"]\n-        pub extern \"unadjusted\" fn f32_as_u128(a: f32) -> u128 {\n+        pub extern $unadj fn f32_as_u128(a: f32) -> u128 {\n             float_as_unsigned!(a, f32, u128)\n         }\n \n         #[export_name=\"__fixdfti\"]\n-        pub extern \"unadjusted\" fn f64_as_i128(a: f64) -> i128 {\n+        pub extern $unadj fn f64_as_i128(a: f64) -> i128 {\n             float_as_signed!(a, f64, i128)\n         }\n \n         #[export_name=\"__fixsfti\"]\n-        pub extern \"unadjusted\" fn f32_as_i128(a: f32) -> i128 {\n+        pub extern $unadj fn f32_as_i128(a: f32) -> i128 {\n             float_as_signed!(a, f32, i128)\n         }\n "}, {"sha": "4f7cd7b016d66ac7f8a38ab05e0516825a4e7210", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -13,7 +13,6 @@ bench = false\n name = \"coretest\"\n path = \"../libcoretest/lib.rs\"\n \n-# FIXME: need to extract benchmarks to a separate crate\n-#[[bench]]\n-#name = \"coretest\"\n-#path = \"../libcoretest/lib.rs\"\n+[[bench]]\n+name = \"corebench\"\n+path = \"../libcore/bench/lib.rs\""}, {"sha": "67e02cf9509b6cd8ba71db2be4dd19cea9946ce0", "filename": "src/libcore/bench/any.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fany.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::any::*;\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn bench_downcast_ref(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut x = 0;\n+        let mut y = &mut x as &mut Any;\n+        black_box(&mut y);\n+        black_box(y.downcast_ref::<isize>() == Some(&0));\n+    });\n+}"}, {"sha": "55d9e3e0913801bf2a4106eee84d44015dfe6cb4", "filename": "src/libcore/bench/hash/mod.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fhash%2Fmod.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod sip;"}, {"sha": "3379c85bbec7d5985df61fa213c3da90127faeb3", "filename": "src/libcore/bench/hash/sip.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fhash%2Fsip.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(deprecated)]\n+\n+use core::hash::*;\n+use test::{Bencher, black_box};\n+\n+fn hash_bytes<H: Hasher>(mut s: H, x: &[u8]) -> u64 {\n+    Hasher::write(&mut s, x);\n+    s.finish()\n+}\n+\n+fn hash_with<H: Hasher, T: Hash>(mut st: H, x: &T) -> u64 {\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    hash_with(SipHasher::new(), x)\n+}\n+\n+#[bench]\n+fn bench_str_under_8_bytes(b: &mut Bencher) {\n+    let s = \"foo\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 16262950014981195938);\n+    })\n+}\n+\n+#[bench]\n+fn bench_str_of_8_bytes(b: &mut Bencher) {\n+    let s = \"foobar78\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 4898293253460910787);\n+    })\n+}\n+\n+#[bench]\n+fn bench_str_over_8_bytes(b: &mut Bencher) {\n+    let s = \"foobarbaz0\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 10581415515220175264);\n+    })\n+}\n+\n+#[bench]\n+fn bench_long_str(b: &mut Bencher) {\n+    let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n+incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n+exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n+irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n+pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n+officia deserunt mollit anim id est laborum.\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 17717065544121360093);\n+    })\n+}\n+\n+#[bench]\n+fn bench_u32(b: &mut Bencher) {\n+    let u = 162629500u32;\n+    let u = black_box(u);\n+    b.iter(|| {\n+        hash(&u)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_u32_keyed(b: &mut Bencher) {\n+    let u = 162629500u32;\n+    let u = black_box(u);\n+    let k1 = black_box(0x1);\n+    let k2 = black_box(0x2);\n+    b.iter(|| {\n+        hash_with(SipHasher::new_with_keys(k1, k2), &u)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_u64(b: &mut Bencher) {\n+    let u = 16262950014981195938u64;\n+    let u = black_box(u);\n+    b.iter(|| {\n+        hash(&u)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_bytes_4(b: &mut Bencher) {\n+    let data = black_box([b' '; 4]);\n+    b.iter(|| {\n+        hash_bytes(SipHasher::default(), &data)\n+    });\n+    b.bytes = 4;\n+}\n+\n+#[bench]\n+fn bench_bytes_7(b: &mut Bencher) {\n+    let data = black_box([b' '; 7]);\n+    b.iter(|| {\n+        hash_bytes(SipHasher::default(), &data)\n+    });\n+    b.bytes = 7;\n+}\n+\n+#[bench]\n+fn bench_bytes_8(b: &mut Bencher) {\n+    let data = black_box([b' '; 8]);\n+    b.iter(|| {\n+        hash_bytes(SipHasher::default(), &data)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_bytes_a_16(b: &mut Bencher) {\n+    let data = black_box([b' '; 16]);\n+    b.iter(|| {\n+        hash_bytes(SipHasher::default(), &data)\n+    });\n+    b.bytes = 16;\n+}\n+\n+#[bench]\n+fn bench_bytes_b_32(b: &mut Bencher) {\n+    let data = black_box([b' '; 32]);\n+    b.iter(|| {\n+        hash_bytes(SipHasher::default(), &data)\n+    });\n+    b.bytes = 32;\n+}\n+\n+#[bench]\n+fn bench_bytes_c_128(b: &mut Bencher) {\n+    let data = black_box([b' '; 128]);\n+    b.iter(|| {\n+        hash_bytes(SipHasher::default(), &data)\n+    });\n+    b.bytes = 128;\n+}"}, {"sha": "93d38a5bc83bbf1e392585821c90b82d5a72d3fb", "filename": "src/libcore/bench/iter.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fiter.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::iter::*;\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn bench_rposition(b: &mut Bencher) {\n+    let it: Vec<usize> = (0..300).collect();\n+    b.iter(|| {\n+        it.iter().rposition(|&x| x <= 150);\n+    });\n+}\n+\n+#[bench]\n+fn bench_skip_while(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        let mut sum = 0;\n+        it.skip_while(|&x| { sum += x; sum < 4000 }).all(|_| true);\n+    });\n+}\n+\n+#[bench]\n+fn bench_multiple_take(b: &mut Bencher) {\n+    let mut it = (0..42).cycle();\n+    b.iter(|| {\n+        let n = it.next().unwrap();\n+        for _ in 0..n {\n+            it.clone().take(it.next().unwrap()).all(|_| true);\n+        }\n+    });\n+}\n+\n+fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n+\n+#[bench]\n+fn bench_max_by_key(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        it.max_by_key(|&x| scatter(x))\n+    })\n+}\n+\n+// http://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/\n+#[bench]\n+fn bench_max_by_key2(b: &mut Bencher) {\n+    fn max_index_iter(array: &[i32]) -> usize {\n+        array.iter().enumerate().max_by_key(|&(_, item)| item).unwrap().0\n+    }\n+\n+    let mut data = vec![0; 1638];\n+    data[514] = 9999;\n+\n+    b.iter(|| max_index_iter(&data));\n+}\n+\n+#[bench]\n+fn bench_max(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        it.map(scatter).max()\n+    })\n+}\n+\n+pub fn copy_zip(xs: &[u8], ys: &mut [u8]) {\n+    for (a, b) in ys.iter_mut().zip(xs) {\n+        *a = *b;\n+    }\n+}\n+\n+pub fn add_zip(xs: &[f32], ys: &mut [f32]) {\n+    for (a, b) in ys.iter_mut().zip(xs) {\n+        *a += *b;\n+    }\n+}\n+\n+#[bench]\n+fn bench_zip_copy(b: &mut Bencher) {\n+    let source = vec![0u8; 16 * 1024];\n+    let mut dst = black_box(vec![0u8; 16 * 1024]);\n+    b.iter(|| {\n+        copy_zip(&source, &mut dst)\n+    })\n+}\n+\n+#[bench]\n+fn bench_zip_add(b: &mut Bencher) {\n+    let source = vec![1.; 16 * 1024];\n+    let mut dst = vec![0.; 16 * 1024];\n+    b.iter(|| {\n+        add_zip(&source, &mut dst)\n+    });\n+}"}, {"sha": "d2db329da799981b3a6d3a372211f21893603b6a", "filename": "src/libcore/bench/lib.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Flib.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+#![feature(flt2dec)]\n+#![feature(slice_patterns)]\n+#![feature(test)]\n+\n+extern crate core;\n+extern crate test;\n+\n+mod any;\n+mod hash;\n+mod iter;\n+mod mem;\n+mod num;\n+mod ops;"}, {"sha": "8e541d92a7f170c366b97c57c1912d9bd19f783d", "filename": "src/libcore/bench/mem.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fmem.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::Bencher;\n+\n+// FIXME #13642 (these benchmarks should be in another place)\n+// Completely miscellaneous language-construct benchmarks.\n+// Static/dynamic method dispatch\n+\n+struct Struct {\n+    field: isize\n+}\n+\n+trait Trait {\n+    fn method(&self) -> isize;\n+}\n+\n+impl Trait for Struct {\n+    fn method(&self) -> isize {\n+        self.field\n+    }\n+}\n+\n+#[bench]\n+fn trait_vtable_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    let t = &s as &Trait;\n+    b.iter(|| {\n+        t.method()\n+    });\n+}\n+\n+#[bench]\n+fn trait_static_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    b.iter(|| {\n+        s.method()\n+    });\n+}\n+\n+// Overhead of various match forms\n+\n+#[bench]\n+fn match_option_some(b: &mut Bencher) {\n+    let x = Some(10);\n+    b.iter(|| {\n+        match x {\n+            Some(y) => y,\n+            None => 11\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn match_vec_pattern(b: &mut Bencher) {\n+    let x = [1,2,3,4,5,6];\n+    b.iter(|| {\n+        match x {\n+            [1,2,3,..] => 10,\n+            _ => 11,\n+        }\n+    });\n+}"}, {"sha": "562866e11777cf0e4db920ff0e9b0d4e60ea5c05", "filename": "src/libcore/bench/num/dec2flt/mod.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fnum%2Fdec2flt%2Fmod.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::f64;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_0(b: &mut Bencher) {\n+    b.iter(|| \"0.0\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_42(b: &mut Bencher) {\n+    b.iter(|| \"42\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_huge_int(b: &mut Bencher) {\n+    // 2^128 - 1\n+    b.iter(|| \"170141183460469231731687303715884105727\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_short_decimal(b: &mut Bencher) {\n+    b.iter(|| \"1234.5678\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_pi_long(b: &mut Bencher) {\n+    b.iter(|| \"3.14159265358979323846264338327950288\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_pi_short(b: &mut Bencher) {\n+    b.iter(|| \"3.141592653589793\".parse::<f64>())\n+}\n+\n+#[bench]\n+fn bench_1e150(b: &mut Bencher) {\n+    b.iter(|| \"1e150\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_long_decimal_and_exp(b: &mut Bencher) {\n+    b.iter(|| \"727501488517303786137132964064381141071e-123\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_min_subnormal(b: &mut Bencher) {\n+    b.iter(|| \"5e-324\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_min_normal(b: &mut Bencher) {\n+    b.iter(|| \"2.2250738585072014e-308\".parse::<f64>());\n+}\n+\n+#[bench]\n+fn bench_max(b: &mut Bencher) {\n+    b.iter(|| \"1.7976931348623157e308\".parse::<f64>());\n+}"}, {"sha": "1de2bf4921f589996130885f363b550cbf179695", "filename": "src/libcore/bench/num/flt2dec/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fmod.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod strategy {\n+    mod dragon;\n+    mod grisu;\n+}\n+\n+use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n+use core::num::flt2dec::MAX_SIG_DIGITS;\n+\n+pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+    match decode(v).1 {\n+        FullDecoded::Finite(decoded) => decoded,\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+    }\n+}"}, {"sha": "6824cf40ed2aec678ae771792ce01f9fb2a573da", "filename": "src/libcore/bench/num/flt2dec/strategy/dragon.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{i16, f64};\n+use super::super::*;\n+use core::num::flt2dec::strategy::dragon::*;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_small_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_big_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_small_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}"}, {"sha": "82e1a858fca9fc655a15967c43a88d7c6fd17711", "filename": "src/libcore/bench/num/flt2dec/strategy/grisu.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{i16, f64};\n+use super::super::*;\n+use core::num::flt2dec::strategy::grisu::*;\n+use test::Bencher;\n+\n+pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+    match decode(v).1 {\n+        FullDecoded::Finite(decoded) => decoded,\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+    }\n+}\n+\n+#[bench]\n+fn bench_small_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_big_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_small_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}"}, {"sha": "55f0bdb57ec820711fc8b8ddec0bc7981eaa6837", "filename": "src/libcore/bench/num/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fnum%2Fmod.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod flt2dec;\n+mod dec2flt;"}, {"sha": "7f36a4b0771aa611d9cb2f07544787da0e28be9c", "filename": "src/libcore/bench/ops.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcore%2Fbench%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbench%2Fops.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::ops::*;\n+use test::Bencher;\n+\n+// Overhead of dtors\n+\n+struct HasDtor {\n+    _x: isize\n+}\n+\n+impl Drop for HasDtor {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+#[bench]\n+fn alloc_obj_with_dtor(b: &mut Bencher) {\n+    b.iter(|| {\n+        HasDtor { _x : 10 };\n+    })\n+}"}, {"sha": "2d3e81aa131ed4ceb5fc7d2696af966b9d9c660b", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -7,9 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use core::any::*;\n-use test::Bencher;\n-use test;\n \n #[derive(PartialEq, Debug)]\n struct Test;\n@@ -124,13 +123,3 @@ fn any_unsized() {\n     fn is_any<T: Any + ?Sized>() {}\n     is_any::<[i32]>();\n }\n-\n-#[bench]\n-fn bench_downcast_ref(b: &mut Bencher) {\n-    b.iter(|| {\n-        let mut x = 0;\n-        let mut y = &mut x as &mut Any;\n-        test::black_box(&mut y);\n-        test::black_box(y.downcast_ref::<isize>() == Some(&0));\n-    });\n-}"}, {"sha": "4a9657e03404af4f6d02cf79a05c92e8a05c8ebb", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(deprecated)]\n \n-use test::{Bencher, black_box};\n-\n use core::hash::{Hash, Hasher};\n use core::hash::{SipHasher, SipHasher13, SipHasher24};\n use core::{slice, mem};\n@@ -58,11 +56,6 @@ fn hash<T: Hash>(x: &T) -> u64 {\n     hash_with(SipHasher::new(), x)\n }\n \n-fn hash_bytes<H: Hasher>(mut s: H, x: &[u8]) -> u64 {\n-    Hasher::write(&mut s, x);\n-    s.finish()\n-}\n-\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash_1_3() {\n@@ -347,126 +340,3 @@ fn test_write_short_works() {\n     h2.write(&[0xFFu8, 0x01u8]);\n     assert_eq!(h1.finish(), h2.finish());\n }\n-\n-#[bench]\n-fn bench_str_under_8_bytes(b: &mut Bencher) {\n-    let s = \"foo\";\n-    b.iter(|| {\n-        assert_eq!(hash(&s), 16262950014981195938);\n-    })\n-}\n-\n-#[bench]\n-fn bench_str_of_8_bytes(b: &mut Bencher) {\n-    let s = \"foobar78\";\n-    b.iter(|| {\n-        assert_eq!(hash(&s), 4898293253460910787);\n-    })\n-}\n-\n-#[bench]\n-fn bench_str_over_8_bytes(b: &mut Bencher) {\n-    let s = \"foobarbaz0\";\n-    b.iter(|| {\n-        assert_eq!(hash(&s), 10581415515220175264);\n-    })\n-}\n-\n-#[bench]\n-fn bench_long_str(b: &mut Bencher) {\n-    let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n-incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n-exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n-irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n-pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n-officia deserunt mollit anim id est laborum.\";\n-    b.iter(|| {\n-        assert_eq!(hash(&s), 17717065544121360093);\n-    })\n-}\n-\n-#[bench]\n-fn bench_u32(b: &mut Bencher) {\n-    let u = 162629500u32;\n-    let u = black_box(u);\n-    b.iter(|| {\n-        hash(&u)\n-    });\n-    b.bytes = 8;\n-}\n-\n-#[bench]\n-fn bench_u32_keyed(b: &mut Bencher) {\n-    let u = 162629500u32;\n-    let u = black_box(u);\n-    let k1 = black_box(0x1);\n-    let k2 = black_box(0x2);\n-    b.iter(|| {\n-        hash_with(SipHasher::new_with_keys(k1, k2), &u)\n-    });\n-    b.bytes = 8;\n-}\n-\n-#[bench]\n-fn bench_u64(b: &mut Bencher) {\n-    let u = 16262950014981195938u64;\n-    let u = black_box(u);\n-    b.iter(|| {\n-        hash(&u)\n-    });\n-    b.bytes = 8;\n-}\n-\n-#[bench]\n-fn bench_bytes_4(b: &mut Bencher) {\n-    let data = black_box([b' '; 4]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n-    b.bytes = 4;\n-}\n-\n-#[bench]\n-fn bench_bytes_7(b: &mut Bencher) {\n-    let data = black_box([b' '; 7]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n-    b.bytes = 7;\n-}\n-\n-#[bench]\n-fn bench_bytes_8(b: &mut Bencher) {\n-    let data = black_box([b' '; 8]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n-    b.bytes = 8;\n-}\n-\n-#[bench]\n-fn bench_bytes_a_16(b: &mut Bencher) {\n-    let data = black_box([b' '; 16]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n-    b.bytes = 16;\n-}\n-\n-#[bench]\n-fn bench_bytes_b_32(b: &mut Bencher) {\n-    let data = black_box([b' '; 32]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n-    b.bytes = 32;\n-}\n-\n-#[bench]\n-fn bench_bytes_c_128(b: &mut Bencher) {\n-    let data = black_box([b' '; 128]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n-    b.bytes = 128;\n-}"}, {"sha": "08442f9bcbff522d498b826d3dda8d1faf1b011e", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -12,9 +12,6 @@ use core::iter::*;\n use core::{i8, i16, isize};\n use core::usize;\n \n-use test::Bencher;\n-use test::black_box;\n-\n #[test]\n fn test_lt() {\n     let empty: [isize; 0] = [];\n@@ -1085,91 +1082,3 @@ fn test_chain_fold() {\n     assert_eq!(&[2, 3, 1, 2, 0], &result[..]);\n }\n \n-#[bench]\n-fn bench_rposition(b: &mut Bencher) {\n-    let it: Vec<usize> = (0..300).collect();\n-    b.iter(|| {\n-        it.iter().rposition(|&x| x <= 150);\n-    });\n-}\n-\n-#[bench]\n-fn bench_skip_while(b: &mut Bencher) {\n-    b.iter(|| {\n-        let it = 0..100;\n-        let mut sum = 0;\n-        it.skip_while(|&x| { sum += x; sum < 4000 }).all(|_| true);\n-    });\n-}\n-\n-#[bench]\n-fn bench_multiple_take(b: &mut Bencher) {\n-    let mut it = (0..42).cycle();\n-    b.iter(|| {\n-        let n = it.next().unwrap();\n-        for _ in 0..n {\n-            it.clone().take(it.next().unwrap()).all(|_| true);\n-        }\n-    });\n-}\n-\n-fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n-\n-#[bench]\n-fn bench_max_by_key(b: &mut Bencher) {\n-    b.iter(|| {\n-        let it = 0..100;\n-        it.max_by_key(|&x| scatter(x))\n-    })\n-}\n-\n-// http://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/\n-#[bench]\n-fn bench_max_by_key2(b: &mut Bencher) {\n-    fn max_index_iter(array: &[i32]) -> usize {\n-        array.iter().enumerate().max_by_key(|&(_, item)| item).unwrap().0\n-    }\n-\n-    let mut data = vec![0; 1638];\n-    data[514] = 9999;\n-\n-    b.iter(|| max_index_iter(&data));\n-}\n-\n-#[bench]\n-fn bench_max(b: &mut Bencher) {\n-    b.iter(|| {\n-        let it = 0..100;\n-        it.map(scatter).max()\n-    })\n-}\n-\n-pub fn copy_zip(xs: &[u8], ys: &mut [u8]) {\n-    for (a, b) in ys.iter_mut().zip(xs) {\n-        *a = *b;\n-    }\n-}\n-\n-pub fn add_zip(xs: &[f32], ys: &mut [f32]) {\n-    for (a, b) in ys.iter_mut().zip(xs) {\n-        *a += *b;\n-    }\n-}\n-\n-#[bench]\n-fn bench_zip_copy(b: &mut Bencher) {\n-    let source = vec![0u8; 16 * 1024];\n-    let mut dst = black_box(vec![0u8; 16 * 1024]);\n-    b.iter(|| {\n-        copy_zip(&source, &mut dst)\n-    })\n-}\n-\n-#[bench]\n-fn bench_zip_add(b: &mut Bencher) {\n-    let source = vec![1.; 16 * 1024];\n-    let mut dst = vec![0.; 16 * 1024];\n-    b.iter(|| {\n-        add_zip(&source, &mut dst)\n-    });\n-}"}, {"sha": "86e59c736ba4a133b8d3257a2c56661c1fa07e33", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -7,8 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use core::mem::*;\n-use test::Bencher;\n \n #[test]\n fn size_of_basic() {\n@@ -121,61 +121,3 @@ fn test_transmute() {\n     }\n }\n \n-// FIXME #13642 (these benchmarks should be in another place)\n-/// Completely miscellaneous language-construct benchmarks.\n-// Static/dynamic method dispatch\n-\n-struct Struct {\n-    field: isize\n-}\n-\n-trait Trait {\n-    fn method(&self) -> isize;\n-}\n-\n-impl Trait for Struct {\n-    fn method(&self) -> isize {\n-        self.field\n-    }\n-}\n-\n-#[bench]\n-fn trait_vtable_method_call(b: &mut Bencher) {\n-    let s = Struct { field: 10 };\n-    let t = &s as &Trait;\n-    b.iter(|| {\n-        t.method()\n-    });\n-}\n-\n-#[bench]\n-fn trait_static_method_call(b: &mut Bencher) {\n-    let s = Struct { field: 10 };\n-    b.iter(|| {\n-        s.method()\n-    });\n-}\n-\n-// Overhead of various match forms\n-\n-#[bench]\n-fn match_option_some(b: &mut Bencher) {\n-    let x = Some(10);\n-    b.iter(|| {\n-        match x {\n-            Some(y) => y,\n-            None => 11\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn match_vec_pattern(b: &mut Bencher) {\n-    let x = [1,2,3,4,5,6];\n-    b.iter(|| {\n-        match x {\n-            [1,2,3,..] => 10,\n-            _ => 11,\n-        }\n-    });\n-}"}, {"sha": "5d546c643e7ee5248ee42b42cc481d24a0d0bd3a", "filename": "src/libcoretest/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -11,7 +11,6 @@\n #![allow(overflowing_literals)]\n \n use std::{i64, f32, f64};\n-use test;\n \n mod parse;\n mod rawfp;\n@@ -144,59 +143,3 @@ fn borderline_overflow() {\n     // It makes no sense to enshrine that in a test, the important part is that it doesn't panic.\n     let _ = s.parse::<f64>();\n }\n-\n-#[bench]\n-fn bench_0(b: &mut test::Bencher) {\n-    b.iter(|| \"0.0\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_42(b: &mut test::Bencher) {\n-    b.iter(|| \"42\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_huge_int(b: &mut test::Bencher) {\n-    // 2^128 - 1\n-    b.iter(|| \"170141183460469231731687303715884105727\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_short_decimal(b: &mut test::Bencher) {\n-    b.iter(|| \"1234.5678\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_pi_long(b: &mut test::Bencher) {\n-    b.iter(|| \"3.14159265358979323846264338327950288\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_pi_short(b: &mut test::Bencher) {\n-    b.iter(|| \"3.141592653589793\".parse::<f64>())\n-}\n-\n-#[bench]\n-fn bench_1e150(b: &mut test::Bencher) {\n-    b.iter(|| \"1e150\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_long_decimal_and_exp(b: &mut test::Bencher) {\n-    b.iter(|| \"727501488517303786137132964064381141071e-123\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_min_subnormal(b: &mut test::Bencher) {\n-    b.iter(|| \"5e-324\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_min_normal(b: &mut test::Bencher) {\n-    b.iter(|| \"2.2250738585072014e-308\".parse::<f64>());\n-}\n-\n-#[bench]\n-fn bench_max(b: &mut test::Bencher) {\n-    b.iter(|| \"1.7976931348623157e308\".parse::<f64>());\n-}"}, {"sha": "4edb0f3df60c44ea3d0b1aa7c76c379cb5d37de5", "filename": "src/libcoretest/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::prelude::v1::*;\n-use std::{i16, f64};\n use super::super::*;\n use core::num::bignum::Big32x40 as Big;\n use core::num::flt2dec::strategy::dragon::*;\n@@ -53,62 +52,6 @@ fn exact_sanity_test() {\n     f32_exact_sanity_test(format_exact);\n }\n \n-#[bench]\n-fn bench_small_shortest(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n-}\n-\n-#[bench]\n-fn bench_big_shortest(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n-}\n-\n-#[bench]\n-fn bench_small_exact_3(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_big_exact_3(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_small_exact_12(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_big_exact_12(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_small_exact_inf(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_big_exact_inf(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n #[test]\n fn test_to_shortest_str() {\n     to_shortest_str_test(format_shortest);"}, {"sha": "79e66ee669e146d13e9addfaf635d1eee5670db4", "filename": "src/libcoretest/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{i16, f64};\n+use std::i16;\n use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n@@ -102,62 +102,6 @@ fn exact_f64_random_equivalence_test() {\n     }\n }\n \n-#[bench]\n-fn bench_small_shortest(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n-}\n-\n-#[bench]\n-fn bench_big_shortest(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n-}\n-\n-#[bench]\n-fn bench_small_exact_3(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_big_exact_3(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_small_exact_12(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_big_exact_12(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_small_exact_inf(b: &mut Bencher) {\n-    let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n-#[bench]\n-fn bench_big_exact_inf(b: &mut Bencher) {\n-    let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n-}\n-\n #[test]\n fn test_to_shortest_str() {\n     to_shortest_str_test(format_shortest);"}, {"sha": "1c6c13b0d02e8b6e5417bbfbc900d4ca78f21f67", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -8,27 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use test::Bencher;\n use core::ops::{Range, RangeFull, RangeFrom, RangeTo};\n \n-// Overhead of dtors\n-\n-struct HasDtor {\n-    _x: isize\n-}\n-\n-impl Drop for HasDtor {\n-    fn drop(&mut self) {\n-    }\n-}\n-\n-#[bench]\n-fn alloc_obj_with_dtor(b: &mut Bencher) {\n-    b.iter(|| {\n-        HasDtor { _x : 10 };\n-    })\n-}\n-\n // Test the Range structs without the syntactic sugar.\n \n #[test]"}, {"sha": "3b4b3998c574531ee3cd16afaaf8540a0d2be24b", "filename": "src/librustc/util/fs.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -31,7 +31,7 @@ use std::io;\n //   https://github.com/rust-lang/rust/issues/25505#issuecomment-102876737\n pub fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n     if !cfg!(windows) {\n-        return p.to_path_buf()\n+        return p.to_path_buf();\n     }\n     let mut components = p.components();\n     let prefix = match components.next() {\n@@ -58,7 +58,7 @@ pub fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n \n pub enum LinkOrCopy {\n     Link,\n-    Copy\n+    Copy,\n }\n \n /// Copy `p` into `q`, preferring to use hard-linking if possible. If\n@@ -76,7 +76,35 @@ pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<Li\n         Err(_) => {\n             match fs::copy(p, q) {\n                 Ok(_) => Ok(LinkOrCopy::Copy),\n-                Err(e) => Err(e)\n+                Err(e) => Err(e),\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum RenameOrCopyRemove {\n+    Rename,\n+    CopyRemove,\n+}\n+\n+/// Rename `p` into `q`, preferring to use `rename` if possible.\n+/// If `rename` fails (rename may fail for reasons such as crossing\n+/// filesystem), fallback to copy & remove\n+pub fn rename_or_copy_remove<P: AsRef<Path>, Q: AsRef<Path>>(p: P,\n+                                                             q: Q)\n+                                                             -> io::Result<RenameOrCopyRemove> {\n+    let p = p.as_ref();\n+    let q = q.as_ref();\n+    match fs::rename(p, q) {\n+        Ok(()) => Ok(RenameOrCopyRemove::Rename),\n+        Err(_) => {\n+            match fs::copy(p, q) {\n+                Ok(_) => {\n+                    fs::remove_file(p)?;\n+                    Ok(RenameOrCopyRemove::CopyRemove)\n+                }\n+                Err(e) => Err(e),\n             }\n         }\n     }\n@@ -93,8 +121,7 @@ pub fn create_dir_racy(path: &Path) -> io::Result<()> {\n     }\n     match path.parent() {\n         Some(p) => try!(create_dir_racy(p)),\n-        None => return Err(io::Error::new(io::ErrorKind::Other,\n-                                          \"failed to create whole tree\")),\n+        None => return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\")),\n     }\n     match fs::create_dir(path) {\n         Ok(()) => Ok(()),"}, {"sha": "3c5d6308ee6bad7b052ae03eb71991b809554c52", "filename": "src/librustc_back/target/aarch64_unknown_freebsd.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_freebsd.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::freebsd_base::opts();\n+    base.max_atomic_width = Some(128);\n+\n+    // see #36994\n+    base.exe_allocation_crate = \"alloc_system\".to_string();\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-freebsd\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"freebsd\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: TargetOptions {\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "9e232bc7e1f2ff96b24b5e6e00a6643cb3119985", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -165,6 +165,7 @@ supported_targets! {\n     (\"armv7-linux-androideabi\", armv7_linux_androideabi),\n     (\"aarch64-linux-android\", aarch64_linux_android),\n \n+    (\"aarch64-unknown-freebsd\", aarch64_unknown_freebsd),\n     (\"i686-unknown-freebsd\", i686_unknown_freebsd),\n     (\"x86_64-unknown-freebsd\", x86_64_unknown_freebsd),\n "}, {"sha": "6f33b4fad769f20d9e7d06b053a0a014fafbb5c3", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -273,7 +273,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n     let mut printed_if_let_err = false;\n-    for &(ref pats, guard) in arms {\n+    for (arm_index, &(ref pats, guard)) in arms.iter().enumerate() {\n         for &(pat, hir_pat) in pats {\n             let v = vec![pat];\n \n@@ -302,10 +302,27 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n                             let span = first_pat.0.span;\n-                            struct_span_err!(cx.tcx.sess, span, E0165,\n-                                             \"irrefutable while-let pattern\")\n-                                .span_label(span, &format!(\"irrefutable pattern\"))\n-                                .emit();\n+\n+                            // check which arm we're on.\n+                            match arm_index {\n+                                // The arm with the user-specified pattern.\n+                                0 => {\n+                                    let mut diagnostic = Diagnostic::new(Level::Warning,\n+                                                                         \"unreachable pattern\");\n+                                    diagnostic.set_span(pat.span);\n+                                    cx.tcx.sess.add_lint_diagnostic(\n+                                            lint::builtin::UNREACHABLE_PATTERNS,\n+                                            hir_pat.id, diagnostic);\n+                                },\n+                                // The arm with the wildcard pattern.\n+                                1 => {\n+                                    struct_span_err!(cx.tcx.sess, span, E0165,\n+                                                     \"irrefutable while-let pattern\")\n+                                        .span_label(span, &format!(\"irrefutable pattern\"))\n+                                        .emit();\n+                                },\n+                                _ => bug!(),\n+                            }\n                         },\n \n                         hir::MatchSource::ForLoopDesugar |"}, {"sha": "af4f63a05613eef94f20438b98343163cf7d0c35", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -482,12 +482,9 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n                     return Ok(Integral(I64(i64::min_value())))\n                 },\n-                (&LitKind::Int(n, _), Some(&ty::TyInt(IntTy::I128))) |\n-                (&LitKind::Int(n, Signed(IntTy::I128)), _) => {\n-                    // SNAP: replace n in pattern with I128_OVERFLOW and remove this if.\n-                    if n == I128_OVERFLOW {\n-                        return Ok(Integral(I128(i128::min_value())))\n-                    }\n+                (&LitKind::Int(I128_OVERFLOW, _), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n+                    return Ok(Integral(I128(i128::min_value())))\n                 },\n                 (&LitKind::Int(n, _), Some(&ty::TyInt(IntTy::Is))) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {"}, {"sha": "17714f2fb2d6cd3074c460e7b6783cbdf0704ee8", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -155,13 +155,11 @@ impl ConstInt {\n             (InferSigned(a @ 0...ibounds::U8MAX), U8(_)) => U8(a as u8),\n             (InferSigned(a @ 0...ibounds::U16MAX), U16(_)) => U16(a as u16),\n             (InferSigned(a @ 0...ibounds::U32MAX), U32(_)) => U32(a as u32),\n-            // SNAP: replace with U64MAX\n-            (InferSigned(a @ 0...ibounds::I64MAX), U64(_)) => U64(a as u64),\n+            (InferSigned(a @ 0...ibounds::U64MAX), U64(_)) => U64(a as u64),\n             (InferSigned(a @ 0...ibounds::I128MAX), U128(_)) => U128(a as u128),\n             (InferSigned(a @ 0...ibounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n             (InferSigned(a @ 0...ibounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            // SNAP: replace with U64MAX\n-            (InferSigned(a @ 0...ibounds::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n+            (InferSigned(a @ 0...ibounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n             (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n             _ => self, // already known types\n         };"}, {"sha": "33bf4d5276adf23e7f9aa8b0d3204bc8483660a0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::util::common::time;\n use rustc::util::nodemap::{NodeSet, NodeMap};\n+use rustc::util::fs::rename_or_copy_remove;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_incremental::ich::Fingerprint;\n@@ -1084,10 +1085,9 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         // are going to build an executable\n         if sess.opts.output_types.contains_key(&OutputType::Exe) {\n             let f = outputs.path(OutputType::Object);\n-            fs::copy(&f,\n+            rename_or_copy_remove(&f,\n                      f.with_file_name(format!(\"{}.0.o\",\n                                               f.file_stem().unwrap().to_string_lossy()))).unwrap();\n-            fs::remove_file(f).unwrap();\n         }\n \n         // Remove assembly source, unless --save-temps was specified"}, {"sha": "8510b9f523cb5eb34af3910c2372a5511e8ae227", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME: Rename 'DIGlobalVariable' to 'DIGlobalVariableExpression'\n+// once support for LLVM 3.9 is dropped.\n+//\n+// This method was changed in this LLVM patch:\n+// https://reviews.llvm.org/D26769\n+\n use debuginfo::{DIBuilderRef, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,\n                 DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,\n                 DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,"}, {"sha": "64100ed4191cc3645b94337814865e0c186bc5a4", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -229,15 +229,10 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     }\n }\n \n-pub fn C_big_integral(t: Type, u: u128, sign_extend: bool) -> ValueRef {\n-    if ::std::mem::size_of::<u128>() == 16 {\n-        unsafe {\n-            let words = [u as u64, u.wrapping_shr(64) as u64];\n-            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n-        }\n-    } else {\n-        // SNAP: remove after snapshot\n-        C_integral(t, u as u64, sign_extend)\n+pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n+    unsafe {\n+        let words = [u as u64, u.wrapping_shr(64) as u64];\n+        llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n     }\n }\n "}, {"sha": "f92faaa0508a653ee035e2a6d8f3961273c122a8", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -75,7 +75,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n             ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n             ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n-            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128, true),\n+            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128),\n             ConstVal::Integral(Isize(v)) => {\n                 let i = v.as_i64(ccx.tcx().sess.target.int_type);\n                 C_integral(Type::int(ccx), i as u64, true)\n@@ -84,7 +84,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n             ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n             ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n-            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v, false),\n+            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v),\n             ConstVal::Integral(Usize(v)) => {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 C_integral(Type::int(ccx), u, false)"}, {"sha": "c690fd467ee4125a97ddefb8af01e327c482f933", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -144,11 +144,24 @@ impl FileDesc {\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n-            cvt(libc::fcntl(self.fd, libc::F_SETFD, previous | libc::FD_CLOEXEC))?;\n+            let new = previous | libc::FD_CLOEXEC;\n+            if new != previous {\n+                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n+            }\n+            Ok(())\n+        }\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        unsafe {\n+            let v = nonblocking as c_int;\n+            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n             Ok(())\n         }\n     }\n \n+    #[cfg(not(target_os = \"linux\"))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         unsafe {\n             let previous = cvt(libc::fcntl(self.fd, libc::F_GETFL))?;\n@@ -157,7 +170,9 @@ impl FileDesc {\n             } else {\n                 previous & !libc::O_NONBLOCK\n             };\n-            cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n+            if new != previous {\n+                cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n+            }\n             Ok(())\n         }\n     }"}, {"sha": "c7bcd2558186e6f94ef24a4e82d14bbedd9326bf", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -588,7 +588,11 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n   }\n #endif\n \n+#if LLVM_VERSION_GE(4, 0)\n+  return wrap(Builder->createGlobalVariableExpression(\n+#else\n   return wrap(Builder->createGlobalVariable(\n+#endif\n       unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n       unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), IsLocalToUnit,\n #if LLVM_VERSION_GE(4, 0)"}, {"sha": "4c894b0bdd3dd2b7724978159332ca00bc61ec28", "filename": "src/test/compile-fail/uninhabited-patterns.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -24,6 +24,10 @@ struct NotSoSecretlyEmpty {\n     _priv: !,\n }\n \n+fn foo() -> Option<NotSoSecretlyEmpty> {\n+    None\n+}\n+\n fn main() {\n     let x: &[!] = &[];\n \n@@ -45,5 +49,9 @@ fn main() {\n         Err(Err(_y)) => (),\n         Err(Ok(_y)) => (),  //~ ERROR unreachable pattern\n     }\n+\n+    while let Some(_y) = foo() {\n+        //~^ ERROR unreachable pattern\n+    }\n }\n "}, {"sha": "9e63beff3cb2eeb0f7c3973a87224fe562f3cc9c", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "4a1d14ccf6118c862f540777a3b4e49186356226", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "012bd6140cdbe6470f3f54e92696cad08979c528", "filename": "src/test/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "16e6371a9c0a9944db7f6989d8061dd26492f5ff", "filename": "src/test/debuginfo/packed-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "75c2feb480ede8f32d0aae9055d9a60a0890ac84", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // ignore-lldb\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "bd044188dbcbcd4f50d4195fe83a335f613855cf", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "b156a3be699e3359490962ebe9c755824aaee5e3", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "f36153d1f5c5a8eca5d52aa027edf3d4f559ce27", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "0b2544151fd323b0d6a6c38d4ce1ac43d2fba107", "filename": "src/test/debuginfo/union-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "5a99de7779cffd3972190b807d7981b2db6b3e68", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n \n // compile-flags:-g\n "}, {"sha": "473f1cc2301dc565f7a30b2761fe8869be17b130", "filename": "src/test/run-pass/i128-ffi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Frun-pass%2Fi128-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Frun-pass%2Fi128-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128-ffi.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-stage0\n-// ignore-stage1\n-\n // MSVC doesn't support 128 bit integers, and other Windows\n // C compilers have very inconsistent views on how the ABI\n // should look like."}, {"sha": "dc4f0774b9771e87e35557a4759585888a6c8bf1", "filename": "src/test/run-pass/i128.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Frun-pass%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Frun-pass%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-stage0\n-// ignore-stage1\n-\n // ignore-emscripten\n \n #![feature(i128_type, test)]"}, {"sha": "a513476d4a33a3fc2ed51dcabd072a71fe90983d", "filename": "src/test/run-pass/issue-38987.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Frun-pass%2Fissue-38987.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031c1168b9b3f38405090f6be678a156b7d71e12/src%2Ftest%2Frun-pass%2Fissue-38987.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38987.rs?ref=031c1168b9b3f38405090f6be678a156b7d71e12", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n #![feature(i128_type)]\n \n-// SNAP: run on all stages after snapshot, i128 currently doesn't work on stages 0 and 1\n-// ignore-stage1\n-// ignore-stage0\n-\n fn main() {\n     let _ = -0x8000_0000_0000_0000_0000_0000_0000_0000i128;\n }"}]}