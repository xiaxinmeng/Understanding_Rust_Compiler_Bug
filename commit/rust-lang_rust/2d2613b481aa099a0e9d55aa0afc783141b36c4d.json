{"sha": "2d2613b481aa099a0e9d55aa0afc783141b36c4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjYxM2I0ODFhYTA5OWEwZTlkNTVhYTBhZmM3ODMxNDFiMzZjNGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-07T17:12:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-07T17:12:54Z"}, "message": "Merge #7198\n\n7198: Styleguide readability r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "769ce8133460ccd55103a759974bd4bfb1725f33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/769ce8133460ccd55103a759974bd4bfb1725f33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d2613b481aa099a0e9d55aa0afc783141b36c4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf90EWCRBK7hj4Ov3rIwAAdHIIAJEZfeZAhyNw5jUjAHLq0rE/\nL1mq+1uirhAvlvRhJrrhtMFvqAbV+NsCtI6+BAzTOvZCznQ02a23qrEfU0pYRoaN\nRMO0YDQfhKjHpTsNwr+dYbLKSDJQpFyEjpTQfd2DrPi6WQzTEGRKXYWHmr+YmeVR\nSFhvBzOokJ8WkBDmccTvKBZT9OL1LYIFOrpWl7u8bYJOM83qgP2NXRkuknCAc4ip\nYjtd+oetfsPfpeSCTxKfEF+FVhTrxPasB3AO3IWWuLpq1E/o4GXkJ++GP3q7k0BX\ntYkRu01uBZugDs9P/pUZTWkgBuGr2su5bMJNjRkxzUm8CGu2nn+vgo6MuusF7JA=\n=Lsmy\n-----END PGP SIGNATURE-----\n", "payload": "tree 769ce8133460ccd55103a759974bd4bfb1725f33\nparent dce5f0c5859ad538074a4e69cd4365813bf96863\nparent 5aed769afec96244c218ac094d46d22a1edb019c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610039574 +0000\ncommitter GitHub <noreply@github.com> 1610039574 +0000\n\nMerge #7198\n\n7198: Styleguide readability r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2613b481aa099a0e9d55aa0afc783141b36c4d", "html_url": "https://github.com/rust-lang/rust/commit/2d2613b481aa099a0e9d55aa0afc783141b36c4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d2613b481aa099a0e9d55aa0afc783141b36c4d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dce5f0c5859ad538074a4e69cd4365813bf96863", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce5f0c5859ad538074a4e69cd4365813bf96863", "html_url": "https://github.com/rust-lang/rust/commit/dce5f0c5859ad538074a4e69cd4365813bf96863"}, {"sha": "5aed769afec96244c218ac094d46d22a1edb019c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aed769afec96244c218ac094d46d22a1edb019c", "html_url": "https://github.com/rust-lang/rust/commit/5aed769afec96244c218ac094d46d22a1edb019c"}], "stats": {"total": 178, "additions": 115, "deletions": 63}, "files": [{"sha": "f4748160bf15eecab1de3e64751c8ae4cebdd8fb", "filename": "docs/dev/style.md", "status": "modified", "additions": 115, "deletions": 63, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/2d2613b481aa099a0e9d55aa0afc783141b36c4d/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d2613b481aa099a0e9d55aa0afc783141b36c4d/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=2d2613b481aa099a0e9d55aa0afc783141b36c4d", "patch": "@@ -53,6 +53,9 @@ We try to be very conservative with usage of crates.io dependencies.\n Don't use small \"helper\" crates (exception: `itertools` is allowed).\n If there's some general reusable bit of code you need, consider adding it to the `stdx` crate.\n \n+**Rational:** keep compile times low, create ecosystem pressure for faster\n+compiles, reduce the number of things which might break.\n+\n ## Commit Style\n \n We don't have specific rules around git history hygiene.\n@@ -66,37 +69,35 @@ Such messages create a lot of duplicate notification traffic during rebases.\n If possible, write commit messages from user's perspective:\n \n ```\n-# Good\n+# GOOD\n Goto definition works inside macros\n \n-# Not as good\n+# BAD\n Use original span for FileId\n ```\n \n This makes it easier to prepare a changelog.\n \n+**Rational:** clean history is potentially useful, but rarely used.\n+But many users read changelogs.\n+\n ## Clippy\n \n We don't enforce Clippy.\n A number of default lints have high false positive rate.\n Selectively patching false-positives with `allow(clippy)` is considered worse than not using Clippy at all.\n There's `cargo xtask lint` command which runs a subset of low-FPR lints.\n Careful tweaking of `xtask lint` is welcome.\n-See also [rust-lang/clippy#5537](https://github.com/rust-lang/rust-clippy/issues/5537).\n Of course, applying Clippy suggestions is welcome as long as they indeed improve the code.\n \n+**Rational:** see [rust-lang/clippy#5537](https://github.com/rust-lang/rust-clippy/issues/5537).\n+\n # Code\n \n ## Minimal Tests\n \n Most tests in rust-analyzer start with a snippet of Rust code.\n This snippets should be minimal -- if you copy-paste a snippet of real code into the tests, make sure to remove everything which could be removed.\n-There are many benefits to this:\n-\n-* less to read or to scroll past\n-* easier to understand what exactly is tested\n-* less stuff printed during printf-debugging\n-* less time to run test\n \n It also makes sense to format snippets more compactly (for example, by placing enum definitions like `enum E { Foo, Bar }` on a single line),\n as long as they are still readable.\n@@ -125,19 +126,28 @@ fn main() {\n     }\n ```\n \n-That way, you can use your editor's \"number of selected characters\" feature to correlate offsets with test's source code.\n+**Rational:**\n+\n+There are many benefits to this:\n+\n+* less to read or to scroll past\n+* easier to understand what exactly is tested\n+* less stuff printed during printf-debugging\n+* less time to run test\n+\n+Formatting ensures that you can use your editor's \"number of selected characters\" feature to correlate offsets with test's source code.\n \n-## Preconditions\n+## Function Preconditions\n \n Express function preconditions in types and force the caller to provide them (rather than checking in callee):\n \n ```rust\n-// Good\n+// GOOD\n fn frbonicate(walrus: Walrus) {\n     ...\n }\n \n-// Not as good\n+// BAD\n fn frobnicate(walrus: Option<Walrus>) {\n     let walrus = match walrus {\n         Some(it) => it,\n@@ -147,10 +157,13 @@ fn frobnicate(walrus: Option<Walrus>) {\n }\n ```\n \n-Avoid preconditions that span across function boundaries:\n+**Rational:** this makes control flow explicit at the call site.\n+Call-site has more context, it often happens that the precondition falls out naturally or can be bubbled up higher in the stack.\n+\n+Avoid splitting precondition check and precondition use across functions:\n \n ```rust\n-// Good\n+// GOOD\n fn main() {\n     let s: &str = ...;\n     if let Some(contents) = string_literal_contents(s) {\n@@ -166,7 +179,7 @@ fn string_literal_contents(s: &str) -> Option<&str> {\n     }\n }\n \n-// Not as good\n+// BAD\n fn main() {\n     let s: &str = ...;\n     if is_string_literal(s) {\n@@ -182,20 +195,24 @@ fn is_string_literal(s: &str) -> bool {\n In the \"Not as good\" version, the precondition that `1` is a valid char boundary is checked in `is_string_literal` and used in `foo`.\n In the \"Good\" version, the precondition check and usage are checked in the same block, and then encoded in the types.\n \n+**Rational:** non-local code properties degrade under change.\n+\n When checking a boolean precondition, prefer `if !invariant` to `if negated_invariant`:\n \n ```rust\n-// Good\n+// GOOD\n if !(idx < len) {\n     return None;\n }\n \n-// Not as good\n+// BAD\n if idx >= len {\n     return None;\n }\n ```\n \n+**Rational:** its useful to see the invariant relied upon by the rest of the function clearly spelled out.\n+\n ## Getters & Setters\n \n If a field can have any value without breaking invariants, make the field public.\n@@ -211,31 +228,36 @@ struct Person {\n     middle_name: Option<String>\n }\n \n-// Good\n+// GOOD\n impl Person {\n     fn first_name(&self) -> &str { self.first_name.as_str() }\n     fn middle_name(&self) -> Option<&str> { self.middle_name.as_ref() }\n }\n \n-// Not as good\n+// BAD\n impl Person {\n     fn first_name(&self) -> String { self.first_name.clone() }\n     fn middle_name(&self) -> &Option<String> { &self.middle_name }\n }\n ```\n \n+**Rational:** we don't provide public API, it's cheaper to refactor than to pay getters rent.\n+Non-local code properties degrade under change, privacy makes invariant local.\n+Borrowed own data discloses irrelevant details about origin of data.\n+Irrelevant (neither right nor wrong) things obscure correctness.\n+\n ## Constructors\n \n Prefer `Default` to zero-argument `new` function\n \n ```rust\n-// Good\n+// GOOD\n #[derive(Default)]\n struct Foo {\n     bar: Option<Bar>\n }\n \n-// Not as good\n+// BAD\n struct Foo {\n     bar: Option<Bar>\n }\n@@ -249,16 +271,18 @@ impl Foo {\n \n Prefer `Default` even it has to be implemented manually.\n \n+**Rational:** less typing in the common case, uniformity.\n+\n ## Functions Over Objects\n \n Avoid creating \"doer\" objects.\n That is, objects which are created only to execute a single action.\n \n ```rust\n-// Good\n+// GOOD\n do_thing(arg1, arg2);\n \n-// Not as good\n+// BAD\n ThingDoer::new(arg1, arg2).do();\n ```\n \n@@ -303,24 +327,22 @@ impl ThingDoer {\n }\n ```\n \n+**Rational:** not bothering the caller with irrelevant details, not mixing user API with implementor API.\n+\n ## Avoid Monomorphization\n \n-Rust uses monomorphization to compile generic code, meaning that for each instantiation of a generic functions with concrete types, the function is compiled afresh, *per crate*.\n-This allows for exceptionally good performance, but leads to increased compile times.\n-Runtime performance obeys 80%/20% rule -- only a small fraction of code is hot.\n-Compile time **does not** obey this rule -- all code has to be compiled.\n-For this reason, avoid making a lot of code type parametric, *especially* on the boundaries between crates.\n+Avoid making a lot of code type parametric, *especially* on the boundaries between crates.\n \n ```rust\n-// Good\n+// GOOD\n fn frbonicate(f: impl FnMut()) {\n     frobnicate_impl(&mut f)\n }\n fn frobnicate_impl(f: &mut dyn FnMut()) {\n     // lots of code\n }\n \n-// Not as good\n+// BAD\n fn frbonicate(f: impl FnMut()) {\n     // lots of code\n }\n@@ -329,15 +351,21 @@ fn frbonicate(f: impl FnMut()) {\n Avoid `AsRef` polymorphism, it pays back only for widely used libraries:\n \n ```rust\n-// Good\n+// GOOD\n fn frbonicate(f: &Path) {\n }\n \n-// Not as good\n+// BAD\n fn frbonicate(f: impl AsRef<Path>) {\n }\n ```\n \n+**Rational:** Rust uses monomorphization to compile generic code, meaning that for each instantiation of a generic functions with concrete types, the function is compiled afresh, *per crate*.\n+This allows for exceptionally good performance, but leads to increased compile times.\n+Runtime performance obeys 80%/20% rule -- only a small fraction of code is hot.\n+Compile time **does not** obey this rule -- all code has to be compiled.\n+\n+\n # Premature Pessimization\n \n ## Avoid Allocations\n@@ -346,45 +374,48 @@ Avoid writing code which is slower than it needs to be.\n Don't allocate a `Vec` where an iterator would do, don't allocate strings needlessly.\n \n ```rust\n-// Good\n+// GOOD\n use itertools::Itertools;\n \n let (first_word, second_word) = match text.split_ascii_whitespace().collect_tuple() {\n     Some(it) => it,\n     None => return,\n }\n \n-// Not as good\n+// BAD\n let words = text.split_ascii_whitespace().collect::<Vec<_>>();\n if words.len() != 2 {\n     return\n }\n ```\n \n+**Rational:** not allocating is almost often faster.\n+\n ## Push Allocations to the Call Site\n \n If allocation is inevitable, let the caller allocate the resource:\n \n ```rust\n-// Good\n+// GOOD\n fn frobnicate(s: String) {\n     ...\n }\n \n-// Not as good\n+// BAD\n fn frobnicate(s: &str) {\n     let s = s.to_string();\n     ...\n }\n ```\n \n-This is better because it reveals the costs.\n+**Rational:** reveals the costs.\n It is also more efficient when the caller already owns the allocation.\n \n ## Collection types\n \n Prefer `rustc_hash::FxHashMap` and `rustc_hash::FxHashSet` instead of the ones in `std::collections`.\n-They use a hasher that's slightly faster and using them consistently will reduce code size by some small amount.\n+\n+**Rational:** they use a hasher that's significantly faster and using them consistently will reduce code size by some small amount.\n \n # Style\n \n@@ -393,6 +424,9 @@ They use a hasher that's slightly faster and using them consistently will reduce\n Separate import groups with blank lines.\n Use one `use` per crate.\n \n+Module declarations come before the imports.\n+Order them in \"suggested reading order\" for a person new to the code base.\n+\n ```rust\n mod x;\n mod y;\n@@ -411,46 +445,45 @@ use crate::{}\n use super::{}\n ```\n \n-Module declarations come before the imports.\n-Order them in \"suggested reading order\" for a person new to the code base.\n+**Rational:** consistency.\n+Reading order is important for new contributors.\n+Grouping by crate allows to spot unwanted dependencies easier.\n \n ## Import Style\n \n Qualify items from `hir` and `ast`.\n \n ```rust\n-// Good\n+// GOOD\n use syntax::ast;\n \n-fn frobnicate(func: hir::Function, strukt: ast::StructDef) {}\n+fn frobnicate(func: hir::Function, strukt: ast::Struct) {}\n \n-// Not as good\n+// BAD\n use hir::Function;\n-use syntax::ast::StructDef;\n+use syntax::ast::Struct;\n \n-fn frobnicate(func: Function, strukt: StructDef) {}\n+fn frobnicate(func: Function, strukt: Struct) {}\n ```\n \n-Avoid local `use MyEnum::*` imports.\n-\n-Prefer `use crate::foo::bar` to `use super::bar`.\n+**Rational:** avoids name clashes, makes the layer clear at a glance.\n \n When implementing traits from `std::fmt` or `std::ops`, import the module:\n \n ```rust\n-// Good\n+// GOOD\n use std::fmt;\n \n impl fmt::Display for RenameError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { .. }\n }\n \n-// Not as good\n+// BAD\n impl std::fmt::Display for RenameError {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { .. }\n }\n \n-// Not as good\n+// BAD\n use std::ops::Deref;\n \n impl Deref for Widget {\n@@ -459,6 +492,15 @@ impl Deref for Widget {\n }\n ```\n \n+**Rational:** overall, less typing.\n+Makes it clear that a trait is implemented, rather than used.\n+\n+Avoid local `use MyEnum::*` imports.\n+**Rational:** consistency.\n+\n+Prefer `use crate::foo::bar` to `use super::bar` or `use self::bar::baz`.\n+**Rational:** consistency, this is the style which works in all cases.\n+\n ## Order of Items\n \n Optimize for the reader who sees the file for the first time, and wants to get a general idea about what's going on.\n@@ -467,7 +509,7 @@ People read things from top to bottom, so place most important things first.\n Specifically, if all items except one are private, always put the non-private item on top.\n \n ```rust\n-// Good\n+// GOOD\n pub(crate) fn frobnicate() {\n     Helper::act()\n }\n@@ -481,7 +523,7 @@ impl Helper {\n     }\n }\n \n-// Not as good\n+// BAD\n #[derive(Default)]\n struct Helper { stuff: i32 }\n \n@@ -497,12 +539,11 @@ impl Helper {\n ```\n \n If there's a mixture of private and public items, put public items first.\n-If function bodies are folded in the editor, the source code should read as documentation for the public API.\n \n-Put `struct`s and `enum`s first, functions and impls last. Order types declarations in top-down manner.\n+Put `struct`s and `enum`s first, functions and impls last. Order type declarations in top-down manner.\n \n ```rust\n-// Good\n+// GOOD\n struct Parent {\n     children: Vec<Child>\n }\n@@ -515,7 +556,7 @@ impl Parent {\n impl Child {\n }\n \n-// Not as good\n+// BAD\n struct Child;\n \n impl Child {\n@@ -529,6 +570,9 @@ impl Parent {\n }\n ```\n \n+**Rational:** easier to get the sense of the API by visually scanning the file.\n+If function bodies are folded in the editor, the source code should read as documentation for the public API.\n+\n ## Variable Naming\n \n Use boring and long names for local variables ([yay code completion](https://github.com/rust-analyzer/rust-analyzer/pull/4162#discussion_r417130973)).\n@@ -556,12 +600,14 @@ enum   -> enum_\n mod    -> module\n ```\n \n+**Rationale:** consistency.\n+\n ## Early Returns\n \n Do use early returns\n \n ```rust\n-// Good\n+// GOOD\n fn foo() -> Option<Bar> {\n     if !condition() {\n         return None;\n@@ -570,7 +616,7 @@ fn foo() -> Option<Bar> {\n     Some(...)\n }\n \n-// Not as good\n+// BAD\n fn foo() -> Option<Bar> {\n     if condition() {\n         Some(...)\n@@ -580,20 +626,26 @@ fn foo() -> Option<Bar> {\n }\n ```\n \n+**Rational:** reduce congnitive stack usage.\n+\n ## Comparisons\n \n Use `<`/`<=`, avoid `>`/`>=`.\n-Less-then comparisons are more intuitive, they correspond spatially to [real line](https://en.wikipedia.org/wiki/Real_line)\n \n ```rust\n-// Good\n+// GOOD\n assert!(lo <= x && x <= hi);\n \n-// Not as good\n+// BAD\n assert!(x >= lo && x <= hi>);\n ```\n \n+**Rational:** Less-then comparisons are more intuitive, they correspond spatially to [real line](https://en.wikipedia.org/wiki/Real_line).\n+\n+\n ## Documentation\n \n For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n If the line is too long, you want to split the sentence in two :-)\n+\n+**Rational:** much easier to edit the text and read the diff."}]}