{"sha": "05c8cc70c90032d578606e811bbb1266cd8d2fcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YzhjYzcwYzkwMDMyZDU3ODYwNmU4MTFiYmIxMjY2Y2Q4ZDJmY2Q=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-20T22:38:41Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: rework file io.. support [p]read,[p]write, impl seek/tell + more tests", "tree": {"sha": "26d35271abb9c78c159499477956fe2aba0d60c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d35271abb9c78c159499477956fe2aba0d60c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05c8cc70c90032d578606e811bbb1266cd8d2fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05c8cc70c90032d578606e811bbb1266cd8d2fcd", "html_url": "https://github.com/rust-lang/rust/commit/05c8cc70c90032d578606e811bbb1266cd8d2fcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05c8cc70c90032d578606e811bbb1266cd8d2fcd/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48d67610285b423e806e0c44be43d01d5c1a7dbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/48d67610285b423e806e0c44be43d01d5c1a7dbc", "html_url": "https://github.com/rust-lang/rust/commit/48d67610285b423e806e0c44be43d01d5c1a7dbc"}], "stats": {"total": 267, "additions": 214, "deletions": 53}, "files": [{"sha": "edc2953a4dd9cb6f3c397848bee5ac1e3ca2e942", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 124, "deletions": 16, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=05c8cc70c90032d578606e811bbb1266cd8d2fcd", "patch": "@@ -11,16 +11,15 @@\n use prelude::*;\n use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n-use super::SeekStyle;\n-use rt::rtio::{RtioFileDescriptor, IoFactory, IoFactoryObject};\n+use super::{SeekSet, SeekStyle};\n+use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n use rt::io::{io_error, read_error, EndOfFile};\n use rt::local::Local;\n use rt::test::*;\n use libc::{O_RDWR, O_RDONLY, O_WRONLY, S_IWUSR, S_IRUSR,\n            O_CREAT, O_TRUNC, O_APPEND};\n \n-/// # FIXME #7785\n-/// * Ugh, this is ridiculous. What is the best way to represent these options?\n+/// Instructions on how to open a file and return a `FileStream`.\n enum FileMode {\n     /// Opens an existing file. IoError if file does not exist.\n     Open,\n@@ -36,15 +35,29 @@ enum FileMode {\n     CreateOrTruncate,\n }\n \n+/// How should the file be opened? `FileStream`s opened with `Read` will\n+/// raise an `io_error` condition if written to.\n enum FileAccess {\n     Read,\n     Write,\n     ReadWrite\n }\n \n+/// Abstraction representing *positional* access to a file. In this case,\n+/// *positional* refers to it keeping an encounter *cursor* of where in the\n+/// file a subsequent `read` or `write` will begin from. Users of a `FileStream`\n+/// can `seek` to move the cursor to a given location *within the bounds of the\n+/// file* and can ask to have the `FileStream` `tell` them the location, in\n+/// bytes, of the cursor.\n+///\n+/// This abstraction is roughly modeled on the access workflow as represented\n+/// by `open(2)`, `read(2)`, `write(2)` and friends.\n+///\n+/// The `open` and `unlink` static methods are provided to manage creation/removal\n+/// of files. All other methods operatin on an instance of `FileStream`.\n pub struct FileStream {\n-    fd: ~RtioFileDescriptor,\n-    last_nread: int\n+    fd: ~RtioFileStream,\n+    last_nread: int,\n }\n \n impl FileStream {\n@@ -101,7 +114,7 @@ impl FileStream {\n \n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.fd.read(buf, 0) {\n+        match self.fd.read(buf) {\n             Ok(read) => {\n                 self.last_nread = read;\n                 match read {\n@@ -126,21 +139,54 @@ impl Reader for FileStream {\n \n impl Writer for FileStream {\n     fn write(&mut self, buf: &[u8]) {\n-        match self.fd.write(buf, 0) {\n+        match self.fd.write(buf) {\n             Ok(_) => (),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n             }\n         }\n     }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) {\n+        match self.fd.flush() {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                read_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n }\n \n impl Seek for FileStream {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 {\n+        let res = self.fd.tell();\n+        match res {\n+            Ok(cursor) => cursor,\n+            Err(ioerr) => {\n+                read_error::cond.raise(ioerr);\n+                return -1;\n+            }\n+        }\n+    }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        use libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n+        let whence = match style {\n+            SeekSet => SEEK_SET,\n+            SeekCur => SEEK_CUR,\n+            SeekEnd => SEEK_END\n+        } as i64;\n+        match self.fd.seek(pos, whence) {\n+            Ok(_) => {\n+                // successful seek resets EOF indocator\n+                self.last_nread = -1;\n+                ()\n+            },\n+            Err(ioerr) => {\n+                read_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n }\n \n fn file_test_smoke_test_impl() {\n@@ -166,7 +212,7 @@ fn file_test_smoke_test_impl() {\n }\n \n #[test]\n-fn file_test_smoke_test() {\n+fn file_test_io_smoke_test() {\n     file_test_smoke_test_impl();\n }\n \n@@ -184,17 +230,15 @@ fn file_test_invalid_path_opened_without_create_should_raise_condition_impl() {\n     }\n }\n #[test]\n-fn file_test_invalid_path_opened_without_create_should_raise_condition() {\n+fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n     file_test_invalid_path_opened_without_create_should_raise_condition_impl();\n }\n \n fn file_test_unlinking_invalid_path_should_raise_condition_impl() {\n-    use io;\n     do run_in_newsched_task {\n         let filename = &Path(\"./another_file_that_does_not_exist.txt\");\n         let mut called = false;\n         do io_error::cond.trap(|e| {\n-            io::println(fmt!(\"condition kind: %?\", e.kind));\n             called = true;\n         }).inside {\n             FileStream::unlink(filename);\n@@ -203,6 +247,70 @@ fn file_test_unlinking_invalid_path_should_raise_condition_impl() {\n     }\n }\n #[test]\n-fn file_test_unlinking_invalid_path_should_raise_condition() {\n+fn file_test_iounlinking_invalid_path_should_raise_condition() {\n     file_test_unlinking_invalid_path_should_raise_condition_impl();\n }\n+\n+fn file_test_io_non_positional_read_impl() {\n+    do run_in_newsched_task {\n+        use str;\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 8];\n+        let filename = &Path(\"./rt_io_file_test_positional.txt\");\n+        {\n+            let mut rw_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            {\n+                let read_buf = read_mem.mut_slice(0, 4);\n+                read_stream.read(read_buf);\n+            }\n+            {\n+                let read_buf = read_mem.mut_slice(4, 8);\n+                read_stream.read(read_buf);\n+            }\n+        }\n+        FileStream::unlink(filename);\n+        let read_str = str::from_bytes(read_mem);\n+        assert!(read_str == message.to_owned());\n+    }\n+}\n+\n+#[test]\n+fn file_test_io_non_positional_read() {\n+    file_test_io_non_positional_read_impl();\n+}\n+\n+fn file_test_io_seeking_impl() {\n+    do run_in_newsched_task {\n+        use str;\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 4];\n+        let set_cursor = 4 as u64;\n+        let mut tell_pos_pre_read;\n+        let mut tell_pos_post_read;\n+        let filename = &Path(\"./rt_io_file_test_seeking.txt\");\n+        {\n+            let mut rw_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            read_stream.seek(set_cursor as i64, SeekSet);\n+            tell_pos_pre_read = read_stream.tell();\n+            read_stream.read(read_mem);\n+            tell_pos_post_read = read_stream.tell();\n+        }\n+        FileStream::unlink(filename);\n+        let read_str = str::from_bytes(read_mem);\n+        assert!(read_str == message.slice(4, 8).to_owned());\n+        assert!(tell_pos_pre_read == set_cursor);\n+        assert!(tell_pos_post_read == message.len() as u64);\n+    }\n+}\n+#[test]\n+fn file_test_io_seek_and_tell_smoke_test() {\n+    file_test_io_seeking_impl();\n+}"}, {"sha": "23b8017bc512c6c15a4586fb693c20923273e7c3", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=05c8cc70c90032d578606e811bbb1266cd8d2fcd", "patch": "@@ -461,6 +461,7 @@ pub enum SeekStyle {\n /// # XXX\n /// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n+    /// Return position of file cursor in the stream\n     fn tell(&self) -> u64;\n \n     /// Seek to an offset in a stream"}, {"sha": "3a14f679fa767f858c08d771b28caecad8120eb4", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=05c8cc70c90032d578606e811bbb1266cd8d2fcd", "patch": "@@ -66,9 +66,9 @@ pub trait IoFactory {\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileDescriptor;\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n     fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode:int)\n-        -> Result<~RtioFileDescriptor, IoError>;\n+        -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n }\n \n@@ -113,7 +113,12 @@ pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n }\n \n-pub trait RtioFileDescriptor {\n-    fn read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError>;\n-    fn write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError>;\n+pub trait RtioFileStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError>;\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError>;\n+    fn seek(&mut self, pos: i64, whence: i64) -> Result<(), IoError>;\n+    fn tell(&self) -> Result<u64, IoError>;\n+    fn flush(&mut self) -> Result<(), IoError>;\n }"}, {"sha": "2a62c782d0ba129b24b69d0cf77272a78537fb95", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 79, "deletions": 32, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c8cc70c90032d578606e811bbb1266cd8d2fcd/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=05c8cc70c90032d578606e811bbb1266cd8d2fcd", "patch": "@@ -31,6 +31,7 @@ use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use unstable::sync::Exclusive;\n use super::super::io::support::PathLike;\n+use libc::{lseek, c_long, SEEK_CUR};\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -458,30 +459,31 @@ impl IoFactory for UvIoFactory {\n         Ok(~UvTimer::new(watcher, home))\n     }\n \n-    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileDescriptor {\n-        ~UvFileDescriptor {\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n+        ~UvFileStream {\n             loop_: Loop{handle:self.uv_loop().native_handle()},\n             fd: file::FileDescriptor(fd),\n-            close_on_drop: close_on_drop\n-        } as ~RtioFileDescriptor\n+            close_on_drop: close_on_drop,\n+        } as ~RtioFileStream\n     }\n \n     fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode: int)\n-        -> Result<~RtioFileDescriptor, IoError> {\n+        -> Result<~RtioFileStream, IoError> {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioFileDescriptor, IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioFileStream,\n+                                           IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let path = path_cell.take();\n             do file::FileDescriptor::open(loop_, path, flags, mode) |req,err| {\n                 if err.is_none() {\n-                    let res = Ok(~UvFileDescriptor {\n+                    let res = Ok(~UvFileStream {\n                         loop_: loop_,\n                         fd: file::FileDescriptor(req.get_result()),\n-                        close_on_drop: true} as ~RtioFileDescriptor);\n+                        close_on_drop: true} as ~RtioFileStream);\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler = Local::take::<Scheduler>();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n@@ -1056,32 +1058,14 @@ impl RtioTimer for UvTimer {\n     }\n }\n \n-pub struct UvFileDescriptor {\n+pub struct UvFileStream {\n     loop_: Loop,\n     fd: file::FileDescriptor,\n     close_on_drop: bool\n }\n \n-impl UvFileDescriptor {\n-}\n-\n-impl Drop for UvFileDescriptor {\n-    fn drop(&self) {\n-        if self.close_on_drop {\n-            let scheduler = Local::take::<Scheduler>();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self.fd.close(self.loop_) |_,_| {\n-                    let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        }\n-    }\n-}\n-\n-impl RtioFileDescriptor for UvFileDescriptor {\n-    fn read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+impl UvFileStream {\n+    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n         let scheduler = Local::take::<Scheduler>();\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n@@ -1101,7 +1085,7 @@ impl RtioFileDescriptor for UvFileDescriptor {\n         };\n         result_cell.take()\n     }\n-    fn write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n         let scheduler = Local::take::<Scheduler>();\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n@@ -1123,6 +1107,69 @@ impl RtioFileDescriptor for UvFileDescriptor {\n     }\n }\n \n+impl Drop for UvFileStream {\n+    fn drop(&self) {\n+        if self.close_on_drop {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self.fd.close(self.loop_) |_,_| {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        }\n+    }\n+}\n+\n+impl RtioFileStream for UvFileStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.base_read(buf, -1)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.base_write(buf, -1)\n+    }\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.base_read(buf, offset as i64)\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.base_write(buf, offset as i64)\n+    }\n+    fn seek(&mut self, pos: i64, whence: i64) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            match lseek((*self.fd), pos as c_long, whence as c_int) {\n+                -1 => {\n+                    Err(IoError {\n+                        kind: OtherIoError,\n+                        desc: \"Failed to lseek.\",\n+                        detail: None\n+                    })\n+                },\n+                _ => Ok(())\n+            }\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            match lseek((*self.fd), 0, SEEK_CUR) {\n+                -1 => {\n+                    Err(IoError {\n+                        kind: OtherIoError,\n+                        desc: \"Failed to lseek, needed to tell().\",\n+                        detail: None\n+                    })\n+                },\n+                n=> Ok(n as u64)\n+            }\n+        }\n+    }\n+    fn flush(&mut self) -> Result<(), IoError> {\n+        Ok(())\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n@@ -1647,12 +1694,12 @@ fn file_test_uvio_full_simple_impl() {\n         {\n             let mut fd = (*io).fs_open(&Path(path), create_flags as int, mode as int).unwrap();\n             let write_buf = write_val.as_bytes();\n-            fd.write(write_buf, 0);\n+            fd.write(write_buf);\n         }\n         {\n             let mut fd = (*io).fs_open(&Path(path), ro_flags as int, mode as int).unwrap();\n             let mut read_vec = [0, .. 1028];\n-            let nread = fd.read(read_vec, 0).unwrap();\n+            let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_bytes(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }"}]}