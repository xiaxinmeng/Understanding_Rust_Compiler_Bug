{"sha": "cf5068bd623a68cf8d190159574839c35197cb06", "node_id": "C_kwDOAAsO6NoAKGNmNTA2OGJkNjIzYTY4Y2Y4ZDE5MDE1OTU3NDgzOWMzNTE5N2NiMDY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-18T23:00:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-18T23:00:29Z"}, "message": "Rollup merge of #107004 - compiler-errors:new-solver-new-candidates-2, r=lcnr\n\nImplement some candidates for the new solver (redux)\n\nBased on #106718, so the diff is hard to read without it. See [here](https://github.com/rust-lang/rust/compare/98700cf481bce946bff316b56836cfffd885127b...compiler-errors:rust:new-solver-new-candidates-2) for an easier view until that one lands.\n\nOf note:\n* 44af916020fb43c12070125c45b6dee4ec303bbc fixes a bug where we need to make the query response *inside* of a probe, or else we make no inference progress (I think)\n* 50daad5acd2f163d03e7ffab942534f09bc36e2e implements `consider_assumption` for traits and predicates. I'm not sure if using `sup` here is necessary or if `eq` is fine.\n* We decided that all of the `instantiate_constituent_tys_for_*` functions are verbose but ok, since they need to be exhaustive and the logic between each of them is not similar enough, right?\n\nr? ``@lcnr``", "tree": {"sha": "455223bf03984d2dfb16057b63778768beb159aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/455223bf03984d2dfb16057b63778768beb159aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf5068bd623a68cf8d190159574839c35197cb06", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjyHoNCRBK7hj4Ov3rIwAAgjoIAGTwReI97vuxwMIcLXBFvLPx\nUyvJ1KbpqyfXyO0tUIs5z4SqP/9k/abX39wW4dXblZq9i/q0VKlGBXnbo3Hkzg6L\nGHJLpgiA6bI/znB9l/9TNSsQCSgCd8gEjVRv2+hwkC2TjNdiJezstoXrrnFKHHDy\nJ0pNBdv+5I0v6Ej2o7occYPYGUN7m9UxcGvgvr7qW7v0LTwybool+rxWdrD1qt4C\nd4+JU2xfFlp51I81X9ac1W/kpKau839IZEmHCt2hFliUcEzGypdxnDx+pIm0HDh/\n28eHf3mP3aAwkOblIVAX6CtE4I3fRzCWjCMHvE/1hk6lfXizDPXdxscSHOUTZyE=\n=gqkO\n-----END PGP SIGNATURE-----\n", "payload": "tree 455223bf03984d2dfb16057b63778768beb159aa\nparent a637e2a950d3274755233efbace05f837a4c5d17\nparent f672436f04938da11c74664f6665f28018f0a390\nauthor Michael Goulet <michael@errs.io> 1674082829 -0500\ncommitter GitHub <noreply@github.com> 1674082829 -0500\n\nRollup merge of #107004 - compiler-errors:new-solver-new-candidates-2, r=lcnr\n\nImplement some candidates for the new solver (redux)\n\nBased on #106718, so the diff is hard to read without it. See [here](https://github.com/rust-lang/rust/compare/98700cf481bce946bff316b56836cfffd885127b...compiler-errors:rust:new-solver-new-candidates-2) for an easier view until that one lands.\n\nOf note:\n* 44af916020fb43c12070125c45b6dee4ec303bbc fixes a bug where we need to make the query response *inside* of a probe, or else we make no inference progress (I think)\n* 50daad5acd2f163d03e7ffab942534f09bc36e2e implements `consider_assumption` for traits and predicates. I'm not sure if using `sup` here is necessary or if `eq` is fine.\n* We decided that all of the `instantiate_constituent_tys_for_*` functions are verbose but ok, since they need to be exhaustive and the logic between each of them is not similar enough, right?\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5068bd623a68cf8d190159574839c35197cb06", "html_url": "https://github.com/rust-lang/rust/commit/cf5068bd623a68cf8d190159574839c35197cb06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf5068bd623a68cf8d190159574839c35197cb06/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a637e2a950d3274755233efbace05f837a4c5d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/a637e2a950d3274755233efbace05f837a4c5d17", "html_url": "https://github.com/rust-lang/rust/commit/a637e2a950d3274755233efbace05f837a4c5d17"}, {"sha": "f672436f04938da11c74664f6665f28018f0a390", "url": "https://api.github.com/repos/rust-lang/rust/commits/f672436f04938da11c74664f6665f28018f0a390", "html_url": "https://github.com/rust-lang/rust/commit/f672436f04938da11c74664f6665f28018f0a390"}], "stats": {"total": 489, "additions": 442, "deletions": 47}, "files": [{"sha": "d681df14af10a969058f491ea9e4c2cece559105", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -2357,6 +2357,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.trait_def(trait_def_id).has_auto_impl\n     }\n \n+    /// Returns `true` if this is a trait alias.\n+    pub fn trait_is_alias(self, trait_def_id: DefId) -> bool {\n+        self.def_kind(trait_def_id) == DefKind::TraitAlias\n+    }\n+\n     pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n         self.trait_is_auto(trait_def_id) || self.lang_items().sized_trait() == Some(trait_def_id)\n     }"}, {"sha": "2336fb53aec282a8e902bc408836033dfd42c80d", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 86, "deletions": 17, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -1,9 +1,10 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalResponse, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::util::elaborate_predicates;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n@@ -89,19 +90,35 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         impl_def_id: DefId,\n-    ) -> Result<Certainty, NoSolution>;\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_auto_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_trait_alias_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n \n     fn consider_builtin_sized_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-    ) -> Result<Certainty, NoSolution>;\n+    ) -> QueryResult<'tcx>;\n \n-    fn consider_assumption(\n+    fn consider_builtin_copy_clone_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> Result<Certainty, NoSolution>;\n+    ) -> QueryResult<'tcx>;\n }\n+\n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn assemble_and_evaluate_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n@@ -119,6 +136,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.assemble_alias_bound_candidates(goal, &mut candidates);\n \n+        self.assemble_object_bound_candidates(goal, &mut candidates);\n+\n         candidates\n     }\n \n@@ -180,9 +199,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         tcx.for_each_relevant_impl(\n             goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n-            |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id)\n-                .and_then(|certainty| self.make_canonical_response(certainty))\n-            {\n+            |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id) {\n                 Ok(result) => candidates\n                     .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),\n                 Err(NoSolution) => (),\n@@ -197,13 +214,21 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) {\n         let lang_items = self.tcx().lang_items();\n         let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n-        let result = if lang_items.sized_trait() == Some(trait_def_id) {\n+        let result = if self.tcx().trait_is_auto(trait_def_id) {\n+            G::consider_auto_trait_candidate(self, goal)\n+        } else if self.tcx().trait_is_alias(trait_def_id) {\n+            G::consider_trait_alias_candidate(self, goal)\n+        } else if lang_items.sized_trait() == Some(trait_def_id) {\n             G::consider_builtin_sized_candidate(self, goal)\n+        } else if lang_items.copy_trait() == Some(trait_def_id)\n+            || lang_items.clone_trait() == Some(trait_def_id)\n+        {\n+            G::consider_builtin_copy_clone_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };\n \n-        match result.and_then(|certainty| self.make_canonical_response(certainty)) {\n+        match result {\n             Ok(result) => {\n                 candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n             }\n@@ -217,9 +242,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n-            match G::consider_assumption(self, goal, assumption)\n-                .and_then(|certainty| self.make_canonical_response(certainty))\n-            {\n+            match G::consider_assumption(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n                 }\n@@ -268,14 +291,60 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             .subst_iter_copied(self.tcx(), alias_ty.substs)\n             .enumerate()\n         {\n-            match G::consider_assumption(self, goal, assumption)\n-                .and_then(|certainty| self.make_canonical_response(certainty))\n-            {\n+            match G::consider_assumption(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound(i), result })\n                 }\n                 Err(NoSolution) => (),\n             }\n         }\n     }\n+\n+    fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let self_ty = goal.predicate.self_ty();\n+        let bounds = match *self_ty.kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Alias(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Param(_)\n+            | ty::Placeholder(..)\n+            | ty::Infer(_)\n+            | ty::Error(_) => return,\n+            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Dynamic(bounds, ..) => bounds,\n+        };\n+\n+        let tcx = self.tcx();\n+        for assumption in\n+            elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n+        {\n+            match G::consider_assumption(self, goal, assumption.predicate) {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n }"}, {"sha": "42f597c781d257e0f97506d931d5121b5d5a83fd", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -1,10 +1,10 @@\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_span::DUMMY_SP;\n \n use super::Goal;\n@@ -25,6 +25,11 @@ pub(super) trait InferCtxtExt<'tcx> {\n         lhs: T,\n         rhs: T,\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n+\n+    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T;\n }\n \n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n@@ -59,4 +64,15 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 NoSolution\n             })\n     }\n+\n+    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T {\n+        self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            value,\n+        )\n+    }\n }"}, {"sha": "32eb84635b53684c0d122f746192eefd8ee25d22", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -313,6 +313,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         })\n     }\n+\n+    fn evaluate_all_and_make_canonical_response(\n+        &mut self,\n+        goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> QueryResult<'tcx> {\n+        self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n+    }\n }\n \n #[instrument(level = \"debug\", skip(infcx), ret)]"}, {"sha": "00c7edf0ef8a354d6a038725c9aadf7e62b0830d", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -191,7 +191,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) -> Result<Certainty, NoSolution> {\n+    ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n \n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n@@ -229,7 +229,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 impl_def_id\n             )? else {\n                 let certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n-                return Ok(trait_ref_certainty.unify_and(certainty));\n+                return ecx.make_canonical_response(trait_ref_certainty.unify_and(certainty));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -286,27 +286,70 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let rhs_certainty =\n                 ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n-            Ok(trait_ref_certainty.unify_and(rhs_certainty))\n+            ecx.make_canonical_response(trait_ref_certainty.unify_and(rhs_certainty))\n         })\n     }\n \n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+            ecx.infcx.probe(|_| {\n+                let assumption_projection_pred =\n+                    ecx.infcx.instantiate_bound_vars_with_infer(poly_projection_pred);\n+                let nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                // The term of our goal should be fully unconstrained, so this should never fail.\n+                //\n+                // It can however be ambiguous when the resolved type is a projection.\n+                let nested_goals = ecx\n+                    .infcx\n+                    .eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n+                    .expect(\"failed to unify with unconstrained term\");\n+                let rhs_certainty = ecx\n+                    .evaluate_all(nested_goals)\n+                    .expect(\"failed to unify with unconstrained term\");\n+\n+                ecx.make_canonical_response(subst_certainty.unify_and(rhs_certainty))\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn consider_auto_trait_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"auto traits do not have associated types: {:?}\", goal);\n+    }\n+\n+    fn consider_trait_alias_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"trait aliases do not have associated types: {:?}\", goal);\n+    }\n+\n     fn consider_builtin_sized_candidate(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-    ) -> Result<Certainty, NoSolution> {\n+    ) -> QueryResult<'tcx> {\n         bug!(\"`Sized` does not have an associated type: {:?}\", goal);\n     }\n \n-    fn consider_assumption(\n+    fn consider_builtin_copy_clone_candidate(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> Result<Certainty, NoSolution> {\n-        if let Some(_poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n-            unimplemented!()\n-        } else {\n-            Err(NoSolution)\n-        }\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Copy`/`Clone` does not have an associated type: {:?}\", goal);\n     }\n }\n "}, {"sha": "1ebcfd03c14ea1db6b6f790568f3de23466b695c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 91, "deletions": 15, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -4,14 +4,17 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::TraitPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n+mod structural_traits;\n+\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n@@ -29,7 +32,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) -> Result<Certainty, NoSolution> {\n+    ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -53,31 +56,104 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n             nested_goals.extend(where_clause_bounds);\n-            ecx.evaluate_all(nested_goals)\n+            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n         })\n     }\n \n-    fn consider_builtin_sized_candidate(\n-        _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n-    ) -> Result<Certainty, NoSolution> {\n-        unimplemented!();\n-    }\n-\n     fn consider_assumption(\n-        _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> Result<Certainty, NoSolution> {\n-        if let Some(_poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n-            unimplemented!()\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+            // FIXME: Constness and polarity\n+            ecx.infcx.probe(|_| {\n+                let assumption_trait_pred =\n+                    ecx.infcx.instantiate_bound_vars_with_infer(poly_trait_pred);\n+                let nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.trait_ref,\n+                    assumption_trait_pred.trait_ref,\n+                )?;\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            })\n         } else {\n             Err(NoSolution)\n         }\n     }\n+\n+    fn consider_auto_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_auto_trait,\n+        )\n+    }\n+\n+    fn consider_trait_alias_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n+\n+        ecx.infcx.probe(|_| {\n+            let nested_obligations = tcx\n+                .predicates_of(goal.predicate.def_id())\n+                .instantiate(tcx, goal.predicate.trait_ref.substs);\n+            ecx.evaluate_all_and_make_canonical_response(\n+                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n+            )\n+        })\n+    }\n+\n+    fn consider_builtin_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_sized_trait,\n+        )\n+    }\n+\n+    fn consider_builtin_copy_clone_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n+        )\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    /// Convenience function for traits that are structural, i.e. that only\n+    /// have nested subgoals that only change the self type. Unlike other\n+    /// evaluate-like helpers, this does a probe, so it doesn't need to be\n+    /// wrapped in one.\n+    fn probe_and_evaluate_goal_for_constituent_tys(\n+        &mut self,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        constituent_tys: impl Fn(&InferCtxt<'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n+    ) -> QueryResult<'tcx> {\n+        self.infcx.probe(|_| {\n+            self.evaluate_all_and_make_canonical_response(\n+                constituent_tys(self.infcx, goal.predicate.self_ty())?\n+                    .into_iter()\n+                    .map(|ty| {\n+                        goal.with(\n+                            self.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n+                        )\n+                    })\n+                    .collect(),\n+            )\n+        })\n+    }\n+\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,"}, {"sha": "bbc0c77253278aa208011e3b9a470bc2d89078d2", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5068bd623a68cf8d190159574839c35197cb06/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=cf5068bd623a68cf8d190159574839c35197cb06", "patch": "@@ -0,0 +1,179 @@\n+use rustc_hir::{Movability, Mutability};\n+use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n+use rustc_middle::ty::{self, Ty};\n+\n+// Calculates the constituent types of a type for `auto trait` purposes.\n+//\n+// For types with an \"existential\" binder, i.e. generator witnesses, we also\n+// instantiate the binder with placeholders eagerly.\n+pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    let tcx = infcx.tcx;\n+    match *ty.kind() {\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Str\n+        | ty::Error(_)\n+        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Never\n+        | ty::Char => Ok(vec![]),\n+\n+        ty::Placeholder(..)\n+        | ty::Dynamic(..)\n+        | ty::Param(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(ty::Projection, ..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_)) => {\n+            // FIXME: Do we need to mark anything as ambiguous here? Yeah?\n+            Err(NoSolution)\n+        }\n+\n+        ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n+            Ok(vec![element_ty])\n+        }\n+\n+        ty::Array(element_ty, _) | ty::Slice(element_ty) => Ok(vec![element_ty]),\n+\n+        ty::Tuple(ref tys) => {\n+            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+            Ok(tys.iter().collect())\n+        }\n+\n+        ty::Closure(_, ref substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, ref substs, _) => {\n+            let generator_substs = substs.as_generator();\n+            Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+\n+        // For `PhantomData<T>`, we pass `T`.\n+        ty::Adt(def, substs) if def.is_phantom_data() => Ok(vec![substs.type_at(0)]),\n+\n+        ty::Adt(def, substs) => Ok(def.all_fields().map(|f| f.ty(tcx, substs)).collect()),\n+\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+            // We can resolve the `impl Trait` to its concrete type,\n+            // which enforces a DAG between the functions requiring\n+            // the auto trait bounds in question.\n+            Ok(vec![tcx.bound_type_of(def_id).subst(tcx, substs)])\n+        }\n+    }\n+}\n+\n+pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    match *ty.kind() {\n+        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::RawPtr(..)\n+        | ty::Char\n+        | ty::Ref(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::Array(..)\n+        | ty::Closure(..)\n+        | ty::Never\n+        | ty::Dynamic(_, _, ty::DynStar)\n+        | ty::Error(_) => Ok(vec![]),\n+\n+        ty::Str\n+        | ty::Slice(_)\n+        | ty::Dynamic(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(..)\n+        | ty::Param(_) => Err(NoSolution),\n+\n+        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+\n+        ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::Tuple(tys) => Ok(tys.to_vec()),\n+\n+        ty::Adt(def, substs) => {\n+            let sized_crit = def.sized_constraint(infcx.tcx);\n+            Ok(sized_crit\n+                .0\n+                .iter()\n+                .map(|ty| sized_crit.rebind(*ty).subst(infcx.tcx, substs))\n+                .collect())\n+        }\n+    }\n+}\n+\n+pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    match *ty.kind() {\n+        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Error(_) => Ok(vec![]),\n+\n+        // Implementations are provided in core\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::Char\n+        | ty::RawPtr(..)\n+        | ty::Never\n+        | ty::Ref(_, _, Mutability::Not)\n+        | ty::Array(..) => Err(NoSolution),\n+\n+        ty::Dynamic(..)\n+        | ty::Str\n+        | ty::Slice(_)\n+        | ty::Generator(_, _, Movability::Static)\n+        | ty::Foreign(..)\n+        | ty::Ref(_, _, Mutability::Mut)\n+        | ty::Adt(_, _)\n+        | ty::Alias(_, _)\n+        | ty::Param(_) => Err(NoSolution),\n+\n+        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+\n+        ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::Tuple(tys) => Ok(tys.to_vec()),\n+\n+        ty::Closure(_, substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, substs, Movability::Movable) => {\n+            if infcx.tcx.features().generator_clone {\n+                let generator = substs.as_generator();\n+                Ok(vec![generator.tupled_upvars_ty(), generator.witness()])\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+    }\n+}"}]}