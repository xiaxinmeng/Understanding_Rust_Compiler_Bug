{"sha": "87af3f3ccab541a59996f289c39ccf7ddad1e29f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YWYzZjNjY2FiNTQxYTU5OTk2ZjI4OWMzOWNjZjdkZGFkMWUyOWY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-14T18:10:32Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-14T18:10:32Z"}, "message": "Dead code elimination", "tree": {"sha": "13e33b96f013ea367e032bb53975caf795ca30c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13e33b96f013ea367e032bb53975caf795ca30c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87af3f3ccab541a59996f289c39ccf7ddad1e29f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87af3f3ccab541a59996f289c39ccf7ddad1e29f", "html_url": "https://github.com/rust-lang/rust/commit/87af3f3ccab541a59996f289c39ccf7ddad1e29f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87af3f3ccab541a59996f289c39ccf7ddad1e29f/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e38eaed9789a2eb9abc2f767d9487708e17ea3dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e38eaed9789a2eb9abc2f767d9487708e17ea3dd", "html_url": "https://github.com/rust-lang/rust/commit/e38eaed9789a2eb9abc2f767d9487708e17ea3dd"}], "stats": {"total": 42, "additions": 4, "deletions": 38}, "files": [{"sha": "146a007b95d6a4d4968ac41403e7b92d20842697", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87af3f3ccab541a59996f289c39ccf7ddad1e29f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87af3f3ccab541a59996f289c39ccf7ddad1e29f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=87af3f3ccab541a59996f289c39ccf7ddad1e29f", "patch": "@@ -118,13 +118,6 @@ type ty_table = hashmap<ast::def_id, ty::t>;\n type crate_ctxt = {impl_map: resolve::impl_map,\n                    method_map: method_map,\n                    vtable_map: vtable_map,\n-                   // Not at all sure it's right to put these here\n-                   /* node_id for the class this fn is in --\n-                      none if it's not in a class */\n-                   enclosing_class_id: option<ast::node_id>,\n-                   /* map from node_ids for enclosing-class\n-                      vars and methods to types */\n-                   enclosing_class: class_map,\n                    tcx: ty::ctxt};\n \n type class_map = hashmap<ast::node_id, ty::t>;\n@@ -246,8 +239,6 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n     let ccx = @{impl_map: impl_map,\n                 method_map: std::map::int_hash(),\n                 vtable_map: std::map::int_hash(),\n-                enclosing_class_id: none,\n-                enclosing_class: std::map::int_hash(),\n                 tcx: tcx};\n     collect::collect_item_types(ccx, crate);\n     check::check_item_types(ccx, crate);"}, {"sha": "929b5d5641e1a73271abef6b9eaeffe9b1facdb3", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/87af3f3ccab541a59996f289c39ccf7ddad1e29f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87af3f3ccab541a59996f289c39ccf7ddad1e29f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=87af3f3ccab541a59996f289c39ccf7ddad1e29f", "patch": "@@ -320,26 +320,6 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method, self_ty: ty::t) {\n     check_bare_fn(ccx, method.decl, method.body, method.id, some(self_ty));\n }\n \n-fn class_types(ccx: @crate_ctxt, members: [@ast::class_member],\n-               rp: ast::region_param) -> class_map {\n-\n-    let rslt = int_hash::<ty::t>();\n-    let rs = rscope::type_rscope(rp);\n-    for members.each { |m|\n-      alt m.node {\n-         ast::instance_var(_,t,_,id,_) {\n-           rslt.insert(id, ccx.to_ty(rs, t));\n-         }\n-         ast::class_method(mth) {\n-           rslt.insert(mth.id,\n-                       ty::mk_fn(ccx.tcx,\n-                                 collect::ty_of_method(ccx, mth, rp).fty));\n-         }\n-      }\n-    }\n-    rslt\n-}\n-\n fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n                       cm: @ast::class_member) {\n     alt cm.node {\n@@ -368,30 +348,25 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         for ms.each {|m| check_method(ccx, m, self_ty);}\n       }\n       ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n-          let cid = some(it.id), tcx = ccx.tcx;\n+          let tcx = ccx.tcx;\n           let class_t = ty::node_id_to_type(tcx, it.id);\n-          let members_info = class_types(ccx, members, rp);\n-          // can also ditch the enclosing_class stuff once we move to self\n-          // FIXME\n-          let class_ccx = @{enclosing_class_id:cid,\n-                            enclosing_class:members_info with *ccx};\n           // typecheck the ctor\n-          check_bare_fn(class_ccx, ctor.node.dec,\n+          check_bare_fn(ccx, ctor.node.dec,\n                         ctor.node.body, ctor.node.id,\n                         some(class_t));\n           // Write the ctor's self's type\n           write_ty_to_tcx(tcx, ctor.node.self_id, class_t);\n \n           option::iter(m_dtor) {|dtor|\n             // typecheck the dtor\n-           check_bare_fn(class_ccx, ast_util::dtor_dec(),\n+           check_bare_fn(ccx, ast_util::dtor_dec(),\n                            dtor.node.body, dtor.node.id,\n                            some(class_t));\n            // Write the dtor's self's type\n            write_ty_to_tcx(tcx, dtor.node.self_id, class_t);\n           };\n           // typecheck the members\n-          for members.each {|m| check_class_member(class_ccx, class_t, m); }\n+          for members.each {|m| check_class_member(ccx, class_t, m); }\n           // Check that there's at least one field\n           let (fields,_) = split_class_items(members);\n           if fields.len() < 1u {"}]}