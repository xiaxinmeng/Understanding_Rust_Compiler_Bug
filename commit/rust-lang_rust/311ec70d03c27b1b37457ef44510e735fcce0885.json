{"sha": "311ec70d03c27b1b37457ef44510e735fcce0885", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMWVjNzBkMDNjMjdiMWIzNzQ1N2VmNDQ1MTBlNzM1ZmNjZTA4ODU=", "commit": {"author": {"name": "Arnaud", "email": "arnaud.golfouse@free.fr", "date": "2021-01-12T16:22:57Z"}, "committer": {"name": "Arnaud", "email": "arnaud.golfouse@free.fr", "date": "2021-01-12T17:01:36Z"}, "message": "Document vfs public items", "tree": {"sha": "acb0a2ae6a5cca2b6f1fd9eea4ff97cf7ad1de70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb0a2ae6a5cca2b6f1fd9eea4ff97cf7ad1de70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/311ec70d03c27b1b37457ef44510e735fcce0885", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/311ec70d03c27b1b37457ef44510e735fcce0885", "html_url": "https://github.com/rust-lang/rust/commit/311ec70d03c27b1b37457ef44510e735fcce0885", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/311ec70d03c27b1b37457ef44510e735fcce0885/comments", "author": null, "committer": null, "parents": [{"sha": "52fa926f005890f07dffc789c84c2be57a6bdccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/52fa926f005890f07dffc789c84c2be57a6bdccc", "html_url": "https://github.com/rust-lang/rust/commit/52fa926f005890f07dffc789c84c2be57a6bdccc"}], "stats": {"total": 206, "additions": 204, "deletions": 2}, "files": [{"sha": "db15a2a21cd6e99a20a64253425751a7eaa5b310", "filename": "crates/vfs/src/anchored_path.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Fanchored_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Fanchored_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fanchored_path.rs?ref=311ec70d03c27b1b37457ef44510e735fcce0885", "patch": "@@ -26,14 +26,24 @@\n //! from the anchor than.\n use crate::FileId;\n \n+/// Path relative to a file.\n+///\n+/// Owned version of [`AnchoredPath`].\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct AnchoredPathBuf {\n+    /// File that this path is relative to.\n     pub anchor: FileId,\n+    /// Path relative to `anchor`'s containing directory.\n     pub path: String,\n }\n \n+/// Path relative to a file.\n+///\n+/// Borrowed version of [`AnchoredPathBuf`].\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct AnchoredPath<'a> {\n+    /// File that this path is relative to.\n     pub anchor: FileId,\n+    /// Path relative to `anchor`'s containing directory.\n     pub path: &'a str,\n }"}, {"sha": "348b6dbfd8c7cee8aaff8fc8c84841009ca2bf68", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=311ec70d03c27b1b37457ef44510e735fcce0885", "patch": "@@ -9,36 +9,50 @@ use rustc_hash::FxHashMap;\n \n use crate::{AnchoredPath, FileId, Vfs, VfsPath};\n \n+/// A set of [`VfsPath`]s identified by [`FileId`]s.\n #[derive(Default, Clone, Eq, PartialEq)]\n pub struct FileSet {\n     files: FxHashMap<VfsPath, FileId>,\n     paths: FxHashMap<FileId, VfsPath>,\n }\n \n impl FileSet {\n+    /// Returns the number of stored paths.\n     pub fn len(&self) -> usize {\n         self.files.len()\n     }\n+\n+    /// Get the id of the file corresponding to `path`.\n+    ///\n+    /// If either `path`'s [`anchor`](AnchoredPath::anchor) or the resolved path is not in\n+    /// the set, returns [`None`].\n     pub fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         let mut base = self.paths[&path.anchor].clone();\n         base.pop();\n         let path = base.join(path.path)?;\n         self.files.get(&path).copied()\n     }\n \n+    /// Get the id corresponding to `path` if it exists in the set.\n     pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n         self.files.get(path)\n     }\n \n+    /// Get the path corresponding to `file` if it exists in the set.\n     pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n         self.paths.get(file)\n     }\n \n+    /// Insert the `file_id, path` pair into the set.\n+    ///\n+    /// # Note\n+    /// Multiple [`FileId`] can be mapped to the same [`VfsPath`], and vice-versa.\n     pub fn insert(&mut self, file_id: FileId, path: VfsPath) {\n         self.files.insert(path.clone(), file_id);\n         self.paths.insert(file_id, path);\n     }\n \n+    /// Iterate over this set's ids.\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.paths.keys().copied()\n     }\n@@ -50,6 +64,23 @@ impl fmt::Debug for FileSet {\n     }\n }\n \n+/// This contains path prefixes to partition a [`Vfs`] into [`FileSet`]s.\n+///\n+/// # Example\n+/// ```rust\n+/// # use vfs::{file_set::FileSetConfigBuilder, VfsPath, Vfs};\n+/// let mut builder = FileSetConfigBuilder::default();\n+/// builder.add_file_set(vec![VfsPath::new_virtual_path(\"/src\".to_string())]);\n+/// let config = builder.build();\n+/// let mut file_system = Vfs::default();\n+/// file_system.set_file_contents(VfsPath::new_virtual_path(\"/src/main.rs\".to_string()), Some(vec![]));\n+/// file_system.set_file_contents(VfsPath::new_virtual_path(\"/src/lib.rs\".to_string()), Some(vec![]));\n+/// file_system.set_file_contents(VfsPath::new_virtual_path(\"/build.rs\".to_string()), Some(vec![]));\n+/// // contains the sets :\n+/// // { \"/src/main.rs\", \"/src/lib.rs\" }\n+/// // { \"build.rs\" }\n+/// let sets = config.partition(&file_system);\n+/// ```\n #[derive(Debug)]\n pub struct FileSetConfig {\n     n_file_sets: usize,\n@@ -63,9 +94,14 @@ impl Default for FileSetConfig {\n }\n \n impl FileSetConfig {\n+    /// Returns a builder for `FileSetConfig`.\n     pub fn builder() -> FileSetConfigBuilder {\n         FileSetConfigBuilder::default()\n     }\n+\n+    /// Partition `vfs` into `FileSet`s.\n+    ///\n+    /// Creates a new [`FileSet`] for every set of prefixes in `self`.\n     pub fn partition(&self, vfs: &Vfs) -> Vec<FileSet> {\n         let mut scratch_space = Vec::new();\n         let mut res = vec![FileSet::default(); self.len()];\n@@ -91,6 +127,7 @@ impl FileSetConfig {\n     }\n }\n \n+/// Builder for [`FileSetConfig`].\n pub struct FileSetConfigBuilder {\n     roots: Vec<Vec<VfsPath>>,\n }\n@@ -102,12 +139,17 @@ impl Default for FileSetConfigBuilder {\n }\n \n impl FileSetConfigBuilder {\n+    /// Returns the number of sets currently held.\n     pub fn len(&self) -> usize {\n         self.roots.len()\n     }\n+\n+    /// Add a new set of paths prefixes.\n     pub fn add_file_set(&mut self, roots: Vec<VfsPath>) {\n         self.roots.push(roots)\n     }\n+\n+    /// Build the `FileSetConfig`.\n     pub fn build(self) -> FileSetConfig {\n         let n_file_sets = self.roots.len() + 1;\n         let map = {"}, {"sha": "bae2c61181c11d67e8a07d4f2ee69231fe868614", "filename": "crates/vfs/src/lib.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=311ec70d03c27b1b37457ef44510e735fcce0885", "patch": "@@ -53,50 +53,89 @@ pub use crate::{\n };\n pub use paths::{AbsPath, AbsPathBuf};\n \n+/// Handle to a file in [`Vfs`]\n+///\n+/// Most functions in rust-analyzer use this when they need to refer to a file.\n #[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n pub struct FileId(pub u32);\n \n+/// Storage for all files read by rust-analyzer.\n+///\n+/// For more informations see the [crate-level](crate) documentation.\n #[derive(Default)]\n pub struct Vfs {\n     interner: PathInterner,\n     data: Vec<Option<Vec<u8>>>,\n     changes: Vec<ChangedFile>,\n }\n \n+/// Changed file in the [`Vfs`].\n pub struct ChangedFile {\n+    /// Id of the changed file\n     pub file_id: FileId,\n+    /// Kind of change\n     pub change_kind: ChangeKind,\n }\n \n impl ChangedFile {\n+    /// Returns `true` if the change is not [`Delete`](ChangeKind::Delete).\n     pub fn exists(&self) -> bool {\n         self.change_kind != ChangeKind::Delete\n     }\n+\n+    /// Returns `true` if the change is [`Create`](ChangeKind::Create) or\n+    /// [`Delete`](ChangeKind::Delete).\n     pub fn is_created_or_deleted(&self) -> bool {\n         matches!(self.change_kind, ChangeKind::Create | ChangeKind::Delete)\n     }\n }\n \n+/// Kind of [file change](ChangedFile).\n #[derive(Eq, PartialEq, Copy, Clone, Debug)]\n pub enum ChangeKind {\n+    /// The file was (re-)created\n     Create,\n+    /// The file was modified\n     Modify,\n+    /// The file was deleted\n     Delete,\n }\n \n impl Vfs {\n+    /// Amount of files currently stored.\n+    ///\n+    /// Note that this includes deleted files.\n     pub fn len(&self) -> usize {\n         self.data.len()\n     }\n+\n+    /// Id of the given path if it exists in the `Vfs` and is not deleted.\n     pub fn file_id(&self, path: &VfsPath) -> Option<FileId> {\n         self.interner.get(path).filter(|&it| self.get(it).is_some())\n     }\n+\n+    /// File path corresponding to the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the id is not present in the `Vfs`.\n     pub fn file_path(&self, file_id: FileId) -> VfsPath {\n         self.interner.lookup(file_id).clone()\n     }\n+\n+    /// File content corresponding to the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the id is not present in the `Vfs`, or if the corresponding file is\n+    /// deleted.\n     pub fn file_contents(&self, file_id: FileId) -> &[u8] {\n         self.get(file_id).as_deref().unwrap()\n     }\n+\n+    /// Returns an iterator over the stored ids and their corresponding paths.\n+    ///\n+    /// This will skip deleted files.\n     pub fn iter(&self) -> impl Iterator<Item = (FileId, &VfsPath)> + '_ {\n         (0..self.data.len())\n             .map(|it| FileId(it as u32))\n@@ -106,6 +145,13 @@ impl Vfs {\n                 (file_id, path)\n             })\n     }\n+\n+    /// Update the `path` with the given `contents`. `None` means the file was deleted.\n+    ///\n+    /// Returns `true` if the file was modified, and saves the [change](ChangedFile).\n+    ///\n+    /// If the path does not currently exists in the `Vfs`, allocates a new\n+    /// [`FileId`] for it.\n     pub fn set_file_contents(&mut self, path: VfsPath, contents: Option<Vec<u8>>) -> bool {\n         let file_id = self.alloc_file_id(path);\n         let change_kind = match (&self.get(file_id), &contents) {\n@@ -120,9 +166,13 @@ impl Vfs {\n         self.changes.push(ChangedFile { file_id, change_kind });\n         true\n     }\n+\n+    /// Returns `true` if the `Vfs` contains [changes](ChangedFile).\n     pub fn has_changes(&self) -> bool {\n         !self.changes.is_empty()\n     }\n+\n+    /// Drain and returns all the changes in the `Vfs`.\n     pub fn take_changes(&mut self) -> Vec<ChangedFile> {\n         mem::take(&mut self.changes)\n     }"}, {"sha": "399015043f4964d901e0c66b47ed37b3b814bb10", "filename": "crates/vfs/src/loader.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=311ec70d03c27b1b37457ef44510e735fcce0885", "patch": "@@ -3,9 +3,12 @@ use std::fmt;\n \n use paths::{AbsPath, AbsPathBuf};\n \n+/// A set of files on the file system.\n #[derive(Debug, Clone)]\n pub enum Entry {\n+    /// The `Entry` is represented by a raw set of files.\n     Files(Vec<AbsPathBuf>),\n+    /// The `Entry` is represented by `Directories`.\n     Directories(Directories),\n }\n \n@@ -17,52 +20,108 @@ pub enum Entry {\n ///   * it is not under `exclude` path\n ///\n /// If many include/exclude paths match, the longest one wins.\n+///\n+/// If a path is in both `include` and `exclude`, the `exclude` one wins.\n #[derive(Debug, Clone, Default)]\n pub struct Directories {\n     pub extensions: Vec<String>,\n     pub include: Vec<AbsPathBuf>,\n     pub exclude: Vec<AbsPathBuf>,\n }\n \n+/// [`Handle`]'s configuration.\n #[derive(Debug)]\n pub struct Config {\n+    /// Set of initially loaded files.\n     pub load: Vec<Entry>,\n+    /// Index of watched entries in `load`.\n+    ///\n+    /// If a path in a watched entry is modified,the [`Handle`] should notify it.\n     pub watch: Vec<usize>,\n }\n \n+/// Message about an action taken by a [`Handle`].\n pub enum Message {\n+    /// Indicate a gradual progress.\n+    ///\n+    /// This is supposed to be the number of loaded files.\n     Progress { n_total: usize, n_done: usize },\n+    /// The handle loaded the following files' content.\n     Loaded { files: Vec<(AbsPathBuf, Option<Vec<u8>>)> },\n }\n \n+/// Type that will receive [`Messages`](Message) from a [`Handle`].\n pub type Sender = Box<dyn Fn(Message) + Send>;\n \n+/// Interface for reading and watching files.\n pub trait Handle: fmt::Debug {\n+    /// Spawn a new handle with the given `sender`.\n     fn spawn(sender: Sender) -> Self\n     where\n         Self: Sized;\n+\n+    /// Set this handle's configuration.\n     fn set_config(&mut self, config: Config);\n+\n+    /// The file's content at `path` has been modified, and should be reloaded.\n     fn invalidate(&mut self, path: AbsPathBuf);\n+\n+    /// Load the content of the given file, returning [`None`] if it does not\n+    /// exists.\n     fn load_sync(&mut self, path: &AbsPath) -> Option<Vec<u8>>;\n }\n \n impl Entry {\n+    /// Returns:\n+    /// ```text\n+    /// Entry::Directories(Directories {\n+    ///     extensions: [\"rs\"],\n+    ///     include: [base],\n+    ///     exclude: [base/.git],\n+    /// })\n+    /// ```\n     pub fn rs_files_recursively(base: AbsPathBuf) -> Entry {\n         Entry::Directories(dirs(base, &[\".git\"]))\n     }\n+\n+    /// Returns:\n+    /// ```text\n+    /// Entry::Directories(Directories {\n+    ///     extensions: [\"rs\"],\n+    ///     include: [base],\n+    ///     exclude: [base/.git, base/target],\n+    /// })\n+    /// ```\n     pub fn local_cargo_package(base: AbsPathBuf) -> Entry {\n         Entry::Directories(dirs(base, &[\".git\", \"target\"]))\n     }\n+\n+    /// Returns:\n+    /// ```text\n+    /// Entry::Directories(Directories {\n+    ///     extensions: [\"rs\"],\n+    ///     include: [base],\n+    ///     exclude: [base/.git, /tests, /examples, /benches],\n+    /// })\n+    /// ```\n     pub fn cargo_package_dependency(base: AbsPathBuf) -> Entry {\n         Entry::Directories(dirs(base, &[\".git\", \"/tests\", \"/examples\", \"/benches\"]))\n     }\n \n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// See [`Directories::contains_file`].\n     pub fn contains_file(&self, path: &AbsPath) -> bool {\n         match self {\n             Entry::Files(files) => files.iter().any(|it| it == path),\n             Entry::Directories(dirs) => dirs.contains_file(path),\n         }\n     }\n+\n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// - If `self` is `Entry::Files`, returns `false`\n+    /// - Else, see [`Directories::contains_dir`].\n     pub fn contains_dir(&self, path: &AbsPath) -> bool {\n         match self {\n             Entry::Files(_) => false,\n@@ -72,13 +131,19 @@ impl Entry {\n }\n \n impl Directories {\n+    /// Returns `true` if `path` is included in `self`.\n     pub fn contains_file(&self, path: &AbsPath) -> bool {\n         let ext = path.extension().unwrap_or_default();\n         if self.extensions.iter().all(|it| it.as_str() != ext) {\n             return false;\n         }\n         self.includes_path(path)\n     }\n+\n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// Since `path` is supposed to be a directory, this will not take extension\n+    /// into account.\n     pub fn contains_dir(&self, path: &AbsPath) -> bool {\n         self.includes_path(path)\n     }"}, {"sha": "74b6333e2912fa5dbde88a0a14edb94f0a821c52", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311ec70d03c27b1b37457ef44510e735fcce0885/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=311ec70d03c27b1b37457ef44510e735fcce0885", "patch": "@@ -3,25 +3,37 @@ use std::fmt;\n \n use paths::{AbsPath, AbsPathBuf};\n \n+/// Path in [`Vfs`].\n+///\n /// Long-term, we want to support files which do not reside in the file-system,\n-/// so we treat VfsPaths as opaque identifiers.\n+/// so we treat `VfsPath`s as opaque identifiers.\n+///\n+/// [`Vfs`]: crate::Vfs\n #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n pub struct VfsPath(VfsPathRepr);\n \n impl VfsPath {\n-    /// Creates an \"in-memory\" path from `/`-separates string.\n+    /// Creates an \"in-memory\" path from `/`-separated string.\n+    ///\n     /// This is most useful for testing, to avoid windows/linux differences\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `path` does not start with `'/'`.\n     pub fn new_virtual_path(path: String) -> VfsPath {\n         assert!(path.starts_with('/'));\n         VfsPath(VfsPathRepr::VirtualPath(VirtualPath(path)))\n     }\n \n+    /// Returns the `AbsPath` representation of `self` if `self` is on the file system.\n     pub fn as_path(&self) -> Option<&AbsPath> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(it) => Some(it.as_path()),\n             VfsPathRepr::VirtualPath(_) => None,\n         }\n     }\n+\n+    /// Creates a new `VfsPath` with `path` adjoined to `self`.\n     pub fn join(&self, path: &str) -> Option<VfsPath> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(it) => {\n@@ -34,12 +46,30 @@ impl VfsPath {\n             }\n         }\n     }\n+\n+    /// Remove the last component of `self` if there is one.\n+    ///\n+    /// If `self` has no component, returns `false`; else returns `true`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use vfs::{AbsPathBuf, VfsPath};\n+    /// let mut path = VfsPath::from(AbsPathBuf::assert(\"/foo/bar\".into()));\n+    /// assert!(path.pop());\n+    /// assert_eq!(path, VfsPath::from(AbsPathBuf::assert(\"/foo\".into())));\n+    /// assert!(path.pop());\n+    /// assert_eq!(path, VfsPath::from(AbsPathBuf::assert(\"/\".into())));\n+    /// assert!(!path.pop());\n+    /// ```\n     pub fn pop(&mut self) -> bool {\n         match &mut self.0 {\n             VfsPathRepr::PathBuf(it) => it.pop(),\n             VfsPathRepr::VirtualPath(it) => it.pop(),\n         }\n     }\n+\n+    /// Returns `true` if `other` is a prefix of `self`.\n     pub fn starts_with(&self, other: &VfsPath) -> bool {\n         match (&self.0, &other.0) {\n             (VfsPathRepr::PathBuf(lhs), VfsPathRepr::PathBuf(rhs)) => lhs.starts_with(rhs),\n@@ -48,6 +78,10 @@ impl VfsPath {\n             (VfsPathRepr::VirtualPath(_), _) => false,\n         }\n     }\n+\n+    /// Returns the `VfsPath` without its final component, if there is one.\n+    ///\n+    /// Returns [`None`] if the path is a root or prefix.\n     pub fn parent(&self) -> Option<VfsPath> {\n         let mut parent = self.clone();\n         if parent.pop() {\n@@ -57,6 +91,7 @@ impl VfsPath {\n         }\n     }\n \n+    /// Returns `self`'s base name and file extension.\n     pub fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(p) => Some(("}]}