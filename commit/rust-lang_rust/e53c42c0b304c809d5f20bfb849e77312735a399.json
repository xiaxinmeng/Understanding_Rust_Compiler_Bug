{"sha": "e53c42c0b304c809d5f20bfb849e77312735a399", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1M2M0MmMwYjMwNGM4MDlkNWYyMGJmYjg0OWU3NzMxMjczNWEzOTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-19T19:15:59Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-06T18:50:11Z"}, "message": "ty/walk: keep track of `GenericArg`s on the stack, instead of `Ty`s.", "tree": {"sha": "ea7633ed9e8d5224d71d47112c198a1abdb09350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea7633ed9e8d5224d71d47112c198a1abdb09350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e53c42c0b304c809d5f20bfb849e77312735a399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e53c42c0b304c809d5f20bfb849e77312735a399", "html_url": "https://github.com/rust-lang/rust/commit/e53c42c0b304c809d5f20bfb849e77312735a399", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e53c42c0b304c809d5f20bfb849e77312735a399/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40158901d5c7e65b2fb5adc6ce186bc308274954", "url": "https://api.github.com/repos/rust-lang/rust/commits/40158901d5c7e65b2fb5adc6ce186bc308274954", "html_url": "https://github.com/rust-lang/rust/commit/40158901d5c7e65b2fb5adc6ce186bc308274954"}], "stats": {"total": 192, "additions": 107, "deletions": 85}, "files": [{"sha": "ca3055c4c62b823223edd907a72ff45359fdbfa0", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e53c42c0b304c809d5f20bfb849e77312735a399/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53c42c0b304c809d5f20bfb849e77312735a399/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=e53c42c0b304c809d5f20bfb849e77312735a399", "patch": "@@ -2698,14 +2698,14 @@ impl<'tcx> TyS<'tcx> {\n     /// [isize] => { [isize], isize }\n     /// ```\n     pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n-        TypeWalker::new(self)\n+        TypeWalker::new(self.into())\n     }\n \n     /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n-    pub fn walk_shallow(&'tcx self) -> smallvec::IntoIter<walk::TypeWalkerArray<'tcx>> {\n-        walk::walk_shallow(self)\n+    pub fn walk_shallow(&'tcx self) -> impl Iterator<Item = Ty<'tcx>> {\n+        walk::walk_shallow(self.into())\n     }\n \n     /// Walks `ty` and any types appearing within `ty`, invoking the"}, {"sha": "8000f23bc78c12b350eefc8cf7f07c4413b6d317", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 104, "deletions": 82, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/e53c42c0b304c809d5f20bfb849e77312735a399/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53c42c0b304c809d5f20bfb849e77312735a399/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=e53c42c0b304c809d5f20bfb849e77312735a399", "patch": "@@ -1,25 +1,25 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n+use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, Ty};\n use smallvec::{self, SmallVec};\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations.\n-pub type TypeWalkerArray<'tcx> = [Ty<'tcx>; 8];\n-pub type TypeWalkerStack<'tcx> = SmallVec<TypeWalkerArray<'tcx>>;\n+type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n \n pub struct TypeWalker<'tcx> {\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n }\n \n impl<'tcx> TypeWalker<'tcx> {\n-    pub fn new(ty: Ty<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: smallvec![ty], last_subtree: 1 }\n+    pub fn new(root: GenericArg<'tcx>) -> TypeWalker<'tcx> {\n+        TypeWalker { stack: smallvec![root], last_subtree: 1 }\n     }\n \n-    /// Skips the subtree of types corresponding to the last type\n+    /// Skips the subtree corresponding to the last type\n     /// returned by `next()`.\n     ///\n     /// Example: Imagine you are walking `Foo<Bar<int>, usize>`.\n@@ -41,98 +41,120 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n \n     fn next(&mut self) -> Option<Ty<'tcx>> {\n         debug!(\"next(): stack={:?}\", self.stack);\n-        match self.stack.pop() {\n-            None => None,\n-            Some(ty) => {\n-                self.last_subtree = self.stack.len();\n-                push_subtypes(&mut self.stack, ty);\n-                debug!(\"next: stack={:?}\", self.stack);\n-                Some(ty)\n+        while let Some(next) = self.stack.pop() {\n+            self.last_subtree = self.stack.len();\n+            push_inner(&mut self.stack, next);\n+            debug!(\"next: stack={:?}\", self.stack);\n+\n+            // FIXME(eddyb) remove this filter and expose all `GenericArg`s.\n+            match next.unpack() {\n+                GenericArgKind::Type(ty) => return Some(ty),\n+                GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => {}\n             }\n         }\n+\n+        None\n     }\n }\n \n-pub fn walk_shallow(ty: Ty<'_>) -> smallvec::IntoIter<TypeWalkerArray<'_>> {\n+pub fn walk_shallow(parent: GenericArg<'tcx>) -> impl Iterator<Item = Ty<'tcx>> {\n     let mut stack = SmallVec::new();\n-    push_subtypes(&mut stack, ty);\n-    stack.into_iter()\n+    push_inner(&mut stack, parent);\n+    stack.into_iter().filter_map(|child| {\n+        // FIXME(eddyb) remove this filter and expose all `GenericArg`s.\n+        match child.unpack() {\n+            GenericArgKind::Type(ty) => Some(ty),\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => None,\n+        }\n+    })\n }\n \n-// We push types on the stack in reverse order so as to\n+// We push `GenericArg`s on the stack in reverse order so as to\n // maintain a pre-order traversal. As of the time of this\n // writing, the fact that the traversal is pre-order is not\n // known to be significant to any code, but it seems like the\n // natural order one would expect (basically, the order of the\n // types as they are written).\n-fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n-    match parent_ty.kind {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Str\n-        | ty::Infer(_)\n-        | ty::Param(_)\n-        | ty::Never\n-        | ty::Error\n-        | ty::Placeholder(..)\n-        | ty::Bound(..)\n-        | ty::Foreign(..) => {}\n-        ty::Array(ty, len) => {\n-            if let ty::ConstKind::Unevaluated(_, substs, promoted) = len.val {\n-                assert!(promoted.is_none());\n-                stack.extend(substs.types().rev());\n+fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>) {\n+    match parent.unpack() {\n+        GenericArgKind::Type(parent_ty) => match parent_ty.kind {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Infer(_)\n+            | ty::Param(_)\n+            | ty::Never\n+            | ty::Error\n+            | ty::Placeholder(..)\n+            | ty::Bound(..)\n+            | ty::Foreign(..) => {}\n+\n+            ty::Array(ty, len) => {\n+                stack.push(len.into());\n+                stack.push(ty.into());\n             }\n-            stack.push(len.ty);\n-            stack.push(ty);\n-        }\n-        ty::Slice(ty) => {\n-            stack.push(ty);\n-        }\n-        ty::RawPtr(ref mt) => {\n-            stack.push(mt.ty);\n-        }\n-        ty::Ref(_, ty, _) => {\n-            stack.push(ty);\n-        }\n-        ty::Projection(ref data) | ty::UnnormalizedProjection(ref data) => {\n-            stack.extend(data.substs.types().rev());\n-        }\n-        ty::Dynamic(ref obj, ..) => {\n-            stack.extend(obj.iter().rev().flat_map(|predicate| {\n-                let (substs, opt_ty) = match *predicate.skip_binder() {\n-                    ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n-                    ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n-                    ty::ExistentialPredicate::AutoTrait(_) =>\n-                    // Empty iterator\n-                    {\n-                        (ty::InternalSubsts::empty(), None)\n-                    }\n-                };\n+            ty::Slice(ty) => {\n+                stack.push(ty.into());\n+            }\n+            ty::RawPtr(mt) => {\n+                stack.push(mt.ty.into());\n+            }\n+            ty::Ref(lt, ty, _) => {\n+                stack.push(ty.into());\n+                stack.push(lt.into());\n+            }\n+            ty::Projection(data) | ty::UnnormalizedProjection(data) => {\n+                stack.extend(data.substs.iter().copied().rev());\n+            }\n+            ty::Dynamic(obj, lt) => {\n+                stack.push(lt.into());\n+                stack.extend(obj.iter().rev().flat_map(|predicate| {\n+                    let (substs, opt_ty) = match *predicate.skip_binder() {\n+                        ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n+                        ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n+                        ty::ExistentialPredicate::AutoTrait(_) =>\n+                        // Empty iterator\n+                        {\n+                            (ty::InternalSubsts::empty(), None)\n+                        }\n+                    };\n \n-                substs.types().rev().chain(opt_ty)\n-            }));\n-        }\n-        ty::Adt(_, substs) | ty::Opaque(_, substs) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ty::Closure(_, ref substs) | ty::Generator(_, ref substs, _) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ty::GeneratorWitness(ts) => {\n-            stack.extend(ts.skip_binder().iter().cloned().rev());\n-        }\n-        ty::Tuple(..) => {\n-            stack.extend(parent_ty.tuple_fields().rev());\n-        }\n-        ty::FnDef(_, substs) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ty::FnPtr(sig) => {\n-            stack.push(sig.skip_binder().output());\n-            stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n+                    substs.iter().copied().rev().chain(opt_ty.map(|ty| ty.into()))\n+                }));\n+            }\n+            ty::Adt(_, substs)\n+            | ty::Opaque(_, substs)\n+            | ty::Closure(_, substs)\n+            | ty::Generator(_, substs, _)\n+            | ty::Tuple(substs)\n+            | ty::FnDef(_, substs) => {\n+                stack.extend(substs.iter().copied().rev());\n+            }\n+            ty::GeneratorWitness(ts) => {\n+                stack.extend(ts.skip_binder().iter().cloned().rev().map(|ty| ty.into()));\n+            }\n+            ty::FnPtr(sig) => {\n+                stack.push(sig.skip_binder().output().into());\n+                stack.extend(sig.skip_binder().inputs().iter().cloned().rev().map(|ty| ty.into()));\n+            }\n+        },\n+        GenericArgKind::Lifetime(_) => {}\n+        GenericArgKind::Const(parent_ct) => {\n+            stack.push(parent_ct.ty.into());\n+            match parent_ct.val {\n+                ty::ConstKind::Infer(_)\n+                | ty::ConstKind::Param(_)\n+                | ty::ConstKind::Placeholder(_)\n+                | ty::ConstKind::Bound(..)\n+                | ty::ConstKind::Value(_) => {}\n+\n+                ty::ConstKind::Unevaluated(_, substs, _) => {\n+                    stack.extend(substs.iter().copied().rev());\n+                }\n+            }\n         }\n     }\n }"}]}