{"sha": "b4e55cdeddcf53953214aadb6eaa431a24aa2601", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZTU1Y2RlZGRjZjUzOTUzMjE0YWFkYjZlYWE0MzFhMjRhYTI2MDE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-14T13:03:52Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-14T13:03:52Z"}, "message": "Refactor num.rs", "tree": {"sha": "eb1bcae64b348356b01eed16bb62da16fb3fcc04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb1bcae64b348356b01eed16bb62da16fb3fcc04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4e55cdeddcf53953214aadb6eaa431a24aa2601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e55cdeddcf53953214aadb6eaa431a24aa2601", "html_url": "https://github.com/rust-lang/rust/commit/b4e55cdeddcf53953214aadb6eaa431a24aa2601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4e55cdeddcf53953214aadb6eaa431a24aa2601/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db071db95aa1ab24d961c961e18daee66fdc4af4", "url": "https://api.github.com/repos/rust-lang/rust/commits/db071db95aa1ab24d961c961e18daee66fdc4af4", "html_url": "https://github.com/rust-lang/rust/commit/db071db95aa1ab24d961c961e18daee66fdc4af4"}], "stats": {"total": 452, "additions": 183, "deletions": 269}, "files": [{"sha": "4af36117de023a8f5c0316b584aa068d13feecba", "filename": "src/base.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=b4e55cdeddcf53953214aadb6eaa431a24aa2601", "patch": "@@ -264,30 +264,19 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let lhs = trans_operand(fx, lhs);\n                     let rhs = trans_operand(fx, rhs);\n \n-                    let res = match lhs.layout().ty.sty {\n-                        ty::Bool => crate::num::trans_bool_binop(fx, *bin_op, lhs, rhs),\n-                        ty::Uint(_) | ty::Int(_ )=> {\n-                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n-                        }\n-                        ty::Float(_) => crate::num::trans_float_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n-                        ty::Char => crate::num::trans_char_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n-                        ty::RawPtr(..) | ty::FnPtr(..) => {\n-                            crate::num::trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n-                        }\n-                        _ => unimplemented!(\"{:?}({:?}, {:?})\", bin_op, lhs.layout().ty, rhs.layout().ty),\n-                    };\n+                    let res = crate::num::codegen_binop(fx, *bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n                     let lhs = trans_operand(fx, lhs);\n                     let rhs = trans_operand(fx, rhs);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n-                        let val = crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lhs.layout().ty).load_scalar(fx);\n+                        let val = crate::num::trans_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n                         let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n                         CValue::by_val_pair(val, is_overflow, lval.layout())\n                     } else {\n-                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n+                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs)\n                     };\n \n                     lval.write_cvalue(fx, res);\n@@ -314,6 +303,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             ty::Int(_) => {\n                                 let clif_ty = fx.clif_type(layout.ty).unwrap();\n                                 if clif_ty == types::I128 {\n+                                    // FIXME implement it\n                                     crate::trap::trap_unreachable_ret_value(fx, layout, \"i128 neg is not yet supported\").load_scalar(fx)\n                                 } else {\n                                     let zero = fx.bcx.ins().iconst(clif_ty, 0);"}, {"sha": "87d69c2d9a71c2aecd9b96a9b8b3c0faaae5c86b", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=b4e55cdeddcf53953214aadb6eaa431a24aa2601", "patch": "@@ -8,7 +8,6 @@ pub fn maybe_codegen<'a, 'tcx>(\n     checked: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n-    out_ty: Ty<'tcx>,\n ) -> Option<CValue<'tcx>> {\n     if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n         return None;\n@@ -26,13 +25,15 @@ pub fn maybe_codegen<'a, 'tcx>(\n         }\n         BinOp::Add | BinOp::Sub if !checked => return None,\n         BinOp::Add => {\n+            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             return Some(if is_signed {\n                 fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n             } else {\n                 fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n             })\n         }\n         BinOp::Sub => {\n+            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             return Some(if is_signed {\n                 fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n             } else {\n@@ -42,6 +43,7 @@ pub fn maybe_codegen<'a, 'tcx>(\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Mul => {\n             let res = if checked {\n+                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n                 if is_signed {\n                     fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n                 } else {\n@@ -91,18 +93,7 @@ pub fn maybe_codegen<'a, 'tcx>(\n                     // } else {\n                     //     msb_cc\n                     // }\n-                    let cc = match (bin_op, is_signed) {\n-                        (BinOp::Ge, false) => IntCC::UnsignedGreaterThanOrEqual,\n-                        (BinOp::Gt, false) => IntCC::UnsignedGreaterThan,\n-                        (BinOp::Lt, false) => IntCC::UnsignedLessThan,\n-                        (BinOp::Le, false) => IntCC::UnsignedLessThanOrEqual,\n-\n-                        (BinOp::Ge, true) => IntCC::SignedGreaterThanOrEqual,\n-                        (BinOp::Gt, true) => IntCC::SignedGreaterThan,\n-                        (BinOp::Lt, true) => IntCC::SignedLessThan,\n-                        (BinOp::Le, true) => IntCC::SignedLessThanOrEqual,\n-                        _ => unreachable!(),\n-                    };\n+                    let cc = crate::num::bin_op_to_intcc(bin_op, is_signed).unwrap();\n \n                     let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n                     let lsb_cc = fx.bcx.ins().icmp(cc, lhs_lsb, rhs_lsb);\n@@ -160,6 +151,7 @@ pub fn maybe_codegen<'a, 'tcx>(\n                 };\n                 if let Some(val) = val {\n                     if let Some(is_overflow) = is_overflow {\n+                        let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n                         let val = val.load_scalar(fx);\n                         return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n                     } else {\n@@ -186,6 +178,7 @@ pub fn maybe_codegen<'a, 'tcx>(\n                 (_, _) => unreachable!(),\n             };\n             if let Some(is_overflow) = is_overflow {\n+                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n                 let val = val.load_scalar(fx);\n                 Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n             } else {"}, {"sha": "317da6f4aaf0d7674289b1cb8c53ae1263dadd63", "filename": "src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=b4e55cdeddcf53953214aadb6eaa431a24aa2601", "patch": "@@ -446,7 +446,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 \"unchecked_shr\" => BinOp::Shr,\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = crate::num::trans_int_binop(fx, bin_op, x, y, ret.layout().ty);\n+            let res = crate::num::trans_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         };\n         _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n@@ -463,7 +463,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 bin_op,\n                 x,\n                 y,\n-                ret.layout().ty,\n             );\n             ret.write_cvalue(fx, res);\n         };\n@@ -480,7 +479,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 bin_op,\n                 x,\n                 y,\n-                ret.layout().ty,\n             );\n             ret.write_cvalue(fx, res);\n         };\n@@ -499,7 +497,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 bin_op,\n                 x,\n                 y,\n-                fx.tcx.mk_tup([T, fx.tcx.types.bool].into_iter()),\n             );\n \n             let (val, has_overflow) = checked_res.load_scalar_pair(fx);"}, {"sha": "1a8aed8f902b7c6fd070b8b8cb6a5d9784f5f9ae", "filename": "src/num.rs", "status": "modified", "additions": 172, "deletions": 238, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e55cdeddcf53953214aadb6eaa431a24aa2601/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=b4e55cdeddcf53953214aadb6eaa431a24aa2601", "patch": "@@ -1,155 +1,148 @@\n use crate::prelude::*;\n \n-macro_rules! binop_match {\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, bug) => {\n-        bug!(\"binop {} on {} lhs: {:?} rhs: {:?}\", stringify!($var), $bug_fmt, $lhs, $rhs)\n-    };\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, icmp($cc:ident)) => {{\n-        assert_eq!($fx.tcx.types.bool, $ret_ty);\n-        let ret_layout = $fx.layout_of($ret_ty);\n-\n-        let b = $fx.bcx.ins().icmp(IntCC::$cc, $lhs, $rhs);\n-        CValue::by_val($fx.bcx.ins().bint(types::I8, b), ret_layout)\n-    }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, fcmp($cc:ident)) => {{\n-        assert_eq!($fx.tcx.types.bool, $ret_ty);\n-        let ret_layout = $fx.layout_of($ret_ty);\n-        let b = $fx.bcx.ins().fcmp(FloatCC::$cc, $lhs, $rhs);\n-        CValue::by_val($fx.bcx.ins().bint(types::I8, b), ret_layout)\n-    }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, custom(|| $body:expr)) => {{\n-        $body\n-    }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $name:ident) => {{\n-        let ret_layout = $fx.layout_of($ret_ty);\n-        CValue::by_val($fx.bcx.ins().$name($lhs, $rhs), ret_layout)\n-    }};\n-    (\n-        $fx:expr, $bin_op:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $bug_fmt:expr;\n-        $(\n-            $var:ident ($sign:pat) $name:tt $( ( $($next:tt)* ) )? ;\n-        )*\n-    ) => {{\n-        let lhs = $lhs.load_scalar($fx);\n-        let rhs = $rhs.load_scalar($fx);\n-        match ($bin_op, $signed) {\n-            $(\n-                (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, $signed, lhs, rhs, $ret_ty, $name $( ( $($next)* ) )?),\n-            )*\n+pub fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n+    use BinOp::*;\n+    use IntCC::*;\n+    Some(match bin_op {\n+        Eq => Equal,\n+        Lt => if signed { SignedLessThan } else { UnsignedLessThan},\n+        Le => if signed { SignedLessThanOrEqual } else { UnsignedLessThanOrEqual},\n+        Ne => NotEqual,\n+        Ge => if signed { SignedGreaterThanOrEqual } else { UnsignedGreaterThanOrEqual },\n+        Gt => if signed { SignedGreaterThan } else { UnsignedGreaterThan },\n+        _ => return None,\n+    })\n+}\n+\n+fn codegen_compare_bin_op<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    signed: bool,\n+    lhs: Value,\n+    rhs: Value,\n+) -> CValue<'tcx> {\n+    let val = fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, signed).unwrap(), lhs, rhs);\n+    let val = fx.bcx.ins().bint(types::I8, val);\n+    CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n+}\n+\n+pub fn codegen_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    match bin_op {\n+        BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+            match in_lhs.layout().ty.sty {\n+                ref sty if *sty == fx.tcx.types.u128.sty || *sty == fx.tcx.types.i128.sty => {}\n+                ty::Bool | ty::Uint(_) | ty::Int(_) | ty::Char => {\n+                    let signed = type_sign(in_lhs.layout().ty);\n+                    let lhs = in_lhs.load_scalar(fx);\n+                    let rhs = in_rhs.load_scalar(fx);\n+\n+                    let (lhs, rhs) = if\n+                        (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n+                        && (in_lhs.layout().ty.sty == fx.tcx.types.i8.sty || in_lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n+                    {\n+                        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n+                        (\n+                            fx.bcx.ins().sextend(types::I32, lhs),\n+                            fx.bcx.ins().sextend(types::I32, rhs),\n+                        )\n+                    } else {\n+                        (lhs, rhs)\n+                    };\n+\n+                    return codegen_compare_bin_op(fx, bin_op, signed, lhs, rhs);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    match in_lhs.layout().ty.sty {\n+        ty::Bool => crate::num::trans_bool_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::Uint(_) | ty::Int(_)=> {\n+            crate::num::trans_int_binop(fx, bin_op, in_lhs, in_rhs)\n         }\n-    }}\n+        ty::Float(_) => crate::num::trans_float_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::RawPtr(..) | ty::FnPtr(..) => {\n+            crate::num::trans_ptr_binop(fx, bin_op, in_lhs, in_rhs)\n+        }\n+        _ => unimplemented!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n+    }\n }\n \n pub fn trans_bool_binop<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, fx.tcx.types.bool, \"bool\";\n-        Add (_) bug;\n-        Sub (_) bug;\n-        Mul (_) bug;\n-        Div (_) bug;\n-        Rem (_) bug;\n-        BitXor (_) bxor;\n-        BitAnd (_) band;\n-        BitOr (_) bor;\n-        Shl (_) bug;\n-        Shr (_) bug;\n-\n-        Eq (_) icmp(Equal);\n-        Lt (_) icmp(UnsignedLessThan);\n-        Le (_) icmp(UnsignedLessThanOrEqual);\n-        Ne (_) icmp(NotEqual);\n-        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n-        Gt (_) icmp(UnsignedGreaterThan);\n-\n-        Offset (_) bug;\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    let b = fx.bcx.ins();\n+    let res = match bin_op {\n+        BinOp::BitXor => b.bxor(lhs, rhs),\n+        BinOp::BitAnd => b.band(lhs, rhs),\n+        BinOp::BitOr => b.bor(lhs, rhs),\n+        // Compare binops handles by `codegen_binop`.\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n     };\n \n-    res\n+    CValue::by_val(res, fx.layout_of(fx.tcx.types.bool))\n }\n \n pub fn trans_int_binop<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    out_ty: Ty<'tcx>,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n     if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n         assert_eq!(\n-            lhs.layout().ty,\n-            rhs.layout().ty,\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty,\n             \"int binop requires lhs and rhs of same type\"\n         );\n     }\n \n-    match out_ty.sty {\n-        ty::Bool | ty::Uint(_) | ty::Int(_) => {}\n-        _ => unreachable!(\"Out ty {:?} is not an integer or bool\", out_ty),\n-    }\n-\n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, lhs, rhs, out_ty) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, in_lhs, in_rhs) {\n         return res;\n     }\n \n-    let signed = type_sign(lhs.layout().ty);\n-\n-    let (lhs, rhs) = if\n-        (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-        && (lhs.layout().ty.sty == fx.tcx.types.i8.sty || lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n-    {\n-        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n-        let lhs = lhs.load_scalar(fx);\n-        let rhs = rhs.load_scalar(fx);\n-        (\n-            CValue::by_val(fx.bcx.ins().sextend(types::I32, lhs), fx.layout_of(fx.tcx.types.i32)),\n-            CValue::by_val(fx.bcx.ins().sextend(types::I32, rhs), fx.layout_of(fx.tcx.types.i32)),\n-        )\n-    } else {\n-        (lhs, rhs)\n+    let signed = type_sign(in_lhs.layout().ty);\n+\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    let b = fx.bcx.ins();\n+    let val = match bin_op {\n+        BinOp::Add => b.iadd(lhs, rhs),\n+        BinOp::Sub => b.isub(lhs, rhs),\n+        BinOp::Mul => b.imul(lhs, rhs),\n+        BinOp::Div => if signed { b.sdiv(lhs, rhs) } else { b.udiv(lhs, rhs) },\n+        BinOp::Rem => if signed { b.srem(lhs, rhs) } else { b.urem(lhs, rhs) },\n+        BinOp::BitXor => b.bxor(lhs, rhs),\n+        BinOp::BitAnd => b.band(lhs, rhs),\n+        BinOp::BitOr => b.bor(lhs, rhs),\n+        BinOp::Shl => b.ishl(lhs, rhs),\n+        BinOp::Shr => if signed { b.sshr(lhs, rhs) } else { b.ushr(lhs, rhs) },\n+        // Compare binops handles by `codegen_binop`.\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     };\n \n-    binop_match! {\n-        fx, bin_op, signed, lhs, rhs, out_ty, \"int/uint\";\n-        Add (_) iadd;\n-        Sub (_) isub;\n-        Mul (_) imul;\n-        Div (false) udiv;\n-        Div (true) sdiv;\n-        Rem (false) urem;\n-        Rem (true) srem;\n-        BitXor (_) bxor;\n-        BitAnd (_) band;\n-        BitOr (_) bor;\n-        Shl (_) ishl;\n-        Shr (false) ushr;\n-        Shr (true) sshr;\n-\n-        Eq (_) icmp(Equal);\n-        Lt (false) icmp(UnsignedLessThan);\n-        Lt (true) icmp(SignedLessThan);\n-        Le (false) icmp(UnsignedLessThanOrEqual);\n-        Le (true) icmp(SignedLessThanOrEqual);\n-        Ne (_) icmp(NotEqual);\n-        Ge (false) icmp(UnsignedGreaterThanOrEqual);\n-        Ge (true) icmp(SignedGreaterThanOrEqual);\n-        Gt (false) icmp(UnsignedGreaterThan);\n-        Gt (true) icmp(SignedGreaterThan);\n-\n-        Offset (_) bug;\n-    }\n+    CValue::by_val(val, in_lhs.layout())\n }\n \n pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n-    out_ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n         assert_eq!(\n@@ -162,7 +155,7 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, in_lhs, in_rhs, out_ty) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, in_lhs, in_rhs) {\n         return res;\n     }\n \n@@ -234,7 +227,7 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n-    let out_place = CPlace::new_stack_slot(fx, out_ty);\n+    let out_place = CPlace::new_stack_slot(fx, fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n     let out_layout = out_place.layout();\n     out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n \n@@ -244,127 +237,83 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n pub fn trans_float_binop<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    ty: Ty<'tcx>,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, ty, \"float\";\n-        Add (_) fadd;\n-        Sub (_) fsub;\n-        Mul (_) fmul;\n-        Div (_) fdiv;\n-        Rem (_) custom(|| {\n-            assert_eq!(lhs.layout().ty, ty);\n-            assert_eq!(rhs.layout().ty, ty);\n-            match ty.sty {\n-                ty::Float(FloatTy::F32) => fx.easy_call(\"fmodf\", &[lhs, rhs], ty),\n-                ty::Float(FloatTy::F64) => fx.easy_call(\"fmod\", &[lhs, rhs], ty),\n-                _ => bug!(),\n-            }\n-        });\n-        BitXor (_) bxor;\n-        BitAnd (_) band;\n-        BitOr (_) bor;\n-        Shl (_) bug;\n-        Shr (_) bug;\n-\n-        Eq (_) fcmp(Equal);\n-        Lt (_) fcmp(LessThan);\n-        Le (_) fcmp(LessThanOrEqual);\n-        Ne (_) fcmp(NotEqual);\n-        Ge (_) fcmp(GreaterThanOrEqual);\n-        Gt (_) fcmp(GreaterThan);\n-\n-        Offset (_) bug;\n-    };\n+    assert_eq!(in_lhs.layout().ty, in_rhs.layout().ty);\n \n-    res\n-}\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n \n-pub fn trans_char_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, ty, \"char\";\n-        Add (_) bug;\n-        Sub (_) bug;\n-        Mul (_) bug;\n-        Div (_) bug;\n-        Rem (_) bug;\n-        BitXor (_) bug;\n-        BitAnd (_) bug;\n-        BitOr (_) bug;\n-        Shl (_) bug;\n-        Shr (_) bug;\n-\n-        Eq (_) icmp(Equal);\n-        Lt (_) icmp(UnsignedLessThan);\n-        Le (_) icmp(UnsignedLessThanOrEqual);\n-        Ne (_) icmp(NotEqual);\n-        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n-        Gt (_) icmp(UnsignedGreaterThan);\n-\n-        Offset (_) bug;\n+    let b = fx.bcx.ins();\n+    let res = match bin_op {\n+        BinOp::Add => b.fadd(lhs, rhs),\n+        BinOp::Sub => b.fsub(lhs, rhs),\n+        BinOp::Mul => b.fmul(lhs, rhs),\n+        BinOp::Div => b.fdiv(lhs, rhs),\n+        BinOp::Rem => {\n+            let name = match in_lhs.layout().ty.sty {\n+                ty::Float(FloatTy::F32) => \"fmodf\",\n+                ty::Float(FloatTy::F64) => \"fmod\",\n+                _ => bug!(),\n+            };\n+            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+        }\n+        BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+            let fltcc = match bin_op {\n+                BinOp::Eq => FloatCC::Equal,\n+                BinOp::Lt => FloatCC::LessThan,\n+                BinOp::Le => FloatCC::LessThanOrEqual,\n+                BinOp::Ne => FloatCC::NotEqual,\n+                BinOp::Ge => FloatCC::GreaterThanOrEqual,\n+                BinOp::Gt => FloatCC::GreaterThan,\n+                _ => unreachable!(),\n+            };\n+            let val = fx.bcx.ins().fcmp(fltcc, lhs, rhs);\n+            let val = fx.bcx.ins().bint(types::I8, val);\n+            return CValue::by_val(val, fx.layout_of(fx.tcx.types.bool));\n+        }\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n     };\n \n-    res\n+    CValue::by_val(res, in_lhs.layout())\n }\n \n pub fn trans_ptr_binop<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    ret_ty: Ty<'tcx>,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    let not_fat = match lhs.layout().ty.sty {\n+    let not_fat = match in_lhs.layout().ty.sty {\n         ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n             ty.is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n         }\n         ty::FnPtr(..) => true,\n         _ => bug!(\"trans_ptr_binop on non ptr\"),\n     };\n     if not_fat {\n-        if let BinOp::Offset = bin_op {\n-            let (base, offset) = (lhs, rhs.load_scalar(fx));\n-            let pointee_ty = base.layout().ty.builtin_deref(true).unwrap().ty;\n-            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n-            let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n-            let base_val = base.load_scalar(fx);\n-            let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-            return CValue::by_val(res, base.layout());\n-        }\n+        match bin_op {\n+            BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+                let lhs = in_lhs.load_scalar(fx);\n+                let rhs = in_rhs.load_scalar(fx);\n \n-        binop_match! {\n-            fx, bin_op, false, lhs, rhs, ret_ty, \"ptr\";\n-            Add (_) bug;\n-            Sub (_) bug;\n-            Mul (_) bug;\n-            Div (_) bug;\n-            Rem (_) bug;\n-            BitXor (_) bug;\n-            BitAnd (_) bug;\n-            BitOr (_) bug;\n-            Shl (_) bug;\n-            Shr (_) bug;\n-\n-            Eq (_) icmp(Equal);\n-            Lt (_) icmp(UnsignedLessThan);\n-            Le (_) icmp(UnsignedLessThanOrEqual);\n-            Ne (_) icmp(NotEqual);\n-            Ge (_) icmp(UnsignedGreaterThanOrEqual);\n-            Gt (_) icmp(UnsignedGreaterThan);\n-\n-            Offset (_) bug; // Handled above\n-        }\n+                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);\n+            }\n+            BinOp::Offset => {\n+                let (base, offset) = (in_lhs, in_rhs.load_scalar(fx));\n+                let pointee_ty = base.layout().ty.builtin_deref(true).unwrap().ty;\n+                let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+                let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n+                let base_val = base.load_scalar(fx);\n+                let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n+                return CValue::by_val(res, base.layout());\n+            }\n+            _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n+        };\n     } else {\n-        let (lhs_ptr, lhs_extra) = lhs.load_scalar_pair(fx);\n-        let (rhs_ptr, rhs_extra) = rhs.load_scalar_pair(fx);\n+        let (lhs_ptr, lhs_extra) = in_lhs.load_scalar_pair(fx);\n+        let (rhs_ptr, rhs_extra) = in_rhs.load_scalar_pair(fx);\n \n         let res = match bin_op {\n             BinOp::Eq => {\n@@ -380,29 +329,14 @@ pub fn trans_ptr_binop<'a, 'tcx: 'a>(\n             BinOp::Lt | BinOp::Le | BinOp::Ge | BinOp::Gt => {\n                 let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n \n-                let ptr_cmp = fx.bcx.ins().icmp(match bin_op {\n-                    BinOp::Lt => IntCC::UnsignedLessThan,\n-                    BinOp::Le => IntCC::UnsignedLessThanOrEqual,\n-                    BinOp::Ge => IntCC::UnsignedGreaterThanOrEqual,\n-                    BinOp::Gt => IntCC::UnsignedGreaterThan,\n-                    _ => unreachable!(),\n-                }, lhs_ptr, rhs_ptr);\n-\n-                let extra_cmp = fx.bcx.ins().icmp(match bin_op {\n-                    BinOp::Lt => IntCC::UnsignedLessThan,\n-                    BinOp::Le => IntCC::UnsignedLessThanOrEqual,\n-                    BinOp::Ge => IntCC::UnsignedGreaterThanOrEqual,\n-                    BinOp::Gt => IntCC::UnsignedGreaterThan,\n-                    _ => unreachable!(),\n-                }, lhs_extra, rhs_extra);\n+                let ptr_cmp = fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                let extra_cmp = fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_extra, rhs_extra);\n \n                 fx.bcx.ins().select(ptr_eq, extra_cmp, ptr_cmp)\n             }\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        assert_eq!(fx.tcx.types.bool, ret_ty);\n-        let ret_layout = fx.layout_of(ret_ty);\n-        CValue::by_val(fx.bcx.ins().bint(types::I8, res), ret_layout)\n+        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n     }\n }"}]}