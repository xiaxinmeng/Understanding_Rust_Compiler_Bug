{"sha": "2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOTJjNjdkYzAzMThhNTJmZTQyYzNjMGJjYTQwOGY3NmM3ZmViNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-28T23:56:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-28T23:56:20Z"}, "message": "auto merge of #16664 : aturon/rust/stabilize-option-result, r=alexcrichton\n\nPer API meeting\r\n\r\n  https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-API-review-2014-08-13.md\r\n\r\n# Changes to `core::option`\r\n\r\nMost of the module is marked as stable or unstable; most of the unstable items are awaiting resolution of conventions issues.\r\n\r\nHowever, a few methods have been deprecated, either due to lack of use or redundancy:\r\n\r\n* `take_unwrap`, `get_ref` and `get_mut_ref` (redundant, and we prefer for this functionality to go through an explicit .unwrap)\r\n* `filtered` and `while`\r\n* `mutate` and `mutate_or_set`\r\n* `collect`: this functionality is being moved to a new `FromIterator` impl.\r\n\r\n# Changes to `core::result`\r\n\r\nMost of the module is marked as stable or unstable; most of the unstable items are awaiting resolution of conventions issues.\r\n\r\n* `collect`: this functionality is being moved to a new `FromIterator` impl.\r\n* `fold_` is deprecated due to lack of use\r\n* Several methods found in `core::option` are added here, including `iter`, `as_slice`, and variants.\r\n\r\nDue to deprecations, this is a:\r\n\r\n[breaking-change]", "tree": {"sha": "1a90b5802f53f36eda0212ac1b02ebd521161f25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a90b5802f53f36eda0212ac1b02ebd521161f25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "html_url": "https://github.com/rust-lang/rust/commit/2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a33d7a54170cd2904cebc7a6fd2d1da471ff64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a33d7a54170cd2904cebc7a6fd2d1da471ff64e", "html_url": "https://github.com/rust-lang/rust/commit/1a33d7a54170cd2904cebc7a6fd2d1da471ff64e"}, {"sha": "9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "html_url": "https://github.com/rust-lang/rust/commit/9a8233d3772fbdb3d496aac3e4693e6d4c30e125"}], "stats": {"total": 598, "additions": 398, "deletions": 200}, "files": [{"sha": "2c3aa88a680833ddf75f94ad95b5a7f84892de6c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -47,7 +47,7 @@ pub fn run(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n             }\n             let ProcessOutput { status, output, error } =\n                 process.wait_with_output().unwrap();\n@@ -79,7 +79,7 @@ pub fn run_background(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n             }\n \n             Some(process)"}, {"sha": "7a0245164ec098a20abcd2d0e134ae947ad17d81", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -1526,7 +1526,7 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n     let testcc = testfile.with_extension(\"cc\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: config.clang_path.get_ref().as_str().unwrap().to_string(),\n+        prog: config.clang_path.as_ref().unwrap().as_str().unwrap().to_string(),\n         args: vec!(\"-c\".to_string(),\n                    \"-emit-llvm\".to_string(),\n                    \"-o\".to_string(),\n@@ -1542,7 +1542,7 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n     let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n-    let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n+    let prog = config.llvm_bin_path.as_ref().unwrap().join(\"llvm-extract\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_string(),\n@@ -1559,7 +1559,7 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n     let extracted_ll = extracted_bc.with_extension(\"ll\");\n-    let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n+    let prog = config.llvm_bin_path.as_ref().unwrap().join(\"llvm-dis\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_string(),"}, {"sha": "73464047319886d53d2990bddc636b13d980881c", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -476,7 +476,7 @@ impl<T> TypedArena<T> {\n     /// Grows the arena.\n     #[inline(never)]\n     fn grow(&self) {\n-        let chunk = self.first.borrow_mut().take_unwrap();\n+        let chunk = self.first.borrow_mut().take().unwrap();\n         let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n         let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n         self.ptr.set(chunk.start() as *const T);\n@@ -489,13 +489,13 @@ impl<T> TypedArena<T> {\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         // Determine how much was filled.\n-        let start = self.first.borrow().get_ref().start() as uint;\n+        let start = self.first.borrow().as_ref().unwrap().start() as uint;\n         let end = self.ptr.get() as uint;\n         let diff = (end - start) / mem::size_of::<T>();\n \n         // Pass that to the `destroy` method.\n         unsafe {\n-            self.first.borrow_mut().get_mut_ref().destroy(diff)\n+            self.first.borrow_mut().as_mut().unwrap().destroy(diff)\n         }\n     }\n }"}, {"sha": "3f37183f1081ca7625458bcc0ff2a5c958003334", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -649,7 +649,7 @@ impl<'a, A> MutItems<'a, A> {\n                     None => return self.list.push_front_node(ins_node),\n                     Some(prev) => prev,\n                 };\n-                let node_own = prev_node.next.take_unwrap();\n+                let node_own = prev_node.next.take().unwrap();\n                 ins_node.next = link_with_prev(node_own, Rawlink::some(&mut *ins_node));\n                 prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n                 self.list.length += 1;"}, {"sha": "855798dc8be271484de95a3eb4fe229d772cee36", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -319,7 +319,7 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n         }\n         let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n         self.index += 1;\n-        Some(self.elts[raw_index].get_ref())\n+        Some(self.elts[raw_index].as_ref().unwrap())\n     }\n \n     #[inline]\n@@ -337,7 +337,7 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n         }\n         self.rindex -= 1;\n         let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n-        Some(self.elts[raw_index].get_ref())\n+        Some(self.elts[raw_index].as_ref().unwrap())\n     }\n }\n \n@@ -353,7 +353,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n             None\n         } else {\n             let raw_index = raw_index(self.lo, self.elts.len(), self.index + j);\n-            Some(self.elts[raw_index].get_ref())\n+            Some(self.elts[raw_index].as_ref().unwrap())\n         }\n     }\n }"}, {"sha": "7a131993c44e36e2059d2b7890decf675eeeab0c", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -1545,7 +1545,7 @@ impl<K: Ord, V> TreeNode<K, V> {\n // Remove left horizontal link by rotating right\n fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.left.as_ref().map_or(false, |x| x.level == node.level) {\n-        let mut save = node.left.take_unwrap();\n+        let mut save = node.left.take().unwrap();\n         swap(&mut node.left, &mut save.right); // save.right now None\n         swap(node, &mut save);\n         node.right = Some(save);\n@@ -1557,7 +1557,7 @@ fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.right.as_ref().map_or(false,\n       |x| x.right.as_ref().map_or(false, |y| y.level == node.level)) {\n-        let mut save = node.right.take_unwrap();\n+        let mut save = node.right.take().unwrap();\n         swap(&mut node.right, &mut save.left); // save.left now None\n         save.level += 1;\n         swap(node, &mut save);\n@@ -1661,7 +1661,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n           Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n-                    let mut left = save.left.take_unwrap();\n+                    let mut left = save.left.take().unwrap();\n                     if left.right.is_some() {\n                         heir_swap(save, &mut left.right);\n                     } else {\n@@ -1671,13 +1671,13 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                     save.left = Some(left);\n                     (remove(&mut save.left, key), true)\n                 } else {\n-                    let new = save.left.take_unwrap();\n+                    let new = save.left.take().unwrap();\n                     let box TreeNode{value, ..} = replace(save, new);\n-                    *save = save.left.take_unwrap();\n+                    *save = save.left.take().unwrap();\n                     (Some(value), true)\n                 }\n             } else if save.right.is_some() {\n-                let new = save.right.take_unwrap();\n+                let new = save.right.take().unwrap();\n                 let box TreeNode{value, ..} = replace(save, new);\n                 (Some(value), true)\n             } else {"}, {"sha": "569cf98ebc8fee093b0ec9675982cab8527287b2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -99,7 +99,7 @@\n //!             // Take a reference to the inside of cache cell\n //!             let mut cache = self.span_tree_cache.borrow_mut();\n //!             if cache.is_some() {\n-//!                 return cache.get_ref().clone();\n+//!                 return cache.as_ref().unwrap().clone();\n //!             }\n //!\n //!             let span_tree = self.calc_span_tree();"}, {"sha": "f8a56b3d6fc221adfda2bb94ceb5744163ad38d6", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -2199,7 +2199,12 @@ pub fn iterate<'a, T: Clone>(f: |T|: 'a -> T, seed: T) -> Iterate<'a, T> {\n         if *first {\n             *first = false;\n         } else {\n-            val.mutate(|x| (*f)(x));\n+            match val.take() {\n+                Some(x) => {\n+                    *val = Some((*f)(x))\n+                }\n+                None => {}\n+            }\n         }\n         val.clone()\n     })"}, {"sha": "537d78a67feb2230188246c1d81d9a0f47e95f46", "filename": "src/libcore/option.rs", "status": "modified", "additions": 106, "deletions": 45, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -141,6 +141,8 @@\n //! }\n //! ```\n \n+#![stable]\n+\n use cmp::{PartialEq, Eq, Ord};\n use default::Default;\n use slice::Slice;\n@@ -155,6 +157,7 @@ use slice;\n \n /// The `Option` type.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n+#[stable]\n pub enum Option<T> {\n     /// No value\n     None,\n@@ -173,6 +176,7 @@ impl<T> Option<T> {\n \n     /// Returns `true` if the option is a `Some` value\n     #[inline]\n+    #[stable]\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n@@ -182,6 +186,7 @@ impl<T> Option<T> {\n \n     /// Returns `true` if the option is a `None` value\n     #[inline]\n+    #[stable]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -207,18 +212,21 @@ impl<T> Option<T> {\n     /// println!(\"still can print num_as_str: {}\", num_as_str);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self { Some(ref x) => Some(x), None => None }\n     }\n \n     /// Convert from `Option<T>` to `Option<&mut T>`\n     #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n     /// Convert from `Option<T>` to `&mut [T]` (without copying)\n     #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n             Some(ref mut x) => {\n@@ -243,6 +251,7 @@ impl<T> Option<T> {\n     /// Fails if the value is a `None` with a custom failure message provided by\n     /// `msg`.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -262,6 +271,7 @@ impl<T> Option<T> {\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -271,6 +281,7 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or a default.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -280,6 +291,7 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or computes it from a closure.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, f: || -> T) -> T {\n         match self {\n             Some(x) => x,\n@@ -303,30 +315,45 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n         match self { Some(x) => Some(f(x)), None => None }\n     }\n \n     /// Applies a function to the contained value or returns a default.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n+    /// Applies a function to the contained value or computes a default.\n+    #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n+    pub fn map_or_else<U>(self, def: || -> U, f: |T| -> U) -> U {\n+        match self { None => def(), Some(t) => f(t) }\n+    }\n+\n+    /// Deprecated.\n+    ///\n     /// Applies a function to the contained value or does nothing.\n     /// Returns true if the contained value was mutated.\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn mutate(&mut self, f: |T| -> T) -> bool {\n         if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n+            *self = Some(f(self.take().unwrap()));\n             true\n         } else { false }\n     }\n \n+    /// Deprecated.\n+    ///\n     /// Applies a function to the contained value or sets it to a default.\n     /// Returns true if the contained value was mutated, or false if set to the default.\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n         if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n+            *self = Some(f(self.take().unwrap()));\n             true\n         } else {\n             *self = Some(def);\n@@ -340,18 +367,21 @@ impl<T> Option<T> {\n \n     /// Returns an iterator over the possibly contained value.\n     #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n         Item{opt: self.as_ref()}\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n     #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n     pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n         Item{opt: self.as_mut()}\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n     #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n     pub fn move_iter(self) -> Item<T> {\n         Item{opt: self}\n     }\n@@ -362,6 +392,7 @@ impl<T> Option<T> {\n \n     /// Returns `None` if the option is `None`, otherwise returns `optb`.\n     #[inline]\n+    #[stable]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n@@ -372,6 +403,7 @@ impl<T> Option<T> {\n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -381,6 +413,7 @@ impl<T> Option<T> {\n \n     /// Returns the option if it contains a value, otherwise returns `optb`.\n     #[inline]\n+    #[stable]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -391,6 +424,7 @@ impl<T> Option<T> {\n     /// Returns the option if it contains a value, otherwise calls `f` and\n     /// returns the result.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -404,21 +438,28 @@ impl<T> Option<T> {\n \n     /// Takes the value out of the option, leaving a `None` in its place.\n     #[inline]\n+    #[stable]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n \n+    /// Deprecated.\n+    ///\n     /// Filters an optional value using a given function.\n     #[inline(always)]\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n         match self {\n             Some(x) => if f(&x) { Some(x) } else { None },\n             None => None\n         }\n     }\n \n+    /// Deprecated.\n+    ///\n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn while_some(self, f: |v: T| -> Option<T>) {\n         let mut opt = self;\n         loop {\n@@ -433,20 +474,25 @@ impl<T> Option<T> {\n     // Common special cases\n     /////////////////////////////////////////////////////////////////////////\n \n+    /// Deprecated: use `take().unwrap()` instead.\n+    ///\n     /// The option dance. Moves a value out of an option type and returns it,\n     /// replacing the original with `None`.\n     ///\n     /// # Failure\n     ///\n     /// Fails if the value equals `None`.\n     #[inline]\n+    #[deprecated = \"use take().unwrap() instead\"]\n     pub fn take_unwrap(&mut self) -> T {\n         match self.take() {\n             Some(x) => x,\n             None => fail!(\"called `Option::take_unwrap()` on a `None` value\")\n         }\n     }\n \n+    /// Deprecated: use `as_ref().unwrap()` instead.\n+    ///\n     /// Gets an immutable reference to the value inside an option.\n     ///\n     /// # Failure\n@@ -460,13 +506,16 @@ impl<T> Option<T> {\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     #[inline]\n+    #[deprecated = \"use .as_ref().unwrap() instead\"]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Some(ref x) => x,\n             None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n+    /// Deprecated: use `as_mut().unwrap()` instead.\n+    ///\n     /// Gets a mutable reference to the value inside an option.\n     ///\n     /// # Failure\n@@ -480,6 +529,7 @@ impl<T> Option<T> {\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     #[inline]\n+    #[deprecated = \"use .as_mut().unwrap() instead\"]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n             Some(ref mut x) => x,\n@@ -512,6 +562,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -527,6 +578,7 @@ impl<T: Default> Option<T> {\n impl<T> Slice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n+    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n@@ -552,6 +604,7 @@ impl<T> Default for Option<T> {\n /// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n /// methods on `Option`.\n #[deriving(Clone)]\n+#[unstable = \"waiting for iterator conventions\"]\n pub struct Item<A> {\n     opt: Option<A>\n }\n@@ -584,54 +637,62 @@ impl<A> ExactSize<A> for Item<A> {}\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Takes each element in the `Iterator`: if it is `None`, no further\n-/// elements are taken, and the `None` is returned. Should no `None` occur, a\n-/// vector containing the values of each `Option` is returned.\n-///\n-/// Here is an example which increments every integer in a vector,\n-/// checking for overflow:\n-///\n-/// ```rust\n-/// use std::option;\n-/// use std::uint;\n-///\n-/// let v = vec!(1u, 2u);\n-/// let res: Option<Vec<uint>> = option::collect(v.iter().map(|x: &uint|\n-///     if *x == uint::MAX { None }\n-///     else { Some(x + 1) }\n-/// ));\n-/// assert!(res == Some(vec!(2u, 3u)));\n-/// ```\n+/// Deprecated: use `Iterator::collect` instead.\n #[inline]\n-pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {\n-    // FIXME(#11084): This could be replaced with Iterator::scan when this\n-    // performance bug is closed.\n-\n-    struct Adapter<Iter> {\n-        iter: Iter,\n-        found_none: bool,\n-    }\n-\n-    impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n-        #[inline]\n-        fn next(&mut self) -> Option<T> {\n-            match self.iter.next() {\n-                Some(Some(value)) => Some(value),\n-                Some(None) => {\n-                    self.found_none = true;\n-                    None\n+#[deprecated = \"use Iterator::collect instead\"]\n+pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(mut iter: Iter) -> Option<V> {\n+    iter.collect()\n+}\n+\n+impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n+    /// Takes each element in the `Iterator`: if it is `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur, a\n+    /// container with the values of each `Option` is returned.\n+    ///\n+    /// Here is an example which increments every integer in a vector,\n+    /// checking for overflow:\n+    ///\n+    /// ```rust\n+    /// use std::uint;\n+    ///\n+    /// let v = vec!(1u, 2u);\n+    /// let res: Option<Vec<uint>> = v.iter().map(|x: &uint|\n+    ///     if *x == uint::MAX { None }\n+    ///     else { Some(x + 1) }\n+    /// ).collect();\n+    /// assert!(res == Some(vec!(2u, 3u)));\n+    /// ```\n+    #[inline]\n+    fn from_iter<I: Iterator<Option<A>>>(iter: I) -> Option<V> {\n+        // FIXME(#11084): This could be replaced with Iterator::scan when this\n+        // performance bug is closed.\n+\n+        struct Adapter<Iter> {\n+            iter: Iter,\n+            found_none: bool,\n+        }\n+\n+        impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n+            #[inline]\n+            fn next(&mut self) -> Option<T> {\n+                match self.iter.next() {\n+                    Some(Some(value)) => Some(value),\n+                    Some(None) => {\n+                        self.found_none = true;\n+                        None\n+                    }\n+                    None => None,\n                 }\n-                None => None,\n             }\n         }\n-    }\n \n-    let mut adapter = Adapter { iter: iter, found_none: false };\n-    let v: V = FromIterator::from_iter(adapter.by_ref());\n+        let mut adapter = Adapter { iter: iter, found_none: false };\n+        let v: V = FromIterator::from_iter(adapter.by_ref());\n \n-    if adapter.found_none {\n-        None\n-    } else {\n-        Some(v)\n+        if adapter.found_none {\n+            None\n+        } else {\n+            Some(v)\n+        }\n     }\n }"}, {"sha": "bf351ecc89b1fd44702ef8c049c730fc6c99aaf2", "filename": "src/libcore/result.rs", "status": "modified", "additions": 173, "deletions": 41, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -274,17 +274,22 @@\n //! the context. The caller of `fail!` should assume that execution\n //! will not resume after failure, that failure is catastrophic.\n \n+#![stable]\n+\n use clone::Clone;\n use cmp::PartialEq;\n use std::fmt::Show;\n-use iter::{Iterator, FromIterator};\n+use slice;\n+use slice::Slice;\n+use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use option::{None, Option, Some};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n #[must_use]\n+#[stable]\n pub enum Result<T, E> {\n     /// Contains the success value\n     Ok(T),\n@@ -315,6 +320,7 @@ impl<T, E> Result<T, E> {\n     /// # }\n     /// ~~~\n     #[inline]\n+    #[stable]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n@@ -335,6 +341,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(bogus.is_err());\n     /// ~~~\n     #[inline]\n+    #[stable]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n@@ -362,6 +369,7 @@ impl<T, E> Result<T, E> {\n     /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n     /// ~~~\n     #[inline]\n+    #[stable]\n     pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x)  => Some(x),\n@@ -374,6 +382,7 @@ impl<T, E> Result<T, E> {\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the value, if any.\n     #[inline]\n+    #[stable]\n     pub fn err(self) -> Option<E> {\n         match self {\n             Ok(_)  => None,\n@@ -390,6 +399,7 @@ impl<T, E> Result<T, E> {\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n     #[inline]\n+    #[stable]\n     pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n@@ -399,13 +409,28 @@ impl<T, E> Result<T, E> {\n \n     /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n     #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n             Err(ref mut x) => Err(x),\n         }\n     }\n \n+    /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n+    #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n+    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n+        match *self {\n+            Ok(ref mut x) => slice::mut_ref_slice(x),\n+            Err(_) => {\n+                // work around lack of implicit coercion from fixed-size array to slice\n+                let emp: &mut [_] = &mut [];\n+                emp\n+            }\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n@@ -441,6 +466,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ~~~\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n@@ -454,19 +480,47 @@ impl<T, E> Result<T, E> {\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n         }\n     }\n \n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Iterator constructors\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns an iterator over the possibly contained value.\n+    #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n+    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n+        Item{opt: self.as_ref().ok()}\n+    }\n+\n+    /// Returns a mutable iterator over the possibly contained value.\n+    #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n+    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n+        Item{opt: self.as_mut().ok()}\n+    }\n+\n+    /// Returns a consuming iterator over the possibly contained value.\n+    #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n+    pub fn move_iter(self) -> Item<T> {\n+        Item{opt: self.ok()}\n+    }\n+\n     ////////////////////////////////////////////////////////////////////////\n     // Boolean operations on the values, eager and lazy\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     #[inline]\n+    #[stable]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n@@ -478,6 +532,7 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -487,6 +542,7 @@ impl<T, E> Result<T, E> {\n \n     /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n     #[inline]\n+    #[stable]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n             Ok(_) => self,\n@@ -498,6 +554,7 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -508,6 +565,7 @@ impl<T, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// Else it returns `optb`.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -518,6 +576,7 @@ impl<T, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// If the value is an `Err` then it calls `op` with its value.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, op: |E| -> T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -541,6 +600,7 @@ impl<T, E: Show> Result<T, E> {\n     /// Fails if the value is an `Err`, with a custom failure message provided\n     /// by the `Err`'s value.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -558,6 +618,7 @@ impl<T: Show, E> Result<T, E> {\n     /// Fails if the value is an `Ok`, with a custom failure message provided\n     /// by the `Ok`'s value.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -568,57 +629,124 @@ impl<T: Show, E> Result<T, E> {\n }\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Takes each element in the `Iterator`: if it is an `Err`, no further\n-/// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n-/// vector containing the values of each `Result` is returned.\n-///\n-/// Here is an example which increments every integer in a vector,\n-/// checking for overflow:\n-///\n-/// ```rust\n-/// use std::result;\n-/// use std::uint;\n+impl<T, E> Slice<T> for Result<T, E> {\n+    /// Convert from `Result<T, E>` to `&[T]` (without copying)\n+    #[inline]\n+    #[stable]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match *self {\n+            Ok(ref x) => slice::ref_slice(x),\n+            Err(_) => {\n+                // work around lack of implicit coercion from fixed-size array to slice\n+                let emp: &[_] = &[];\n+                emp\n+            }\n+        }\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// The Result Iterator\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// A `Result` iterator that yields either one or zero elements\n ///\n-/// let v = vec!(1u, 2u);\n-/// let res: Result<Vec<uint>, &'static str> = result::collect(v.iter().map(|x: &uint|\n-///     if *x == uint::MAX { Err(\"Overflow!\") }\n-///     else { Ok(x + 1) }\n-/// ));\n-/// assert!(res == Ok(vec!(2u, 3u)));\n-/// ```\n-#[inline]\n-pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {\n-    // FIXME(#11084): This could be replaced with Iterator::scan when this\n-    // performance bug is closed.\n+/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// methods on `Result`.\n+#[deriving(Clone)]\n+#[unstable = \"waiting for iterator conventions\"]\n+pub struct Item<T> {\n+    opt: Option<T>\n+}\n+\n+impl<T> Iterator<T> for Item<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.opt.take()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        match self.opt {\n+            Some(_) => (1, Some(1)),\n+            None => (0, Some(0)),\n+        }\n+    }\n+}\n \n-    struct Adapter<Iter, E> {\n-        iter: Iter,\n-        err: Option<E>,\n+impl<A> DoubleEndedIterator<A> for Item<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        self.opt.take()\n     }\n+}\n+\n+impl<A> ExactSize<A> for Item<A> {}\n \n-    impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n-        #[inline]\n-        fn next(&mut self) -> Option<T> {\n-            match self.iter.next() {\n-                Some(Ok(value)) => Some(value),\n-                Some(Err(err)) => {\n-                    self.err = Some(err);\n-                    None\n+/////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Deprecated: use `Iterator::collect`.\n+#[inline]\n+#[deprecated = \"use Iterator::collect instead\"]\n+pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(mut iter: Iter)\n+                                                                       -> Result<V, E> {\n+    iter.collect()\n+}\n+\n+impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n+    /// container with the values of each `Result` is returned.\n+    ///\n+    /// Here is an example which increments every integer in a vector,\n+    /// checking for overflow:\n+    ///\n+    /// ```rust\n+    /// use std::uint;\n+    ///\n+    /// let v = vec!(1u, 2u);\n+    /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|x: &uint|\n+    ///     if *x == uint::MAX { Err(\"Overflow!\") }\n+    ///     else { Ok(x + 1) }\n+    /// ).collect();\n+    /// assert!(res == Ok(vec!(2u, 3u)));\n+    /// ```\n+    #[inline]\n+    fn from_iter<I: Iterator<Result<A, E>>>(iter: I) -> Result<V, E> {\n+        // FIXME(#11084): This could be replaced with Iterator::scan when this\n+        // performance bug is closed.\n+\n+        struct Adapter<Iter, E> {\n+            iter: Iter,\n+            err: Option<E>,\n+        }\n+\n+        impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n+            #[inline]\n+            fn next(&mut self) -> Option<T> {\n+                match self.iter.next() {\n+                    Some(Ok(value)) => Some(value),\n+                    Some(Err(err)) => {\n+                        self.err = Some(err);\n+                        None\n+                    }\n+                    None => None,\n                 }\n-                None => None,\n             }\n         }\n-    }\n \n-    let mut adapter = Adapter { iter: iter, err: None };\n-    let v: V = FromIterator::from_iter(adapter.by_ref());\n+        let mut adapter = Adapter { iter: iter, err: None };\n+        let v: V = FromIterator::from_iter(adapter.by_ref());\n \n-    match adapter.err {\n-        Some(err) => Err(err),\n-        None => Ok(v),\n+        match adapter.err {\n+            Some(err) => Err(err),\n+            None => Ok(v),\n+        }\n     }\n }\n \n@@ -627,6 +755,7 @@ pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Ite\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n+#[experimental]\n pub fn fold<T,\n             V,\n             E,\n@@ -644,12 +773,15 @@ pub fn fold<T,\n     Ok(init)\n }\n \n+/// Deprecated.\n+///\n /// Perform a trivial fold operation over the result values\n /// from an iterator.\n ///\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, a simple `Ok(())` is returned.\n #[inline]\n+#[deprecated = \"use fold instead\"]\n pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n     fold(iterator, (), |_, _| ())\n }"}, {"sha": "2dad9fc3a22c42def94cc7973600ae2fcfecb0d2", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -73,7 +73,7 @@ fn test_option_dance() {\n     let mut y = Some(5i);\n     let mut y2 = 0;\n     for _x in x.iter() {\n-        y2 = y.take_unwrap();\n+        y2 = y.take().unwrap();\n     }\n     assert_eq!(y2, 5);\n     assert!(y.is_none());\n@@ -82,8 +82,8 @@ fn test_option_dance() {\n #[test] #[should_fail]\n fn test_option_too_much_dance() {\n     let mut y = Some(marker::NoCopy);\n-    let _y2 = y.take_unwrap();\n-    let _y3 = y.take_unwrap();\n+    let _y2 = y.take().unwrap();\n+    let _y3 = y.take().unwrap();\n }\n \n #[test]"}, {"sha": "90afee652646ce71f02bd163a1b0848da88fe0f5", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -106,7 +106,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n     let mut root = os::getcwd();\n     let pat_root = Path::new(pattern).root_path();\n     if pat_root.is_some() {\n-        if check_windows_verbatim(pat_root.get_ref()) {\n+        if check_windows_verbatim(pat_root.as_ref().unwrap()) {\n             // FIXME: How do we want to handle verbatim paths? I'm inclined to return nothing,\n             // since we can't very well find all UNC shares with a 1-letter server name.\n             return Paths {\n@@ -116,7 +116,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n                 todo: Vec::new(),\n             };\n         }\n-        root.push(pat_root.get_ref());\n+        root.push(pat_root.as_ref().unwrap());\n     }\n \n     let root_len = pat_root.map_or(0u, |p| p.as_vec().len());"}, {"sha": "cc77d151231e87484d329aa9245f049f7b0bf6c2", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -305,7 +305,7 @@ pub fn start(argc: int, argv: *const *const u8,\n     let mut main = Some(main);\n     let mut ret = None;\n     simple::task().run(|| {\n-        ret = Some(run(event_loop_factory, main.take_unwrap()));\n+        ret = Some(run(event_loop_factory, main.take().unwrap()));\n     }).destroy();\n     // unsafe is ok b/c we're sure that the runtime is gone\n     unsafe { rt::cleanup() }"}, {"sha": "084a66fdddf154c26f2daef852910273fe7fbbb8", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -203,7 +203,7 @@ impl Scheduler {\n         let mut sched_task = self.run(sched_task);\n \n         // Close the idle callback.\n-        let mut sched = sched_task.sched.take_unwrap();\n+        let mut sched = sched_task.sched.take().unwrap();\n         sched.idle_callback.take();\n         // Make one go through the loop to run the close callback.\n         let mut stask = sched.run(sched_task);\n@@ -702,7 +702,7 @@ impl Scheduler {\n             assert!(sched.sched_task.is_none());\n             sched.sched_task = Some(stask);\n         });\n-        (cur.sched.take_unwrap(), cur)\n+        (cur.sched.take().unwrap(), cur)\n     }\n \n     fn resume_task_immediately_cl(sched: Box<Scheduler>,\n@@ -738,7 +738,7 @@ impl Scheduler {\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n-        let stask = self.sched_task.take_unwrap();\n+        let stask = self.sched_task.take().unwrap();\n         // Otherwise this is the same as below.\n         self.switch_running_tasks_and_then(cur, stask, f)\n     }\n@@ -788,7 +788,7 @@ impl Scheduler {\n                 sched.enqueue_task(last_task);\n             }\n         });\n-        (cur.sched.take_unwrap(), cur)\n+        (cur.sched.take().unwrap(), cur)\n     }\n \n     // * Task Context Helpers\n@@ -800,9 +800,9 @@ impl Scheduler {\n                                   -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n-        let stask = self.sched_task.take_unwrap();\n+        let stask = self.sched_task.take().unwrap();\n         let _cur = self.change_task_context(cur, stask, |sched, mut dead_task| {\n-            let coroutine = dead_task.coroutine.take_unwrap();\n+            let coroutine = dead_task.coroutine.take().unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n             sched.task_state.decrement();\n         });\n@@ -818,7 +818,7 @@ impl Scheduler {\n     }\n \n     pub fn run_task_later(mut cur: Box<GreenTask>, next: Box<GreenTask>) {\n-        let mut sched = cur.sched.take_unwrap();\n+        let mut sched = cur.sched.take().unwrap();\n         sched.enqueue_task(next);\n         cur.put_with_sched(sched);\n     }\n@@ -838,7 +838,7 @@ impl Scheduler {\n             self.yield_check_count = reset_yield_check(&mut self.rng);\n             // Tell the scheduler to start stealing on the next iteration\n             self.steal_for_yield = true;\n-            let stask = self.sched_task.take_unwrap();\n+            let stask = self.sched_task.take().unwrap();\n             let cur = self.change_task_context(cur, stask, |sched, task| {\n                 sched.enqueue_task(task);\n             });\n@@ -878,7 +878,7 @@ impl Scheduler {\n     pub fn sched_id(&self) -> uint { self as *const Scheduler as uint }\n \n     pub fn run_cleanup_job(&mut self) {\n-        let cleanup_job = self.cleanup_job.take_unwrap();\n+        let cleanup_job = self.cleanup_job.take().unwrap();\n         cleanup_job.run(self)\n     }\n \n@@ -1235,7 +1235,7 @@ mod test {\n \n             fn run(next: Box<GreenTask>) {\n                 let mut task = GreenTask::convert(Local::take());\n-                let sched = task.sched.take_unwrap();\n+                let sched = task.sched.take().unwrap();\n                 sched.run_task(task, next)\n             }\n "}, {"sha": "2d67307431b86806b9e27fca75eb8bcb05db13ed", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -110,7 +110,7 @@ extern fn bootstrap_green_task(task: uint, code: *mut (), env: *mut ()) -> ! {\n     // requested. This is the \"try/catch\" block for this green task and\n     // is the wrapper for *all* code run in the task.\n     let mut start = Some(start);\n-    let task = task.swap().run(|| start.take_unwrap()()).destroy();\n+    let task = task.swap().run(|| start.take().unwrap()()).destroy();\n \n     // Once the function has exited, it's time to run the termination\n     // routine. This means we need to context switch one more time but\n@@ -212,7 +212,7 @@ impl GreenTask {\n \n     pub fn take_unwrap_home(&mut self) -> Home {\n         match self.task_type {\n-            TypeGreen(ref mut home) => home.take_unwrap(),\n+            TypeGreen(ref mut home) => home.take().unwrap(),\n             TypeSched => rtabort!(\"type error: used SchedTask as GreenTask\"),\n         }\n     }\n@@ -277,7 +277,7 @@ impl GreenTask {\n     }\n \n     pub fn swap(mut self: Box<GreenTask>) -> Box<Task> {\n-        let mut task = self.task.take_unwrap();\n+        let mut task = self.task.take().unwrap();\n         task.put_runtime(self);\n         return task;\n     }\n@@ -288,7 +288,7 @@ impl GreenTask {\n     }\n \n     fn terminate(mut self: Box<GreenTask>) -> ! {\n-        let sched = self.sched.take_unwrap();\n+        let sched = self.sched.take().unwrap();\n         sched.terminate_current_task(self)\n     }\n \n@@ -324,13 +324,13 @@ impl GreenTask {\n impl Runtime for GreenTask {\n     fn yield_now(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n-        let sched = self.sched.take_unwrap();\n+        let sched = self.sched.take().unwrap();\n         sched.yield_now(self);\n     }\n \n     fn maybe_yield(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n-        let sched = self.sched.take_unwrap();\n+        let sched = self.sched.take().unwrap();\n         sched.maybe_yield(self);\n     }\n \n@@ -339,7 +339,7 @@ impl Runtime for GreenTask {\n                   cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         self.put_task(cur_task);\n-        let mut sched = self.sched.take_unwrap();\n+        let mut sched = self.sched.take().unwrap();\n \n         // In order for this task to be reawoken in all possible contexts, we\n         // may need a handle back in to the current scheduler. When we're woken\n@@ -418,7 +418,7 @@ impl Runtime for GreenTask {\n         match running_task.maybe_take_runtime::<GreenTask>() {\n             Some(mut running_green_task) => {\n                 running_green_task.put_task(running_task);\n-                let sched = running_green_task.sched.take_unwrap();\n+                let sched = running_green_task.sched.take().unwrap();\n \n                 if sched.pool_id == self.pool_id {\n                     sched.run_task(running_green_task, self);"}, {"sha": "06b78a54e53ee8906110ae29d8a41f3dde70831d", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -119,7 +119,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n-        let mut cb = timer.cb.take_unwrap();\n+        let mut cb = timer.cb.take().unwrap();\n         cb.call();\n         if timer.repeat {\n             timer.cb = Some(cb);"}, {"sha": "06f89d38ca0a183da8e7b9a8795a53ade841ec39", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -139,7 +139,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n         unsafe {\n             rt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n-        exit_code = Some(run(main.take_unwrap()));\n+        exit_code = Some(run(main.take().unwrap()));\n     }).destroy());\n     unsafe { rt::cleanup(); }\n     // If the exit code wasn't set, then the task block must have failed."}, {"sha": "ba3f101720fa858a7f66af12b3adf1aafd224bf3", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -92,7 +92,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n         let mut f = Some(f);\n         let mut task = task;\n         task.put_runtime(ops);\n-        drop(task.run(|| { f.take_unwrap()() }).destroy());\n+        drop(task.run(|| { f.take().unwrap()() }).destroy());\n         drop(token);\n     })\n }"}, {"sha": "da20c945cb04a5befc52d6695a137c32efd5d5b5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -223,7 +223,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let mut addl_plugins = Some(addl_plugins);\n     let Plugins { macros, registrars }\n         = time(time_passes, \"plugin loading\", (), |_|\n-               plugin::load::load_plugins(sess, &krate, addl_plugins.take_unwrap()));\n+               plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n     let mut registry = Registry::new(&krate);\n "}, {"sha": "8952e565008e8fd5d9b60780db664b2bb19dc665", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -207,7 +207,7 @@ pub struct Context<'a> {\n macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lints.passes.take_unwrap();\n+    let mut passes = $cx.lints.passes.take().unwrap();\n     for obj in passes.mut_iter() {\n         obj.$f($cx, $($args),*);\n     }"}, {"sha": "f05602bbb58c830fabc42bc4cf9b418a06781887", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -166,7 +166,7 @@ impl<'a> Drop for StatRecorder<'a> {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats.n_llvm_insns.get();\n-            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take_unwrap(),\n+            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take().unwrap(),\n                                                        elapsed,\n                                                        iend - self.istart));\n             self.ccx.stats.n_fns.set(self.ccx.stats.n_fns.get() + 1);"}, {"sha": "f2a7f1dc4f8ee287d9814bb153384857b05ca6c6", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -147,7 +147,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             decl_internal_rust_fn(ccx, mono_ty, s.as_slice())\n         };\n \n-        ccx.monomorphized.borrow_mut().insert(hash_id.take_unwrap(), lldecl);\n+        ccx.monomorphized.borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n "}, {"sha": "f7962455c03e332e7f1b4ec4dfa27867f7c19258", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -108,7 +108,7 @@ fn try_inline_def(cx: &core::DocContext,\n         _ => return None,\n     };\n     let fqn = csearch::get_item_path(tcx, did);\n-    cx.inlined.borrow_mut().get_mut_ref().insert(did);\n+    cx.inlined.borrow_mut().as_mut().unwrap().insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(fqn.last().unwrap().to_string()),\n@@ -142,7 +142,7 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n         core::Typed(ref tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n             let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n-            cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+            cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n         core::NotTyped(..) => {}\n     }\n@@ -272,7 +272,7 @@ fn build_impls(cx: &core::DocContext,\n fn build_impl(cx: &core::DocContext,\n               tcx: &ty::ctxt,\n               did: ast::DefId) -> Option<clean::Item> {\n-    if !cx.inlined.borrow_mut().get_mut_ref().insert(did) {\n+    if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n         return None\n     }\n "}, {"sha": "a630d6bb5f67a4777a9d3b39d923c874bf9c7f4d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -468,7 +468,7 @@ impl Clean<TyParam> for ast::TyParam {\n \n impl Clean<TyParam> for ty::TypeParameterDef {\n     fn clean(&self) -> TyParam {\n-        get_cx().external_typarams.borrow_mut().get_mut_ref()\n+        get_cx().external_typarams.borrow_mut().as_mut().unwrap()\n                 .insert(self.def_id, self.ident.clean());\n         TyParam {\n             name: self.ident.clean(),\n@@ -549,8 +549,8 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n-        cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n-                                                            (fqn, TypeTrait));\n+        cx.external_paths.borrow_mut().as_mut().unwrap().insert(did,\n+                                                                (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n             path: path,\n             typarams: None,\n@@ -571,7 +571,7 @@ impl Clean<TyParamBound> for ty::TraitRef {\n                      .collect::<Vec<String>>();\n         let path = external_path(fqn.last().unwrap().as_slice(),\n                                  &self.substs);\n-        cx.external_paths.borrow_mut().get_mut_ref().insert(self.def_id,\n+        cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n             path: path,\n@@ -1299,7 +1299,7 @@ impl Clean<Type> for ty::t {\n                 };\n                 let path = external_path(fqn.last().unwrap().to_string().as_slice(),\n                                          substs);\n-                get_cx().external_paths.borrow_mut().get_mut_ref()\n+                get_cx().external_paths.borrow_mut().as_mut().unwrap()\n                                        .insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n@@ -2091,7 +2091,7 @@ fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n     match kind {\n         TypeTrait => {\n             let t = inline::build_external_trait(tcx, did);\n-            cx.external_traits.borrow_mut().get_mut_ref().insert(did, t);\n+            cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n         }\n         _ => {}\n     }\n@@ -2158,7 +2158,7 @@ fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n     let fqn: Vec<String> = fqn.move_iter().map(|i| {\n         i.to_string()\n     }).collect();\n-    get_cx().external_paths.borrow_mut().get_mut_ref()\n+    get_cx().external_paths.borrow_mut().as_mut().unwrap()\n                            .insert(did, (fqn, TypeStruct));\n     ResolvedPath {\n         typarams: None,"}, {"sha": "f9cf881ab04c9831d1ff29cf8beb454a49623cb0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -297,7 +297,7 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n     let public_items = public_items.unwrap_or(NodeSet::new());\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n-        let paths = a.external_paths.borrow_mut().take_unwrap();\n+        let paths = a.external_paths.borrow_mut().take().unwrap();\n         paths.move_iter().map(|(k, (v, t))| {\n             (k, (v, match t {\n                 clean::TypeStruct => item_type::Struct,\n@@ -325,13 +325,13 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n         traits: analysis.as_ref().map(|a| {\n-            a.external_traits.borrow_mut().take_unwrap()\n+            a.external_traits.borrow_mut().take().unwrap()\n         }).unwrap_or(HashMap::new()),\n         typarams: analysis.as_ref().map(|a| {\n-            a.external_typarams.borrow_mut().take_unwrap()\n+            a.external_typarams.borrow_mut().take().unwrap()\n         }).unwrap_or(HashMap::new()),\n         inlined: analysis.as_ref().map(|a| {\n-            a.inlined.borrow_mut().take_unwrap()\n+            a.inlined.borrow_mut().take().unwrap()\n         }).unwrap_or(HashSet::new()),\n     };\n     cache.stack.push(krate.name.clone());\n@@ -805,7 +805,7 @@ impl DocFolder for Cache {\n                         v.push(Implementor {\n                             def_id: item.def_id,\n                             generics: i.generics.clone(),\n-                            trait_: i.trait_.get_ref().clone(),\n+                            trait_: i.trait_.as_ref().unwrap().clone(),\n                             for_: i.for_.clone(),\n                             stability: item.stability.clone(),\n                         });\n@@ -878,7 +878,7 @@ impl DocFolder for Cache {\n \n         // Keep track of the fully qualified path for this item.\n         let pushed = if item.name.is_some() {\n-            let n = item.name.get_ref();\n+            let n = item.name.as_ref().unwrap();\n             if n.len() > 0 {\n                 self.stack.push(n.to_string());\n                 true\n@@ -1125,7 +1125,7 @@ impl Context {\n                 if title.len() > 0 {\n                     title.push_str(\"::\");\n                 }\n-                title.push_str(it.name.get_ref().as_slice());\n+                title.push_str(it.name.as_ref().unwrap().as_slice());\n             }\n             title.push_str(\" - Rust\");\n             let tyname = shortty(it).to_static_str();\n@@ -1191,10 +1191,10 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n-                let name = item.name.get_ref().to_string();\n+                let name = item.name.as_ref().unwrap().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n-                    let item = item.take_unwrap();\n+                    let item = item.take().unwrap();\n                     let dst = this.dst.join(\"index.html\");\n                     let dst = try!(File::create(&dst));\n                     try!(render(dst, this, &item, false));\n@@ -1398,7 +1398,7 @@ fn item_path(item: &clean::Item) -> String {\n fn full_path(cx: &Context, item: &clean::Item) -> String {\n     let mut s = cx.current.connect(\"::\");\n     s.push_str(\"::\");\n-    s.push_str(item.name.get_ref().as_slice());\n+    s.push_str(item.name.as_ref().unwrap().as_slice());\n     return s\n }\n \n@@ -1809,7 +1809,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \" {{\\n\"));\n         for v in e.variants.iter() {\n             try!(write!(w, \"    \"));\n-            let name = v.name.get_ref().as_slice();\n+            let name = v.name.as_ref().unwrap().as_slice();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n@@ -2098,7 +2098,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let curty = shortty(cur).to_static_str();\n-                let class = if cur.name.get_ref() == item &&\n+                let class = if cur.name.as_ref().unwrap() == item &&\n                                short == curty { \"current\" } else { \"\" };\n                 try!(write!(w, \"<a class='{ty} {class}' href='{href}{path}'>\\\n                                 {name}</a>\","}, {"sha": "2f140aa8a6802c2841d08419a4b56821f621f48a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -385,7 +385,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n-    match krate.module.get_ref().doc_list() {\n+    match krate.module.as_ref().unwrap().doc_list() {\n         Some(nested) => {\n             for inner in nested.iter() {\n                 match *inner {"}, {"sha": "9d921943313d8e206d125474e97b1afd9263f69a", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -384,7 +384,7 @@ impl Task {\n         //      function, and I would be saddened if more usage of the function\n         //      crops up.\n         unsafe {\n-            let imp = self.imp.take_unwrap();\n+            let imp = self.imp.take().unwrap();\n             let vtable = mem::transmute::<_, &raw::TraitObject>(&imp).vtable;\n             match imp.wrap().downcast::<T>() {\n                 Ok(t) => Some(t),\n@@ -407,7 +407,7 @@ impl Task {\n     pub fn spawn_sibling(mut self: Box<Task>,\n                          opts: TaskOpts,\n                          f: proc(): Send) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.spawn_sibling(self, opts, f)\n     }\n \n@@ -417,51 +417,51 @@ impl Task {\n     pub fn deschedule(mut self: Box<Task>,\n                       amt: uint,\n                       f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.deschedule(amt, self, f)\n     }\n \n     /// Wakes up a previously blocked task, optionally specifying whether the\n     /// current task can accept a change in scheduling. This function can only\n     /// be called on tasks that were previously blocked in `deschedule`.\n     pub fn reawaken(mut self: Box<Task>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.reawaken(self);\n     }\n \n     /// Yields control of this task to another task. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n     /// opportunity to allow other tasks a chance to run.\n     pub fn yield_now(mut self: Box<Task>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.yield_now(self);\n     }\n \n     /// Similar to `yield_now`, except that this function may immediately return\n     /// without yielding (depending on what the runtime decides to do).\n     pub fn maybe_yield(mut self: Box<Task>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.maybe_yield(self);\n     }\n \n     /// Acquires a handle to the I/O factory that this task contains, normally\n     /// stored in the task's runtime. This factory may not always be available,\n     /// which is why the return type is `Option`\n     pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {\n-        self.imp.get_mut_ref().local_io()\n+        self.imp.as_mut().unwrap().local_io()\n     }\n \n     /// Returns the stack bounds for this task in (lo, hi) format. The stack\n     /// bounds may not be known for all tasks, so the return value may be\n     /// `None`.\n     pub fn stack_bounds(&self) -> (uint, uint) {\n-        self.imp.get_ref().stack_bounds()\n+        self.imp.as_ref().unwrap().stack_bounds()\n     }\n \n     /// Returns whether it is legal for this task to block the OS thread that it\n     /// is running on.\n     pub fn can_block(&self) -> bool {\n-        self.imp.get_ref().can_block()\n+        self.imp.as_ref().unwrap().can_block()\n     }\n \n     /// Consume this task, flagging it as a candidate for destruction."}, {"sha": "1f0b0c7c207bfbb540ee66d7bf256f902531304d", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -128,7 +128,7 @@ impl<T: Send> Thread<T> {\n         unsafe { imp::join(self.native) };\n         self.joined = true;\n         assert!(self.packet.is_some());\n-        self.packet.take_unwrap()\n+        self.packet.take().unwrap()\n     }\n }\n "}, {"sha": "8b41219db62f154d6b2837b6524aaf9742f1a359", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -86,7 +86,7 @@ impl GetAddrInfoRequest {\n                 });\n \n                 match cx.status {\n-                    0 => Ok(accum_addrinfo(cx.addrinfo.get_ref())),\n+                    0 => Ok(accum_addrinfo(cx.addrinfo.as_ref().unwrap())),\n                     n => Err(UvError(n))\n                 }\n             }"}, {"sha": "8bed4cfb8114b590c800b9ba630928ed4f2694d8", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -136,7 +136,7 @@ mod test_remote {\n                 // once\n                 let MyCallback(ref mut s) = *self;\n                 if s.is_some() {\n-                    s.take_unwrap().send(1);\n+                    s.take().unwrap().send(1);\n                 }\n             }\n         }"}, {"sha": "561a4dffe82f2f6aef886041d404c698fd4ab14f", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -259,7 +259,7 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>,\n \n fn wakeup(slot: &mut Option<BlockedTask>) {\n     assert!(slot.is_some());\n-    let _ = slot.take_unwrap().wake().map(|t| t.reawaken());\n+    let _ = slot.take().unwrap().wake().map(|t| t.reawaken());\n }\n \n pub struct Request {"}, {"sha": "09d008a9fa9046e666877fd6aa94c8404c93946d", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -596,7 +596,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 wait_until_woken_after(&mut cx.task, &loop_, || {\n                     unsafe { uvll::set_data_for_uv_handle(handle, &mut cx) }\n                 });\n-                match cx.result.take_unwrap() {\n+                match cx.result.take().unwrap() {\n                     (n, _) if n < 0 =>\n                         Err(uv_error_to_io_error(UvError(n as c_int))),\n                     (n, addr) => Ok((n as uint, addr.unwrap()))\n@@ -657,7 +657,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         // here.\n         let data = if guard.can_timeout {Some(Vec::from_slice(buf))} else {None};\n         let uv_buf = if guard.can_timeout {\n-            slice_to_uv_buf(data.get_ref().as_slice())\n+            slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {\n             slice_to_uv_buf(buf)\n         };"}, {"sha": "4a12f959ad9a530c8616f52c3e83636ccfa0f205", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -297,7 +297,7 @@ impl rtio::RtioProcess for Process {\n             self.timer = Some(timer);\n         }\n \n-        let timer = self.timer.get_mut_ref();\n+        let timer = self.timer.as_mut().unwrap();\n         timer.stop();\n         timer.start(timer_cb, ms, 0);\n         self.timeout_state = TimeoutPending;"}, {"sha": "12831002b65ec3c1730334a4d808d1707623531d", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -161,7 +161,7 @@ impl StreamWatcher {\n         // bytes.\n         let data = if may_timeout {Some(Vec::from_slice(buf))} else {None};\n         let uv_buf = if may_timeout {\n-            slice_to_uv_buf(data.get_ref().as_slice())\n+            slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {\n             slice_to_uv_buf(buf)\n         };"}, {"sha": "6b550288f6726f93ecbc0a30ba24283e4994411c", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -148,7 +148,7 @@ impl<T: Send> AccessTimeout<T> {\n             self.timer = Some(timer);\n         }\n \n-        let timer = self.timer.get_mut_ref();\n+        let timer = self.timer.as_mut().unwrap();\n         unsafe {\n             let cx = uvll::get_data_for_uv_handle(timer.handle);\n             let cx = cx as *mut TimerContext;"}, {"sha": "412506604c674cc50bf90e8e1c6939ce47b91e87", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -132,9 +132,9 @@ extern fn timer_cb(handle: *mut uvll::uv_timer_t) {\n     let _f = ForbidSwitch::new(\"timer callback can't switch\");\n     let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n-    match timer.action.take_unwrap() {\n+    match timer.action.take().unwrap() {\n         WakeTask => {\n-            let task = timer.blocker.take_unwrap();\n+            let task = timer.blocker.take().unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n         CallOnce(mut cb) => { cb.call() }"}, {"sha": "30b172c5b6bf010cf229de1b73e463e3b6190eda", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -66,7 +66,7 @@ impl Drop for UvEventLoop {\n         // Lastly, after we've closed the pool of handles we pump the event loop\n         // one last time to run any closing callbacks to make sure the loop\n         // shuts down cleanly.\n-        let handle = self.uvio.handle_pool.get_ref().handle();\n+        let handle = self.uvio.handle_pool.as_ref().unwrap().handle();\n         drop(self.uvio.handle_pool.take());\n         self.run();\n \n@@ -132,7 +132,7 @@ impl UvIoFactory {\n         // It's understood by the homing code that the \"local id\" is just the\n         // pointer of the local I/O factory cast to a uint.\n         let id: uint = unsafe { mem::transmute_copy(&self) };\n-        HomeHandle::new(id, &mut **self.handle_pool.get_mut_ref())\n+        HomeHandle::new(id, &mut **self.handle_pool.as_mut().unwrap())\n     }\n }\n "}, {"sha": "0c63f1a901f5a248cfef32e275e908c1b94c24b6", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -182,7 +182,7 @@ impl<W: Writer> BufferedWriter<W> {\n     pub fn unwrap(mut self) -> W {\n         // FIXME(#12628): is failing the right thing to do if flushing fails?\n         self.flush_buf().unwrap();\n-        self.inner.take_unwrap()\n+        self.inner.take().unwrap()\n     }\n }\n "}, {"sha": "c1f4161fe181fc7d1386c47068ee019c0257f644", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -54,7 +54,7 @@ use collections::HashMap;\n ///     Err(e) => fail!(\"failed to execute child: {}\", e),\n /// };\n ///\n-/// let contents = child.stdout.get_mut_ref().read_to_end();\n+/// let contents = child.stdout.as_mut().unwrap().read_to_end();\n /// assert!(child.wait().unwrap().success());\n /// ```\n pub struct Process {\n@@ -95,7 +95,7 @@ pub type EnvMap = HashMap<CString, CString>;\n ///   Err(e) => fail!(\"failed to execute process: {}\", e),\n /// };\n ///\n-/// let output = process.stdout.get_mut_ref().read_to_end();\n+/// let output = process.stdout.as_mut().unwrap().read_to_end();\n /// ```\n #[deriving(Clone)]\n pub struct Command {"}, {"sha": "8def5d5c99752d76728b0a12cf7af7ed106eaf11", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -70,7 +70,7 @@ impl TempDir {\n     /// temporary directory is prevented.\n     pub fn unwrap(self) -> Path {\n         let mut tmpdir = self;\n-        tmpdir.path.take_unwrap()\n+        tmpdir.path.take().unwrap()\n     }\n \n     /// Access the wrapped `std::path::Path` to the temporary directory."}, {"sha": "5b3cf33ebf0934d9a1128b4599cf4087b110b218", "filename": "src/libsync/comm/oneshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -107,7 +107,7 @@ impl<T: Send> Packet<T> {\n             // Couldn't send the data, the port hung up first. Return the data\n             // back up the stack.\n             DISCONNECTED => {\n-                Err(self.data.take_unwrap())\n+                Err(self.data.take().unwrap())\n             }\n \n             // Not possible, these are one-use channels\n@@ -244,7 +244,7 @@ impl<T: Send> Packet<T> {\n             // There's data on the channel, so make sure we destroy it promptly.\n             // This is why not using an arc is a little difficult (need the box\n             // to stay valid while we take the data).\n-            DATA => { self.data.take_unwrap(); }\n+            DATA => { self.data.take().unwrap(); }\n \n             // We're the only ones that can block on this port\n             _ => unreachable!()"}, {"sha": "528a15cf6d7658a10bb26332d814e10794eee340", "filename": "src/libsync/comm/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -347,7 +347,7 @@ impl<T: Send> Packet<T> {\n         let waiter = match mem::replace(&mut state.blocker, NoneBlocked) {\n             NoneBlocked => None,\n             BlockedSender(task) => {\n-                *state.canceled.take_unwrap() = true;\n+                *state.canceled.take().unwrap() = true;\n                 Some(task)\n             }\n             BlockedReceiver(..) => unreachable!(),\n@@ -434,7 +434,7 @@ impl<T> Buffer<T> {\n         let start = self.start;\n         self.size -= 1;\n         self.start = (self.start + 1) % self.buf.len();\n-        self.buf.get_mut(start).take_unwrap()\n+        self.buf.get_mut(start).take().unwrap()\n     }\n \n     fn size(&self) -> uint { self.size }\n@@ -481,7 +481,7 @@ impl Queue {\n         }\n         unsafe {\n             (*node).next = 0 as *mut Node;\n-            Some((*node).task.take_unwrap())\n+            Some((*node).task.take().unwrap())\n         }\n     }\n }"}, {"sha": "ad2539fc260082c9028ece661853ad1bf1a8034c", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -122,7 +122,7 @@ impl<T: Send> Queue<T> {\n                 *self.tail.get() = next;\n                 assert!((*tail).value.is_none());\n                 assert!((*next).value.is_some());\n-                let ret = (*next).value.take_unwrap();\n+                let ret = (*next).value.take().unwrap();\n                 let _: Box<Node<T>> = mem::transmute(tail);\n                 return Data(ret);\n             }"}, {"sha": "245a7666a64a9583645dea5036b1005474a3b9c6", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -266,7 +266,7 @@ impl<'a> Condvar<'a> {\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n             (|| {\n-                let _ = wait_end.take_unwrap().recv();\n+                let _ = wait_end.take().unwrap().recv();\n             }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {\n@@ -325,7 +325,7 @@ impl<'a> Condvar<'a> {\n                               condvar_id,\n                               \"cond.signal_on()\",\n                               || {\n-                queue.take_unwrap().broadcast()\n+                queue.take().unwrap().broadcast()\n             })\n         }\n     }"}, {"sha": "88f9c2b4ce39db28e04856b7c65aec1bcf962570", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -245,7 +245,7 @@ impl<'a> Iterator<&'a str> for Graphemes<'a> {\n             // looking up each character twice.\n             cat = match self.cat {\n                 None => gr::grapheme_category(ch),\n-                _ => self.cat.take_unwrap()\n+                _ => self.cat.take().unwrap()\n             };\n \n             if match cat {\n@@ -345,7 +345,7 @@ impl<'a> DoubleEndedIterator<&'a str> for Graphemes<'a> {\n             // cached category, if any\n             cat = match self.catb {\n                 None => gr::grapheme_category(ch),\n-                _ => self.catb.take_unwrap()\n+                _ => self.catb.take().unwrap()\n             };\n \n             // a matching state machine that runs *backwards* across an input string"}, {"sha": "ebd5aa4b37bec1790284b61ba2adee2f6ef42551", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -52,8 +52,8 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     // Send/Receive lots of messages.\n     for j in range(0u, count) {\n         //println!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take_unwrap();\n-        let num_port2 = num_port.take_unwrap();\n+        let num_chan2 = num_chan.take().unwrap();\n+        let num_port2 = num_port.take().unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}, {"sha": "764d80984c3040189c86de52ca7a4501c3ebbb1b", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e92c67dc0318a52fe42c3c0bca408f76c7feb61/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=2e92c67dc0318a52fe42c3c0bca408f76c7feb61", "patch": "@@ -52,8 +52,8 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     // Send/Receive lots of messages.\n     for j in range(0u, count) {\n         //println!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take_unwrap();\n-        let num_port2 = num_port.take_unwrap();\n+        let num_chan2 = num_chan.take().unwrap();\n+        let num_port2 = num_port.take().unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}]}