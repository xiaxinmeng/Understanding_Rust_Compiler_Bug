{"sha": "43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzY2MzMmZiYjI1MDZlZmYwMDkwZTg5NGMxZThhNDZiNjJhOGViMGI=", "commit": {"author": {"name": "Michael Bradshaw", "email": "mjbshaw@google.com", "date": "2018-09-30T02:51:09Z"}, "committer": {"name": "Michael Bradshaw", "email": "mjbshaw@google.com", "date": "2018-09-30T02:51:09Z"}, "message": "Merge branch 'master' into drop", "tree": {"sha": "ac301fe1be819c25d833880da0ab32bf550016eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac301fe1be819c25d833880da0ab32bf550016eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "html_url": "https://github.com/rust-lang/rust/commit/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/comments", "author": {"login": "mjbshaw", "id": 1204698, "node_id": "MDQ6VXNlcjEyMDQ2OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1204698?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjbshaw", "html_url": "https://github.com/mjbshaw", "followers_url": "https://api.github.com/users/mjbshaw/followers", "following_url": "https://api.github.com/users/mjbshaw/following{/other_user}", "gists_url": "https://api.github.com/users/mjbshaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjbshaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjbshaw/subscriptions", "organizations_url": "https://api.github.com/users/mjbshaw/orgs", "repos_url": "https://api.github.com/users/mjbshaw/repos", "events_url": "https://api.github.com/users/mjbshaw/events{/privacy}", "received_events_url": "https://api.github.com/users/mjbshaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mjbshaw", "id": 1204698, "node_id": "MDQ6VXNlcjEyMDQ2OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1204698?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjbshaw", "html_url": "https://github.com/mjbshaw", "followers_url": "https://api.github.com/users/mjbshaw/followers", "following_url": "https://api.github.com/users/mjbshaw/following{/other_user}", "gists_url": "https://api.github.com/users/mjbshaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjbshaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjbshaw/subscriptions", "organizations_url": "https://api.github.com/users/mjbshaw/orgs", "repos_url": "https://api.github.com/users/mjbshaw/repos", "events_url": "https://api.github.com/users/mjbshaw/events{/privacy}", "received_events_url": "https://api.github.com/users/mjbshaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aec5330082a0c4664abf0f6604c1b05768a90234", "url": "https://api.github.com/repos/rust-lang/rust/commits/aec5330082a0c4664abf0f6604c1b05768a90234", "html_url": "https://github.com/rust-lang/rust/commit/aec5330082a0c4664abf0f6604c1b05768a90234"}, {"sha": "9653f790333d1270f36f1614e85d8a7b54193e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/9653f790333d1270f36f1614e85d8a7b54193e75", "html_url": "https://github.com/rust-lang/rust/commit/9653f790333d1270f36f1614e85d8a7b54193e75"}], "stats": {"total": 10393, "additions": 7140, "deletions": 3253}, "files": [{"sha": "08470e731d8e7390f89d8479f0d9a363089268ad", "filename": "RELEASES.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1,3 +1,16 @@\n+Version 1.29.1 (2018-09-25)\n+===========================\n+\n+Security Notes\n+--------------\n+\n+- The standard library's `str::repeat` function contained an out of bounds write\n+  caused by an integer overflow. This has been fixed by deterministically\n+  panicking when an overflow happens.\n+\n+  Thank you to Scott McMurray for responsibily disclosing this vulnerability to\n+  us.\n+\n Version 1.29.0 (2018-09-13)\n ==========================\n "}, {"sha": "5a44b696a03e16e22fd4dd7757d802ecf98d3603", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -344,6 +344,7 @@ dependencies = [\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2372,6 +2373,7 @@ dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"rustc_typeck 0.0.0\","}, {"sha": "47f45a0b91f8572ff12eab0ece815c8ff5fdd798", "filename": "src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Femit-stack-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Femit-stack-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Femit-stack-sizes.md?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,167 @@\n+# `emit-stack-sizes`\n+\n+The tracking issue for this feature is: [#54192]\n+\n+[#54192]: https://github.com/rust-lang/rust/issues/54192\n+\n+------------------------\n+\n+The rustc flag `-Z emit-stack-sizes` makes LLVM emit stack size metadata.\n+\n+> **NOTE**: This LLVM feature only supports the ELF object format as of LLVM\n+> 8.0. Using this flag with targets that use other object formats (e.g. macOS\n+> and Windows) will result in it being ignored.\n+\n+Consider this crate:\n+\n+```\n+#![crate_type = \"lib\"]\n+\n+use std::ptr;\n+\n+pub fn foo() {\n+    // this function doesn't use the stack\n+}\n+\n+pub fn bar() {\n+    let xs = [0u32; 2];\n+\n+    // force LLVM to allocate `xs` on the stack\n+    unsafe { ptr::read_volatile(&xs.as_ptr()); }\n+}\n+```\n+\n+Using the `-Z emit-stack-sizes` flag produces extra linker sections in the\n+output *object file*.\n+\n+``` console\n+$ rustc -C opt-level=3 --emit=obj foo.rs\n+\n+$ size -A foo.o\n+foo.o  :\n+section                                 size   addr\n+.text                                      0      0\n+.text._ZN3foo3foo17he211d7b4a3a0c16eE      1      0\n+.text._ZN3foo3bar17h1acb594305f70c2eE     22      0\n+.note.GNU-stack                            0      0\n+.eh_frame                                 72      0\n+Total                                     95\n+\n+$ rustc -C opt-level=3 --emit=obj -Z emit-stack-sizes foo.rs\n+\n+$ size -A foo.o\n+foo.o  :\n+section                                 size   addr\n+.text                                      0      0\n+.text._ZN3foo3foo17he211d7b4a3a0c16eE      1      0\n+.stack_sizes                               9      0\n+.text._ZN3foo3bar17h1acb594305f70c2eE     22      0\n+.stack_sizes                               9      0\n+.note.GNU-stack                            0      0\n+.eh_frame                                 72      0\n+Total                                    113\n+```\n+\n+As of LLVM 7.0 the data will be written into a section named `.stack_sizes` and\n+the format is \"an array of pairs of function symbol values (pointer size) and\n+stack sizes (unsigned LEB128)\".\n+\n+``` console\n+$ objdump -d foo.o\n+\n+foo.o:     file format elf64-x86-64\n+\n+Disassembly of section .text._ZN3foo3foo17he211d7b4a3a0c16eE:\n+\n+0000000000000000 <_ZN3foo3foo17he211d7b4a3a0c16eE>:\n+   0:   c3                      retq\n+\n+Disassembly of section .text._ZN3foo3bar17h1acb594305f70c2eE:\n+\n+0000000000000000 <_ZN3foo3bar17h1acb594305f70c2eE>:\n+   0:   48 83 ec 10             sub    $0x10,%rsp\n+   4:   48 8d 44 24 08          lea    0x8(%rsp),%rax\n+   9:   48 89 04 24             mov    %rax,(%rsp)\n+   d:   48 8b 04 24             mov    (%rsp),%rax\n+  11:   48 83 c4 10             add    $0x10,%rsp\n+  15:   c3                      retq\n+\n+$ objdump -s -j .stack_sizes foo.o\n+\n+foo.o:     file format elf64-x86-64\n+\n+Contents of section .stack_sizes:\n+ 0000 00000000 00000000 00                 .........\n+Contents of section .stack_sizes:\n+ 0000 00000000 00000000 10                 .........\n+```\n+\n+It's important to note that linkers will discard this linker section by default.\n+To preserve the section you can use a linker script like the one shown below.\n+\n+``` text\n+/* file: keep-stack-sizes.x */\n+SECTIONS\n+{\n+  /* `INFO` makes the section not allocatable so it won't be loaded into memory */\n+  .stack_sizes (INFO) :\n+  {\n+    KEEP(*(.stack_sizes));\n+  }\n+}\n+```\n+\n+The linker script must be passed to the linker using a rustc flag like `-C\n+link-arg`.\n+\n+```\n+// file: src/main.rs\n+use std::ptr;\n+\n+#[inline(never)]\n+fn main() {\n+    let xs = [0u32; 2];\n+\n+    // force LLVM to allocate `xs` on the stack\n+    unsafe { ptr::read_volatile(&xs.as_ptr()); }\n+}\n+```\n+\n+``` console\n+$ RUSTFLAGS=\"-Z emit-stack-sizes\" cargo build --release\n+\n+$ size -A target/release/hello | grep stack_sizes || echo section was not found\n+section was not found\n+\n+$ RUSTFLAGS=\"-Z emit-stack-sizes\" cargo rustc --release -- \\\n+    -C link-arg=-Wl,-Tkeep-stack-sizes.x \\\n+    -C link-arg=-N\n+\n+$ size -A target/release/hello | grep stack_sizes\n+.stack_sizes                               90   176272\n+\n+$ # non-allocatable section (flags don't contain the \"A\" (alloc) flag)\n+$ readelf -S target/release/hello\n+Section Headers:\n+  [Nr]   Name              Type             Address           Offset\n+       Size              EntSize            Flags  Link  Info  Align\n+(..)\n+  [1031] .stack_sizes      PROGBITS         000000000002b090  0002b0f0\n+       000000000000005a  0000000000000000   L       5     0     1\n+\n+$ objdump -s -j .stack_sizes target/release/hello\n+\n+target/release/hello:     file format elf64-x86-64\n+\n+Contents of section .stack_sizes:\n+ 2b090 c0040000 00000000 08f00400 00000000  ................\n+ 2b0a0 00080005 00000000 00000810 05000000  ................\n+ 2b0b0 00000000 20050000 00000000 10400500  .... ........@..\n+ 2b0c0 00000000 00087005 00000000 00000080  ......p.........\n+ 2b0d0 05000000 00000000 90050000 00000000  ................\n+ 2b0e0 00a00500 00000000 0000               ..........\n+```\n+\n+> Author note: I'm not entirely sure why, in *this* case, `-N` is required in\n+> addition to `-Tkeep-stack-sizes.x`. For example, it's not required when\n+> producing statically linked files for the ARM Cortex-M architecture."}, {"sha": "216915dba5fe7c03116d1cf2906afd7bbafe392f", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -322,11 +322,8 @@ def to_string(self):\n     def children(self):\n         (length, data_ptr) = \\\n             rustpp.extract_length_and_ptr_from_std_btreeset(self.__val)\n-        leaf_node = GdbValue(data_ptr.get_wrapped_value().dereference())\n-        maybe_uninit_keys = leaf_node.get_child_at_index(3)\n-        manually_drop_keys = maybe_uninit_keys.get_child_at_index(1)\n-        keys = manually_drop_keys.get_child_at_index(0)\n-        gdb_ptr = keys.get_wrapped_value()\n+        val = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(3)\n+        gdb_ptr = val.get_wrapped_value()\n         for index in xrange(length):\n             yield (str(index), gdb_ptr[index])\n \n@@ -348,14 +345,9 @@ def to_string(self):\n     def children(self):\n         (length, data_ptr) = \\\n             rustpp.extract_length_and_ptr_from_std_btreemap(self.__val)\n-        leaf_node = GdbValue(data_ptr.get_wrapped_value().dereference())\n-        maybe_uninit_keys = leaf_node.get_child_at_index(3)\n-        manually_drop_keys = maybe_uninit_keys.get_child_at_index(1)\n-        keys = manually_drop_keys.get_child_at_index(0)\n+        keys = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(3)\n         keys_ptr = keys.get_wrapped_value()\n-        maybe_uninit_vals = leaf_node.get_child_at_index(4)\n-        manually_drop_vals = maybe_uninit_vals.get_child_at_index(1)\n-        vals = manually_drop_vals.get_child_at_index(0)\n+        vals = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(4)\n         vals_ptr = vals.get_wrapped_value()\n         for index in xrange(length):\n             yield (str(index), keys_ptr[index])"}, {"sha": "0315545262b6bc0a295953f22b4328070223356b", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -42,7 +42,7 @@\n //   This implies that even an empty internal node has at least one edge.\n \n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n+use core::mem;\n use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n@@ -73,7 +73,7 @@ struct LeafNode<K, V> {\n     /// This node's index into the parent node's `edges` array.\n     /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n     /// This is only guaranteed to be initialized when `parent` is nonnull.\n-    parent_idx: MaybeUninit<u16>,\n+    parent_idx: u16,\n \n     /// The number of keys and values this node stores.\n     ///\n@@ -83,8 +83,8 @@ struct LeafNode<K, V> {\n \n     /// The arrays storing the actual data of the node. Only the first `len` elements of each\n     /// array are initialized and valid.\n-    keys: MaybeUninit<[K; CAPACITY]>,\n-    vals: MaybeUninit<[V; CAPACITY]>,\n+    keys: [K; CAPACITY],\n+    vals: [V; CAPACITY],\n }\n \n impl<K, V> LeafNode<K, V> {\n@@ -94,10 +94,10 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: MaybeUninit::uninitialized(),\n-            vals: MaybeUninit::uninitialized(),\n+            keys: mem::uninitialized(),\n+            vals: mem::uninitialized(),\n             parent: ptr::null(),\n-            parent_idx: MaybeUninit::uninitialized(),\n+            parent_idx: mem::uninitialized(),\n             len: 0\n         }\n     }\n@@ -115,10 +115,10 @@ unsafe impl Sync for LeafNode<(), ()> {}\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n     parent: ptr::null(),\n-    parent_idx: MaybeUninit::uninitialized(),\n+    parent_idx: 0,\n     len: 0,\n-    keys: MaybeUninit::uninitialized(),\n-    vals: MaybeUninit::uninitialized(),\n+    keys: [(); CAPACITY],\n+    vals: [(); CAPACITY],\n };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n@@ -430,7 +430,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_leaf().parent_idx.get_ref()) },\n+                idx: self.as_leaf().parent_idx as usize,\n                 _marker: PhantomData\n             })\n         } else {\n@@ -567,7 +567,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n             // the node, which is allowed by LLVM.\n             unsafe {\n                 slice::from_raw_parts(\n-                    self.as_leaf().keys.as_ptr() as *const K,\n+                    self.as_leaf().keys.as_ptr(),\n                     self.len()\n                 )\n             }\n@@ -578,7 +578,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts(\n-                self.as_leaf().vals.as_ptr() as *const V,\n+                self.as_leaf().vals.as_ptr(),\n                 self.len()\n             )\n         }\n@@ -605,7 +605,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         } else {\n             unsafe {\n                 slice::from_raw_parts_mut(\n-                    self.as_leaf_mut().keys.get_mut() as *mut [K] as *mut K,\n+                    &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n                     self.len()\n                 )\n             }\n@@ -616,7 +616,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n-                self.as_leaf_mut().vals.get_mut() as *mut [V] as *mut V,\n+                &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n                 self.len()\n             )\n         }\n@@ -1013,7 +1013,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let ptr = self.node.as_internal_mut() as *mut _;\n         let mut child = self.descend();\n         child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.set(idx);\n+        child.as_leaf_mut().parent_idx = idx;\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n@@ -1152,12 +1152,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n \n             ptr::copy_nonoverlapping(\n                 self.node.keys().as_ptr().add(self.idx + 1),\n-                new_node.keys.as_mut_ptr() as *mut K,\n+                new_node.keys.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.vals().as_ptr().add(self.idx + 1),\n-                new_node.vals.as_mut_ptr() as *mut V,\n+                new_node.vals.as_mut_ptr(),\n                 new_len\n             );\n \n@@ -1210,12 +1210,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             ptr::copy_nonoverlapping(\n                 self.node.keys().as_ptr().add(self.idx + 1),\n-                new_node.data.keys.as_mut_ptr() as *mut K,\n+                new_node.data.keys.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.vals().as_ptr().add(self.idx + 1),\n-                new_node.data.vals.as_mut_ptr() as *mut V,\n+                new_node.data.vals.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping("}, {"sha": "f92075cc84e509a739ad3ef8984c77d2f1f27437", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -120,7 +120,6 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit)]\n \n // Allow testing this library\n "}, {"sha": "03e7a9a49d8a763da0c6772b678ab23cba06ceb6", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n-use mem::MaybeUninit;\n+use mem;\n use num::flt2dec;\n \n // Don't inline this so callers don't use the stack space this function\n@@ -20,11 +20,11 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n     where T: flt2dec::DecodableFloat\n {\n     unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        let mut buf: [u8; 1024] = mem::uninitialized(); // enough for f32 and f64\n+        let mut parts: [flt2dec::Part; 4] = mem::uninitialized();\n         let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n                                                     *num, sign, precision,\n-                                                    false, buf.get_mut(), parts.get_mut());\n+                                                    false, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n@@ -38,11 +38,10 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter, num: &T,\n {\n     unsafe {\n         // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        let mut buf: [u8; flt2dec::MAX_SIG_DIGITS] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 4] = mem::uninitialized();\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n-                                                 sign, precision, false, buf.get_mut(),\n-                                                 parts.get_mut());\n+                                                 sign, precision, false, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n@@ -76,11 +75,11 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n     where T: flt2dec::DecodableFloat\n {\n     unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        let mut buf: [u8; 1024] = mem::uninitialized(); // enough for f32 and f64\n+        let mut parts: [flt2dec::Part; 6] = mem::uninitialized();\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n-                                                  upper, buf.get_mut(), parts.get_mut());\n+                                                  upper, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n@@ -95,11 +94,11 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n {\n     unsafe {\n         // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        let mut buf: [u8; flt2dec::MAX_SIG_DIGITS] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 6] = mem::uninitialized();\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,\n-                                                     buf.get_mut(), parts.get_mut());\n+                                                     &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }"}, {"sha": "675e73e952cc2ca011c055a949d38c75e99b18e2", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -246,8 +246,6 @@ macro_rules! test_v512 { ($item:item) => {}; }\n #[allow(unused_macros)]\n macro_rules! vector_impl { ($([$f:ident, $($args:tt)*]),*) => { $($f!($($args)*);)* } }\n #[path = \"../stdsimd/coresimd/mod.rs\"]\n-// replacing uses of mem::{uninitialized,zeroed} with MaybeUninit needs to be in the stdsimd repo\n-#[allow(deprecated)]\n #[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n #[cfg(not(stage0))] // allow changes to how stdsimd works in stage0"}, {"sha": "0224560af4c764657e5e667e40434f731b8aba7d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -293,21 +293,21 @@ where\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P: fmt::Debug> fmt::Debug for Pin<P> {\n+impl<P: fmt::Debug> fmt::Debug for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P: fmt::Display> fmt::Display for Pin<P> {\n+impl<P: fmt::Display> fmt::Display for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n+impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.pointer, f)\n     }\n@@ -319,10 +319,10 @@ impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n // for other reasons, though, so we just need to take care not to allow such\n // impls to land in std.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P, U> CoerceUnsized<Pin<U>> for Pin<P>\n+impl<P, U> CoerceUnsized<Pin<U>> for Pin<P>\n where\n     P: CoerceUnsized<U>,\n {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P> Unpin for Pin<P> {}\n+impl<P> Unpin for Pin<P> {}"}, {"sha": "14f2148a64e0ef299e1cebf7e295b3a6e1d0bc2d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -79,7 +79,7 @@ use ops::CoerceUnsized;\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n-use mem::{self, MaybeUninit};\n+use mem;\n use nonzero::NonZero;\n \n use cmp::Ordering::{self, Less, Equal, Greater};\n@@ -294,12 +294,16 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp: T = mem::uninitialized();\n \n     // Perform the swap\n-    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n+    copy_nonoverlapping(x, &mut tmp, 1);\n     copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.get_ref(), y, 1);\n+    copy_nonoverlapping(&tmp, y, 1);\n+\n+    // y and t now point to the same thing, but we need to completely forget `tmp`\n+    // because it's no longer relevant.\n+    mem::forget(tmp);\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -386,8 +390,8 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     while i + block_size <= len {\n         // Create some uninitialized memory as scratch space\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n-        let mut t = mem::MaybeUninit::<Block>::uninitialized();\n-        let t = t.as_mut_ptr() as *mut u8;\n+        let mut t: Block = mem::uninitialized();\n+        let t = &mut t as *mut _ as *mut u8;\n         let x = x.add(i);\n         let y = y.add(i);\n \n@@ -401,10 +405,10 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n \n     if i < len {\n         // Swap any remaining bytes\n-        let mut t = mem::MaybeUninit::<UnalignedBlock>::uninitialized();\n+        let mut t: UnalignedBlock = mem::uninitialized();\n         let rem = len - i;\n \n-        let t = t.as_mut_ptr() as *mut u8;\n+        let t = &mut t as *mut _ as *mut u8;\n         let x = x.add(i);\n         let y = y.add(i);\n \n@@ -569,9 +573,9 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n-    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.into_inner()\n+    let mut tmp: T = mem::uninitialized();\n+    copy_nonoverlapping(src, &mut tmp, 1);\n+    tmp\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -636,11 +640,11 @@ pub unsafe fn read<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping(src as *const u8,\n-                        tmp.as_mut_ptr() as *mut u8,\n+                        &mut tmp as *mut T as *mut u8,\n                         mem::size_of::<T>());\n-    tmp.into_inner()\n+    tmp\n }\n \n /// Overwrites a memory location with the given value without reading or"}, {"sha": "0d182b8497452e2bf7db6d6417b4b6e2092d3b34", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use cmp;\n-use mem::{self, MaybeUninit};\n+use mem;\n use ptr;\n \n /// Rotation is much faster if it has access to a little bit of memory. This\n@@ -26,6 +26,12 @@ union RawArray<T> {\n }\n \n impl<T> RawArray<T> {\n+    fn new() -> Self {\n+        unsafe { mem::uninitialized() }\n+    }\n+    fn ptr(&self) -> *mut T {\n+        unsafe { &self.typed as *const T as *mut T }\n+    }\n     fn cap() -> usize {\n         if mem::size_of::<T>() == 0 {\n             usize::max_value()\n@@ -82,8 +88,8 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n         }\n     }\n \n-    let mut rawarray = MaybeUninit::<RawArray<T>>::uninitialized();\n-    let buf = &mut (*rawarray.as_mut_ptr()).typed as *mut [T; 2] as *mut T;\n+    let rawarray = RawArray::new();\n+    let buf = rawarray.ptr();\n \n     let dim = mid.sub(left).add(right);\n     if left <= right {"}, {"sha": "e4c1fd03f9eb384b1197e5a6d3b82ed14f85d349", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -17,7 +17,7 @@\n //! stable sorting implementation.\n \n use cmp;\n-use mem::{self, MaybeUninit};\n+use mem;\n use ptr;\n \n /// When dropped, copies from `src` into `dest`.\n@@ -226,14 +226,14 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n     let mut block_l = BLOCK;\n     let mut start_l = ptr::null_mut();\n     let mut end_l = ptr::null_mut();\n-    let mut offsets_l = MaybeUninit::<[u8; BLOCK]>::uninitialized();\n+    let mut offsets_l: [u8; BLOCK] = unsafe { mem::uninitialized() };\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n     let mut end_r = ptr::null_mut();\n-    let mut offsets_r = MaybeUninit::<[u8; BLOCK]>::uninitialized();\n+    let mut offsets_r: [u8; BLOCK] = unsafe { mem::uninitialized() };\n \n     // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n     // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.\n@@ -272,8 +272,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n         if start_l == end_l {\n             // Trace `block_l` elements from the left side.\n-            start_l = offsets_l.as_mut_ptr() as *mut u8;\n-            end_l = offsets_l.as_mut_ptr() as *mut u8;\n+            start_l = offsets_l.as_mut_ptr();\n+            end_l = offsets_l.as_mut_ptr();\n             let mut elem = l;\n \n             for i in 0..block_l {\n@@ -288,8 +288,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n         if start_r == end_r {\n             // Trace `block_r` elements from the right side.\n-            start_r = offsets_r.as_mut_ptr() as *mut u8;\n-            end_r = offsets_r.as_mut_ptr() as *mut u8;\n+            start_r = offsets_r.as_mut_ptr();\n+            end_r = offsets_r.as_mut_ptr();\n             let mut elem = r;\n \n             for i in 0..block_r {"}, {"sha": "fa4bf1511b87434bc6c1d2094293f2b96fed6afe", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -287,6 +287,31 @@ impl DefPath {\n         s\n     }\n \n+    /// Return filename friendly string of the DefPah with the\n+    /// crate-prefix.\n+    pub fn to_string_friendly<F>(&self, crate_imported_name: F) -> String\n+        where F: FnOnce(CrateNum) -> Symbol\n+    {\n+        let crate_name_str = crate_imported_name(self.krate).as_str();\n+        let mut s = String::with_capacity(crate_name_str.len() + self.data.len() * 16);\n+\n+        write!(s, \"::{}\", crate_name_str).unwrap();\n+\n+        for component in &self.data {\n+            if component.disambiguator == 0 {\n+                write!(s, \"::{}\", component.data.as_interned_str()).unwrap();\n+            } else {\n+                write!(s,\n+                       \"{}[{}]\",\n+                       component.data.as_interned_str(),\n+                       component.disambiguator)\n+                    .unwrap();\n+            }\n+        }\n+\n+        s\n+    }\n+\n     /// Return filename friendly string of the DefPah without\n     /// the crate-prefix. This method is useful if you don't have\n     /// a TyCtxt available."}, {"sha": "e3bbdab4fd9659db1a3b0f64fc82f2e397045684", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -55,23 +55,22 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use infer;\n-use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n-use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n+use super::region_constraints::GenericKind;\n+use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n+use infer::{self, SuppressRegionErrors};\n \n-use std::{cmp, fmt};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use hir;\n-use hir::Node;\n use hir::def_id::DefId;\n+use hir::Node;\n use middle::region;\n-use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, subst::Subst, Region, Ty, TyCtxt, TypeFoldable, TyKind};\n-use ty::error::TypeError;\n-use session::config::BorrowckMode;\n+use std::{cmp, fmt};\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n+use traits::{ObligationCause, ObligationCauseCode};\n+use ty::error::TypeError;\n+use ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n \n mod note;\n \n@@ -153,8 +152,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n-            ty::ReCanonical(..) |\n-            ty::ReClosureBound(..) => {\n+            ty::ReCanonical(..) | ty::ReClosureBound(..) => {\n                 bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n             }\n         };\n@@ -176,9 +174,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n         match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_)  => {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n                 self.msg_span_from_early_bound_and_free_regions(region)\n-            },\n+            }\n             ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n             _ => bug!(\"{:?}\", region),\n         }\n@@ -197,25 +195,28 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n             Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n-            _ => unreachable!()\n+            _ => unreachable!(),\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n                 let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir.get_generics(scope).and_then(|generics| {\n-                    generics.get_named(&br.name)\n-                }) {\n+                if let Some(param) = self.hir\n+                    .get_generics(scope)\n+                    .and_then(|generics| generics.get_named(&br.name))\n+                {\n                     sp = param.span;\n                 }\n                 (format!(\"the lifetime {} as defined on\", br.name), sp)\n             }\n             ty::ReFree(ty::FreeRegion {\n-                bound_region: ty::BoundRegion::BrNamed(_, ref name), ..\n+                bound_region: ty::BoundRegion::BrNamed(_, ref name),\n+                ..\n             }) => {\n                 let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir.get_generics(scope).and_then(|generics| {\n-                    generics.get_named(&name)\n-                }) {\n+                if let Some(param) = self.hir\n+                    .get_generics(scope)\n+                    .and_then(|generics| generics.get_named(&name))\n+                {\n                     sp = param.span;\n                 }\n                 (format!(\"the lifetime {} as defined on\", name), sp)\n@@ -278,9 +279,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n         match item.node {\n             hir::ImplItemKind::Method(..) => \"method body\",\n-            hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Existential(..) |\n-            hir::ImplItemKind::Type(..) => \"associated item\",\n+            hir::ImplItemKind::Const(..)\n+            | hir::ImplItemKind::Existential(..)\n+            | hir::ImplItemKind::Type(..) => \"associated item\",\n         }\n     }\n \n@@ -298,20 +299,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         region_scope_tree: &region::ScopeTree,\n         errors: &Vec<RegionResolutionError<'tcx>>,\n-        will_later_be_reported_by_nll: bool,\n+        suppress: SuppressRegionErrors,\n     ) {\n-        debug!(\"report_region_errors(): {} errors to start\", errors.len());\n-\n-        // If the errors will later be reported by NLL, choose wether to display them or not based\n-        // on the borrowck mode\n-        if will_later_be_reported_by_nll {\n-            match self.tcx.borrowck_mode() {\n-                // If we're on AST or Migrate mode, report AST region errors\n-                BorrowckMode::Ast | BorrowckMode::Migrate => {},\n-                // If we're on MIR or Compare mode, don't report AST region errors as they should\n-                // be reported by NLL\n-                BorrowckMode::Compare | BorrowckMode::Mir => return,\n-            }\n+        debug!(\n+            \"report_region_errors(): {} errors to start, suppress = {:?}\",\n+            errors.len(),\n+            suppress\n+        );\n+\n+        if suppress.suppressed() {\n+            return;\n         }\n \n         // try to pre-process the errors, which will group some of them\n@@ -482,17 +479,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         err.span_label(arm_span, msg);\n                     }\n-                },\n-                hir::MatchSource::TryDesugar => { // Issue #51632\n+                }\n+                hir::MatchSource::TryDesugar => {\n+                    // Issue #51632\n                     if let Ok(try_snippet) = self.tcx.sess.source_map().span_to_snippet(arm_span) {\n                         err.span_suggestion_with_applicability(\n                             arm_span,\n                             \"try wrapping with a success variant\",\n                             format!(\"Ok({})\", try_snippet),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n-                },\n+                }\n                 _ => {\n                     let msg = \"match arm with an incompatible type\";\n                     if self.tcx.sess.source_map().is_multiline(arm_span) {\n@@ -641,16 +639,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn strip_generic_default_params(\n         &self,\n         def_id: DefId,\n-        substs: &ty::subst::Substs<'tcx>\n+        substs: &ty::subst::Substs<'tcx>,\n     ) -> &'tcx ty::subst::Substs<'tcx> {\n         let generics = self.tcx.generics_of(def_id);\n         let mut num_supplied_defaults = 0;\n-        let mut type_params = generics.params.iter().rev().filter_map(|param| match param.kind {\n-            ty::GenericParamDefKind::Lifetime => None,\n-            ty::GenericParamDefKind::Type { has_default, .. } => {\n-                Some((param.def_id, has_default))\n-            }\n-        }).peekable();\n+        let mut type_params = generics\n+            .params\n+            .iter()\n+            .rev()\n+            .filter_map(|param| match param.kind {\n+                ty::GenericParamDefKind::Lifetime => None,\n+                ty::GenericParamDefKind::Type { has_default, .. } => {\n+                    Some((param.def_id, has_default))\n+                }\n+            })\n+            .peekable();\n         let has_default = {\n             let has_default = type_params.peek().map(|(_, has_default)| has_default);\n             *has_default.unwrap_or(&false)\n@@ -684,10 +687,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Infer(ty::InferTy::IntVar(_)))\n                 | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n                 | (&ty::Infer(ty::InferTy::FloatVar(_)), &ty::Float(_))\n-                | (\n-                    &ty::Infer(ty::InferTy::FloatVar(_)),\n-                    &ty::Infer(ty::InferTy::FloatVar(_)),\n-                ) => true,\n+                | (&ty::Infer(ty::InferTy::FloatVar(_)), &ty::Infer(ty::InferTy::FloatVar(_))) => {\n+                    true\n+                }\n                 _ => false,\n             }\n         }\n@@ -703,11 +705,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 \"&{}{}{}\",\n                 r,\n                 if r == \"\" { \"\" } else { \" \" },\n-                if mutbl == hir::MutMutable {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                }\n+                if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n             ));\n             s.push_normal(ty.to_string());\n         }\n@@ -738,9 +736,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let common_len = cmp::min(len1, len2);\n                     let remainder1: Vec<_> = sub1.types().skip(common_len).collect();\n                     let remainder2: Vec<_> = sub2.types().skip(common_len).collect();\n-                    let common_default_params =\n-                        remainder1.iter().rev().zip(remainder2.iter().rev())\n-                                               .filter(|(a, b)| a == b).count();\n+                    let common_default_params = remainder1\n+                        .iter()\n+                        .rev()\n+                        .zip(remainder2.iter().rev())\n+                        .filter(|(a, b)| a == b)\n+                        .count();\n                     let len = sub1.len() - common_default_params;\n \n                     // Only draw `<...>` if there're lifetime/type arguments.\n@@ -866,8 +867,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n-            (&ty::Ref(r1, ref_ty1, mutbl1),\n-             &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1), &ty::Ref(r2, ref_ty2, mutbl2))\n+                if equals(&ref_ty1, &ref_ty2) =>\n+            {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n@@ -1068,11 +1070,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n-        self.construct_generic_bound_failure(region_scope_tree,\n-                                             span,\n-                                             origin,\n-                                             bound_kind,\n-                                             sub)\n+        self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n             .emit()\n     }\n \n@@ -1083,8 +1081,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'a>\n-    {\n+    ) -> DiagnosticBuilder<'a> {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n@@ -1161,8 +1158,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let tail = if has_lifetimes { \" + \" } else { \"\" };\n                 let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n                 err.span_suggestion_short_with_applicability(\n-                    sp, consider, suggestion,\n-                    Applicability::MaybeIncorrect // Issue #41966\n+                    sp,\n+                    consider,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n                 err.help(consider);\n@@ -1358,12 +1357,10 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar { .. } => {\n-                    \"`if let` arms have incompatible types\"\n-                },\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n                 hir::MatchSource::TryDesugar => {\n                     \"try expression alternatives have incompatible types\"\n-                },\n+                }\n                 _ => \"match arms have incompatible types\",\n             }),\n             IfExpression => Error0308(\"if and else have incompatible types\"),"}, {"sha": "a8fbfc3b64dfd1e1d63ec40bc02b415bc3bdf882", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 64, "deletions": 63, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -10,23 +10,26 @@\n \n //! The code to do lexical region resolution.\n \n-use infer::SubregionOrigin;\n-use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n use infer::region_constraints::VarInfos;\n use infer::region_constraints::VerifyBound;\n+use infer::RegionVariableOrigin;\n+use infer::SubregionOrigin;\n use middle::free_region::RegionRelations;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::implementation::{Graph, Direction, NodeIndex, INCOMING, OUTGOING};\n+use rustc_data_structures::graph::implementation::{\n+    Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n+};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::u32;\n-use ty::{self, TyCtxt};\n-use ty::{Region, RegionVid};\n+use ty::fold::TypeFoldable;\n+use ty::{self, Ty, TyCtxt};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n+use ty::{Region, RegionVid};\n \n mod graphviz;\n \n@@ -108,11 +111,15 @@ struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.region_rels.tcx\n+    }\n+\n     fn infer_variable_values(\n         &mut self,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n-        let mut var_data = self.construct_var_data(self.region_rels.tcx);\n+        let mut var_data = self.construct_var_data(self.tcx());\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n@@ -239,9 +246,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n                 debug!(\n                     \"Expanding value of {:?} from {:?} to {:?}\",\n-                    b_vid,\n-                    cur_region,\n-                    lub\n+                    b_vid, cur_region, lub\n                 );\n \n                 *b_data = VarValue::Value(lub);\n@@ -254,18 +259,17 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let tcx = self.region_rels.tcx;\n+        let tcx = self.tcx();\n         match (a, b) {\n-            (&ty::ReCanonical(..), _) |\n-            (_, &ty::ReCanonical(..)) |\n-            (&ty::ReClosureBound(..), _) |\n-            (_, &ty::ReClosureBound(..)) |\n-            (&ReLateBound(..), _) |\n-            (_, &ReLateBound(..)) |\n-            (&ReErased, _) |\n-            (_, &ReErased) => {\n+            (&ty::ReCanonical(..), _)\n+            | (_, &ty::ReCanonical(..))\n+            | (&ty::ReClosureBound(..), _)\n+            | (_, &ty::ReClosureBound(..))\n+            | (&ReLateBound(..), _)\n+            | (_, &ReLateBound(..))\n+            | (&ReErased, _)\n+            | (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n@@ -287,20 +291,20 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            (&ReEarlyBound(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(_)) => {\n+            (&ReEarlyBound(_), &ReScope(s_id))\n+            | (&ReScope(s_id), &ReEarlyBound(_))\n+            | (&ReFree(_), &ReScope(s_id))\n+            | (&ReScope(s_id), &ReFree(_)) => {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n                     (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n                         .region_scope_tree\n-                        .early_free_scope(self.region_rels.tcx, br),\n+                        .early_free_scope(self.tcx(), br),\n                     (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n                         .region_scope_tree\n-                        .free_scope(self.region_rels.tcx, fr),\n+                        .free_scope(self.tcx(), fr),\n                     _ => bug!(),\n                 };\n                 let r_id = self.region_rels\n@@ -332,10 +336,10 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 tcx.mk_region(ReScope(lub))\n             }\n \n-            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReEarlyBound(_)) |\n-            (&ReEarlyBound(_), &ReFree(_)) |\n-            (&ReFree(_), &ReFree(_)) => self.region_rels.lub_free_regions(a, b),\n+            (&ReEarlyBound(_), &ReEarlyBound(_))\n+            | (&ReFree(_), &ReEarlyBound(_))\n+            | (&ReEarlyBound(_), &ReFree(_))\n+            | (&ReFree(_), &ReFree(_)) => self.region_rels.lub_free_regions(a, b),\n \n             // For these types, we cannot define any additional\n             // relationship:\n@@ -358,8 +362,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         for (constraint, origin) in &self.data.constraints {\n             debug!(\n                 \"collect_errors: constraint={:?} origin={:?}\",\n-                constraint,\n-                origin\n+                constraint, origin\n             );\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n@@ -374,9 +377,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                     debug!(\n                         \"collect_errors: region error at {:?}: \\\n                          cannot verify that {:?} <= {:?}\",\n-                        origin,\n-                        sub,\n-                        sup\n+                        origin, sub, sup\n                     );\n \n                     errors.push(RegionResolutionError::ConcreteFailure(\n@@ -402,10 +403,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n-                            origin,\n-                            a_vid,\n-                            a_region,\n-                            b_region\n+                            origin, a_vid, a_region, b_region\n                         );\n                         *a_data = VarValue::ErrorValue;\n                     }\n@@ -415,24 +413,23 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n         for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = var_data.normalize(verify.region);\n+            let sub = var_data.normalize(self.tcx(), verify.region);\n \n             // This was an inference variable which didn't get\n             // constrained, therefore it can be assume to hold.\n             if let ty::ReEmpty = *sub {\n                 continue;\n             }\n \n-            if self.bound_is_met(&verify.bound, var_data, sub) {\n+            let verify_kind_ty = verify.kind.to_ty(self.tcx());\n+            if self.bound_is_met(&verify.bound, var_data, verify_kind_ty, sub) {\n                 continue;\n             }\n \n             debug!(\n                 \"collect_errors: region error at {:?}: \\\n                  cannot verify that {:?} <= {:?}\",\n-                verify.origin,\n-                verify.region,\n-                verify.bound\n+                verify.origin, verify.region, verify.bound\n             );\n \n             errors.push(RegionResolutionError::GenericBoundFailure(\n@@ -580,10 +577,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n-                        origin,\n-                        node_idx,\n-                        lower_bound.region,\n-                        upper_bound.region\n+                        origin, node_idx, lower_bound.region, upper_bound.region\n                     );\n                     errors.push(RegionResolutionError::SubSupConflict(\n                         origin,\n@@ -645,8 +639,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             debug!(\n                 \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                orig_node_idx,\n-                node_idx\n+                orig_node_idx, node_idx\n             );\n \n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n@@ -721,20 +714,26 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         &self,\n         bound: &VerifyBound<'tcx>,\n         var_values: &LexicalRegionResolutions<'tcx>,\n+        generic_ty: Ty<'tcx>,\n         min: ty::Region<'tcx>,\n     ) -> bool {\n         match bound {\n-            VerifyBound::AnyRegion(rs) => rs.iter()\n-                .map(|&r| var_values.normalize(r))\n-                .any(|r| self.region_rels.is_subregion_of(min, r)),\n+            VerifyBound::IfEq(k, b) => {\n+                (var_values.normalize(self.region_rels.tcx, *k) == generic_ty)\n+                    && self.bound_is_met(b, var_values, generic_ty, min)\n+            }\n \n-            VerifyBound::AllRegions(rs) => rs.iter()\n-                .map(|&r| var_values.normalize(r))\n-                .all(|r| self.region_rels.is_subregion_of(min, r)),\n+            VerifyBound::OutlivedBy(r) =>\n+                self.region_rels.is_subregion_of(\n+                    min,\n+                    var_values.normalize(self.tcx(), r),\n+                ),\n \n-            VerifyBound::AnyBound(bs) => bs.iter().any(|b| self.bound_is_met(b, var_values, min)),\n+            VerifyBound::AnyBound(bs) => bs.iter()\n+                .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n \n-            VerifyBound::AllBounds(bs) => bs.iter().all(|b| self.bound_is_met(b, var_values, min)),\n+            VerifyBound::AllBounds(bs) => bs.iter()\n+                .all(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n         }\n     }\n }\n@@ -745,13 +744,15 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n     }\n }\n \n-\n impl<'tcx> LexicalRegionResolutions<'tcx> {\n-    fn normalize(&self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            ty::ReVar(rid) => self.resolve_var(rid),\n+    fn normalize<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(&value, &mut false, |r, _db| match r {\n+            ty::ReVar(rid) => self.resolve_var(*rid),\n             _ => r,\n-        }\n+        })\n     }\n \n     fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {"}, {"sha": "dc10ec03feef04c1ae2056b3ad28dc2fe637487e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -24,6 +24,7 @@ use middle::free_region::RegionRelations;\n use middle::lang_items;\n use middle::region;\n use rustc_data_structures::unify as ut;\n+use session::config::BorrowckMode;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n@@ -80,6 +81,38 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n+/// A flag that is used to suppress region errors. This is normally\n+/// false, but sometimes -- when we are doing region checks that the\n+/// NLL borrow checker will also do -- it might be set to true.\n+#[derive(Copy, Clone, Default, Debug)]\n+pub struct SuppressRegionErrors {\n+    suppressed: bool\n+}\n+\n+impl SuppressRegionErrors {\n+    pub fn suppressed(self) -> bool {\n+        self.suppressed\n+    }\n+\n+    /// Indicates that the MIR borrowck will repeat these region\n+    /// checks, so we should ignore errors if NLL is (unconditionally)\n+    /// enabled.\n+    pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_, '_>) -> Self {\n+        match tcx.borrowck_mode() {\n+            // If we're on AST or Migrate mode, report AST region errors\n+            BorrowckMode::Ast | BorrowckMode::Migrate => SuppressRegionErrors {\n+                suppressed: false\n+            },\n+\n+            // If we're on MIR or Compare mode, don't report AST region errors as they should\n+            // be reported by NLL\n+            BorrowckMode::Compare | BorrowckMode::Mir => SuppressRegionErrors {\n+                suppressed: true\n+            },\n+        }\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n@@ -408,7 +441,7 @@ pub enum FixupError {\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region<'tcx>,\n     pub sup_type: Ty<'tcx>,\n-    pub cause: ObligationCause<'tcx>,\n+    pub origin: SubregionOrigin<'tcx>,\n }\n \n impl fmt::Display for FixupError {\n@@ -1039,34 +1072,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_context: DefId,\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        self.resolve_regions_and_report_errors_inner(\n-            region_context,\n-            region_map,\n-            outlives_env,\n-            false,\n-        )\n-    }\n-\n-    /// Like `resolve_regions_and_report_errors`, but skips error\n-    /// reporting if NLL is enabled.  This is used for fn bodies where\n-    /// the same error may later be reported by the NLL-based\n-    /// inference.\n-    pub fn resolve_regions_and_report_errors_unless_nll(\n-        &self,\n-        region_context: DefId,\n-        region_map: &region::ScopeTree,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        self.resolve_regions_and_report_errors_inner(region_context, region_map, outlives_env, true)\n-    }\n-\n-    fn resolve_regions_and_report_errors_inner(\n-        &self,\n-        region_context: DefId,\n-        region_map: &region::ScopeTree,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-        will_later_be_reported_by_nll: bool,\n+        suppress: SuppressRegionErrors,\n     ) {\n         assert!(\n             self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n@@ -1098,7 +1104,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors, will_later_be_reported_by_nll);\n+            self.report_region_errors(region_map, &errors, suppress);\n         }\n     }\n "}, {"sha": "631ff58d3e37e3e87e0574c3d925ad0b5966612b", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{GenericKind, InferCtxt};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use traits::query::outlives_bounds::{self, OutlivesBound};\n-use ty::{self, Ty};\n-\n+use infer::{GenericKind, InferCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use syntax_pos::Span;\n+use traits::query::outlives_bounds::{self, OutlivesBound};\n+use ty::{self, Ty};\n \n /// The `OutlivesEnvironment` collects information about what outlives\n /// what in a given type-checking setting. For example, if we have a\n@@ -39,15 +39,51 @@ use syntax_pos::Span;\n pub struct OutlivesEnvironment<'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     free_region_map: FreeRegionMap<'tcx>,\n-    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+\n+    // Contains, for each body B that we are checking (that is, the fn\n+    // item, but also any nested closures), the set of implied region\n+    // bounds that are in scope in that particular body.\n+    //\n+    // Example:\n+    //\n+    // ```\n+    // fn foo<'a, 'b, T>(x: &'a T, y: &'b ()) {\n+    //   bar(x, y, |y: &'b T| { .. } // body B1)\n+    // } // body B0\n+    // ```\n+    //\n+    // Here, for body B0, the list would be `[T: 'a]`, because we\n+    // infer that `T` must outlive `'a` from the implied bounds on the\n+    // fn declaration.\n+    //\n+    // For the body B1, the list would be `[T: 'a, T: 'b]`, because we\n+    // also can see that -- within the closure body! -- `T` must\n+    // outlive `'b`. This is not necessarily true outside the closure\n+    // body, since the closure may never be called.\n+    //\n+    // We collect this map as we descend the tree. We then use the\n+    // results when proving outlives obligations like `T: 'x` later\n+    // (e.g., if `T: 'x` must be proven within the body B1, then we\n+    // know it is true if either `'a: 'x` or `'b: 'x`).\n+    region_bound_pairs_map: FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+\n+    // Used to compute `region_bound_pairs_map`: contains the set of\n+    // in-scope region-bound pairs thus far.\n+    region_bound_pairs_accum: RegionBoundPairs<'tcx>,\n }\n \n+/// \"Region-bound pairs\" tracks outlives relations that are known to\n+/// be true, either because of explicit where clauses like `T: 'a` or\n+/// because of implied bounds.\n+pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n+\n impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut env = OutlivesEnvironment {\n             param_env,\n             free_region_map: FreeRegionMap::new(),\n-            region_bound_pairs: vec![],\n+            region_bound_pairs_map: FxHashMap::default(),\n+            region_bound_pairs_accum: vec![],\n         };\n \n         env.add_outlives_bounds(None, outlives_bounds::explicit_outlives_bounds(param_env));\n@@ -61,8 +97,8 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs(&self) -> &[(ty::Region<'tcx>, GenericKind<'tcx>)] {\n-        &self.region_bound_pairs\n+    pub fn region_bound_pairs_map(&self) -> &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>> {\n+        &self.region_bound_pairs_map\n     }\n \n     /// Returns ownership of the `free_region_map`.\n@@ -108,12 +144,12 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     /// similar leaks around givens that seem equally suspicious, to\n     /// be honest. --nmatsakis\n     pub fn push_snapshot_pre_closure(&self) -> usize {\n-        self.region_bound_pairs.len()\n+        self.region_bound_pairs_accum.len()\n     }\n \n     /// See `push_snapshot_pre_closure`.\n     pub fn pop_snapshot_post_closure(&mut self, len: usize) {\n-        self.region_bound_pairs.truncate(len);\n+        self.region_bound_pairs_accum.truncate(len);\n     }\n \n     /// This method adds \"implied bounds\" into the outlives environment.\n@@ -149,6 +185,15 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         }\n     }\n \n+    /// Save the current set of region-bound pairs under the given `body_id`.\n+    pub fn save_implied_bounds(&mut self, body_id: ast::NodeId) {\n+        let old = self.region_bound_pairs_map.insert(\n+            body_id,\n+            self.region_bound_pairs_accum.clone(),\n+        );\n+        assert!(old.is_none());\n+    }\n+\n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n     ///\n     /// The `infcx` parameter is optional; if the implied bounds may\n@@ -167,16 +212,18 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         for outlives_bound in outlives_bounds {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n-                OutlivesBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_), &ty::ReVar(vid_b)) |\n-                OutlivesBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n-                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, vid_b);\n+                OutlivesBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_), &ty::ReVar(vid_b))\n+                | OutlivesBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n+                    infcx\n+                        .expect(\"no infcx provided but region vars found\")\n+                        .add_given(r_a, vid_b);\n                 }\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs\n+                    self.region_bound_pairs_accum\n                         .push((r_a, GenericKind::Param(param_b)));\n                 }\n                 OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs\n+                    self.region_bound_pairs_accum\n                         .push((r_a, GenericKind::Projection(projection_b)));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {"}, {"sha": "282aef786f08ab2ad8b724b9f8130dd643edfff6", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -13,3 +13,4 @@\n pub mod env;\n pub mod free_region_map;\n pub mod obligations;\n+pub mod verify;"}, {"sha": "332859d4f81db28fd6b24471e4c40ba24126bba6", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 105, "deletions": 286, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -69,13 +69,14 @@\n //! might later infer `?U` to something like `&'b u32`, which would\n //! imply that `'b: 'a`.\n \n-use hir::def_id::DefId;\n+use infer::outlives::env::RegionBoundPairs;\n+use infer::outlives::verify::VerifyBoundCx;\n use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n-use traits;\n+use traits::ObligationCause;\n use ty::outlives::Component;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -98,6 +99,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             .push((body_id, obligation));\n     }\n \n+    pub fn register_region_obligation_with_cause(\n+        &self,\n+        sup_type: Ty<'tcx>,\n+        sub_region: Region<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+    ) {\n+        let origin = SubregionOrigin::from_obligation_cause(cause, || {\n+            infer::RelateParamBound(cause.span, sup_type)\n+        });\n+\n+        self.register_region_obligation(\n+            cause.body_id,\n+            RegionObligation {\n+                sup_type,\n+                sub_region,\n+                origin,\n+            },\n+        );\n+    }\n+\n     /// Trait queries just want to pass back type obligations \"as is\"\n     pub fn take_registered_region_obligations(&self) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n         ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n@@ -138,10 +159,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// processed.\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs_map: &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n     ) {\n         assert!(\n             !self.in_snapshot.get(),\n@@ -150,49 +170,47 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         debug!(\"process_registered_region_obligations()\");\n \n-        // pull out the region obligations with the given `body_id` (leaving the rest)\n-        let mut my_region_obligations = Vec::with_capacity(self.region_obligations.borrow().len());\n-        {\n-            let mut r_o = self.region_obligations.borrow_mut();\n-            my_region_obligations.extend(\n-                r_o.drain_filter(|(ro_body_id, _)| *ro_body_id == body_id)\n-                   .map(|(_, obligation)| obligation)\n-            );\n-        }\n-\n-        let outlives = &mut TypeOutlives::new(\n-            self,\n-            self.tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-        );\n+        let my_region_obligations = self.take_registered_region_obligations();\n \n-        for RegionObligation {\n-            sup_type,\n-            sub_region,\n-            cause,\n-        } in my_region_obligations\n+        for (\n+            body_id,\n+            RegionObligation {\n+                sup_type,\n+                sub_region,\n+                origin,\n+            },\n+        ) in my_region_obligations\n         {\n             debug!(\n-                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} cause={:?}\",\n-                sup_type, sub_region, cause\n+                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n+                sup_type, sub_region, origin\n             );\n \n-            let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-                infer::RelateParamBound(cause.span, sup_type)\n-            });\n-\n             let sup_type = self.resolve_type_vars_if_possible(&sup_type);\n-            outlives.type_must_outlive(origin, sup_type, sub_region);\n+\n+            if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n+                let outlives = &mut TypeOutlives::new(\n+                    self,\n+                    self.tcx,\n+                    &region_bound_pairs,\n+                    implicit_region_bound,\n+                    param_env,\n+                );\n+                outlives.type_must_outlive(origin, sup_type, sub_region);\n+            } else {\n+                self.tcx.sess.delay_span_bug(\n+                    origin.span(),\n+                    &format!(\"no region-bound-pairs for {:?}\", body_id),\n+                )\n+            }\n         }\n     }\n \n     /// Processes a single ad-hoc region obligation that was not\n     /// registered in advance.\n     pub fn type_must_outlive(\n         &self,\n-        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         origin: infer::SubregionOrigin<'tcx>,\n@@ -225,9 +243,7 @@ where\n     // of these fields.\n     delegate: D,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    verify_bound: VerifyBoundCx<'cx, 'gcx, 'tcx>,\n }\n \n pub trait TypeOutlivesDelegate<'tcx> {\n@@ -254,16 +270,19 @@ where\n     pub fn new(\n         delegate: D,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         Self {\n             delegate,\n             tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n+            verify_bound: VerifyBoundCx::new(\n+                tcx,\n+                region_bound_pairs,\n+                implicit_region_bound,\n+                param_env,\n+            ),\n         }\n     }\n \n@@ -302,7 +321,8 @@ where\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, region1);\n+                    self.delegate\n+                        .push_sub_region_constraint(origin, region, region1);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, param_ty);\n@@ -337,8 +357,8 @@ where\n             region, param_ty, origin\n         );\n \n-        let verify_bound = self.param_bound(param_ty);\n         let generic = GenericKind::Param(param_ty);\n+        let verify_bound = self.verify_bound.generic_bound(generic);\n         self.delegate\n             .push_verify(origin, generic, region, verify_bound);\n     }\n@@ -368,19 +388,22 @@ where\n         // rule might not apply (but another rule might). For now, we err\n         // on the side of adding too few edges into the graph.\n \n-        // Compute the bounds we can derive from the environment or trait\n-        // definition.  We know that the projection outlives all the\n-        // regions in this list.\n-        let env_bounds = self.projection_declared_bounds(projection_ty);\n-\n-        debug!(\"projection_must_outlive: env_bounds={:?}\", env_bounds);\n+        // Compute the bounds we can derive from the environment. This\n+        // is an \"approximate\" match -- in some cases, these bounds\n+        // may not apply.\n+        let approx_env_bounds = self.verify_bound\n+            .projection_approx_declared_bounds_from_env(projection_ty);\n+        debug!(\n+            \"projection_must_outlive: approx_env_bounds={:?}\",\n+            approx_env_bounds\n+        );\n \n-        // If we know that the projection outlives 'static, then we're\n-        // done here.\n-        if env_bounds.contains(&&ty::ReStatic) {\n-            debug!(\"projection_must_outlive: 'static as declared bound\");\n-            return;\n-        }\n+        // Compute the bounds we can derive from the trait definition.\n+        // These are guaranteed to apply, no matter the inference\n+        // results.\n+        let trait_bounds: Vec<_> = self.verify_bound\n+            .projection_declared_bounds_from_trait(projection_ty)\n+            .collect();\n \n         // If declared bounds list is empty, the only applicable rule is\n         // OutlivesProjectionComponent. If there are inference variables,\n@@ -397,261 +420,58 @@ where\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n         let needs_infer = projection_ty.needs_infer();\n-        if env_bounds.is_empty() && needs_infer {\n+        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n             for component_ty in projection_ty.substs.types() {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n             for r in projection_ty.substs.regions() {\n-                self.delegate.push_sub_region_constraint(origin.clone(), region, r);\n+                self.delegate\n+                    .push_sub_region_constraint(origin.clone(), region, r);\n             }\n \n             return;\n         }\n \n-        // If we find that there is a unique declared bound `'b`, and this bound\n-        // appears in the trait reference, then the best action is to require that `'b:'r`,\n-        // so do that. This is best no matter what rule we use:\n+        // If we found a unique bound `'b` from the trait, and we\n+        // found nothing else from the environment, then the best\n+        // action is to require that `'b: 'r`, so do that.\n+        //\n+        // This is best no matter what rule we use:\n         //\n-        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n-        // the requirement that `'b:'r`\n-        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n-        // other conditions\n-        if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n-            let unique_bound = env_bounds[0];\n+        // - OutlivesProjectionEnv: these would translate to the requirement that `'b:'r`\n+        // - OutlivesProjectionTraitDef: these would translate to the requirement that `'b:'r`\n+        // - OutlivesProjectionComponent: this would require `'b:'r`\n+        //   in addition to other conditions\n+        if !trait_bounds.is_empty()\n+            && trait_bounds[1..]\n+                .iter()\n+                .chain(approx_env_bounds.iter().map(|b| &b.1))\n+                .all(|b| *b == trait_bounds[0])\n+        {\n+            let unique_bound = trait_bounds[0];\n             debug!(\n-                \"projection_must_outlive: unique declared bound = {:?}\",\n+                \"projection_must_outlive: unique trait bound = {:?}\",\n                 unique_bound\n             );\n-            if projection_ty\n-                .substs\n-                .regions()\n-                .any(|r| env_bounds.contains(&r))\n-            {\n-                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.delegate\n-                    .push_sub_region_constraint(origin.clone(), region, unique_bound);\n-                return;\n-            }\n+            debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+            self.delegate\n+                .push_sub_region_constraint(origin.clone(), region, unique_bound);\n+            return;\n         }\n \n         // Fallback to verifying after the fact that there exists a\n         // declared bound, or that all the components appearing in the\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let verify_bound = self.projection_bound(env_bounds, projection_ty);\n         let generic = GenericKind::Projection(projection_ty);\n+        let verify_bound = self.verify_bound.generic_bound(generic);\n         self.delegate\n             .push_verify(origin, generic.clone(), region, verify_bound);\n     }\n-\n-    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.sty {\n-            ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => {\n-                let declared_bounds = self.projection_declared_bounds(data);\n-                self.projection_bound(declared_bounds, data)\n-            }\n-            _ => self.recursive_type_bound(ty),\n-        }\n-    }\n-\n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        debug!(\"param_bound(param_ty={:?})\", param_ty);\n-\n-        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n-\n-        // Add in the default bound of fn body that applies to all in\n-        // scope type parameters:\n-        param_bounds.extend(self.implicit_region_bound);\n-\n-        VerifyBound::AnyRegion(param_bounds)\n-    }\n-\n-    fn projection_declared_bounds(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        // First assemble bounds from where clauses and traits.\n-\n-        let mut declared_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n-\n-        declared_bounds\n-            .extend_from_slice(&self.declared_projection_bounds_from_trait(projection_ty));\n-\n-        declared_bounds\n-    }\n-\n-    fn projection_bound(\n-        &self,\n-        declared_bounds: Vec<ty::Region<'tcx>>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> VerifyBound<'tcx> {\n-        debug!(\n-            \"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n-            declared_bounds, projection_ty\n-        );\n-\n-        // see the extensive comment in projection_must_outlive\n-        let ty = self\n-            .tcx\n-            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(ty);\n-\n-        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n-    }\n-\n-    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = ty.walk_shallow().map(|subty| self.type_bound(subty)).collect::<Vec<_>>();\n-\n-        let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllRegions(regions));\n-\n-        // remove bounds that must hold, since they are not interesting\n-        bounds.retain(|b| !b.must_hold());\n-\n-        if bounds.len() == 1 {\n-            bounds.pop().unwrap()\n-        } else {\n-            VerifyBound::AllBounds(bounds)\n-        }\n-    }\n-\n-    fn declared_generic_bounds_from_env(\n-        &self,\n-        generic: GenericKind<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx;\n-\n-        // To start, collect bounds from user environment. Note that\n-        // parameter environments are already elaborated, so we don't\n-        // have to worry about that. Comparing using `==` is a bit\n-        // dubious for projections, but it will work for simple cases\n-        // like `T` and `T::Item`. It may not work as well for things\n-        // like `<T as Foo<'a>>::Item`.\n-        let generic_ty = generic.to_ty(tcx);\n-        let c_b = self.param_env.caller_bounds;\n-        let mut param_bounds = self.collect_outlives_from_predicate_list(generic_ty, c_b);\n-\n-        // Next, collect regions we scraped from the well-formedness\n-        // constraints in the fn signature. To do that, we walk the list\n-        // of known relations from the fn ctxt.\n-        //\n-        // This is crucial because otherwise code like this fails:\n-        //\n-        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n-        //\n-        // The problem is that the type of `x` is `&'a A`. To be\n-        // well-formed, then, A must be lower-generic by `'a`, but we\n-        // don't know that this holds from first principles.\n-        for &(r, p) in self.region_bound_pairs {\n-            debug!(\"generic={:?} p={:?}\", generic, p);\n-            if generic == p {\n-                param_bounds.push(r);\n-            }\n-        }\n-\n-        param_bounds\n-    }\n-\n-    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n-    /// declared in the trait definition. For example, if the trait were\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n-    /// then this function would return `'x`. This is subject to the\n-    /// limitations around higher-ranked bounds described in\n-    /// `region_bounds_declared_on_associated_item`.\n-    fn declared_projection_bounds_from_trait(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n-        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n-        for r in &mut bounds {\n-            *r = r.subst(self.tcx, projection_ty.substs);\n-        }\n-        bounds\n-    }\n-\n-    /// Given the def-id of an associated item, returns any region\n-    /// bounds attached to that associated item from the trait definition.\n-    ///\n-    /// For example:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n-    /// If we were given the def-id of `Foo::Bar`, we would return\n-    /// `'a`. You could then apply the substitutions from the\n-    /// projection to convert this into your namespace. This also\n-    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n-    /// the trait. In fact, it works by searching for just such a\n-    /// where-clause.\n-    ///\n-    /// It will not, however, work for higher-ranked bounds like:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a, 'b>\n-    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n-    /// {\n-    ///     type Bar;\n-    /// }\n-    /// ```\n-    ///\n-    /// This is for simplicity, and because we are not really smart\n-    /// enough to cope with such bounds anywhere.\n-    fn region_bounds_declared_on_associated_item(\n-        &self,\n-        assoc_item_def_id: DefId,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx;\n-        let assoc_item = tcx.associated_item(assoc_item_def_id);\n-        let trait_def_id = assoc_item.container.assert_trait();\n-        let trait_predicates = tcx.predicates_of(trait_def_id);\n-        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n-        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n-        self.collect_outlives_from_predicate_list(\n-            identity_proj,\n-            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n-        )\n-    }\n-\n-    /// Searches through a predicate list for a predicate `T: 'a`.\n-    ///\n-    /// Careful: does not elaborate predicates, and just uses `==`\n-    /// when comparing `ty` for equality, so `ty` must be something\n-    /// that does not involve inference variables and where you\n-    /// otherwise want a precise match.\n-    fn collect_outlives_from_predicate_list<I, P>(\n-        &self,\n-        ty: Ty<'tcx>,\n-        predicates: I,\n-    ) -> Vec<ty::Region<'tcx>>\n-    where\n-        I: IntoIterator<Item = P>,\n-        P: AsRef<ty::Predicate<'tcx>>,\n-    {\n-        predicates\n-            .into_iter()\n-            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| p.no_late_bound_regions())\n-            .filter(|p| p.0 == ty)\n-            .map(|p| p.1)\n-            .collect()\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n@@ -674,4 +494,3 @@ impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, '\n         self.verify_generic_bound(origin, kind, a, bound)\n     }\n }\n-"}, {"sha": "e1db295b7e14d6e10dcfa3fd006ccbb5ff3b1403", "filename": "src/librustc/infer/outlives/verify.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,329 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use infer::outlives::env::RegionBoundPairs;\n+use infer::{GenericKind, VerifyBound};\n+use traits;\n+use ty::subst::{Subst, Substs};\n+use ty::{self, Ty, TyCtxt};\n+use util::captures::Captures;\n+\n+/// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n+/// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n+/// described on the module comment. The final constraints are emitted\n+/// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n+/// accrues them into the `region_obligations` code, but for NLL we\n+/// use something else.\n+pub struct VerifyBoundCx<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        }\n+    }\n+\n+    /// Returns a \"verify bound\" that encodes what we know about\n+    /// `generic` and the regions it outlives.\n+    pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n+        match generic {\n+            GenericKind::Param(param_ty) => self.param_bound(param_ty),\n+            GenericKind::Projection(projection_ty) => self.projection_bound(projection_ty),\n+        }\n+    }\n+\n+    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        match ty.sty {\n+            ty::Param(p) => self.param_bound(p),\n+            ty::Projection(data) => self.projection_bound(data),\n+            _ => self.recursive_type_bound(ty),\n+        }\n+    }\n+\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+        debug!(\"param_bound(param_ty={:?})\", param_ty);\n+\n+        // Start with anything like `T: 'a` we can scrape from the\n+        // environment\n+        let param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty))\n+            .into_iter()\n+            .map(|outlives| outlives.1);\n+\n+        // Add in the default bound of fn body that applies to all in\n+        // scope type parameters:\n+        let param_bounds = param_bounds.chain(self.implicit_region_bound);\n+\n+        VerifyBound::AnyBound(param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect())\n+    }\n+\n+    /// Given a projection like `T::Item`, searches the environment\n+    /// for where-clauses like `T::Item: 'a`. Returns the set of\n+    /// regions `'a` that it finds.\n+    ///\n+    /// This is an \"approximate\" check -- it may not find all\n+    /// applicable bounds, and not all the bounds it returns can be\n+    /// relied upon. In particular, this check ignores region\n+    /// identity.  So, for example, if we have `<T as\n+    /// Trait<'0>>::Item` where `'0` is a region variable, and the\n+    /// user has `<T as Trait<'a>>::Item: 'b` in the environment, then\n+    /// the clause from the environment only applies if `'0 = 'a`,\n+    /// which we don't know yet. But we would still include `'b` in\n+    /// this list.\n+    pub fn projection_approx_declared_bounds_from_env(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n+        let erased_projection_ty = self.tcx.erase_regions(&projection_ty);\n+        self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n+            if let ty::Projection(..) = ty.sty {\n+                let erased_ty = self.tcx.erase_regions(&ty);\n+                erased_ty == erased_projection_ty\n+            } else {\n+                false\n+            }\n+        })\n+    }\n+\n+    /// Searches the where clauses in scope for regions that\n+    /// `projection_ty` is known to outlive. Currently requires an\n+    /// exact match.\n+    pub fn projection_declared_bounds_from_trait(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+        self.declared_projection_bounds_from_trait(projection_ty)\n+    }\n+\n+    pub fn projection_bound(&self, projection_ty: ty::ProjectionTy<'tcx>) -> VerifyBound<'tcx> {\n+        debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n+\n+        let projection_ty_as_ty =\n+            self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+\n+        // Search the env for where clauses like `P: 'a`.\n+        let env_bounds = self.projection_approx_declared_bounds_from_env(projection_ty)\n+            .into_iter()\n+            .map(|ty::OutlivesPredicate(ty, r)| {\n+                let vb = VerifyBound::OutlivedBy(r);\n+                if ty == projection_ty_as_ty {\n+                    // Micro-optimize if this is an exact match (this\n+                    // occurs often when there are no region variables\n+                    // involved).\n+                    vb\n+                } else {\n+                    VerifyBound::IfEq(ty, Box::new(vb))\n+                }\n+            });\n+\n+        // Extend with bounds that we can find from the trait.\n+        let trait_bounds = self.projection_declared_bounds_from_trait(projection_ty)\n+            .into_iter()\n+            .map(|r| VerifyBound::OutlivedBy(r));\n+\n+        // see the extensive comment in projection_must_outlive\n+        let ty = self.tcx\n+            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+        let recursive_bound = self.recursive_type_bound(ty);\n+\n+        VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n+    }\n+\n+    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        let mut bounds = ty.walk_shallow()\n+            .map(|subty| self.type_bound(subty))\n+            .collect::<Vec<_>>();\n+\n+        let mut regions = ty.regions();\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n+        bounds.push(VerifyBound::AllBounds(\n+            regions\n+                .into_iter()\n+                .map(|r| VerifyBound::OutlivedBy(r))\n+                .collect(),\n+        ));\n+\n+        // remove bounds that must hold, since they are not interesting\n+        bounds.retain(|b| !b.must_hold());\n+\n+        if bounds.len() == 1 {\n+            bounds.pop().unwrap()\n+        } else {\n+            VerifyBound::AllBounds(bounds)\n+        }\n+    }\n+\n+    /// Searches the environment for where-clauses like `G: 'a` where\n+    /// `G` is either some type parameter `T` or a projection like\n+    /// `T::Item`. Returns a vector of the `'a` bounds it can find.\n+    ///\n+    /// This is a conservative check -- it may not find all applicable\n+    /// bounds, but all the bounds it returns can be relied upon.\n+    fn declared_generic_bounds_from_env(\n+        &self,\n+        generic: GenericKind<'tcx>,\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let generic_ty = generic.to_ty(self.tcx);\n+        self.declared_generic_bounds_from_env_with_compare_fn(|ty| ty == generic_ty)\n+    }\n+\n+    fn declared_generic_bounds_from_env_with_compare_fn(\n+        &self,\n+        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let tcx = self.tcx;\n+\n+        // To start, collect bounds from user environment. Note that\n+        // parameter environments are already elaborated, so we don't\n+        // have to worry about that. Comparing using `==` is a bit\n+        // dubious for projections, but it will work for simple cases\n+        // like `T` and `T::Item`. It may not work as well for things\n+        // like `<T as Foo<'a>>::Item`.\n+        let c_b = self.param_env.caller_bounds;\n+        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b);\n+\n+        // Next, collect regions we scraped from the well-formedness\n+        // constraints in the fn signature. To do that, we walk the list\n+        // of known relations from the fn ctxt.\n+        //\n+        // This is crucial because otherwise code like this fails:\n+        //\n+        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n+        //\n+        // The problem is that the type of `x` is `&'a A`. To be\n+        // well-formed, then, A must be lower-generic by `'a`, but we\n+        // don't know that this holds from first principles.\n+        let from_region_bound_pairs = self.region_bound_pairs.iter().filter_map(|&(r, p)| {\n+            debug!(\n+                \"declared_generic_bounds_from_env_with_compare_fn: region_bound_pair = {:?}\",\n+                (r, p)\n+            );\n+            let p_ty = p.to_ty(tcx);\n+            if compare_ty(p_ty) {\n+                Some(ty::OutlivesPredicate(p_ty, r))\n+            } else {\n+                None\n+            }\n+        });\n+\n+        param_bounds\n+            .chain(from_region_bound_pairs)\n+            .inspect(|bound| {\n+                debug!(\n+                    \"declared_generic_bounds_from_env_with_compare_fn: result predicate = {:?}\",\n+                    bound\n+                )\n+            })\n+            .collect()\n+    }\n+\n+    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n+    /// declared in the trait definition. For example, if the trait were\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// then this function would return `'x`. This is subject to the\n+    /// limitations around higher-ranked bounds described in\n+    /// `region_bounds_declared_on_associated_item`.\n+    fn declared_projection_bounds_from_trait(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n+        let tcx = self.tcx;\n+        self.region_bounds_declared_on_associated_item(projection_ty.item_def_id)\n+            .map(move |r| r.subst(tcx, projection_ty.substs))\n+    }\n+\n+    /// Given the def-id of an associated item, returns any region\n+    /// bounds attached to that associated item from the trait definition.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// `'a`. You could then apply the substitutions from the\n+    /// projection to convert this into your namespace. This also\n+    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n+    /// the trait. In fact, it works by searching for just such a\n+    /// where-clause.\n+    ///\n+    /// It will not, however, work for higher-ranked bounds like:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a, 'b>\n+    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n+    /// {\n+    ///     type Bar;\n+    /// }\n+    /// ```\n+    ///\n+    /// This is for simplicity, and because we are not really smart\n+    /// enough to cope with such bounds anywhere.\n+    fn region_bounds_declared_on_associated_item(\n+        &self,\n+        assoc_item_def_id: DefId,\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+        let tcx = self.tcx;\n+        let assoc_item = tcx.associated_item(assoc_item_def_id);\n+        let trait_def_id = assoc_item.container.assert_trait();\n+        let trait_predicates = tcx.predicates_of(trait_def_id).predicates\n+            .into_iter()\n+            .map(|(p, _)| p)\n+            .collect();\n+        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n+        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n+        self.collect_outlives_from_predicate_list(\n+            move |ty| ty == identity_proj,\n+            traits::elaborate_predicates(tcx, trait_predicates),\n+        ).map(|b| b.1)\n+    }\n+\n+    /// Searches through a predicate list for a predicate `T: 'a`.\n+    ///\n+    /// Careful: does not elaborate predicates, and just uses `==`\n+    /// when comparing `ty` for equality, so `ty` must be something\n+    /// that does not involve inference variables and where you\n+    /// otherwise want a precise match.\n+    fn collect_outlives_from_predicate_list(\n+        &self,\n+        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+        predicates: impl IntoIterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n+    ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        predicates\n+            .into_iter()\n+            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| p.no_late_bound_regions())\n+            .filter(move |p| compare_ty(p.0))\n+    }\n+}"}, {"sha": "bc9027a08258c944d91223de0111f96238ae8a66", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 90, "deletions": 35, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -155,29 +155,94 @@ pub enum GenericKind<'tcx> {\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n-/// When we introduce a verification step, we wish to test that a\n-/// particular region (let's call it `'min`) meets some bound.\n-/// The bound is described the by the following grammar:\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GenericKind<'tcx> {\n+        (GenericKind::Param)(a),\n+        (GenericKind::Projection)(a),\n+    }\n+}\n+\n+/// Describes the things that some `GenericKind` value G is known to\n+/// outlive. Each variant of `VerifyBound` can be thought of as a\n+/// function:\n+///\n+///     fn(min: Region) -> bool { .. }\n+///\n+/// where `true` means that the region `min` meets that `G: min`.\n+/// (False means nothing.)\n+///\n+/// So, for example, if we have the type `T` and we have in scope that\n+/// `T: 'a` and `T: 'b`, then the verify bound might be:\n+///\n+///     fn(min: Region) -> bool {\n+///        ('a: min) || ('b: min)\n+///     }\n+///\n+/// This is described with a `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n-    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    /// Given a kind K and a bound B, expands to a function like the\n+    /// following, where `G` is the generic for which this verify\n+    /// bound was created:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       if G == K {\n+    ///         B(min)\n+    ///       } else {\n+    ///         false\n+    ///       }\n+    ///     }\n+    ///\n+    /// In other words, if the generic `G` that we are checking is\n+    /// equal to `K`, then check the associated verify bound\n+    /// (otherwise, false).\n     ///\n-    /// Put another way, the subject value is known to outlive all\n-    /// regions in {R}, so if any of those outlives 'min, then the\n-    /// bound is met.\n-    AnyRegion(Vec<Region<'tcx>>),\n+    /// This is used when we have something in the environment that\n+    /// may or may not be relevant, depending on the region inference\n+    /// results. For example, we may have `where <T as\n+    /// Trait<'a>>::Item: 'b` in our where clauses. If we are\n+    /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n+    /// this where-clause is only relevant if `'0` winds up inferred\n+    /// to `'a`.\n+    ///\n+    /// So we would compile to a verify-bound like\n+    ///\n+    ///     IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    ///\n+    /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n+    /// (after inference), and `'a: min`, then `G: min`.\n+    IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n \n-    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    /// Given a region `R`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       R: min\n+    ///     }\n     ///\n-    /// Put another way, the subject value is known to outlive some\n-    /// region in {R}, so if all of those outlives 'min, then the bound\n-    /// is met.\n-    AllRegions(Vec<Region<'tcx>>),\n+    /// This is used when we can establish that `G: R` -- therefore,\n+    /// if `R: min`, then by transitivity `G: min`.\n+    OutlivedBy(Region<'tcx>),\n \n-    /// B = exists {B} --> 'min must meet some bound b in {B}\n+    /// Given a set of bounds `B`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       exists (b in B) { b(min) }\n+    ///     }\n+    ///\n+    /// In other words, if we meet some bound in `B`, that suffices.\n+    /// This is used when all the bounds in `B` are known to apply to\n+    /// G.\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n-    /// B = forall {B} --> 'min must meet all bounds b in {B}\n+    /// Given a set of bounds `B`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       forall (b in B) { b(min) }\n+    ///     }\n+    ///\n+    /// In other words, if we meet *all* bounds in `B`, that suffices.\n+    /// This is used when *some* bound in `B` is known to suffice, but\n+    /// we don't know which.\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -882,33 +947,23 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut dyn FnMut(ty::Region<'tcx>)) {\n-        match self {\n-            &VerifyBound::AnyRegion(ref rs) | &VerifyBound::AllRegions(ref rs) => for &r in rs {\n-                f(r);\n-            },\n-\n-            &VerifyBound::AnyBound(ref bs) | &VerifyBound::AllBounds(ref bs) => for b in bs {\n-                b.for_each_region(f);\n-            },\n-        }\n-    }\n-\n     pub fn must_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n-            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n+            VerifyBound::IfEq(..) => false,\n+            VerifyBound::OutlivedBy(ty::ReStatic) => true,\n+            VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n+            VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),\n         }\n     }\n \n     pub fn cannot_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n-            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n+            VerifyBound::IfEq(_, b) => b.cannot_hold(),\n+            VerifyBound::OutlivedBy(ty::ReEmpty) => true,\n+            VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),\n+            VerifyBound::AllBounds(bs) => bs.iter().any(|b| b.cannot_hold()),\n         }\n     }\n "}, {"sha": "4f513cd5d484d99ec1fd6f222f86996754c2fea8", "filename": "src/librustc/infer/region_constraints/taint.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -13,34 +13,39 @@ use super::*;\n #[derive(Debug)]\n pub(super) struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>\n+    regions: FxHashSet<ty::Region<'tcx>>,\n }\n \n impl<'tcx> TaintSet<'tcx> {\n-    pub(super) fn new(directions: TaintDirections,\n-                      initial_region: ty::Region<'tcx>)\n-                      -> Self {\n+    pub(super) fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n         let mut regions = FxHashSet();\n         regions.insert(initial_region);\n-        TaintSet { directions: directions, regions: regions }\n+        TaintSet {\n+            directions: directions,\n+            regions: regions,\n+        }\n     }\n \n-    pub(super) fn fixed_point(&mut self,\n-                              tcx: TyCtxt<'_, '_, 'tcx>,\n-                              undo_log: &[UndoLogEntry<'tcx>],\n-                              verifys: &[Verify<'tcx>]) {\n+    pub(super) fn fixed_point(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        undo_log: &[UndoLogEntry<'tcx>],\n+        verifys: &[Verify<'tcx>],\n+    ) {\n         let mut prev_len = 0;\n         while prev_len < self.len() {\n-            debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n-                   prev_len, self.len());\n+            debug!(\n+                \"tainted: prev_len = {:?} new_len = {:?}\",\n+                prev_len,\n+                self.len()\n+            );\n \n             prev_len = self.len();\n \n             for undo_entry in undo_log {\n                 match undo_entry {\n                     &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)),\n-                                      tcx.mk_region(ReVar(b)));\n+                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n                     }\n                     &AddConstraint(Constraint::RegSubVar(a, b)) => {\n                         self.add_edge(a, tcx.mk_region(ReVar(b)));\n@@ -55,15 +60,13 @@ impl<'tcx> TaintSet<'tcx> {\n                         self.add_edge(a, tcx.mk_region(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n-                        verifys[i].bound.for_each_region(&mut |b| {\n-                            self.add_edge(verifys[i].region, b);\n-                        });\n+                        span_bug!(\n+                            verifys[i].origin.span(),\n+                            \"we never add verifications while doing higher-ranked things\",\n+                        )\n                     }\n-                    &Purged |\n-                    &AddCombination(..) |\n-                    &AddVar(..) |\n-                    &OpenSnapshot |\n-                    &CommitedSnapshot => {}\n+                    &Purged | &AddCombination(..) | &AddVar(..) | &OpenSnapshot\n+                    | &CommitedSnapshot => {}\n                 }\n             }\n         }\n@@ -77,9 +80,7 @@ impl<'tcx> TaintSet<'tcx> {\n         self.regions.len()\n     }\n \n-    fn add_edge(&mut self,\n-                source: ty::Region<'tcx>,\n-                target: ty::Region<'tcx>) {\n+    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n         if self.directions.incoming {\n             if self.regions.contains(&target) {\n                 self.regions.insert(source);\n@@ -93,4 +94,3 @@ impl<'tcx> TaintSet<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "38ec414fda9e383c9c91ee9a719d036fba52ba24", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -338,6 +338,12 @@ declare_lint! {\n      cannot be referred to by absolute paths\"\n }\n \n+declare_lint! {\n+    pub EXPLICIT_OUTLIVES_REQUIREMENTS,\n+    Allow,\n+    \"outlives requirements can be inferred\"\n+}\n+\n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {"}, {"sha": "8fea749e5ab4973dc6b044df2d9bbff35ac257a9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1631,7 +1631,7 @@ impl<'tcx> Statement<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n-    Assign(Place<'tcx>, Rvalue<'tcx>),\n+    Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n \n     /// This represents all the reading that a pattern match may do\n     /// (e.g. inspecting constants and discriminant values), and the\n@@ -1654,8 +1654,8 @@ pub enum StatementKind<'tcx> {\n     /// Execute a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n-        outputs: Vec<Place<'tcx>>,\n-        inputs: Vec<Operand<'tcx>>,\n+        outputs: Box<[Place<'tcx>]>,\n+        inputs: Box<[Operand<'tcx>]>,\n     },\n \n     /// Assert the given places to be valid inhabitants of their type.  These statements are"}, {"sha": "eb779e6382f4bebb5e7418f7645329cea222cc66", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1385,6 +1385,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"run the self profiler\"),\n     profile_json: bool = (false, parse_bool, [UNTRACKED],\n           \"output a json file with profiler results\"),\n+    emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n+          \"emits a section containing stack size metadata\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "8f106a08125386a56ee32998d2b3cbe0eeb554eb", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -16,10 +16,9 @@ use super::*;\n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-\n use infer::region_constraints::{Constraint, RegionConstraintData};\n-use infer::{InferCtxt, RegionObligation};\n+use infer::InferCtxt;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n use ty::fold::TypeFolder;\n use ty::{Region, RegionVid};\n@@ -227,20 +226,18 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 .iter()\n                 .filter_map(|param| match param.kind {\n                     ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n-                    _ => None\n+                    _ => None,\n                 })\n                 .collect();\n \n-            let body_ids: FxHashSet<_> = infcx\n+            let body_id_map: FxHashMap<_, _> = infcx\n                 .region_obligations\n                 .borrow()\n                 .iter()\n-                .map(|&(id, _)| id)\n+                .map(|&(id, _)| (id, vec![]))\n                 .collect();\n \n-            for id in body_ids {\n-                infcx.process_registered_region_obligations(&[], None, full_env.clone(), id);\n-            }\n+            infcx.process_registered_region_obligations(&body_id_map, None, full_env.clone());\n \n             let region_data = infcx\n                 .borrow_region_constraints()\n@@ -359,8 +356,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &Err(SelectionError::Unimplemented) => {\n                     if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n-                        self.add_user_pred(&mut user_computed_preds,\n-                                           ty::Predicate::Trait(pred.clone()));\n+                        self.add_user_pred(\n+                            &mut user_computed_preds,\n+                            ty::Predicate::Trait(pred.clone()),\n+                        );\n                         predicates.push_back(pred);\n                     } else {\n                         debug!(\n@@ -418,8 +417,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // under which a type implements an auto trait. A trait predicate involving\n     // a HRTB means that the type needs to work with any choice of lifetime,\n     // not just one specific lifetime (e.g. 'static).\n-    fn add_user_pred<'c>(&self, user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n-                         new_pred: ty::Predicate<'c>) {\n+    fn add_user_pred<'c>(\n+        &self,\n+        user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n+        new_pred: ty::Predicate<'c>,\n+    ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             match (&new_pred, old_pred) {\n@@ -431,20 +433,19 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         if !new_substs.types().eq(old_substs.types()) {\n                             // We can't compare lifetimes if the types are different,\n                             // so skip checking old_pred\n-                            return true\n+                            return true;\n                         }\n \n-                        for (new_region, old_region) in new_substs\n-                            .regions()\n-                            .zip(old_substs.regions()) {\n-\n+                        for (new_region, old_region) in\n+                            new_substs.regions().zip(old_substs.regions())\n+                        {\n                             match (new_region, old_region) {\n                                 // If both predicates have an 'ReLateBound' (a HRTB) in the\n                                 // same spot, we do nothing\n                                 (\n                                     ty::RegionKind::ReLateBound(_, _),\n-                                    ty::RegionKind::ReLateBound(_, _)\n-                                ) => {},\n+                                    ty::RegionKind::ReLateBound(_, _),\n+                                ) => {}\n \n                                 (ty::RegionKind::ReLateBound(_, _), _) => {\n                                     // The new predicate has a HRTB in a spot where the old\n@@ -458,7 +459,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                     // so we return 'false' to remove the old predicate from\n                                     // user_computed_preds\n                                     return false;\n-                                },\n+                                }\n                                 (_, ty::RegionKind::ReLateBound(_, _)) => {\n                                     // This is the opposite situation as the previous arm - the\n                                     // old predicate has a HRTB lifetime in a place where the\n@@ -471,10 +472,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => {}\n             }\n-            return true\n+            return true;\n         });\n \n         if should_add_new {\n@@ -513,44 +514,32 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             match constraint {\n                 &Constraint::VarSubVar(r1, r2) => {\n                     {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::RegionVid(r1))\n-                            .or_default();\n+                        let deps1 = vid_map.entry(RegionTarget::RegionVid(r1)).or_default();\n                         deps1.larger.insert(RegionTarget::RegionVid(r2));\n                     }\n \n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(r2))\n-                        .or_default();\n+                    let deps2 = vid_map.entry(RegionTarget::RegionVid(r2)).or_default();\n                     deps2.smaller.insert(RegionTarget::RegionVid(r1));\n                 }\n                 &Constraint::RegSubVar(region, vid) => {\n                     {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::Region(region))\n-                            .or_default();\n+                        let deps1 = vid_map.entry(RegionTarget::Region(region)).or_default();\n                         deps1.larger.insert(RegionTarget::RegionVid(vid));\n                     }\n \n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(vid))\n-                        .or_default();\n+                    let deps2 = vid_map.entry(RegionTarget::RegionVid(vid)).or_default();\n                     deps2.smaller.insert(RegionTarget::Region(region));\n                 }\n                 &Constraint::VarSubReg(vid, region) => {\n                     finished_map.insert(vid, region);\n                 }\n                 &Constraint::RegSubReg(r1, r2) => {\n                     {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::Region(r1))\n-                            .or_default();\n+                        let deps1 = vid_map.entry(RegionTarget::Region(r1)).or_default();\n                         deps1.larger.insert(RegionTarget::Region(r2));\n                     }\n \n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::Region(r2))\n-                        .or_default();\n+                    let deps2 = vid_map.entry(RegionTarget::Region(r2)).or_default();\n                     deps2.smaller.insert(RegionTarget::Region(r1));\n                 }\n             }\n@@ -683,7 +672,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     }\n                 }\n                 &ty::Predicate::RegionOutlives(ref binder) => {\n-                    if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n+                    if select\n+                        .infcx()\n+                        .region_outlives_predicate(&dummy_cause, binder)\n+                        .is_err()\n+                    {\n                         return false;\n                     }\n                 }\n@@ -693,23 +686,17 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n                     ) {\n                         (None, Some(t_a)) => {\n-                            select.infcx().register_region_obligation(\n-                                ast::DUMMY_NODE_ID,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: select.infcx().tcx.types.re_static,\n-                                    cause: dummy_cause.clone(),\n-                                },\n+                            select.infcx().register_region_obligation_with_cause(\n+                                t_a,\n+                                select.infcx().tcx.types.re_static,\n+                                &dummy_cause,\n                             );\n                         }\n                         (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select.infcx().register_region_obligation(\n-                                ast::DUMMY_NODE_ID,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_b,\n-                                    cause: dummy_cause.clone(),\n-                                },\n+                            select.infcx().register_region_obligation_with_cause(\n+                                t_a,\n+                                r_b,\n+                                &dummy_cause,\n                             );\n                         }\n                         _ => {}"}, {"sha": "9e9cdc69441cd16d4617b6d9ab0bd0240860f0dc", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -96,10 +96,10 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n \n     let header = ty::ImplHeader {\n         impl_def_id,\n-        self_ty: tcx.type_of(impl_def_id),\n-        trait_ref: tcx.impl_trait_ref(impl_def_id),\n-        predicates: tcx.predicates_of(impl_def_id).predicates\n-    }.subst(tcx, impl_substs);\n+        self_ty: tcx.type_of(impl_def_id).subst(tcx, impl_substs),\n+        trait_ref: tcx.impl_trait_ref(impl_def_id).subst(tcx, impl_substs),\n+        predicates: tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs).predicates,\n+    };\n \n     let Normalized { value: mut header, obligations } =\n         traits::normalize(selcx, param_env, ObligationCause::dummy(), &header);"}, {"sha": "19ee2c1aabfa47c8c0e9bd10b4f21b0a9ea920bd", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{RegionObligation, InferCtxt};\n+use infer::InferCtxt;\n use mir::interpret::GlobalId;\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n@@ -372,13 +372,11 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                             Some(t_a) => {\n                                 let r_static = self.selcx.tcx().types.re_static;\n                                 if self.register_region_obligations {\n-                                    self.selcx.infcx().register_region_obligation(\n-                                        obligation.cause.body_id,\n-                                        RegionObligation {\n-                                            sup_type: t_a,\n-                                            sub_region: r_static,\n-                                            cause: obligation.cause.clone(),\n-                                        });\n+                                    self.selcx.infcx().register_region_obligation_with_cause(\n+                                        t_a,\n+                                        r_static,\n+                                        &obligation.cause,\n+                                    );\n                                 }\n                                 ProcessResult::Changed(vec![])\n                             }\n@@ -387,13 +385,11 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                     // If there aren't, register the obligation.\n                     Some(ty::OutlivesPredicate(t_a, r_b)) => {\n                         if self.register_region_obligations {\n-                            self.selcx.infcx().register_region_obligation(\n-                                obligation.cause.body_id,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_b,\n-                                    cause: obligation.cause.clone()\n-                                });\n+                            self.selcx.infcx().register_region_obligation_with_cause(\n+                                t_a,\n+                                r_b,\n+                                &obligation.cause,\n+                            );\n                         }\n                         ProcessResult::Changed(vec![])\n                     }"}, {"sha": "6b1092814a4043616ab8d119d5078c6c7c70359b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -20,6 +20,7 @@ pub use self::ObligationCauseCode::*;\n use chalk_engine;\n use hir;\n use hir::def_id::DefId;\n+use infer::SuppressRegionErrors;\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use mir::interpret::ConstEvalErr;\n@@ -715,7 +716,12 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // cares about declarations like `'a: 'b`.\n         let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n-        infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &outlives_env);\n+        infcx.resolve_regions_and_report_errors(\n+            region_context,\n+            &region_scope_tree,\n+            &outlives_env,\n+            SuppressRegionErrors::default(),\n+        );\n \n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,\n@@ -810,11 +816,10 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                                       key: (DefId, &'tcx Substs<'tcx>))\n                                                       -> bool\n {\n-    use ty::subst::Subst;\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n            key);\n \n-    let predicates = tcx.predicates_of(key.0).predicates.subst(tcx, key.1);\n+    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n     let result = normalize_and_test_predicates(tcx, predicates);\n \n     debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\","}, {"sha": "d5942e738fdd9ad6a334e9b9ed69eea92b10defd", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         predicates\n             .predicates\n             .into_iter()\n-            .map(|predicate| predicate.subst_supertrait(self, &trait_ref))\n+            .map(|(predicate, _)| predicate.subst_supertrait(self, &trait_ref))\n             .any(|predicate| {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if self.predicates_of(method.def_id).predicates.into_iter()\n                 // A trait object can't claim to live more than the concrete type,\n                 // so outlives predicates will always hold.\n-                .filter(|p| p.to_opt_type_outlives().is_none())\n+                .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting."}, {"sha": "ab71d13ab0686d1818257c8170ed3c3d456eb439", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -3401,7 +3401,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n-        let mut predicates: Vec<_> = predicates.predicates.iter().flat_map(|predicate| {\n+        let mut predicates: Vec<_> = predicates.predicates.iter().flat_map(|(predicate, _)| {\n             let predicate = normalize_with_depth(self, param_env, cause.clone(), recursion_depth,\n                                                  &predicate.subst(tcx, substs));\n             predicate.obligations.into_iter().chain("}, {"sha": "bd6c2982065ef1acfc05be875a0291dc5f94d903", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -428,7 +428,7 @@ fn to_pretty_impl_header(tcx: TyCtxt, impl_def_id: DefId) -> Option<String> {\n     let mut pretty_predicates = Vec::with_capacity(\n         predicates.len() + types_without_default_bounds.len());\n \n-    for p in predicates {\n+    for (p, _) in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n                 types_without_default_bounds.remove(poly_trait_ref.self_ty());"}, {"sha": "7c273fb14db54fea2502510cb86d88583328b318", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -137,7 +137,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n                               .iter()\n-                              .map(|p| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n+                              .map(|(p, _)| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n                               .collect();\n \n                 debug!(\"super_predicates: data={:?} predicates={:?}\",\n@@ -311,7 +311,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n         self.stack.extend(\n             predicates.predicates\n                       .iter()\n-                      .filter_map(|p| p.to_opt_poly_trait_ref())\n+                      .filter_map(|(p, _)| p.to_opt_poly_trait_ref())\n                       .map(|t| t.def_id())\n                       .filter(|&super_def_id| visited.insert(super_def_id)));\n         Some(def_id)"}, {"sha": "45280402e489be43d71963999e2ce06a4d8a480e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -109,8 +109,9 @@ pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n {\n     predicates.parent.encode(encoder)?;\n     predicates.predicates.len().encode(encoder)?;\n-    for predicate in &predicates.predicates {\n-        encode_with_shorthand(encoder, predicate, &cache)?\n+    for (predicate, span) in &predicates.predicates {\n+        encode_with_shorthand(encoder, predicate, &cache)?;\n+        span.encode(encoder)?;\n     }\n     Ok(())\n }\n@@ -178,15 +179,16 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n         parent: Decodable::decode(decoder)?,\n         predicates: (0..decoder.read_usize()?).map(|_| {\n                 // Handle shorthands first, if we have an usize > 0x80.\n-                if decoder.positioned_at_shorthand() {\n+                let predicate = if decoder.positioned_at_shorthand() {\n                     let pos = decoder.read_usize()?;\n                     assert!(pos >= SHORTHAND_OFFSET);\n                     let shorthand = pos - SHORTHAND_OFFSET;\n \n                     decoder.with_position(shorthand, ty::Predicate::decode)\n                 } else {\n                     ty::Predicate::decode(decoder)\n-                }\n+                }?;\n+                Ok((predicate, Decodable::decode(decoder)?))\n             })\n             .collect::<Result<Vec<_>, _>>()?,\n     })"}, {"sha": "4e37a34a0c8a7f9af70d13a8f8d1cd8a790a3003", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n             }\n \n-            if sized && fields.iter().any(|f| f.abi.is_uninhabited()) {\n+            if sized && fields.iter().any(|f| f.abi == Abi::Uninhabited) {\n                 abi = Abi::Uninhabited;\n             }\n \n@@ -724,7 +724,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // See issue #49298 for more details on the need to leave space\n                 // for non-ZST uninhabited data (mostly partial initialization).\n                 let absent = |fields: &[TyLayout]| {\n-                    let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n+                    let uninhabited = fields.iter().any(|f| f.abi == Abi::Uninhabited);\n                     let is_zst = fields.iter().all(|f| f.is_zst());\n                     uninhabited && is_zst\n                 };\n@@ -872,7 +872,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 _ => Abi::Aggregate { sized: true },\n                             };\n \n-                            if st.iter().all(|v| v.abi.is_uninhabited()) {\n+                            if st.iter().all(|v| v.abi == Abi::Uninhabited) {\n                                 abi = Abi::Uninhabited;\n                             }\n \n@@ -900,7 +900,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let discr_type = def.repr.discr_type();\n                 let bits = Integer::from_attr(tcx, discr_type).size().bits();\n                 for (i, discr) in def.discriminants(tcx).enumerate() {\n-                    if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n+                    if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n                         continue;\n                     }\n                     let mut x = discr.val as i128;\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                 }\n \n-                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                if layout_variants.iter().all(|v| v.abi == Abi::Uninhabited) {\n                     abi = Abi::Uninhabited;\n                 }\n "}, {"sha": "df9335e909bc5e3d3f64950a0a97aae9bae633d2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -982,7 +982,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n #[derive(Clone, Default)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n-    pub predicates: Vec<Predicate<'tcx>>,\n+    pub predicates: Vec<(Predicate<'tcx>, Span)>,\n }\n \n impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n@@ -998,7 +998,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n-            predicates: self.predicates.subst(tcx, substs)\n+            predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n         }\n     }\n \n@@ -1008,7 +1008,9 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n-        instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n+        instantiated.predicates.extend(\n+            self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)),\n+        );\n     }\n \n     pub fn instantiate_identity(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n@@ -1023,7 +1025,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n         }\n-        instantiated.predicates.extend(&self.predicates)\n+        instantiated.predicates.extend(self.predicates.iter().map(|&(p, _)| p))\n     }\n \n     pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -1032,7 +1034,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     {\n         assert_eq!(self.parent, None);\n         InstantiatedPredicates {\n-            predicates: self.predicates.iter().map(|pred| {\n+            predicates: self.predicates.iter().map(|(pred, _)| {\n                 pred.subst_supertrait(tcx, poly_trait_ref)\n             }).collect()\n         }\n@@ -2351,7 +2353,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n                 let predicates = tcx.predicates_of(self.did).predicates;\n-                if predicates.into_iter().any(|p| p == sized_predicate) {\n+                if predicates.into_iter().any(|(p, _)| p == sized_predicate) {\n                     vec![]\n                 } else {\n                     vec![ty]"}, {"sha": "296602e21bad74f13c0871478811dc8eb62adfdb", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -606,6 +606,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, '\n         alloc_decoding_session.decode_alloc_id(self)\n     }\n }\n+\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let tag: u8 = Decodable::decode(self)?;"}, {"sha": "aab268c07c4fbf36473610facf7a79aff6daf3f8", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -720,6 +720,16 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     }\n }\n \n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>().into_boxed_slice()\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.map_bound_ref(|ty| ty.fold_with(folder))"}, {"sha": "f1bb41bcebacf3e3f85608d9b92cff01725bee62", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -30,7 +30,7 @@ pub fn codegen_inline_asm(\n     ia: &hir::InlineAsm,\n     outputs: Vec<PlaceRef<'ll, 'tcx>>,\n     mut inputs: Vec<&'ll Value>\n-) {\n+) -> bool {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n \n@@ -97,6 +97,10 @@ pub fn codegen_inline_asm(\n         ia.alignstack,\n         dialect\n     );\n+    if r.is_none() {\n+        return false;\n+    }\n+    let r = r.unwrap();\n \n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n@@ -117,6 +121,8 @@ pub fn codegen_inline_asm(\n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));\n     }\n+\n+    return true;\n }\n \n pub fn codegen_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,"}, {"sha": "ce52fe00b0eb2ec30d19b27e6d3460d6418b1f1e", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -47,7 +47,8 @@ use std::str;\n use syntax::attr;\n \n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n-                                  invalid_output_for_target, out_filename, check_file_is_writeable};\n+                                  invalid_output_for_target, out_filename, check_file_is_writeable,\n+                                  filename_for_metadata};\n \n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n@@ -218,15 +219,6 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     false\n }\n \n-fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilenames) -> PathBuf {\n-    let out_filename = outputs.single_output_file.clone()\n-        .unwrap_or(outputs\n-            .out_directory\n-            .join(&format!(\"lib{}{}.rmeta\", crate_name, sess.opts.cg.extra_filename)));\n-    check_file_is_writeable(&out_filename, sess);\n-    out_filename\n-}\n-\n pub(crate) fn each_linked_rlib(sess: &Session,\n                                info: &CrateInfo,\n                                f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {"}, {"sha": "02ef690b942333c8f44ed8576fd863eeceba265e", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -196,6 +196,7 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n     let features = CString::new(features).unwrap();\n     let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n+    let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n \n     let asm_comments = sess.asm_comments();\n \n@@ -213,6 +214,7 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n                 trap_unreachable,\n                 singlethread,\n                 asm_comments,\n+                emit_stack_size_section,\n             )\n         };\n "}, {"sha": "77de88997e4903ebc0326203049a4d1756e670a7", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -737,7 +737,7 @@ impl Builder<'a, 'll, 'tcx> {\n     pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n                          inputs: &[&'ll Value], output: &'ll Type,\n                          volatile: bool, alignstack: bool,\n-                         dia: AsmDialect) -> &'ll Value {\n+                         dia: AsmDialect) -> Option<&'ll Value> {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -753,9 +753,17 @@ impl Builder<'a, 'll, 'tcx> {\n         debug!(\"Asm Output Type: {:?}\", output);\n         let fty = Type::func(&argtys[..], output);\n         unsafe {\n-            let v = llvm::LLVMRustInlineAsm(\n-                fty, asm, cons, volatile, alignstack, dia);\n-            self.call(v, inputs, None)\n+            // Ask LLVM to verify that the constraints are well-formed.\n+            let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n+            debug!(\"Constraint verification result: {:?}\", constraints_ok);\n+            if constraints_ok == llvm::True {\n+                let v = llvm::LLVMRustInlineAsm(\n+                    fty, asm, cons, volatile, alignstack, dia);\n+                Some(self.call(v, inputs, None))\n+            } else {\n+                // LLVM has detected an issue with our constaints, bail out\n+                None\n+            }\n         }\n     }\n "}, {"sha": "99919a940b40511dcd605cea460440d5a1a9e05a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -279,7 +279,7 @@ pub fn create_function_debug_context(\n         }\n         None => {}\n     };\n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n+    if cx.layout_of(sig.output()).abi == ty::layout::Abi::Uninhabited {\n         flags = flags | DIFlags::FlagNoReturn;\n     }\n "}, {"sha": "5e743ac51bc616ffebbf47aa31851f9911a243a7", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -23,7 +23,7 @@\n use llvm;\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::spec::PanicStrategy;\n@@ -137,7 +137,7 @@ pub fn declare_fn(\n     let fty = FnType::new(cx, sig, &[]);\n     let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n \n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n+    if cx.layout_of(sig.output()).abi == layout::Abi::Uninhabited {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "242b7a1a119f7ef54b8aace01f4769ead2a40329", "filename": "src/librustc_codegen_llvm/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -47,4 +47,26 @@ unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n ```\n \"##,\n \n+E0668: r##\"\n+Malformed inline assembly rejected by LLVM.\n+\n+LLVM checks the validity of the constraints and the assembly string passed to\n+it. This error implies that LLVM seems something wrong with the inline\n+assembly call.\n+\n+In particular, it can happen if you forgot the closing bracket of a register\n+constraint (see issue #51430):\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(asm)]\n+\n+fn main() {\n+    let rax: u64;\n+    unsafe {\n+        asm!(\"\" :\"={rax\"(rax));\n+        println!(\"Accumulator is: {}\", rax);\n+    }\n+}\n+```\n+\"##,\n+\n }"}, {"sha": "8485db4210cb0b691fb2cfcbe7b6987838bf6f96", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1208,6 +1208,9 @@ extern \"C\" {\n                              AlignStack: Bool,\n                              Dialect: AsmDialect)\n                              -> &Value;\n+    pub fn LLVMRustInlineAsmVerify(Ty: &Type,\n+                             Constraints: *const c_char)\n+                             -> Bool;\n \n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n     pub fn LLVMRustVersionMajor() -> u32;\n@@ -1460,7 +1463,8 @@ extern \"C\" {\n                                        DataSections: bool,\n                                        TrapUnreachable: bool,\n                                        Singlethread: bool,\n-                                       AsmComments: bool)\n+                                       AsmComments: bool,\n+                                       EmitStackSizeSection: bool)\n                                        -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n     pub fn LLVMRustAddAnalysisPasses(T: &'a TargetMachine, PM: &PassManager<'a>, M: &'a Module);"}, {"sha": "a534b4e478fb793e4f96496e4621287c25eb0a24", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -482,54 +482,6 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     _ => FnType::new(bx.cx, sig, &extra_args)\n                 };\n \n-                // emit a panic instead of instantiating an uninhabited type\n-                if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n-                    fn_ty.ret.layout.abi.is_uninhabited()\n-                {\n-                    let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                    let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = C_str_slice(bx.cx, filename);\n-                    let line = C_u32(bx.cx, loc.line as u32);\n-                    let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n-                    let align = tcx.data_layout.aggregate_align\n-                        .max(tcx.data_layout.i32_align)\n-                        .max(tcx.data_layout.pointer_align);\n-\n-                    let str = format!(\n-                        \"Attempted to instantiate uninhabited type {} using mem::{}\",\n-                        sig.output(),\n-                        if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n-                    );\n-                    let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = C_str_slice(bx.cx, msg_str);\n-                    let msg_file_line_col = C_struct(bx.cx,\n-                                                    &[msg_str, filename, line, col],\n-                                                    false);\n-                    let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                            msg_file_line_col,\n-                                                            align,\n-                                                            Some(\"panic_loc\"));\n-\n-                    // Obtain the panic entry point.\n-                    let def_id =\n-                        common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n-                    let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                    let fn_ty = FnType::of_instance(bx.cx, &instance);\n-                    let llfn = callee::get_fn(bx.cx, instance);\n-\n-                    // Codegen the actual panic invoke/call.\n-                    do_call(\n-                        self,\n-                        bx,\n-                        fn_ty,\n-                        llfn,\n-                        &[msg_file_line_col],\n-                        destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n-                        cleanup,\n-                    );\n-                    return;\n-                }\n-\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n                 let mut llargs = Vec::with_capacity(arg_count);"}, {"sha": "c781b456af6b284825e3048984aaebaff01ab28d", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -173,10 +173,7 @@ impl PlaceRef<'ll, 'tcx> {\n         let cx = bx.cx;\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n-        let effective_field_align = self.align\n-            .min(self.layout.align)\n-            .min(field.align)\n-            .restrict_for_offset(offset);\n+        let effective_field_align = self.align.restrict_for_offset(offset);\n \n         let simple = || {\n             // Unions and newtypes only use an offset of 0.\n@@ -278,7 +275,7 @@ impl PlaceRef<'ll, 'tcx> {\n     /// Obtain the actual discriminant of a value.\n     pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n-        if self.layout.abi.is_uninhabited() {\n+        if self.layout.abi == layout::Abi::Uninhabited {\n             return C_undef(cast_to);\n         }\n         match self.layout.variants {\n@@ -341,7 +338,7 @@ impl PlaceRef<'ll, 'tcx> {\n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize) {\n-        if self.layout.for_variant(bx.cx, variant_index).abi.is_uninhabited() {\n+        if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n         match self.layout.variants {"}, {"sha": "c3ec347f60876c03dc846bbec04f75f546b8d75d", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -290,7 +290,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     mir::CastKind::Misc => {\n                         assert!(cast.is_llvm_immediate());\n                         let ll_t_out = cast.immediate_llvm_type(bx.cx);\n-                        if operand.layout.abi.is_uninhabited() {\n+                        if operand.layout.abi == layout::Abi::Uninhabited {\n                             return (bx, OperandRef {\n                                 val: OperandValue::Immediate(C_undef(ll_t_out)),\n                                 layout: cast,"}, {"sha": "6bd41bfe16feee3d6c23e6f8fd8eb271ecc45123", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -86,7 +86,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     self.codegen_operand(&bx, input).immediate()\n                 }).collect();\n \n-                asm::codegen_inline_asm(&bx, asm, outputs, input_vals);\n+                let res = asm::codegen_inline_asm(&bx, asm, outputs, input_vals);\n+                if !res {\n+                    span_err!(bx.sess(), statement.source_info.span, E0668,\n+                              \"malformed inline assembly\");\n+                }\n                 bx\n             }\n             mir::StatementKind::FakeRead(..) |"}, {"sha": "3d47f91a6239a96a5d412de3de6287a4be332caf", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -97,6 +97,19 @@ pub fn find_crate_name(sess: Option<&Session>,\n     \"rust_out\".to_string()\n }\n \n+pub fn filename_for_metadata(sess: &Session,\n+                             crate_name: &str,\n+                             outputs: &OutputFilenames) -> PathBuf {\n+    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n+\n+    let out_filename = outputs.single_output_file.clone()\n+        .unwrap_or(outputs.out_directory.join(&format!(\"lib{}.rmeta\", libname)));\n+\n+    check_file_is_writeable(&out_filename, sess);\n+\n+    out_filename\n+}\n+\n pub fn filename_for_input(sess: &Session,\n                           crate_type: config::CrateType,\n                           crate_name: &str,"}, {"sha": "a59bf9d530c4d0919001c3c81f23a33c9c0bbb40", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -535,6 +535,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.len()\n     }\n \n+    /// Gives the next index that will be assigned when `push` is\n+    /// called.\n+    #[inline]\n+    pub fn next_index(&self) -> I {\n+        I::new(self.len())\n+    }\n+\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n         self.raw.is_empty()"}, {"sha": "27176a821b4affa6e50d8b0587cac045a1e14c1d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -980,6 +980,7 @@ pub fn enable_save_analysis(control: &mut CompileController) {\n                                 state.expanded_crate.unwrap(),\n                                 state.analysis.unwrap(),\n                                 state.crate_name.unwrap(),\n+                                state.input,\n                                 None,\n                                 DumpHandler::new(state.out_dir,\n                                                  state.crate_name.unwrap()))"}, {"sha": "f18f40bf7a1448851a6bc44b398673d86a8eb76b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 219, "deletions": 163, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -14,29 +14,29 @@ use std::path::PathBuf;\n use std::sync::mpsc;\n \n use driver;\n-use rustc_lint;\n-use rustc_resolve::MakeGlobMap;\n-use rustc::middle::region;\n-use rustc::ty::subst::Subst;\n-use rustc::traits::ObligationCause;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::query::OnDiskCache;\n-use rustc::infer::{self, InferOk, InferResult};\n+use errors;\n+use errors::emitter::Emitter;\n+use errors::{DiagnosticBuilder, Level};\n+use rustc::hir::map as hir_map;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc_metadata::cstore::CStore;\n-use rustc::hir::map as hir_map;\n-use rustc::session::{self, config};\n+use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n+use rustc::middle::region;\n use rustc::session::config::{OutputFilenames, OutputTypes};\n+use rustc::session::{self, config};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::query::OnDiskCache;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::sync::{self, Lrc};\n+use rustc_lint;\n+use rustc_metadata::cstore::CStore;\n+use rustc_resolve::MakeGlobMap;\n+use rustc_target::spec::abi::Abi;\n use syntax;\n use syntax::ast;\n-use rustc_target::spec::abi::Abi;\n-use syntax::source_map::{SourceMap, FilePathMapping, FileName};\n-use errors;\n-use errors::emitter::Emitter;\n-use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::source_map::{FileName, FilePathMapping, SourceMap};\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n@@ -90,13 +90,15 @@ impl Emitter for ExpectErrorEmitter {\n \n fn errors(msgs: &[&str]) -> (Box<dyn Emitter + sync::Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>, msgs.len())\n+    (\n+        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>,\n+        msgs.len(),\n+    )\n }\n \n-fn test_env<F>(source_string: &str,\n-               args: (Box<dyn Emitter + sync::Send>, usize),\n-               body: F)\n-    where F: FnOnce(Env)\n+fn test_env<F>(source_string: &str, args: (Box<dyn Emitter + sync::Send>, usize), body: F)\n+where\n+    F: FnOnce(Env),\n {\n     syntax::with_globals(|| {\n         let mut options = config::Options::default();\n@@ -113,34 +115,41 @@ fn test_env_with_pool<F>(\n     options: config::Options,\n     source_string: &str,\n     (emitter, expected_err_count): (Box<dyn Emitter + sync::Send>, usize),\n-    body: F\n-)\n-    where F: FnOnce(Env)\n+    body: F,\n+) where\n+    F: FnOnce(Env),\n {\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n-    let sess = session::build_session_(options,\n-                                       None,\n-                                       diagnostic_handler,\n-                                       Lrc::new(SourceMap::new(FilePathMapping::empty())));\n+    let sess = session::build_session_(\n+        options,\n+        None,\n+        diagnostic_handler,\n+        Lrc::new(SourceMap::new(FilePathMapping::empty())),\n+    );\n     let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::Anon,\n         input: source_string.to_string(),\n     };\n-    let krate = driver::phase_1_parse_input(&driver::CompileController::basic(),\n-                                            &sess,\n-                                            &input).unwrap();\n-    let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(&sess,\n-                                             &cstore,\n-                                             krate,\n-                                             None,\n-                                             \"test\",\n-                                             None,\n-                                             MakeGlobMap::No,\n-                                             |_| Ok(()))\n-            .expect(\"phase 2 aborted\")\n+    let krate =\n+        driver::phase_1_parse_input(&driver::CompileController::basic(), &sess, &input).unwrap();\n+    let driver::ExpansionResult {\n+        defs,\n+        resolutions,\n+        mut hir_forest,\n+        ..\n+    } = {\n+        driver::phase_2_configure_and_expand(\n+            &sess,\n+            &cstore,\n+            krate,\n+            None,\n+            \"test\",\n+            None,\n+            MakeGlobMap::No,\n+            |_| Ok(()),\n+        ).expect(\"phase 2 aborted\")\n     };\n \n     let arenas = ty::AllArenas::new();\n@@ -155,32 +164,39 @@ fn test_env_with_pool<F>(\n         extra: String::new(),\n         outputs: OutputTypes::new(&[]),\n     };\n-    TyCtxt::create_and_enter(&sess,\n-                             &cstore,\n-                             ty::query::Providers::default(),\n-                             ty::query::Providers::default(),\n-                             &arenas,\n-                             resolutions,\n-                             hir_map,\n-                             OnDiskCache::new_empty(sess.source_map()),\n-                             \"test_crate\",\n-                             tx,\n-                             &outputs,\n-                             |tcx| {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_scope_tree = region::ScopeTree::default();\n-            let param_env = ty::ParamEnv::empty();\n-            body(Env {\n-                infcx: &infcx,\n-                region_scope_tree: &mut region_scope_tree,\n-                param_env: param_env,\n+    TyCtxt::create_and_enter(\n+        &sess,\n+        &cstore,\n+        ty::query::Providers::default(),\n+        ty::query::Providers::default(),\n+        &arenas,\n+        resolutions,\n+        hir_map,\n+        OnDiskCache::new_empty(sess.source_map()),\n+        \"test_crate\",\n+        tx,\n+        &outputs,\n+        |tcx| {\n+            tcx.infer_ctxt().enter(|infcx| {\n+                let mut region_scope_tree = region::ScopeTree::default();\n+                let param_env = ty::ParamEnv::empty();\n+                body(Env {\n+                    infcx: &infcx,\n+                    region_scope_tree: &mut region_scope_tree,\n+                    param_env: param_env,\n+                });\n+                let outlives_env = OutlivesEnvironment::new(param_env);\n+                let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n+                infcx.resolve_regions_and_report_errors(\n+                    def_id,\n+                    &region_scope_tree,\n+                    &outlives_env,\n+                    SuppressRegionErrors::default(),\n+                );\n+                assert_eq!(tcx.sess.err_count(), expected_err_count);\n             });\n-            let outlives_env = OutlivesEnvironment::new(param_env);\n-            let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n-            infcx.resolve_regions_and_report_errors(def_id, &region_scope_tree, &outlives_env);\n-            assert_eq!(tcx.sess.err_count(), expected_err_count);\n-        });\n-    });\n+        },\n+    );\n }\n \n fn d1() -> ty::DebruijnIndex {\n@@ -196,9 +212,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH,\n-                                   parent: (region::Scope, region::ScopeDepth)) {\n-        let me = region::Scope { id: rh.id, data: region::ScopeData::Node };\n+    pub fn create_region_hierarchy(\n+        &mut self,\n+        rh: &RH,\n+        parent: (region::Scope, region::ScopeDepth),\n+    ) {\n+        let me = region::Scope {\n+            id: rh.id,\n+            data: region::ScopeData::Node,\n+        };\n         self.region_scope_tree.record_scope_parent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n@@ -211,20 +233,25 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n         let dscope = region::Scope {\n             id: hir::ItemLocalId(1),\n-            data: region::ScopeData::Destruction\n+            data: region::ScopeData::Destruction,\n         };\n         self.region_scope_tree.record_scope_parent(dscope, None);\n-        self.create_region_hierarchy(&RH {\n-            id: hir::ItemLocalId(1),\n-            sub: &[RH {\n-                id: hir::ItemLocalId(10),\n-                sub: &[],\n+        self.create_region_hierarchy(\n+            &RH {\n+                id: hir::ItemLocalId(1),\n+                sub: &[\n+                    RH {\n+                        id: hir::ItemLocalId(10),\n+                        sub: &[],\n+                    },\n+                    RH {\n+                        id: hir::ItemLocalId(11),\n+                        sub: &[],\n+                    },\n+                ],\n             },\n-            RH {\n-                id: hir::ItemLocalId(11),\n-                sub: &[],\n-            }],\n-        }, (dscope, 1));\n+            (dscope, 1),\n+        );\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -236,11 +263,12 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        fn search_mod(this: &Env,\n-                      m: &hir::Mod,\n-                      idx: usize,\n-                      names: &[String])\n-                      -> Option<ast::NodeId> {\n+        fn search_mod(\n+            this: &Env,\n+            m: &hir::Mod,\n+            idx: usize,\n+            names: &[String],\n+        ) -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n                 let item = this.infcx.tcx.hir.expect_item(item.id);\n@@ -257,30 +285,33 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n \n             return match it.node {\n-                hir::ItemKind::Use(..) |\n-                hir::ItemKind::ExternCrate(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::ForeignMod(..) |\n-                hir::ItemKind::GlobalAsm(..) |\n-                hir::ItemKind::Existential(..) |\n-                hir::ItemKind::Ty(..) => None,\n-\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) |\n-                hir::ItemKind::Impl(..) => None,\n+                hir::ItemKind::Use(..)\n+                | hir::ItemKind::ExternCrate(..)\n+                | hir::ItemKind::Const(..)\n+                | hir::ItemKind::Static(..)\n+                | hir::ItemKind::Fn(..)\n+                | hir::ItemKind::ForeignMod(..)\n+                | hir::ItemKind::GlobalAsm(..)\n+                | hir::ItemKind::Existential(..)\n+                | hir::ItemKind::Ty(..) => None,\n+\n+                hir::ItemKind::Enum(..)\n+                | hir::ItemKind::Struct(..)\n+                | hir::ItemKind::Union(..)\n+                | hir::ItemKind::Trait(..)\n+                | hir::ItemKind::TraitAlias(..)\n+                | hir::ItemKind::Impl(..) => None,\n \n                 hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(a, b) {\n+        match self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sub(a, b)\n+        {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n@@ -302,13 +333,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n-            input_tys.iter().cloned(),\n-            output_ty,\n-            false,\n-            hir::Unsafety::Normal,\n-            Abi::Rust\n-        )))\n+        self.infcx\n+            .tcx\n+            .mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n+                input_tys.iter().cloned(),\n+                output_ty,\n+                false,\n+                hir::Unsafety::Normal,\n+                Abi::Rust,\n+            )))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n@@ -321,23 +354,30 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n+        self.infcx\n+            .tcx\n+            .mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name).as_interned_str();\n-        self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n-            index,\n-            name,\n-        }))\n+        self.infcx\n+            .tcx\n+            .mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+                index,\n+                name,\n+            }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self,\n-                                       id: u32,\n-                                       debruijn: ty::DebruijnIndex)\n-                                       -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n+    pub fn re_late_bound_with_debruijn(\n+        &self,\n+        id: u32,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> ty::Region<'tcx> {\n+        self.infcx\n+            .tcx\n+            .mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n     pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n@@ -349,20 +389,23 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_late_bound_with_debruijn(&self,\n-                                           id: u32,\n-                                           debruijn: ty::DebruijnIndex)\n-                                           -> Ty<'tcx> {\n+    pub fn t_rptr_late_bound_with_debruijn(\n+        &self,\n+        id: u32,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n         let r = ty::ReScope(region::Scope {\n             id: hir::ItemLocalId(id),\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         });\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx\n+            .tcx\n+            .mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n@@ -378,14 +421,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(t1, t2)\n+        self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sub(t1, t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(t1, t2) {\n-            Ok(InferOk { obligations, value: () }) => {\n+            Ok(InferOk {\n+                obligations,\n+                value: (),\n+            }) => {\n                 // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n             }\n@@ -445,8 +493,10 @@ fn sub_free_bound_false() {\n         env.create_simple_region_hierarchy();\n         let t_rptr_free1 = env.t_rptr_free(1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n+        env.check_not_sub(\n+            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+        );\n     })\n }\n \n@@ -462,8 +512,10 @@ fn sub_bound_free_true() {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n+        env.check_sub(\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+        );\n     })\n }\n \n@@ -476,18 +528,20 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+        let t_infer1 = env.infcx\n+            .next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n+        env.check_not_sub(\n+            env.t_fn(&[t_infer1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+        );\n     })\n }\n \n /// Test substituting a bound region into a function, which introduces another level of binding.\n /// This requires adjusting the Debruijn index.\n #[test]\n fn subst_ty_renumber_bound() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n@@ -509,11 +563,10 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -546,11 +599,10 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -559,7 +611,6 @@ fn subst_ty_renumber_some_bounds() {\n /// Test that we correctly compute whether a type has escaping regions or not.\n #[test]\n fn escaping() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n@@ -608,11 +659,10 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[t_rptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -627,9 +677,13 @@ fn walk_ty() {\n         let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n         let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n-        assert_eq!(walked,\n-                   [tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty,\n-                    usize_ty, int_ty, usize_ty, usize_ty]);\n+        assert_eq!(\n+            walked,\n+            [\n+                tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty, usize_ty,\n+                int_ty, usize_ty, usize_ty\n+            ]\n+        );\n     })\n }\n \n@@ -644,14 +698,16 @@ fn walk_ty_skip_subtree() {\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n-        let mut expected = vec![(tup2_ty, false),\n-                                (tup1_ty, false),\n-                                (int_ty, false),\n-                                (usize_ty, false),\n-                                (int_ty, false),\n-                                (usize_ty, false),\n-                                (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (usize_ty, false)];\n+        let mut expected = vec![\n+            (tup2_ty, false),\n+            (tup1_ty, false),\n+            (int_ty, false),\n+            (usize_ty, false),\n+            (int_ty, false),\n+            (usize_ty, false),\n+            (tup1_ty, true), // skip the isize/usize/isize/usize\n+            (usize_ty, false),\n+        ];\n         expected.reverse();\n \n         let mut walker = tup2_ty.walk();"}, {"sha": "7eda6e94dd0715f5a4cca9c7f981aa24c1385915", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 233, "deletions": 3, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1736,8 +1736,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             let predicates = cx.tcx.predicates_of(def_id);\n-            for predicate in &predicates.predicates {\n-                let predicate_kind_name = match *predicate {\n+            for &(predicate, span) in &predicates.predicates {\n+                let predicate_kind_name = match predicate {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1755,7 +1755,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                 if predicate.is_global() {\n                     cx.span_lint(\n                         TRIVIAL_BOUNDS,\n-                        item.span,\n+                        span,\n                         &format!(\"{} bound {} does not depend on any type \\\n                                 or lifetime parameters\", predicate_kind_name, predicate),\n                     );\n@@ -1999,3 +1999,233 @@ impl EarlyLintPass for KeywordIdents {\n         lint.emit()\n     }\n }\n+\n+\n+pub struct ExplicitOutlivesRequirements;\n+\n+impl LintPass for ExplicitOutlivesRequirements {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![EXPLICIT_OUTLIVES_REQUIREMENTS]\n+    }\n+}\n+\n+impl ExplicitOutlivesRequirements {\n+    fn collect_outlives_bound_spans(\n+        &self,\n+        cx: &LateContext,\n+        item_def_id: DefId,\n+        param_name: &str,\n+        bounds: &hir::GenericBounds,\n+        infer_static: bool\n+    ) -> Vec<(usize, Span)> {\n+        // For lack of a more elegant strategy for comparing the `ty::Predicate`s\n+        // returned by this query with the params/bounds grabbed from the HIR\u2014and\n+        // with some regrets\u2014we're going to covert the param/lifetime names to\n+        // strings\n+        let inferred_outlives = cx.tcx.inferred_outlives_of(item_def_id);\n+\n+        let ty_lt_names = inferred_outlives.iter().filter_map(|pred| {\n+            let binder = match pred {\n+                ty::Predicate::TypeOutlives(binder) => binder,\n+                _ => { return None; }\n+            };\n+            let ty_outlives_pred = binder.skip_binder();\n+            let ty_name = match ty_outlives_pred.0.sty {\n+                ty::Param(param) => param.name.to_string(),\n+                _ => { return None; }\n+            };\n+            let lt_name = match ty_outlives_pred.1 {\n+                ty::RegionKind::ReEarlyBound(region) => {\n+                    region.name.to_string()\n+                },\n+                _ => { return None; }\n+            };\n+            Some((ty_name, lt_name))\n+        }).collect::<Vec<_>>();\n+\n+        let mut bound_spans = Vec::new();\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if let hir::GenericBound::Outlives(lifetime) = bound {\n+                let is_static = match lifetime.name {\n+                    hir::LifetimeName::Static => true,\n+                    _ => false\n+                };\n+                if is_static && !infer_static {\n+                    // infer-outlives for 'static is still feature-gated (tracking issue #44493)\n+                    continue;\n+                }\n+\n+                let lt_name = &lifetime.name.ident().to_string();\n+                if ty_lt_names.contains(&(param_name.to_owned(), lt_name.to_owned())) {\n+                    bound_spans.push((i, bound.span()));\n+                }\n+            }\n+        }\n+        bound_spans\n+    }\n+\n+    fn consolidate_outlives_bound_spans(\n+        &self,\n+        lo: Span,\n+        bounds: &hir::GenericBounds,\n+        bound_spans: Vec<(usize, Span)>\n+    ) -> Vec<Span> {\n+        if bounds.is_empty() {\n+            return Vec::new();\n+        }\n+        if bound_spans.len() == bounds.len() {\n+            let (_, last_bound_span) = bound_spans[bound_spans.len()-1];\n+            // If all bounds are inferable, we want to delete the colon, so\n+            // start from just after the parameter (span passed as argument)\n+            vec![lo.to(last_bound_span)]\n+        } else {\n+            let mut merged = Vec::new();\n+            let mut last_merged_i = None;\n+\n+            let mut from_start = true;\n+            for (i, bound_span) in bound_spans {\n+                match last_merged_i {\n+                    // If the first bound is inferable, our span should also eat the trailing `+`\n+                    None if i == 0 => {\n+                        merged.push(bound_span.to(bounds[1].span().shrink_to_lo()));\n+                        last_merged_i = Some(0);\n+                    },\n+                    // If consecutive bounds are inferable, merge their spans\n+                    Some(h) if i == h+1 => {\n+                        if let Some(tail) = merged.last_mut() {\n+                            // Also eat the trailing `+` if the first\n+                            // more-than-one bound is inferable\n+                            let to_span = if from_start && i < bounds.len() {\n+                                bounds[i+1].span().shrink_to_lo()\n+                            } else {\n+                                bound_span\n+                            };\n+                            *tail = tail.to(to_span);\n+                            last_merged_i = Some(i);\n+                        } else {\n+                            bug!(\"another bound-span visited earlier\");\n+                        }\n+                    },\n+                    _ => {\n+                        // When we find a non-inferable bound, subsequent inferable bounds\n+                        // won't be consecutive from the start (and we'll eat the leading\n+                        // `+` rather than the trailing one)\n+                        from_start = false;\n+                        merged.push(bounds[i-1].span().shrink_to_hi().to(bound_span));\n+                        last_merged_i = Some(i);\n+                    }\n+                }\n+            }\n+            merged\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n+        let def_id = cx.tcx.hir.local_def_id(item.id);\n+        if let hir::ItemKind::Struct(_, ref generics) = item.node {\n+            let mut bound_count = 0;\n+            let mut lint_spans = Vec::new();\n+\n+            for param in &generics.params {\n+                let param_name = match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => { continue; },\n+                    hir::GenericParamKind::Type { .. } => {\n+                        match param.name {\n+                            hir::ParamName::Fresh(_) => { continue; },\n+                            hir::ParamName::Plain(name) => name.to_string()\n+                        }\n+                    }\n+                };\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx, def_id, &param_name, &param.bounds, infer_static\n+                );\n+                bound_count += bound_spans.len();\n+                lint_spans.extend(\n+                    self.consolidate_outlives_bound_spans(\n+                        param.span.shrink_to_hi(), &param.bounds, bound_spans\n+                    )\n+                );\n+            }\n+\n+            let mut where_lint_spans = Vec::new();\n+            let mut dropped_predicate_count = 0;\n+            let num_predicates = generics.where_clause.predicates.len();\n+            for (i, where_predicate) in generics.where_clause.predicates.iter().enumerate() {\n+                if let hir::WherePredicate::BoundPredicate(predicate) = where_predicate {\n+                    let param_name = match predicate.bounded_ty.node {\n+                        hir::TyKind::Path(ref qpath) => {\n+                            if let hir::QPath::Resolved(None, ty_param_path) = qpath {\n+                                ty_param_path.segments[0].ident.to_string()\n+                            } else {\n+                                continue;\n+                            }\n+                        },\n+                        _ => { continue; }\n+                    };\n+                    let bound_spans = self.collect_outlives_bound_spans(\n+                        cx, def_id, &param_name, &predicate.bounds, infer_static\n+                    );\n+                    bound_count += bound_spans.len();\n+\n+                    let drop_predicate = bound_spans.len() == predicate.bounds.len();\n+                    if drop_predicate {\n+                        dropped_predicate_count += 1;\n+                    }\n+\n+                    // If all the bounds on a predicate were inferable and there are\n+                    // further predicates, we want to eat the trailing comma\n+                    if drop_predicate && i + 1 < num_predicates {\n+                        let next_predicate_span = generics.where_clause.predicates[i+1].span();\n+                        where_lint_spans.push(\n+                            predicate.span.to(next_predicate_span.shrink_to_lo())\n+                        );\n+                    } else {\n+                        where_lint_spans.extend(\n+                            self.consolidate_outlives_bound_spans(\n+                                predicate.span.shrink_to_lo(),\n+                                &predicate.bounds,\n+                                bound_spans\n+                            )\n+                        );\n+                    }\n+                }\n+            }\n+\n+            // If all predicates are inferable, drop the entire clause\n+            // (including the `where`)\n+            if num_predicates > 0 && dropped_predicate_count == num_predicates {\n+                let full_where_span = generics.span.shrink_to_hi()\n+                    .to(generics.where_clause.span()\n+                    .expect(\"span of (nonempty) where clause should exist\"));\n+                lint_spans.push(\n+                    full_where_span\n+                );\n+            } else {\n+                lint_spans.extend(where_lint_spans);\n+            }\n+\n+            if !lint_spans.is_empty() {\n+                let mut err = cx.struct_span_lint(\n+                    EXPLICIT_OUTLIVES_REQUIREMENTS,\n+                    lint_spans.clone(),\n+                    \"outlives requirements can be inferred\"\n+                );\n+                err.multipart_suggestion_with_applicability(\n+                    if bound_count == 1 {\n+                        \"remove this bound\"\n+                    } else {\n+                        \"remove these bounds\"\n+                    },\n+                    lint_spans.into_iter().map(|span| (span, \"\".to_owned())).collect::<Vec<_>>(),\n+                    Applicability::MachineApplicable\n+                );\n+                err.emit();\n+            }\n+\n+        }\n+    }\n+\n+}"}, {"sha": "9e0471f59fbab6548fa741fb4765ca68b20be392", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -48,6 +48,7 @@ use rustc::lint::builtin::{\n     BARE_TRAIT_OBJECTS,\n     ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     ELIDED_LIFETIMES_IN_PATHS,\n+    EXPLICIT_OUTLIVES_REQUIREMENTS,\n     parser::QUESTION_MARK_MACRO_SEP\n };\n use rustc::session;\n@@ -157,6 +158,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         TypeLimits: TypeLimits::new(),\n         MissingDoc: MissingDoc::new(),\n         MissingDebugImplementations: MissingDebugImplementations::new(),\n+        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n     ]], ['tcx]);\n \n     store.register_late_pass(sess, false, box BuiltinCombinedLateLintPass::new());\n@@ -199,7 +201,8 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     BARE_TRAIT_OBJECTS,\n                     UNUSED_EXTERN_CRATES,\n                     ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n-                    ELIDED_LIFETIMES_IN_PATHS\n+                    ELIDED_LIFETIMES_IN_PATHS,\n+                    EXPLICIT_OUTLIVES_REQUIREMENTS\n \n                     // FIXME(#52665, #47816) not always applicable and not all\n                     // macros are ready for this yet."}, {"sha": "fa2debf2c0dc75e1cad65d7bf402f87c5d615af8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -256,6 +256,7 @@ impl<'a> CrateLoader<'a> {\n \n         let cmeta = cstore::CrateMetadata {\n             name: crate_root.name,\n+            imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,"}, {"sha": "ec48a4a4c6997187fd3e2a8cf1cbdbfa39e087a1", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -53,8 +53,13 @@ pub struct ImportedSourceFile {\n }\n \n pub struct CrateMetadata {\n+    /// Original name of the crate.\n     pub name: Symbol,\n \n+    /// Name of the crate as imported.  I.e. if imported with\n+    /// `extern crate foo as bar;` this will be `bar`.\n+    pub imported_name: Symbol,\n+\n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n     /// (e.g., by the allocator)"}, {"sha": "fb0d6837986066e108685efd98709916e2c4667e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -441,8 +441,7 @@ impl cstore::CStore {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n-        } else if data.name == \"proc_macro\" &&\n-                  self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n+        } else if data.name == \"proc_macro\" && data.item_name(id.index) == \"quote\" {\n             use syntax::ext::base::SyntaxExtension;\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n \n@@ -454,8 +453,9 @@ impl cstore::CStore {\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }\n \n-        let (name, def) = data.get_macro(id.index);\n-        let source_name = FileName::Macros(name.to_string());\n+        let def = data.get_macro(id.index);\n+        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.imported_name);\n+        let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n         let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);"}, {"sha": "33a4af053eb73a2ae9e01bb142b7ee22eef4123d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1106,10 +1106,10 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_macro(&self, id: DefIndex) -> (InternedString, MacroDef) {\n+    pub fn get_macro(&self, id: DefIndex) -> MacroDef {\n         let entry = self.entry(id);\n         match entry.kind {\n-            EntryKind::MacroDef(macro_def) => (self.item_name(id), macro_def.decode(self)),\n+            EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }"}, {"sha": "a4e9e9579950badf0574a158dbd88338771c80be", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1319,7 +1319,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n                     if let StatementKind::Assign(\n                         Place::Local(assigned_to),\n-                        rvalue,\n+                        box rvalue,\n                     ) = &stmt.kind {\n                         debug!(\"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n                                rvalue={:?}\", assigned_to, rvalue);\n@@ -1823,7 +1823,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             None => return OtherUse(self.mir.source_info(location).span),\n         };\n \n-        if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+        if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n             if let AggregateKind::Closure(def_id, _) = **kind {\n                 debug!(\"find_closure_move_span: found closure {:?}\", places);\n \n@@ -1886,7 +1886,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places))\n+                = stmt.kind {\n                 if let AggregateKind::Closure(def_id, _) = **kind {\n                     debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n "}, {"sha": "6ecbc5ee727c1ddb1ef7b047175442b91d7ade13", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -534,7 +534,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 ref inputs,\n             } => {\n                 let context = ContextKind::InlineAsm.new(location);\n-                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                for (o, output) in asm.outputs.iter().zip(outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoeded through MIR place derefs instead.\n@@ -561,7 +561,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                         );\n                     }\n                 }\n-                for input in inputs {\n+                for input in inputs.iter() {\n                     self.consume_operand(context, (input, span), flow_state);\n                 }\n             }"}, {"sha": "1c55806872d57ce0430b609a63ce5f858bbc93e7", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n                     Place::Local(local),\n-                    Rvalue::Use(Operand::Move(move_from)),\n+                    box Rvalue::Use(Operand::Move(move_from)),\n                 )) = self.mir.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)"}, {"sha": "f19c102adcfe9d08db44cc197bc4bc6de47a1689", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -109,7 +109,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 ref inputs,\n             } => {\n                 let context = ContextKind::InlineAsm.new(location);\n-                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                for (o, output) in asm.outputs.iter().zip(outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoeded through MIR place derefs instead.\n@@ -128,7 +128,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                         );\n                     }\n                 }\n-                for input in inputs {\n+                for input in inputs.iter() {\n                     self.consume_operand(context, input);\n                 }\n             }\n@@ -479,7 +479,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n \n     /// Generate a new invalidates(L, B) fact\n     fn generate_invalidates(&mut self, b: BorrowIndex, l: Location) {\n-        let lidx = self.location_table.mid_index(l);\n+        let lidx = self.location_table.start_index(l);\n         self.all_facts.invalidates.push((lidx, b));\n     }\n }"}, {"sha": "2dbb5cd9deb144437a38fb9d9cbd9e236489f217", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 131, "deletions": 60, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -10,15 +10,13 @@\n \n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use borrow_check::nll::constraints::{\n-    ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n-};\n+use borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::region_constraints::{GenericKind, VarInfos};\n+use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n@@ -29,7 +27,7 @@ use rustc::util::common;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::{DiagnosticBuilder, Diagnostic};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n \n use std::rc::Rc;\n \n@@ -71,6 +69,15 @@ pub struct RegionInferenceContext<'tcx> {\n     /// visible from this index.\n     scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n \n+    /// Contains a \"representative\" from each SCC. This will be the\n+    /// minimal RegionVid belonging to that universe. It is used as a\n+    /// kind of hacky way to manage checking outlives relationships,\n+    /// since we can 'canonicalize' each region to the representative\n+    /// of its SCC and be sure that -- if they have the same repr --\n+    /// they *must* be equal (though not having the same repr does not\n+    /// mean they are unequal).\n+    scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n+\n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n@@ -162,42 +169,7 @@ pub struct TypeTest<'tcx> {\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n-    pub test: RegionTest,\n-}\n-\n-/// A \"test\" that can be applied to some \"subject region\" `'x`. These are used to\n-/// describe type constraints. Tests do not presently affect the\n-/// region values that get inferred for each variable; they only\n-/// examine the results *after* inference.  This means they can\n-/// conveniently include disjuction (\"a or b must be true\").\n-#[derive(Clone, Debug)]\n-pub enum RegionTest {\n-    /// The subject region `'x` must by outlived by *some* region in\n-    /// the given set of regions.\n-    ///\n-    /// This test comes from e.g. a where clause like `T: 'a + 'b`,\n-    /// which implies that we know that `T: 'a` and that `T:\n-    /// 'b`. Therefore, if we are trying to prove that `T: 'x`, we can\n-    /// do so by showing that `'a: 'x` *or* `'b: 'x`.\n-    IsOutlivedByAnyRegionIn(Vec<RegionVid>),\n-\n-    /// The subject region `'x` must by outlived by *all* regions in\n-    /// the given set of regions.\n-    ///\n-    /// This test comes from e.g. a projection type like `T = <u32 as\n-    /// Trait<'a, 'b>>::Foo`, which must outlive `'a` or `'b`, and\n-    /// maybe both. Therefore we can prove that `T: 'x` if we know\n-    /// that `'a: 'x` *and* `'b: 'x`.\n-    IsOutlivedByAllRegionsIn(Vec<RegionVid>),\n-\n-    /// Any of the given tests are true.\n-    ///\n-    /// This arises from projections, for which there are multiple\n-    /// ways to prove an outlives relationship.\n-    Any(Vec<RegionTest>),\n-\n-    /// All of the given tests are true.\n-    All(Vec<RegionTest>),\n+    pub verify_bound: VerifyBound<'tcx>,\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -245,13 +217,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n \n+        let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n+\n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n             scc_universes,\n+            scc_representatives,\n             scc_values,\n             type_tests,\n             universal_regions,\n@@ -288,6 +263,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         scc_universes\n     }\n \n+    /// For each SCC, we compute a unique `RegionVid` (in fact, the\n+    /// minimal one that belongs to the SCC). See\n+    /// `scc_representatives` field of `RegionInferenceContext` for\n+    /// more details.\n+    fn compute_scc_representatives(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    ) -> IndexVec<ConstraintSccIndex, ty::RegionVid> {\n+        let num_sccs = constraints_scc.num_sccs();\n+        let next_region_vid = definitions.next_index();\n+        let mut scc_representatives = IndexVec::from_elem_n(next_region_vid, num_sccs);\n+\n+        for region_vid in definitions.indices() {\n+            let scc = constraints_scc.scc(region_vid);\n+            let prev_min = scc_representatives[scc];\n+            scc_representatives[scc] = region_vid.min(prev_min);\n+        }\n+\n+        scc_representatives\n+    }\n+\n     /// Initializes the region variables for each universally\n     /// quantified region (lifetime parameter). The first N variables\n     /// always correspond to the regions appearing in the function\n@@ -582,7 +578,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(mir, type_test.lower_bound, &type_test.test) {\n+            let generic_ty = type_test.generic_kind.to_ty(tcx);\n+            if self.eval_verify_bound(\n+                tcx,\n+                mir,\n+                generic_ty,\n+                type_test.lower_bound,\n+                &type_test.verify_bound,\n+            ) {\n                 continue;\n             }\n \n@@ -689,7 +692,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             generic_kind,\n             lower_bound,\n             locations,\n-            test: _,\n+            verify_bound: _,\n         } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n@@ -716,7 +719,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_region_test(mir, ur, &type_test.test) {\n+            if self.eval_verify_bound(tcx, mir, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -888,31 +891,99 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Test if `test` is true when applied to `lower_bound` at\n     /// `point`, and returns true or false.\n-    fn eval_region_test(&self, mir: &Mir<'tcx>, lower_bound: RegionVid, test: &RegionTest) -> bool {\n+    fn eval_verify_bound(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        generic_ty: Ty<'tcx>,\n+        lower_bound: RegionVid,\n+        verify_bound: &VerifyBound<'tcx>,\n+    ) -> bool {\n         debug!(\n-            \"eval_region_test(lower_bound={:?}, test={:?})\",\n-            lower_bound, test\n+            \"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\",\n+            lower_bound, verify_bound\n         );\n \n-        match test {\n-            RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n-                .iter()\n-                .all(|&r| self.eval_outlives(mir, r, lower_bound)),\n+        match verify_bound {\n+            VerifyBound::IfEq(test_ty, verify_bound1) => {\n+                self.eval_if_eq(tcx, mir, generic_ty, lower_bound, test_ty, verify_bound1)\n+            }\n \n-            RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n-                .iter()\n-                .any(|&r| self.eval_outlives(mir, r, lower_bound)),\n+            VerifyBound::OutlivedBy(r) => {\n+                let r_vid = self.to_region_vid(r);\n+                self.eval_outlives(mir, r_vid, lower_bound)\n+            }\n \n-            RegionTest::Any(tests) => tests\n-                .iter()\n-                .any(|test| self.eval_region_test(mir, lower_bound, test)),\n+            VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n+                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            }),\n \n-            RegionTest::All(tests) => tests\n-                .iter()\n-                .all(|test| self.eval_region_test(mir, lower_bound, test)),\n+            VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n+                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            }),\n+        }\n+    }\n+\n+    fn eval_if_eq(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        generic_ty: Ty<'tcx>,\n+        lower_bound: RegionVid,\n+        test_ty: Ty<'tcx>,\n+        verify_bound: &VerifyBound<'tcx>,\n+    ) -> bool {\n+        let generic_ty_normalized = self.normalize_to_scc_representatives(tcx, generic_ty);\n+        let test_ty_normalized = self.normalize_to_scc_representatives(tcx, test_ty);\n+        if generic_ty_normalized == test_ty_normalized {\n+            self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+        } else {\n+            false\n         }\n     }\n \n+    /// This is a conservative normalization procedure. It takes every\n+    /// free region in `value` and replaces it with the\n+    /// \"representative\" of its SCC (see `scc_representatives` field).\n+    /// We are guaranteed that if two values normalize to the same\n+    /// thing, then they are equal; this is a conservative check in\n+    /// that they could still be equal even if they normalize to\n+    /// different results. (For example, there might be two regions\n+    /// with the same value that are not in the same SCC).\n+    ///\n+    /// NB. This is not an ideal approach and I would like to revisit\n+    /// it. However, it works pretty well in practice. In particular,\n+    /// this is needed to deal with projection outlives bounds like\n+    ///\n+    ///     <T as Foo<'0>>::Item: '1\n+    ///\n+    /// In particular, this routine winds up being important when\n+    /// there are bounds like `where <T as Foo<'a>>::Item: 'b` in the\n+    /// environment.  In this case, if we can show that `'0 == 'a`,\n+    /// and that `'b: '1`, then we know that the clause is\n+    /// satisfied. In such cases, particularly due to limitations of\n+    /// the trait solver =), we usually wind up with a where-clause like\n+    /// `T: Foo<'a>` in scope, which thus forces `'0 == 'a` to be added as\n+    /// a constraint, and thus ensures that they are in the same SCC.\n+    ///\n+    /// So why can't we do a more correct routine? Well, we could\n+    /// *almost* use the `relate_tys` code, but the way it is\n+    /// currently setup it creates inference variables to deal with\n+    /// higher-ranked things and so forth, and right now the inference\n+    /// context is not permitted to make more inference variables. So\n+    /// we use this kind of hacky solution.\n+    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(&value, &mut false, |r, _db| {\n+            let vid = self.to_region_vid(r);\n+            let scc = self.constraint_sccs.scc(vid);\n+            let repr = self.scc_representatives[scc];\n+            tcx.mk_region(ty::ReVar(repr))\n+        })\n+    }\n+\n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,"}, {"sha": "dabf669eca65f0de63169e9584a4e8ae08a8df5f", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 6, "deletions": 58, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n-use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n+use borrow_check::nll::region_infer::TypeTest;\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc::infer::{self, SubregionOrigin};\n@@ -25,43 +24,37 @@ use syntax_pos::DUMMY_SP;\n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n-    location_table: &'a LocationTable,\n-    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n     outlives_constraints: &'a mut ConstraintSet,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n-    all_facts: &'a mut Option<AllFacts>,\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n-        location_table: &'a LocationTable,\n-        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n         outlives_constraints: &'a mut ConstraintSet,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n-        all_facts: &'a mut Option<AllFacts>,\n     ) -> Self {\n         Self {\n             tcx,\n             universal_regions,\n-            location_table,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n             locations,\n             category,\n             outlives_constraints,\n             type_tests,\n-            all_facts,\n         }\n     }\n \n@@ -100,23 +93,6 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n                 self.add_outlives(r1_vid, r2_vid);\n-\n-                // In the new analysis, all outlives relations etc\n-                // \"take effect\" at the mid point of the statement\n-                // that requires them, so ignore the `at_location`.\n-                if let Some(all_facts) = &mut self.all_facts {\n-                    if let Some(from_location) = self.locations.from_location() {\n-                        all_facts.outlives.push((\n-                            r1_vid,\n-                            r2_vid,\n-                            self.location_table.mid_index(from_location),\n-                        ));\n-                    } else {\n-                        for location in self.location_table.all_points() {\n-                            all_facts.outlives.push((r1_vid, r2_vid, location));\n-                        }\n-                    }\n-                }\n             }\n \n             UnpackedKind::Type(t1) => {\n@@ -139,43 +115,15 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         &self,\n         generic_kind: GenericKind<'tcx>,\n         region: ty::Region<'tcx>,\n-        bound: VerifyBound<'tcx>,\n+        verify_bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n \n-        let test = self.verify_bound_to_region_test(&bound);\n-\n         TypeTest {\n             generic_kind,\n             lower_bound,\n             locations: self.locations,\n-            test,\n-        }\n-    }\n-\n-    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n-        match verify_bound {\n-            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-\n-            VerifyBound::AllBounds(bounds) => RegionTest::All(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n+            verify_bound,\n         }\n     }\n "}, {"sha": "f33909db78f9fe2cdb92c8d23fe2674442ed6ec3", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::location::LocationTable;\n-use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::type_check::constraint_conversion;\n use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use borrow_check::nll::universal_regions::UniversalRegions;\n@@ -69,19 +67,15 @@ crate struct CreateResult<'tcx> {\n crate fn create(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    location_table: &LocationTable,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     constraints: &mut MirTypeckRegionConstraints<'tcx>,\n-    all_facts: &mut Option<AllFacts>,\n ) -> CreateResult<'tcx> {\n     UniversalRegionRelationsBuilder {\n         infcx,\n         param_env,\n         implicit_region_bound,\n         constraints,\n-        location_table,\n-        all_facts,\n         universal_regions: universal_regions.clone(),\n         region_bound_pairs: Vec::new(),\n         relations: UniversalRegionRelations {\n@@ -210,11 +204,9 @@ impl UniversalRegionRelations<'tcx> {\n struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n     infcx: &'this InferCtxt<'this, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    location_table: &'this LocationTable,\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     constraints: &'this mut MirTypeckRegionConstraints<'tcx>,\n-    all_facts: &'this mut Option<AllFacts>,\n \n     // outputs:\n     relations: UniversalRegionRelations<'tcx>,\n@@ -281,15 +273,13 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx.tcx,\n                 &self.universal_regions,\n-                &self.location_table,\n                 &self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n                 Locations::All(DUMMY_SP),\n                 ConstraintCategory::Internal,\n                 &mut self.constraints.outlives_constraints,\n                 &mut self.constraints.type_tests,\n-                &mut self.all_facts,\n             ).convert_all(&data);\n         }\n "}, {"sha": "cc176cbc40392aa733851faa605d681645fc1ee6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -17,6 +17,7 @@\n //! types, instead of all variables.\n \n use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::facts::{AllFacts, AllFactsExt};\n use rustc::mir::{Local, Mir};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -61,12 +62,13 @@ impl NllLivenessMap {\n         mir: &Mir<'tcx>,\n     ) -> Self {\n         let mut to_local = IndexVec::default();\n+        let facts_enabled = AllFacts::enabled(tcx);\n         let from_local: IndexVec<Local, Option<_>> = mir.local_decls\n             .iter_enumerated()\n             .map(|(local, local_decl)| {\n                 if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n                     free_regions.contains(&r.to_region_vid())\n-                }) {\n+                }) && !facts_enabled {\n                     // If all the regions in the type are free regions\n                     // (or there are no regions), then we don't need\n                     // to track liveness for this variable."}, {"sha": "9ccdc84db156186a27553fffdb7a15786fcea355", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::location::LocationTable;\n use borrow_check::nll::region_infer::values::RegionValueElements;\n use borrow_check::nll::constraints::ConstraintSet;\n use borrow_check::nll::NllLivenessMap;\n@@ -40,6 +41,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n+    location_table: &LocationTable,\n ) {\n     debug!(\"liveness::generate\");\n     let free_regions = {\n@@ -51,7 +53,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n         )\n     };\n     let liveness_map = NllLivenessMap::compute(typeck.tcx(), &free_regions, mir);\n-    trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map);\n+    trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map, location_table);\n }\n \n /// Compute all regions that are (currently) known to outlive free"}, {"sha": "6c1252fc73d8bc0da81997add09880c99cbe2ed6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::ConstraintCategory;\n use borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n use borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n@@ -49,6 +50,7 @@ pub(super) fn trace(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     liveness_map: &NllLivenessMap,\n+    location_table: &LocationTable,\n ) {\n     debug!(\"trace()\");\n \n@@ -67,6 +69,7 @@ pub(super) fn trace(\n         move_data,\n         liveness_map,\n         drop_data: FxHashMap::default(),\n+        location_table,\n     };\n \n     LivenessResults::new(cx).compute_for_all_locals();\n@@ -105,6 +108,9 @@ where\n \n     /// Map tracking which variables need liveness computation.\n     liveness_map: &'me NllLivenessMap,\n+\n+    /// Maps between a MIR Location and a LocationIndex\n+    location_table: &'me LocationTable,\n }\n \n struct DropData<'tcx> {\n@@ -453,7 +459,13 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n-        Self::make_all_regions_live(self.elements, &mut self.typeck, value, live_at)\n+        Self::make_all_regions_live(\n+            self.elements,\n+            &mut self.typeck,\n+            value,\n+            live_at,\n+            self.location_table,\n+        )\n     }\n \n     /// Some variable with type `live_ty` is \"drop live\" at `location`\n@@ -505,7 +517,13 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n         for &kind in &drop_data.dropck_result.kinds {\n-            Self::make_all_regions_live(self.elements, &mut self.typeck, kind, live_at);\n+            Self::make_all_regions_live(\n+                self.elements,\n+                &mut self.typeck,\n+                kind,\n+                live_at,\n+                self.location_table,\n+            );\n         }\n     }\n \n@@ -514,6 +532,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         typeck: &mut TypeChecker<'_, '_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n         live_at: &HybridBitSet<PointIndex>,\n+        location_table: &LocationTable,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!(\n@@ -532,8 +551,12 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n                 .liveness_constraints\n                 .add_elements(live_region_vid, live_at);\n \n-            if let Some(_) = borrowck_context.all_facts {\n-                bug!(\"polonius liveness facts not implemented yet\")\n+            if let Some(facts) = borrowck_context.all_facts {\n+                for point in live_at.iter() {\n+                    let loc = elements.to_location(point);\n+                    facts.region_live_at.push((live_region_vid, location_table.start_index(loc)));\n+                    facts.region_live_at.push((live_region_vid, location_table.mid_index(loc)));\n+                }\n             }\n         });\n     }"}, {"sha": "4c2ef58a3a78321d56ccddc942f42beebd9744d2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 150, "deletions": 177, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -17,37 +17,38 @@ use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, Outlives\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use borrow_check::nll::renumber;\n use borrow_check::nll::type_check::free_region_relations::{\n     CreateResult, UniversalRegionRelations,\n };\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n-use borrow_check::nll::renumber;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n-use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n+use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use rustc::ty::subst::Subst;\n-use std::fmt;\n+use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use std::{fmt, iter};\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n \n use rustc_data_structures::fx::FxHashSet;\n+use either::Either;\n \n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n@@ -135,41 +136,35 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     } = free_region_relations::create(\n         infcx,\n         param_env,\n-        location_table,\n         Some(implicit_region_bound),\n         universal_regions,\n         &mut constraints,\n-        all_facts,\n     );\n \n-    {\n-        let mut borrowck_context = BorrowCheckContext {\n-            universal_regions,\n-            location_table,\n-            borrow_set,\n-            all_facts,\n-            constraints: &mut constraints,\n-        };\n+    let mut borrowck_context = BorrowCheckContext {\n+        universal_regions,\n+        location_table,\n+        borrow_set,\n+        all_facts,\n+        constraints: &mut constraints,\n+    };\n \n-        type_check_internal(\n-            infcx,\n-            mir_def_id,\n-            param_env,\n-            mir,\n-            &region_bound_pairs,\n-            Some(implicit_region_bound),\n-            Some(&mut borrowck_context),\n-            Some(&universal_region_relations),\n-            |cx| {\n-                cx.equate_inputs_and_outputs(\n-                    mir,\n-                    universal_regions,\n-                    &normalized_inputs_and_output,\n-                );\n-                liveness::generate(cx, mir, elements, flow_inits, move_data);\n-            },\n-        );\n-    }\n+    type_check_internal(\n+        infcx,\n+        mir_def_id,\n+        param_env,\n+        mir,\n+        &region_bound_pairs,\n+        Some(implicit_region_bound),\n+        Some(&mut borrowck_context),\n+        Some(&universal_region_relations),\n+        |cx| {\n+            cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n+            liveness::generate(cx, mir, elements, flow_inits, move_data, location_table);\n+\n+            cx.borrowck_context.as_mut().map(|bcx| translate_outlives_facts(bcx));\n+        },\n+    );\n \n     MirTypeckResults {\n         constraints,\n@@ -182,7 +177,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &'a Mir<'tcx>,\n-    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n@@ -212,6 +207,27 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     extra(&mut checker)\n }\n \n+fn translate_outlives_facts(cx: &mut BorrowCheckContext) {\n+    if let Some(facts) = cx.all_facts {\n+        let location_table = cx.location_table;\n+        facts.outlives.extend(\n+            cx.constraints.outlives_constraints.iter().flat_map(|constraint: &OutlivesConstraint| {\n+                if let Some(from_location) = constraint.locations.from_location() {\n+                    Either::Left(iter::once((\n+                        constraint.sup,\n+                        constraint.sub,\n+                        location_table.mid_index(from_location),\n+                    )))\n+                } else {\n+                    Either::Right(location_table.all_points().map(move |location| {\n+                       (constraint.sup, constraint.sub, location)\n+                    }))\n+                }\n+            })\n+        );\n+    }\n+}\n+\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n@@ -377,14 +393,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n-        if let Err(terr) = self.cx\n-            .eq_types(\n-                constant.literal.ty,\n-                constant.ty,\n-                location.to_locations(),\n-                ConstraintCategory::Boring,\n-            )\n-        {\n+        if let Err(terr) = self.cx.eq_types(\n+            constant.literal.ty,\n+            constant.ty,\n+            location.to_locations(),\n+            ConstraintCategory::Boring,\n+        ) {\n             span_mirbug!(\n                 self,\n                 constant,\n@@ -429,12 +443,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(\n-                    ty,\n-                    sty,\n-                    location.to_locations(),\n-                    ConstraintCategory::Boring,\n-                ) {\n+                if let Err(terr) =\n+                    self.cx\n+                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n+                {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -693,7 +705,7 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     last_span: Span,\n     mir: &'a Mir<'tcx>,\n     mir_def_id: DefId,\n-    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n@@ -802,7 +814,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &'a Mir<'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n-        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n         universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n@@ -861,15 +873,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx.tcx,\n                 borrowck_context.universal_regions,\n-                borrowck_context.location_table,\n                 self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n                 locations,\n                 category,\n                 &mut borrowck_context.constraints.outlives_constraints,\n                 &mut borrowck_context.constraints.type_tests,\n-                &mut borrowck_context.all_facts,\n             ).convert_all(&data);\n         }\n     }\n@@ -955,66 +965,55 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let parent_def_id = infcx.tcx.closure_base_def_id(self.mir_def_id);\n-        let opaque_type_map =\n-            self.fully_perform_op(\n-                locations,\n-                category,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        let mut obligations = ObligationAccumulator::default();\n-\n-                        let dummy_body_id = ObligationCause::dummy().body_id;\n-                        let (output_ty, opaque_type_map) =\n-                            obligations.add(infcx.instantiate_opaque_types(\n-                                parent_def_id,\n-                                dummy_body_id,\n-                                param_env,\n-                                &anon_ty,\n-                            ));\n+        let opaque_type_map = self.fully_perform_op(\n+            locations,\n+            category,\n+            CustomTypeOp::new(\n+                |infcx| {\n+                    let mut obligations = ObligationAccumulator::default();\n+\n+                    let dummy_body_id = ObligationCause::dummy().body_id;\n+                    let (output_ty, opaque_type_map) =\n+                        obligations.add(infcx.instantiate_opaque_types(\n+                            parent_def_id,\n+                            dummy_body_id,\n+                            param_env,\n+                            &anon_ty,\n+                        ));\n+                    debug!(\n+                        \"eq_opaque_type_and_type: \\\n+                         instantiated output_ty={:?} \\\n+                         opaque_type_map={:#?} \\\n+                         revealed_ty={:?}\",\n+                        output_ty, opaque_type_map, revealed_ty\n+                    );\n+                    obligations.add(infcx\n+                        .at(&ObligationCause::dummy(), param_env)\n+                        .eq(output_ty, revealed_ty)?);\n+\n+                    for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                        let opaque_defn_ty = tcx.type_of(opaque_def_id);\n+                        let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n+                        let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n                         debug!(\n-                            \"eq_opaque_type_and_type: \\\n-                             instantiated output_ty={:?} \\\n-                             opaque_type_map={:#?} \\\n-                             revealed_ty={:?}\",\n-                            output_ty,\n-                            opaque_type_map,\n-                            revealed_ty\n+                            \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty, opaque_defn_ty\n                         );\n-                        obligations.add(\n-                            infcx\n-                                .at(&ObligationCause::dummy(), param_env)\n-                                .eq(output_ty, revealed_ty)?,\n-                        );\n-\n-                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                            let opaque_defn_ty = renumber::renumber_regions(\n-                                infcx,\n-                                &opaque_defn_ty,\n-                            );\n-                            debug!(\n-                                \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n-                                opaque_decl.concrete_ty,\n-                                opaque_defn_ty\n-                            );\n-                            obligations.add(\n-                                infcx\n-                                    .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n-                            );\n-                        }\n+                        obligations.add(infcx\n+                            .at(&ObligationCause::dummy(), param_env)\n+                            .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                    }\n \n-                        debug!(\"eq_opaque_type_and_type: equated\");\n+                    debug!(\"eq_opaque_type_and_type: equated\");\n \n-                        Ok(InferOk {\n-                            value: Some(opaque_type_map),\n-                            obligations: obligations.into_vec(),\n-                        })\n-                    },\n-                    || \"input_output\".to_string(),\n-                ),\n-            )?;\n+                    Ok(InferOk {\n+                        value: Some(opaque_type_map),\n+                        obligations: obligations.into_vec(),\n+                    })\n+                },\n+                || \"input_output\".to_string(),\n+            ),\n+        )?;\n \n         let universal_region_relations = match self.universal_region_relations {\n             Some(rel) => rel,\n@@ -1035,7 +1034,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             infcx.constrain_opaque_type(\n                                 opaque_def_id,\n                                 &opaque_decl,\n-                                universal_region_relations\n+                                universal_region_relations,\n                             );\n                             Ok(InferOk {\n                                 value: (),\n@@ -1073,12 +1072,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types_or_anon(\n-                    rv_ty,\n-                    place_ty,\n-                    location.to_locations(),\n-                    category,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n+                {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1117,7 +1113,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.prove_trait_ref(\n                         trait_ref,\n                         location.to_locations(),\n-                    ConstraintCategory::SizedBound,\n+                        ConstraintCategory::SizedBound,\n                     );\n                 }\n             }\n@@ -1148,15 +1144,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) =\n-                    self.relate_type_and_user_type(\n-                        place_ty,\n-                        variance,\n-                        c_ty,\n-                        Locations::All(stmt.source_info.span),\n-                        ConstraintCategory::TypeAnnotation,\n-                    )\n-                {\n+                if let Err(terr) = self.relate_type_and_user_type(\n+                    place_ty,\n+                    variance,\n+                    c_ty,\n+                    Locations::All(stmt.source_info.span),\n+                    ConstraintCategory::TypeAnnotation,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1208,12 +1202,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = term_location.to_locations();\n-                if let Err(terr) = self.sub_types(\n-                    rv_ty,\n-                    place_ty,\n-                    locations,\n-                    ConstraintCategory::Assignment,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n+                {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1327,8 +1318,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ty,\n                             term_location.to_locations(),\n                             ConstraintCategory::Return,\n-                        )\n-                        {\n+                        ) {\n                             span_mirbug!(\n                                 self,\n                                 term,\n@@ -1366,12 +1356,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types_or_anon(\n-                    sig.output(),\n-                    dest_ty,\n-                    locations,\n-                    category,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n+                {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1539,12 +1526,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-        local: Local,\n-        local_decl: &LocalDecl<'tcx>,\n-    ) {\n+    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1713,13 +1695,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1739,13 +1721,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1768,13 +1750,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1957,14 +1939,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                 category: ConstraintCategory::Boring,\n                             });\n \n-                            if let Some(all_facts) = all_facts {\n-                                all_facts.outlives.push((\n-                                    ref_region.to_region_vid(),\n-                                    borrow_region.to_region_vid(),\n-                                    location_table.mid_index(location),\n-                                ));\n-                            }\n-\n                             match mutbl {\n                                 hir::Mutability::MutImmutable => {\n                                     // Immutable reference. We don't need the base\n@@ -2232,7 +2206,7 @@ impl MirPass for TypeckMir {\n                 def_id,\n                 param_env,\n                 mir,\n-                &[],\n+                &vec![],\n                 None,\n                 None,\n                 None,\n@@ -2277,4 +2251,3 @@ impl<'tcx> ObligationAccumulator<'tcx> {\n         self.obligations\n     }\n }\n-"}, {"sha": "13d59c3ba29c6707f52a3f2bbe7129dbc7252667", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 191, "deletions": 129, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -10,15 +10,13 @@\n \n use borrow_check::nll::constraints::{ConstraintCategory, OutlivesConstraint};\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::ToRegionVid;\n use rustc::infer::canonical::{Canonical, CanonicalVarInfos};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::traits::query::Fallible;\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::Kind;\n-use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, CanonicalTy, CanonicalVar, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n@@ -33,11 +31,9 @@ pub(super) fn sub_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx,\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Covariant,\n-        locations,\n-        category,\n-        borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n@@ -54,11 +50,9 @@ pub(super) fn eq_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx,\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Invariant,\n-        locations,\n-        category,\n-        borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n@@ -91,18 +85,22 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     let v1 = ty::Contravariant.xform(v);\n \n     TypeRelating::new(\n-        infcx,\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v1,\n-        locations,\n-        category,\n-        borrowck_context,\n         b_variables,\n     ).relate(&b_value, &a)?;\n     Ok(())\n }\n \n-struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    /// Callback to use when we deduce an outlives relationship\n+    delegate: D,\n \n     /// How are we relating `a` and `b`?\n     ///\n@@ -122,19 +120,10 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     ///\n     /// This field stores the instantiations for late-bound regions in\n     /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope>,\n+    a_scopes: Vec<BoundRegionScope<'tcx>>,\n \n     /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope>,\n-\n-    /// Where (and why) is this relation taking place?\n-    locations: Locations,\n-\n-    category: ConstraintCategory,\n-\n-    /// This will be `Some` when we are running the type check as part\n-    /// of NLL, and `None` if we are running a \"sanity check\".\n-    borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n+    b_scopes: Vec<BoundRegionScope<'tcx>>,\n \n     /// As we execute, the type on the LHS *may* come from a canonical\n     /// source. In that case, we will sometimes find a constraint like\n@@ -150,37 +139,128 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n+trait TypeRelatingDelegate<'tcx> {\n+    /// Push a constraint `sup: sub` -- this constraint must be\n+    /// satisfied for the two types to be related. `sub` and `sup` may\n+    /// be regions from the type or new variables created through the\n+    /// delegate.\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+\n+    /// Creates a new region variable representing an instantiated\n+    /// higher-ranked region; this will be either existential or\n+    /// universal depending on the context.  So e.g. if you have\n+    /// `for<'a> fn(..) <: for<'b> fn(..)`, then we will first\n+    /// instantiate `'b` with a universally quantitifed region and\n+    /// then `'a` with an existentially quantified region (the order\n+    /// is important so that the existential region `'a` can see the\n+    /// universal one).\n+    fn next_region_var(\n+        &mut self,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> ty::Region<'tcx>;\n+\n+    /// Creates a new existential region in the given universe. This\n+    /// is used when handling subtyping and type variables -- if we\n+    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n+    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n+    /// existential variable created by this function. We would then\n+    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n+    /// relation stating that `'?0: 'a`).\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+}\n+\n+struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+\n+    /// Where (and why) is this relation taking place?\n+    locations: Locations,\n+\n+    /// What category do we assign the resulting `'a: 'b` relationships?\n+    category: ConstraintCategory,\n+}\n+\n+impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            borrowck_context,\n+            locations,\n+            category,\n+        }\n+    }\n+}\n+\n+impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n+    fn next_region_var(\n+        &mut self,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> ty::Region<'tcx> {\n+        let origin = if universally_quantified.0 {\n+            NLLRegionVariableOrigin::BoundRegion(self.infcx.create_subuniverse())\n+        } else {\n+            NLLRegionVariableOrigin::Existential\n+        };\n+        self.infcx.next_nll_region_var(origin)\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, universe)\n+    }\n+\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            let sub = borrowck_context.universal_regions.to_region_vid(sub);\n+            let sup = borrowck_context.universal_regions.to_region_vid(sup);\n+            borrowck_context\n+                .constraints\n+                .outlives_constraints\n+                .push(OutlivesConstraint {\n+                    sup,\n+                    sub,\n+                    locations: self.locations,\n+                    category: self.category,\n+                });\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n struct ScopesAndKind<'tcx> {\n-    scopes: Vec<BoundRegionScope>,\n+    scopes: Vec<BoundRegionScope<'tcx>>,\n     kind: Kind<'tcx>,\n }\n \n #[derive(Clone, Debug, Default)]\n-struct BoundRegionScope {\n-    map: FxHashMap<ty::BoundRegion, RegionVid>,\n+struct BoundRegionScope<'tcx> {\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n }\n \n #[derive(Copy, Clone)]\n struct UniversallyQuantified(bool);\n \n-impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n+impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn new(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+        delegate: D,\n         ambient_variance: ty::Variance,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-        borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n         canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n         let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n         Self {\n-            infcx,\n+            tcx,\n+            delegate,\n             ambient_variance,\n-            borrowck_context,\n-            locations,\n             canonical_var_values,\n-            category,\n             a_scopes: vec![],\n             b_scopes: vec![],\n         }\n@@ -204,10 +284,10 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         &mut self,\n         value: &ty::Binder<impl TypeFoldable<'tcx>>,\n         universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope {\n+    ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n         value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            infcx: self.infcx,\n+            delegate: &mut self.delegate,\n             target_index: ty::INNERMOST,\n             universally_quantified,\n             bound_region_scope: &mut scope,\n@@ -227,8 +307,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         debruijn: ty::DebruijnIndex,\n         br: &ty::BoundRegion,\n         first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope],\n-    ) -> RegionVid {\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n         // The debruijn index is a \"reverse index\" into the\n         // scopes listing. So when we have INNERMOST (0), we\n         // want the *last* scope pushed, and so forth.\n@@ -245,40 +325,23 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     /// with. Otherwise just return `r`.\n     fn replace_bound_region(\n         &self,\n-        universal_regions: &UniversalRegions<'tcx>,\n         r: ty::Region<'tcx>,\n         first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope],\n-    ) -> RegionVid {\n-        match r {\n-            ty::ReLateBound(debruijn, br) => {\n-                Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n-            }\n-\n-            ty::ReVar(v) => *v,\n-\n-            _ => universal_regions.to_region_vid(r),\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n+        if let ty::ReLateBound(debruijn, br) = r {\n+            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n+        } else {\n+            r\n         }\n     }\n \n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n-    fn push_outlives(&mut self, sup: RegionVid, sub: RegionVid) {\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n-        if let Some(borrowck_context) = &mut self.borrowck_context {\n-            borrowck_context\n-                .constraints\n-                .outlives_constraints\n-                .push(OutlivesConstraint {\n-                    sup,\n-                    sub,\n-                    locations: self.locations,\n-                    category: self.category,\n-                });\n-\n-            // FIXME all facts!\n-        }\n+        self.delegate.push_outlives(sup, sub);\n     }\n \n     /// When we encounter a canonical variable `var` in the output,\n@@ -316,12 +379,10 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         return result;\n     }\n \n-    fn generalize_value(\n-        &self,\n-        kind: Kind<'tcx>,\n-    ) -> Kind<'tcx> {\n+    fn generalize_value(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n         TypeGeneralizer {\n-            type_rel: self,\n+            tcx: self.tcx,\n+            delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n \n@@ -333,11 +394,12 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n-    for TypeRelating<'cx, 'bccx, 'gcx, 'tcx>\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n-        self.infcx.tcx\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -397,37 +459,30 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        if let Some(&mut BorrowCheckContext {\n-            universal_regions, ..\n-        }) = self.borrowck_context\n-        {\n-            if let ty::ReCanonical(var) = a {\n-                self.relate_var(*var, b.into())?;\n-                return Ok(a);\n-            }\n+        if let ty::ReCanonical(var) = a {\n+            self.relate_var(*var, b.into())?;\n+            return Ok(a);\n+        }\n \n-            debug!(\n-                \"regions(a={:?}, b={:?}, variance={:?})\",\n-                a, b, self.ambient_variance\n-            );\n+        debug!(\n+            \"regions(a={:?}, b={:?}, variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n \n-            let v_a =\n-                self.replace_bound_region(universal_regions, a, ty::INNERMOST, &self.a_scopes);\n-            let v_b =\n-                self.replace_bound_region(universal_regions, b, ty::INNERMOST, &self.b_scopes);\n+        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n+        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n \n-            debug!(\"regions: v_a = {:?}\", v_a);\n-            debug!(\"regions: v_b = {:?}\", v_b);\n+        debug!(\"regions: v_a = {:?}\", v_a);\n+        debug!(\"regions: v_b = {:?}\", v_b);\n \n-            if self.ambient_covariance() {\n-                // Covariance: a <= b. Hence, `b: a`.\n-                self.push_outlives(v_b, v_a);\n-            }\n+        if self.ambient_covariance() {\n+            // Covariance: a <= b. Hence, `b: a`.\n+            self.push_outlives(v_b, v_a);\n+        }\n \n-            if self.ambient_contravariance() {\n-                // Contravariant: b <= a. Hence, `a: b`.\n-                self.push_outlives(v_a, v_b);\n-            }\n+        if self.ambient_contravariance() {\n+            // Contravariant: b <= a. Hence, `a: b`.\n+            self.push_outlives(v_a, v_b);\n         }\n \n         Ok(a)\n@@ -527,10 +582,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n \n             // Reset ambient variance to contravariance. See the\n             // covariant case above for an explanation.\n-            let variance = ::std::mem::replace(\n-                &mut self.ambient_variance,\n-                ty::Variance::Contravariant,\n-            );\n+            let variance =\n+                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n@@ -551,15 +604,21 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct ScopeInstantiator<'me, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    delegate: &'me mut D,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n     universally_quantified: UniversallyQuantified,\n-    bound_region_scope: &'cx mut BoundRegionScope,\n+    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n+impl<'me, 'tcx, D> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -570,21 +629,18 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let ScopeInstantiator {\n-            infcx,\n             universally_quantified,\n+            bound_region_scope,\n+            delegate,\n             ..\n-        } = *self;\n+        } = self;\n \n         match r {\n             ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n-                self.bound_region_scope.map.entry(*br).or_insert_with(|| {\n-                    let origin = if universally_quantified.0 {\n-                        NLLRegionVariableOrigin::BoundRegion(infcx.create_subuniverse())\n-                    } else {\n-                        NLLRegionVariableOrigin::Existential\n-                    };\n-                    infcx.next_nll_region_var(origin).to_region_vid()\n-                });\n+                bound_region_scope\n+                    .map\n+                    .entry(*br)\n+                    .or_insert_with(|| delegate.next_region_var(*universally_quantified));\n             }\n \n             _ => {}\n@@ -613,8 +669,13 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n /// scopes.\n ///\n /// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    delegate: &'me mut D,\n \n     /// After we generalize this type, we are going to relative it to\n     /// some other type. What will be the variance at this point?\n@@ -625,9 +686,12 @@ struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     universe: ty::UniverseIndex,\n }\n \n-impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.type_rel.infcx.tcx\n+        self.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -710,9 +774,7 @@ impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n         // though, we may however need to check well-formedness or\n         // risk a problem like #41677 again.\n \n-        let replacement_region_vid = self.type_rel\n-            .infcx\n-            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, self.universe);\n+        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n \n         Ok(replacement_region_vid)\n     }"}, {"sha": "619ebb1675ca6155520b6d6ab544fb6f367d204e", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> CFG<'tcx> {\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n             source_info,\n-            kind: StatementKind::Assign(place.clone(), rvalue)\n+            kind: StatementKind::Assign(place.clone(), box rvalue)\n         });\n     }\n "}, {"sha": "32f09599ace82fd2e04913a1afa99d3989f8e3b3", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -143,11 +143,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let outputs = outputs\n                     .into_iter()\n                     .map(|output| unpack!(block = this.as_place(block, output)))\n-                    .collect();\n+                    .collect::<Vec<_>>()\n+                    .into_boxed_slice();\n                 let inputs = inputs\n                     .into_iter()\n                     .map(|input| unpack!(block = this.as_local_operand(block, input)))\n-                    .collect();\n+                    .collect::<Vec<_>>()\n+                    .into_boxed_slice();\n                 this.cfg.push(\n                     block,\n                     Statement {"}, {"sha": "caf87fdd5ccce675403f0ceda38d2b8ca609fb3d", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // re-consider the current implementations of the\n                 // propagate_call_return method.\n \n-                if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n+                if let mir::Rvalue::Ref(region, _, ref place) = **rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.mir,"}, {"sha": "2884b15ca47db2bdce009f5380b9d83c81861039", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -290,7 +290,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                         self.gather_init(output, InitKind::Deep);\n                     }\n                 }\n-                for input in inputs {\n+                for input in inputs.iter() {\n                     self.gather_operand(input);\n                 }\n             }"}, {"sha": "6187e091319e0f03fcd44ce8b2a3ed2fe62ce40f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -539,7 +539,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                 .emit();\n         } else if has_guard && !cx.tcx.allow_bind_by_move_patterns_with_guards() {\n             let mut err = struct_span_err!(cx.tcx.sess, p.span, E0008,\n-                                       \"cannot bind by-move into a pattern guard\");\n+                                           \"cannot bind by-move into a pattern guard\");\n             err.span_label(p.span, \"moves value into pattern guard\");\n             if cx.tcx.sess.opts.unstable_features.is_nightly_build() && cx.tcx.use_mir_borrowck() {\n                 err.help(\"add #![feature(bind_by_move_pattern_guards)] to the \\"}, {"sha": "fef2f916b415667652fbf123527509fd40d5257a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         rval: OpTy<'tcx>,\n     ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n-        if rval.layout.abi.is_uninhabited() {\n+        if rval.layout.abi == layout::Abi::Uninhabited {\n             return err!(Unreachable);\n         }\n "}, {"sha": "7ba72366af73630907c228f317ae50594513d21a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 Place::Local(RETURN_PLACE),\n-                Rvalue::Use(Operand::Copy(rcvr))\n+                box Rvalue::Use(Operand::Copy(rcvr))\n             )\n         );\n         self.block(vec![ret_statement], TerminatorKind::Return, false);\n@@ -458,7 +458,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let statement = self.make_statement(\n             StatementKind::Assign(\n                 ref_loc.clone(),\n-                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, src)\n+                box Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, src)\n             )\n         );\n \n@@ -485,7 +485,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let compute_cond = self.make_statement(\n             StatementKind::Assign(\n                 cond.clone(),\n-                Rvalue::BinaryOp(BinOp::Ne, Operand::Copy(end), Operand::Copy(beg))\n+                box Rvalue::BinaryOp(BinOp::Ne, Operand::Copy(end), Operand::Copy(beg))\n             )\n         );\n \n@@ -521,13 +521,13 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             self.make_statement(\n                 StatementKind::Assign(\n                     Place::Local(beg),\n-                    Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                    box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n                 )\n             ),\n             self.make_statement(\n                 StatementKind::Assign(\n                     end.clone(),\n-                    Rvalue::Use(Operand::Constant(self.make_usize(len)))\n+                    box Rvalue::Use(Operand::Constant(self.make_usize(len)))\n                 )\n             )\n         ];\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             self.make_statement(\n                 StatementKind::Assign(\n                     Place::Local(beg),\n-                    Rvalue::BinaryOp(\n+                    box Rvalue::BinaryOp(\n                         BinOp::Add,\n                         Operand::Copy(Place::Local(beg)),\n                         Operand::Constant(self.make_usize(1))\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let init = self.make_statement(\n             StatementKind::Assign(\n                 Place::Local(beg),\n-                Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n             )\n         );\n         self.block(vec![init], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let statement = self.make_statement(\n             StatementKind::Assign(\n                 Place::Local(beg),\n-                Rvalue::BinaryOp(\n+                box Rvalue::BinaryOp(\n                     BinOp::Add,\n                     Operand::Copy(Place::Local(beg)),\n                     Operand::Constant(self.make_usize(1))\n@@ -715,7 +715,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 source_info,\n                 kind: StatementKind::Assign(\n                     Place::Local(ref_rcvr),\n-                    Rvalue::Ref(tcx.types.re_erased, borrow_kind, rcvr_l)\n+                    box Rvalue::Ref(tcx.types.re_erased, borrow_kind, rcvr_l)\n                 )\n             });\n             Operand::Move(Place::Local(ref_rcvr))\n@@ -851,7 +851,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n             source_info,\n             kind: StatementKind::Assign(\n                 Place::Local(RETURN_PLACE),\n-                Rvalue::Aggregate(\n+                box Rvalue::Aggregate(\n                     box AggregateKind::Adt(adt_def, variant_no, substs, None, None),\n                     (1..sig.inputs().len()+1).map(|i| {\n                         Operand::Move(Place::Local(Local::new(i)))"}, {"sha": "5b489b5db942b1916db954bb776b7faa486cbd04", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -320,12 +320,12 @@ impl MirPass for AddValidation {\n             for i in (0..block_data.statements.len()).rev() {\n                 match block_data.statements[i].kind {\n                     // When the borrow of this ref expires, we need to recover validation.\n-                    StatementKind::Assign(_, Rvalue::Ref(_, _, _)) => {\n+                    StatementKind::Assign(_, box Rvalue::Ref(_, _, _)) => {\n                         // Due to a lack of NLL; we can't capture anything directly here.\n                         // Instead, we have to re-match and clone there.\n                         let (dest_place, re, src_place) = match block_data.statements[i].kind {\n                             StatementKind::Assign(ref dest_place,\n-                                                  Rvalue::Ref(re, _, ref src_place)) => {\n+                                                  box Rvalue::Ref(re, _, ref src_place)) => {\n                                 (dest_place.clone(), re, src_place.clone())\n                             },\n                             _ => bug!(\"We already matched this.\"),\n@@ -354,17 +354,17 @@ impl MirPass for AddValidation {\n                         block_data.statements.insert(i, release_stmt);\n                     }\n                     // Casts can change what validation does (e.g. unsizing)\n-                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Copy(_), _)) |\n-                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Move(_), _))\n+                    StatementKind::Assign(_, box Rvalue::Cast(kind, Operand::Copy(_), _)) |\n+                    StatementKind::Assign(_, box Rvalue::Cast(kind, Operand::Move(_), _))\n                         if kind != CastKind::Misc =>\n                     {\n                         // Due to a lack of NLL; we can't capture anything directly here.\n                         // Instead, we have to re-match and clone there.\n                         let (dest_place, src_place) = match block_data.statements[i].kind {\n                             StatementKind::Assign(ref dest_place,\n-                                    Rvalue::Cast(_, Operand::Copy(ref src_place), _)) |\n+                                    box Rvalue::Cast(_, Operand::Copy(ref src_place), _)) |\n                             StatementKind::Assign(ref dest_place,\n-                                    Rvalue::Cast(_, Operand::Move(ref src_place), _)) =>\n+                                    box Rvalue::Cast(_, Operand::Move(ref src_place), _)) =>\n                             {\n                                 (dest_place.clone(), src_place.clone())\n                             },"}, {"sha": "6d0b25b2c694041bb3336e4ae99d086626536624", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -104,7 +104,7 @@ impl MirPass for CopyPropagation {\n \n                     // That use of the source must be an assignment.\n                     match statement.kind {\n-                        StatementKind::Assign(Place::Local(local), Rvalue::Use(ref operand)) if\n+                        StatementKind::Assign(Place::Local(local), box Rvalue::Use(ref operand)) if\n                                 local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Copy(ref src_place) |\n@@ -155,11 +155,11 @@ fn eliminate_self_assignments<'tcx>(\n                 match stmt.kind {\n                     StatementKind::Assign(\n                         Place::Local(local),\n-                        Rvalue::Use(Operand::Copy(Place::Local(src_local))),\n+                        box Rvalue::Use(Operand::Copy(Place::Local(src_local))),\n                     ) |\n                     StatementKind::Assign(\n                         Place::Local(local),\n-                        Rvalue::Use(Operand::Move(Place::Local(src_local))),\n+                        box Rvalue::Use(Operand::Move(Place::Local(src_local))),\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n                         continue;"}, {"sha": "8a14890f92e1e7be7d29980dd7aa2f1a956c38ed", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -26,7 +26,7 @@ impl MirPass for Deaggregator {\n             bb.expand_statements(|stmt| {\n                 // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n                 if let StatementKind::Assign(_, ref rhs) = stmt.kind {\n-                    if let Rvalue::Aggregate(ref kind, _) = *rhs {\n+                    if let Rvalue::Aggregate(ref kind, _) = **rhs {\n                         // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n                         if let AggregateKind::Array(_) = **kind {\n                             return None;\n@@ -41,8 +41,12 @@ impl MirPass for Deaggregator {\n                 let stmt = stmt.replace_nop();\n                 let source_info = stmt.source_info;\n                 let (mut lhs, kind, operands) = match stmt.kind {\n-                    StatementKind::Assign(lhs, Rvalue::Aggregate(kind, operands))\n-                        => (lhs, kind, operands),\n+                    StatementKind::Assign(lhs, box rvalue) => {\n+                        match rvalue {\n+                            Rvalue::Aggregate(kind, operands) => (lhs, kind, operands),\n+                            _ => bug!()\n+                        }\n+                    }\n                     _ => bug!()\n                 };\n \n@@ -82,7 +86,7 @@ impl MirPass for Deaggregator {\n                     };\n                     Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(lhs_field, Rvalue::Use(op)),\n+                        kind: StatementKind::Assign(lhs_field, box Rvalue::Use(op)),\n                     }\n                 }).chain(set_discriminant))\n             });"}, {"sha": "9d77289d7b9b172d64377269d4278498b58bc694", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -478,7 +478,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n-            kind: StatementKind::Assign(location.clone(), Rvalue::Use(value.clone())),\n+            kind: StatementKind::Assign(location.clone(), box Rvalue::Use(value.clone())),\n             source_info: terminator.source_info\n         };\n "}, {"sha": "62adbf1bdf7db91961c16001f7b3fc30213644cd", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n         });\n         Statement {\n             source_info,\n-            kind: StatementKind::Assign(state, Rvalue::Use(val)),\n+            kind: StatementKind::Assign(state, box Rvalue::Use(val)),\n         }\n     }\n }\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             data.statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(Place::Local(RETURN_PLACE),\n-                    self.make_state(state_idx, v)),\n+                                            box self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n                 let state = 3 + self.suspension_points.len() as u32;"}, {"sha": "040ee35632cbba871067e03fbbb19e32a97cefa9", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -447,7 +447,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                     let stmt = Statement {\n                         source_info: callsite.location,\n-                        kind: StatementKind::Assign(tmp.clone(), dest)\n+                        kind: StatementKind::Assign(tmp.clone(), box dest)\n                     };\n                     caller_mir[callsite.bb]\n                         .statements.push(stmt);\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let stmt = Statement {\n             source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::Local(arg_tmp), arg),\n+            kind: StatementKind::Assign(Place::Local(arg_tmp), box arg),\n         };\n         caller_mir[callsite.bb].statements.push(stmt);\n         arg_tmp"}, {"sha": "b2ddbe04d755f7073f79fa3e090f25fd6b325dd3", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -79,11 +79,14 @@ impl Lower128Bit {\n                 let bin_statement = block.statements.pop().unwrap();\n                 let source_info = bin_statement.source_info;\n                 let (place, lhs, mut rhs) = match bin_statement.kind {\n-                    StatementKind::Assign(place, Rvalue::BinaryOp(_, lhs, rhs))\n-                    | StatementKind::Assign(place, Rvalue::CheckedBinaryOp(_, lhs, rhs)) => {\n-                        (place, lhs, rhs)\n+                    StatementKind::Assign(place, box rvalue) => {\n+                        match rvalue {\n+                            Rvalue::BinaryOp(_, lhs, rhs)\n+                            | Rvalue::CheckedBinaryOp(_, lhs, rhs) => (place, lhs, rhs),\n+                            _ => bug!(),\n+                        }\n                     }\n-                    _ => bug!(\"Statement doesn't match pattern any more?\"),\n+                    _ => bug!()\n                 };\n \n                 if let Some(local) = cast_local {\n@@ -95,7 +98,7 @@ impl Lower128Bit {\n                         source_info: source_info,\n                         kind: StatementKind::Assign(\n                             Place::Local(local),\n-                            Rvalue::Cast(\n+                            box Rvalue::Cast(\n                                 CastKind::Misc,\n                                 rhs,\n                                 rhs_override_ty.unwrap())),\n@@ -154,13 +157,13 @@ fn lower_to<'a, 'tcx, D>(statement: &Statement<'tcx>, local_decls: &D, tcx: TyCt\n     where D: HasLocalDecls<'tcx>\n {\n     match statement.kind {\n-        StatementKind::Assign(_, Rvalue::BinaryOp(bin_op, ref lhs, _)) => {\n+        StatementKind::Assign(_, box Rvalue::BinaryOp(bin_op, ref lhs, _)) => {\n             let ty = lhs.ty(local_decls, tcx);\n             if let Some(is_signed) = sign_of_128bit(ty) {\n                 return item_for_op(bin_op, is_signed);\n             }\n         },\n-        StatementKind::Assign(_, Rvalue::CheckedBinaryOp(bin_op, ref lhs, _)) => {\n+        StatementKind::Assign(_, box Rvalue::CheckedBinaryOp(bin_op, ref lhs, _)) => {\n             let ty = lhs.ty(local_decls, tcx);\n             if let Some(is_signed) = sign_of_128bit(ty) {\n                 return item_for_checked_op(bin_op, is_signed);"}, {"sha": "34339b0634194906755684650f0942deb6a91f88", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            kind: StatementKind::Assign(Place::Local(dest), rvalue)\n+            kind: StatementKind::Assign(Place::Local(dest), box rvalue)\n         });\n     }\n \n@@ -217,7 +217,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n         if loc.statement_index < no_stmts {\n-            let (mut rvalue, source_info) = {\n+            let (rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n                 let rhs = match statement.kind {\n                     StatementKind::Assign(_, ref mut rhs) => rhs,\n@@ -230,11 +230,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 (if self.keep_original {\n                     rhs.clone()\n                 } else {\n-                    let unit = Rvalue::Aggregate(box AggregateKind::Tuple, vec![]);\n+                    let unit = box Rvalue::Aggregate(box AggregateKind::Tuple, vec![]);\n                     mem::replace(rhs, unit)\n                 }, statement.source_info)\n             };\n \n+            let mut rvalue = *rvalue;\n             self.visit_rvalue(&mut rvalue, loc);\n             self.assign(new_temp, rvalue, source_info.span);\n         } else {\n@@ -301,7 +302,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(_, Rvalue::Ref(_, _, ref mut place)) => {\n+                        StatementKind::Assign(_, box Rvalue::Ref(_, _, ref mut place)) => {\n                             // Find the underlying local for this (necessarily interior) borrow.\n                             // HACK(eddyb) using a recursive function because of mutable borrows.\n                             fn interior_base<'a, 'tcx>(place: &'a mut Place<'tcx>)"}, {"sha": "a6e2cad509408cf2309f27263f0ecdae6ecc42b0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             match *candidate {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     match self.mir[bb].statements[stmt_idx].kind {\n-                        StatementKind::Assign(_, Rvalue::Ref(_, _, Place::Local(index))) => {\n+                        StatementKind::Assign(_, box Rvalue::Ref(_, _, Place::Local(index))) => {\n                             promoted_temps.insert(index);\n                         }\n                         _ => {}"}, {"sha": "98420115d75d73afae9ee9bdd9b4913be9d563f3", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -15,7 +15,7 @@ pub fn is_min_const_fn(\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n-        for predicate in &predicates.predicates {\n+        for (predicate, _) in &predicates.predicates {\n             match predicate {\n                 | Predicate::RegionOutlives(_)\n                 | Predicate::TypeOutlives(_)"}, {"sha": "4b4b284b02cd575a7a80bcd9420524bb8b0d3bd6", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -60,7 +60,7 @@ impl RemoveNoopLandingPads {\n                     // instructions, but this should all run after borrowck).\n                 }\n \n-                StatementKind::Assign(Place::Local(_), Rvalue::Use(_)) => {\n+                StatementKind::Assign(Place::Local(_), box Rvalue::Use(_)) => {\n                     // Writing to a local (e.g. a drop flag) does not\n                     // turn a landing pad to a non-nop\n                 }"}, {"sha": "05044574e5ca3a4f1485edacf093d1eff821d41d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -171,7 +171,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         if place == peek_arg_place {\n-            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = *rvalue {\n+            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = **rvalue {\n                 // Okay, our search is over.\n                 match move_data.rev_lookup.find(peeking_at_place) {\n                     LookupResult::Exact(peek_mpi) => {"}, {"sha": "b123a846596e593802a3249116e884ac3bfccc4d", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -184,7 +184,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n             for candidate in &visitor.candidates {\n                 let statement = &mir[candidate.block].statements[candidate.statement_index];\n                 if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n-                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n+                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = **rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n                             if let Operand::Move(Place::Local(local)) = item {\n                                 let local_use = &visitor.locals_use[*local];\n@@ -268,7 +268,7 @@ impl RestoreSubsliceArrayMoveOut {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n                     Place::Local(_),\n-                    Rvalue::Use(Operand::Move(Place::Projection(box PlaceProjection{\n+                    box Rvalue::Use(Operand::Move(Place::Projection(box PlaceProjection{\n                         ref base, elem: ProjectionElem::ConstantIndex{\n                             offset, min_length: _, from_end: false}})))) = statement.kind {\n                     return Some((offset, base))"}, {"sha": "9b8165181cc1d04687252913b5425464e6c32e10", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -977,7 +977,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn assign(&self, lhs: &Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n         Statement {\n             source_info: self.source_info,\n-            kind: StatementKind::Assign(lhs.clone(), rhs)\n+            kind: StatementKind::Assign(lhs.clone(), box rhs)\n         }\n     }\n }"}, {"sha": "807c8386693f8829bbc050d89a51a2345f6b81ea", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn add_assign(&mut self, loc: Location, place: Place<'tcx>, rv: Rvalue<'tcx>) {\n-        self.add_statement(loc, StatementKind::Assign(place, rv));\n+        self.add_statement(loc, StatementKind::Assign(place, box rv));\n     }\n \n     pub fn make_nop(&mut self, loc: Location) {"}, {"sha": "1fe370b44c5bcf33cbb4ac52254b50eb78a6be8a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -434,7 +434,7 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n \n     fn predicates(&mut self) -> &mut Self {\n         let predicates = self.ev.tcx.predicates_of(self.item_def_id);\n-        for predicate in &predicates.predicates {\n+        for (predicate, _) in &predicates.predicates {\n             predicate.visit_with(self);\n             match predicate {\n                 &ty::Predicate::Trait(poly_predicate) => {\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             if self.check_trait_ref(*principal.skip_binder()) {\n                 return;\n             }\n-            for poly_predicate in projections {\n+            for (poly_predicate, _) in projections {\n                 let tcx = self.tcx;\n                 if self.check_trait_ref(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n                     return;\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ty::Opaque(def_id, ..) => {\n-                for predicate in &self.tcx.predicates_of(def_id).predicates {\n+                for (predicate, _) in &self.tcx.predicates_of(def_id).predicates {\n                     let trait_ref = match *predicate {\n                         ty::Predicate::Trait(ref poly_trait_predicate) => {\n                             Some(poly_trait_predicate.skip_binder().trait_ref)\n@@ -1387,7 +1387,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         // for the inferred outlives rules; see\n         // `src/test/ui/rfc-2093-infer-outlives/privacy.rs`.\n         let predicates = self.tcx.explicit_predicates_of(self.item_def_id);\n-        for predicate in &predicates.predicates {\n+        for (predicate, _) in &predicates.predicates {\n             predicate.visit_with(self);\n             match predicate {\n                 &ty::Predicate::Trait(poly_predicate) => {"}, {"sha": "5e3f7470099117c806abfd11e5eba77ee59fe066", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -42,8 +42,9 @@ use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::session::config::nightly_options;\n+use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use rustc_metadata::creader::CrateLoader;\n@@ -1381,6 +1382,9 @@ pub struct Resolver<'a, 'b: 'a> {\n     /// The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n \n+    /// The current self item if inside an ADT (used for better errors).\n+    current_self_item: Option<NodeId>,\n+\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n@@ -1710,6 +1714,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             current_trait_ref: None,\n             current_self_type: None,\n+            current_self_item: None,\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n@@ -2186,15 +2191,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n-        self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n-            let item_def_id = this.definitions.local_def_id(item.id);\n-            if this.session.features_untracked().self_in_typedefs {\n-                this.with_self_rib(Def::SelfTy(None, Some(item_def_id)), |this| {\n+        self.with_current_self_item(item, |this| {\n+            this.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+                let item_def_id = this.definitions.local_def_id(item.id);\n+                if this.session.features_untracked().self_in_typedefs {\n+                    this.with_self_rib(Def::SelfTy(None, Some(item_def_id)), |this| {\n+                        visit::walk_item(this, item);\n+                    });\n+                } else {\n                     visit::walk_item(this, item);\n-                });\n-            } else {\n-                visit::walk_item(this, item);\n-            }\n+                }\n+            });\n         });\n     }\n \n@@ -2435,6 +2442,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         result\n     }\n \n+    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n+        where F: FnOnce(&mut Resolver) -> T\n+    {\n+        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n+        let result = f(self);\n+        self.current_self_item = previous_value;\n+        result\n+    }\n+\n     /// This is called to resolve a trait reference from an `impl` (i.e. `impl Trait for Foo`)\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n@@ -3004,6 +3020,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     \"traits and impls\"\n                 };\n                 err.span_label(span, format!(\"`Self` is only available in {}\", available_in));\n+                if this.current_self_item.is_some() && nightly_options::is_nightly_build() {\n+                    err.help(\"add #![feature(self_in_typedefs)] to the crate attributes \\\n+                              to enable\");\n+                }\n                 return (err, Vec::new());\n             }\n             if is_self_value(path, ns) {"}, {"sha": "e47f89c64ff075154e85bcf8a9a7c1dc8ac4c620", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -12,6 +12,7 @@ crate-type = [\"dylib\"]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "ab8f468672944eb070864a0b9df3257badcb85be", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -25,10 +25,12 @@\n \n use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n+use rustc::session::config::Input;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n use std::path::Path;\n+use std::env;\n \n use syntax::ast::{self, Attribute, NodeId, PatKind, CRATE_NODE_ID};\n use syntax::parse::token;\n@@ -49,8 +51,8 @@ use json_dumper::{Access, DumpOutput, JsonDumper};\n use span_utils::SpanUtils;\n use sig;\n \n-use rls_data::{CratePreludeData, Def, DefKind, GlobalCrateId, Import, ImportKind, Ref, RefKind,\n-               Relation, RelationKind, SpanData};\n+use rls_data::{CompilationOptions, CratePreludeData, Def, DefKind, GlobalCrateId, Import,\n+               ImportKind, Ref, RefKind, Relation, RelationKind, SpanData};\n \n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n@@ -169,6 +171,54 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.dumper.crate_prelude(data);\n     }\n \n+    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: &str) {\n+        // Apply possible `remap-path-prefix` remapping to the input source file\n+        // (and don't include remapping args anymore)\n+        let (program, arguments) = {\n+            let remap_arg_indices = {\n+                let mut indices = FxHashSet();\n+                // Args are guaranteed to be valid UTF-8 (checked early)\n+                for (i, e) in env::args().enumerate() {\n+                    if e.starts_with(\"--remap-path-prefix=\") {\n+                        indices.insert(i);\n+                    } else if e == \"--remap-path-prefix\" {\n+                        indices.insert(i);\n+                        indices.insert(i + 1);\n+                    }\n+                }\n+                indices\n+            };\n+\n+            let mut args = env::args()\n+                .enumerate()\n+                .filter(|(i, _)| !remap_arg_indices.contains(i))\n+                .map(|(_, arg)| {\n+                    match input {\n+                        Input::File(ref path) if path == Path::new(&arg) => {\n+                            let mapped = &self.tcx.sess.local_crate_source_file;\n+                            mapped\n+                                .as_ref()\n+                                .unwrap()\n+                                .to_string_lossy()\n+                                .into()\n+                        },\n+                        _ => arg,\n+                    }\n+                });\n+\n+            (args.next().unwrap(), args.collect())\n+        };\n+\n+        let data = CompilationOptions {\n+            directory: self.tcx.sess.working_dir.0.clone(),\n+            program,\n+            arguments,\n+            output: self.save_ctxt.compilation_output(crate_name),\n+        };\n+\n+        self.dumper.compilation_opts(data);\n+    }\n+\n     // Return all non-empty prefixes of a path.\n     // For each prefix, we return the span for the last segment in the prefix and\n     // a str representation of the entire prefix."}, {"sha": "e14ac73ee10202b1eb450fdf5de59d5511f810c9", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -12,9 +12,9 @@ use std::io::Write;\n \n use rustc_serialize::json::as_json;\n \n-use rls_data::{self, Analysis, CratePreludeData, Def, DefKind, Import, MacroRef, Ref, RefKind,\n-               Relation, Impl};\n use rls_data::config::Config;\n+use rls_data::{self, Analysis, CompilationOptions, CratePreludeData, Def, DefKind, Impl, Import,\n+               MacroRef, Ref, RefKind, Relation};\n use rls_span::{Column, Row};\n \n #[derive(Debug)]\n@@ -89,6 +89,10 @@ impl<'b, O: DumpOutput + 'b> JsonDumper<O> {\n         self.result.prelude = Some(data)\n     }\n \n+    pub fn compilation_opts(&mut self, data: CompilationOptions) {\n+        self.result.compilation = Some(data);\n+    }\n+\n     pub fn macro_use(&mut self, data: MacroRef) {\n         if self.config.pub_only || self.config.reachable_only {\n             return;"}, {"sha": "f6045c7b2d2df2b1123406a40153d5e544cdd0c3", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -23,6 +23,7 @@ extern crate rustc;\n #[macro_use]\n extern crate log;\n extern crate rustc_data_structures;\n+extern crate rustc_codegen_utils;\n extern crate rustc_serialize;\n extern crate rustc_target;\n extern crate rustc_typeck;\n@@ -45,9 +46,10 @@ use rustc::hir::def::Def as HirDef;\n use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::ExternCrate;\n-use rustc::session::config::CrateType;\n+use rustc::session::config::{CrateType, Input, OutputType};\n use rustc::ty::{self, TyCtxt};\n use rustc_typeck::hir_ty_to_ty;\n+use rustc_codegen_utils::link::{filename_for_metadata, out_filename};\n \n use std::cell::Cell;\n use std::default::Default;\n@@ -110,6 +112,24 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    // Returns path to the compilation output (e.g. libfoo-12345678.rmeta)\n+    pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n+        let sess = &self.tcx.sess;\n+        // Save-analysis is emitted per whole session, not per each crate type\n+        let crate_type = sess.crate_types.borrow()[0];\n+        let outputs = &*self.tcx.output_filenames(LOCAL_CRATE);\n+\n+        if outputs.outputs.contains_key(&OutputType::Metadata) {\n+            filename_for_metadata(sess, crate_name, outputs)\n+        } else if outputs.outputs.should_codegen() {\n+            out_filename(sess, crate_type, outputs, crate_name)\n+        } else {\n+            // Otherwise it's only a DepInfo, in which case we return early and\n+            // not even reach the analysis stage.\n+            unreachable!()\n+        }\n+    }\n+\n     // List external crates used by the current crate.\n     pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n         let mut result = Vec::with_capacity(self.tcx.crates().len());\n@@ -126,7 +146,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             result.push(ExternalCrateData {\n                 // FIXME: change file_name field to PathBuf in rls-data\n                 // https://github.com/nrc/rls-data/issues/7\n-                file_name: self.span_utils.make_path_string(&lo_loc.file.name),\n+                file_name: self.span_utils.make_filename_string(&lo_loc.file),\n                 num: n.as_u32(),\n                 id: GlobalCrateId {\n                     name: self.tcx.crate_name(n).to_string(),\n@@ -1015,6 +1035,7 @@ pub trait SaveHandler {\n         save_ctxt: SaveContext<'l, 'tcx>,\n         krate: &ast::Crate,\n         cratename: &str,\n+        input: &'l Input,\n     );\n }\n \n@@ -1080,12 +1101,14 @@ impl<'a> SaveHandler for DumpHandler<'a> {\n         save_ctxt: SaveContext<'l, 'tcx>,\n         krate: &ast::Crate,\n         cratename: &str,\n+        input: &'l Input,\n     ) {\n         let output = &mut self.output_file(&save_ctxt);\n         let mut dumper = JsonDumper::new(output, save_ctxt.config.clone());\n         let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n \n         visitor.dump_crate_info(cratename, krate);\n+        visitor.dump_compilation_options(input, cratename);\n         visit::walk_crate(&mut visitor, krate);\n     }\n }\n@@ -1101,6 +1124,7 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n         save_ctxt: SaveContext<'l, 'tcx>,\n         krate: &ast::Crate,\n         cratename: &str,\n+        input: &'l Input,\n     ) {\n         // We're using the JsonDumper here because it has the format of the\n         // save-analysis results that we will pass to the callback. IOW, we are\n@@ -1111,6 +1135,7 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n         let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n \n         visitor.dump_crate_info(cratename, krate);\n+        visitor.dump_compilation_options(input, cratename);\n         visit::walk_crate(&mut visitor, krate);\n     }\n }\n@@ -1120,6 +1145,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n     krate: &ast::Crate,\n     analysis: &'l ty::CrateAnalysis,\n     cratename: &str,\n+    input: &'l Input,\n     config: Option<Config>,\n     mut handler: H,\n ) {\n@@ -1137,7 +1163,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n             impl_counter: Cell::new(0),\n         };\n \n-        handler.save(save_ctxt, krate, cratename)\n+        handler.save(save_ctxt, krate, cratename, input)\n     })\n }\n "}, {"sha": "47677a751712e9ccf837b92df268e7f3ca4d6380", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -35,14 +35,24 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn make_path_string(&self, path: &FileName) -> String {\n-        match *path {\n-            FileName::Real(ref path) if !path.is_absolute() =>\n-                self.sess.working_dir.0\n-                    .join(&path)\n-                    .display()\n-                    .to_string(),\n-            _ => path.to_string(),\n+    pub fn make_filename_string(&self, file: &SourceFile) -> String {\n+        match &file.name {\n+            FileName::Real(path) if !file.name_was_remapped => {\n+                if path.is_absolute() {\n+                    self.sess.source_map().path_mapping()\n+                        .map_prefix(path.clone()).0\n+                        .display()\n+                        .to_string()\n+                } else {\n+                    self.sess.working_dir.0\n+                        .join(&path)\n+                        .display()\n+                        .to_string()\n+                }\n+            },\n+            // If the file name is already remapped, we assume the user\n+            // configured it the way they wanted to, so use that directly\n+            filename => filename.to_string()\n         }\n     }\n "}, {"sha": "5c4cd849f89bcd681e323d5db483f2d6764a874e", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -802,14 +802,6 @@ impl Abi {\n             _ => false,\n         }\n     }\n-\n-    /// Returns true if this is an uninhabited type\n-    pub fn is_uninhabited(&self) -> bool {\n-        match *self {\n-            Abi::Uninhabited => true,\n-            _ => false,\n-        }\n-    }\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]"}, {"sha": "3f1e8ee55286b6bfd682894aa3bbbc5e29c9cb13", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -761,7 +761,7 @@ impl Default for TargetOptions {\n }\n \n impl Target {\n-    /// Given a function ABI, turn \"System\" into the correct ABI for this target.\n+    /// Given a function ABI, turn it into the correct ABI for this target.\n     pub fn adjust_abi(&self, abi: Abi) -> Abi {\n         match abi {\n             Abi::System => {\n@@ -771,6 +771,16 @@ impl Target {\n                     Abi::C\n                 }\n             },\n+            // These ABI kinds are ignored on non-x86 Windows targets.\n+            // See https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions\n+            // and the individual pages for __stdcall et al.\n+            Abi::Stdcall | Abi::Fastcall | Abi::Vectorcall | Abi::Thiscall => {\n+                if self.options.is_like_windows && self.arch != \"x86\" {\n+                    Abi::C\n+                } else {\n+                    abi\n+                }\n+            },\n             abi => abi\n         }\n     }"}, {"sha": "ad724babe49fb69aa7e4e7f426876df7f21650a0", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -260,7 +260,10 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n     let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n \n-    let where_clauses = &tcx.predicates_defined_on(def_id).predicates;\n+    let where_clauses = &tcx.predicates_defined_on(def_id).predicates\n+        .into_iter()\n+        .map(|(wc, _)| wc.lower())\n+        .collect::<Vec<_>>();\n \n     // Rule Implied-Bound-From-Trait\n     //\n@@ -273,8 +276,8 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n     // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`, for each where clause WC\n     let implied_bound_clauses = where_clauses\n-        .into_iter()\n-        .map(|wc| wc.lower())\n+        .iter()\n+        .cloned()\n \n         // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n         .map(|wc| wc.map_bound(|goal| ProgramClause {\n@@ -296,8 +299,8 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let wf_conditions = iter::once(ty::Binder::dummy(trait_pred.lower()))\n         .chain(\n             where_clauses\n-                .into_iter()\n-                .map(|wc| wc.lower())\n+                .iter()\n+                .cloned()\n                 .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()))\n         );\n \n@@ -338,7 +341,10 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n \n     // `WC`\n-    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+    let where_clauses = tcx.predicates_of(def_id).predicates\n+        .into_iter()\n+        .map(|(wc, _)| wc.lower())\n+        .collect::<Vec<_>>();\n \n     // `Implemented(A0: Trait<A1..An>) :- WC`\n     let clause = ProgramClause {\n@@ -370,7 +376,10 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     let ty = tcx.type_of(def_id);\n \n     // `WC`\n-    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+    let where_clauses = tcx.predicates_of(def_id).predicates\n+        .into_iter()\n+        .map(|(wc, _)| wc.lower())\n+        .collect::<Vec<_>>();\n \n     // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n     let well_formed = ProgramClause {"}, {"sha": "057a586e9ac98a3f4ec9b8529a0524d212ea5edc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -693,7 +693,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>,\n+        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n         speculative: bool)\n         -> ty::PolyTraitRef<'tcx>\n     {\n@@ -716,7 +716,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+            // ok to ignore Err() because ErrorReported (see above)\n+            Some((predicate.ok()?, binding.span))\n         }));\n \n         debug!(\"ast_path_to_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n@@ -727,7 +728,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n         self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n@@ -974,7 +975,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let existential_principal = principal.map_bound(|trait_ref| {\n             self.trait_ref_to_existential(trait_ref)\n         });\n-        let existential_projections = projection_bounds.iter().map(|bound| {\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n                 let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n                 ty::ExistentialProjection {\n@@ -1006,7 +1007,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .map(|item| item.def_id));\n         }\n \n-        for projection_bound in &projection_bounds {\n+        for (projection_bound, _) in &projection_bounds {\n             associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n@@ -1089,7 +1090,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let bounds: Vec<_> = self.get_type_parameter_bounds(span, ty_param_def_id)\n-            .predicates.into_iter().filter_map(|p| p.to_opt_poly_trait_ref()).collect();\n+            .predicates.into_iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()).collect();\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n@@ -1701,42 +1702,41 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    pub region_bounds: Vec<ty::Region<'tcx>>,\n-    pub implicitly_sized: bool,\n-    pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n-    pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n+    pub implicitly_sized: Option<Span>,\n+    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span)>,\n+    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n }\n \n impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n-                      -> Vec<ty::Predicate<'tcx>>\n+                      -> Vec<(ty::Predicate<'tcx>, Span)>\n     {\n         // If it could be sized, and is, add the sized predicate\n-        let sized_predicate = if self.implicitly_sized {\n+        let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {\n                 let trait_ref = ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[])\n                 };\n-                trait_ref.to_predicate()\n+                (trait_ref.to_predicate(), span)\n             })\n-        } else {\n-            None\n-        };\n+        });\n \n         sized_predicate.into_iter().chain(\n-            self.region_bounds.iter().map(|&region_bound| {\n+            self.region_bounds.iter().map(|&(region_bound, span)| {\n                 // account for the binder being introduced below; no need to shift `param_ty`\n                 // because, at present at least, it can only refer to early-bound regions\n                 let region_bound = tcx.mk_region(ty::fold::shift_region(*region_bound, 1));\n-                ty::Binder::dummy(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate()\n+                let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n+                (ty::Binder::dummy(outlives).to_predicate(), span)\n             }).chain(\n-                self.trait_bounds.iter().map(|bound_trait_ref| {\n-                    bound_trait_ref.to_predicate()\n+                self.trait_bounds.iter().map(|&(bound_trait_ref, span)| {\n+                    (bound_trait_ref.to_predicate(), span)\n                 })\n             ).chain(\n-                self.projection_bounds.iter().map(|projection| {\n-                    projection.to_predicate()\n+                self.projection_bounds.iter().map(|&(projection, span)| {\n+                    (projection.to_predicate(), span)\n                 })\n             )\n         ).collect()"}, {"sha": "88e2e02cf503f14725722f7f18e4968fc9ba52b1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -81,35 +81,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             //\n             // See the examples in `run-pass/match-defbm*.rs`.\n             let mut pat_adjustments = vec![];\n-            expected = loop {\n+            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n                 debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n-                match exp_ty.sty {\n-                    ty::Ref(_, inner_ty, inner_mutability) => {\n-                        debug!(\"current discriminant is Ref, inserting implicit deref\");\n-                        // Preserve the reference type. We'll need it later during HAIR lowering.\n-                        pat_adjustments.push(exp_ty);\n-\n-                        exp_ty = inner_ty;\n-                        def_bm = match def_bm {\n-                            // If default binding mode is by value, make it `ref` or `ref mut`\n-                            // (depending on whether we observe `&` or `&mut`).\n-                            ty::BindByValue(_) =>\n-                                ty::BindByReference(inner_mutability),\n-\n-                            // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n-                            // the underlying value.\n-                            ty::BindByReference(hir::Mutability::MutImmutable) =>\n-                                ty::BindByReference(hir::Mutability::MutImmutable),\n-\n-                            // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n-                            // (on `&`).\n-                            ty::BindByReference(hir::Mutability::MutMutable) =>\n-                                ty::BindByReference(inner_mutability),\n-                        };\n-                    },\n-                    _ => break exp_ty,\n-                }\n-            };\n+\n+                debug!(\"current discriminant is Ref, inserting implicit deref\");\n+                // Preserve the reference type. We'll need it later during HAIR lowering.\n+                pat_adjustments.push(exp_ty);\n+\n+                exp_ty = inner_ty;\n+                def_bm = match def_bm {\n+                    // If default binding mode is by value, make it `ref` or `ref mut`\n+                    // (depending on whether we observe `&` or `&mut`).\n+                    ty::BindByValue(_) =>\n+                        ty::BindByReference(inner_mutability),\n+\n+                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n+                    // the underlying value.\n+                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n+                        ty::BindByReference(hir::Mutability::MutImmutable),\n+\n+                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n+                    // (on `&`).\n+                    ty::BindByReference(hir::Mutability::MutMutable) =>\n+                        ty::BindByReference(inner_mutability),\n+                };\n+            }\n+            expected = exp_ty;\n+\n             if pat_adjustments.len() > 0 {\n                 debug!(\"default binding mode is now {:?}\", def_bm);\n                 self.inh.tables.borrow_mut()\n@@ -153,7 +151,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n                             if let ty::Slice(_) = r_ty.sty {\n                                 pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n-                                                         tcx.mk_slice(tcx.types.u8))\n+                                                        tcx.mk_slice(tcx.types.u8))\n                             }\n                         }\n                     }\n@@ -294,7 +292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n                     // FIXME: MiscVariable for now, obtaining the span and name information\n-                    //       from all tuple elements isn't trivial.\n+                    //        from all tuple elements isn't trivial.\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n@@ -394,7 +392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     tcx.sess, pat.span, E0527,\n                                     \"pattern requires {} elements but array has {}\",\n                                     min_len, size)\n-                                    .span_label(pat.span, format!(\"expected {} elements\",size))\n+                                    .span_label(pat.span, format!(\"expected {} elements\", size))\n                                     .emit();\n                             }\n                             (inner_ty, tcx.types.err)\n@@ -857,7 +855,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                              subpats.len(), subpats_ending, def.kind_name(),\n                              variant.fields.len(),  fields_ending)\n                 .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n-                                               variant.fields.len(), fields_ending, subpats.len()))\n+                                              variant.fields.len(), fields_ending, subpats.len()))\n                 .emit();\n             on_error();\n             return tcx.types.err;"}, {"sha": "de4293aaaeac79ef676869c4f1da015c0c8b291c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -166,34 +166,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => continue,\n             };\n \n-            match self.lookup_method_in_trait(call_expr.span,\n-                                              method_name,\n-                                              trait_def_id,\n-                                              adjusted_ty,\n-                                              None) {\n-                None => continue,\n-                Some(ok) => {\n-                    let method = self.register_infer_ok_obligations(ok);\n-                    let mut autoref = None;\n-                    if borrow {\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                            let mutbl = match mutbl {\n-                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                    // For initial two-phase borrow\n-                                    // deployment, conservatively omit\n-                                    // overloaded function call ops.\n-                                    allow_two_phase_borrow: AllowTwoPhase::No,\n-                                }\n-                            };\n-                            autoref = Some(Adjustment {\n-                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                target: method.sig.inputs()[0]\n-                            });\n-                        }\n+            if let Some(ok) = self.lookup_method_in_trait(call_expr.span,\n+                                                          method_name,\n+                                                          trait_def_id,\n+                                                          adjusted_ty,\n+                                                          None) {\n+                let method = self.register_infer_ok_obligations(ok);\n+                let mut autoref = None;\n+                if borrow {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        let mutbl = match mutbl {\n+                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                // For initial two-phase borrow\n+                                // deployment, conservatively omit\n+                                // overloaded function call ops.\n+                                allow_two_phase_borrow: AllowTwoPhase::No,\n+                            }\n+                        };\n+                        autoref = Some(Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                            target: method.sig.inputs()[0]\n+                        });\n                     }\n-                    return Some((autoref, method));\n                 }\n+                return Some((autoref, method));\n             }\n         }\n \n@@ -238,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.span_suggestion_with_applicability(\n                         call_expr.span,\n                         &format!(\"`{}` is a unit variant, you need to write it \\\n-                                 without the parenthesis\", path),\n+                                  without the parenthesis\", path),\n                         path.to_string(),\n                         Applicability::MachineApplicable\n                     );"}, {"sha": "564ecae15dc35ba9001ecddfb79cfa3dc120f233", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -219,11 +219,11 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n                 err.span_label(error_span,\n                                format!(\"cannot cast `{}` as `{}`\",\n-                                        fcx.ty_to_string(self.expr_ty),\n-                                        cast_ty));\n+                                       fcx.ty_to_string(self.expr_ty),\n+                                       cast_ty));\n                 if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr.span) {\n                     err.span_help(self.expr.span,\n-                                   &format!(\"did you mean `*{}`?\", snippet));\n+                        &format!(\"did you mean `*{}`?\", snippet));\n                 }\n                 err.emit();\n             }\n@@ -267,16 +267,16 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::CastToChar => {\n                 type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0604,\n-                                 \"only `u8` can be cast as `char`, not `{}`\", self.expr_ty).emit();\n+                    \"only `u8` can be cast as `char`, not `{}`\", self.expr_ty).emit();\n             }\n             CastError::NonScalar => {\n                 type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0605,\n-                                 \"non-primitive cast: `{}` as `{}`\",\n-                                 self.expr_ty,\n-                                 fcx.ty_to_string(self.cast_ty))\n-                                .note(\"an `as` expression can only be used to convert between \\\n-                                       primitive types. Consider using the `From` trait\")\n-                                .emit();\n+                                   \"non-primitive cast: `{}` as `{}`\",\n+                                   self.expr_ty,\n+                                   fcx.ty_to_string(self.cast_ty))\n+                                  .note(\"an `as` expression can only be used to convert between \\\n+                                         primitive types. Consider using the `From` trait\")\n+                                  .emit();\n             }\n             CastError::SizedUnsizedCast => {\n                 use structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n@@ -445,7 +445,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                              self.expr_ty,\n                                              fcx.tcx.mk_fn_ptr(f),\n                                              AllowTwoPhase::No);\n-                    if !res.is_ok() {\n+                    if res.is_err() {\n                         return Err(CastError::NonScalar);\n                     }\n                     (FnPtr, t_cast)"}, {"sha": "202789d1d8af6edbef4b8d4fdb921fb6534dfef6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -231,20 +231,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate {\n+                if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n-                    ty::Predicate::Projection(ref proj_predicate) => {\n-                        let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n-                        self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                            .and_then(|_| {\n-                                self.deduce_sig_from_projection(\n-                                    Some(obligation.cause.span),\n-                                    proj_predicate,\n-                                )\n-                            })\n-                    }\n-                    _ => None,\n+                    let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n+                    self.self_type_matches_expected_vid(trait_ref, expected_vid)\n+                        .and_then(|_| {\n+                            self.deduce_sig_from_projection(\n+                                Some(obligation.cause.span),\n+                                proj_predicate\n+                            )\n+                        })\n+                } else {\n+                    None\n                 }\n             })\n             .next();\n@@ -318,9 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let input_tys = match arg_param_ty.sty {\n             ty::Tuple(tys) => tys.into_iter(),\n-            _ => {\n-                return None;\n-            }\n+            _ => return None\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n@@ -560,8 +557,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // The liberated version of this signature should be be a subtype\n             // of the liberated form of the expectation.\n             for ((hir_ty, &supplied_ty), expected_ty) in decl.inputs.iter()\n-                           .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n-                           .zip(expected_sigs.liberated_sig.inputs())\n+               .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+               .zip(expected_sigs.liberated_sig.inputs())\n             // `liberated_sig` is E'.\n             {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n@@ -638,11 +635,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.types.err\n         });\n \n-        match decl.output {\n-            hir::Return(ref output) => {\n-                astconv.ast_ty_to_ty(&output);\n-            }\n-            hir::DefaultReturn(_) => {}\n+        if let hir::Return(ref output) = decl.output {\n+            astconv.ast_ty_to_ty(&output);\n         }\n \n         let result = ty::Binder::bind(self.tcx.mk_fn_sig("}, {"sha": "967c710ac34a1ae9392f799db16169e673820c5e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -144,8 +144,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             if self.use_lub {\n-                self.at(&self.cause, self.fcx.param_env)\n-                    .lub(b, a)\n+                self.at(&self.cause, self.fcx.param_env).lub(b, a)\n             } else {\n                 self.at(&self.cause, self.fcx.param_env)\n                     .sup(b, a)\n@@ -256,8 +255,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                b: Ty<'tcx>,\n                                r_b: ty::Region<'tcx>,\n                                mt_b: TypeAndMut<'tcx>)\n-                               -> CoerceResult<'tcx> {\n-\n+                               -> CoerceResult<'tcx>\n+    {\n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n         // If we have a parameter of type `&M T_a` and the value\n@@ -591,9 +590,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 }\n \n                 Ok(Some(vtable)) => {\n-                    for obligation in vtable.nested_obligations() {\n-                        queue.push_back(obligation);\n-                    }\n+                    queue.extend(vtable.nested_obligations())\n                 }\n             }\n         }\n@@ -620,12 +617,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n               G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n         if let ty::FnPtr(fn_ty_b) = b.sty {\n-            match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n-                (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n-                    let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and(unsafe_a, b, to_unsafe);\n-                }\n-                _ => {}\n+            if let (hir::Unsafety::Normal, hir::Unsafety::Unsafe)\n+                = (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n+            {\n+                let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n+                return self.unify_and(unsafe_a, b, to_unsafe);\n             }\n         }\n         self.unify_and(a, b, normal)\n@@ -653,7 +649,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n         //! into a closure or a `proc`.\n-        //!\n \n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n@@ -724,9 +719,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let (is_ref, mt_a) = match a.sty {\n             ty::Ref(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n             ty::RawPtr(mt) => (false, mt),\n-            _ => {\n-                return self.unify_and(a, b, identity);\n-            }\n+            _ => return self.unify_and(a, b, identity)\n         };\n \n         // Check that the types which they point at are compatible.\n@@ -896,10 +889,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if !noop {\n-                return self.commit_if_ok(|_| {\n+                return self.commit_if_ok(|_|\n                     self.at(cause, self.param_env)\n                         .lub(prev_ty, new_ty)\n-                }).map(|ok| self.register_infer_ok_obligations(ok));\n+                ).map(|ok| self.register_infer_ok_obligations(ok));\n             }\n         }\n \n@@ -909,10 +902,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(e) = first_error {\n                     Err(e)\n                 } else {\n-                    self.commit_if_ok(|_| {\n+                    self.commit_if_ok(|_|\n                         self.at(cause, self.param_env)\n                             .lub(prev_ty, new_ty)\n-                    }).map(|ok| self.register_infer_ok_obligations(ok))\n+                    ).map(|ok| self.register_infer_ok_obligations(ok))\n                 }\n             }\n             Ok(ok) => {\n@@ -1005,7 +998,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     /// needlessly cloning the slice.\n     pub fn with_coercion_sites(expected_ty: Ty<'tcx>,\n                                coercion_sites: &'exprs [E])\n-                      -> Self {\n+                               -> Self {\n         Self::make(expected_ty, Expressions::UpFront(coercion_sites))\n     }\n "}, {"sha": "29770dc12eb3349e9fa249ce118afa75efa3e21f", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 43, "deletions": 71, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -20,7 +20,7 @@ use errors::Applicability;\n \n use syntax_pos::Span;\n \n-use super::{Inherited, FnCtxt};\n+use super::{Inherited, FnCtxt, potentially_plural_count};\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -209,8 +209,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // We then register the obligations from the impl_m and check to see\n     // if all constraints hold.\n-    hybrid_preds.predicates\n-                .extend(trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+    hybrid_preds.predicates.extend(\n+        trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n@@ -320,12 +320,12 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             trait_m.ident);\n             if let TypeError::Mutability = terr {\n                 if let Some(trait_err_span) = trait_err_span {\n-                    if let Ok(trait_err_str) = tcx.sess.source_map().\n-                                               span_to_snippet(trait_err_span) {\n+                    if let Ok(trait_err_str) = tcx.sess.source_map()\n+                                                       .span_to_snippet(trait_err_span) {\n                         diag.span_suggestion_with_applicability(\n                             impl_err_span,\n                             \"consider change the type to match the mutability in trait\",\n-                            format!(\"{}\", trait_err_str),\n+                            trait_err_str.to_string(),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n@@ -334,7 +334,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             infcx.note_type_err(&mut diag,\n                                 &cause,\n-                                trait_err_span.map(|sp| (sp, \"type in trait\".to_string())),\n+                                trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_fty,\n                                     found: impl_fty,\n@@ -408,7 +408,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return Err(ErrorReported);\n     }\n \n-    return Ok(());\n+    Ok(())\n }\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n@@ -470,14 +470,14 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 impl_iter.zip(trait_iter)\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n-                         .filter_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)| {\n+                         .filter_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)|\n                              match infcx.at(&cause, param_env).sub(trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n-                         })\n+                         )\n                          .next()\n-                         .unwrap_or_else(|| {\n+                         .unwrap_or_else(||\n                              if\n                                  infcx.at(&cause, param_env)\n                                       .sup(trait_sig.output(), impl_sig.output())\n@@ -487,7 +487,7 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                              } else {\n                                  (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n                              }\n-                         })\n+                         )\n             } else {\n                 (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n             }\n@@ -526,9 +526,9 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             );\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n-                ExplicitSelf::ByValue => \"self\".to_string(),\n-                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n-                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_string(),\n+                ExplicitSelf::ByValue => \"self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_owned(),\n                 _ => format!(\"self: {}\", self_arg_ty)\n             }\n         })\n@@ -591,6 +591,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.own_counts().types;\n     let num_trait_m_type_params = trait_m_generics.own_counts().types;\n+\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n         let impl_m_item = tcx.hir.expect_impl_item(impl_m_node_id);\n@@ -600,43 +601,26 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             impl_m_item.generics.span\n         };\n \n-        let mut err = struct_span_err!(tcx.sess,\n-                                       span,\n-                                       E0049,\n-                                       \"method `{}` has {} type parameter{} but its trait \\\n-                                        declaration has {} type parameter{}\",\n-                                       trait_m.ident,\n-                                       num_impl_m_type_params,\n-                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n-                                       num_trait_m_type_params,\n-                                       if num_trait_m_type_params == 1 {\n-                                           \"\"\n-                                       } else {\n-                                           \"s\"\n-                                       });\n+        let mut err = struct_span_err!(tcx.sess, span, E0049,\n+            \"method `{}` has {} but its trait declaration has {}\",\n+            trait_m.ident,\n+            potentially_plural_count(num_impl_m_type_params, \"type parameter\"),\n+            potentially_plural_count(num_trait_m_type_params, \"type parameter\")\n+        );\n \n         let mut suffix = None;\n \n         if let Some(span) = trait_item_span {\n-            err.span_label(span,\n-                           format!(\"expected {}\",\n-                                    &if num_trait_m_type_params != 1 {\n-                                        format!(\"{} type parameters\", num_trait_m_type_params)\n-                                    } else {\n-                                        format!(\"{} type parameter\", num_trait_m_type_params)\n-                                    }));\n+            err.span_label(span, format!(\"expected {}\",\n+                potentially_plural_count(num_trait_m_type_params, \"type parameter\")));\n         } else {\n             suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n         }\n \n         err.span_label(span,\n                        format!(\"found {}{}\",\n-                                &if num_impl_m_type_params != 1 {\n-                                    format!(\"{} type parameters\", num_impl_m_type_params)\n-                                } else {\n-                                    \"1 type parameter\".to_string()\n-                                },\n-                                suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n+                           potentially_plural_count(num_impl_m_type_params, \"type parameter\"),\n+                           suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n \n         err.emit();\n \n@@ -694,33 +678,21 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = struct_span_err!(tcx.sess,\n                                        impl_span,\n                                        E0050,\n-                                       \"method `{}` has {} parameter{} but the declaration in \\\n+                                       \"method `{}` has {} but the declaration in \\\n                                         trait `{}` has {}\",\n                                        trait_m.ident,\n-                                       impl_number_args,\n-                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n+                                       potentially_plural_count(impl_number_args, \"parameter\"),\n                                        tcx.item_path_str(trait_m.def_id),\n                                        trait_number_args);\n         if let Some(trait_span) = trait_span {\n-            err.span_label(trait_span,\n-                           format!(\"trait requires {}\",\n-                                    &if trait_number_args != 1 {\n-                                        format!(\"{} parameters\", trait_number_args)\n-                                    } else {\n-                                        format!(\"{} parameter\", trait_number_args)\n-                                    }));\n+            err.span_label(trait_span, format!(\"trait requires {}\",\n+                potentially_plural_count(trait_number_args, \"parameter\")));\n         } else {\n             err.note_trait_signature(trait_m.ident.to_string(),\n                                      trait_m.signature(&tcx));\n         }\n-        err.span_label(impl_span,\n-                       format!(\"expected {}, found {}\",\n-                                &if trait_number_args != 1 {\n-                                    format!(\"{} parameters\", trait_number_args)\n-                                } else {\n-                                    format!(\"{} parameter\", trait_number_args)\n-                                },\n-                                impl_number_args));\n+        err.span_label(impl_span, format!(\"expected {}, found {}\",\n+            potentially_plural_count(trait_number_args, \"parameter\"), impl_number_args));\n         err.emit();\n         return Err(ErrorReported);\n     }\n@@ -750,8 +722,9 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             GenericParamDefKind::Lifetime => None,\n         }\n     });\n-    for ((impl_def_id, impl_synthetic),\n-         (trait_def_id, trait_synthetic)) in impl_m_type_params.zip(trait_m_type_params) {\n+    for ((impl_def_id, impl_synthetic), (trait_def_id, trait_synthetic))\n+        in impl_m_type_params.zip(trait_m_type_params)\n+    {\n         if impl_synthetic != trait_synthetic {\n             let impl_node_id = tcx.hir.as_local_node_id(impl_def_id).unwrap();\n             let impl_span = tcx.hir.span(impl_node_id);\n@@ -831,15 +804,14 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         impl<'v> hir::intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty) {\n                                 hir::intravisit::walk_ty(self, ty);\n-                                match ty.node {\n-                                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                                        if let hir::def::Def::TyParam(def_id) = path.def {\n-                                            if def_id == self.1 {\n-                                                self.0 = Some(ty.span);\n-                                            }\n+                                if let hir::TyKind::Path(\n+                                    hir::QPath::Resolved(None, ref path)) = ty.node\n+                                {\n+                                    if let hir::def::Def::TyParam(def_id) = path.def {\n+                                        if def_id == self.1 {\n+                                            self.0 = Some(ty.span);\n                                         }\n-                                    },\n-                                    _ => {}\n+                                    }\n                                 }\n                             }\n                             fn nested_visit_map<'this>(\n@@ -975,7 +947,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             infcx.note_type_err(&mut diag,\n                                 &cause,\n-                                trait_c_span.map(|span| (span, \"type in trait\".to_string())),\n+                                trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_ty,\n                                     found: impl_ty,"}, {"sha": "71c78e7f87c07613f09eb5537faa668ffb2074d2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -115,19 +115,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // field is of the found type, suggest such variants. See Issue\n         // #42764.\n         if let ty::Adt(expected_adt, substs) = expected.sty {\n-            let mut compatible_variants = vec![];\n-            for variant in &expected_adt.variants {\n-                if variant.fields.len() == 1 {\n-                    let sole_field = &variant.fields[0];\n-                    let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                    if self.can_coerce(expr_ty, sole_field_ty) {\n-                        let mut variant_path = self.tcx.item_path_str(variant.did);\n-                        variant_path = variant_path.trim_left_matches(\"std::prelude::v1::\")\n-                            .to_string();\n-                        compatible_variants.push(variant_path);\n-                    }\n+            let compatible_variants = expected_adt.variants\n+                                                  .iter()\n+                                                  .filter(|variant| variant.fields.len() == 1)\n+                                                  .filter_map(|variant| {\n+                let sole_field = &variant.fields[0];\n+                let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                if self.can_coerce(expr_ty, sole_field_ty) {\n+                    let variant_path = self.tcx.item_path_str(variant.did);\n+                    Some(variant_path.trim_left_matches(\"std::prelude::v1::\").to_string())\n+                } else {\n+                    None\n                 }\n-            }\n+            }).collect::<Vec<_>>();\n+\n             if !compatible_variants.is_empty() {\n                 let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n                 let suggestions = compatible_variants.iter()\n@@ -380,15 +381,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       expected_ty: Ty<'tcx>)\n                       -> bool {\n         let parent_id = self.tcx.hir.get_parent_node(expr.id);\n-        match self.tcx.hir.find(parent_id) {\n-            Some(parent) => {\n-                // Shouldn't suggest `.into()` on `const`s.\n-                if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n-                    // FIXME(estebank): modify once we decide to suggest `as` casts\n-                    return false;\n-                }\n+        if let Some(parent) = self.tcx.hir.find(parent_id) {\n+            // Shouldn't suggest `.into()` on `const`s.\n+            if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n+                // FIXME(estebank): modify once we decide to suggest `as` casts\n+                return false;\n             }\n-            None => {}\n         };\n \n         let will_truncate = \"will truncate the source value\";\n@@ -662,15 +660,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer\",\n-                                      msg),\n+                                     msg),\n                             into_suggestion,\n                             Applicability::MachineApplicable\n                         );\n                     } else if can_cast {\n                         err.span_suggestion_with_applicability(expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer, rounded if necessary\",\n-                                      msg),\n+                                     msg),\n                             cast_suggestion,\n                             Applicability::MaybeIncorrect  // lossy conversion\n                         );\n@@ -684,7 +682,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer\",\n-                                      msg),\n+                                     msg),\n                             into_suggestion,\n                             Applicability::MachineApplicable\n                         );\n@@ -693,7 +691,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer, rounded if necessary\",\n-                                      msg),\n+                                     msg),\n                             cast_suggestion,\n                             Applicability::MaybeIncorrect  // lossy conversion\n                         );"}, {"sha": "b8544177bbbbeeb960cf99bfb1170976b848a232", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -11,12 +11,12 @@\n use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n-use rustc::infer::{self, InferOk};\n use rustc::infer::outlives::env::OutlivesEnvironment;\n+use rustc::infer::{self, InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n+use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use util::common::ErrorReported;\n \n use syntax::ast;\n@@ -39,32 +39,36 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 drop_impl_did: DefId)\n-                                 -> Result<(), ErrorReported> {\n+pub fn check_drop_impl<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    drop_impl_did: DefId,\n+) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::Adt(adt_def, self_to_impl_substs) => {\n-            ensure_drop_params_and_item_params_correspond(tcx,\n-                                                          drop_impl_did,\n-                                                          dtor_self_type,\n-                                                          adt_def.did)?;\n+            ensure_drop_params_and_item_params_correspond(\n+                tcx,\n+                drop_impl_did,\n+                dtor_self_type,\n+                adt_def.did,\n+            )?;\n \n-            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n-                                                            drop_impl_did,\n-                                                            &dtor_predicates,\n-                                                            adt_def.did,\n-                                                            self_to_impl_substs)\n+            ensure_drop_predicates_are_implied_by_item_defn(\n+                tcx,\n+                drop_impl_did,\n+                &dtor_predicates,\n+                adt_def.did,\n+                self_to_impl_substs,\n+            )\n         }\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);\n             tcx.sess.delay_span_bug(span,\n-                            &format!(\"should have been rejected by coherence check: {}\",\n-                            dtor_self_type));\n+                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type));\n             Err(ErrorReported)\n         }\n     }\n@@ -74,9 +78,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n-    self_type_did: DefId)\n-    -> Result<(), ErrorReported>\n-{\n+    self_type_did: DefId,\n+) -> Result<(), ErrorReported> {\n     let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n@@ -89,22 +92,29 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let named_type = tcx.type_of(self_type_did);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n-        let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+        let fresh_impl_substs = infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n-        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n+        match infcx\n+            .at(cause, impl_param_env)\n+            .eq(named_type, fresh_impl_self_ty)\n+        {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }\n             Err(_) => {\n                 let item_span = tcx.def_span(self_type_did);\n-                struct_span_err!(tcx.sess, drop_impl_span, E0366,\n-                                 \"Implementations of Drop cannot be specialized\")\n-                    .span_note(item_span,\n-                               \"Use same sequence of generic type and region \\\n-                                parameters that is on the struct/enum definition\")\n+                struct_span_err!(\n+                    tcx.sess,\n+                    drop_impl_span,\n+                    E0366,\n+                    \"Implementations of Drop cannot be specialized\"\n+                ).span_note(\n+                    item_span,\n+                    \"Use same sequence of generic type and region \\\n+                     parameters that is on the struct/enum definition\",\n+                )\n                     .emit();\n                 return Err(ErrorReported);\n             }\n@@ -128,7 +138,12 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         // conservative. -nmatsakis\n         let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n \n-        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_scope_tree, &outlives_env);\n+        infcx.resolve_regions_and_report_errors(\n+            drop_impl_did,\n+            &region_scope_tree,\n+            &outlives_env,\n+            SuppressRegionErrors::default(),\n+        );\n         Ok(())\n     })\n }\n@@ -140,9 +155,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n-    self_to_impl_substs: &Substs<'tcx>)\n-    -> Result<(), ErrorReported>\n-{\n+    self_to_impl_substs: &Substs<'tcx>,\n+) -> Result<(), ErrorReported> {\n     let mut result = Ok(());\n \n     // Here is an example, analogous to that from\n@@ -198,7 +212,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     // just to look for all the predicates directly.\n \n     assert_eq!(dtor_predicates.parent, None);\n-    for predicate in &dtor_predicates.predicates {\n+    for (predicate, _) in &dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced\n         // to take on a structure that is roughly an alpha-renaming of\n@@ -213,11 +227,17 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n             let item_span = tcx.hir.span(self_type_node_id);\n-            struct_span_err!(tcx.sess, drop_impl_span, E0367,\n-                             \"The requirement `{}` is added only by the Drop impl.\", predicate)\n-                .span_note(item_span,\n-                           \"The same requirement must be part of \\\n-                            the struct/enum definition\")\n+            struct_span_err!(\n+                tcx.sess,\n+                drop_impl_span,\n+                E0367,\n+                \"The requirement `{}` is added only by the Drop impl.\",\n+                predicate\n+            ).span_note(\n+                item_span,\n+                \"The same requirement must be part of \\\n+                 the struct/enum definition\",\n+            )\n                 .emit();\n             result = Err(ErrorReported);\n         }\n@@ -283,18 +303,16 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     ty: Ty<'tcx>,\n     span: Span,\n     body_id: ast::NodeId,\n-    scope: region::Scope)\n-    -> Result<(), ErrorReported>\n-{\n+    scope: region::Scope,\n+) -> Result<(), ErrorReported> {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            ty, scope);\n \n-\n     let parent_scope = match rcx.region_scope_tree.opt_encl_scope(scope) {\n         Some(parent_scope) => parent_scope,\n         // If no enclosing scope, then it must be the root scope\n         // which cannot be outlived.\n-        None => return Ok(())\n+        None => return Ok(()),\n     };\n     let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n     let origin = || infer::SubregionOrigin::SafeDestructor(span);"}, {"sha": "83005bc374ef5213e6dfad2c1e175cadfdbfc43b", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n                 // See the mega-comment at `yield_in_scope` for a proof.\n \n                 debug!(\"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                    expr_count, self.expr_count, source_span);\n+                       expr_count, self.expr_count, source_span);\n \n                 if expr_count >= self.expr_count {\n                     Some(yield_span)"}, {"sha": "d630c5b3040b7f1db3dc036125b6468e166d013d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n \n         struct_span_err!(tcx.sess, span, E0094,\n                         \"intrinsic has wrong number of type \\\n-                        parameters: found {}, expected {}\",\n+                         parameters: found {}, expected {}\",\n                         i_n_tps, n_tps)\n             .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n@@ -83,7 +83,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let name = it.name.as_str();\n     let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+        assert!(split.len() >= 2, \"Atomic intrinsic in an incorrect format\");\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n@@ -127,8 +127,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"size_of_val\" |  \"min_align_of_val\" => {\n                 (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST,\n-                                                                  ty::BrAnon(0))),\n-                                    param(0))\n+                                                                 ty::BrAnon(0))),\n+                                   param(0))\n                  ], tcx.types.usize)\n             }\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n@@ -306,7 +306,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"discriminant_value\" => (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST,\n-                                                                  ty::BrAnon(0))),\n+                                                                 ty::BrAnon(0))),\n                                    param(0))], tcx.types.u64),\n \n             \"try\" => {\n@@ -327,10 +327,10 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             ref other => {\n                 struct_span_err!(tcx.sess, it.span, E0093,\n-                                \"unrecognized intrinsic function: `{}`\",\n-                                *other)\n-                                .span_label(it.span, \"unrecognized intrinsic\")\n-                                .emit();\n+                                 \"unrecognized intrinsic function: `{}`\",\n+                                 *other)\n+                                 .span_label(it.span, \"unrecognized intrinsic\")\n+                                 .emit();\n                 return;\n             }\n         };"}, {"sha": "4e5488b432d48938df035d99473335f4079bb4d4", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -210,9 +210,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         target\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    //\n-\n     /// Returns a set of substitutions for the method *receiver* where all type and region\n     /// parameters are instantiated with fresh variables. This substitution does not include any\n     /// parameters declared on the method itself.\n@@ -291,18 +288,18 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         self.fcx\n             .autoderef(self.span, self_ty)\n             .include_raw_pointers()\n-            .filter_map(|(ty, _)| {\n+            .filter_map(|(ty, _)|\n                 match ty.sty {\n                     ty::Dynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n                     _ => None,\n                 }\n-            })\n+            )\n             .next()\n-            .unwrap_or_else(|| {\n+            .unwrap_or_else(||\n                 span_bug!(self.span,\n                           \"self-type `{}` for ObjectPick never dereferenced to an object\",\n                           self_ty)\n-            })\n+            )\n     }\n \n     fn instantiate_method_substs(\n@@ -373,9 +370,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    //\n-\n     // NOTE: this returns the *unnormalized* predicates and method sig. Because of\n     // inference guessing, the predicates and method signature can't be normalized\n     // until we unify the `Self` type.\n@@ -444,11 +438,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     /// respectively.\n     fn convert_place_derefs_to_mutable(&self) {\n         // Gather up expressions we want to munge.\n-        let mut exprs = Vec::new();\n-        exprs.push(self.self_expr);\n+        let mut exprs = vec![self.self_expr];\n+\n         loop {\n-            let last = exprs[exprs.len() - 1];\n-            match last.node {\n+            match exprs.last().unwrap().node {\n                 hir::ExprKind::Field(ref expr, _) |\n                 hir::ExprKind::Index(ref expr, _) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref expr) => exprs.push(&expr),"}, {"sha": "ec4483204f05ebe02838e14c5e084d0df76fa35a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -17,6 +17,9 @@ use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use namespace::Namespace;\n+use rustc::hir;\n+use rustc::lint;\n+use rustc::session::config::nightly_options;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n@@ -28,8 +31,6 @@ use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n use syntax_pos::{Span, symbol::Symbol};\n-use rustc::hir;\n-use rustc::lint;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -1073,9 +1074,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             self.tcx.item_path_str(stable_pick.item.def_id),\n         ));\n \n-        if ::rustc::session::config::nightly_options::is_nightly_build() {\n+        if nightly_options::is_nightly_build() {\n             for (candidate, feature) in unstable_candidates {\n-                diag.note(&format!(\n+                diag.help(&format!(\n                     \"add #![feature({})] to the crate attributes to enable `{}`\",\n                     feature,\n                     self.tcx.item_path_str(candidate.item.def_id),\n@@ -1255,9 +1256,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         // Do all probes correspond to the same trait?\n         let container = probes[0].0.item.container;\n-        match container {\n-            ty::TraitContainer(_) => {}\n-            ty::ImplContainer(_) => return None,\n+        if let ty::ImplContainer(_) = container {\n+            return None\n         }\n         if probes[1..].iter().any(|&(p, _)| p.item.container != container) {\n             return None;\n@@ -1461,7 +1461,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     .filter(|x| {\n                         let dist = lev_distance(&*name.as_str(), &x.ident.as_str());\n                         Namespace::from(x.kind) == Namespace::Value && dist > 0\n-                        && dist <= max_dist\n+                            && dist <= max_dist\n                     })\n                     .collect()\n             } else {"}, {"sha": "f5d332521ff0bb0e4a905f8106c87abca1cb5d9d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -88,7 +88,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let report_candidates = |err: &mut DiagnosticBuilder, mut sources: Vec<CandidateSource>| {\n-\n             sources.sort();\n             sources.dedup();\n             // Dynamic limit to avoid hiding just one candidate, which is silly.\n@@ -225,9 +224,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // ({integer}/{float}).\n                     let mut candidates = all_traits(self.tcx)\n                         .into_iter()\n-                        .filter(|info| {\n-                            self.associated_item(info.def_id, item_name, Namespace::Value).is_some()\n-                        });\n+                        .filter_map(|info|\n+                            self.associated_item(info.def_id, item_name, Namespace::Value)\n+                        );\n                     if let (true, false, Some(expr), Some(_)) = (actual.is_numeric(),\n                                                                  actual.has_concrete_skeleton(),\n                                                                  rcvr_expr,\n@@ -247,9 +246,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprKind::Lit(ref lit) => {  // numeric literal\n+                            hir::ExprKind::Lit(ref lit) => { // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n-                                    .unwrap_or(\"<numeric literal>\".to_string());\n+                                    .unwrap_or(\"<numeric literal>\".to_owned());\n \n                                 err.span_suggestion_with_applicability(\n                                                     lit.span,\n@@ -342,8 +341,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // give a helping note that it has to be called as (x.f)(...).\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n-                        match ty.sty {\n-                            ty::Adt(def, substs) if !def.is_enum() => {\n+                        if let ty::Adt(def, substs) = ty.sty {\n+                            if !def.is_enum() {\n                                 let variant = &def.non_enum_variant();\n                                 if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n@@ -377,7 +376,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     break;\n                                 }\n                             }\n-                            _ => {}\n                         }\n                     }\n                 } else {\n@@ -722,12 +720,9 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n         }\n         impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n-                match i.node {\n-                    hir::ItemKind::Trait(..) => {\n-                        let def_id = self.map.local_def_id(i.id);\n-                        self.traits.push(def_id);\n-                    }\n-                    _ => {}\n+                if let hir::ItemKind::Trait(..) = i.node {\n+                    let def_id = self.map.local_def_id(i.id);\n+                    self.traits.push(def_id);\n                 }\n             }\n "}, {"sha": "a9354e12deb34c69cabba4ce3991c490d6883931", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 117, "deletions": 145, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -662,7 +662,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     }\n \n     fn register_predicates<I>(&self, obligations: I)\n-    where I: IntoIterator<Item = traits::PredicateObligation<'tcx>> {\n+        where I: IntoIterator<Item = traits::PredicateObligation<'tcx>>\n+    {\n         for obligation in obligations {\n             self.register_predicate(obligation);\n         }\n@@ -1150,19 +1151,16 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     if let Some(term_id) = fcx.tcx.lang_items().termination() {\n         if let Some((id, _, entry_type)) = *fcx.tcx.sess.entry_fn.borrow() {\n             if id == fn_id {\n-                match entry_type {\n-                    config::EntryFnType::Main => {\n-                        let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n-                        let trait_ref = ty::TraitRef::new(term_id, substs);\n-                        let return_ty_span = decl.output.span();\n-                        let cause = traits::ObligationCause::new(\n-                            return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n-\n-                        inherited.register_predicate(\n-                            traits::Obligation::new(\n-                                cause, param_env, trait_ref.to_predicate()));\n-                    },\n-                    config::EntryFnType::Start => {},\n+                if let config::EntryFnType::Main = entry_type {\n+                    let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n+                    let trait_ref = ty::TraitRef::new(term_id, substs);\n+                    let return_ty_span = decl.output.span();\n+                    let cause = traits::ObligationCause::new(\n+                        return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n+\n+                    inherited.register_predicate(\n+                        traits::Obligation::new(\n+                            cause, param_env, trait_ref.to_predicate()));\n                 }\n             }\n         }\n@@ -1540,10 +1538,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_trait_ref);\n                     } else {\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n-                                  \"item `{}` is an associated const, \\\n-                                  which doesn't match its trait `{}`\",\n-                                  ty_impl_item.ident,\n-                                  impl_trait_ref);\n+                             \"item `{}` is an associated const, \\\n+                              which doesn't match its trait `{}`\",\n+                             ty_impl_item.ident,\n+                             impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n@@ -1564,10 +1562,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             trait_span);\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n-                                  \"item `{}` is an associated method, \\\n-                                  which doesn't match its trait `{}`\",\n-                                  ty_impl_item.ident,\n-                                  impl_trait_ref);\n+                            \"item `{}` is an associated method, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n@@ -1583,10 +1581,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n-                                  \"item `{}` is an associated type, \\\n-                                  which doesn't match its trait `{}`\",\n-                                  ty_impl_item.ident,\n-                                  impl_trait_ref);\n+                            \"item `{}` is an associated type, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n@@ -1624,8 +1622,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|trait_item| trait_item.ident.to_string())\n-                  .collect::<Vec<_>>().join(\"`, `\"));\n+                .map(|trait_item| trait_item.ident.to_string())\n+                .collect::<Vec<_>>().join(\"`, `\"));\n         err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n                     .map(|trait_item| trait_item.ident.to_string())\n@@ -1683,8 +1681,8 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n-    match t.sty {\n-        ty::Adt(def, substs) if def.is_struct() => {\n+    if let ty::Adt(def, substs) = t.sty {\n+        if def.is_struct() {\n             let fields = &def.non_enum_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -1699,15 +1697,14 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n             }\n             match e.sty {\n                 ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n-                _ if e.is_machine()  => { /* struct(u8, u8, u8, u8) is ok */ }\n+                _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n                 _ => {\n                     span_err!(tcx.sess, sp, E0077,\n                               \"SIMD vector element type should be machine type\");\n                     return;\n                 }\n             }\n         }\n-        _ => ()\n     }\n }\n \n@@ -1743,28 +1740,24 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n         return false;\n     }\n-    match t.sty {\n-        ty::Adt(def, substs) if def.is_struct() || def.is_union() => {\n+    if let ty::Adt(def, substs) = t.sty {\n+        if def.is_struct() || def.is_union() {\n             if tcx.adt_def(def.did).repr.align > 0 {\n                 return true;\n             }\n             // push struct def_id before checking fields\n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n                 let f = field.ty(tcx, substs);\n-                match f.sty {\n-                    ty::Adt(def, _) => {\n-                        if check_packed_inner(tcx, def.did, stack) {\n-                            return true;\n-                        }\n+                if let ty::Adt(def, _) = f.sty {\n+                    if check_packed_inner(tcx, def.did, stack) {\n+                        return true;\n                     }\n-                    _ => ()\n                 }\n             }\n             // only need to pop if not early out\n             stack.pop();\n         }\n-        _ => ()\n     }\n     false\n }\n@@ -1793,7 +1786,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n         let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| *span).collect();\n         struct_span_err!(tcx.sess, sp, E0690,\n                          \"transparent struct needs exactly one non-zero-sized field, but has {}\",\n-                          non_zst_count)\n+                         non_zst_count)\n         .span_note(field_spans, \"non-zero-sized field\")\n         .emit();\n     }\n@@ -1842,7 +1835,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let mut disr_vals: Vec<Discr<'tcx>> = Vec::new();\n+    let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n     for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n@@ -1882,14 +1875,17 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         let index = generics.param_def_id_to_index[&def_id];\n         ty::GenericPredicates {\n             parent: None,\n-            predicates: self.param_env.caller_bounds.iter().filter(|predicate| {\n-                match **predicate {\n-                    ty::Predicate::Trait(ref data) => {\n-                        data.skip_binder().self_ty().is_param(index)\n+            predicates: self.param_env.caller_bounds.iter().filter_map(|&predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref data)\n+                    if data.skip_binder().self_ty().is_param(index) => {\n+                        // HACK(eddyb) should get the original `Span`.\n+                        let span = tcx.def_span(def_id);\n+                        Some((predicate, span))\n                     }\n-                    _ => false\n+                    _ => None\n                 }\n-            }).cloned().collect()\n+            }).collect()\n         }\n     }\n \n@@ -2078,13 +2074,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> LocalTy<'tcx> {\n-        match self.locals.borrow().get(&nid) {\n-            Some(&t) => t,\n-            None => {\n-                span_bug!(span, \"no type for local variable {}\",\n-                          self.tcx.hir.node_to_string(nid));\n-            }\n-        }\n+        self.locals.borrow().get(&nid).cloned().unwrap_or_else(||\n+            span_bug!(span, \"no type for local variable {}\",\n+                      self.tcx.hir.node_to_string(nid))\n+        )\n     }\n \n     #[inline]\n@@ -2373,8 +2366,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n-    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n-    {\n+    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr) {\n         for ty in substs.types() {\n             self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n@@ -2421,8 +2413,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     substs: &Substs<'tcx>)\n                     -> Ty<'tcx>\n     {\n-        self.normalize_associated_types_in(span,\n-                                           &field.ty(self.tcx, substs))\n+        self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n     }\n \n     fn check_casts(&self) {\n@@ -2473,11 +2464,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Select as many obligations as we can at present.\n     fn select_obligations_where_possible(&self, fallback_has_occurred: bool) {\n-        match self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n-            Ok(()) => { }\n-            Err(errors) => {\n-                self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n-            },\n+        if let Err(errors) = self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n+            self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n         }\n     }\n \n@@ -2772,17 +2760,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expected_arg_count = fn_inputs.len();\n \n         let param_count_error = |expected_count: usize,\n-                                arg_count: usize,\n-                                error_code: &str,\n-                                variadic: bool,\n-                                sugg_unit: bool| {\n+                                 arg_count: usize,\n+                                 error_code: &str,\n+                                 variadic: bool,\n+                                 sugg_unit: bool| {\n             let mut err = tcx.sess.struct_span_err_with_code(sp,\n-                &format!(\"this function takes {}{} parameter{} but {} parameter{} supplied\",\n+                &format!(\"this function takes {}{} but {} {} supplied\",\n                     if variadic {\"at least \"} else {\"\"},\n-                    expected_count,\n-                    if expected_count == 1 {\"\"} else {\"s\"},\n-                    arg_count,\n-                    if arg_count == 1 {\" was\"} else {\"s were\"}),\n+                    potentially_plural_count(expected_count, \"parameter\"),\n+                    potentially_plural_count(arg_count, \"parameter\"),\n+                    if arg_count == 1 {\"was\"} else {\"were\"}),\n                 DiagnosticId::Error(error_code.to_owned()));\n \n             if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().def_span(sp)) {\n@@ -2798,10 +2785,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     String::from(\"()\"),\n                     Applicability::MachineApplicable);\n             } else {\n-                err.span_label(sp, format!(\"expected {}{} parameter{}\",\n-                                            if variadic {\"at least \"} else {\"\"},\n-                                            expected_count,\n-                                            if expected_count == 1 {\"\"} else {\"s\"}));\n+                err.span_label(sp, format!(\"expected {}{}\",\n+                                           if variadic {\"at least \"} else {\"\"},\n+                                           potentially_plural_count(expected_count, \"parameter\")));\n             }\n             err.emit();\n         };\n@@ -2967,7 +2953,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        (0..len).map(|_| self.tcx.types.err).collect()\n+        vec![self.tcx.types.err; len]\n     }\n \n     // AST fragment checking\n@@ -2982,7 +2968,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n                 tcx.mk_imm_ref(tcx.types.re_static,\n-                                tcx.mk_array(tcx.types.u8, v.len() as u64))\n+                               tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n             ast::LitKind::Char(_) => tcx.types.char,\n@@ -3051,23 +3037,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             // Add help to type error if this is an `if` condition with an assignment\n-            match (expected, &expr.node) {\n-                (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs)) => {\n-                    let msg = \"try comparing for equality\";\n-                    if let (Ok(left), Ok(right)) = (\n-                        self.tcx.sess.source_map().span_to_snippet(lhs.span),\n-                        self.tcx.sess.source_map().span_to_snippet(rhs.span))\n-                    {\n-                        err.span_suggestion_with_applicability(\n-                            expr.span,\n-                            msg,\n-                            format!(\"{} == {}\", left, right),\n-                            Applicability::MaybeIncorrect);\n-                    } else {\n-                        err.help(msg);\n-                    }\n+            if let (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs))\n+                 = (expected, &expr.node)\n+            {\n+                let msg = \"try comparing for equality\";\n+                if let (Ok(left), Ok(right)) = (\n+                    self.tcx.sess.source_map().span_to_snippet(lhs.span),\n+                    self.tcx.sess.source_map().span_to_snippet(rhs.span))\n+                {\n+                    err.span_suggestion_with_applicability(\n+                        expr.span,\n+                        msg,\n+                        format!(\"{} == {}\", left, right),\n+                        Applicability::MaybeIncorrect);\n+                } else {\n+                    err.help(msg);\n                 }\n-                _ => (),\n             }\n             err.emit();\n         }\n@@ -3355,8 +3340,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx().types.err\n         } else if self.method_exists(field, expr_t, expr.id, true) {\n             type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n-                              \"attempted to take value of method `{}` on type `{}`\",\n-                              field, expr_t)\n+                               \"attempted to take value of method `{}` on type `{}`\",\n+                               field, expr_t)\n                 .help(\"maybe a `()` to call it is missing?\")\n                 .emit();\n             self.tcx().types.err\n@@ -3441,14 +3426,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n-        let mut available = Vec::new();\n-        for field in variant.fields.iter() {\n+        variant.fields.iter().filter(|field| {\n             let def_scope = self.tcx.adjust_ident(field.ident, variant.did, self.body_id).1;\n-            if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                available.push(field.ident.name);\n-            }\n-        }\n-        available\n+            field.vis.is_accessible_from(def_scope, self.tcx)\n+        })\n+        .map(|field| field.ident.name)\n+        .collect()\n     }\n \n     fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n@@ -3480,13 +3463,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |actual| match ty.sty {\n                 ty::Adt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n-                                    \"{} `{}::{}` has no field named `{}`\",\n-                                    kind_name, actual, variant.name, field.ident)\n+                                     \"{} `{}::{}` has no field named `{}`\",\n+                                     kind_name, actual, variant.name, field.ident)\n                 }\n                 _ => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n-                                    \"{} `{}` has no field named `{}`\",\n-                                    kind_name, actual, field.ident)\n+                                     \"{} `{}` has no field named `{}`\",\n+                                     kind_name, actual, field.ident)\n                 }\n             },\n             ty);\n@@ -3571,10 +3554,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 error_happened = true;\n                 if let Some(prev_span) = seen_fields.get(&ident) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n-                                                field.ident.span,\n-                                                E0062,\n-                                                \"field `{}` specified more than once\",\n-                                                ident);\n+                                                   field.ident.span,\n+                                                   E0062,\n+                                                   \"field `{}` specified more than once\",\n+                                                   ident);\n \n                     err.span_label(field.ident.span, \"used more than once\");\n                     err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n@@ -3638,11 +3621,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n-        match *base_expr {\n-            Some(ref base) => {\n-                self.check_expr(&base);\n-            },\n-            None => {}\n+        if let Some(ref base) = *base_expr {\n+            self.check_expr(&base);\n         }\n     }\n \n@@ -3972,11 +3952,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty\n             }\n             hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-                for output in outputs {\n-                    self.check_expr(output);\n-                }\n-                for input in inputs {\n-                    self.check_expr(input);\n+                for expr in outputs.iter().chain(inputs.iter()) {\n+                    self.check_expr(expr);\n                 }\n                 tcx.mk_unit()\n             }\n@@ -4075,7 +4052,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Ret(ref expr_opt) => {\n                 if self.ret_coercion.is_none() {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                        \"return statement outside of function body\").emit();\n+                                     \"return statement outside of function body\").emit();\n                 } else if let Some(ref e) = *expr_opt {\n                     self.check_return_expr(e);\n                 } else {\n@@ -4393,7 +4370,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                                 if needs_note {\n                                     err.help(\"to access tuple elements, use tuple indexing \\\n-                                            syntax (e.g. `tuple.0`)\");\n+                                              syntax (e.g. `tuple.0`)\");\n                                 }\n                             }\n                             err.emit();\n@@ -4409,7 +4386,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     None => {\n                         struct_span_err!(self.tcx.sess, expr.span, E0627,\n-                                        \"yield statement outside of generator literal\").emit();\n+                                         \"yield statement outside of generator literal\").emit();\n                     }\n                 }\n                 tcx.mk_unit()\n@@ -4523,7 +4500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n+    pub fn check_decl_local(&self, local: &'gcx hir::Local) {\n         let t = self.local_ty(local.span, local.id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n@@ -4547,11 +4524,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Don't do all the complex logic below for DeclItem.\n         match stmt.node {\n             hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Local(_) => {}\n-                    hir::DeclKind::Item(_) => {\n-                        return;\n-                    }\n+                if let hir::DeclKind::Item(_) = decl.node {\n+                    return\n                 }\n             }\n             hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n@@ -4809,7 +4783,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 Some(format!(\"{}{}\", receiver, method_call))\n                             }\n                         }\n-                    }) .collect::<Vec<_>>();\n+                    }).collect::<Vec<_>>();\n                 if !suggestions.is_empty() {\n                     err.span_suggestions_with_applicability(\n                         expr.span,\n@@ -5286,18 +5260,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n-        match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n-            Node::Expr(expr) => {\n-                match expr.node {\n-                    hir::ExprKind::Call(ref callee, ..) => {\n-                        if callee.id == node_id {\n-                            return\n-                        }\n-                    }\n-                    _ => {}\n+        if let Node::Expr(expr) = self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n+            if let hir::ExprKind::Call(ref callee, ..) = expr.node {\n+                if callee.id == node_id {\n+                    return\n                 }\n             }\n-            _ => {}\n         }\n \n         self.tcx.sess.span_err(span, \"this function can only be invoked \\\n@@ -5323,8 +5291,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,\n-                                        ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n-                                   -> (BreakableCtxt<'gcx, 'tcx>, R) {\n+                                                ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n+                                                -> (BreakableCtxt<'gcx, 'tcx>, R) {\n         let index;\n         {\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n@@ -5398,3 +5366,7 @@ fn fatally_break_rust(sess: &Session) {\n         ::session::config::host_triple(),\n     ));\n }\n+\n+fn potentially_plural_count(count: usize, word: &str) -> String {\n+    format!(\"{} {}{}\", count, word, if count == 1 { \"\" } else { \"s\" })\n+}"}, {"sha": "89ed689b5d407526bbc2d60284b086a86d9e34c9", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 hir::BinOpKind::BitOr  => Some(\"std::ops::BitOrAssign\"),\n                                 hir::BinOpKind::Shl    => Some(\"std::ops::ShlAssign\"),\n                                 hir::BinOpKind::Shr    => Some(\"std::ops::ShrAssign\"),\n-                                _             => None\n+                                _                      => None\n                             };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n@@ -338,15 +338,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         IsAssign::No => {\n                             let mut err = struct_span_err!(self.tcx.sess, expr.span, E0369,\n-                                            \"binary operation `{}` cannot be applied to type `{}`\",\n-                                            op.node.as_str(),\n-                                            lhs_ty);\n+                                \"binary operation `{}` cannot be applied to type `{}`\",\n+                                op.node.as_str(),\n+                                lhs_ty);\n                             let mut suggested_deref = false;\n                             if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n-                                                                        rty,\n-                                                                        lhs_expr.span) &&\n+                                                                      rty,\n+                                                                      lhs_expr.span) &&\n                                         self.lookup_op_method(rty,\n                                                               &[rhs_ty],\n                                                               Op::Binary(op, is_assign))"}, {"sha": "80b4ba6240d335099618e82340053d38e2395479", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 403, "deletions": 326, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -88,27 +88,32 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty};\n-use rustc::infer;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n+use rustc::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc::ty::adjustment;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, Ty};\n \n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, PatKind};\n+use rustc_data_structures::sync::Lrc;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n-use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, PatKind};\n \n // a variation on try that just returns unit\n macro_rules! ignore_err {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(_) => {\n-        debug!(\"ignoring mem-categorization error!\");\n-        return ()\n-    }})\n+    ($e:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(_) => {\n+                debug!(\"ignoring mem-categorization error!\");\n+                return ();\n+            }\n+        }\n+    };\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -118,38 +123,46 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(id),\n-                                      id,\n-                                      Subject(subject),\n-                                      self.param_env);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(id),\n+            id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n+\n+        // There are no add'l implied bounds when checking a\n+        // standalone expr (e.g., the `E` in a type like `[u32; E]`).\n+        rcx.outlives_environment.save_implied_bounds(id);\n+\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n             rcx.visit_region_obligations(id);\n         }\n-        rcx.resolve_regions_and_report_errors_unless_nll();\n+        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n \n         assert!(self.tables.borrow().free_region_map.is_empty());\n         self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n     /// types from which we should derive implied bounds, if any.\n-    pub fn regionck_item(&self,\n-                         item_id: ast::NodeId,\n-                         span: Span,\n-                         wf_tys: &[Ty<'tcx>]) {\n+    pub fn regionck_item(&self, item_id: ast::NodeId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir.local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(item_id),\n-                                      item_id,\n-                                      Subject(subject),\n-                                      self.param_env);\n-        rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(item_id),\n+            item_id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n+        rcx.outlives_environment\n+            .add_implied_bounds(self, wf_tys, item_id, span);\n+        rcx.outlives_environment.save_implied_bounds(item_id);\n         rcx.visit_region_obligations(item_id);\n-        rcx.resolve_regions_and_report_errors();\n+        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::default());\n     }\n \n     /// Region check a function body. Not invoked on closures, but\n@@ -160,24 +173,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self,\n-                       fn_id: ast::NodeId,\n-                       body: &'gcx hir::Body) {\n+    pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(node_id),\n-                                      node_id,\n-                                      Subject(subject),\n-                                      self.param_env);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(node_id),\n+            node_id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n         }\n \n-        rcx.resolve_regions_and_report_errors_unless_nll();\n+        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n \n         // In this mode, we also copy the free-region-map into the\n         // tables of the enclosing fcx. In the other regionck modes\n@@ -190,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct RegionCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n     pub region_scope_tree: Lrc<region::ScopeTree>,\n@@ -208,7 +221,6 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: DefId,\n-\n }\n \n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n@@ -222,12 +234,13 @@ pub struct RepeatingScope(ast::NodeId);\n pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n-    pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-               RepeatingScope(initial_repeating_scope): RepeatingScope,\n-               initial_body_id: ast::NodeId,\n-               Subject(subject): Subject,\n-               param_env: ty::ParamEnv<'tcx>)\n-               -> RegionCtxt<'a, 'gcx, 'tcx> {\n+    pub fn new(\n+        fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+        RepeatingScope(initial_repeating_scope): RepeatingScope,\n+        initial_body_id: ast::NodeId,\n+        Subject(subject): Subject,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> RegionCtxt<'a, 'gcx, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n@@ -296,11 +309,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// closures, however, we save and restore any \"scoped state\"\n     /// before we invoke this function. (See `visit_fn` in the\n     /// `intravisit::Visitor` impl below.)\n-    fn visit_fn_body(&mut self,\n-                     id: ast::NodeId, // the id of the fn itself\n-                     body: &'gcx hir::Body,\n-                     span: Span)\n-    {\n+    fn visit_fn_body(\n+        &mut self,\n+        id: ast::NodeId, // the id of the fn itself\n+        body: &'gcx hir::Body,\n+        span: Span,\n+    ) {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n@@ -309,7 +323,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let call_site = region::Scope {\n             id: body.value.hir_id.local_id,\n-            data: region::ScopeData::CallSite\n+            data: region::ScopeData::CallSite,\n         };\n         self.call_site_scope = Some(call_site);\n \n@@ -328,65 +342,70 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // because it will have no effect.\n         //\n         // FIXME(#27579) return types should not be implied bounds\n-        let fn_sig_tys: Vec<_> =\n-            fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n+        let fn_sig_tys: Vec<_> = fn_sig\n+            .inputs()\n+            .iter()\n+            .cloned()\n+            .chain(Some(fn_sig.output()))\n+            .collect();\n \n         self.outlives_environment.add_implied_bounds(\n             self.fcx,\n             &fn_sig_tys[..],\n             body_id.node_id,\n-            span);\n+            span,\n+        );\n+        self.outlives_environment\n+            .save_implied_bounds(body_id.node_id);\n         self.link_fn_args(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n-                data: region::ScopeData::Node\n+                data: region::ScopeData::Node,\n             },\n-            &body.arguments);\n+            &body.arguments,\n+        );\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n-               body.id(), call_site_scope);\n+        debug!(\n+            \"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n+            body.id(),\n+            call_site_scope\n+        );\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n \n         let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n-        self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_hir_id,\n-                                       call_site_region);\n+        self.type_of_node_must_outlive(infer::CallReturn(span), body_hir_id, call_site_region);\n \n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n         );\n     }\n \n-    fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n-    {\n+    fn visit_region_obligations(&mut self, node_id: ast::NodeId) {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n \n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n         // obligations. So make sure we process those.\n         self.select_all_obligations_or_error();\n+    }\n \n+    fn resolve_regions_and_report_errors(&self, suppress: SuppressRegionErrors) {\n         self.infcx.process_registered_region_obligations(\n-            self.outlives_environment.region_bound_pairs(),\n+            self.outlives_environment.region_bound_pairs_map(),\n             self.implicit_region_bound,\n             self.param_env,\n-            self.body_id);\n-    }\n-\n-    fn resolve_regions_and_report_errors(&self) {\n-        self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n-                                                   &self.region_scope_tree,\n-                                                   &self.outlives_environment);\n-    }\n+        );\n \n-    fn resolve_regions_and_report_errors_unless_nll(&self) {\n-        self.fcx.resolve_regions_and_report_errors_unless_nll(self.subject_def_id,\n-                                                              &self.region_scope_tree,\n-                                                              &self.outlives_environment);\n+        self.fcx.resolve_regions_and_report_errors(\n+            self.subject_def_id,\n+            &self.region_scope_tree,\n+            &self.outlives_environment,\n+            suppress,\n+        );\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n@@ -423,7 +442,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, body_id, var_scope);\n+                self, typ, span, body_id, var_scope,\n+            );\n         })\n     }\n }\n@@ -441,14 +461,21 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'gcx>,\n-                _: &'gcx hir::FnDecl,\n-                body_id: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId) {\n-        assert!(match fk { intravisit::FnKind::Closure(..) => true, _ => false },\n-                \"visit_fn invoked for something other than a closure\");\n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'gcx>,\n+        _: &'gcx hir::FnDecl,\n+        body_id: hir::BodyId,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n+        assert!(\n+            match fk {\n+                intravisit::FnKind::Closure(..) => true,\n+                _ => false,\n+            },\n+            \"visit_fn invoked for something other than a closure\"\n+        );\n \n         // Save state of current function before invoking\n         // `visit_fn_body`.  We will restore afterwards.\n@@ -460,7 +487,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         self.visit_fn_body(id, body, span);\n \n         // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n+        self.outlives_environment\n+            .pop_snapshot_post_closure(env_snapshot);\n         self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n     }\n@@ -483,20 +511,24 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n-               expr, self.repeating_scope);\n+        debug!(\n+            \"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+            expr, self.repeating_scope\n+        );\n \n         // No matter what, the type of each expression must outlive the\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope {\n-                id: expr.hir_id.local_id,\n-                data: region::ScopeData::Node\n-            }));\n-        self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                               expr_ty, expr_region);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: expr.hir_id.local_id,\n+            data: region::ScopeData::Node,\n+        }));\n+        self.type_must_outlive(\n+            infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n+            expr_ty,\n+            expr_region,\n+        );\n \n         let is_method_call = self.tables.borrow().is_method_call(expr);\n \n@@ -506,12 +538,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // provided as arguments outlive the call.\n         if is_method_call {\n             let origin = match expr.node {\n-                hir::ExprKind::MethodCall(..) =>\n-                    infer::ParameterOrigin::MethodCall,\n-                hir::ExprKind::Unary(op, _) if op == hir::UnDeref =>\n-                    infer::ParameterOrigin::OverloadedDeref,\n-                _ =>\n-                    infer::ParameterOrigin::OverloadedOperator\n+                hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n+                hir::ExprKind::Unary(op, _) if op == hir::UnDeref => {\n+                    infer::ParameterOrigin::OverloadedDeref\n+                }\n+                _ => infer::ParameterOrigin::OverloadedOperator,\n             };\n \n             let substs = self.tables.borrow().node_substs(expr.hir_id);\n@@ -533,8 +564,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n-               expr, self.repeating_scope);\n+        debug!(\n+            \"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n+            expr, self.repeating_scope\n+        );\n         match expr.node {\n             hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n@@ -571,7 +604,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n-            },\n+            }\n \n             hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n                 // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n@@ -586,8 +619,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n                 let rhs_ty = self.resolve_expr_type_adjusted(&rhs);\n                 for &ty in &[lhs_ty, rhs_ty] {\n-                    self.type_must_outlive(infer::Operand(expr.span),\n-                                           ty, expr_region);\n+                    self.type_must_outlive(infer::Operand(expr.span), ty, expr_region);\n                 }\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -674,12 +706,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n-                debug!(\"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n-                       ret_expr.id, call_site_scope);\n+                debug!(\n+                    \"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n+                    ret_expr.id, call_site_scope\n+                );\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n-                self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n-                                               ret_expr.hir_id,\n-                                               call_site_region);\n+                self.type_of_node_must_outlive(\n+                    infer::CallReturn(ret_expr.span),\n+                    ret_expr.hir_id,\n+                    call_site_region,\n+                );\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -691,54 +727,47 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n-    fn constrain_cast(&mut self,\n-                      cast_expr: &hir::Expr,\n-                      source_expr: &hir::Expr)\n-    {\n-        debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n-               cast_expr,\n-               source_expr);\n+    fn constrain_cast(&mut self, cast_expr: &hir::Expr, source_expr: &hir::Expr) {\n+        debug!(\n+            \"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n+            cast_expr, source_expr\n+        );\n \n         let source_ty = self.resolve_node_type(source_expr.hir_id);\n         let target_ty = self.resolve_node_type(cast_expr.hir_id);\n \n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n \n-    fn walk_cast(&mut self,\n-                 cast_expr: &hir::Expr,\n-                 from_ty: Ty<'tcx>,\n-                 to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\",\n-               from_ty,\n-               to_ty);\n+    fn walk_cast(&mut self, cast_expr: &hir::Expr, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::Ref(from_r, from_ty, _),\n-            /*To:  */  &ty::Ref(to_r, to_ty, _)) => {\n+            /*From:*/\n+            (&ty::Ref(from_r, from_ty, _), /*To:  */ &ty::Ref(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n-            /*From:*/ (_,\n-            /*To:  */  &ty::Dynamic(.., r)) => {\n+            /*From:*/\n+            (_, /*To:  */ &ty::Dynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n-            /*From:*/ (&ty::Adt(from_def, _),\n-            /*To:  */  &ty::Adt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n+            /*From:*/\n+            (&ty::Adt(from_def, _), /*To:  */ &ty::Adt(to_def, _))\n+                if from_def.is_box() && to_def.is_box() =>\n+            {\n                 self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n     }\n \n-    fn check_expr_fn_block(&mut self,\n-                           expr: &'gcx hir::Expr,\n-                           body_id: hir::BodyId) {\n+    fn check_expr_fn_block(&mut self, expr: &'gcx hir::Expr, body_id: hir::BodyId) {\n         let repeating_scope = self.set_repeating_scope(body_id.node_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n@@ -747,7 +776,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n-            ty::FnDef(..) | ty::FnPtr(_) => { }\n+            ty::FnDef(..) | ty::FnPtr(_) => {}\n             _ => {\n                 // this should not happen, but it does if the program is\n                 // erroneous\n@@ -760,26 +789,29 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                                                           call_expr: &hir::Expr,\n-                                                           receiver: Option<&hir::Expr>,\n-                                                           arg_exprs: I) {\n+    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        call_expr: &hir::Expr,\n+        receiver: Option<&hir::Expr>,\n+        arg_exprs: I,\n+    ) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n         //! and overloaded operators). Constrains the regions which appear\n         //! in the type of the function. Also constrains the regions that\n         //! appear in the arguments appropriately.\n \n-        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\",\n-                call_expr,\n-                receiver);\n+        debug!(\n+            \"constrain_call(call_expr={:?}, receiver={:?})\",\n+            call_expr, receiver\n+        );\n \n         // `callee_region` is the scope representing the time in which the\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n         let callee_scope = region::Scope {\n             id: call_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         };\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n@@ -790,27 +822,30 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n             // ensure that any regions appearing in the argument type are\n             // valid for at least the lifetime of the function:\n-            self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n-                                           arg_expr.hir_id,\n-                                           callee_region);\n+            self.type_of_node_must_outlive(\n+                infer::CallArg(arg_expr.span),\n+                arg_expr.hir_id,\n+                callee_region,\n+            );\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n-            self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n-                                           r.hir_id,\n-                                           callee_region);\n+            self.type_of_node_must_outlive(infer::CallRcvr(r.span), r.hir_id, callee_region);\n         }\n     }\n \n     /// Create a temporary `MemCategorizationContext` and pass it to the closure.\n     fn with_mc<F, R>(&self, f: F) -> R\n-        where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R,\n     {\n-        f(mc::MemCategorizationContext::with_infer(&self.infcx,\n-                                                   &self.region_scope_tree,\n-                                                   &self.tables.borrow()))\n+        f(mc::MemCategorizationContext::with_infer(\n+            &self.infcx,\n+            &self.region_scope_tree,\n+            &self.tables.borrow(),\n+        ))\n     }\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n@@ -832,37 +867,46 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n \n-        let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope {\n-                id: expr.hir_id.local_id,\n-                data: region::ScopeData::Node\n-            }));\n+        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: expr.hir_id.local_id,\n+            data: region::ScopeData::Node,\n+        }));\n         for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n-                   adjustment, cmt);\n+            debug!(\n+                \"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n+                adjustment, cmt\n+            );\n \n             if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n                 debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n \n                 // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                 // was applied on the base type, as that is always the case.\n-                let input = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: cmt.ty,\n-                    mutbl: deref.mutbl,\n-                });\n-                let output = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: adjustment.target,\n-                    mutbl: deref.mutbl,\n-                });\n-\n-                self.link_region(expr.span, deref.region,\n-                                 ty::BorrowKind::from_mutbl(deref.mutbl), &cmt);\n+                let input = self.tcx.mk_ref(\n+                    deref.region,\n+                    ty::TypeAndMut {\n+                        ty: cmt.ty,\n+                        mutbl: deref.mutbl,\n+                    },\n+                );\n+                let output = self.tcx.mk_ref(\n+                    deref.region,\n+                    ty::TypeAndMut {\n+                        ty: adjustment.target,\n+                        mutbl: deref.mutbl,\n+                    },\n+                );\n+\n+                self.link_region(\n+                    expr.span,\n+                    deref.region,\n+                    ty::BorrowKind::from_mutbl(deref.mutbl),\n+                    &cmt,\n+                );\n \n                 // Specialized version of constrain_call.\n-                self.type_must_outlive(infer::CallRcvr(expr.span),\n-                                       input, expr_region);\n-                self.type_must_outlive(infer::CallReturn(expr.span),\n-                                       output, expr_region);\n+                self.type_must_outlive(infer::CallRcvr(expr.span), input, expr_region);\n+                self.type_must_outlive(infer::CallReturn(expr.span), output, expr_region);\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n@@ -872,73 +916,83 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 // the current node.\n                 //\n                 // FIXME(#6268) remove to support nested method calls\n-                self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                               expr.hir_id,\n-                                               expr_region);\n+                self.type_of_node_must_outlive(\n+                    infer::AutoBorrow(expr.span),\n+                    expr.hir_id,\n+                    expr_region,\n+                );\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n-                self.mk_subregion_due_to_dereference(expr.span,\n-                                                     expr_region, r_ptr);\n+                self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n             }\n         }\n \n         Ok(cmt)\n     }\n \n-    pub fn mk_subregion_due_to_dereference(&mut self,\n-                                           deref_span: Span,\n-                                           minimum_lifetime: ty::Region<'tcx>,\n-                                           maximum_lifetime: ty::Region<'tcx>) {\n-        self.sub_regions(infer::DerefPointer(deref_span),\n-                         minimum_lifetime, maximum_lifetime)\n+    pub fn mk_subregion_due_to_dereference(\n+        &mut self,\n+        deref_span: Span,\n+        minimum_lifetime: ty::Region<'tcx>,\n+        maximum_lifetime: ty::Region<'tcx>,\n+    ) {\n+        self.sub_regions(\n+            infer::DerefPointer(deref_span),\n+            minimum_lifetime,\n+            maximum_lifetime,\n+        )\n     }\n \n-    fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n-                                                     cmt: &mc::cmt_<'tcx>,\n-                                                     span: Span) {\n-        match cmt.cat {\n-            Categorization::Rvalue(region) => {\n-                match *region {\n-                    ty::ReScope(rvalue_scope) => {\n-                        let typ = self.resolve_type(cmt.ty);\n-                        let body_id = self.body_id;\n-                        let _ = dropck::check_safety_of_destructor_if_necessary(\n-                            self, typ, span, body_id, rvalue_scope);\n-                    }\n-                    ty::ReStatic => {}\n-                    _ => {\n-                        span_bug!(span,\n-                                  \"unexpected rvalue region in rvalue \\\n-                                   destructor safety checking: `{:?}`\",\n-                                  region);\n-                    }\n+    fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n+        if let Categorization::Rvalue(region) = cmt.cat {\n+            match *region {\n+                ty::ReScope(rvalue_scope) => {\n+                    let typ = self.resolve_type(cmt.ty);\n+                    let body_id = self.body_id;\n+                    let _ = dropck::check_safety_of_destructor_if_necessary(\n+                        self,\n+                        typ,\n+                        span,\n+                        body_id,\n+                        rvalue_scope,\n+                    );\n+                }\n+                ty::ReStatic => {}\n+                _ => {\n+                    span_bug!(\n+                        span,\n+                        \"unexpected rvalue region in rvalue \\\n+                         destructor safety checking: `{:?}`\",\n+                        region\n+                    );\n                 }\n             }\n-            _ => {}\n         }\n     }\n \n     /// Invoked on any index expression that occurs. Checks that if this is a slice\n     /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self,\n-                       index_expr: &hir::Expr,\n-                       indexed_ty: Ty<'tcx>)\n-    {\n-        debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n-               self.ty_to_string(indexed_ty));\n+    fn constrain_index(&mut self, index_expr: &hir::Expr, indexed_ty: Ty<'tcx>) {\n+        debug!(\n+            \"constrain_index(index_expr=?, indexed_ty={}\",\n+            self.ty_to_string(indexed_ty)\n+        );\n \n         let r_index_expr = ty::ReScope(region::Scope {\n             id: index_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         });\n         if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n             match r_ty.sty {\n                 ty::Slice(_) | ty::Str => {\n-                    self.sub_regions(infer::IndexSlice(index_expr.span),\n-                                     self.tcx.mk_region(r_index_expr), r_ptr);\n+                    self.sub_regions(\n+                        infer::IndexSlice(index_expr.span),\n+                        self.tcx.mk_region(r_index_expr),\n+                        r_ptr,\n+                    );\n                 }\n                 _ => {}\n             }\n@@ -947,27 +1001,29 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Guarantees that any lifetimes which appear in the type of the node `id` (after applying\n     /// adjustments) are valid for at least `minimum_lifetime`\n-    fn type_of_node_must_outlive(&mut self,\n+    fn type_of_node_must_outlive(\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         hir_id: hir::HirId,\n-        minimum_lifetime: ty::Region<'tcx>)\n-    {\n+        minimum_lifetime: ty::Region<'tcx>,\n+    ) {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(hir_id);\n \n         let ty = self.tables\n-                     .borrow()\n-                     .adjustments()\n-                     .get(hir_id)\n-                     .and_then(|adj| adj.last())\n-                     .map_or(ty0, |adj| adj.target);\n+            .borrow()\n+            .adjustments()\n+            .get(hir_id)\n+            .and_then(|adj| adj.last())\n+            .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n-        debug!(\"constrain_regions_in_type_of_node(\\\n-                ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n-                ty,  ty0,\n-                hir_id, minimum_lifetime);\n+        debug!(\n+            \"constrain_regions_in_type_of_node(\\\n+             ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n+            ty, ty0, hir_id, minimum_lifetime\n+        );\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n@@ -979,23 +1035,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n-    pub fn type_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             ty: Ty<'tcx>,\n-                             region: ty::Region<'tcx>)\n-    {\n-        self.infcx.type_must_outlive(self.outlives_environment.region_bound_pairs(),\n-                                     self.implicit_region_bound,\n-                                     self.param_env,\n-                                     origin,\n-                                     ty,\n-                                     region);\n+    pub fn type_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        self.infcx.register_region_obligation(\n+            self.body_id,\n+            RegionObligation {\n+                sub_region: region,\n+                sup_type: ty,\n+                origin,\n+            },\n+        );\n     }\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(&mut self, expr: &hir::Expr,\n-                    mutability: hir::Mutability, base: &hir::Expr) {\n+    fn link_addr_of(&mut self, expr: &hir::Expr, mutability: hir::Mutability, base: &hir::Expr) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n@@ -1011,7 +1069,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_local(&self, local: &hir::Local) {\n         debug!(\"regionck::for_local()\");\n         let init_expr = match local.init {\n-            None => { return; }\n+            None => {\n+                return;\n+            }\n             Some(ref expr) => &**expr,\n         };\n         let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr))));\n@@ -1043,48 +1103,53 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_cmt = self.with_mc(|mc| {\n                 Rc::new(mc.cat_rvalue(arg.hir_id, arg.pat.span, re_scope, arg_ty))\n             });\n-            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n-                   arg_ty,\n-                   arg_cmt,\n-                   arg);\n+            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\", arg_ty, arg_cmt, arg);\n             self.link_pattern(arg_cmt, &arg.pat);\n         }\n     }\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n     fn link_pattern(&self, discr_cmt: mc::cmt<'tcx>, root_pat: &hir::Pat) {\n-        debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n-               discr_cmt,\n-               root_pat);\n+        debug!(\n+            \"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n+            discr_cmt, root_pat\n+        );\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n-                match sub_pat.node {\n-                    // `ref x` pattern\n-                    PatKind::Binding(..) => {\n-                        if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n-                            if let ty::BindByReference(mutbl) = bm {\n-                                self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                                mutbl, &sub_cmt);\n-                            }\n-                        } else {\n-                            self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n+                // `ref x` pattern\n+                if let PatKind::Binding(..) = sub_pat.node {\n+                    if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n+                        if let ty::BindByReference(mutbl) = bm {\n+                            self.link_region_from_node_type(\n+                                sub_pat.span,\n+                                sub_pat.hir_id,\n+                                mutbl,\n+                                &sub_cmt,\n+                            );\n                         }\n+                    } else {\n+                        self.tcx\n+                            .sess\n+                            .delay_span_bug(sub_pat.span, \"missing binding mode\");\n                     }\n-                    _ => {}\n                 }\n             })\n         }));\n     }\n \n     /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n     /// autoref'd.\n-    fn link_autoref(&self,\n-                    expr: &hir::Expr,\n-                    expr_cmt: &mc::cmt_<'tcx>,\n-                    autoref: &adjustment::AutoBorrow<'tcx>)\n-    {\n-        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n+    fn link_autoref(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_cmt: &mc::cmt_<'tcx>,\n+        autoref: &adjustment::AutoBorrow<'tcx>,\n+    ) {\n+        debug!(\n+            \"link_autoref(autoref={:?}, expr_cmt={:?})\",\n+            autoref, expr_cmt\n+        );\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n@@ -1094,7 +1159,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             adjustment::AutoBorrow::RawPtr(m) => {\n                 let r = self.tcx.mk_region(ty::ReScope(region::Scope {\n                     id: expr.hir_id.local_id,\n-                    data: region::ScopeData::Node\n+                    data: region::ScopeData::Node,\n                 }));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n@@ -1103,17 +1168,21 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n     /// which must be some reference (`&T`, `&str`, etc).\n-    fn link_region_from_node_type(&self,\n-                                  span: Span,\n-                                  id: hir::HirId,\n-                                  mutbl: hir::Mutability,\n-                                  cmt_borrowed: &mc::cmt_<'tcx>) {\n-        debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n-               id, mutbl, cmt_borrowed);\n+    fn link_region_from_node_type(\n+        &self,\n+        span: Span,\n+        id: hir::HirId,\n+        mutbl: hir::Mutability,\n+        cmt_borrowed: &mc::cmt_<'tcx>,\n+    ) {\n+        debug!(\n+            \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n+            id, mutbl, cmt_borrowed\n+        );\n \n         let rptr_ty = self.resolve_node_type(id);\n         if let ty::Ref(r, _, _) = rptr_ty.sty {\n-            debug!(\"rptr_ty={}\",  rptr_ty);\n+            debug!(\"rptr_ty={}\", rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n     }\n@@ -1122,28 +1191,35 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// kind `borrow_kind` and lifetime `borrow_region`.\n     /// In order to ensure borrowck is satisfied, this may create constraints\n     /// between regions, as explained in `link_reborrowed_region()`.\n-    fn link_region(&self,\n-                   span: Span,\n-                   borrow_region: ty::Region<'tcx>,\n-                   borrow_kind: ty::BorrowKind,\n-                   borrow_cmt: &mc::cmt_<'tcx>) {\n+    fn link_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+        borrow_cmt: &mc::cmt_<'tcx>,\n+    ) {\n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n         self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n         let mut borrow_kind = borrow_kind;\n         let mut borrow_cmt_cat = borrow_cmt.cat.clone();\n \n         loop {\n-            debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n-                   borrow_region,\n-                   borrow_kind,\n-                   borrow_cmt);\n+            debug!(\n+                \"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n+                borrow_region, borrow_kind, borrow_cmt\n+            );\n             match borrow_cmt_cat {\n                 Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n-                    match self.link_reborrowed_region(span,\n-                                                      borrow_region, borrow_kind,\n-                                                      ref_cmt, ref_region, ref_kind,\n-                                                      borrow_cmt.note) {\n+                    match self.link_reborrowed_region(\n+                        span,\n+                        borrow_region,\n+                        borrow_kind,\n+                        ref_cmt,\n+                        ref_region,\n+                        ref_kind,\n+                        borrow_cmt.note,\n+                    ) {\n                         Some((c, k)) => {\n                             borrow_cmt_cat = c.cat.clone();\n                             borrow_kind = k;\n@@ -1154,20 +1230,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                Categorization::Downcast(cmt_base, _) |\n-                Categorization::Deref(cmt_base, mc::Unique) |\n-                Categorization::Interior(cmt_base, _) => {\n+                Categorization::Downcast(cmt_base, _)\n+                | Categorization::Deref(cmt_base, mc::Unique)\n+                | Categorization::Interior(cmt_base, _) => {\n                     // Borrowing interior or owned data requires the base\n                     // to be valid and borrowable in the same fashion.\n                     borrow_cmt_cat = cmt_base.cat.clone();\n                     borrow_kind = borrow_kind;\n                 }\n \n-                Categorization::Deref(_, mc::UnsafePtr(..)) |\n-                Categorization::StaticItem |\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) |\n-                Categorization::Rvalue(..) => {\n+                Categorization::Deref(_, mc::UnsafePtr(..))\n+                | Categorization::StaticItem\n+                | Categorization::Upvar(..)\n+                | Categorization::Local(..)\n+                | Categorization::Rvalue(..) => {\n                     // These are all \"base cases\" with independent lifetimes\n                     // that are not subject to inference\n                     return;\n@@ -1218,16 +1294,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// The return value of this function indicates whether we need to\n     /// recurse and process `ref_cmt` (see case 2 above).\n-    fn link_reborrowed_region(&self,\n-                              span: Span,\n-                              borrow_region: ty::Region<'tcx>,\n-                              borrow_kind: ty::BorrowKind,\n-                              ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: ty::Region<'tcx>,\n-                              mut ref_kind: ty::BorrowKind,\n-                              note: mc::Note)\n-                              -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n-    {\n+    fn link_reborrowed_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+        ref_cmt: mc::cmt<'tcx>,\n+        ref_region: ty::Region<'tcx>,\n+        mut ref_kind: ty::BorrowKind,\n+        note: mc::Note,\n+    ) -> Option<(mc::cmt<'tcx>, ty::BorrowKind)> {\n         // Possible upvar ID we may need later to create an entry in the\n         // maybe link map.\n \n@@ -1243,7 +1319,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                         infer::ReborrowUpvar(span, *upvar_id)\n                     }\n                     _ => {\n-                        span_bug!( span, \"Illegal upvar id: {:?}\", upvar_id);\n+                        span_bug!(span, \"Illegal upvar id: {:?}\", upvar_id);\n                     }\n                 }\n             }\n@@ -1253,14 +1329,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 // link\n                 infer::ReborrowUpvar(span, *upvar_id)\n             }\n-            _ => {\n-                infer::Reborrow(span)\n-            }\n+            _ => infer::Reborrow(span),\n         };\n \n-        debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n-               borrow_region,\n-               ref_region);\n+        debug!(\n+            \"link_reborrowed_region: {:?} <= {:?}\",\n+            borrow_region, ref_region\n+        );\n         self.sub_regions(cause, borrow_region, ref_region);\n \n         // If we end up needing to recurse and establish a region link\n@@ -1272,10 +1347,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // borrowck requires a unique path to the `&mut` reference but not\n         // necessarily a *mutable* path.\n         let new_borrow_kind = match borrow_kind {\n-            ty::ImmBorrow =>\n-                ty::ImmBorrow,\n-            ty::MutBorrow | ty::UniqueImmBorrow =>\n-                ty::UniqueImmBorrow\n+            ty::ImmBorrow => ty::ImmBorrow,\n+            ty::MutBorrow | ty::UniqueImmBorrow => ty::UniqueImmBorrow,\n         };\n \n         // Decide whether we need to recurse and link any regions within\n@@ -1329,16 +1402,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Checks that the values provided for type/region arguments in a given\n     /// expression are well-formed and in-scope.\n-    fn substs_wf_in_scope(&mut self,\n-                          origin: infer::ParameterOrigin,\n-                          substs: &Substs<'tcx>,\n-                          expr_span: Span,\n-                          expr_region: ty::Region<'tcx>) {\n-        debug!(\"substs_wf_in_scope(substs={:?}, \\\n-                expr_region={:?}, \\\n-                origin={:?}, \\\n-                expr_span={:?})\",\n-               substs, expr_region, origin, expr_span);\n+    fn substs_wf_in_scope(\n+        &mut self,\n+        origin: infer::ParameterOrigin,\n+        substs: &Substs<'tcx>,\n+        expr_span: Span,\n+        expr_region: ty::Region<'tcx>,\n+    ) {\n+        debug!(\n+            \"substs_wf_in_scope(substs={:?}, \\\n+             expr_region={:?}, \\\n+             origin={:?}, \\\n+             expr_span={:?})\",\n+            substs, expr_region, origin, expr_span\n+        );\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n "}, {"sha": "99effce4ee08df4edfa44c5c68910206de179e24", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -73,15 +73,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n-        match expr.node {\n-            hir::ExprKind::Closure(cc, _, body_id, _, _) => {\n-                let body = self.fcx.tcx.hir.body(body_id);\n-                self.visit_body(body);\n-                self.fcx\n-                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n-            }\n-\n-            _ => {}\n+        if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.node {\n+            let body = self.fcx.tcx.hir.body(body_id);\n+            self.visit_body(body);\n+            self.fcx\n+                .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n         }\n \n         intravisit::walk_expr(self, expr);\n@@ -335,49 +331,46 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             \"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n             guarantor.cat\n         );\n-        match guarantor.cat {\n-            Categorization::Deref(_, mc::BorrowedPtr(..)) => {\n-                debug!(\n-                    \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n-                    cmt.note\n-                );\n-                match guarantor.note {\n-                    mc::NoteUpvarRef(upvar_id) => {\n-                        debug!(\n-                            \"adjust_upvar_borrow_kind_for_consume: \\\n-                             setting upvar_id={:?} to by value\",\n-                            upvar_id\n-                        );\n-\n-                        // to move out of an upvar, this must be a FnOnce closure\n-                        self.adjust_closure_kind(\n-                            upvar_id.closure_expr_id,\n-                            ty::ClosureKind::FnOnce,\n-                            guarantor.span,\n-                            var_name(tcx, upvar_id.var_id),\n-                        );\n+        if let Categorization::Deref(_, mc::BorrowedPtr(..)) = guarantor.cat {\n+            debug!(\n+                \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n+                cmt.note\n+            );\n+            match guarantor.note {\n+                mc::NoteUpvarRef(upvar_id) => {\n+                    debug!(\n+                        \"adjust_upvar_borrow_kind_for_consume: \\\n+                         setting upvar_id={:?} to by value\",\n+                        upvar_id\n+                    );\n \n-                        self.adjust_upvar_captures\n-                            .insert(upvar_id, ty::UpvarCapture::ByValue);\n-                    }\n-                    mc::NoteClosureEnv(upvar_id) => {\n-                        // we get just a closureenv ref if this is a\n-                        // `move` closure, or if the upvar has already\n-                        // been inferred to by-value. In any case, we\n-                        // must still adjust the kind of the closure\n-                        // to be a FnOnce closure to permit moves out\n-                        // of the environment.\n-                        self.adjust_closure_kind(\n-                            upvar_id.closure_expr_id,\n-                            ty::ClosureKind::FnOnce,\n-                            guarantor.span,\n-                            var_name(tcx, upvar_id.var_id),\n-                        );\n-                    }\n-                    mc::NoteIndex | mc::NoteNone => {}\n+                    // to move out of an upvar, this must be a FnOnce closure\n+                    self.adjust_closure_kind(\n+                        upvar_id.closure_expr_id,\n+                        ty::ClosureKind::FnOnce,\n+                        guarantor.span,\n+                        var_name(tcx, upvar_id.var_id),\n+                    );\n+\n+                    self.adjust_upvar_captures\n+                        .insert(upvar_id, ty::UpvarCapture::ByValue);\n+                }\n+                mc::NoteClosureEnv(upvar_id) => {\n+                    // we get just a closureenv ref if this is a\n+                    // `move` closure, or if the upvar has already\n+                    // been inferred to by-value. In any case, we\n+                    // must still adjust the kind of the closure\n+                    // to be a FnOnce closure to permit moves out\n+                    // of the environment.\n+                    self.adjust_closure_kind(\n+                        upvar_id.closure_expr_id,\n+                        ty::ClosureKind::FnOnce,\n+                        guarantor.span,\n+                        var_name(tcx, upvar_id.var_id),\n+                    );\n                 }\n+                mc::NoteIndex | mc::NoteNone => {}\n             }\n-            _ => {}\n         }\n     }\n "}, {"sha": "cc1906d91d4c9bc438847f0c029e5f9e014e420d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 62, "deletions": 72, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -77,8 +77,8 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n     let item = tcx.hir.expect_item(node_id);\n \n     debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n-            item.id,\n-            tcx.item_path_str(def_id));\n+           item.id,\n+           tcx.item_path_str(def_id));\n \n     match item.node {\n         // Right now we check that every default trait implementation\n@@ -110,8 +110,8 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n                 if trait_ref.is_some() && !is_auto {\n                     span_err!(tcx.sess, item.span, E0192,\n-                                \"negative impls are only allowed for \\\n-                                auto traits (e.g., `Send` and `Sync`)\")\n+                              \"negative impls are only allowed for \\\n+                               auto traits (e.g., `Send` and `Sync`)\")\n                 }\n             }\n         }\n@@ -175,17 +175,17 @@ pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n }\n \n fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            item_id: ast::NodeId,\n-                            span: Span,\n-                            sig_if_method: Option<&hir::MethodSig>) {\n+                                   item_id: ast::NodeId,\n+                                   span: Span,\n+                                   sig_if_method: Option<&hir::MethodSig>) {\n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n             ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n             ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                            fcx.tcx.type_of(def_id))\n+                                          fcx.tcx.type_of(def_id))\n         };\n \n         match item.kind {\n@@ -199,7 +199,7 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n                 let sig = fcx.normalize_associated_types_in(span, &sig);\n                 check_fn_or_method(tcx, fcx, span, sig,\n-                                        item.def_id, &mut implied_bounds);\n+                                   item.def_id, &mut implied_bounds);\n                 let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n                 check_method_receiver(fcx, sig_if_method, &item, self_ty);\n             }\n@@ -220,12 +220,12 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n-                    -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+                            -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     for_id(tcx, item.id, item.span)\n }\n \n fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n-                -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+                          -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     let def_id = tcx.hir.local_def_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -330,14 +330,12 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n         let sig = fcx.normalize_associated_types_in(item.span, &sig);\n         let mut implied_bounds = vec![];\n         check_fn_or_method(tcx, fcx, item.span, sig,\n-                                def_id, &mut implied_bounds);\n+                           def_id, &mut implied_bounds);\n         implied_bounds\n     })\n }\n \n-fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    item: &hir::Item)\n-{\n+fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     debug!(\"check_item_type: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, _this| {\n@@ -351,9 +349,9 @@ fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                item: &hir::Item,\n-                ast_self_ty: &hir::Ty,\n-                ast_trait_ref: &Option<hir::TraitRef>)\n+                        item: &hir::Item,\n+                        ast_self_ty: &hir::Ty,\n+                        ast_trait_ref: &Option<hir::TraitRef>)\n {\n     debug!(\"check_impl: {:?}\", item);\n \n@@ -462,7 +460,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n         }\n     });\n     // Now we build the substituted predicates.\n-    let default_obligations = predicates.predicates.iter().flat_map(|&pred| {\n+    let default_obligations = predicates.predicates.iter().flat_map(|&(pred, _)| {\n         struct CountParams { params: FxHashSet<u32> }\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n@@ -484,12 +482,9 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n         let substituted_pred = pred.subst(fcx.tcx, substs);\n         // Don't check non-defaulted params, dependent defaults (including lifetimes)\n         // or preds with multiple params.\n-        if {\n-            substituted_pred.references_error() || param_count.params.len() > 1\n-                || has_region\n-        } {\n-                None\n-        } else if predicates.predicates.contains(&substituted_pred) {\n+        if substituted_pred.references_error() || param_count.params.len() > 1 || has_region {\n+            None\n+        } else if predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n             // Avoid duplication of predicates that contain no parameters, for example.\n             None\n         } else {\n@@ -535,11 +530,11 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n }\n \n fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                    span: Span,\n-                                    sig: ty::PolyFnSig<'tcx>,\n-                                    def_id: DefId,\n-                                    implied_bounds: &mut Vec<Ty<'tcx>>)\n+                                            fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                            span: Span,\n+                                            sig: ty::PolyFnSig<'tcx>,\n+                                            def_id: DefId,\n+                                            implied_bounds: &mut Vec<Ty<'tcx>>)\n {\n     let sig = fcx.normalize_associated_types_in(span, &sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n@@ -679,10 +674,10 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         \"check_existential_types may define. adding predicates: {:#?}\",\n                         predicates,\n                     );\n-                    for &pred in predicates.predicates.iter() {\n+                    for &(pred, _) in predicates.predicates.iter() {\n                         let substituted_pred = pred.subst(fcx.tcx, substs);\n                         // Avoid duplication of predicates that contain no parameters, for example.\n-                        if !predicates.predicates.contains(&substituted_pred) {\n+                        if !predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n                             substituted_predicates.push(substituted_pred);\n                         }\n                     }\n@@ -702,7 +697,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n {\n     // check that the method has a valid receiver type, given the type `Self`\n     debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n-            method, self_ty);\n+           method, self_ty);\n \n     if !method.method_has_self_argument {\n         return;\n@@ -806,14 +801,14 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut constrained_parameters: FxHashSet<_> =\n         variances.iter().enumerate()\n-                    .filter(|&(_, &variance)| variance != ty::Bivariant)\n-                    .map(|(index, _)| Parameter(index as u32))\n-                    .collect();\n+                        .filter(|&(_, &variance)| variance != ty::Bivariant)\n+                        .map(|(index, _)| Parameter(index as u32))\n+                        .collect();\n \n     identify_constrained_type_params(tcx,\n-                                        ty_predicates.predicates.as_slice(),\n-                                        None,\n-                                        &mut constrained_parameters);\n+                                     &ty_predicates,\n+                                     None,\n+                                     &mut constrained_parameters);\n \n     for (index, _) in variances.iter().enumerate() {\n         if constrained_parameters.contains(&Parameter(index as u32)) {\n@@ -826,22 +821,17 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        span: Span,\n-                        param_name: ast::Name)\n+                               span: Span,\n+                               param_name: ast::Name)\n {\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n-    match suggested_marker_id {\n-        Some(def_id) => {\n-            err.help(\n-                &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                            param_name,\n-                            tcx.item_path_str(def_id)));\n-        }\n-        None => {\n-            // no lang items, no help!\n-        }\n+    // help is available only in presence of lang items\n+    if let Some(def_id) = suggested_marker_id {\n+        err.help(&format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                          param_name,\n+                          tcx.item_path_str(def_id)));\n     }\n     err.emit();\n }\n@@ -855,11 +845,10 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n     }).collect();\n \n     for method_param in &generics.params {\n-        match method_param.kind {\n-            // Shadowing is checked in resolve_lifetime.\n-            GenericParamDefKind::Lifetime => continue,\n-            _ => {},\n-        };\n+        // Shadowing is checked in resolve_lifetime.\n+        if let GenericParamDefKind::Lifetime = method_param.kind {\n+            continue\n+        }\n         if impl_params.contains_key(&method_param.name) {\n             // Tighten up the span to focus on only the shadowing type\n             let type_span = tcx.def_span(method_param.def_id);\n@@ -876,16 +865,19 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n /// Feature gates RFC 2056 - trivial bounds, checking for global bounds that\n /// aren't true.\n fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n-        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-        span: Span,\n-        id: ast::NodeId,\n-) {\n+    fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+    span: Span,\n+    id: ast::NodeId)\n+{\n     use rustc::ty::TypeFoldable;\n \n     let empty_env = ty::ParamEnv::empty();\n \n     let def_id = fcx.tcx.hir.local_def_id(id);\n-    let predicates = fcx.tcx.predicates_of(def_id).predicates;\n+    let predicates = fcx.tcx.predicates_of(def_id).predicates\n+        .into_iter()\n+        .map(|(p, _)| p)\n+        .collect();\n     // Check elaborated bounds\n     let implied_obligations = traits::elaborate_predicates(fcx.tcx, predicates);\n \n@@ -963,15 +955,13 @@ struct AdtField<'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn non_enum_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n-        let fields =\n-            struct_def.fields().iter()\n-            .map(|field| {\n-                let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n-                let field_ty = self.normalize_associated_types_in(field.span,\n-                                                                  &field_ty);\n-                AdtField { ty: field_ty, span: field.span }\n-            })\n-            .collect();\n+        let fields = struct_def.fields().iter().map(|field| {\n+            let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n+            let field_ty = self.normalize_associated_types_in(field.span,\n+                                                              &field_ty);\n+            AdtField { ty: field_ty, span: field.span }\n+        })\n+        .collect();\n         AdtVariant { fields: fields }\n     }\n \n@@ -1010,8 +1000,8 @@ fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast:\n \n fn error_194(tcx: TyCtxt, span: Span, trait_decl_span: Span, name: &str) {\n     struct_span_err!(tcx.sess, span, E0194,\n-              \"type parameter `{}` shadows another type parameter of the same name\",\n-              name)\n+                     \"type parameter `{}` shadows another type parameter of the same name\",\n+                     name)\n         .span_label(span, \"shadows another type parameter\")\n         .span_label(trait_decl_span, format!(\"first `{}` declared here\", name))\n         .emit();"}, {"sha": "40f5d27356c7b97a7524174510bf0d4d683864ac", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -178,39 +178,34 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         if let hir::ExprKind::Index(ref base, ref index) = e.node {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n-            match tables.expr_ty_adjusted(&base).sty {\n-                // All valid indexing looks like this\n-                ty::Ref(_, base_ty, _) => {\n-                    let index_ty = tables.expr_ty_adjusted(&index);\n-                    let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n-\n-                    if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n-                        // Remove the method call record\n-                        tables.type_dependent_defs_mut().remove(e.hir_id);\n-                        tables.node_substs_mut().remove(e.hir_id);\n-\n-                        tables.adjustments_mut().get_mut(base.hir_id).map(|a| {\n-                            // Discard the need for a mutable borrow\n-                            match a.pop() {\n-                                // Extra adjustment made when indexing causes a drop\n-                                // of size information - we need to get rid of it\n-                                // Since this is \"after\" the other adjustment to be\n-                                // discarded, we do an extra `pop()`\n-                                Some(Adjustment {\n-                                    kind: Adjust::Unsize,\n-                                    ..\n-                                }) => {\n-                                    // So the borrow discard actually happens here\n-                                    a.pop();\n-                                }\n-                                _ => {}\n+            // All valid indexing looks like this; might encounter non-valid indexes at this point\n+            if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).sty {\n+                let index_ty = tables.expr_ty_adjusted(&index);\n+                let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n+\n+                if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n+                    // Remove the method call record\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n+\n+                    tables.adjustments_mut().get_mut(base.hir_id).map(|a| {\n+                        // Discard the need for a mutable borrow\n+                        match a.pop() {\n+                            // Extra adjustment made when indexing causes a drop\n+                            // of size information - we need to get rid of it\n+                            // Since this is \"after\" the other adjustment to be\n+                            // discarded, we do an extra `pop()`\n+                            Some(Adjustment {\n+                                kind: Adjust::Unsize,\n+                                ..\n+                            }) => {\n+                                // So the borrow discard actually happens here\n+                                a.pop();\n                             }\n-                        });\n-                    }\n+                            _ => {}\n+                        }\n+                    });\n                 }\n-                // Might encounter non-valid indexes at this point, so there\n-                // has to be a fall-through\n-                _ => {}\n             }\n         }\n     }\n@@ -445,7 +440,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                     span,\n                                     &format!(\n                                         \"type parameter `{}` is part of concrete type but not used \\\n-                                        in parameter list for existential type\",\n+                                         in parameter list for existential type\",\n                                         ty,\n                                     ),\n                                 )\n@@ -767,10 +762,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n     // FIXME This should be carefully checked\n     // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match self.infcx.fully_resolve(&r) {\n-            Ok(r) => r,\n-            Err(_) => self.tcx.types.re_static,\n-        }\n+        self.infcx.fully_resolve(&r).unwrap_or(self.tcx.types.re_static)\n     }\n }\n "}, {"sha": "db08bf80953523d79a0504da27649097877c43d0", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -11,6 +11,7 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n+use rustc::infer::SuppressRegionErrors;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n@@ -396,6 +397,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             impl_did,\n             &region_scope_tree,\n             &outlives_env,\n+            SuppressRegionErrors::default(),\n         );\n \n         CoerceUnsizedInfo {"}, {"sha": "fe6be5adc6fe6b93fd57f83a900a21673d00cf77", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -56,6 +56,8 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n+use std::iter;\n+\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n@@ -292,9 +294,10 @@ fn type_param_predicates<'a, 'tcx>(\n                 ItemKind::Trait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n+                        let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n                         result\n                             .predicates\n-                            .push(ty::TraitRef::identity(tcx, item_def_id).to_predicate());\n+                            .push((identity_trait_ref.to_predicate(), item.span));\n                     }\n                     generics\n                 }\n@@ -327,7 +330,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n         ast_generics: &hir::Generics,\n         param_id: ast::NodeId,\n         ty: Ty<'tcx>,\n-    ) -> Vec<ty::Predicate<'tcx>> {\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let from_ty_params = ast_generics\n             .params\n             .iter()\n@@ -705,8 +708,10 @@ fn super_predicates_of<'a, 'tcx>(\n \n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n-    for bound in superbounds.iter().filter_map(|p| p.to_opt_poly_trait_ref()) {\n-        tcx.at(item.span).super_predicates_of(bound.def_id());\n+    for &(pred, span) in &superbounds {\n+        if let ty::Predicate::Trait(bound) = pred {\n+            tcx.at(span).super_predicates_of(bound.def_id());\n+        }\n     }\n \n     ty::GenericPredicates {\n@@ -1584,10 +1589,10 @@ fn predicates_defined_on<'a, 'tcx>(\n     def_id: DefId,\n ) -> ty::GenericPredicates<'tcx> {\n     let explicit = tcx.explicit_predicates_of(def_id);\n-    let predicates = [\n-      &explicit.predicates[..],\n-      &tcx.inferred_outlives_of(def_id)[..],\n-    ].concat();\n+    let span = tcx.def_span(def_id);\n+    let predicates = explicit.predicates.into_iter().chain(\n+        tcx.inferred_outlives_of(def_id).iter().map(|&p| (p, span))\n+    ).collect();\n \n     ty::GenericPredicates {\n         parent: explicit.parent,\n@@ -1617,7 +1622,8 @@ fn predicates_of<'a, 'tcx>(\n         // prove that the trait applies to the types that were\n         // used, and adding the predicate into this list ensures\n         // that this is done.\n-        predicates.push(ty::TraitRef::identity(tcx, def_id).to_predicate());\n+        let span = tcx.def_span(def_id);\n+        predicates.push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n     }\n \n     ty::GenericPredicates { parent, predicates }\n@@ -1747,7 +1753,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // (see below). Recall that a default impl is not itself an impl, but rather a\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n-        predicates.push(trait_ref.to_poly_trait_ref().to_predicate());\n+        predicates.push((trait_ref.to_poly_trait_ref().to_predicate(), tcx.def_span(def_id)));\n     }\n \n     // Collect the region predicates that were declared inline as\n@@ -1768,7 +1774,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n                         let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n-                        predicates.push(outlives.to_predicate());\n+                        predicates.push((outlives.to_predicate(), lt.span));\n                     }\n                     _ => bug!(),\n                 });\n@@ -1812,7 +1818,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         // users who never wrote `where Type:,` themselves, to\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n-                        predicates.push(ty::Predicate::WellFormed(ty));\n+                        let span = bound_pred.bounded_ty.span;\n+                        predicates.push((ty::Predicate::WellFormed(ty), span));\n                     }\n                 }\n \n@@ -1828,14 +1835,16 @@ fn explicit_predicates_of<'a, 'tcx>(\n                                 &mut projections,\n                             );\n \n-                            predicates.push(trait_ref.to_predicate());\n-                            predicates.extend(projections.iter().map(|p| p.to_predicate()));\n+                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n+                            predicates.extend(projections.iter().map(|&(p, span)| {\n+                                (p.to_predicate(), span)\n+                            }));\n                         }\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n-                            predicates.push(ty::Predicate::TypeOutlives(pred))\n+                            predicates.push((ty::Predicate::TypeOutlives(pred), lifetime.span))\n                         }\n                     }\n                 }\n@@ -1844,14 +1853,14 @@ fn explicit_predicates_of<'a, 'tcx>(\n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n                 let r1 = AstConv::ast_region_to_region(&icx, &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = match bound {\n+                    let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n-                            AstConv::ast_region_to_region(&icx, lt, None)\n+                            (AstConv::ast_region_to_region(&icx, lt, None), lt.span)\n                         }\n                         _ => bug!(),\n                     };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n-                    predicates.push(ty::Predicate::RegionOutlives(pred))\n+                    predicates.push((ty::Predicate::RegionOutlives(pred), span))\n                 }\n             }\n \n@@ -1940,22 +1949,25 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n \n     let mut projection_bounds = vec![];\n \n-    let mut trait_bounds: Vec<_> = trait_bounds\n-        .iter()\n-        .map(|&bound| astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds))\n-        .collect();\n+    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n+        (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)\n+    }).collect();\n \n     let region_bounds = region_bounds\n         .into_iter()\n-        .map(|r| astconv.ast_region_to_region(r, None))\n+        .map(|r| (astconv.ast_region_to_region(r, None), r.span))\n         .collect();\n \n-    trait_bounds.sort_by_key(|t| t.def_id());\n+    trait_bounds.sort_by_key(|(t, _)| t.def_id());\n \n     let implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n-        !is_unsized(astconv, ast_bounds, span)\n+        if !is_unsized(astconv, ast_bounds, span) {\n+            Some(span)\n+        } else {\n+            None\n+        }\n     } else {\n-        false\n+        None\n     };\n \n     Bounds {\n@@ -1975,21 +1987,21 @@ fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx, 'tcx>,\n     param_ty: Ty<'tcx>,\n     bound: &hir::GenericBound,\n-) -> Vec<ty::Predicate<'tcx>> {\n+) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n             let pred = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n-            projections\n-                .into_iter()\n-                .map(|p| p.to_predicate())\n-                .chain(Some(pred.to_predicate()))\n-                .collect()\n+            iter::once((pred.to_predicate(), tr.span)).chain(\n+                projections\n+                    .into_iter()\n+                    .map(|(p, span)| (p.to_predicate(), span))\n+            ).collect()\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![ty::Predicate::TypeOutlives(pred)]\n+            vec![(ty::Predicate::TypeOutlives(pred), lifetime.span)]\n         }\n         hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => vec![],\n     }"}, {"sha": "1ef599ec58f9ea716d941f5c14113a3ca8742323", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -11,6 +11,7 @@\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::util::nodemap::FxHashSet;\n+use syntax::source_map::Span;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Parameter(pub u32);\n@@ -86,12 +87,12 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n }\n \n-pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt,\n-                                              predicates: &[ty::Predicate<'tcx>],\n+pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                                              predicates: &ty::GenericPredicates<'tcx>,\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut FxHashSet<Parameter>)\n {\n-    let mut predicates = predicates.to_owned();\n+    let mut predicates = predicates.predicates.clone();\n     setup_constraining_predicates(tcx, &mut predicates, impl_trait_ref, input_parameters);\n }\n \n@@ -137,7 +138,7 @@ pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt,\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt,\n-                                           predicates: &mut [ty::Predicate<'tcx>],\n+                                           predicates: &mut [(ty::Predicate<'tcx>, Span)],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                            input_parameters: &mut FxHashSet<Parameter>)\n {\n@@ -169,7 +170,7 @@ pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt,\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::Predicate::Projection(ref poly_projection) = predicates[j] {\n+            if let ty::Predicate::Projection(ref poly_projection) = predicates[j].0 {\n                 // Note that we can skip binder here because the impl\n                 // trait ref never contains any late-bound regions.\n                 let projection = poly_projection.skip_binder();"}, {"sha": "abb59dc9d9a3e0bc6d0f74f7dfdc3e90fd43db69", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -100,7 +100,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     ctp::identify_constrained_type_params(\n-        tcx, &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n+        tcx, &impl_predicates, impl_trait_ref, &mut input_parameters);\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()"}, {"sha": "1de79ddf4a49f8e53445e35d1398b987cf456ed5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -392,7 +392,7 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n }\n \n pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n-        -> (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>) {\n+        -> (ty::PolyTraitRef<'tcx>, Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>) {\n     // In case there are any projections etc, find the \"environment\"\n     // def-id that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing."}, {"sha": "75f8b78b9ecf3617c1b4e68ea3335872091efdeb", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             let mut required_predicates = RequiredPredicates::default();\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n-            for pred in predicates.into_iter() {\n+            for (pred, _) in predicates.into_iter() {\n                 match pred {\n                     ty::Predicate::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();"}, {"sha": "a435712ac3d6ce75ae6f52e5995eb5c550d5bf7f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -13,7 +13,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::MacroKind;\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -105,12 +105,12 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, did))\n         }\n-        // FIXME(misdreavus): if attributes/derives come down here we should probably document them\n-        // separately\n+        // FIXME: proc-macros don't propagate attributes or spans across crates, so they look empty\n         Def::Macro(did, MacroKind::Bang) => {\n-            record_extern_fqn(cx, did, clean::TypeKind::Macro);\n-            if let Some(mac) = build_macro(cx, did, name) {\n-                clean::MacroItem(mac)\n+            let mac = build_macro(cx, did, name);\n+            if let clean::MacroItem(..) = mac {\n+                record_extern_fqn(cx, did, clean::TypeKind::Macro);\n+                mac\n             } else {\n                 return None;\n             }\n@@ -442,31 +442,41 @@ fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n     }\n }\n \n-fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> Option<clean::Macro> {\n+fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n-    let def = match cx.cstore.load_macro_untracked(did, cx.sess()) {\n-        LoadedMacro::MacroDef(macro_def) => macro_def,\n-        // FIXME(jseyfried): document proc macro re-exports\n-        LoadedMacro::ProcMacro(..) => return None,\n-    };\n-\n-    let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n-        let tts: Vec<_> = def.stream().into_trees().collect();\n-        tts.chunks(4).map(|arm| arm[0].span()).collect()\n-    } else {\n-        unreachable!()\n-    };\n-\n-    let source = format!(\"macro_rules! {} {{\\n{}}}\",\n-                         name.clean(cx),\n-                         matchers.iter().map(|span| {\n-                             format!(\"    {} => {{ ... }};\\n\", span.to_src(cx))\n-                         }).collect::<String>());\n+    match cx.cstore.load_macro_untracked(did, cx.sess()) {\n+        LoadedMacro::MacroDef(def) => {\n+            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n+                let tts: Vec<_> = def.stream().into_trees().collect();\n+                tts.chunks(4).map(|arm| arm[0].span()).collect()\n+            } else {\n+                unreachable!()\n+            };\n+\n+            let source = format!(\"macro_rules! {} {{\\n{}}}\",\n+                                 name.clean(cx),\n+                                 matchers.iter().map(|span| {\n+                                     format!(\"    {} => {{ ... }};\\n\", span.to_src(cx))\n+                                 }).collect::<String>());\n+\n+            clean::MacroItem(clean::Macro {\n+                source,\n+                imported_from: Some(imported_from).clean(cx),\n+            })\n+        }\n+        LoadedMacro::ProcMacro(ext) => {\n+            let helpers = match &*ext {\n+                &SyntaxExtension::ProcMacroDerive(_, ref syms, ..) => { syms.clean(cx) }\n+                _ => Vec::new(),\n+            };\n+\n+            clean::ProcMacroItem(clean::ProcMacro {\n+                kind: ext.kind(),\n+                helpers,\n+            })\n+        }\n+    }\n \n-    Some(clean::Macro {\n-        source,\n-        imported_from: Some(imported_from).clean(cx),\n-    })\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "a91f2fd7474f5b7b28e1136bcd9c0521d404d83a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -21,6 +21,7 @@ pub use self::Visibility::{Public, Inherited};\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n@@ -527,6 +528,7 @@ pub enum ItemEnum {\n     /// `type`s from an extern block\n     ForeignTypeItem,\n     MacroItem(Macro),\n+    ProcMacroItem(ProcMacro),\n     PrimitiveItem(PrimitiveType),\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<GenericBound>, Option<Type>),\n@@ -588,6 +590,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n+        items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -1571,7 +1574,9 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n             }\n         }).collect::<Vec<GenericParamDef>>();\n \n-        let mut where_predicates = preds.predicates.to_vec().clean(cx);\n+        let mut where_predicates = preds.predicates.iter()\n+            .map(|(p, _)| p.clean(cx))\n+            .collect::<Vec<_>>();\n \n         // Type parameters and have a Sized bound by default unless removed with\n         // ?Sized. Scan through the predicates and mark any type parameter with\n@@ -2189,6 +2194,8 @@ pub enum TypeKind {\n     Typedef,\n     Foreign,\n     Macro,\n+    Attr,\n+    Derive,\n }\n \n pub trait GetDefId {\n@@ -3725,7 +3732,12 @@ pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n-        Def::Macro(i, _) => (i, TypeKind::Macro),\n+        Def::Macro(i, mac_kind) => match mac_kind {\n+            MacroKind::Bang => (i, TypeKind::Macro),\n+            MacroKind::Attr => (i, TypeKind::Attr),\n+            MacroKind::Derive => (i, TypeKind::Derive),\n+            MacroKind::ProcMacroStub => unreachable!(),\n+        },\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n@@ -3780,6 +3792,30 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct ProcMacro {\n+    pub kind: MacroKind,\n+    pub helpers: Vec<String>,\n+}\n+\n+impl Clean<Item> for doctree::ProcMacro {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: Some(Public),\n+            stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n+            inner: ProcMacroItem(ProcMacro {\n+                kind: self.kind,\n+                helpers: self.helpers.clean(cx),\n+            }),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Stability {\n     pub level: stability::StabilityLevel,"}, {"sha": "eda522af9224597a9bdf1e3a59d137899ae323ac", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -157,7 +157,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child).predicates;\n-    predicates.iter().filter_map(|pred| {\n+    predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.skip_binder().trait_ref.self_ty().is_self() {\n                 Some(pred.def_id())"}, {"sha": "4a6a4ee09ea1a0276af9ad19b6e9c924c221edf0", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -15,6 +15,7 @@ pub use self::StructType::*;\n use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::ptr::P;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n@@ -46,6 +47,7 @@ pub struct Module {\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<hir::ForeignMod>,\n     pub macros: Vec<Macro>,\n+    pub proc_macros: Vec<ProcMacro>,\n     pub is_crate: bool,\n }\n \n@@ -75,6 +77,7 @@ impl Module {\n             impls      : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n+            proc_macros: Vec::new(),\n             is_crate   : false,\n         }\n     }\n@@ -264,6 +267,17 @@ pub struct Import {\n     pub whence: Span,\n }\n \n+pub struct ProcMacro {\n+    pub name: Name,\n+    pub id: NodeId,\n+    pub kind: MacroKind,\n+    pub helpers: Vec<Name>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub whence: Span,\n+    pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n+}\n+\n pub fn struct_type_from_def(vdata: &hir::VariantData) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "acb8f6a66dfcb42ff3d87c4fdb52ca4186dfac0d", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -11,6 +11,7 @@\n //! Item types.\n \n use std::fmt;\n+use syntax::ext::base::MacroKind;\n use clean;\n \n /// Item type. Corresponds to `clean::ItemEnum` variants.\n@@ -19,6 +20,11 @@ use clean;\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n /// the `itemTypes` mapping table in `static/main.js`.\n+///\n+/// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n+/// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n+/// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n+/// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Clone, Debug)]\n pub enum ItemType {\n     Module          = 0,\n@@ -44,6 +50,8 @@ pub enum ItemType {\n     ForeignType     = 20,\n     Keyword         = 21,\n     Existential     = 22,\n+    ProcAttribute   = 23,\n+    ProcDerive      = 24,\n }\n \n \n@@ -88,6 +96,12 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::ForeignTypeItem         => ItemType::ForeignType,\n             clean::KeywordItem(..)         => ItemType::Keyword,\n+            clean::ProcMacroItem(ref mac)  => match mac.kind {\n+                MacroKind::Bang            => ItemType::Macro,\n+                MacroKind::Attr            => ItemType::ProcAttribute,\n+                MacroKind::Derive          => ItemType::ProcDerive,\n+                MacroKind::ProcMacroStub   => unreachable!(),\n+            }\n             clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n@@ -107,7 +121,9 @@ impl From<clean::TypeKind> for ItemType {\n             clean::TypeKind::Variant  => ItemType::Variant,\n             clean::TypeKind::Typedef  => ItemType::Typedef,\n             clean::TypeKind::Foreign  => ItemType::ForeignType,\n-            clean::TypeKind::Macro  => ItemType::Macro,\n+            clean::TypeKind::Macro    => ItemType::Macro,\n+            clean::TypeKind::Attr     => ItemType::ProcAttribute,\n+            clean::TypeKind::Derive   => ItemType::ProcDerive,\n         }\n     }\n }\n@@ -138,6 +154,8 @@ impl ItemType {\n             ItemType::ForeignType     => \"foreigntype\",\n             ItemType::Keyword         => \"keyword\",\n             ItemType::Existential     => \"existential\",\n+            ItemType::ProcAttribute   => \"attr\",\n+            ItemType::ProcDerive      => \"derive\",\n         }\n     }\n \n@@ -166,7 +184,9 @@ impl ItemType {\n             ItemType::Constant |\n             ItemType::AssociatedConst => NameSpace::Value,\n \n-            ItemType::Macro => NameSpace::Macro,\n+            ItemType::Macro |\n+            ItemType::ProcAttribute |\n+            ItemType::ProcDerive => NameSpace::Macro,\n \n             ItemType::Keyword => NameSpace::Keyword,\n         }"}, {"sha": "1c61e73fae03cdd0f8346bee6244c05bfd517256", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -56,6 +56,7 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -1595,6 +1596,8 @@ struct AllTypes {\n     statics: FxHashSet<ItemEntry>,\n     constants: FxHashSet<ItemEntry>,\n     keywords: FxHashSet<ItemEntry>,\n+    attributes: FxHashSet<ItemEntry>,\n+    derives: FxHashSet<ItemEntry>,\n }\n \n impl AllTypes {\n@@ -1613,6 +1616,8 @@ impl AllTypes {\n             statics: new_set(100),\n             constants: new_set(100),\n             keywords: new_set(100),\n+            attributes: new_set(100),\n+            derives: new_set(100),\n         }\n     }\n \n@@ -1634,6 +1639,8 @@ impl AllTypes {\n                 ItemType::Existential => self.existentials.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Static => self.statics.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Constant => self.constants.insert(ItemEntry::new(new_url, name)),\n+                ItemType::ProcAttribute => self.attributes.insert(ItemEntry::new(new_url, name)),\n+                ItemType::ProcDerive => self.derives.insert(ItemEntry::new(new_url, name)),\n                 _ => true,\n             };\n         }\n@@ -1673,6 +1680,8 @@ impl fmt::Display for AllTypes {\n         print_entries(f, &self.primitives, \"Primitives\", \"primitives\")?;\n         print_entries(f, &self.traits, \"Traits\", \"traits\")?;\n         print_entries(f, &self.macros, \"Macros\", \"macros\")?;\n+        print_entries(f, &self.attributes, \"Attribute Macros\", \"attributes\")?;\n+        print_entries(f, &self.derives, \"Derive Macros\", \"derives\")?;\n         print_entries(f, &self.functions, \"Functions\", \"functions\")?;\n         print_entries(f, &self.typedefs, \"Typedefs\", \"typedefs\")?;\n         print_entries(f, &self.existentials, \"Existentials\", \"existentials\")?;\n@@ -2155,6 +2164,12 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n             clean::TypedefItem(..) => write!(fmt, \"Type Definition \")?,\n             clean::MacroItem(..) => write!(fmt, \"Macro \")?,\n+            clean::ProcMacroItem(ref mac) => match mac.kind {\n+                MacroKind::Bang => write!(fmt, \"Macro \")?,\n+                MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n+                MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n+                MacroKind::ProcMacroStub => unreachable!(),\n+            }\n             clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n             clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n             clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n@@ -2191,6 +2206,7 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n             clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n+            clean::ProcMacroItem(ref m) => item_proc_macro(fmt, self.cx, self.item, m),\n             clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n             clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n                 item_static(fmt, self.cx, self.item, i),\n@@ -4079,11 +4095,12 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 write!(fmt,\n                        \"<div class='block version'>\\\n                         <p>Version {}</p>\\\n-                        </div>\n-                        <a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n-                       version,\n-                       it.name.as_ref().unwrap())?;\n+                        </div>\",\n+                       version)?;\n             }\n+\n+            write!(fmt, \"<a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n+                   it.name.as_ref().expect(\"crates always have a name\"))?;\n         }\n \n         write!(fmt, \"<div class=\\\"sidebar-elems\\\">\")?;\n@@ -4523,6 +4540,8 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n         ItemType::ForeignType     => (\"foreign-types\", \"Foreign Types\"),\n         ItemType::Keyword         => (\"keywords\", \"Keywords\"),\n         ItemType::Existential     => (\"existentials\", \"Existentials\"),\n+        ItemType::ProcAttribute   => (\"attributes\", \"Attribute Macros\"),\n+        ItemType::ProcDerive      => (\"derives\", \"Derive Macros\"),\n     }\n }\n \n@@ -4598,6 +4617,39 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n+fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n+    -> fmt::Result\n+{\n+    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+    match m.kind {\n+        MacroKind::Bang => {\n+            write!(w, \"<pre class='rust macro'>\")?;\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name)?;\n+            write!(w, \"</pre>\")?;\n+        }\n+        MacroKind::Attr => {\n+            write!(w, \"<pre class='rust attr'>\")?;\n+            write!(w, \"#[{}]\", name)?;\n+            write!(w, \"</pre>\")?;\n+        }\n+        MacroKind::Derive => {\n+            write!(w, \"<pre class='rust derive'>\")?;\n+            write!(w, \"#[derive({})]\", name)?;\n+            if !m.helpers.is_empty() {\n+                writeln!(w, \"\\n{{\")?;\n+                writeln!(w, \"    // Attributes available to this derive:\")?;\n+                for attr in &m.helpers {\n+                    writeln!(w, \"    #[{}]\", attr)?;\n+                }\n+                write!(w, \"}}\")?;\n+            }\n+            write!(w, \"</pre>\")?;\n+        }\n+        _ => {}\n+    }\n+    document(w, cx, it)\n+}\n+\n fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {"}, {"sha": "6307dda454da892b261ed71c8d2d40e908956df3", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -39,7 +39,10 @@\n                      \"associatedconstant\",\n                      \"union\",\n                      \"foreigntype\",\n-                     \"keyword\"];\n+                     \"keyword\",\n+                     \"existential\",\n+                     \"attr\",\n+                     \"derive\"];\n \n     var search_input = document.getElementsByClassName('search-input')[0];\n "}, {"sha": "34a1d71beecfcdf863f5fdc29b89549b9c7fadaf", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -124,6 +124,8 @@ pre {\n .content .highlighted.tymethod { background-color: #4950ed; }\n .content .highlighted.type { background-color: #38902c; }\n .content .highlighted.foreigntype { background-color: #b200d6; }\n+.content .highlighted.attr,\n+.content .highlighted.derive,\n .content .highlighted.macro { background-color: #217d1c; }\n .content .highlighted.constant,\n .content .highlighted.static { background-color: #0063cc; }\n@@ -134,6 +136,8 @@ pre {\n .content span.struct, .content a.struct, .block a.current.struct { color: #2dbfb8; }\n .content span.type, .content a.type, .block a.current.type { color: #ff7f00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #dd7de8; }\n+.content span.attr, .content a.attr, .block a.current.attr,\n+.content span.derive, .content a.derive, .block a.current.derive,\n .content span.macro, .content a.macro, .block a.current.macro { color: #09bd00; }\n .content span.union, .content a.union, .block a.current.union { color: #a6ae37; }\n .content span.constant, .content a.constant, .block a.current.constant,"}, {"sha": "8218b1b371ea72fcba87a0e3fb2205ef90c34355", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -124,6 +124,8 @@ pre {\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #ffc891; }\n .content .highlighted.foreigntype { background-color: #f5c4ff; }\n+.content .highlighted.attr,\n+.content .highlighted.derive,\n .content .highlighted.macro { background-color: #8ce488; }\n .content .highlighted.constant,\n .content .highlighted.static { background-color: #c3e0ff; }\n@@ -134,6 +136,8 @@ pre {\n .content span.struct, .content a.struct, .block a.current.struct { color: #ad448e; }\n .content span.type, .content a.type, .block a.current.type { color: #ba5d00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #cd00e2; }\n+.content span.attr, .content a.attr, .block a.current.attr,\n+.content span.derive, .content a.derive, .block a.current.derive,\n .content span.macro, .content a.macro, .block a.current.macro { color: #068000; }\n .content span.union, .content a.union, .block a.current.union { color: #767b27; }\n .content span.constant, .content a.constant, .block a.current.constant,"}, {"sha": "d00eb3257d43c6a5aacb537390c24361fcceb10d", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -249,6 +249,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             // tymethods/macros have no control over privacy\n             clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n \n+            // Proc-macros are always public\n+            clean::ProcMacroItem(..) => {}\n+\n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n "}, {"sha": "92d8dbed0718a5a1ecefde7e31024384de4b5188", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -15,6 +15,7 @@ use std::mem;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n@@ -168,24 +169,75 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         }\n     }\n \n-    pub fn visit_fn(&mut self, item: &hir::Item,\n+    pub fn visit_fn(&mut self, om: &mut Module, item: &hir::Item,\n                     name: ast::Name, fd: &hir::FnDecl,\n                     header: hir::FnHeader,\n                     gen: &hir::Generics,\n-                    body: hir::BodyId) -> Function {\n+                    body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n-        Function {\n-            id: item.id,\n-            vis: item.vis.clone(),\n-            stab: self.stability(item.id),\n-            depr: self.deprecation(item.id),\n-            attrs: item.attrs.clone(),\n-            decl: fd.clone(),\n-            name,\n-            whence: item.span,\n-            generics: gen.clone(),\n-            header,\n-            body,\n+        let macro_kind = item.attrs.iter().filter_map(|a| {\n+            if a.check_name(\"proc_macro\") {\n+                Some(MacroKind::Bang)\n+            } else if a.check_name(\"proc_macro_derive\") {\n+                Some(MacroKind::Derive)\n+            } else if a.check_name(\"proc_macro_attribute\") {\n+                Some(MacroKind::Attr)\n+            } else {\n+                None\n+            }\n+        }).next();\n+        match macro_kind {\n+            Some(kind) => {\n+                let name = if kind == MacroKind::Derive {\n+                    item.attrs.lists(\"proc_macro_derive\")\n+                              .filter_map(|mi| mi.name())\n+                              .next()\n+                              .expect(\"proc-macro derives require a name\")\n+                } else {\n+                    name\n+                };\n+\n+                let mut helpers = Vec::new();\n+                for mi in item.attrs.lists(\"proc_macro_derive\") {\n+                    if !mi.check_name(\"attributes\") {\n+                        continue;\n+                    }\n+\n+                    if let Some(list) = mi.meta_item_list() {\n+                        for inner_mi in list {\n+                            if let Some(name) = inner_mi.name() {\n+                                helpers.push(name);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                om.proc_macros.push(ProcMacro {\n+                    name,\n+                    id: item.id,\n+                    kind,\n+                    helpers,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                    stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n+                });\n+            }\n+            None => {\n+                om.fns.push(Function {\n+                    id: item.id,\n+                    vis: item.vis.clone(),\n+                    stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n+                    attrs: item.attrs.clone(),\n+                    decl: fd.clone(),\n+                    name,\n+                    whence: item.span,\n+                    generics: gen.clone(),\n+                    header,\n+                    body,\n+                });\n+            }\n         }\n     }\n \n@@ -425,7 +477,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             hir::ItemKind::Union(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n             hir::ItemKind::Fn(ref fd, header, ref gen, body) =>\n-                om.fns.push(self.visit_fn(item, name, &**fd, header, gen, body)),\n+                self.visit_fn(om, item, name, &**fd, header, gen, body),\n             hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),"}, {"sha": "e263db24fc2c80cf9b429c2d4e150e6952bbc3f1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1204,8 +1204,8 @@ pub trait Write {\n pub trait Seek {\n     /// Seek to an offset, in bytes, in a stream.\n     ///\n-    /// A seek beyond the end of a stream is allowed, but implementation\n-    /// defined.\n+    /// A seek beyond the end of a stream is allowed, but behavior is defined\n+    /// by the implementation.\n     ///\n     /// If the seek operation completed successfully,\n     /// this method returns the new position from the start of the stream."}, {"sha": "f79c986cc89e454603eb3aa283a45d97c09461f4", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -517,6 +517,7 @@ pub fn update_count_then_panic(msg: Box<dyn Any + Send>) -> ! {\n }\n \n /// A private no-mangle function on which to slap yer breakpoints.\n+#[inline(never)]\n #[no_mangle]\n #[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints\n pub fn rust_panic(mut msg: &mut dyn BoxMeUp) -> ! {"}, {"sha": "9ed628e2ed337d50e16e02073a342810f52cebbd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1885,6 +1885,8 @@ pub struct Mod {\n     /// to the last token in the external file.\n     pub inner: Span,\n     pub items: Vec<P<Item>>,\n+    /// For `mod foo;` inline is false, for `mod foo { .. }` it is true.\n+    pub inline: bool,\n }\n \n /// Foreign module declaration."}, {"sha": "a9ce23655777956dd32592f668dfb7e6307eccb8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -90,6 +90,7 @@ impl<'a> StripUnconfigured<'a> {\n             parser.expect(&token::Comma)?;\n             let lo = parser.span.lo();\n             let (path, tokens) = parser.parse_meta_item_unrestricted()?;\n+            parser.eat(&token::Comma); // Optional trailing comma\n             parser.expect(&token::CloseDelim(token::Paren))?;\n             Ok((cfg, path, tokens, parser.prev_span.with_lo(lo)))\n         }) {"}, {"sha": "6210003a40da41d1e63fb64a5e4f41a94ee75253", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1101,6 +1101,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             ast::ItemKind::Mod(ast::Mod {\n                 inner: inner_span,\n                 items,\n+                inline: true\n             })\n         )\n     }"}, {"sha": "52322e98d46f9cd0e7e3e57b3b0e98a7fe14967a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -303,6 +303,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 krate.module = ast::Mod {\n                     inner: orig_mod_span,\n                     items: vec![],\n+                    inline: true,\n                 };\n             },\n             _ => unreachable!(),"}, {"sha": "95a2298ca757db404c30d156b2e09e0e37db0cdd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1044,10 +1044,11 @@ pub fn noop_fold_fn_header<T: Folder>(mut header: FnHeader, folder: &mut T) -> F\n     header\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, items, inline}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n         items: items.move_flat_map(|x| folder.fold_item(x)),\n+        inline: inline,\n     }\n }\n \n@@ -1077,6 +1078,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n         None => (ast::Mod {\n             inner: span,\n             items: vec![],\n+            inline: true,\n         }, vec![], span)\n     };\n "}, {"sha": "5571a18b5962518ed1de26e47a55cbac4249fb06", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -6297,6 +6297,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::Mod {\n             inner: inner_lo.to(hi),\n             items,\n+            inline: true\n         })\n     }\n \n@@ -6334,6 +6335,7 @@ impl<'a> Parser<'a> {\n                     self.submod_path(id, &outer_attrs, id_span)?;\n                 let (module, mut attrs) =\n                     self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n+                // Record that we fetched the mod from an external file\n                 if warn {\n                     let attr = Attribute {\n                         id: attr::mk_attr_id(),\n@@ -6346,9 +6348,13 @@ impl<'a> Parser<'a> {\n                     attr::mark_known(&attr);\n                     attrs.push(attr);\n                 }\n-                Ok((id, module, Some(attrs)))\n+                Ok((id, ItemKind::Mod(module), Some(attrs)))\n             } else {\n-                let placeholder = ast::Mod { inner: syntax_pos::DUMMY_SP, items: Vec::new() };\n+                let placeholder = ast::Mod {\n+                    inner: syntax_pos::DUMMY_SP,\n+                    items: Vec::new(),\n+                    inline: false\n+                };\n                 Ok((id, ItemKind::Mod(placeholder), None))\n             }\n         } else {\n@@ -6548,7 +6554,7 @@ impl<'a> Parser<'a> {\n                     directory_ownership: DirectoryOwnership,\n                     name: String,\n                     id_sp: Span)\n-                    -> PResult<'a, (ast::ItemKind, Vec<Attribute> )> {\n+                    -> PResult<'a, (ast::Mod, Vec<Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n             let mut err = String::from(\"circular modules: \");\n@@ -6568,9 +6574,10 @@ impl<'a> Parser<'a> {\n         p0.cfg_mods = self.cfg_mods;\n         let mod_inner_lo = p0.span;\n         let mod_attrs = p0.parse_inner_attributes()?;\n-        let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n+        let mut m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n+        m0.inline = false;\n         self.sess.included_mod_stack.borrow_mut().pop();\n-        Ok((ast::ItemKind::Mod(m0), mod_attrs))\n+        Ok((m0, mod_attrs))\n     }\n \n     /// Parse a function declaration from a foreign module"}, {"sha": "f2acdb3f469d1e9b5f6587e749565ebaa409a8b9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -61,6 +61,7 @@ pub struct State<'a> {\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (dyn PpAnn+'a),\n+    is_expanded: bool\n }\n \n fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a> {\n@@ -72,6 +73,7 @@ fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a>\n         cur_cmnt: 0,\n         boxes: Vec::new(),\n         ann,\n+        is_expanded: false\n     }\n }\n \n@@ -133,14 +135,17 @@ impl<'a> State<'a> {\n             // If the code is post expansion, don't use the table of\n             // literals, since it doesn't correspond with the literals\n             // in the AST anymore.\n-            if is_expanded { None } else { Some(lits) })\n+            if is_expanded { None } else { Some(lits) },\n+            is_expanded\n+        )\n     }\n \n     pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write+'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>) -> State<'a> {\n+               literals: Option<Vec<comments::Literal>>,\n+               is_expanded: bool) -> State<'a> {\n         State {\n             s: pp::mk_printer(out, DEFAULT_COLUMNS),\n             cm: Some(cm),\n@@ -149,6 +154,7 @@ impl<'a> State<'a> {\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n+            is_expanded: is_expanded\n         }\n     }\n }\n@@ -1260,10 +1266,18 @@ impl<'a> State<'a> {\n             ast::ItemKind::Mod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_ident(item.ident)?;\n-                self.nbsp()?;\n-                self.bopen()?;\n-                self.print_mod(_mod, &item.attrs)?;\n-                self.bclose(item.span)?;\n+\n+                if _mod.inline || self.is_expanded {\n+                    self.nbsp()?;\n+                    self.bopen()?;\n+                    self.print_mod(_mod, &item.attrs)?;\n+                    self.bclose(item.span)?;\n+                } else {\n+                    self.s.word(\";\")?;\n+                    self.end()?; // end inner head-block\n+                    self.end()?; // end outer head-block\n+                }\n+\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;"}, {"sha": "9f554a90afbc4d7bcf5b87b38febcbdf77f35505", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -237,6 +237,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     })).collect();\n \n     let reexport_mod = ast::Mod {\n+        inline: true,\n         inner: DUMMY_SP,\n         items,\n     };"}, {"sha": "67fd847a2ae9197790a0d2a71917e0cec74d84fb", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -87,7 +87,7 @@ scoped_thread_local!(pub static GLOBALS: Globals);\n #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n pub enum FileName {\n     Real(PathBuf),\n-    /// e.g. \"std\" macros\n+    /// A macro.  This includes the full name of the macro, so that there are no clashes.\n     Macros(String),\n     /// call to `quote!`\n     QuoteExpansion,"}, {"sha": "06f75d981e3d6c8405503942e9da1734636acfce", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -373,7 +373,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool DataSections,\n     bool TrapUnreachable,\n     bool Singlethread,\n-    bool AsmComments) {\n+    bool AsmComments,\n+    bool EmitStackSizeSection) {\n \n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n@@ -411,6 +412,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   }\n \n #if LLVM_VERSION_GE(6, 0)\n+  Options.EmitStackSizeSection = EmitStackSizeSection;\n+\n   Optional<CodeModel::Model> CM;\n #else\n   CodeModel::Model CM = CodeModel::Model::Default;"}, {"sha": "f1ab1d4ddfa476d8fb0006583f4a3b7521eac4e6", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -426,6 +426,11 @@ extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString,\n                              HasSideEffects, IsAlignStack, fromRust(Dialect)));\n }\n \n+extern \"C\" bool LLVMRustInlineAsmVerify(LLVMTypeRef Ty,\n+                                          char *Constraints) {\n+  return InlineAsm::Verify(unwrap<FunctionType>(Ty), Constraints);\n+}\n+\n extern \"C\" void LLVMRustAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm) {\n   unwrap(M)->appendModuleInlineAsm(StringRef(Asm));\n }"}, {"sha": "887c43c6761e86bbc739f0525c2912561c18dae9", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -48,6 +48,16 @@ pub fn align64(i : i32) -> Align64 {\n     a64\n }\n \n+// For issue 54028: make sure that we are specifying the correct alignment for fields of aligned\n+// structs\n+// CHECK-LABEL: @align64_load\n+#[no_mangle]\n+pub fn align64_load(a: Align64) -> i32 {\n+// CHECK: [[FIELD:%.*]] = bitcast %Align64* %{{.*}} to i32*\n+// CHECK: {{%.*}} = load i32, i32* [[FIELD]], align 64\n+    a.0\n+}\n+\n // CHECK-LABEL: @nested64\n #[no_mangle]\n pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {"}, {"sha": "8feb10b57577ca1b1595685b88ba321653985621", "filename": "src/test/codegen/issue-32364.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fcodegen%2Fissue-32364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fcodegen%2Fissue-32364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-32364.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-arm\n-// ignore-aarch64\n+// Test that `extern \"stdcall\"` is properly translated.\n+\n+// only-x86\n \n // compile-flags: -C no-prepopulate-passes\n "}, {"sha": "94377421c0b0c9927a039b26970371581d959315", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE Instantiating an empty enum is UB. This test may break in the future.\n-\n // LLDB can't handle zero-sized values\n // ignore-lldb\n \n@@ -27,11 +25,8 @@\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n-#![feature(maybe_uninit)]\n #![omit_gdb_pretty_printer_section]\n \n-use std::mem::MaybeUninit;\n-\n enum ANilEnum {}\n enum AnotherNilEnum {}\n \n@@ -40,8 +35,8 @@ enum AnotherNilEnum {}\n // The error from gdbr is expected since nil enums are not supposed to exist.\n fn main() {\n     unsafe {\n-        let first: ANilEnum = MaybeUninit::uninitialized().into_inner();\n-        let second: AnotherNilEnum = MaybeUninit::uninitialized().into_inner();\n+        let first: ANilEnum = ::std::mem::zeroed();\n+        let second: AnotherNilEnum = ::std::mem::zeroed();\n \n         zzz(); // #break\n     }"}, {"sha": "0087c3c455897b85df0731de818488d4dc21a330", "filename": "src/test/pretty/issue_12590_a.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue_12590_a.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+\n+// The next line should not be expanded\n+\n+mod issue_12590_b;\n+\n+fn main() { }"}, {"sha": "ebb6310b047648f48b833f52c28666ba3137e876", "filename": "src/test/pretty/issue_12590_b.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue_12590_b.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Second part of two file test\n+fn b() { }\n+\n+fn main() { }"}, {"sha": "7e057406d830f5ecb74f87d952d6a4df9f3bd6e7", "filename": "src/test/pretty/issue_12590_c.pp", "status": "renamed", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_c.pp", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_c.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue_12590_c.pp?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -1,4 +1,10 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+#![feature(prelude_import)]\n+#![no_std]\n+#[prelude_import]\n+use ::std::prelude::v1::*;\n+#[macro_use]\n+extern crate std;\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,16 +14,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -O\n-#![crate_type=\"lib\"]\n-#![feature(maybe_uninit)]\n+// pretty-compare-only\n+// pretty-mode:expanded\n+// pp-exact:issue_12590_c.pp\n \n-use std::mem::MaybeUninit;\n+// The next line should be expanded\n \n-// Boxing a `MaybeUninit` value should not copy junk from the stack\n-#[no_mangle]\n-pub fn box_uninitialized() -> Box<MaybeUninit<usize>> {\n-    // CHECK-LABEL: @box_uninitialized\n-    // CHECK-NOT: store\n-    Box::new(MaybeUninit::uninitialized())\n+mod issue_12590_b {\n+\n+    fn b() { }\n+    fn main() { }\n }\n+fn main() { }", "previous_filename": "src/test/codegen/box-maybe-uninit.rs"}, {"sha": "e3db870ae4f487a833cf9fa2868cff7b0a76bc89", "filename": "src/test/pretty/issue_12590_c.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Fpretty%2Fissue_12590_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue_12590_c.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pretty-compare-only\n+// pretty-mode:expanded\n+// pp-exact:issue_12590_c.pp\n+\n+// The next line should be expanded\n+\n+mod issue_12590_b;\n+\n+fn main() { }"}, {"sha": "c2f643ce24c41df18ef382784634ec0d5a68ac9c", "filename": "src/test/run-make-fulldeps/emit-stack-sizes/Makefile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-make-fulldeps%2Femit-stack-sizes%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-make-fulldeps%2Femit-stack-sizes%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Femit-stack-sizes%2FMakefile?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,31 @@\n+-include ../tools.mk\n+\n+# This feature only works when the output object format is ELF so we ignore\n+# macOS and Windows\n+ifdef IS_WINDOWS\n+# Do nothing on Windows.\n+all:\n+\texit 0\n+else ifneq (,$(filter $(TARGET),i686-apple-darwin x86_64-apple-darwin))\n+# Do nothing on macOS.\n+all:\n+\texit 0\n+else\n+# check that the .stack_sizes section is generated\n+# this test requires LLVM >= 6.0.0\n+vers = $(shell $(RUSTC) -Vv)\n+ifneq (,$(findstring LLVM version: 3,$(vers)))\n+all:\n+\texit 0\n+else ifneq (,$(findstring LLVM version: 4,$(vers)))\n+all:\n+\texit 0\n+else ifneq (,$(findstring LLVM version: 5,$(vers)))\n+all:\n+\texit 0\n+else\n+all:\n+\t$(RUSTC) -C opt-level=3 -Z emit-stack-sizes --emit=obj foo.rs\n+\tsize -A $(TMPDIR)/foo.o | $(CGREP) .stack_sizes\n+endif\n+endif"}, {"sha": "6c81b63963a1c22c7388a0bc8007e7121d9d469b", "filename": "src/test/run-make-fulldeps/emit-stack-sizes/foo.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-make-fulldeps%2Femit-stack-sizes%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-make-fulldeps%2Femit-stack-sizes%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Femit-stack-sizes%2Ffoo.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn foo() {}"}, {"sha": "a3f05a01c5ad0d47bbbd13d37ddcea50e5a09aac", "filename": "src/test/run-pass/allocator/auxiliary/custom-as-global.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/allocator/auxiliary/custom-as-global.rs"}, {"sha": "b17464e04190f459bfebe1101c1360e3c714b71b", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/allocator/auxiliary/custom.rs"}, {"sha": "e75a432710df2fe79d4e7ded0c2e888135d6fc10", "filename": "src/test/run-pass/allocator/auxiliary/helper.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fhelper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fhelper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fhelper.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/allocator/auxiliary/helper.rs"}, {"sha": "9617f7d4685d7b89a824ba221b64a091c49b9692", "filename": "src/test/run-pass/allocator/custom.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/allocator/custom.rs"}, {"sha": "8b9e1e329f7b90245e25985c80e1ad993225a39e", "filename": "src/test/run-pass/allocator/xcrate-use.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/allocator/xcrate-use.rs"}, {"sha": "2e52f28d3117a20f61beecc0bf8e097d5cf64cd8", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/allocator/xcrate-use2.rs"}, {"sha": "4029a270c8d18c397743328b204018a7bdbe9c97", "filename": "src/test/run-pass/array-slice-vec/arr_cycle.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Farr_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Farr_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Farr_cycle.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/arr_cycle.rs"}, {"sha": "2bc8bf9796e829d301e4bef629ec918f6de500b5", "filename": "src/test/run-pass/array-slice-vec/array_const_index-1.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Farray_const_index-1.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n #![allow(stable_features)]\n \n #![feature(const_indexing)]", "previous_filename": "src/test/ui/run-pass/array-slice-vec/array_const_index-1.rs"}, {"sha": "5d6cc5f686e7fbfefab0aad3437f6c4d20be7bea", "filename": "src/test/run-pass/array-slice-vec/box-of-array-of-drop-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fbox-of-array-of-drop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fbox-of-array-of-drop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fbox-of-array-of-drop-1.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/box-of-array-of-drop-1.rs"}, {"sha": "d2dedc4602aaea020b8ec165c431ded13cdbeacd", "filename": "src/test/run-pass/array-slice-vec/box-of-array-of-drop-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fbox-of-array-of-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fbox-of-array-of-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fbox-of-array-of-drop-2.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/box-of-array-of-drop-2.rs"}, {"sha": "d78bc0b0072d3f4ffc0efeb71aa7bc8147271e35", "filename": "src/test/run-pass/array-slice-vec/cast-in-array-size.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcast-in-array-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcast-in-array-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcast-in-array-size.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/cast-in-array-size.rs"}, {"sha": "998a1d9ee27857982f09577405406c3f3f8e9522", "filename": "src/test/run-pass/array-slice-vec/check-static-mut-slices.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcheck-static-mut-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcheck-static-mut-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcheck-static-mut-slices.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n \n // Checks that mutable static items can have mutable slices\n ", "previous_filename": "src/test/ui/run-pass/array-slice-vec/check-static-mut-slices.rs"}, {"sha": "6627095c32bccbbb498dc233899f80b5167abbb5", "filename": "src/test/run-pass/array-slice-vec/check-static-slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcheck-static-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcheck-static-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcheck-static-slice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/check-static-slice.rs"}, {"sha": "917683e4eeb93b3439b48b6d1c6d46807738926b", "filename": "src/test/run-pass/array-slice-vec/copy-out-of-array-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcopy-out-of-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcopy-out-of-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fcopy-out-of-array-1.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/copy-out-of-array-1.rs"}, {"sha": "17620f62be6a06686658f5555fc5ac2e7db6c7d9", "filename": "src/test/run-pass/array-slice-vec/destructure-array-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fdestructure-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fdestructure-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fdestructure-array-1.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/destructure-array-1.rs"}, {"sha": "7411d5743212d0b84caca106892db79b6b8a3155", "filename": "src/test/run-pass/array-slice-vec/empty-mutable-vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fempty-mutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fempty-mutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fempty-mutable-vec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/empty-mutable-vec.rs"}, {"sha": "768229aafbf57c37d89dea5f08f3a0fdc746bc41", "filename": "src/test/run-pass/array-slice-vec/estr-slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/estr-slice.rs"}, {"sha": "b1a55a04a2499c96c0844ae5d2c8b7330188aa63", "filename": "src/test/run-pass/array-slice-vec/evec-slice.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fevec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fevec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fevec-slice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_assignments)]\n \n pub fn main() {\n     let x : &[isize] = &[1,2,3,4,5];", "previous_filename": "src/test/ui/run-pass/array-slice-vec/evec-slice.rs"}, {"sha": "09492e37e28b84e882e543f2b6744678c46fd8b5", "filename": "src/test/run-pass/array-slice-vec/fixed_length_copy.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Ffixed_length_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Ffixed_length_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Ffixed_length_copy.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/fixed_length_copy.rs"}, {"sha": "27b4e68e771c8b2bc7beeaac80d429ab5040b990", "filename": "src/test/run-pass/array-slice-vec/huge-largest-array.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fhuge-largest-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fhuge-largest-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fhuge-largest-array.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/huge-largest-array.rs"}, {"sha": "2f3efef56369d832a6f4df060d08ad39f930bbfc", "filename": "src/test/run-pass/array-slice-vec/ivec-pass-by-value.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fivec-pass-by-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fivec-pass-by-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fivec-pass-by-value.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/ivec-pass-by-value.rs"}, {"sha": "49dc348952ba16ca8be98dd8a453503379c2f363", "filename": "src/test/run-pass/array-slice-vec/mutability-inherits-through-fixed-length-vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fmutability-inherits-through-fixed-length-vec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/mutability-inherits-through-fixed-length-vec.rs"}, {"sha": "dc2548ad53c4d9398b9c2966c54d409480c5b468", "filename": "src/test/run-pass/array-slice-vec/mutable-alias-vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fmutable-alias-vec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/mutable-alias-vec.rs"}, {"sha": "62bcc5f72543fa3d2c6f261d7b483bd565a47b65", "filename": "src/test/run-pass/array-slice-vec/nested-vec-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-1.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/nested-vec-1.rs"}, {"sha": "4af2350cc369b0d051e54b68c71058f71e85b4d9", "filename": "src/test/run-pass/array-slice-vec/nested-vec-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-2.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/nested-vec-2.rs"}, {"sha": "dc3146a2b351760c5b9ed4ca849f8698066b3f7b", "filename": "src/test/run-pass/array-slice-vec/nested-vec-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnested-vec-3.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/nested-vec-3.rs"}, {"sha": "268fa5c4b59ac22c2a295cb56c1f6e3716ccae04", "filename": "src/test/run-pass/array-slice-vec/new-style-fixed-length-vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnew-style-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnew-style-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fnew-style-fixed-length-vec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/new-style-fixed-length-vec.rs"}, {"sha": "76302b92ed0349f109549c1f0fe2f8ce8014e5dc", "filename": "src/test/run-pass/array-slice-vec/rcvr-borrowed-to-slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Frcvr-borrowed-to-slice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/rcvr-borrowed-to-slice.rs"}, {"sha": "d706be4c3367634b2c31d8a39381fab44761822e", "filename": "src/test/run-pass/array-slice-vec/repeated-vector-syntax.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Frepeated-vector-syntax.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/repeated-vector-syntax.rs"}, {"sha": "dda4ce9f227b1195738aa5f759a19c3b52cf6070", "filename": "src/test/run-pass/array-slice-vec/show-boxed-slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fshow-boxed-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fshow-boxed-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fshow-boxed-slice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/show-boxed-slice.rs"}, {"sha": "1f71ceac04f9dc09842f8d888f9be06a1d8f1a73", "filename": "src/test/run-pass/array-slice-vec/slice-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-2.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/slice-2.rs"}, {"sha": "671246f6a63a2f6078ea34849d49ce772e62fdc4", "filename": "src/test/run-pass/array-slice-vec/slice-of-zero-size-elements.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-of-zero-size-elements.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/slice-of-zero-size-elements.rs"}, {"sha": "b9d816acaa2284ee5858cbef3b3f8bafc8b85a94", "filename": "src/test/run-pass/array-slice-vec/slice-panic-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-panic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-panic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-panic-1.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/slice-panic-1.rs"}, {"sha": "787d10b042f8c035a8fc34c2336f8e34dc77f6e8", "filename": "src/test/run-pass/array-slice-vec/slice-panic-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-panic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-panic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice-panic-2.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/slice-panic-2.rs"}, {"sha": "b85cb97b6bafdff9ee70ec784be5076eaec83af1", "filename": "src/test/run-pass/array-slice-vec/slice.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n \n // Test slicing sugar.\n ", "previous_filename": "src/test/ui/run-pass/array-slice-vec/slice.rs"}, {"sha": "081b06bea5c17fcfa141a2342c4abd1ecdd0b002", "filename": "src/test/run-pass/array-slice-vec/slice_binary_search.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice_binary_search.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice_binary_search.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fslice_binary_search.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/slice_binary_search.rs"}, {"sha": "5cf52006f3c2cda65009c259978e53a8317c75e2", "filename": "src/test/run-pass/array-slice-vec/variance-vec-covariant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvariance-vec-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvariance-vec-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvariance-vec-covariant.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/variance-vec-covariant.rs"}, {"sha": "7c734d8d6a2bb2035cde8c177d4a054919200740", "filename": "src/test/run-pass/array-slice-vec/vec-concat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-concat.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-concat.rs"}, {"sha": "6421b69d22e3fa2f2a3bdb20422417ff949705f9", "filename": "src/test/run-pass/array-slice-vec/vec-dst.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-dst.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-dst.rs"}, {"sha": "a7b867941323fe7a0b051a7ce173b5372167dccc", "filename": "src/test/run-pass/array-slice-vec/vec-fixed-length.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-fixed-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-fixed-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-fixed-length.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-fixed-length.rs"}, {"sha": "e783a799c056201bcaab8a24f34a3b535d8406d9", "filename": "src/test/run-pass/array-slice-vec/vec-growth.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-growth.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-growth.rs"}, {"sha": "234d63672d943435734b9e63b889a840dbbddcf9", "filename": "src/test/run-pass/array-slice-vec/vec-late-init.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-late-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-late-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-late-init.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_mut)]\n \n \n pub fn main() {", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-late-init.rs"}, {"sha": "509167413b6f4b67825567f0c579c8c5b4c18013", "filename": "src/test/run-pass/array-slice-vec/vec-macro-no-std.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-no-std.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-macro-no-std.rs"}, {"sha": "36c8b7cffabec47f85fcc44c6cb06686ba27b20a", "filename": "src/test/run-pass/array-slice-vec/vec-macro-repeat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-repeat.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-macro-repeat.rs"}, {"sha": "8ccf22e62887cd2942e55e86ee9003b9bed7e598", "filename": "src/test/run-pass/array-slice-vec/vec-macro-rvalue-scope.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-rvalue-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-rvalue-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-rvalue-scope.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-macro-rvalue-scope.rs"}, {"sha": "aa7d96a5e5a2ae99830345596f56189ad9e6165a", "filename": "src/test/run-pass/array-slice-vec/vec-macro-with-brackets.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-with-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-with-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-with-brackets.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n \n // pretty-expanded FIXME #23616\n ", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-macro-with-brackets.rs"}, {"sha": "046d634b19d467a1025b0875d667d804402a5d3f", "filename": "src/test/run-pass/array-slice-vec/vec-macro-with-trailing-comma.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-with-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-with-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-macro-with-trailing-comma.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-macro-with-trailing-comma.rs"}, {"sha": "b5cefb48ce79660dc33209cab9ad09b803c180f0", "filename": "src/test/run-pass/array-slice-vec/vec-matching-autoslice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-autoslice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-matching-autoslice.rs"}, {"sha": "7bfecdd2c7f3cb21554f30478033ab90407d602c", "filename": "src/test/run-pass/array-slice-vec/vec-matching-fixed.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-fixed.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-matching-fixed.rs"}, {"sha": "b1aa7f1b70c86d0c644e9a61611244cf9f9aacd3", "filename": "src/test/run-pass/array-slice-vec/vec-matching-fold.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-fold.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-matching-fold.rs"}, {"sha": "3d4a84aa5c3c0ccb1f021065ff58db6df8a7fb97", "filename": "src/test/run-pass/array-slice-vec/vec-matching-legal-tail-element-borrow.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n \n #![feature(slice_patterns)]\n ", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-matching-legal-tail-element-borrow.rs"}, {"sha": "8d1ef6f755a356439997869754a2ab58a0f85284", "filename": "src/test/run-pass/array-slice-vec/vec-matching.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-matching.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-matching.rs"}, {"sha": "360568048c0899345e8970950c608d7df509ff4c", "filename": "src/test/run-pass/array-slice-vec/vec-push.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-push.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-push.rs"}, {"sha": "650de32fe6146c469bfee741e7ed612abb9ee5bb", "filename": "src/test/run-pass/array-slice-vec/vec-repeat-with-cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-repeat-with-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-repeat-with-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-repeat-with-cast.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-repeat-with-cast.rs"}, {"sha": "189d5a38ae3cac9584234de0aafafbbd48c43a1b", "filename": "src/test/run-pass/array-slice-vec/vec-slice-drop.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-slice-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-slice-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-slice-drop.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-slice-drop.rs"}, {"sha": "8ad662f0c6348ab9d472c105dbcbeec37e023900", "filename": "src/test/run-pass/array-slice-vec/vec-slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-slice.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-slice.rs"}, {"sha": "46a882a2ae1b4fac1134b8022fa92b6715ab60c0", "filename": "src/test/run-pass/array-slice-vec/vec-tail-matching.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-tail-matching.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-tail-matching.rs"}, {"sha": "4facc0e6892e6d67f6ecf52947756689ebb04ef1", "filename": "src/test/run-pass/array-slice-vec/vec-to_str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec-to_str.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec-to_str.rs"}, {"sha": "34a8e125a5ceb9530a26dbef02276d47c6fcfe22", "filename": "src/test/run-pass/array-slice-vec/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec.rs"}, {"sha": "3222b0e789d0c96120ceb069ad5fc9f22c432d13", "filename": "src/test/run-pass/array-slice-vec/vec_cycle.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec_cycle.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec_cycle.rs"}, {"sha": "355f9d3e40ed6d345ddb8dcf0a1a86528868db51", "filename": "src/test/run-pass/array-slice-vec/vec_cycle_wrapped.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec_cycle_wrapped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec_cycle_wrapped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvec_cycle_wrapped.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vec_cycle_wrapped.rs"}, {"sha": "0b09545c0aa64cc4401e2277a1818b80d6ba474d", "filename": "src/test/run-pass/array-slice-vec/vector-no-ann-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvector-no-ann-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvector-no-ann-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Fvector-no-ann-2.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/array-slice-vec/vector-no-ann-2.rs"}, {"sha": "3ef8e6c2478c8ccc3629ab374dbdc02e51f1cd6d", "filename": "src/test/run-pass/associated-consts/associated-const-const-eval.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-const-eval.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-const-eval.rs"}, {"sha": "c0f1d93c25398b6a0bcb2c712cf570befe201d3e", "filename": "src/test/run-pass/associated-consts/associated-const-cross-crate-const-eval.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate-const-eval.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-cross-crate-const-eval.rs"}, {"sha": "7d85c7021ab63152de965815cd3d8e7182da2dd6", "filename": "src/test/run-pass/associated-consts/associated-const-cross-crate-defaults.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate-defaults.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-cross-crate-defaults.rs"}, {"sha": "0f1bde4b4db746c9c6485da3eecd0cf82bcdd062", "filename": "src/test/run-pass/associated-consts/associated-const-cross-crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-cross-crate.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-cross-crate.rs"}, {"sha": "089bf07b9c78488e32df6931dcddc98d143d62d0", "filename": "src/test/run-pass/associated-consts/associated-const-in-global-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-in-global-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-in-global-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-in-global-const.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-in-global-const.rs"}, {"sha": "60b794015f9c550c67a1bd2e323405196f4ae5e8", "filename": "src/test/run-pass/associated-consts/associated-const-inherent-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-inherent-impl.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-inherent-impl.rs"}, {"sha": "de9edfc679e99a2c07b0d70add30eb74a584fd91", "filename": "src/test/run-pass/associated-consts/associated-const-marks-live-code.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-marks-live-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-marks-live-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-marks-live-code.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-marks-live-code.rs"}, {"sha": "9fbce1cebf3181642b1b23aad4bd25bb976cb0fa", "filename": "src/test/run-pass/associated-consts/associated-const-match-patterns.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-match-patterns.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-match-patterns.rs"}, {"sha": "c62e073a6a711fa97afcab5c951d46404de46d81", "filename": "src/test/run-pass/associated-consts/associated-const-outer-ty-refs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-outer-ty-refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-outer-ty-refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-outer-ty-refs.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-outer-ty-refs.rs"}, {"sha": "0e225d7117e6c2989cf4a80387b9a2cb4887a526", "filename": "src/test/run-pass/associated-consts/associated-const-overwrite-default.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-overwrite-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-overwrite-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-overwrite-default.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-overwrite-default.rs"}, {"sha": "8c11ae69ded769f5b26e963413bf5e2e99e3dd4a", "filename": "src/test/run-pass/associated-consts/associated-const-public-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-public-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-public-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-public-impl.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-public-impl.rs"}, {"sha": "b425d759b03f495734ae1de57997a52aa62a7046", "filename": "src/test/run-pass/associated-consts/associated-const-range-match-patterns.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n \n struct Foo;\n ", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-range-match-patterns.rs"}, {"sha": "ed02644c6a11901e8baed132372eac35df6804c0", "filename": "src/test/run-pass/associated-consts/associated-const-resolution-order.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-resolution-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-resolution-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-resolution-order.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-resolution-order.rs"}, {"sha": "52d9574edde284e8b487f4879e05a8b2aadf0d9b", "filename": "src/test/run-pass/associated-consts/associated-const-self-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-self-type.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-self-type.rs"}, {"sha": "37407b6bf9f9863abdaf343eec8542297cc0028b", "filename": "src/test/run-pass/associated-consts/associated-const-type-parameters.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-type-parameters.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-type-parameters.rs"}, {"sha": "6269222fb8e9e249bf727bdc951279a52dd55aa9", "filename": "src/test/run-pass/associated-consts/associated-const-ufcs-infer-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-ufcs-infer-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-ufcs-infer-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-ufcs-infer-trait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-ufcs-infer-trait.rs"}, {"sha": "623949b2418c1aceb7829f3f9e09dd67000c88dd", "filename": "src/test/run-pass/associated-consts/associated-const-use-default.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-use-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-use-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-use-default.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-use-default.rs"}, {"sha": "80848e5653fb544aafb0e1487d7fa151b9fe173a", "filename": "src/test/run-pass/associated-consts/associated-const-use-impl-of-same-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-use-impl-of-same-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-use-impl-of-same-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-use-impl-of-same-trait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const-use-impl-of-same-trait.rs"}, {"sha": "c20025c385ac49589eba89f22c0efda8b0f99ed4", "filename": "src/test/run-pass/associated-consts/associated-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/associated-const.rs"}, {"sha": "e4cada40db3c99c800dd8f90c9eac5656167e380", "filename": "src/test/run-pass/associated-consts/auxiliary/associated-const-cc-lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fauxiliary%2Fassociated-const-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fauxiliary%2Fassociated-const-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fauxiliary%2Fassociated-const-cc-lib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/auxiliary/associated-const-cc-lib.rs"}, {"sha": "734e57a774d87935a50b08162effe599960a69e0", "filename": "src/test/run-pass/associated-consts/auxiliary/empty-struct.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fauxiliary%2Fempty-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fauxiliary%2Fempty-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fauxiliary%2Fempty-struct.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-consts/auxiliary/empty-struct.rs"}, {"sha": "3628f9ce183f8ebe0ec9b0aad9ae48d45b7df80c", "filename": "src/test/run-pass/associated-types/associated-types-basic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-basic.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-basic.rs"}, {"sha": "63ac60e62d91fd68c12c41966f51ed6558b35c44", "filename": "src/test/run-pass/associated-types/associated-types-binding-in-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-binding-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-binding-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-binding-in-trait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-binding-in-trait.rs"}, {"sha": "7b735520efb2d6f49368322d327426d90a2d75ab", "filename": "src/test/run-pass/associated-types/associated-types-binding-in-where-clause.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-binding-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-binding-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-binding-in-where-clause.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-binding-in-where-clause.rs"}, {"sha": "56ce378da65fbb09e075f7ab98f12e8c7d585206", "filename": "src/test/run-pass/associated-types/associated-types-bound.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-bound.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-bound.rs"}, {"sha": "282e44ed42b69da7ead0aeb5c86cd47b1dda8421", "filename": "src/test/run-pass/associated-types/associated-types-cc.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-cc.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // aux-build:associated-types-cc-lib.rs\n \n // Test that we are able to reference cross-crate traits that employ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-cc.rs"}, {"sha": "a795ee2c5ef05441f2ab0e1469b9690ee8fc7627", "filename": "src/test/run-pass/associated-types/associated-types-conditional-dispatch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-conditional-dispatch.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-conditional-dispatch.rs"}, {"sha": "3581a6c43888db613df9d4c60945fc1aa5d245c4", "filename": "src/test/run-pass/associated-types/associated-types-constant-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-constant-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-constant-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-constant-type.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-constant-type.rs"}, {"sha": "4b8ceda9b811cac578fd92d9c251572545fde306", "filename": "src/test/run-pass/associated-types/associated-types-doubleendediterator-object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-doubleendediterator-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-doubleendediterator-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-doubleendediterator-object.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-doubleendediterator-object.rs"}, {"sha": "53d25b23b480a7019f3a614a03573492f9a016e8", "filename": "src/test/run-pass/associated-types/associated-types-duplicate-binding-in-env-hrtb.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-duplicate-binding-in-env-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-duplicate-binding-in-env-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-duplicate-binding-in-env-hrtb.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n // Check that we do not report ambiguities when equivalent predicates\n // (modulo bound lifetime names) appears in the environment\n // twice. Issue #21965.", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-duplicate-binding-in-env-hrtb.rs"}, {"sha": "b04da14795fcbebef77794a6bf395e2d860ac186", "filename": "src/test/run-pass/associated-types/associated-types-duplicate-binding-in-env.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-duplicate-binding-in-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-duplicate-binding-in-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-duplicate-binding-in-env.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n // Check that we do not report ambiguities when the same predicate\n // appears in the environment twice. Issue #21965.\n ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-duplicate-binding-in-env.rs"}, {"sha": "d21195c3d3a6cc6055320bd4a7baf72ea5619950", "filename": "src/test/run-pass/associated-types/associated-types-enum-field-named.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-enum-field-named.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-enum-field-named.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-enum-field-named.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-enum-field-named.rs"}, {"sha": "9a91a998201fe1255b179f7f02edcdca8f6aea3c", "filename": "src/test/run-pass/associated-types/associated-types-enum-field-numbered.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-enum-field-numbered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-enum-field-numbered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-enum-field-numbered.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-enum-field-numbered.rs"}, {"sha": "75fe2093da99ff76b56c05e80d444dd3b4c03d16", "filename": "src/test/run-pass/associated-types/associated-types-eq-obj.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-eq-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-eq-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-eq-obj.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-eq-obj.rs"}, {"sha": "fd2fade2f887dd1ef889da9096cbd49c1745e727", "filename": "src/test/run-pass/associated-types/associated-types-impl-redirect.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-impl-redirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-impl-redirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-impl-redirect.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n+#![allow(unused_mut)]\n+#![allow(unused_imports)]\n // Test how resolving a projection interacts with inference.  In this\n // case, we were eagerly unifying the type variable for the iterator\n // type with `I` from the where clause, ignoring the in-scope `impl`", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-impl-redirect.rs"}, {"sha": "a80350a596e5d41c17bacb1426dfcb517a33ac32", "filename": "src/test/run-pass/associated-types/associated-types-in-bound-type-arg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-bound-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-bound-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-bound-type-arg.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-in-bound-type-arg.rs"}, {"sha": "846dfcd2141c4fc2bafec41e68947420e36fdfb2", "filename": "src/test/run-pass/associated-types/associated-types-in-default-method.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-default-method.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-in-default-method.rs"}, {"sha": "555c74dd70a71cb72db18114245c44c9278bf620", "filename": "src/test/run-pass/associated-types/associated-types-in-fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-fn.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-in-fn.rs"}, {"sha": "d27c1dd296e498de5806a26c7b61e8aab99a14b9", "filename": "src/test/run-pass/associated-types/associated-types-in-impl-generics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-impl-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-impl-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-impl-generics.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-in-impl-generics.rs"}, {"sha": "f68ab8cd610cccec88f4208553a5172f00209ec0", "filename": "src/test/run-pass/associated-types/associated-types-in-inherent-method.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-inherent-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-inherent-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-in-inherent-method.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-in-inherent-method.rs"}, {"sha": "e2a87382fba9f8d8c3c92b8d0320b458b499b123", "filename": "src/test/run-pass/associated-types/associated-types-issue-20220.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-20220.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-20220.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-20220.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-issue-20220.rs"}, {"sha": "54f1d2e81260b240ba9bc483a7f3ea193085b181", "filename": "src/test/run-pass/associated-types/associated-types-issue-20371.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-20371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-20371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-20371.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-issue-20371.rs"}, {"sha": "c5baec7be00df1b835dac721a368297200fb967a", "filename": "src/test/run-pass/associated-types/associated-types-issue-21212.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-21212.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-21212.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-issue-21212.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // Regression test for #21212: an overflow occurred during trait\n // checking where normalizing `Self::Input` led to normalizing the\n // where clauses in the environment which in turn required normalizing", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-issue-21212.rs"}, {"sha": "eab66a9412917eaf48d85058fdfe07e199c352a2", "filename": "src/test/run-pass/associated-types/associated-types-iterator-binding.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-iterator-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-iterator-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-iterator-binding.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-iterator-binding.rs"}, {"sha": "73d075313ad5f395e72311a4e4a33026c9dcfb46", "filename": "src/test/run-pass/associated-types/associated-types-method.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-method.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-method.rs"}, {"sha": "af6f3da195e864c1cfe5811934a5a04b4f284227", "filename": "src/test/run-pass/associated-types/associated-types-nested-projections.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-nested-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-nested-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-nested-projections.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // Test that we can resolve nested projection types. Issue #20666.\n \n // pretty-expanded FIXME #23616", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-nested-projections.rs"}, {"sha": "4dd810d10565d75cd9d6994435c444dfc9826e6d", "filename": "src/test/run-pass/associated-types/associated-types-normalize-in-bounds-binding.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds-binding.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // Test that we normalize associated types that appear in a bound that\n // contains a binding. Issue #21664.\n ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-normalize-in-bounds-binding.rs"}, {"sha": "d534051267d918f233880e3788d0387b3ec15c18", "filename": "src/test/run-pass/associated-types/associated-types-normalize-in-bounds-ufcs.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds-ufcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds-ufcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds-ufcs.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // Test that we normalize associated types that appear in bounds; if\n // we didn't, the call to `self.split2()` fails to type check.\n ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-normalize-in-bounds-ufcs.rs"}, {"sha": "6651a0b53ac3cc7d1db5755795258c7dd08f31a7", "filename": "src/test/run-pass/associated-types/associated-types-normalize-in-bounds.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-in-bounds.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // Test that we normalize associated types that appear in bounds; if\n // we didn't, the call to `self.split2()` fails to type check.\n ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-normalize-in-bounds.rs"}, {"sha": "03d712b110dc2a0ff15b7c6c9e0d9488f27d3544", "filename": "src/test/run-pass/associated-types/associated-types-normalize-unifield-struct.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-unifield-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-unifield-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-normalize-unifield-struct.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-normalize-unifield-struct.rs"}, {"sha": "f21bbddc4ddc5489a797f63456ca1322c0d9e9f5", "filename": "src/test/run-pass/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-project-from-type-param-via-bound-in-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-project-from-type-param-via-bound-in-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-project-from-type-param-via-bound-in-where.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs"}, {"sha": "2f27cb1cd9ee9135d66ac87a84b0bce469908f5c", "filename": "src/test/run-pass/associated-types/associated-types-projection-bound-in-supertraits.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-bound-in-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-bound-in-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-bound-in-supertraits.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(unused_variables)]\n // Test that we correctly handle projection bounds appearing in the\n // supertrait list (and in conjunction with overloaded operators). In\n // this case, the `Result=Self` binding in the supertrait listing of", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-projection-bound-in-supertraits.rs"}, {"sha": "964eb886236058839b743f6d5460b91d7dd9ceae", "filename": "src/test/run-pass/associated-types/associated-types-projection-from-known-type-in-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-from-known-type-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-from-known-type-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-from-known-type-in-impl.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-projection-from-known-type-in-impl.rs"}, {"sha": "c0844e9076e357d6c2133b3f01fb2a226a982179", "filename": "src/test/run-pass/associated-types/associated-types-projection-in-object-type.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-object-type.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n // Corrected regression test for #20831. The original did not compile.\n // When fixed, it revealed another problem concerning projections that\n // appear in associated type bindings in object types, which were not", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-projection-in-object-type.rs"}, {"sha": "23c9fb89f393a73d34cb15c74c054718e591cb61", "filename": "src/test/run-pass/associated-types/associated-types-projection-in-supertrait.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-supertrait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n // Test that we are handle to correctly handle a projection type\n // that appears in a supertrait bound. Issue #20559.\n ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-projection-in-supertrait.rs"}, {"sha": "238f98086ceb1ba2a9b7dacb12a9bfcff92878da", "filename": "src/test/run-pass/associated-types/associated-types-projection-in-where-clause.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-where-clause.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n // Test a where clause that uses a non-normalized projection type.\n \n // pretty-expanded FIXME #23616", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-projection-in-where-clause.rs"}, {"sha": "f6951b48ae79525169c6fe5e204433417188438e", "filename": "src/test/run-pass/associated-types/associated-types-projection-to-unrelated-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-projection-to-unrelated-trait.rs"}, {"sha": "b3d5c3539894095dc6072d0154bc02b34de71b82", "filename": "src/test/run-pass/associated-types/associated-types-qualified-path-with-trait-with-type-parameters.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-qualified-path-with-trait-with-type-parameters.rs"}, {"sha": "e45766adc2ca2cc09768088f170cf9e3bd59d881", "filename": "src/test/run-pass/associated-types/associated-types-ref-from-struct.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-ref-from-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-ref-from-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-ref-from-struct.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-ref-from-struct.rs"}, {"sha": "02e1d74db47d41363e0d0b28bc15dda7dfa185a0", "filename": "src/test/run-pass/associated-types/associated-types-ref-in-struct-literal.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-ref-in-struct-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-ref-in-struct-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-ref-in-struct-literal.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-ref-in-struct-literal.rs"}, {"sha": "40864835d2e41400216212ffedebd2fadda8844f", "filename": "src/test/run-pass/associated-types/associated-types-region-erasure-issue-20582.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-region-erasure-issue-20582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-region-erasure-issue-20582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-region-erasure-issue-20582.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n // Regression test for #20582. This test caused an ICE related to\n // inconsistent region erasure in codegen.\n ", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-region-erasure-issue-20582.rs"}, {"sha": "b77f3fcd295fbc06d5e0226ad16a73ba0d18bada", "filename": "src/test/run-pass/associated-types/associated-types-resolve-lifetime.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-resolve-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-resolve-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-resolve-lifetime.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-resolve-lifetime.rs"}, {"sha": "18b05987715a4083ac725299f6f3c4ddf5d9201c", "filename": "src/test/run-pass/associated-types/associated-types-return.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-return.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-return.rs"}, {"sha": "8e9b2367fcd0917e0d05ca1b3b8f8d2f5a4ccbd5", "filename": "src/test/run-pass/associated-types/associated-types-simple.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-simple.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-simple.rs"}, {"sha": "c486e3463515e3268ac91131d35c07ce0e590273", "filename": "src/test/run-pass/associated-types/associated-types-stream.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-stream.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-stream.rs"}, {"sha": "384ec8ef44f0e0db2e5ae872da43c9ed7e0bdbef", "filename": "src/test/run-pass/associated-types/associated-types-struct-field-named.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-struct-field-named.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-struct-field-named.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-struct-field-named.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-struct-field-named.rs"}, {"sha": "54d0c8839a37847e9389765e0051ce9e667f8abd", "filename": "src/test/run-pass/associated-types/associated-types-struct-field-numbered.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-struct-field-numbered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-struct-field-numbered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-struct-field-numbered.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-struct-field-numbered.rs"}, {"sha": "c3c76eb1313a0d29e792844e57bd6abb11f43e2b", "filename": "src/test/run-pass/associated-types/associated-types-sugar-path.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-sugar-path.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(unused_imports)]\n // Test paths to associated types using the type-parameter-only sugar.\n \n use std::ops::Deref;", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-sugar-path.rs"}, {"sha": "5c03a6bbc027a4b3d7afbb1ea54e4f6a52bca1cb", "filename": "src/test/run-pass/associated-types/associated-types-where-clause-impl-ambiguity.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-where-clause-impl-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-where-clause-impl-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-where-clause-impl-ambiguity.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n // Test how resolving a projection interacts with inference.  In this\n // case, we were eagerly unifying the type variable for the iterator\n // type with `I` from the where clause, ignoring the in-scope `impl`", "previous_filename": "src/test/ui/run-pass/associated-types/associated-types-where-clause-impl-ambiguity.rs"}, {"sha": "175e8730cbcd3f8ccbed893ace5b4d98dd8d1641", "filename": "src/test/run-pass/associated-types/auxiliary/associated-types-cc-lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fauxiliary%2Fassociated-types-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fassociated-types%2Fauxiliary%2Fassociated-types-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fauxiliary%2Fassociated-types-cc-lib.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/associated-types/auxiliary/associated-types-cc-lib.rs"}, {"sha": "d984531b8bbf4b375ccbc7beaebe6c033471ff56", "filename": "src/test/run-pass/autoref-autoderef/auto-ref-bounded-ty-param.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref-bounded-ty-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref-bounded-ty-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref-bounded-ty-param.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/autoref-autoderef/auto-ref-bounded-ty-param.rs"}, {"sha": "6e665b0765680a48409760113f796b0b7e0f8e00", "filename": "src/test/run-pass/autoref-autoderef/auto-ref-sliceable.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref-sliceable.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/autoref-autoderef/auto-ref-sliceable.rs"}, {"sha": "afc79cce35e0e1f1b9f95b3bbcb670cff10c1ab8", "filename": "src/test/run-pass/autoref-autoderef/auto-ref.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fauto-ref.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/autoref-autoderef/auto-ref.rs"}, {"sha": "8ab2bf2f9b8919a6bd7b6d3e21a3dd5e954b7cdd", "filename": "src/test/run-pass/autoref-autoderef/autoderef-and-borrow-method-receiver.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-and-borrow-method-receiver.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // run-pass\n+#![allow(dead_code)]\n // pretty-expanded FIXME #23616\n \n struct Foo {", "previous_filename": "src/test/ui/run-pass/autoref-autoderef/autoderef-and-borrow-method-receiver.rs"}, {"sha": "8116a311eb458a5695819f1ad53418e5ced29ca0", "filename": "src/test/run-pass/autoref-autoderef/autoderef-method-on-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cc32fbb2506eff0090e894c1e8a46b62a8eb0b/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-method-on-trait.rs?ref=43cc32fbb2506eff0090e894c1e8a46b62a8eb0b", "previous_filename": "src/test/ui/run-pass/autoref-autoderef/autoderef-method-on-trait.rs"}]}