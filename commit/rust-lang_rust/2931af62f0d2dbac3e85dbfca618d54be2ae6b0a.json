{"sha": "2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MzFhZjYyZjBkMmRiYWMzZTg1ZGJmY2E2MThkNTRiZTJhZTZiMGE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T04:58:34Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-14T06:55:43Z"}, "message": "rustc_trans: access fields directly on CrateContext.", "tree": {"sha": "4e210a441cb3f8d5870b0726105700f836ddda5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e210a441cb3f8d5870b0726105700f836ddda5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "html_url": "https://github.com/rust-lang/rust/commit/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b3ac2142762b9246005080dce6bb8176936f3db", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3ac2142762b9246005080dce6bb8176936f3db", "html_url": "https://github.com/rust-lang/rust/commit/7b3ac2142762b9246005080dce6bb8176936f3db"}], "stats": {"total": 691, "additions": 298, "deletions": 393}, "files": [{"sha": "e1c8311651fd315a64a32b79194f074fed7e6876", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -649,9 +649,9 @@ pub struct FnType<'tcx> {\n impl<'a, 'tcx> FnType<'tcx> {\n     pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n-        let fn_ty = instance.ty(ccx.tcx());\n+        let fn_ty = instance.ty(ccx.tcx);\n         let sig = ty_fn_sig(ccx, fn_ty);\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+        let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n         FnType::new(ccx, sig, &[])\n     }\n \n@@ -681,7 +681,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 .unwrap_or_else(|| {\n                     bug!(\"FnType::new_vtable: non-pointer self {:?}\", self_arg)\n                 }).ty;\n-            let fat_ptr_ty = ccx.tcx().mk_mut_ptr(pointee);\n+            let fat_ptr_ty = ccx.tcx.mk_mut_ptr(pointee);\n             self_arg.layout = ccx.layout_of(fat_ptr_ty).field(ccx, 0);\n         }\n         fn_ty.adjust_for_abi(ccx, sig.abi);"}, {"sha": "709af224c9767b8d76d15540719173b3d6b38646", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -109,20 +109,20 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx(),\n+        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n         let val: llvm::ValueRef = C_i32(bcx.ccx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bcx.ccx.llcx(), &val, 1));\n+            llvm::LLVMMDNodeInContext(bcx.ccx.llcx, &val, 1));\n     }\n }\n \n pub fn trans_global_asm<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   ga: &hir::GlobalAsm) {\n     let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n     unsafe {\n-        llvm::LLVMRustAppendModuleInlineAsm(ccx.llmod(), asm.as_ptr());\n+        llvm::LLVMRustAppendModuleInlineAsm(ccx.llmod, asm.as_ptr());\n     }\n }"}, {"sha": "1f33681507951eac6644f84c3c5770988dd9f32e", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -103,7 +103,7 @@ pub fn set_probestack(ccx: &CrateContext, llfn: ValueRef) {\n /// attributes.\n pub fn from_fn_attrs(ccx: &CrateContext, llfn: ValueRef, id: DefId) {\n     use syntax::attr::*;\n-    let attrs = ccx.tcx().get_attrs(id);\n+    let attrs = ccx.tcx.get_attrs(id);\n     inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), &attrs));\n \n     set_frame_pointer_elimination(ccx, llfn);\n@@ -124,7 +124,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, llfn: ValueRef, id: DefId) {\n         }\n     }\n \n-    let target_features = ccx.tcx().target_features_enabled(id);\n+    let target_features = ccx.tcx.target_features_enabled(id);\n     if !target_features.is_empty() {\n         let val = CString::new(target_features.join(\",\")).unwrap();\n         llvm::AddFunctionAttrStringValue("}, {"sha": "c6e31298863e0eb2f06c121b7da4837bdddc6bc9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -101,7 +101,7 @@ pub struct StatRecorder<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n     pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n-        let istart = ccx.stats().borrow().n_llvm_insns;\n+        let istart = ccx.stats.borrow().n_llvm_insns;\n         StatRecorder {\n             ccx,\n             name: Some(name),\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n-            let mut stats = self.ccx.stats().borrow_mut();\n+            let mut stats = self.ccx.stats.borrow_mut();\n             let iend = stats.n_llvm_insns;\n             stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n             stats.n_fns += 1;\n@@ -194,7 +194,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 target: Ty<'tcx>,\n                                 old_info: Option<ValueRef>)\n                                 -> ValueRef {\n-    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n+    let (source, target) = ccx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n             C_usize(ccx, len.val.to_const_int().unwrap().to_u64().unwrap())\n@@ -206,7 +206,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n         (_, &ty::TyDynamic(ref data, ..)) => {\n-            let vtable_ptr = ccx.layout_of(ccx.tcx().mk_mut_ptr(target))\n+            let vtable_ptr = ccx.layout_of(ccx.tcx.mk_mut_ptr(target))\n                 .field(ccx, abi::FAT_PTR_EXTRA);\n             consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n                             vtable_ptr.llvm_type(ccx))\n@@ -421,7 +421,7 @@ pub fn call_memcpy(b: &Builder,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n+    let size = b.intcast(n_bytes, ccx.isize_ty, false);\n     let align = C_i32(ccx, align.abi() as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n@@ -458,7 +458,7 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n-        DefPathBasedNames::new(ccx.tcx(), true, true)\n+        DefPathBasedNames::new(ccx.tcx, true, true)\n             .push_def_path(instance.def_id(), &mut instance_name);\n         Some(StatRecorder::new(ccx, instance_name))\n     } else {\n@@ -470,16 +470,16 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = instance.ty(ccx.tcx());\n+    let fn_ty = instance.ty(ccx.tcx);\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+    let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n \n-    let lldecl = match ccx.instances().borrow().get(&instance) {\n+    let lldecl = match ccx.instances.borrow().get(&instance) {\n         Some(&val) => val,\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n \n-    ccx.stats().borrow_mut().n_closures += 1;\n+    ccx.stats.borrow_mut().n_closures += 1;\n \n     // The `uwtable` attribute according to LLVM is:\n     //\n@@ -502,7 +502,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n         attributes::emit_uwtable(lldecl, true);\n     }\n \n-    let mir = ccx.tcx().instance_mir(instance.def);\n+    let mir = ccx.tcx.instance_mir(instance.def);\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n@@ -525,14 +525,14 @@ pub fn set_link_section(ccx: &CrateContext,\n fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n     let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n-            (ccx.tcx().hir.local_def_id(id), span)\n+            (ccx.tcx.hir.local_def_id(id), span)\n         }\n         None => return,\n     };\n \n-    let instance = Instance::mono(ccx.tcx(), main_def_id);\n+    let instance = Instance::mono(ccx.tcx, main_def_id);\n \n-    if !ccx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n+    if !ccx.codegen_unit.contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n@@ -554,7 +554,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                        use_start_lang_item: bool) {\n         let llfty = Type::func(&[Type::c_int(ccx), Type::i8p(ccx).ptr_to()], &Type::c_int(ccx));\n \n-        let main_ret_ty = ccx.tcx().fn_sig(rust_main_def_id).output();\n+        let main_ret_ty = ccx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n         // then its return type cannot have\n         // late-bound regions, since late-bound\n@@ -582,12 +582,12 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         // Params from native main() used as args for rust start function\n         let param_argc = get_param(llfn, 0);\n         let param_argv = get_param(llfn, 1);\n-        let arg_argc = bld.intcast(param_argc, ccx.isize_ty(), true);\n+        let arg_argc = bld.intcast(param_argc, ccx.isize_ty, true);\n         let arg_argv = param_argv;\n \n         let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = ccx.tcx().require_lang_item(StartFnLangItem);\n-            let start_fn = callee::resolve_and_get_fn(ccx, start_def_id, ccx.tcx().mk_substs(\n+            let start_def_id = ccx.tcx.require_lang_item(StartFnLangItem);\n+            let start_fn = callee::resolve_and_get_fn(ccx, start_def_id, ccx.tcx.mk_substs(\n                 iter::once(Kind::from(main_ret_ty))));\n             (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()),\n                             arg_argc, arg_argv])\n@@ -1205,8 +1205,8 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Instantiate translation items without filling out definitions yet...\n         let ccx = CrateContext::new(tcx, cgu, &llmod_id);\n         let module = {\n-            let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx());\n+            let trans_items = ccx.codegen_unit\n+                                 .items_in_deterministic_order(ccx.tcx);\n             for &(trans_item, (linkage, visibility)) in &trans_items {\n                 trans_item.predefine(&ccx, linkage, visibility);\n             }\n@@ -1221,7 +1221,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             maybe_create_entry_wrapper(&ccx);\n \n             // Run replace-all-uses-with for statics that need it\n-            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+            for &(old_g, new_g) in ccx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n                     let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n@@ -1231,13 +1231,13 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // Create the llvm.used variable\n             // This variable has type [N x i8*] and is stored in the llvm.metadata section\n-            if !ccx.used_statics().borrow().is_empty() {\n+            if !ccx.used_statics.borrow().is_empty() {\n                 let name = CString::new(\"llvm.used\").unwrap();\n                 let section = CString::new(\"llvm.metadata\").unwrap();\n-                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics().borrow());\n+                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics.borrow());\n \n                 unsafe {\n-                    let g = llvm::LLVMAddGlobal(ccx.llmod(),\n+                    let g = llvm::LLVMAddGlobal(ccx.llmod,\n                                                 val_ty(array).to_ref(),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n@@ -1252,8 +1252,8 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             let llvm_module = ModuleLlvm {\n-                llcx: ccx.llcx(),\n-                llmod: ccx.llmod(),\n+                llcx: ccx.llcx,\n+                llmod: ccx.llmod,\n                 tm: create_target_machine(ccx.sess()),\n             };\n "}, {"sha": "b636b1e8a8613642503bc0a05ed8bd903870e6f5", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n             llvm::LLVMAppendBasicBlockInContext(\n-                ccx.llcx(),\n+                ccx.llcx,\n                 llfn,\n                 name.as_ptr()\n             )\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n-            llvm::LLVMCreateBuilderInContext(ccx.llcx())\n+            llvm::LLVMCreateBuilderInContext(ccx.llcx)\n         };\n         Builder {\n             llbuilder,\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.ccx.tcx()\n+        self.ccx.tcx\n     }\n \n     pub fn llfn(&self) -> ValueRef {\n@@ -102,10 +102,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n-            self.ccx.stats().borrow_mut().n_llvm_insns += 1;\n+            self.ccx.stats.borrow_mut().n_llvm_insns += 1;\n         }\n         if self.ccx.sess().count_llvm_insns() {\n-            *self.ccx.stats()\n+            *self.ccx.stats\n                 .borrow_mut()\n                 .llvm_insns\n                 .entry(category.to_string())\n@@ -558,7 +558,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx,\n                                                             v.as_ptr(),\n                                                             v.len() as c_uint));\n         }\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn nonnull_metadata(&self, load: ValueRef) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx, ptr::null(), 0));\n         }\n     }\n \n@@ -621,7 +621,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             //\n             // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n             let one = C_i32(self.ccx, 1);\n-            let node = llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n+            let node = llvm::LLVMMDNodeInContext(self.ccx.llcx,\n                                                  &one,\n                                                  1);\n             llvm::LLVMSetMetadata(insn,\n@@ -1160,7 +1160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn set_invariant_load(&self, load: ValueRef) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx, ptr::null(), 0));\n         }\n     }\n "}, {"sha": "0ae737e52bf276a07c889eeb94933fffdb41867d", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -20,12 +20,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += ccx.tcx.data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+    let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n "}, {"sha": "2bdcf1d3a75217b29f3cec4323f97b07c3318f3a", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -20,12 +20,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += ccx.tcx.data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+    let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n "}, {"sha": "02e13479a2f96d84da260246210300e22bd11687", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -20,12 +20,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += ccx.tcx.data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+    let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n "}, {"sha": "0ae737e52bf276a07c889eeb94933fffdb41867d", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -20,12 +20,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += ccx.tcx.data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+    let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n "}, {"sha": "cbc766c842c6b2d2ef6cfba2fdd75694fe5be41e", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -40,16 +40,16 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                         instance: Instance<'tcx>)\n                         -> ValueRef\n {\n-    let tcx = ccx.tcx();\n+    let tcx = ccx.tcx;\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_regions());\n     assert!(!instance.substs.has_param_types());\n \n-    let fn_ty = instance.ty(ccx.tcx());\n-    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n+    let fn_ty = instance.ty(ccx.tcx);\n+    if let Some(&llfn) = ccx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n \n@@ -149,9 +149,9 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if ccx.tcx().is_translated_function(instance_def_id) {\n+            if ccx.tcx.is_translated_function(instance_def_id) {\n                 if instance_def_id.is_local() {\n-                    if !ccx.tcx().is_exported_symbol(instance_def_id) {\n+                    if !ccx.tcx.is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {\n@@ -160,7 +160,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n \n-        if ccx.use_dll_storage_attrs() &&\n+        if ccx.use_dll_storage_attrs &&\n             tcx.is_dllimport_foreign_item(instance_def_id)\n         {\n             unsafe {\n@@ -171,7 +171,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         llfn\n     };\n \n-    ccx.instances().borrow_mut().insert(instance, llfn);\n+    ccx.instances.borrow_mut().insert(instance, llfn);\n \n     llfn\n }\n@@ -184,7 +184,7 @@ pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     get_fn(\n         ccx,\n         ty::Instance::resolve(\n-            ccx.tcx(),\n+            ccx.tcx,\n             ty::ParamEnv::empty(traits::Reveal::All),\n             def_id,\n             substs"}, {"sha": "de0d7913be4a1f693d3668f50f21d2c2852c68ee", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -175,7 +175,7 @@ pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n         assert!(i < (1<<bit_size));\n     }\n \n-    C_uint(ccx.isize_ty(), i)\n+    C_uint(ccx.isize_ty, i)\n }\n \n pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n@@ -187,11 +187,11 @@ pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        if let Some(&llval) = cx.const_cstr_cache().borrow().get(&s) {\n+        if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n             return llval;\n         }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n                                                 s.as_ptr() as *const c_char,\n                                                 s.len() as c_uint,\n                                                 !null_terminated as Bool);\n@@ -203,7 +203,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n \n-        cx.const_cstr_cache().borrow_mut().insert(s, g);\n+        cx.const_cstr_cache.borrow_mut().insert(s, g);\n         g\n     }\n }\n@@ -213,7 +213,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n-        cx.layout_of(cx.tcx().mk_str()).llvm_type(cx).ptr_to());\n+        cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n     C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n }\n \n@@ -224,7 +224,7 @@ pub fn C_fat_ptr(cx: &CrateContext, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n-    C_struct_in_context(cx.llcx(), elts, packed)\n+    C_struct_in_context(cx.llcx, elts, packed)\n }\n \n pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -248,7 +248,7 @@ pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n }\n \n pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n-    C_bytes_in_context(cx.llcx(), bytes)\n+    C_bytes_in_context(cx.llcx, bytes)\n }\n \n pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n@@ -389,9 +389,9 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match ty.sty {\n         ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n+        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx),\n         ty::TyClosure(def_id, substs) => {\n-            let tcx = ccx.tcx();\n+            let tcx = ccx.tcx;\n             let sig = substs.closure_sig(def_id, tcx);\n \n             let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -404,8 +404,8 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ))\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n-            let tcx = ccx.tcx();\n-            let sig = substs.generator_poly_sig(def_id, ccx.tcx());\n+            let tcx = ccx.tcx;\n+            let sig = substs.generator_poly_sig(def_id, ccx.tcx);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);"}, {"sha": "a7e947701b5dabb58a914bc25036ecc04dbabb49", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -85,7 +85,7 @@ pub fn addr_of(ccx: &CrateContext,\n                align: Align,\n                kind: &str)\n                -> ValueRef {\n-    if let Some(&gv) = ccx.const_globals().borrow().get(&cv) {\n+    if let Some(&gv) = ccx.const_globals.borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n             // alignment requirements\n@@ -100,27 +100,27 @@ pub fn addr_of(ccx: &CrateContext,\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gv, True);\n     }\n-    ccx.const_globals().borrow_mut().insert(cv, gv);\n+    ccx.const_globals.borrow_mut().insert(cv, gv);\n     gv\n }\n \n pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n-    let instance = Instance::mono(ccx.tcx(), def_id);\n-    if let Some(&g) = ccx.instances().borrow().get(&instance) {\n+    let instance = Instance::mono(ccx.tcx, def_id);\n+    if let Some(&g) = ccx.instances.borrow().get(&instance) {\n         return g;\n     }\n \n-    let ty = instance.ty(ccx.tcx());\n-    let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n+    let ty = instance.ty(ccx.tcx);\n+    let g = if let Some(id) = ccx.tcx.hir.as_local_node_id(def_id) {\n \n         let llty = ccx.layout_of(ty).llvm_type(ccx);\n-        let (g, attrs) = match ccx.tcx().hir.get(id) {\n+        let (g, attrs) = match ccx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = MonoItem::Static(id).symbol_name(ccx.tcx());\n+                let sym = MonoItem::Static(id).symbol_name(ccx.tcx);\n \n-                let defined_in_current_codegen_unit = ccx.codegen_unit()\n+                let defined_in_current_codegen_unit = ccx.codegen_unit\n                                                          .items()\n                                                          .contains_key(&MonoItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n@@ -131,7 +131,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n-                if !ccx.tcx().is_exported_symbol(def_id) {\n+                if !ccx.tcx.is_exported_symbol(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }\n@@ -143,7 +143,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = ccx.tcx().symbol_name(instance);\n+                let sym = ccx.tcx.symbol_name(instance);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -197,13 +197,13 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         for attr in attrs {\n             if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, ccx.tls_model());\n+                llvm::set_thread_local_mode(g, ccx.tls_model);\n             }\n         }\n \n         g\n     } else {\n-        let sym = ccx.tcx().symbol_name(instance);\n+        let sym = ccx.tcx.symbol_name(instance);\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -214,12 +214,12 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in ccx.tcx().get_attrs(def_id).iter() {\n+        for attr in ccx.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, ccx.tls_model());\n+                llvm::set_thread_local_mode(g, ccx.tls_model);\n             }\n         }\n-        if ccx.use_dll_storage_attrs() && !ccx.tcx().is_foreign_item(def_id) {\n+        if ccx.use_dll_storage_attrs && !ccx.tcx.is_foreign_item(def_id) {\n             // This item is external but not foreign, i.e. it originates from an external Rust\n             // crate. Since we don't know whether this crate will be linked dynamically or\n             // statically in the final application, we always mark such symbols as 'dllimport'.\n@@ -232,15 +232,15 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-    if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n+    if ccx.use_dll_storage_attrs && ccx.tcx.is_dllimport_foreign_item(def_id) {\n         // For foreign (native) libs we know the exact storage type to use.\n         unsafe {\n             llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n         }\n     }\n \n-    ccx.instances().borrow_mut().insert(instance, g);\n-    ccx.statics().borrow_mut().insert(g, def_id);\n+    ccx.instances.borrow_mut().insert(instance, g);\n+    ccx.statics.borrow_mut().insert(g, def_id);\n     g\n }\n \n@@ -250,7 +250,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               attrs: &[ast::Attribute])\n                               -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n-        let def_id = ccx.tcx().hir.local_def_id(id);\n+        let def_id = ccx.tcx.hir.local_def_id(id);\n         let g = get_static(ccx, def_id);\n \n         let v = ::mir::trans_static_initializer(ccx, def_id)?;\n@@ -265,8 +265,8 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             v\n         };\n \n-        let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = instance.ty(ccx.tcx());\n+        let instance = Instance::mono(ccx.tcx, def_id);\n+        let ty = instance.ty(ccx.tcx);\n         let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let g = if val_llty == llty {\n             g\n@@ -282,15 +282,15 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let visibility = llvm::LLVMRustGetVisibility(g);\n \n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n+                ccx.llmod, name_string.as_ptr(), val_llty.to_ref());\n \n             llvm::LLVMRustSetLinkage(new_g, linkage);\n             llvm::LLVMRustSetVisibility(new_g, visibility);\n \n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)\n-            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n+            ccx.statics_to_rauw.borrow_mut().push((g, new_g));\n             new_g\n         };\n         set_global_alignment(ccx, g, ccx.align_of(ty));\n@@ -307,15 +307,15 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debuginfo::create_global_var_metadata(ccx, id, g);\n \n         if attr::contains_name(attrs, \"thread_local\") {\n-            llvm::set_thread_local_mode(g, ccx.tls_model());\n+            llvm::set_thread_local_mode(g, ccx.tls_model);\n         }\n \n         base::set_link_section(ccx, g, attrs);\n \n         if attr::contains_name(attrs, \"used\") {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n             let cast = llvm::LLVMConstPointerCast(g, Type::i8p(ccx).to_ref());\n-            ccx.used_statics().borrow_mut().push(cast);\n+            ccx.used_statics.borrow_mut().push(cast);\n         }\n \n         Ok(g)"}, {"sha": "e1adf6e9adf32dafbdc24f2a478cf95652bdc424", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 28, "deletions": 123, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -46,23 +46,23 @@ use abi::Abi;\n /// `ContextRef` so that several compilation units may be optimized in parallel.\n /// All other LLVM data structures in the `CrateContext` are tied to that `ContextRef`.\n pub struct CrateContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    check_overflow: bool,\n-    use_dll_storage_attrs: bool,\n-    tls_model: llvm::ThreadLocalMode,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub check_overflow: bool,\n+    pub use_dll_storage_attrs: bool,\n+    pub tls_model: llvm::ThreadLocalMode,\n \n-    llmod: ModuleRef,\n-    llcx: ContextRef,\n-    stats: RefCell<Stats>,\n-    codegen_unit: Arc<CodegenUnit<'tcx>>,\n+    pub llmod: ModuleRef,\n+    pub llcx: ContextRef,\n+    pub stats: RefCell<Stats>,\n+    pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FxHashMap<(Ty<'tcx>,\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>,\n                                 Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n-    const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a ValueRef holding a *T,\n@@ -72,34 +72,34 @@ pub struct CrateContext<'a, 'tcx: 'a> {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    statics: RefCell<FxHashMap<ValueRef, DefId>>,\n+    pub statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n     /// to constants.)\n-    statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n+    pub statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n \n     /// Statics that will be placed in the llvm.used variable\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n-    used_statics: RefCell<Vec<ValueRef>>,\n+    pub used_statics: RefCell<Vec<ValueRef>>,\n \n-    lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n-    scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n-    isize_ty: Type,\n+    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n+    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n+    pub isize_ty: Type,\n \n-    dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n     eh_unwind_resume: Cell<Option<ValueRef>>,\n-    rust_try_fn: Cell<Option<ValueRef>>,\n+    pub rust_try_fn: Cell<Option<ValueRef>>,\n \n     intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n@@ -319,16 +319,12 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n }\n \n impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.tcx.sess\n     }\n \n     pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n-        if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n+        if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n         match declare_intrinsic(self, key) {\n@@ -337,97 +333,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn llmod(&self) -> ModuleRef {\n-        self.llmod\n-    }\n-\n-    pub fn llcx(&self) -> ContextRef {\n-        self.llcx\n-    }\n-\n-    pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n-        &self.codegen_unit\n-    }\n-\n-    pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.instances\n-    }\n-\n-    pub fn vtables<'a>(&'a self)\n-        -> &'a RefCell<FxHashMap<(Ty<'tcx>,\n-                                  Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>> {\n-        &self.vtables\n-    }\n-\n-    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<InternedString, ValueRef>> {\n-        &self.const_cstr_cache\n-    }\n-\n-    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.const_unsized\n-    }\n-\n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.const_globals\n-    }\n-\n-    pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n-        &self.statics\n-    }\n-\n-    pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n-        &self.statics_to_rauw\n-    }\n-\n-    pub fn used_statics<'a>(&'a self) -> &'a RefCell<Vec<ValueRef>> {\n-        &self.used_statics\n-    }\n-\n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>> {\n-        &self.lltypes\n-    }\n-\n-    pub fn scalar_lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n-        &self.scalar_lltypes\n-    }\n-\n-    pub fn pointee_infos<'a>(&'a self)\n-                             -> &'a RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>> {\n-        &self.pointee_infos\n-    }\n-\n-    pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n-        &self.stats\n-    }\n-\n-    pub fn isize_ty(&self) -> Type {\n-        self.isize_ty\n-    }\n-\n-    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n-        &self.dbg_cx\n-    }\n-\n-    pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.rust_try_fn\n-    }\n-\n-    fn intrinsics<'a>(&'a self) -> &'a RefCell<FxHashMap<&'static str, ValueRef>> {\n-        &self.intrinsics\n-    }\n-\n-    pub fn check_overflow(&self) -> bool {\n-        self.check_overflow\n-    }\n-\n-    pub fn use_dll_storage_attrs(&self) -> bool {\n-        self.use_dll_storage_attrs\n-    }\n-\n-    pub fn tls_model(&self) -> llvm::ThreadLocalMode {\n-        self.tls_model\n-    }\n-\n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n@@ -466,7 +371,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         if let Some(llpersonality) = self.eh_personality.get() {\n             return llpersonality\n         }\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n                 callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n@@ -494,7 +399,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             return llfn;\n         }\n \n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n             let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n@@ -575,23 +480,23 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n             if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::variadic_func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );"}, {"sha": "f4f2e2571555306a0a2252c33c3ae1ae93cf74bb", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -46,7 +46,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n     let section_var_name = &c_section_var_name[..c_section_var_name.len()-1];\n \n     let section_var = unsafe {\n-        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+        llvm::LLVMGetNamedGlobal(ccx.llmod,\n                                  c_section_var_name.as_ptr() as *const _)\n     };\n \n@@ -79,7 +79,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n \n pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&ccx.tcx().hir.krate_attrs(),\n+        attr::contains_name(&ccx.tcx.hir.krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&"}, {"sha": "486a947edd62b23d574dec0c508bd595338a65bd", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx());\n+        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx);\n         type_id_hasher.visit_ty(type_);\n         let unique_type_id = type_id_hasher.finish().to_hex();\n \n@@ -304,7 +304,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = cx.tcx().mk_imm_ptr(element_type);\n+    let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n \n     let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n \n@@ -313,7 +313,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let slice_type_name = compute_debuginfo_type_name(cx, slice_ptr_type, true);\n \n     let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n-    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx().types.usize);\n+    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx.types.usize);\n \n     let member_descriptions = [\n         MemberDescription {\n@@ -326,7 +326,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n-            type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n+            type_metadata: type_metadata(cx, cx.tcx.types.usize, span),\n             offset: pointer_size,\n             size: usize_size,\n             align: usize_align,\n@@ -353,7 +353,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = cx.tcx().erase_late_bound_regions_and_normalize(&signature);\n+    let signature = cx.tcx.erase_late_bound_regions_and_normalize(&signature);\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs().len() + 1);\n \n@@ -415,7 +415,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let file_metadata = unknown_file_metadata(cx);\n \n-    let layout = cx.layout_of(cx.tcx().mk_mut_ptr(trait_type));\n+    let layout = cx.layout_of(cx.tcx.mk_mut_ptr(trait_type));\n \n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n@@ -426,7 +426,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         MemberDescription {\n             name: \"pointer\".to_string(),\n             type_metadata: type_metadata(cx,\n-                cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n+                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n                 syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(0),\n             size: data_ptr_field.size,\n@@ -498,7 +498,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n             }\n             ty::TyStr => {\n-                Ok(vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span))\n+                Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span))\n             }\n             ty::TyDynamic(..) => {\n                 Ok(MetadataCreationResult::new(\n@@ -538,7 +538,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n         ty::TyStr => {\n-            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx().types.i8, usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span)\n         }\n         ty::TyDynamic(..) => {\n             MetadataCreationResult::new(\n@@ -566,7 +566,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n-                                                       t.fn_sig(cx.tcx()),\n+                                                       t.fn_sig(cx.tcx),\n                                                        usage_site_span).metadata;\n             match debug_context(cx).type_map\n                                    .borrow()\n@@ -580,16 +580,16 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         }\n         ty::TyClosure(def_id, substs) => {\n-            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx()).collect();\n+            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n-            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx()).map(|t| {\n-                cx.tcx().fully_normalize_associated_types_in(&t)\n+            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n+                cx.tcx.fully_normalize_associated_types_in(&t)\n             }).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n@@ -1368,7 +1368,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let file_metadata = unknown_file_metadata(cx);\n \n     let def = enum_type.ty_adt_def().unwrap();\n-    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx())\n+    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx)\n         .zip(&def.variants)\n         .map(|(discr, v)| {\n             let token = v.name.as_str();\n@@ -1394,7 +1394,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let (discriminant_size, discriminant_align) =\n                     (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n-                    type_metadata(cx, discr.to_ty(cx.tcx()), syntax_pos::DUMMY_SP);\n+                    type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n@@ -1473,7 +1473,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     fn get_enum_discriminant_name(cx: &CrateContext,\n                                   def_id: DefId)\n                                   -> InternedString {\n-        cx.tcx().item_name(def_id)\n+        cx.tcx.item_name(def_id)\n     }\n }\n \n@@ -1636,17 +1636,17 @@ fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn create_global_var_metadata(cx: &CrateContext,\n                                   node_id: ast::NodeId,\n                                   global: ValueRef) {\n-    if cx.dbg_cx().is_none() {\n+    if cx.dbg_cx.is_none() {\n         return;\n     }\n \n-    let tcx = cx.tcx();\n+    let tcx = cx.tcx;\n     let node_def_id = tcx.hir.local_def_id(node_id);\n     let no_mangle = attr::contains_name(&tcx.get_attrs(node_def_id), \"no_mangle\");\n     // We may want to remove the namespace scope if we're in an extern block, see:\n     // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952\n     let var_scope = get_namespace_for_item(cx, node_def_id);\n-    let span = cx.tcx().def_span(node_def_id);\n+    let span = cx.tcx.def_span(node_def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n@@ -1656,7 +1656,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = Instance::mono(cx.tcx(), node_def_id).ty(cx.tcx());\n+    let variable_type = Instance::mono(cx.tcx, node_def_id).ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let var_name = CString::new(var_name).unwrap();\n@@ -1710,7 +1710,7 @@ pub fn extend_scope_to_file(ccx: &CrateContext,\n pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         ty: ty::Ty<'tcx>,\n                                         vtable: ValueRef) {\n-    if cx.dbg_cx().is_none() {\n+    if cx.dbg_cx.is_none() {\n         return;\n     }\n \n@@ -1734,7 +1734,7 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             Size::from_bytes(0).bits(),\n-            cx.tcx().data_layout.pointer_align.abi_bits() as u32,\n+            cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n             ptr::null_mut(),\n             empty_array,"}, {"sha": "c3a95d446d28bbfc7c34a95adfcb8fe790d82f01", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -151,7 +151,7 @@ pub enum VariableKind {\n \n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: &CrateContext) {\n-    if cx.dbg_cx().is_none() {\n+    if cx.dbg_cx.is_none() {\n         return;\n     }\n \n@@ -176,21 +176,21 @@ pub fn finalize(cx: &CrateContext) {\n         // Android has the same issue (#22398)\n         if cx.sess().target.target.options.is_like_osx ||\n            cx.sess().target.target.options.is_like_android {\n-            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+            llvm::LLVMRustAddModuleFlag(cx.llmod,\n                                         \"Dwarf Version\\0\".as_ptr() as *const _,\n                                         2)\n         }\n \n         // Indicate that we want CodeView debug information on MSVC\n         if cx.sess().target.target.options.is_like_msvc {\n-            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+            llvm::LLVMRustAddModuleFlag(cx.llmod,\n                                         \"CodeView\\0\".as_ptr() as *const _,\n                                         1)\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n         let ptr = \"Debug Info Version\\0\".as_ptr();\n-        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+        llvm::LLVMRustAddModuleFlag(cx.llmod, ptr as *const _,\n                                     llvm::LLVMRustDebugMetadataVersion());\n     };\n }\n@@ -210,7 +210,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n-    for attr in instance.def.attrs(cx.tcx()).iter() {\n+    for attr in instance.def.attrs(cx.tcx).iter() {\n         if attr.check_name(\"no_debug\") {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n@@ -235,15 +235,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx().def_key(def_id);\n+    let def_key = cx.tcx.def_key(def_id);\n     let mut name = def_key.disambiguated_data.data.to_string();\n \n-    let enclosing_fn_def_id = cx.tcx().closure_base_def_id(def_id);\n+    let enclosing_fn_def_id = cx.tcx.closure_base_def_id(def_id);\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().generics_of(enclosing_fn_def_id);\n-    let substs = instance.substs.truncate_to(cx.tcx(), generics);\n+    let generics = cx.tcx.generics_of(enclosing_fn_def_id);\n+    let substs = instance.substs.truncate_to(cx.tcx, generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n                                                       substs,\n@@ -255,7 +255,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let scope_line = span_start(cx, span).line;\n \n-    let local_id = cx.tcx().hir.as_local_node_id(instance.def_id());\n+    let local_id = cx.tcx.hir.as_local_node_id(instance.def_id());\n     let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n     let function_name = CString::new(name).unwrap();\n@@ -334,8 +334,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.extend(inputs.iter().map(|&t| {\n                 let t = match t.sty {\n                     ty::TyArray(ct, _)\n-                        if (ct == cx.tcx().types.u8) || cx.layout_of(ct).is_zst() => {\n-                        cx.tcx().mk_imm_ptr(ct)\n+                        if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n+                        cx.tcx.mk_imm_ptr(ct)\n                     }\n                     _ => t\n                 };\n@@ -375,7 +375,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let actual_type = cx.tcx().fully_normalize_associated_types_in(&actual_type);\n+            let actual_type = cx.tcx.fully_normalize_associated_types_in(&actual_type);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n@@ -388,7 +388,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n             substs.types().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx().fully_normalize_associated_types_in(&ty);\n+                let actual_type = cx.tcx.fully_normalize_associated_types_in(&ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {\n@@ -411,7 +411,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_type_parameter_names(cx: &CrateContext, generics: &ty::Generics) -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx().generics_of(def_id))\n+            get_type_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names\n@@ -423,10 +423,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n-        let self_type = cx.tcx().impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+        let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n-            if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx().trans_impl_self_ty(impl_def_id, instance.substs);\n+            if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n+                let impl_self_ty = cx.tcx.trans_impl_self_ty(impl_def_id, instance.substs);\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n@@ -446,7 +446,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         self_type.unwrap_or_else(|| {\n             namespace::item_namespace(cx, DefId {\n                 krate: instance.def_id().krate,\n-                index: cx.tcx()\n+                index: cx.tcx\n                          .def_key(instance.def_id())\n                          .parent\n                          .expect(\"get_containing_scope: missing parent?\")"}, {"sha": "1f1015e1ed20165e90a96ea685aa7abf011c0abe", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -29,15 +29,15 @@ pub fn mangled_name_of_instance<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> ty::SymbolName {\n-     let tcx = ccx.tcx();\n+     let tcx = ccx.tcx;\n      tcx.symbol_name(instance)\n }\n \n pub fn mangled_name_of_item<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     node_id: ast::NodeId,\n ) -> ty::SymbolName {\n-    let tcx = ccx.tcx();\n+    let tcx = ccx.tcx;\n     let node_def_id = tcx.hir.local_def_id(node_id);\n     let instance = Instance::mono(tcx, node_def_id);\n     tcx.symbol_name(instance)\n@@ -48,7 +48,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n         return scope;\n     }\n \n-    let def_key = ccx.tcx().def_key(def_id);\n+    let def_key = ccx.tcx.def_key(def_id);\n     let parent_scope = def_key.parent.map_or(ptr::null_mut(), |parent| {\n         item_namespace(ccx, DefId {\n             krate: def_id.krate,\n@@ -57,7 +57,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n+        DefPathData::CrateRoot => ccx.tcx.crate_name(def_id.krate).as_str(),\n         data => data.as_interned_str()\n     };\n "}, {"sha": "039028c8883ca3574cd8390ea4d0d4f5e417e594", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -117,14 +117,14 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         ty::TyDynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n-                let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n+                let principal = cx.tcx.erase_late_bound_regions_and_normalize(\n                     &principal);\n                 push_item_name(cx, principal.def_id, false, output);\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n         ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-            let sig = t.fn_sig(cx.tcx());\n+            let sig = t.fn_sig(cx.tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }\n@@ -138,7 +138,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+            let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n@@ -184,13 +184,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       qualified: bool,\n                       output: &mut String) {\n         if qualified {\n-            output.push_str(&cx.tcx().crate_name(def_id.krate).as_str());\n-            for path_element in cx.tcx().def_path(def_id).data {\n+            output.push_str(&cx.tcx.crate_name(def_id.krate).as_str());\n+            for path_element in cx.tcx.def_path(def_id).data {\n                 output.push_str(\"::\");\n                 output.push_str(&path_element.data.as_interned_str());\n             }\n         } else {\n-            output.push_str(&cx.tcx().item_name(def_id));\n+            output.push_str(&cx.tcx.item_name(def_id));\n         }\n     }\n "}, {"sha": "18dec45ea6379bf92989410317da9d4f58e9ba43", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -33,8 +33,8 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    let def_id = cx.tcx().hir.local_def_id(node_id);\n-    !cx.tcx().is_exported_symbol(def_id)\n+    let def_id = cx.tcx.hir.local_def_id(node_id);\n+    !cx.tcx.is_exported_symbol(def_id)\n }\n \n #[allow(non_snake_case)]\n@@ -52,16 +52,16 @@ pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n #[inline]\n pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n                            -> &'a CrateDebugContext<'tcx> {\n-    cx.dbg_cx().as_ref().unwrap()\n+    cx.dbg_cx.as_ref().unwrap()\n }\n \n #[inline]\n #[allow(non_snake_case)]\n pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx().as_ref().unwrap().builder\n+    cx.dbg_cx.as_ref().unwrap().builder\n }\n \n pub fn get_namespace_for_item(cx: &CrateContext, def_id: DefId) -> DIScope {\n-    item_namespace(cx, cx.tcx().parent(def_id)\n+    item_namespace(cx, cx.tcx.parent(def_id)\n         .expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "c9da7c71207b80f8ac899759836f7b5cafe39397", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -45,7 +45,7 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertGlobal(ccx.llmod, namebuf.as_ptr(), ty.to_ref())\n     }\n }\n \n@@ -60,20 +60,20 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n-        llvm::LLVMRustGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertFunction(ccx.llmod, namebuf.as_ptr(), ty.to_ref())\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n     // Function addresses in Rust are never significant, allowing functions to\n     // be merged.\n     llvm::SetUnnamedAddr(llfn, true);\n \n-    if ccx.tcx().sess.opts.cg.no_redzone\n-        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n+    if ccx.tcx.sess.opts.cg.no_redzone\n+        .unwrap_or(ccx.tcx.sess.target.target.options.disable_redzone) {\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n-    if let Some(ref sanitizer) = ccx.tcx().sess.opts.debugging_opts.sanitizer {\n+    if let Some(ref sanitizer) = ccx.tcx.sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n             Sanitizer::Address => {\n                 llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n@@ -88,7 +88,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         }\n     }\n \n-    match ccx.tcx().sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n+    match ccx.tcx.sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n             llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n@@ -99,7 +99,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         _ => {},\n     }\n \n-    if ccx.tcx().sess.panic_strategy() != PanicStrategy::Unwind {\n+    if ccx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n         attributes::unwind(llfn, false);\n     }\n \n@@ -127,7 +127,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n     let sig = common::ty_fn_sig(ccx, fn_type);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+    let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(ccx, sig, &[]);\n@@ -197,7 +197,7 @@ pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n-    let val = unsafe { llvm::LLVMRustGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n+    let val = unsafe { llvm::LLVMRustGetNamedValue(ccx.llmod, namebuf.as_ptr()) };\n     if val.is_null() {\n         debug!(\"get_declared_value: {:?} value is null\", name);\n         None"}, {"sha": "42dd58c59c9ad7134449f00764671bb83eca85c5", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -92,7 +92,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       llresult: ValueRef,\n                                       span: Span) {\n     let ccx = bcx.ccx;\n-    let tcx = ccx.tcx();\n+    let tcx = ccx.tcx;\n \n     let (def_id, substs) = match callee_ty.sty {\n         ty::TyFnDef(def_id, substs) => (def_id, substs),\n@@ -176,7 +176,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             C_str_slice(ccx, ty_name)\n         }\n         \"type_id\" => {\n-            C_u64(ccx, ccx.tcx().type_id_hash(substs.type_at(0)))\n+            C_u64(ccx, ccx.tcx.type_id_hash(substs.type_at(0)))\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n@@ -399,11 +399,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.ccx.isize_ty());\n+            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.ccx.isize_ty);\n             // `ptr_val % align`\n             let align = args[1].immediate();\n             let offset = bcx.urem(ptr_val, align);\n-            let zero = C_null(bcx.ccx.isize_ty());\n+            let zero = C_null(bcx.ccx.isize_ty);\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { align - offset }`\n@@ -844,7 +844,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n-        let tcx = ccx.tcx();\n+        let tcx = ccx.tcx;\n         let tydesc = match tcx.lang_items().msvc_try_filter() {\n             Some(did) => ::consts::get_static(ccx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n@@ -948,7 +948,7 @@ fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::Binder(ccx.tcx().mk_fn_sig(\n+    let rust_fn_ty = ccx.tcx.mk_fn_ptr(ty::Binder(ccx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n         false,\n@@ -968,12 +968,12 @@ fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                              trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n-    if let Some(llfn) = ccx.rust_try_fn().get() {\n+    if let Some(llfn) = ccx.rust_try_fn.get() {\n         return llfn;\n     }\n \n     // Define the type up front for the signature of the rust_try function.\n-    let tcx = ccx.tcx();\n+    let tcx = ccx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     let fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n         iter::once(i8p),\n@@ -984,7 +984,7 @@ fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     )));\n     let output = tcx.types.i32;\n     let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n-    ccx.rust_try_fn().set(Some(rust_try));\n+    ccx.rust_try_fn.set(Some(rust_try));\n     return rust_try\n }\n \n@@ -1247,7 +1247,7 @@ fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n     match ty.sty {\n         ty::TyInt(t) => Some((match t {\n             ast::IntTy::Isize => {\n-                match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+                match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n                     \"32\" => 32,\n                     \"64\" => 64,\n@@ -1262,7 +1262,7 @@ fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n         }, true)),\n         ty::TyUint(t) => Some((match t {\n             ast::UintTy::Usize => {\n-                match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+                match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n                     \"32\" => 32,\n                     \"64\" => 64,"}, {"sha": "8154df1e537d81c0e68e689b77e1577f28c2ad2f", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -74,12 +74,12 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n                             -> ValueRef\n {\n-    let tcx = ccx.tcx();\n+    let tcx = ccx.tcx;\n \n     debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n \n     // Check the cache.\n-    if let Some(&val) = ccx.vtables().borrow().get(&(ty, trait_ref)) {\n+    if let Some(&val) = ccx.vtables.borrow().get(&(ty, trait_ref)) {\n         return val;\n     }\n \n@@ -88,7 +88,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let (size, align) = ccx.size_and_align_of(ty);\n     let mut components: Vec<_> = [\n-        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx(), ty)),\n+        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx, ty)),\n         C_usize(ccx, size.bytes()),\n         C_usize(ccx, align.abi())\n     ].iter().cloned().collect();\n@@ -110,6 +110,6 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debuginfo::create_vtable_metadata(ccx, ty, vtable);\n \n-    ccx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n+    ccx.vtables.borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "e70cb6d0c9aec1ed5e396e8158ff2bde88b17bf4", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -117,7 +117,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.ccx.tcx().lang_items().box_free_fn() => {\n+            } if Some(def_id) == self.cx.ccx.tcx.lang_items().box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -145,18 +145,18 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 _ => false\n             };\n             if is_consume {\n-                let base_ty = proj.base.ty(self.cx.mir, ccx.tcx());\n+                let base_ty = proj.base.ty(self.cx.mir, ccx.tcx);\n                 let base_ty = self.cx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty.projection_ty(ccx.tcx(), &proj.elem).to_ty(ccx.tcx());\n+                let elem_ty = base_ty.projection_ty(ccx.tcx, &proj.elem).to_ty(ccx.tcx);\n                 let elem_ty = self.cx.monomorphize(&elem_ty);\n                 if ccx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx()));\n+                    let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx));\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -200,8 +200,8 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             }\n \n             PlaceContext::Drop => {\n-                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.ccx.tcx);\n+                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx));\n \n                 // Only need the place if we're actually dropping it.\n                 if self.cx.ccx.type_needs_drop(ty) {"}, {"sha": "48187bfd2ce6d99abaf3ddc3a68e5b11fd76e2f3", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.tcx(), ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.tcx, ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 args = &args[..1 + place.has_extra() as usize];\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n-                        let fn_ty = drop_fn.ty(bcx.ccx.tcx());\n+                        let fn_ty = drop_fn.ty(bcx.ccx.tcx);\n                         let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n                         let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                         let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n@@ -308,7 +308,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bcx.ccx.check_overflow() {\n+                if !bcx.ccx.check_overflow {\n                     use rustc_const_math::ConstMathErr::Overflow;\n                     use rustc_const_math::Op::Neg;\n \n@@ -440,7 +440,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bcx.ccx.tcx(),\n+                        (Some(ty::Instance::resolve(bcx.ccx.tcx,\n                                                     ty::ParamEnv::empty(traits::Reveal::All),\n                                                     def_id,\n                                                     substs).unwrap()),\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }).collect();\n \n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bcx.ccx.tcx());\n+                    let callee_ty = instance.as_ref().unwrap().ty(bcx.ccx.tcx);\n                     trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n \n@@ -720,9 +720,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let layout = ccx.layout_of(ccx.tcx().intern_tup(&[\n-                ccx.tcx().mk_mut_ptr(ccx.tcx().types.u8),\n-                ccx.tcx().types.i32\n+            let layout = ccx.layout_of(ccx.tcx.intern_tup(&[\n+                ccx.tcx.mk_mut_ptr(ccx.tcx.types.u8),\n+                ccx.tcx.types.i32\n             ], false));\n             let slot = PlaceRef::alloca(bcx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);"}, {"sha": "68e0855701cfb7e8f96bf0419bc855bc1af2244d", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     pub fn from_constint(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n-        let tcx = ccx.tcx();\n+        let tcx = ccx.tcx;\n         let (llval, ty) = match *ci {\n             I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n             I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n@@ -294,22 +294,22 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = ty::Instance::resolve(ccx.tcx(),\n+        let instance = ty::Instance::resolve(ccx.tcx,\n                                              ty::ParamEnv::empty(traits::Reveal::All),\n                                              def_id,\n                                              substs).unwrap();\n-        let mir = ccx.tcx().instance_mir(instance.def);\n+        let mir = ccx.tcx.instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }\n \n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        self.ccx.tcx().trans_apply_param_substs(self.substs, value)\n+        self.ccx.tcx.trans_apply_param_substs(self.substs, value)\n     }\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.ccx.tcx;\n         let mut bb = mir::START_BLOCK;\n \n         // Make sure to evaluate all statemenets to\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn is_binop_lang_item(&mut self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.ccx.tcx;\n         let items = tcx.lang_items();\n         let def_id = Some(def_id);\n         if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_place(&self, place: &mir::Place<'tcx>, span: Span)\n                     -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.ccx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n             return self.locals[index].clone().unwrap_or_else(|| {\n@@ -537,13 +537,13 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         } else {\n                             base.get_fat_ptr(self.ccx)\n                         };\n-                        if self.ccx.statics().borrow().contains_key(&base) {\n+                        if self.ccx.statics.borrow().contains_key(&base) {\n                             (Base::Static(base), extra)\n                         } else if let ty::TyStr = projected_ty.sty {\n                             (Base::Str(base), extra)\n                         } else {\n                             let v = base;\n-                            let v = self.ccx.const_unsized().borrow().get(&v).map_or(v, |&v| v);\n+                            let v = self.ccx.const_unsized.borrow().get(&v).map_or(v, |&v| v);\n                             let mut val = unsafe { llvm::LLVMGetInitializer(v) };\n                             if val.is_null() {\n                                 span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n@@ -653,7 +653,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.ccx.tcx;\n         debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n@@ -763,7 +763,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                                       unsized_ty, old_info);\n \n                         if old_info.is_none() {\n-                            let prev_const = self.ccx.const_unsized().borrow_mut()\n+                            let prev_const = self.ccx.const_unsized.borrow_mut()\n                                                      .insert(base, operand.llval);\n                             assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n                         }\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 (CastTy::Int(_), CastTy::Ptr(_)) => {\n                                     let s = signed as llvm::Bool;\n                                     let usize_llval = llvm::LLVMConstIntCast(llval,\n-                                        self.ccx.isize_ty().to_ref(), s);\n+                                        self.ccx.isize_ty.to_ref(), s);\n                                     llvm::LLVMConstIntToPtr(usize_llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Int(_)) |\n@@ -860,7 +860,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let align = if self.ccx.type_is_sized(ty) {\n                             self.ccx.align_of(ty)\n                         } else {\n-                            self.ccx.tcx().data_layout.pointer_align\n+                            self.ccx.tcx.data_layout.pointer_align\n                         };\n                         if bk == mir::BorrowKind::Mut {\n                             consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n@@ -1090,7 +1090,7 @@ unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n     };\n     if cast_result.status.contains(Status::INVALID_OP) {\n         let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n-        err.report(ccx.tcx(), span, \"expression\");\n+        err.report(ccx.tcx, span, \"expression\");\n     }\n     C_uint_big(int_ty, cast_result.value)\n }\n@@ -1224,7 +1224,7 @@ fn trans_const_adt<'a, 'tcx>(\n         layout::Variants::Tagged { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n+                    adt_def.discriminant_for_variant(ccx.tcx, variant_index)\n                            .to_u128_unchecked() as u64\n                 },\n                 _ => 0,"}, {"sha": "2d23bf3e6993598ff113e77f43bfe7f753cda516", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        self.ccx.tcx().trans_apply_param_substs(self.param_substs, value)\n+        self.ccx.tcx.trans_apply_param_substs(self.param_substs, value)\n     }\n \n     pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {"}, {"sha": "e9569df60d591f89c31d4c19be351f9d8f20ee3e", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_place(place={:?})\", place);\n \n         let ccx = bcx.ccx;\n-        let tcx = ccx.tcx();\n+        let tcx = ccx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n             match self.locals[index] {\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.ccx.tcx;\n         let place_ty = place.ty(self.mir, tcx);\n         self.monomorphize(&place_ty.to_ty(tcx))\n     }"}, {"sha": "5d27d2c1c6afda67c44d0ae7eacdf57bb384a3a9", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.layout.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bcx.ccx.tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                    bcx.ccx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n                                 bcx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bcx.intcast(llval, bcx.ccx.isize_ty(), signed);\n+                                let usize_llval = bcx.intcast(llval, bcx.ccx.isize_ty, signed);\n                                 bcx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Int(_), CastTy::Float) =>\n@@ -348,8 +348,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 (bcx, OperandRef {\n                     val,\n-                    layout: self.ccx.layout_of(self.ccx.tcx().mk_ref(\n-                        self.ccx.tcx().types.re_erased,\n+                    layout: self.ccx.layout_of(self.ccx.tcx.mk_ref(\n+                        self.ccx.tcx.types.re_erased,\n                         ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n                     )),\n                 })\n@@ -477,7 +477,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                let ty = rvalue.ty(self.mir, self.ccx.tcx);\n                 (bcx, OperandRef::new_zst(self.ccx,\n                     self.ccx.layout_of(self.monomorphize(&ty))))\n             }\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        if !bcx.ccx.check_overflow() {\n+        if !bcx.ccx.check_overflow {\n             let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n             return OperandValue::Pair(val, C_bool(bcx.ccx, false));\n         }\n@@ -697,7 +697,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                let ty = rvalue.ty(self.mir, self.ccx.tcx);\n                 let ty = self.monomorphize(&ty);\n                 self.ccx.layout_of(ty).is_zst()\n             }"}, {"sha": "a01a786303c87fd94e70d7413493bf02bdbf9de5", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -40,13 +40,13 @@ pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n     fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(ccx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               ccx.codegen_unit.name());\n \n         match *self.as_mono_item() {\n             MonoItem::Static(node_id) => {\n-                let tcx = ccx.tcx();\n+                let tcx = ccx.tcx;\n                 let item = tcx.hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n                     match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n@@ -60,7 +60,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 }\n             }\n             MonoItem::GlobalAsm(node_id) => {\n-                let item = ccx.tcx().hir.expect_item(node_id);\n+                let item = ccx.tcx.hir.expect_item(node_id);\n                 if let hir::ItemGlobalAsm(ref ga) = item.node {\n                     asm::trans_global_asm(ccx, ga);\n                 } else {\n@@ -73,21 +73,21 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(ccx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               ccx.codegen_unit.name());\n     }\n \n     fn predefine(&self,\n                  ccx: &CrateContext<'a, 'tcx>,\n                  linkage: Linkage,\n                  visibility: Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(ccx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               ccx.codegen_unit.name());\n \n-        let symbol_name = self.symbol_name(ccx.tcx());\n+        let symbol_name = self.symbol_name(ccx.tcx);\n \n         debug!(\"symbol {}\", &symbol_name);\n \n@@ -102,9 +102,9 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(ccx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               ccx.codegen_unit.name());\n     }\n \n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n@@ -143,13 +143,13 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               linkage: Linkage,\n                               visibility: Visibility,\n                               symbol_name: &str) {\n-    let def_id = ccx.tcx().hir.local_def_id(node_id);\n-    let instance = Instance::mono(ccx.tcx(), def_id);\n-    let ty = instance.ty(ccx.tcx());\n+    let def_id = ccx.tcx.hir.local_def_id(node_id);\n+    let instance = Instance::mono(ccx.tcx, def_id);\n+    let ty = instance.ty(ccx.tcx);\n     let llty = ccx.layout_of(ty).llvm_type(ccx);\n \n     let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-        ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),\n+        ccx.sess().span_fatal(ccx.tcx.hir.span(node_id),\n             &format!(\"symbol `{}` is already defined\", symbol_name))\n     });\n \n@@ -158,8 +158,8 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n     }\n \n-    ccx.instances().borrow_mut().insert(instance, g);\n-    ccx.statics().borrow_mut().insert(g, def_id);\n+    ccx.instances.borrow_mut().insert(instance, g);\n+    ccx.statics.borrow_mut().insert(g, def_id);\n }\n \n fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -170,22 +170,22 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert!(!instance.substs.needs_infer() &&\n             !instance.substs.has_param_types());\n \n-    let mono_ty = instance.ty(ccx.tcx());\n-    let attrs = instance.def.attrs(ccx.tcx());\n+    let mono_ty = instance.ty(ccx.tcx);\n+    let attrs = instance.def.attrs(ccx.tcx);\n     let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n     unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n     base::set_link_section(ccx, lldecl, &attrs);\n     if linkage == Linkage::LinkOnceODR ||\n         linkage == Linkage::WeakODR {\n-        llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n+        llvm::SetUniqueComdat(ccx.llmod, lldecl);\n     }\n \n     // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n     // compiler-rt, then we want to implicitly compile everything with hidden\n     // visibility as we're going to link this object all over the place but\n     // don't want the symbols to get exported.\n     if linkage != Linkage::Internal && linkage != Linkage::Private &&\n-       attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n+       attr::contains_name(ccx.tcx.hir.krate_attrs(), \"compiler_builtins\") {\n         unsafe {\n             llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n         }\n@@ -196,10 +196,10 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-    if instance.def.is_inline(ccx.tcx()) {\n+    if instance.def.is_inline(ccx.tcx) {\n         attributes::inline(lldecl, attributes::InlineAttr::Hint);\n     }\n     attributes::from_fn_attrs(ccx, lldecl, instance.def.def_id());\n \n-    ccx.instances().borrow_mut().insert(instance, lldecl);\n+    ccx.instances.borrow_mut().insert(instance, lldecl);\n }"}, {"sha": "5c826399e72f5e1b36ed070e6e9b4f0ad970fe8d", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -63,52 +63,52 @@ impl Type {\n     }\n \n     pub fn void(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n     }\n \n     pub fn metadata(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx))\n     }\n \n     pub fn i1(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n     }\n \n     pub fn i8(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n     }\n \n     pub fn i8_llcx(llcx: ContextRef) -> Type {\n         ty!(llvm::LLVMInt8TypeInContext(llcx))\n     }\n \n     pub fn i16(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n     }\n \n     pub fn i32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n     }\n \n     pub fn i64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n     }\n \n     pub fn i128(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), 128))\n+        ty!(llvm::LLVMIntTypeInContext(ccx.llcx, 128))\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n     pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n+        ty!(llvm::LLVMIntTypeInContext(ccx.llcx, num_bits as c_uint))\n     }\n \n     pub fn f32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n     }\n \n     pub fn f64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n     }\n \n     pub fn bool(ccx: &CrateContext) -> Type {\n@@ -128,7 +128,7 @@ impl Type {\n     }\n \n     pub fn isize(ccx: &CrateContext) -> Type {\n-        match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n@@ -137,7 +137,7 @@ impl Type {\n     }\n \n     pub fn c_int(ccx: &CrateContext) -> Type {\n-        match &ccx.tcx().sess.target.target.target_c_int_width[..] {\n+        match &ccx.tcx.sess.target.target.target_c_int_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n@@ -147,7 +147,7 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::IntTy::Isize => ccx.isize_ty(),\n+            ast::IntTy::Isize => ccx.isize_ty,\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n@@ -158,7 +158,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::UintTy::Usize => ccx.isize_ty(),\n+            ast::UintTy::Usize => ccx.isize_ty,\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n@@ -188,14 +188,14 @@ impl Type {\n \n     pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els: &[TypeRef] = Type::to_ref_slice(els);\n-        ty!(llvm::LLVMStructTypeInContext(ccx.llcx(), els.as_ptr(),\n+        ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n         let name = CString::new(name).unwrap();\n-        ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n+        ty!(llvm::LLVMStructCreateNamed(ccx.llcx, name.as_ptr()))\n     }\n \n \n@@ -295,6 +295,6 @@ impl Type {\n     }\n \n     pub fn x86_mmx(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMX86MMXTypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMX86MMXTypeInContext(ccx.llcx))\n     }\n }"}, {"sha": "325e62e41735dcf7fb4f63342152c28d53dfc88f", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "patch": "@@ -61,7 +61,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyForeign(..) |\n         ty::TyStr => {\n             let mut name = String::with_capacity(32);\n-            let printer = DefPathBasedNames::new(ccx.tcx(), true, true);\n+            let printer = DefPathBasedNames::new(ccx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n             match (&layout.ty.sty, &layout.variants) {\n                 (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n@@ -244,7 +244,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n-            if let Some(&llty) = ccx.scalar_lltypes().borrow().get(&self.ty) {\n+            if let Some(&llty) = ccx.scalar_lltypes.borrow().get(&self.ty) {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n@@ -256,12 +256,12 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                     ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx).ptr_to()\n                 }\n                 ty::TyFnPtr(sig) => {\n-                    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                    let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n                     FnType::new(ccx, sig, &[]).llvm_type(ccx).ptr_to()\n                 }\n                 _ => self.scalar_llvm_type_at(ccx, scalar, Size::from_bytes(0))\n             };\n-            ccx.scalar_lltypes().borrow_mut().insert(self.ty, llty);\n+            ccx.scalar_lltypes.borrow_mut().insert(self.ty, llty);\n             return llty;\n         }\n \n@@ -271,7 +271,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             layout::Variants::Single { index } => Some(index),\n             _ => None\n         };\n-        if let Some(&llty) = ccx.lltypes().borrow().get(&(self.ty, variant_index)) {\n+        if let Some(&llty) = ccx.lltypes.borrow().get(&(self.ty, variant_index)) {\n             return llty;\n         }\n \n@@ -281,7 +281,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes.\n-        let normal_ty = ccx.tcx().erase_regions(&self.ty);\n+        let normal_ty = ccx.tcx.erase_regions(&self.ty);\n \n         let mut defer = None;\n         let llty = if self.ty != normal_ty {\n@@ -295,7 +295,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        ccx.lltypes().borrow_mut().insert((self.ty, variant_index), llty);\n+        ccx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n             let (llfields, packed) = struct_llfields(ccx, layout);\n@@ -342,7 +342,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 return self.field(ccx, index).llvm_type(ccx);\n             }\n             ty::TyAdt(def, _) if def.is_box() => {\n-                let ptr_ty = ccx.tcx().mk_mut_ptr(self.ty.boxed_ty());\n+                let ptr_ty = ccx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n                 return ccx.layout_of(ptr_ty).scalar_pair_element_llvm_type(ccx, index);\n             }\n             _ => {}\n@@ -398,7 +398,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n     fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo> {\n-        if let Some(&pointee) = ccx.pointee_infos().borrow().get(&(self.ty, offset)) {\n+        if let Some(&pointee) = ccx.pointee_infos.borrow().get(&(self.ty, offset)) {\n             return pointee;\n         }\n \n@@ -423,8 +423,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         PointerKind::Shared\n                     },\n                     hir::MutMutable => {\n-                        if ccx.tcx().sess.opts.debugging_opts.mutable_noalias ||\n-                           ccx.tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                        if ccx.tcx.sess.opts.debugging_opts.mutable_noalias ||\n+                           ccx.tcx.sess.panic_strategy() == PanicStrategy::Abort {\n                             PointerKind::UniqueBorrowed\n                         } else {\n                             PointerKind::Shared\n@@ -495,7 +495,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n         }\n \n-        ccx.pointee_infos().borrow_mut().insert((self.ty, offset), result);\n+        ccx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result\n     }\n }"}]}