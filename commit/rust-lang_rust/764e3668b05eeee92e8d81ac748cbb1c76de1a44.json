{"sha": "764e3668b05eeee92e8d81ac748cbb1c76de1a44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NGUzNjY4YjA1ZWVlZTkyZThkODFhYzc0OGNiYjFjNzZkZTFhNDQ=", "commit": {"author": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2019-04-14T23:00:50Z"}, "committer": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2019-05-05T22:07:14Z"}, "message": "to_xe_bytes for isize and usize returns an array of different size\n\n... on different platforms.\n\nOfficial rustdoc of\n[`usize::to_le_bytes`](https://doc.rust-lang.org/std/primitive.usize.html#method.to_le_bytes)\ndisplays signature\n\n```\npub fn to_ne_bytes(self) -> [u8; 8]\n```\n\nwhich might be misleading: this function returns 4 bytes on 32-bit\nsystems.", "tree": {"sha": "104eeb527e9991f1792b19a270a784b068049bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/104eeb527e9991f1792b19a270a784b068049bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/764e3668b05eeee92e8d81ac748cbb1c76de1a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/764e3668b05eeee92e8d81ac748cbb1c76de1a44", "html_url": "https://github.com/rust-lang/rust/commit/764e3668b05eeee92e8d81ac748cbb1c76de1a44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/764e3668b05eeee92e8d81ac748cbb1c76de1a44/comments", "author": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d8fd98d347239bc7e29c19988d7c19cf860cced", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8fd98d347239bc7e29c19988d7c19cf860cced", "html_url": "https://github.com/rust-lang/rust/commit/5d8fd98d347239bc7e29c19988d7c19cf860cced"}], "stats": {"total": 113, "additions": 83, "deletions": 30}, "files": [{"sha": "562a7a4b3c7196d1ef392299b7e68e7de66b3163", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 83, "deletions": 30, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/764e3668b05eeee92e8d81ac748cbb1c76de1a44/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764e3668b05eeee92e8d81ac748cbb1c76de1a44/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=764e3668b05eeee92e8d81ac748cbb1c76de1a44", "patch": "@@ -214,11 +214,31 @@ pub mod diy_float;\n \n mod wrapping;\n \n+macro_rules! usize_isize_to_xe_bytes_doc {\n+    () => {\"\n+\n+**Note**: This function returns an array of length 2, 4 or 8 bytes\n+depending on the target pointer size.\n+\n+\"}\n+}\n+\n+\n+macro_rules! usize_isize_from_xe_bytes_doc {\n+    () => {\"\n+\n+**Note**: This function takes an array of length 2, 4 or 8 bytes\n+depending on the target pointer size.\n+\n+\"}\n+}\n+\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n     ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n      $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-     $reversed:expr, $le_bytes:expr, $be_bytes:expr) => {\n+     $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n+     $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -2023,7 +2043,9 @@ $EndFeature, \"\n         doc_comment! {\n             concat!(\"Return the memory representation of this integer as a byte array in\n big-endian (network) byte order.\n-\n+\",\n+$to_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -2041,7 +2063,9 @@ assert_eq!(bytes, \", $be_bytes, \");\n doc_comment! {\n             concat!(\"Return the memory representation of this integer as a byte array in\n little-endian byte order.\n-\n+\",\n+$to_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -2064,7 +2088,9 @@ native byte order.\n As the target platform's native endianness is used, portable code\n should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n instead.\n-\n+\",\n+$to_xe_bytes_doc,\n+\"\n [`to_be_bytes`]: #method.to_be_bytes\n [`to_le_bytes`]: #method.to_le_bytes\n \n@@ -2089,7 +2115,9 @@ assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n doc_comment! {\n             concat!(\"Create an integer value from its representation as a byte array in\n big endian.\n-\n+\",\n+$from_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -2120,7 +2148,9 @@ doc_comment! {\n             concat!(\"\n Create an integer value from its representation as a byte array in\n little endian.\n-\n+\",\n+$from_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -2157,7 +2187,9 @@ appropriate instead.\n \n [`from_be_bytes`]: #method.from_be_bytes\n [`from_le_bytes`]: #method.from_le_bytes\n-\n+\",\n+$from_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -2193,28 +2225,28 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n #[lang = \"i8\"]\n impl i8 {\n     int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n-        \"[0x12]\", \"[0x12]\" }\n+        \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n     int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n-        \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n+        \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n     int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n         \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78]\" }\n+        \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n     int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\", 12,\n          \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n          \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n+         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n }\n \n #[lang = \"i128\"]\n@@ -2226,22 +2258,24 @@ impl i128 {\n         \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n           0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\" }\n+          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n-        \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n+        \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n+        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n         \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78]\" }\n+        \"[0x12, 0x34, 0x56, 0x78]\",\n+        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n@@ -2250,14 +2284,16 @@ impl isize {\n     int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\",\n         12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n          \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n+         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+         usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n         $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-        $reversed:expr, $le_bytes:expr, $be_bytes:expr) => {\n+        $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n+        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -3817,7 +3853,9 @@ $EndFeature, \"\n         doc_comment! {\n             concat!(\"Return the memory representation of this integer as a byte array in\n big-endian (network) byte order.\n-\n+\",\n+$to_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -3835,7 +3873,9 @@ assert_eq!(bytes, \", $be_bytes, \");\n         doc_comment! {\n             concat!(\"Return the memory representation of this integer as a byte array in\n little-endian byte order.\n-\n+\",\n+$to_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -3858,7 +3898,9 @@ native byte order.\n As the target platform's native endianness is used, portable code\n should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n instead.\n-\n+\",\n+$to_xe_bytes_doc,\n+\"\n [`to_be_bytes`]: #method.to_be_bytes\n [`to_le_bytes`]: #method.to_le_bytes\n \n@@ -3883,7 +3925,9 @@ assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n         doc_comment! {\n             concat!(\"Create an integer value from its representation as a byte array in\n big endian.\n-\n+\",\n+$from_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -3914,7 +3958,9 @@ fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             concat!(\"\n Create an integer value from its representation as a byte array in\n little endian.\n-\n+\",\n+$from_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -3951,7 +3997,9 @@ appropriate instead.\n \n [`from_be_bytes`]: #method.from_be_bytes\n [`from_le_bytes`]: #method.from_le_bytes\n-\n+\",\n+$from_xe_bytes_doc,\n+\"\n # Examples\n \n ```\n@@ -3987,7 +4035,7 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n #[lang = \"u8\"]\n impl u8 {\n     uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n-        \"[0x12]\" }\n+        \"[0x12]\", \"\", \"\" }\n \n \n     /// Checks if the value is within the ASCII range.\n@@ -4506,21 +4554,22 @@ impl u8 {\n #[lang = \"u16\"]\n impl u16 {\n     uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-        \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n+        \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n     uint_impl! { u32, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\" }\n+        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n     uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n         \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n         \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n+        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        \"\", \"\"}\n }\n \n #[lang = \"u128\"]\n@@ -4531,20 +4580,23 @@ impl u128 {\n         \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n           0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\" }\n+          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n+         \"\", \"\"}\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-        \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n+        \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n+        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\" }\n+        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n+        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n@@ -4553,7 +4605,8 @@ impl usize {\n     uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n         \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n         \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n+         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n /// A classification of floating point numbers."}]}