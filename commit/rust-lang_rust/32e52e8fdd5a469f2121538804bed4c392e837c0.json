{"sha": "32e52e8fdd5a469f2121538804bed4c392e837c0", "node_id": "C_kwDOAAsO6NoAKDMyZTUyZThmZGQ1YTQ2OWYyMTIxNTM4ODA0YmVkNGMzOTJlODM3YzA", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-05-23T06:56:31Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-05-23T06:56:31Z"}, "message": "Merge from rustc", "tree": {"sha": "cb610bb06b5b3c180e8a14aa08d04e78402a792f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb610bb06b5b3c180e8a14aa08d04e78402a792f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e52e8fdd5a469f2121538804bed4c392e837c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e52e8fdd5a469f2121538804bed4c392e837c0", "html_url": "https://github.com/rust-lang/rust/commit/32e52e8fdd5a469f2121538804bed4c392e837c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e52e8fdd5a469f2121538804bed4c392e837c0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a43c5d8591f25063a0adeddbc961e86249dfb764", "url": "https://api.github.com/repos/rust-lang/rust/commits/a43c5d8591f25063a0adeddbc961e86249dfb764", "html_url": "https://github.com/rust-lang/rust/commit/a43c5d8591f25063a0adeddbc961e86249dfb764"}, {"sha": "8b4b20836b832e91aa605a2faf5e2a55190202c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b4b20836b832e91aa605a2faf5e2a55190202c8", "html_url": "https://github.com/rust-lang/rust/commit/8b4b20836b832e91aa605a2faf5e2a55190202c8"}], "stats": {"total": 9154, "additions": 6295, "deletions": 2859}, "files": [{"sha": "04c804d19a4f24aca4a0da07ec261950276143c8", "filename": "Cargo.lock", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -154,11 +154,11 @@ checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"ar_archive_writer\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0639441fd17a3197d1cbca8dc8768cc172a63b64b4bb6c372e8f41ed0acc9bb\"\n+checksum = \"74cfb39880a59e122232cb5fb06b20b4382d58c12fa9747d16f846d38a7b094c\"\n dependencies = [\n- \"object\",\n+ \"object 0.31.1\",\n ]\n \n [[package]]\n@@ -233,7 +233,7 @@ dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.30.1\",\n  \"rustc-demangle\",\n ]\n \n@@ -331,6 +331,12 @@ dependencies = [\n  \"packed_simd_2\",\n ]\n \n+[[package]]\n+name = \"byteorder\"\n+version = \"1.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n+\n [[package]]\n name = \"bytes\"\n version = \"1.0.1\"\n@@ -629,7 +635,7 @@ dependencies = [\n  \"itertools\",\n  \"pulldown-cmark\",\n  \"quine-mc_cluskey\",\n- \"regex-syntax\",\n+ \"regex-syntax 0.7.1\",\n  \"rustc-semver\",\n  \"semver\",\n  \"serde\",\n@@ -723,6 +729,7 @@ dependencies = [\n name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n+ \"anyhow\",\n  \"build_helper\",\n  \"colored\",\n  \"diff\",\n@@ -2364,13 +2371,23 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8d864c91689fdc196779b98dba0aceac6118594c2df6ee5d943eb6a8df4d107a\"\n dependencies = [\n  \"compiler_builtins\",\n+ \"memchr\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.31.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8bda667d9f2b5051b8833f59f3bf748b28ef54f850f4fcb389a252aa383866d1\"\n+dependencies = [\n  \"crc32fast\",\n  \"flate2\",\n  \"hashbrown 0.13.1\",\n  \"indexmap\",\n  \"memchr\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n+ \"ruzstd\",\n ]\n \n [[package]]\n@@ -2695,9 +2712,9 @@ checksum = \"dbf0c48bc1d91375ae5c3cd81e3722dff1abcf81a30960240640d223f59fe0e5\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.53\"\n+version = \"1.0.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ba466839c78239c09faf015484e5cc04860f88242cff4d03eb038f04b4699b73\"\n+checksum = \"2b63bdb0cd06f1f4dedf69b254734f9b45af66e4a031e42a7480257d9898b435\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -2865,7 +2882,7 @@ checksum = \"d83f127d94bdbcda4c8cc2e50f6f84f4b611f69c902699ca385a39c3a75f9ff1\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n- \"regex-syntax\",\n+ \"regex-syntax 0.6.26\",\n ]\n \n [[package]]\n@@ -2874,7 +2891,7 @@ version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132\"\n dependencies = [\n- \"regex-syntax\",\n+ \"regex-syntax 0.6.26\",\n ]\n \n [[package]]\n@@ -2892,6 +2909,12 @@ version = \"0.6.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64\"\n \n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a5996294f19bd3aae0453a862ad728f60e6600695733dd5df01da90c54363a3c\"\n+\n [[package]]\n name = \"remote-test-client\"\n version = \"0.1.0\"\n@@ -3222,7 +3245,7 @@ dependencies = [\n  \"cstr\",\n  \"libc\",\n  \"measureme\",\n- \"object\",\n+ \"object 0.31.1\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3258,7 +3281,7 @@ dependencies = [\n  \"itertools\",\n  \"jobserver\",\n  \"libc\",\n- \"object\",\n+ \"object 0.31.1\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_arena\",\n@@ -4417,6 +4440,17 @@ version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"61b3909d758bb75c79f23d4736fac9433868679d3ad2ea7a61e3c25cfda9a088\"\n \n+[[package]]\n+name = \"ruzstd\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9a15e661f0f9dac21f3494fe5d23a6338c0ac116a2d22c2b63010acd89467ffe\"\n+dependencies = [\n+ \"byteorder\",\n+ \"thiserror\",\n+ \"twox-hash\",\n+]\n+\n [[package]]\n name = \"ryu\"\n version = \"1.0.5\"\n@@ -4477,18 +4511,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.159\"\n+version = \"1.0.160\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3c04e8343c3daeec41f58990b9d77068df31209f2af111e059e9fe9646693065\"\n+checksum = \"bb2f3770c8bce3bcda7e149193a069a0f4365bda1fa5cd88e03bca26afc1216c\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.159\"\n+version = \"1.0.160\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c614d17805b093df4b147b51339e7e44bf05ef59fba1e45d83500bcfb4d8585\"\n+checksum = \"291a097c63d8497e00160b166a967a4a79c64f3facdd01cbd7502231688d77df\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4653,7 +4687,7 @@ dependencies = [\n  \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.30.1\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -4925,13 +4959,13 @@ dependencies = [\n \n [[package]]\n name = \"thorin-dwp\"\n-version = \"0.4.0\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"da8fbf660a019b6bf11ea95762041464aa9099cc293b6a66d77cea5107619671\"\n+checksum = \"98c040e1340b889d4180c64e1d787efa9c32cb1617757e101480b61238b0d927\"\n dependencies = [\n  \"gimli 0.26.2\",\n  \"hashbrown 0.12.3\",\n- \"object\",\n+ \"object 0.31.1\",\n  \"tracing\",\n ]\n "}, {"sha": "f11c1c77f9cfc30a180ae8f3f669105dc22804af", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -12,7 +12,7 @@ use tracing::debug;\n pub trait LayoutCalculator {\n     type TargetDataLayoutRef: Borrow<TargetDataLayout>;\n \n-    fn delay_bug(&self, txt: &str);\n+    fn delay_bug(&self, txt: String);\n     fn current_data_layout(&self) -> Self::TargetDataLayoutRef;\n \n     fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutS {\n@@ -969,7 +969,7 @@ fn univariant(\n     for &i in &inverse_memory_index {\n         let field = &fields[i];\n         if !sized {\n-            this.delay_bug(&format!(\n+            this.delay_bug(format!(\n                 \"univariant: field #{} comes after unsized field\",\n                 offsets.len(),\n             ));"}, {"sha": "211f5cb0a2a3cb4b3d13df45955f6520a1607424", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -58,7 +58,7 @@ use rustc_errors::{\n use rustc_fluent_macro::fluent_messages;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::{Idx, IndexSlice, IndexVec};\n@@ -435,6 +435,7 @@ pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     // Queries that borrow `resolver_for_lowering`.\n     tcx.ensure_with_value().output_filenames(());\n     tcx.ensure_with_value().early_lint_checks(());\n+    tcx.ensure_with_value().debugger_visualizers(LOCAL_CRATE);\n     let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);"}, {"sha": "372a58857f3d38bbca4e62f9832f0a06122368d4", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -23,8 +23,7 @@ use crate::session_diagnostics::{self, IncorrectReprFormatGenericCause};\n pub const VERSION_PLACEHOLDER: &str = \"CURRENT_RUSTC_VERSION\";\n \n pub fn rust_version_symbol() -> Symbol {\n-    let version = option_env!(\"CFG_VERSION\").unwrap_or(\"<current>\");\n-    let version = version.split(' ').next().unwrap();\n+    let version = option_env!(\"CFG_RELEASE\").unwrap_or(\"<current>\");\n     Symbol::intern(&version)\n }\n "}, {"sha": "b6ccf924a5c88ec19ccf537c042fe9d34d72b35f", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -430,7 +430,7 @@ pub(super) fn dump_annotation<'tcx>(\n fn for_each_region_constraint<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     closure_region_requirements: &ClosureRegionRequirements<'tcx>,\n-    with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n+    with_msg: &mut dyn FnMut(String) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n         let subject = match req.subject {\n@@ -439,7 +439,7 @@ fn for_each_region_constraint<'tcx>(\n                 format!(\"{:?}\", ty.instantiate(tcx, |vid| tcx.mk_re_var(vid)))\n             }\n         };\n-        with_msg(&format!(\"where {}: {:?}\", subject, req.outlived_free_region,))?;\n+        with_msg(format!(\"where {}: {:?}\", subject, req.outlived_free_region,))?;\n     }\n     Ok(())\n }"}, {"sha": "fa4bc926f273916806c823c73b1e03f1e60e4287", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -71,7 +71,7 @@ macro_rules! span_mirbug {\n         $crate::type_check::mirbug(\n             $context.tcx(),\n             $context.last_span,\n-            &format!(\n+            format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n                 $context.body().source.def_id(),\n                 $elem,\n@@ -274,7 +274,7 @@ fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n }\n \n #[track_caller]\n-fn mirbug(tcx: TyCtxt<'_>, span: Span, msg: &str) {\n+fn mirbug(tcx: TyCtxt<'_>, span: Span, msg: String) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n     // to avoid reporting bugs in those cases."}, {"sha": "5217e317adfee7898ca63c950b80dccc86aaaff8", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -550,7 +550,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n         if !parser.errors.is_empty() {\n             let err = parser.errors.remove(0);\n             let err_sp = template_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n-            let msg = &format!(\"invalid asm template string: {}\", err.description);\n+            let msg = format!(\"invalid asm template string: {}\", err.description);\n             let mut e = ecx.struct_span_err(err_sp, msg);\n             e.span_label(err_sp, err.label + \" in asm template string\");\n             if let Some(note) = err.note {\n@@ -585,7 +585,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                 || args.reg_args.contains(idx)\n                             {\n                                 let msg = format!(\"invalid reference to argument at index {}\", idx);\n-                                let mut err = ecx.struct_span_err(span, &msg);\n+                                let mut err = ecx.struct_span_err(span, msg);\n                                 err.span_label(span, \"from here\");\n \n                                 let positional_args = args.operands.len()\n@@ -638,7 +638,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                     ecx.struct_span_err(\n                                         template_span\n                                             .from_inner(InnerSpan::new(span.start, span.end)),\n-                                        &msg,\n+                                        msg,\n                                     )\n                                     .emit();\n                                     None"}, {"sha": "ed91cea4ae26ae1dcb29a8cb393386b79a9ce867", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -166,7 +166,9 @@ impl CfgEval<'_, '_> {\n                     ))\n                 },\n                 Annotatable::Stmt(_) => |parser| {\n-                    Ok(Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes)?.unwrap())))\n+                    Ok(Annotatable::Stmt(P(parser\n+                        .parse_stmt_without_recovery(false, ForceCollect::Yes)?\n+                        .unwrap())))\n                 },\n                 Annotatable::Expr(_) => {\n                     |parser| Ok(Annotatable::Expr(parser.parse_expr_force_collect()?))"}, {"sha": "9883563746e905f172ad3a387deb99b1885dbbf8", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -145,7 +145,7 @@ fn cs_clone_simple(\n             }\n             _ => cx.span_bug(\n                 trait_span,\n-                &format!(\"unexpected substructure in simple `derive({})`\", name),\n+                format!(\"unexpected substructure in simple `derive({})`\", name),\n             ),\n         }\n     }\n@@ -179,10 +179,10 @@ fn cs_clone(\n             vdata = &variant.data;\n         }\n         EnumTag(..) | AllFieldlessEnum(..) => {\n-            cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,))\n+            cx.span_bug(trait_span, format!(\"enum tags in `derive({})`\", name,))\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n-            cx.span_bug(trait_span, &format!(\"associated function in `derive({})`\", name))\n+            cx.span_bug(trait_span, format!(\"associated function in `derive({})`\", name))\n         }\n     }\n \n@@ -194,7 +194,7 @@ fn cs_clone(\n                     let Some(ident) = field.name else {\n                         cx.span_bug(\n                             trait_span,\n-                            &format!(\"unnamed field in normal struct in `derive({})`\", name,),\n+                            format!(\"unnamed field in normal struct in `derive({})`\", name,),\n                         );\n                     };\n                     let call = subcall(cx, field);"}, {"sha": "4ba09335cb7abfe961631ad5234889ca6a475ef7", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1591,7 +1591,7 @@ impl<'a> TraitDef<'a> {\n                                 BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n                                 sp,\n                                 ast::CRATE_NODE_ID,\n-                                &format!(\n+                                format!(\n                                     \"{} slice in a packed struct that derives a built-in trait\",\n                                     ty\n                                 ),"}, {"sha": "c59a733c05568974757c0f92773cf748ac2bee4c", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -814,7 +814,7 @@ fn report_invalid_references(\n         };\n         e = ecx.struct_span_err(\n             span,\n-            &format!(\"invalid reference to positional {} ({})\", arg_list, num_args_desc),\n+            format!(\"invalid reference to positional {} ({})\", arg_list, num_args_desc),\n         );\n         e.note(\"positional arguments are zero-based\");\n     }"}, {"sha": "e613b904d2eaf66439115ddb07f72b9cb93a29b4", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -188,12 +188,12 @@ pub fn expand_include_str(\n                 base::MacEager::expr(cx.expr_str(sp, interned_src))\n             }\n             Err(_) => {\n-                cx.span_err(sp, &format!(\"{} wasn't a utf-8 file\", file.display()));\n+                cx.span_err(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n                 DummyResult::any(sp)\n             }\n         },\n         Err(e) => {\n-            cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n             DummyResult::any(sp)\n         }\n     }\n@@ -221,7 +221,7 @@ pub fn expand_include_bytes(\n             base::MacEager::expr(expr)\n         }\n         Err(e) => {\n-            cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n             DummyResult::any(sp)\n         }\n     }"}, {"sha": "1007b33eca42d73aa787779cac302f09d70c07b8", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -227,7 +227,7 @@ pub(crate) fn write_ir_file(\n         // Using early_warn as no Session is available here\n         rustc_session::early_warn(\n             rustc_session::config::ErrorOutputType::default(),\n-            &format!(\"error writing ir file: {}\", err),\n+            format!(\"error writing ir file: {}\", err),\n         );\n     }\n }"}, {"sha": "ad51f2d095857bc08c343076a029dc39fff32669", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -11,7 +11,7 @@ bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-object = { version = \"0.30.1\", default-features = false, features = [\n+object = { version = \"0.31.1\", default-features = false, features = [\n     \"std\",\n     \"read\",\n ] }"}, {"sha": "37f30917609aef11ab1d286fc5183abc45e70645", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -9,10 +9,9 @@ use rustc_ast::attr;\n use rustc_codegen_ssa::base::collect_debugger_visualizers_transitive;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_middle::bug;\n+use rustc_middle::{bug, middle::debugger_visualizer::DebuggerVisualizerType};\n use rustc_session::config::{CrateType, DebugInfo};\n use rustc_span::symbol::sym;\n-use rustc_span::DebuggerVisualizerType;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker."}, {"sha": "bd2fba12602827dc8172b38ad3548033aeeb931e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -806,8 +806,7 @@ pub fn build_compile_unit_di_node<'ll, 'tcx>(\n     name_in_debuginfo.push(codegen_unit_name);\n \n     debug!(\"build_compile_unit_di_node: {:?}\", name_in_debuginfo);\n-    let rustc_producer =\n-        format!(\"rustc version {}\", option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),);\n+    let rustc_producer = format!(\"rustc version {}\", tcx.sess.cfg_version);\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n "}, {"sha": "0ac12d32be535925c9a029a7f0ebf0db3e858466", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -14,7 +14,7 @@ itertools = \"0.10.1\"\n tracing = \"0.1\"\n jobserver = \"0.1.22\"\n tempfile = \"3.2\"\n-thorin-dwp = \"0.4\"\n+thorin-dwp = \"0.6\"\n pathdiff = \"0.2.0\"\n serde_json = \"1.0.59\"\n snap = \"1\"\n@@ -46,7 +46,7 @@ rustc_session = { path = \"../rustc_session\" }\n libc = \"0.2.50\"\n \n [dependencies.object]\n-version = \"0.30.1\"\n+version = \"0.31.1\"\n default-features = false\n features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]\n "}, {"sha": "8a00c42a0e8bd9fd149d7cc84e4b85df4614c22d", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -9,6 +9,7 @@ use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_metadata::find_native_static_library;\n use rustc_metadata::fs::{emit_wrapper_file, METADATA_FILENAME};\n+use rustc_middle::middle::debugger_visualizer::DebuggerVisualizerFile;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n@@ -21,7 +22,6 @@ use rustc_session::utils::NativeLibKind;\n /// need out of the shared crate context before we get rid of it.\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n-use rustc_span::DebuggerVisualizerFile;\n use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, LinkerFlavorCli, Lld, PanicStrategy};\n use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo};\n@@ -574,6 +574,8 @@ fn link_staticlib<'a>(\n         }\n     }\n \n+    all_native_libs.extend_from_slice(&codegen_results.crate_info.used_libraries);\n+\n     if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n         print_native_static_libs(sess, &all_native_libs, &all_rust_dylibs);\n     }"}, {"sha": "15c7847155d2f0a509181ee8d9c8779f68acda64", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -23,6 +23,7 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc_middle::middle::debugger_visualizer::{DebuggerVisualizerFile, DebuggerVisualizerType};\n use rustc_middle::middle::exported_symbols;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_middle::middle::lang_items;\n@@ -35,7 +36,6 @@ use rustc_session::config::{self, CrateType, EntryFnType, OutputType};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n-use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n use rustc_target::abi::{Align, FIRST_VARIANT};\n \n use std::collections::BTreeSet;"}, {"sha": "31854c7f4c4e0cb6501d9b3631c9266cf0243e18", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -28,6 +28,7 @@ use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_fluent_macro::fluent_messages;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::dep_graph::WorkProduct;\n+use rustc_middle::middle::debugger_visualizer::DebuggerVisualizerFile;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_middle::query::{ExternProviders, Providers};\n@@ -36,8 +37,8 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_session::config::{CrateType, OutputFilenames, OutputType, RUST_CGU_EXT};\n use rustc_session::cstore::{self, CrateSource};\n use rustc_session::utils::NativeLibKind;\n+use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_span::DebuggerVisualizerFile;\n use std::collections::BTreeSet;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -175,11 +176,11 @@ pub struct CodegenResults {\n     pub crate_info: CrateInfo,\n }\n \n-pub enum CodegenErrors<'a> {\n+pub enum CodegenErrors {\n     WrongFileType,\n     EmptyVersionNumber,\n     EncodingVersionMismatch { version_array: String, rlink_version: u32 },\n-    RustcVersionMismatch { rustc_version: String, current_version: &'a str },\n+    RustcVersionMismatch { rustc_version: String },\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -213,10 +214,9 @@ pub fn looks_like_rust_object_file(filename: &str) -> bool {\n const RLINK_VERSION: u32 = 1;\n const RLINK_MAGIC: &[u8] = b\"rustlink\";\n \n-const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n-\n impl CodegenResults {\n     pub fn serialize_rlink(\n+        sess: &Session,\n         rlink_file: &Path,\n         codegen_results: &CodegenResults,\n     ) -> Result<usize, io::Error> {\n@@ -225,12 +225,12 @@ impl CodegenResults {\n         // `emit_raw_bytes` is used to make sure that the version representation does not depend on\n         // Encoder's inner representation of `u32`.\n         encoder.emit_raw_bytes(&RLINK_VERSION.to_be_bytes());\n-        encoder.emit_str(RUSTC_VERSION.unwrap());\n+        encoder.emit_str(sess.cfg_version);\n         Encodable::encode(codegen_results, &mut encoder);\n         encoder.finish()\n     }\n \n-    pub fn deserialize_rlink<'a>(data: Vec<u8>) -> Result<Self, CodegenErrors<'a>> {\n+    pub fn deserialize_rlink(sess: &Session, data: Vec<u8>) -> Result<Self, CodegenErrors> {\n         // The Decodable machinery is not used here because it panics if the input data is invalid\n         // and because its internal representation may change.\n         if !data.starts_with(RLINK_MAGIC) {\n@@ -252,11 +252,9 @@ impl CodegenResults {\n \n         let mut decoder = MemDecoder::new(&data[4..], 0);\n         let rustc_version = decoder.read_str();\n-        let current_version = RUSTC_VERSION.unwrap();\n-        if rustc_version != current_version {\n+        if rustc_version != sess.cfg_version {\n             return Err(CodegenErrors::RustcVersionMismatch {\n                 rustc_version: rustc_version.to_string(),\n-                current_version,\n             });\n         }\n "}, {"sha": "c5976a65411fdd739afe6170077beb04099c4b67", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -250,6 +250,7 @@ const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"f\", Some(sym::riscv_target_feature)),\n     (\"m\", Some(sym::riscv_target_feature)),\n     (\"relax\", Some(sym::riscv_target_feature)),\n+    (\"unaligned-scalar-mem\", Some(sym::riscv_target_feature)),\n     (\"v\", Some(sym::riscv_target_feature)),\n     (\"zba\", Some(sym::riscv_target_feature)),\n     (\"zbb\", Some(sym::riscv_target_feature)),"}, {"sha": "594ed1ad2e70748d60aebf25541c4f1769d520d2", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -109,28 +109,27 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // they have been placed in the bucket.\n         //\n         // We compute a partial set of immediate dominators here.\n-        let z = parent[w];\n-        for &v in bucket[z].iter() {\n+        for &v in bucket[w].iter() {\n             // This uses the result of Lemma 5 from section 2 from the original\n             // 1979 paper, to compute either the immediate or relative dominator\n             // for a given vertex v.\n             //\n             // eval returns a vertex y, for which semi[y] is minimum among\n-            // vertices semi[v] +> y *> v. Note that semi[v] = z as we're in the\n-            // z bucket.\n+            // vertices semi[v] +> y *> v. Note that semi[v] = w as we're in the\n+            // w bucket.\n             //\n             // Given such a vertex y, semi[y] <= semi[v] and idom[y] = idom[v].\n             // If semi[y] = semi[v], though, idom[v] = semi[v].\n             //\n             // Using this, we can either set idom[v] to be:\n-            //  * semi[v] (i.e. z), if semi[y] is z\n+            //  * semi[v] (i.e. w), if semi[y] is w\n             //  * idom[y], otherwise\n             //\n             // We don't directly set to idom[y] though as it's not necessarily\n             // known yet. The second preorder traversal will cleanup by updating\n             // the idom for any that were missed in this pass.\n             let y = eval(&mut parent, lastlinked, &semi, &mut label, v);\n-            idom[v] = if semi[y] < z { y } else { z };\n+            idom[v] = if semi[y] < w { y } else { w };\n         }\n \n         // This loop computes the semi[w] for w.\n@@ -213,10 +212,11 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // If we don't yet know the idom directly, then push this vertex into\n         // our semidominator's bucket, where it will get processed at a later\n         // stage to compute its immediate dominator.\n-        if parent[w] != semi[w] {\n+        let z = parent[w];\n+        if z != semi[w] {\n             bucket[semi[w]].push(w);\n         } else {\n-            idom[w] = parent[w];\n+            idom[w] = z;\n         }\n \n         // Optimization: We share the parent array between processed and not"}, {"sha": "5472bb8087ec79b98a99f373176b45016b1f2065", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -53,3 +53,30 @@ fn immediate_dominator() {\n     assert_eq!(dominators.immediate_dominator(2), Some(1));\n     assert_eq!(dominators.immediate_dominator(3), Some(2));\n }\n+\n+#[test]\n+fn transitive_dominator() {\n+    let graph = TestGraph::new(\n+        0,\n+        &[\n+            // First tree branch.\n+            (0, 1),\n+            (1, 2),\n+            (2, 3),\n+            (3, 4),\n+            // Second tree branch.\n+            (1, 5),\n+            (5, 6),\n+            // Third tree branch.\n+            (0, 7),\n+            // These links make 0 the dominator for 2 and 3.\n+            (7, 2),\n+            (5, 3),\n+        ],\n+    );\n+\n+    let dom_tree = dominators(&graph);\n+    let immediate_dominators = &dom_tree.immediate_dominators;\n+    assert_eq!(immediate_dominators[2], Some(0));\n+    assert_eq!(immediate_dominators[3], Some(0)); // This used to return Some(1).\n+}"}, {"sha": "d61bb55be6836968d87f1cf09a86a0300eba266f", "filename": "compiler/rustc_data_structures/src/sync/worker_local.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -154,13 +154,6 @@ impl<T> WorkerLocal<T> {\n     }\n }\n \n-impl<T> WorkerLocal<Vec<T>> {\n-    /// Joins the elements of all the worker locals into one Vec\n-    pub fn join(self) -> Vec<T> {\n-        self.into_inner().into_iter().flat_map(|v| v).collect()\n-    }\n-}\n-\n impl<T> Deref for WorkerLocal<T> {\n     type Target = T;\n "}, {"sha": "a713affa0991938835e8122c979a8e293d46e9c2", "filename": "compiler/rustc_driver_impl/src/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -25,7 +25,7 @@ pub fn arg_expand_all(at_args: &[String]) -> Vec<String> {\n             Ok(arg) => args.extend(arg),\n             Err(err) => rustc_session::early_error(\n                 rustc_session::config::ErrorOutputType::default(),\n-                &format!(\"Failed to load argument file: {err}\"),\n+                format!(\"Failed to load argument file: {err}\"),\n             ),\n         }\n     }"}, {"sha": "6c204b894a6ad27a5f1fbbc97af7dd5b6bfb5c04", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -322,7 +322,7 @@ fn run_compiler(\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(\n                 config.opts.error_format,\n-                &format!(\n+                format!(\n                     \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n                     matches.free[0], matches.free[1],\n                 ),\n@@ -527,7 +527,7 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n             }\n         }\n         Err(InvalidErrorCode) => {\n-            early_error(output, &format!(\"{code} is not a valid error code\"));\n+            early_error(output, format!(\"{code} is not a valid error code\"));\n         }\n     }\n }\n@@ -572,7 +572,7 @@ pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Comp\n             let rlink_data = fs::read(file).unwrap_or_else(|err| {\n                 sess.emit_fatal(RlinkUnableToRead { err });\n             });\n-            let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n+            let codegen_results = match CodegenResults::deserialize_rlink(sess, rlink_data) {\n                 Ok(codegen) => codegen,\n                 Err(err) => {\n                     match err {\n@@ -586,10 +586,10 @@ pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Comp\n                                 rlink_version,\n                             })\n                         }\n-                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n+                        CodegenErrors::RustcVersionMismatch { rustc_version } => {\n                             sess.emit_fatal(RLinkRustcVersionMismatch {\n                                 rustc_version,\n-                                current_version,\n+                                current_version: sess.cfg_version,\n                             })\n                         }\n                     };\n@@ -1102,7 +1102,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n                 .map(|(flag, _)| format!(\"{e}. Did you mean `-{flag} {opt}`?\")),\n             _ => None,\n         };\n-        early_error(ErrorOutputType::default(), &msg.unwrap_or_else(|| e.to_string()));\n+        early_error(ErrorOutputType::default(), msg.unwrap_or_else(|| e.to_string()));\n     });\n \n     // For all options we just parsed, we check a few aspects:\n@@ -1250,7 +1250,8 @@ pub fn install_ice_hook(bug_report_url: &'static str, extra_info: fn(&Handler))\n         #[cfg(windows)]\n         if let Some(msg) = info.payload().downcast_ref::<String>() {\n             if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\") {\n-                early_error_no_abort(ErrorOutputType::default(), &msg);\n+                // the error code is already going to be reported when the panic unwinds up the stack\n+                let _ = early_error_no_abort(ErrorOutputType::default(), msg.as_str());\n                 return;\n             }\n         };\n@@ -1342,7 +1343,7 @@ pub fn init_rustc_env_logger() {\n /// other than `RUSTC_LOG`.\n pub fn init_env_logger(env: &str) {\n     if let Err(error) = rustc_log::init_env_logger(env) {\n-        early_error(ErrorOutputType::default(), &error.to_string());\n+        early_error(ErrorOutputType::default(), error.to_string());\n     }\n }\n \n@@ -1409,7 +1410,7 @@ pub fn main() -> ! {\n                 arg.into_string().unwrap_or_else(|arg| {\n                     early_error(\n                         ErrorOutputType::default(),\n-                        &format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n+                        format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n                     )\n                 })\n             })"}, {"sha": "3e38d6afb0b8eed4b383bef78fbf05dd54db2d3e", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -2303,22 +2303,25 @@ impl EmitterWriter {\n \n         // Colorize addition/replacements with green.\n         for &SubstitutionHighlight { start, end } in highlight_parts {\n-            // Account for tabs when highlighting (#87972).\n-            let tabs: usize = line_to_add\n-                .chars()\n-                .take(start)\n-                .map(|ch| match ch {\n-                    '\\t' => 3,\n-                    _ => 0,\n-                })\n-                .sum();\n-            buffer.set_style_range(\n-                *row_num,\n-                max_line_num_len + 3 + start + tabs,\n-                max_line_num_len + 3 + end + tabs,\n-                Style::Addition,\n-                true,\n-            );\n+            // This is a no-op for empty ranges\n+            if start != end {\n+                // Account for tabs when highlighting (#87972).\n+                let tabs: usize = line_to_add\n+                    .chars()\n+                    .take(start)\n+                    .map(|ch| match ch {\n+                        '\\t' => 3,\n+                        _ => 0,\n+                    })\n+                    .sum();\n+                buffer.set_style_range(\n+                    *row_num,\n+                    max_line_num_len + 3 + start + tabs,\n+                    max_line_num_len + 3 + end + tabs,\n+                    Style::Addition,\n+                    true,\n+                );\n+            }\n         }\n         *row_num += 1;\n     }"}, {"sha": "5a80024f19bf5ed517a86b5bc6544b301eeadbab", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -330,12 +330,11 @@ impl CodeSuggestion {\n                     });\n                     buf.push_str(&part.snippet);\n                     let cur_hi = sm.lookup_char_pos(part.span.hi());\n-                    if cur_hi.line == cur_lo.line && !part.snippet.is_empty() {\n-                        // Account for the difference between the width of the current code and the\n-                        // snippet being suggested, so that the *later* suggestions are correctly\n-                        // aligned on the screen.\n-                        acc += len - (cur_hi.col.0 - cur_lo.col.0) as isize;\n-                    }\n+                    // Account for the difference between the width of the current code and the\n+                    // snippet being suggested, so that the *later* suggestions are correctly\n+                    // aligned on the screen. Note that cur_hi and cur_lo can be on different\n+                    // lines, so cur_hi.col can be smaller than cur_lo.col\n+                    acc += len - (cur_hi.col.0 as isize - cur_lo.col.0 as isize);\n                     prev_hi = cur_hi;\n                     prev_line = sf.get_line(prev_hi.line - 1);\n                     for line in part.snippet.split('\\n').skip(1) {\n@@ -1740,7 +1739,7 @@ impl DelayedDiagnostic {\n     }\n \n     fn decorate(mut self) -> Diagnostic {\n-        self.inner.note(format!(\"delayed at {}\", self.note));\n+        self.inner.note(format!(\"delayed at {}\\n{}\", self.inner.emitted_at, self.note));\n         self.inner\n     }\n }"}, {"sha": "fd721749066474027e4a96dc5ba87ff7130b65c6", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -15,7 +15,8 @@ use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{\n-    Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan, PResult,\n+    Applicability, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, IntoDiagnostic,\n+    MultiSpan, PResult,\n };\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, RegisteredTools};\n@@ -1110,7 +1111,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         self.sess.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n     }\n@@ -1132,14 +1133,14 @@ impl<'a> ExtCtxt<'a> {\n     /// Compilation will be stopped in the near future (at the end of\n     /// the macro expansion phase).\n     #[rustc_lint_diagnostics]\n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.sess.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n     #[rustc_lint_diagnostics]\n-    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.sess.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n+    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.sess.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n     pub fn trace_macros_diag(&mut self) {"}, {"sha": "5d369a1879a29305467669a9d05b849b4fb7fe32", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -722,7 +722,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                     });\n                                 }\n                             };\n-                            if fragment_kind == AstFragmentKind::Expr && items.is_empty() {\n+                            if matches!(\n+                                fragment_kind,\n+                                AstFragmentKind::Expr | AstFragmentKind::MethodReceiverExpr\n+                            ) && items.is_empty()\n+                            {\n                                 self.cx.emit_err(RemoveExprNotSupported { span });\n                                 fragment_kind.dummy(span)\n                             } else {\n@@ -1664,7 +1668,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         &UNUSED_ATTRIBUTES,\n                         attr.span,\n                         self.cx.current_expansion.lint_node_id,\n-                        &format!(\"unused attribute `{}`\", attr_name),\n+                        format!(\"unused attribute `{}`\", attr_name),\n                         BuiltinLintDiagnostics::UnusedBuiltinAttribute {\n                             attr_name,\n                             macro_name: pprust::path_to_string(&call.path),"}, {"sha": "cb8b4899e485ce4628e2acf3b153209a0086612c", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -48,7 +48,7 @@ pub(super) fn failed_to_match_macro<'cx>(\n \n     let span = token.span.substitute_dummy(sp);\n \n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    let mut err = cx.struct_span_err(span, parse_failure_msg(&token));\n     err.span_label(span, label);\n     if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n         err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n@@ -170,7 +170,7 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n             }\n             Error(err_sp, msg) => {\n                 let span = err_sp.substitute_dummy(self.root_span);\n-                self.cx.struct_span_err(span, msg).emit();\n+                self.cx.struct_span_err(span, msg.as_str()).emit();\n                 self.result = Some(DummyResult::any(span));\n             }\n             ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),"}, {"sha": "34f998274e99531ad6512e3eb3c7383f56030fd6", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -110,7 +110,7 @@ use crate::mbe::{KleeneToken, TokenTree};\n use rustc_ast::token::{Delimiter, Token, TokenKind};\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::MultiSpan;\n+use rustc_errors::{DiagnosticMessage, MultiSpan};\n use rustc_session::lint::builtin::{META_VARIABLE_MISUSE, MISSING_FRAGMENT_SPECIFIER};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::kw;\n@@ -593,7 +593,7 @@ fn check_ops_is_prefix(\n             return;\n         }\n     }\n-    buffer_lint(sess, span.into(), node_id, &format!(\"unknown macro variable `{}`\", name));\n+    buffer_lint(sess, span.into(), node_id, format!(\"unknown macro variable `{}`\", name));\n }\n \n /// Returns whether `binder_ops` is a prefix of `occurrence_ops`.\n@@ -626,7 +626,7 @@ fn ops_is_prefix(\n         if i >= occurrence_ops.len() {\n             let mut span = MultiSpan::from_span(span);\n             span.push_span_label(binder.span, \"expected repetition\");\n-            let message = &format!(\"variable '{}' is still repeating at this depth\", name);\n+            let message = format!(\"variable '{}' is still repeating at this depth\", name);\n             buffer_lint(sess, span, node_id, message);\n             return;\n         }\n@@ -642,7 +642,12 @@ fn ops_is_prefix(\n     }\n }\n \n-fn buffer_lint(sess: &ParseSess, span: MultiSpan, node_id: NodeId, message: &str) {\n+fn buffer_lint(\n+    sess: &ParseSess,\n+    span: MultiSpan,\n+    node_id: NodeId,\n+    message: impl Into<DiagnosticMessage>,\n+) {\n     // Macros loaded from other crates have dummy node ids.\n     if node_id != DUMMY_NODE_ID {\n         sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);"}, {"sha": "d523d3eacbeb9df1f94678fde5e760ed447a6dec", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -510,7 +510,7 @@ fn out_of_bounds_err<'a>(\n              must be less than {max}\"\n         )\n     };\n-    cx.struct_span_err(span, &msg)\n+    cx.struct_span_err(span, msg)\n }\n \n fn transcribe_metavar_expr<'a>("}, {"sha": "a40a0178710191c193403df094352d9b6dc0eb30", "filename": "compiler/rustc_hir/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -10,13 +10,13 @@ fn def_path_hash_depends_on_crate_id() {\n     // the crate-id of the defining crate. This is a desirable property\n     // because the crate-id can be more easily changed than the DefPath\n     // of an item, so, in the case of a crate-local DefPathHash collision,\n-    // the user can simply \"role the dice again\" for all DefPathHashes in\n+    // the user can simply \"roll the dice again\" for all DefPathHashes in\n     // the crate by changing the crate disambiguator (e.g. via bumping the\n     // crate's version number).\n \n     create_session_if_not_set_then(Edition::Edition2024, |_| {\n-        let id0 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"1\".to_string()]);\n-        let id1 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"2\".to_string()]);\n+        let id0 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"1\".to_string()], \"\");\n+        let id1 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"2\".to_string()], \"\");\n \n         let h0 = mk_test_hash(id0);\n         let h1 = mk_test_hash(id1);"}, {"sha": "39d1d1f2de52ad9ce74166b0b8b12f5ea6e3ade1", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -24,7 +24,7 @@ fn generic_arg_mismatch_err(\n     arg: &GenericArg<'_>,\n     param: &GenericParamDef,\n     possible_ordering_error: bool,\n-    help: Option<&str>,\n+    help: Option<String>,\n ) -> ErrorGuaranteed {\n     let sess = tcx.sess;\n     let mut err = struct_span_err!(\n@@ -300,7 +300,7 @@ pub fn create_substs_for_generic_args<'tcx, 'a>(\n                                     arg,\n                                     param,\n                                     !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n-                                    Some(&format!(\n+                                    Some(format!(\n                                         \"reorder the arguments: {}: `<{}>`\",\n                                         param_types_present\n                                             .into_iter()"}, {"sha": "22502bd4fdb98b28f68f81ff8d3b0052d71dedbc", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -73,7 +73,6 @@ pub fn provide(providers: &mut Providers) {\n         fn_sig,\n         impl_trait_ref,\n         impl_polarity,\n-        is_foreign_item,\n         generator_kind,\n         collect_mod_item_types,\n         is_type_alias_impl_trait,\n@@ -1466,10 +1465,6 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     fty\n }\n \n-fn is_foreign_item(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    matches!(tcx.hir().get_by_def_id(def_id), Node::ForeignItem(..))\n-}\n-\n fn generator_kind(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<hir::GeneratorKind> {\n     match tcx.hir().get_by_def_id(def_id) {\n         Node::Expr(&rustc_hir::Expr {"}, {"sha": "ca430a5e8632434debd2acba8c3970b7db2ed1d0", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -164,7 +164,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n             let Some(type_dependent_def) = tables.type_dependent_def_id(parent_node_id) else {\n                 return tcx.ty_error_with_message(\n                     tcx.def_span(def_id),\n-                    &format!(\"unable to find type-dependent def for {:?}\", parent_node_id),\n+                    format!(\"unable to find type-dependent def for {:?}\", parent_node_id),\n                 );\n             };\n             let idx = segment\n@@ -205,14 +205,14 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n                     } else {\n                         return tcx.ty_error_with_message(\n                             tcx.def_span(def_id),\n-                            &format!(\"unable to find const parent for {} in pat {:?}\", hir_id, pat),\n+                            format!(\"unable to find const parent for {} in pat {:?}\", hir_id, pat),\n                         );\n                     }\n                 }\n                 _ => {\n                     return tcx.ty_error_with_message(\n                         tcx.def_span(def_id),\n-                        &format!(\"unexpected const parent path {:?}\", parent_node),\n+                        format!(\"unexpected const parent path {:?}\", parent_node),\n                     );\n                 }\n             };\n@@ -243,7 +243,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n                 None => {\n                     return tcx.ty_error_with_message(\n                         tcx.def_span(def_id),\n-                        &format!(\"unexpected anon const res {:?} in path: {:?}\", segment.res, path),\n+                        format!(\"unexpected anon const res {:?} in path: {:?}\", segment.res, path),\n                     );\n                 }\n             };\n@@ -253,7 +253,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n \n         _ => return tcx.ty_error_with_message(\n             tcx.def_span(def_id),\n-            &format!(\"unexpected const parent in type_of(): {parent_node:?}\"),\n+            format!(\"unexpected const parent in type_of(): {parent_node:?}\"),\n         ),\n     };\n \n@@ -279,7 +279,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n     } else {\n         return tcx.ty_error_with_message(\n             tcx.def_span(def_id),\n-            &format!(\"const generic parameter not found in {generics:?} at position {arg_idx:?}\"),\n+            format!(\"const generic parameter not found in {generics:?} at position {arg_idx:?}\"),\n         );\n     }\n }"}, {"sha": "adc1b090af675a1466e7e87ed6f50dd47d7cd4b1", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -721,7 +721,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // ICE this expression in particular (see #43162).\n                 if let ExprKind::Path(QPath::Resolved(_, path)) = e.kind {\n                     if path.segments.len() == 1 && path.segments[0].ident.name == sym::rust {\n-                        fatally_break_rust(self.tcx.sess);\n+                        fatally_break_rust(self.tcx);\n                     }\n                 }\n             }\n@@ -2469,7 +2469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             self.suggest_method_call(\n                 &mut err,\n-                &format!(\"a method `{field}` also exists, call it with parentheses\"),\n+                format!(\"a method `{field}` also exists, call it with parentheses\"),\n                 field,\n                 expr_t,\n                 expr,"}, {"sha": "64426c4cbbb70a5c44c6bbedb4e9c4fc5260516b", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -72,7 +72,6 @@ use rustc_middle::query::Providers;\n use rustc_middle::traits;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config;\n-use rustc_session::Session;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::{sym, Span};\n \n@@ -438,8 +437,8 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-fn fatally_break_rust(sess: &Session) {\n-    let handler = sess.diagnostic();\n+fn fatally_break_rust(tcx: TyCtxt<'_>) {\n+    let handler = tcx.sess.diagnostic();\n     handler.span_bug_no_panic(\n         MultiSpan::new(),\n         \"It looks like you're trying to break rust; would you like some ICE?\",\n@@ -451,7 +450,7 @@ fn fatally_break_rust(sess: &Session) {\n     );\n     handler.note_without_error(format!(\n         \"rustc {} running on {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+        tcx.sess.cfg_version,\n         config::host_triple(),\n     ));\n }"}, {"sha": "59bf45f0ed210dfeeed8edb049bd3566b1713473", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let Some((ty, n)) = autoderef.nth(pick.autoderefs) else {\n             return self.tcx.ty_error_with_message(\n                 rustc_span::DUMMY_SP,\n-                &format!(\"failed autoderef {}\", pick.autoderefs),\n+                format!(\"failed autoderef {}\", pick.autoderefs),\n             );\n         };\n         assert_eq!(n, pick.autoderefs);"}, {"sha": "6f4d674ba103bf4f090b54b63e639d315a8eb7ba", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -13,7 +13,7 @@ pub use self::MethodError::*;\n use crate::errors::OpMethodGenericParams;\n use crate::FnCtxt;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn suggest_method_call(\n         &self,\n         err: &mut Diagnostic,\n-        msg: &str,\n+        msg: impl Into<SubdiagnosticMessage> + std::fmt::Debug,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n         call_expr: &hir::Expr<'tcx>,"}, {"sha": "17364509844db802d6baf24764314c3a6f8a1f34", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -288,8 +288,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mode = no_match_data.mode;\n         let tcx = self.tcx;\n         let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-        let (ty_str, ty_file) = tcx.short_ty_string(rcvr_ty);\n-        let short_ty_str = with_forced_trimmed_paths!(rcvr_ty.to_string());\n+        let ((mut ty_str, ty_file), short_ty_str) = if trait_missing_method\n+            && let ty::Dynamic(predicates, _, _) = rcvr_ty.kind() {\n+                ((predicates.to_string(), None), with_forced_trimmed_paths!(predicates.to_string()))\n+            } else {\n+                (tcx.short_ty_string(rcvr_ty), with_forced_trimmed_paths!(rcvr_ty.to_string()))\n+            };\n         let is_method = mode == Mode::MethodCall;\n         let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n         let similar_candidate = no_match_data.similar_candidate;\n@@ -329,12 +333,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span = item_name.span;\n \n         // Don't show generic arguments when the method can't be found in any implementation (#81576).\n-        let mut ty_str_reported = if trait_missing_method {\n-            ty_str.strip_prefix(\"dyn \").expect(\"Failed to remove the prefix dyn\").to_owned()\n-        } else {\n-            ty_str.clone()\n-        };\n-\n+        let mut ty_str_reported = ty_str.clone();\n         if let ty::Adt(_, generics) = rcvr_ty.kind() {\n             if generics.len() > 0 {\n                 let mut autoderef = self.autoderef(span, rcvr_ty);\n@@ -383,14 +382,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if tcx.sess.source_map().is_multiline(sugg_span) {\n             err.span_label(sugg_span.with_hi(span.lo()), \"\");\n         }\n-        let mut ty_str = if short_ty_str.len() < ty_str.len() && ty_str.len() > 10 {\n-            short_ty_str\n-        } else {\n-            ty_str\n-        };\n-        if trait_missing_method {\n-            ty_str =\n-                ty_str.strip_prefix(\"dyn \").expect(\"Failed to remove the prefix dyn\").to_owned();\n+\n+        if short_ty_str.len() < ty_str.len() && ty_str.len() > 10 {\n+            ty_str = short_ty_str;\n         }\n \n         if let Some(file) = ty_file {"}, {"sha": "a4c6dd4332a6029904bd1093250a67f095a129cc", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -237,7 +237,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     // error has been emitted. (#64638)\n                     self.fcx.tcx.ty_error_with_message(\n                         e.span,\n-                        &format!(\"bad index {:?} for base: `{:?}`\", index, base),\n+                        format!(\"bad index {:?} for base: `{:?}`\", index, base),\n                     )\n                 });\n                 let index_ty = self.fcx.resolve_vars_if_possible(index_ty);\n@@ -692,15 +692,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.offset_of_data().items_in_stable_order()\n         {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n-\n-            if cfg!(debug_assertions) && container.has_infer() {\n-                span_bug!(\n-                    hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    container\n-                );\n-            };\n-\n+            let container = self.resolve(container, &hir_id);\n             self.typeck_results.offset_of_data_mut().insert(hir_id, (container, indices.clone()));\n         }\n     }"}, {"sha": "25bf83f64a08617b8276871c26a4f537f548b96c", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -14,6 +14,7 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encoder;\n use rustc_session::Session;\n+use std::borrow::Cow;\n use std::env;\n use std::fs;\n use std::io::{self, Read};\n@@ -25,17 +26,12 @@ const FILE_MAGIC: &[u8] = b\"RSIC\";\n /// Change this if the header format changes.\n const HEADER_FORMAT_VERSION: u16 = 0;\n \n-/// A version string that hopefully is always different for compiler versions\n-/// with different encodings of incremental compilation artifacts. Contains\n-/// the Git commit hash.\n-const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n-\n-pub(crate) fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) {\n+pub(crate) fn write_file_header(stream: &mut FileEncoder, sess: &Session) {\n     stream.emit_raw_bytes(FILE_MAGIC);\n     stream\n         .emit_raw_bytes(&[(HEADER_FORMAT_VERSION >> 0) as u8, (HEADER_FORMAT_VERSION >> 8) as u8]);\n \n-    let rustc_version = rustc_version(nightly_build);\n+    let rustc_version = rustc_version(sess.is_nightly_build(), sess.cfg_version);\n     assert_eq!(rustc_version.len(), (rustc_version.len() as u8) as usize);\n     stream.emit_raw_bytes(&[rustc_version.len() as u8]);\n     stream.emit_raw_bytes(rustc_version.as_bytes());\n@@ -73,7 +69,7 @@ where\n         }\n     };\n \n-    write_file_header(&mut encoder, sess.is_nightly_build());\n+    write_file_header(&mut encoder, sess);\n \n     match encode(encoder) {\n         Ok(position) => {\n@@ -100,9 +96,10 @@ where\n /// - Returns `Err(..)` if some kind of IO error occurred while reading the\n ///   file.\n pub fn read_file(\n-    report_incremental_info: bool,\n     path: &Path,\n-    nightly_build: bool,\n+    report_incremental_info: bool,\n+    is_nightly_build: bool,\n+    cfg_version: &'static str,\n ) -> io::Result<Option<(Mmap, usize)>> {\n     let file = match fs::File::open(path) {\n         Ok(file) => file,\n@@ -152,7 +149,7 @@ pub fn read_file(\n         let mut buffer = vec![0; rustc_version_str_len];\n         file.read_exact(&mut buffer)?;\n \n-        if buffer != rustc_version(nightly_build).as_bytes() {\n+        if buffer != rustc_version(is_nightly_build, cfg_version).as_bytes() {\n             report_format_mismatch(report_incremental_info, path, \"Different compiler version\");\n             return Ok(None);\n         }\n@@ -174,17 +171,15 @@ fn report_format_mismatch(report_incremental_info: bool, file: &Path, message: &\n     }\n }\n \n-fn rustc_version(nightly_build: bool) -> String {\n+/// A version string that hopefully is always different for compiler versions\n+/// with different encodings of incremental compilation artifacts. Contains\n+/// the Git commit hash.\n+fn rustc_version(nightly_build: bool, cfg_version: &'static str) -> Cow<'static, str> {\n     if nightly_build {\n-        if let Some(val) = env::var_os(\"RUSTC_FORCE_RUSTC_VERSION\") {\n-            return val.to_string_lossy().into_owned();\n+        if let Ok(val) = env::var(\"RUSTC_FORCE_RUSTC_VERSION\") {\n+            return val.into();\n         }\n     }\n \n-    RUSTC_VERSION\n-        .expect(\n-            \"Cannot use rustc without explicit version for \\\n-                          incremental compilation\",\n-        )\n-        .to_string()\n+    cfg_version.into()\n }"}, {"sha": "a4407a93ff3ba18f35450a86898e53d5b43802f8", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -73,12 +73,22 @@ impl<T: Default> LoadResult<T> {\n     }\n }\n \n-fn load_data(\n-    report_incremental_info: bool,\n+fn load_data(path: &Path, sess: &Session) -> LoadResult<(Mmap, usize)> {\n+    load_data_no_sess(\n+        path,\n+        sess.opts.unstable_opts.incremental_info,\n+        sess.is_nightly_build(),\n+        sess.cfg_version,\n+    )\n+}\n+\n+fn load_data_no_sess(\n     path: &Path,\n-    nightly_build: bool,\n+    report_incremental_info: bool,\n+    is_nightly_build: bool,\n+    cfg_version: &'static str,\n ) -> LoadResult<(Mmap, usize)> {\n-    match file_format::read_file(report_incremental_info, path, nightly_build) {\n+    match file_format::read_file(path, report_incremental_info, is_nightly_build, cfg_version) {\n         Ok(Some(data_and_pos)) => LoadResult::Ok { data: data_and_pos },\n         Ok(None) => {\n             // The file either didn't exist or was produced by an incompatible\n@@ -138,14 +148,13 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     let expected_hash = sess.opts.dep_tracking_hash(false);\n \n     let mut prev_work_products = FxHashMap::default();\n-    let nightly_build = sess.is_nightly_build();\n \n     // If we are only building with -Zquery-dep-graph but without an actual\n     // incr. comp. session directory, we skip this. Otherwise we'd fail\n     // when trying to load work products.\n     if sess.incr_comp_session_dir_opt().is_some() {\n         let work_products_path = work_products_path(sess);\n-        let load_result = load_data(report_incremental_info, &work_products_path, nightly_build);\n+        let load_result = load_data(&work_products_path, sess);\n \n         if let LoadResult::Ok { data: (work_products_data, start_pos) } = load_result {\n             // Decode the list of work_products\n@@ -173,10 +182,13 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n         }\n     }\n \n+    let is_nightly_build = sess.is_nightly_build();\n+    let cfg_version = sess.cfg_version;\n+\n     MaybeAsync::Async(std::thread::spawn(move || {\n         let _prof_timer = prof.generic_activity(\"incr_comp_load_dep_graph\");\n \n-        match load_data(report_incremental_info, &path, nightly_build) {\n+        match load_data_no_sess(&path, report_incremental_info, is_nightly_build, cfg_version) {\n             LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n             LoadResult::LoadDepGraph(path, err) => LoadResult::LoadDepGraph(path, err),\n             LoadResult::DecodeIncrCache(err) => LoadResult::DecodeIncrCache(err),\n@@ -218,11 +230,7 @@ pub fn load_query_result_cache(sess: &Session) -> Option<OnDiskCache<'_>> {\n \n     let _prof_timer = sess.prof.generic_activity(\"incr_comp_load_query_result_cache\");\n \n-    match load_data(\n-        sess.opts.unstable_opts.incremental_info,\n-        &query_cache_path(sess),\n-        sess.is_nightly_build(),\n-    ) {\n+    match load_data(&query_cache_path(sess), sess) {\n         LoadResult::Ok { data: (bytes, start_pos) } => {\n             Some(OnDiskCache::new(sess, bytes, start_pos))\n         }"}, {"sha": "7376be6be8b8a85d70d91b1aa8d354391c20cb76", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -164,7 +164,7 @@ pub fn build_dep_graph(\n         }\n     };\n \n-    file_format::write_file_header(&mut encoder, sess.is_nightly_build());\n+    file_format::write_file_header(&mut encoder, sess);\n \n     // First encode the commandline arguments hash\n     sess.opts.dep_tracking_hash(false).encode(&mut encoder);"}, {"sha": "de9afbbcaabbd3f433c6eb8dd47a6b8dd851af3d", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -153,20 +153,22 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Used by the new solver as that one takes the opaque types at the end of a probe\n     /// to deal with multiple candidates without having to recompute them.\n-    pub fn clone_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    pub fn clone_opaque_types_for_query_response(\n+        &self,\n+    ) -> Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)> {\n         self.inner\n             .borrow()\n             .opaque_type_storage\n             .opaque_types\n             .iter()\n-            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n+            .map(|(k, v)| (*k, v.hidden_type.ty))\n             .collect()\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    fn take_opaque_types_for_query_response(&self) -> Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)> {\n         std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n             .into_iter()\n-            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n+            .map(|(k, v)| (k, v.hidden_type.ty))\n             .collect()\n     }\n \n@@ -507,8 +509,22 @@ impl<'tcx> InferCtxt<'tcx> {\n             let a = substitute_value(self.tcx, &result_subst, a);\n             let b = substitute_value(self.tcx, &result_subst, b);\n             debug!(?a, ?b, \"constrain opaque type\");\n-            obligations\n-                .extend(self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, a, b)?.obligations);\n+            // We use equate here instead of, for example, just registering the\n+            // opaque type's hidden value directly, because we may be instantiating\n+            // a query response that was canonicalized in an InferCtxt that had\n+            // a different defining anchor. In that case, we may have inferred\n+            // `NonLocalOpaque := LocalOpaque` but can only instantiate it in\n+            // the other direction as `LocalOpaque := NonLocalOpaque`. Using eq\n+            // here allows us to try both directions (in `InferCtxt::handle_opaque_type`).\n+            obligations.extend(\n+                self.at(cause, param_env)\n+                    .eq(\n+                        DefineOpaqueTypes::Yes,\n+                        self.tcx.mk_opaque(a.def_id.to_def_id(), a.substs),\n+                        b,\n+                    )?\n+                    .obligations,\n+            );\n         }\n \n         Ok(InferOk { value: result_subst, obligations })"}, {"sha": "b88ba04b2737939562c8676c35b847e5da6a70ca", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -530,19 +530,18 @@ impl<'tcx> InferCtxt<'tcx> {\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n-\n-        let mut obligations = vec![];\n         let prev = self.inner.borrow_mut().opaque_types().register(\n             OpaqueTypeKey { def_id, substs },\n             OpaqueHiddenType { ty: hidden_ty, span },\n             origin,\n         );\n-        if let Some(prev) = prev {\n-            obligations = self\n-                .at(&cause, param_env)\n+        let mut obligations = if let Some(prev) = prev {\n+            self.at(&cause, param_env)\n                 .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n-                .obligations;\n-        }\n+                .obligations\n+        } else {\n+            Vec::new()\n+        };\n \n         let item_bounds = tcx.explicit_item_bounds(def_id);\n "}, {"sha": "681819703c29868b0ae678a457c83408acc285c8", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -80,7 +80,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                     ($reason: expr) => {\n                         early_error(\n                             ErrorOutputType::default(),\n-                            &format!(concat!(\"invalid `--cfg` argument: `{}` (\", $reason, \")\"), s),\n+                            format!(concat!(\"invalid `--cfg` argument: `{}` (\", $reason, \")\"), s),\n                         );\n                     };\n                 }\n@@ -139,10 +139,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                 ($reason: expr) => {\n                     early_error(\n                         ErrorOutputType::default(),\n-                        &format!(\n-                            concat!(\"invalid `--check-cfg` argument: `{}` (\", $reason, \")\"),\n-                            s\n-                        ),\n+                        format!(concat!(\"invalid `--check-cfg` argument: `{}` (\", $reason, \")\"), s),\n                     )\n                 };\n             }"}, {"sha": "42d8d228091789a7325e597cda767c5c943eb78b", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -89,6 +89,7 @@ pub fn register_plugins<'a>(\n         crate_name,\n         sess.crate_types().contains(&CrateType::Executable),\n         sess.opts.cg.metadata.clone(),\n+        sess.cfg_version,\n     );\n     sess.stable_crate_id.set(stable_crate_id).expect(\"not yet initialized\");\n     rustc_incremental::prepare_session_directory(sess, crate_name, stable_crate_id)?;\n@@ -486,6 +487,11 @@ fn write_out_deps(tcx: TyCtxt<'_>, outputs: &OutputFilenames, out_filenames: &[P\n             files.push(normalize_path(profile_sample.as_path().to_path_buf()));\n         }\n \n+        // Debugger visualizer files\n+        for debugger_visualizer in tcx.debugger_visualizers(LOCAL_CRATE) {\n+            files.push(normalize_path(debugger_visualizer.path.clone().unwrap()));\n+        }\n+\n         if sess.binary_dep_depinfo() {\n             if let Some(ref backend) = sess.opts.unstable_opts.codegen_backend {\n                 if backend.contains('.') {"}, {"sha": "c441a8ffd6f94179fd92c1b870e66190cb2cf6da", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -369,7 +369,7 @@ impl Linker {\n \n         if sess.opts.unstable_opts.no_link {\n             let rlink_file = self.prepare_outputs.with_extension(config::RLINK_EXT);\n-            CodegenResults::serialize_rlink(&rlink_file, &codegen_results)\n+            CodegenResults::serialize_rlink(sess, &rlink_file, &codegen_results)\n                 .map_err(|error| sess.emit_fatal(FailedWritingFile { path: &rlink_file, error }))?;\n             return Ok(());\n         }"}, {"sha": "28e719a40e565a1d76d8ef83a68f21bae5b0e507", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -52,7 +52,8 @@ fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n         output_file: None,\n         temps_dir,\n     };\n-    let sess = build_session(sessopts, io, None, registry, vec![], Default::default(), None, None);\n+    let sess =\n+        build_session(sessopts, io, None, registry, vec![], Default::default(), None, None, \"\");\n     (sess, cfg)\n }\n "}, {"sha": "cb19750203e8559a09ef51a4090f52551464066c", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -88,7 +88,7 @@ pub fn create_session(\n     ) {\n         Ok(bundle) => bundle,\n         Err(e) => {\n-            early_error(sopts.error_format, &format!(\"failed to load fluent bundle: {e}\"));\n+            early_error(sopts.error_format, format!(\"failed to load fluent bundle: {e}\"));\n         }\n     };\n \n@@ -104,6 +104,7 @@ pub fn create_session(\n         lint_caps,\n         file_loader,\n         target_override,\n+        rustc_version_str().unwrap_or(\"unknown\"),\n     );\n \n     codegen_backend.init(&sess);\n@@ -220,13 +221,13 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n fn load_backend_from_dylib(path: &Path) -> MakeBackendFn {\n     let lib = unsafe { Library::new(path) }.unwrap_or_else(|err| {\n         let err = format!(\"couldn't load codegen backend {path:?}: {err}\");\n-        early_error(ErrorOutputType::default(), &err);\n+        early_error(ErrorOutputType::default(), err);\n     });\n \n     let backend_sym = unsafe { lib.get::<MakeBackendFn>(b\"__rustc_codegen_backend\") }\n         .unwrap_or_else(|e| {\n             let err = format!(\"couldn't load codegen backend: {e}\");\n-            early_error(ErrorOutputType::default(), &err);\n+            early_error(ErrorOutputType::default(), err);\n         });\n \n     // Intentionally leak the dynamic library. We can't ever unload it\n@@ -320,7 +321,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n             \"failed to find a `codegen-backends` folder \\\n                            in the sysroot candidates:\\n* {candidates}\"\n         );\n-        early_error(ErrorOutputType::default(), &err);\n+        early_error(ErrorOutputType::default(), err);\n     });\n     info!(\"probing {} for a codegen backend\", sysroot.display());\n \n@@ -331,7 +332,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n             sysroot.display(),\n             e\n         );\n-        early_error(ErrorOutputType::default(), &err);\n+        early_error(ErrorOutputType::default(), err);\n     });\n \n     let mut file: Option<PathBuf> = None;\n@@ -359,7 +360,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n                 prev.display(),\n                 path.display()\n             );\n-            early_error(ErrorOutputType::default(), &err);\n+            early_error(ErrorOutputType::default(), err);\n         }\n         file = Some(path.clone());\n     }\n@@ -368,7 +369,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n         Some(ref s) => load_backend_from_dylib(s),\n         None => {\n             let err = format!(\"unsupported builtin codegen backend `{backend_name}`\");\n-            early_error(ErrorOutputType::default(), &err);\n+            early_error(ErrorOutputType::default(), err);\n         }\n     }\n }"}, {"sha": "e1658d3ff82b7fe2f56cc37d855b32bd98431601", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -521,18 +521,18 @@ lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its ass\n \n lint_opaque_hidden_inferred_bound_sugg = add this bound\n \n-lint_drop_ref = calls to `std::mem::drop` with a reference instead of an owned value does nothing\n+lint_dropping_references = calls to `std::mem::drop` with a reference instead of an owned value does nothing\n     .label = argument has type `{$arg_ty}`\n     .note = use `let _ = ...` to ignore the expression or result\n \n-lint_drop_copy = calls to `std::mem::drop` with a value that implements `Copy` does nothing\n+lint_dropping_copy_types = calls to `std::mem::drop` with a value that implements `Copy` does nothing\n     .label = argument has type `{$arg_ty}`\n     .note = use `let _ = ...` to ignore the expression or result\n \n-lint_forget_ref = calls to `std::mem::forget` with a reference instead of an owned value does nothing\n+lint_forgetting_references = calls to `std::mem::forget` with a reference instead of an owned value does nothing\n     .label = argument has type `{$arg_ty}`\n     .note = use `let _ = ...` to ignore the expression or result\n \n-lint_forget_copy = calls to `std::mem::forget` with a value that implements `Copy` does nothing\n+lint_forgetting_copy_types = calls to `std::mem::forget` with a value that implements `Copy` does nothing\n     .label = argument has type `{$arg_ty}`\n     .note = use `let _ = ...` to ignore the expression or result"}, {"sha": "ed2b384805e056a9a0d2c605e8a5af74972f86bc", "filename": "compiler/rustc_lint/src/drop_forget_useless.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fsrc%2Fdrop_forget_useless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fsrc%2Fdrop_forget_useless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fdrop_forget_useless.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -7,7 +7,7 @@ use crate::{\n };\n \n declare_lint! {\n-    /// The `drop_ref` lint checks for calls to `std::mem::drop` with a reference\n+    /// The `dropping_references` lint checks for calls to `std::mem::drop` with a reference\n     /// instead of an owned value.\n     ///\n     /// ### Example\n@@ -29,13 +29,13 @@ declare_lint! {\n     /// reference itself, which is a no-op. It will not call the `drop` method (from\n     /// the `Drop` trait implementation) on the underlying referenced value, which\n     /// is likely what was intended.\n-    pub DROP_REF,\n+    pub DROPPING_REFERENCES,\n     Warn,\n     \"calls to `std::mem::drop` with a reference instead of an owned value\"\n }\n \n declare_lint! {\n-    /// The `forget_ref` lint checks for calls to `std::mem::forget` with a reference\n+    /// The `forgetting_references` lint checks for calls to `std::mem::forget` with a reference\n     /// instead of an owned value.\n     ///\n     /// ### Example\n@@ -52,13 +52,13 @@ declare_lint! {\n     /// Calling `forget` on a reference will only forget the\n     /// reference itself, which is a no-op. It will not forget the underlying\n     /// referenced value, which is likely what was intended.\n-    pub FORGET_REF,\n+    pub FORGETTING_REFERENCES,\n     Warn,\n     \"calls to `std::mem::forget` with a reference instead of an owned value\"\n }\n \n declare_lint! {\n-    /// The `drop_copy` lint checks for calls to `std::mem::drop` with a value\n+    /// The `dropping_copy_types` lint checks for calls to `std::mem::drop` with a value\n     /// that derives the Copy trait.\n     ///\n     /// ### Example\n@@ -76,13 +76,13 @@ declare_lint! {\n     /// Calling `std::mem::drop` [does nothing for types that\n     /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n     /// value will be copied and moved into the function on invocation.\n-    pub DROP_COPY,\n+    pub DROPPING_COPY_TYPES,\n     Warn,\n     \"calls to `std::mem::drop` with a value that implements Copy\"\n }\n \n declare_lint! {\n-    /// The `forget_copy` lint checks for calls to `std::mem::forget` with a value\n+    /// The `forgetting_copy_types` lint checks for calls to `std::mem::forget` with a value\n     /// that derives the Copy trait.\n     ///\n     /// ### Example\n@@ -104,12 +104,12 @@ declare_lint! {\n     /// An alternative, but also valid, explanation is that Copy types do not\n     /// implement the Drop trait, which means they have no destructors. Without a\n     /// destructor, there is nothing for `std::mem::forget` to ignore.\n-    pub FORGET_COPY,\n+    pub FORGETTING_COPY_TYPES,\n     Warn,\n     \"calls to `std::mem::forget` with a value that implements Copy\"\n }\n \n-declare_lint_pass!(DropForgetUseless => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COPY]);\n+declare_lint_pass!(DropForgetUseless => [DROPPING_REFERENCES, FORGETTING_REFERENCES, DROPPING_COPY_TYPES, FORGETTING_COPY_TYPES]);\n \n impl<'tcx> LateLintPass<'tcx> for DropForgetUseless {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n@@ -123,16 +123,16 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetUseless {\n             let drop_is_single_call_in_arm = is_single_call_in_arm(cx, arg, expr);\n             match fn_name {\n                 sym::mem_drop if arg_ty.is_ref() && !drop_is_single_call_in_arm => {\n-                    cx.emit_spanned_lint(DROP_REF, expr.span, DropRefDiag { arg_ty, label: arg.span });\n+                    cx.emit_spanned_lint(DROPPING_REFERENCES, expr.span, DropRefDiag { arg_ty, label: arg.span });\n                 },\n                 sym::mem_forget if arg_ty.is_ref() => {\n-                    cx.emit_spanned_lint(FORGET_REF, expr.span, ForgetRefDiag { arg_ty, label: arg.span });\n+                    cx.emit_spanned_lint(FORGETTING_REFERENCES, expr.span, ForgetRefDiag { arg_ty, label: arg.span });\n                 },\n                 sym::mem_drop if is_copy && !drop_is_single_call_in_arm => {\n-                    cx.emit_spanned_lint(DROP_COPY, expr.span, DropCopyDiag { arg_ty, label: arg.span });\n+                    cx.emit_spanned_lint(DROPPING_COPY_TYPES, expr.span, DropCopyDiag { arg_ty, label: arg.span });\n                 }\n                 sym::mem_forget if is_copy => {\n-                    cx.emit_spanned_lint(FORGET_COPY, expr.span, ForgetCopyDiag { arg_ty, label: arg.span });\n+                    cx.emit_spanned_lint(FORGETTING_COPY_TYPES, expr.span, ForgetCopyDiag { arg_ty, label: arg.span });\n                 }\n                 _ => return,\n             };"}, {"sha": "de1c2be287576287cac7cc59358c40aded7d9851", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -662,9 +662,9 @@ pub struct ForLoopsOverFalliblesSuggestion<'a> {\n     pub end_span: Span,\n }\n \n-// drop_ref.rs\n+// drop_forget_useless.rs\n #[derive(LintDiagnostic)]\n-#[diag(lint_drop_ref)]\n+#[diag(lint_dropping_references)]\n #[note]\n pub struct DropRefDiag<'a> {\n     pub arg_ty: Ty<'a>,\n@@ -673,7 +673,7 @@ pub struct DropRefDiag<'a> {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(lint_drop_copy)]\n+#[diag(lint_dropping_copy_types)]\n #[note]\n pub struct DropCopyDiag<'a> {\n     pub arg_ty: Ty<'a>,\n@@ -682,7 +682,7 @@ pub struct DropCopyDiag<'a> {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(lint_forget_ref)]\n+#[diag(lint_forgetting_references)]\n #[note]\n pub struct ForgetRefDiag<'a> {\n     pub arg_ty: Ty<'a>,\n@@ -691,7 +691,7 @@ pub struct ForgetRefDiag<'a> {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(lint_forget_copy)]\n+#[diag(lint_forgetting_copy_types)]\n #[note]\n pub struct ForgetCopyDiag<'a> {\n     pub arg_ty: Ty<'a>,"}, {"sha": "0fe140e08d26ac945be5271370cbb45a27c4d6fa", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -103,8 +103,10 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             && let ty = cx.typeck_results().expr_ty(&await_expr)\n             && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: future_def_id, .. }) = ty.kind()\n             && cx.tcx.ty_is_opaque_future(ty)\n-            // FIXME: This also includes non-async fns that return `impl Future`.\n             && let async_fn_def_id = cx.tcx.parent(*future_def_id)\n+            && matches!(cx.tcx.def_kind(async_fn_def_id), DefKind::Fn | DefKind::AssocFn)\n+            // Check that this `impl Future` actually comes from an `async fn`\n+            && cx.tcx.asyncness(async_fn_def_id).is_async()\n             && check_must_use_def(\n                 cx,\n                 async_fn_def_id,"}, {"sha": "d0d41c614d6080436022f495ac298e9b6cc5c4c0", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -253,7 +253,7 @@ fn add_query_desc_cached_impl(\n         quote! {\n             #[allow(unused_variables, unused_braces, rustc::pass_by_value)]\n             #[inline]\n-            pub fn #name<'tcx>(#tcx: TyCtxt<'tcx>, #key: &crate::query::query_keys::#name<'tcx>) -> bool {\n+            pub fn #name<'tcx>(#tcx: TyCtxt<'tcx>, #key: &crate::query::queries::#name::Key<'tcx>) -> bool {\n                 #expr\n             }\n         }\n@@ -262,7 +262,7 @@ fn add_query_desc_cached_impl(\n             // we're taking `key` by reference, but some rustc types usually prefer being passed by value\n             #[allow(rustc::pass_by_value)]\n             #[inline]\n-            pub fn #name<'tcx>(_: TyCtxt<'tcx>, _: &crate::query::query_keys::#name<'tcx>) -> bool {\n+            pub fn #name<'tcx>(_: TyCtxt<'tcx>, _: &crate::query::queries::#name::Key<'tcx>) -> bool {\n                 false\n             }\n         }\n@@ -273,7 +273,7 @@ fn add_query_desc_cached_impl(\n \n     let desc = quote! {\n         #[allow(unused_variables)]\n-        pub fn #name<'tcx>(tcx: TyCtxt<'tcx>, key: crate::query::query_keys::#name<'tcx>) -> String {\n+        pub fn #name<'tcx>(tcx: TyCtxt<'tcx>, key: crate::query::queries::#name::Key<'tcx>) -> String {\n             let (#tcx, #key) = (tcx, key);\n             ::rustc_middle::ty::print::with_no_trimmed_paths!(\n                 format!(#desc)"}, {"sha": "98ea9dc750127a600d8b2ae4a27f92880491a3e4", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -943,7 +943,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                     lint::builtin::UNUSED_CRATE_DEPENDENCIES,\n                     span,\n                     ast::CRATE_NODE_ID,\n-                    &format!(\n+                    format!(\n                         \"external crate `{}` unused in `{}`: remove the dependency or add `use {} as _;`\",\n                         name,\n                         self.tcx.crate_name(LOCAL_CRATE),"}, {"sha": "6ec691f73b77d5e49fddeb21f85dfe1cec29d384", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -245,6 +245,7 @@ pub(crate) struct CrateLocator<'a> {\n     only_needs_metadata: bool,\n     sysroot: &'a Path,\n     metadata_loader: &'a dyn MetadataLoader,\n+    cfg_version: &'static str,\n \n     // Immutable per-search configuration.\n     crate_name: Symbol,\n@@ -322,6 +323,7 @@ impl<'a> CrateLocator<'a> {\n             only_needs_metadata,\n             sysroot: &sess.sysroot,\n             metadata_loader,\n+            cfg_version: sess.cfg_version,\n             crate_name,\n             exact_paths: if hash.is_none() {\n                 sess.opts\n@@ -654,7 +656,7 @@ impl<'a> CrateLocator<'a> {\n     }\n \n     fn crate_matches(&mut self, metadata: &MetadataBlob, libpath: &Path) -> Option<Svh> {\n-        let rustc_version = rustc_version();\n+        let rustc_version = rustc_version(self.cfg_version);\n         let found_version = metadata.get_rustc_version();\n         if found_version != rustc_version {\n             info!(\"Rejecting via version: expected {} got {}\", rustc_version, found_version);\n@@ -1096,7 +1098,7 @@ impl CrateError {\n                         crate_name,\n                         add_info,\n                         found_crates,\n-                        rustc_version: rustc_version(),\n+                        rustc_version: rustc_version(sess.cfg_version),\n                     });\n                 } else if !locator.crate_rejections.via_invalid.is_empty() {\n                     let mut crate_rejections = Vec::new();"}, {"sha": "834e2453ee0f176fe64e8bb2f1eb641ce95ed706", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -19,6 +19,7 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_index::{Idx, IndexVec};\n use rustc_middle::metadata::ModChild;\n+use rustc_middle::middle::debugger_visualizer::DebuggerVisualizerFile;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::ty::codec::TyDecoder;\n@@ -958,7 +959,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_debugger_visualizers(self) -> Vec<rustc_span::DebuggerVisualizerFile> {\n+    fn get_debugger_visualizers(self) -> Vec<DebuggerVisualizerFile> {\n         self.root.debugger_visualizers.decode(self).collect::<Vec<_>>()\n     }\n \n@@ -1251,14 +1252,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn is_foreign_item(self, id: DefIndex) -> bool {\n-        if let Some(parent) = self.def_key(id).parent {\n-            matches!(self.def_kind(parent), DefKind::ForeignMod)\n-        } else {\n-            false\n-        }\n-    }\n-\n     #[inline]\n     fn def_key(self, index: DefIndex) -> DefKey {\n         *self"}, {"sha": "364269095e01199832d94206bb3ebce128b16d6c", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -114,8 +114,8 @@ macro_rules! provide_one {\n     ($tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => $compute:block) => {\n         fn $name<'tcx>(\n             $tcx: TyCtxt<'tcx>,\n-            def_id_arg: rustc_middle::query::query_keys::$name<'tcx>,\n-        ) -> rustc_middle::query::query_provided::$name<'tcx> {\n+            def_id_arg: rustc_middle::query::queries::$name::Key<'tcx>,\n+        ) -> rustc_middle::query::queries::$name::ProvidedValue<'tcx> {\n             let _prof_timer =\n                 $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n \n@@ -280,7 +280,6 @@ provide! { tcx, def_id, other, cdata,\n     }\n     associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n-    is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     item_attrs => { tcx.arena.alloc_from_iter(cdata.get_item_attrs(def_id.index, tcx.sess)) }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n     is_ctfe_mir_available => { cdata.is_ctfe_mir_available(def_id.index) }"}, {"sha": "40723f4195988b9fbc03c1d71ce09517575f8d81", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -19,6 +19,7 @@ use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::hir::nested_filter;\n+use rustc_middle::middle::debugger_visualizer::DebuggerVisualizerFile;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo,\n@@ -36,9 +37,7 @@ use rustc_session::config::{CrateType, OptLevel};\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{\n-    self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n-};\n+use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -1855,7 +1854,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_debugger_visualizers(&mut self) -> LazyArray<DebuggerVisualizerFile> {\n         empty_proc_macro!(self);\n-        self.lazy_array(self.tcx.debugger_visualizers(LOCAL_CRATE).iter())\n+        self.lazy_array(\n+            self.tcx\n+                .debugger_visualizers(LOCAL_CRATE)\n+                .iter()\n+                // Erase the path since it may contain privacy sensitive data\n+                // that we don't want to end up in crate metadata.\n+                // The path is only needed for the local crate because of\n+                // `--emit dep-info`.\n+                .map(DebuggerVisualizerFile::path_erased),\n+        )\n     }\n \n     fn encode_crate_deps(&mut self) -> LazyArray<CrateDep> {\n@@ -2276,7 +2284,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n     };\n \n     // Encode the rustc version string in a predictable location.\n-    rustc_version().encode(&mut ecx);\n+    rustc_version(tcx.sess.cfg_version).encode(&mut ecx);\n \n     // Encode all the entries and extra information in the crate,\n     // culminating in the `CrateRoot` which points to all of it."}, {"sha": "97e67fcf8fdd0aa838a69a98a2ee101cd8ac668e", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -2,6 +2,7 @@ use crate::creader::CrateMetadataRef;\n use decoder::Metadata;\n use def_path_hash_map::DefPathHashMapRef;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::middle::debugger_visualizer::DebuggerVisualizerFile;\n use table::TableBuilder;\n \n use rustc_ast as ast;\n@@ -48,8 +49,8 @@ mod def_path_hash_map;\n mod encoder;\n mod table;\n \n-pub(crate) fn rustc_version() -> String {\n-    format!(\"rustc {}\", option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n+pub(crate) fn rustc_version(cfg_version: &'static str) -> String {\n+    format!(\"rustc {}\", cfg_version)\n }\n \n /// Metadata encoding version.\n@@ -245,7 +246,7 @@ pub(crate) struct CrateRoot {\n     proc_macro_data: Option<ProcMacroData>,\n \n     tables: LazyTables,\n-    debugger_visualizers: LazyArray<rustc_span::DebuggerVisualizerFile>,\n+    debugger_visualizers: LazyArray<DebuggerVisualizerFile>,\n \n     exported_symbols: LazyArray<(ExportedSymbol<'static>, SymbolExportInfo)>,\n "}, {"sha": "3b59df778dc98f1a6486fb4cef98ce8645406c0f", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,5 @@\n use crate::hir::{ModuleItems, Owner};\n+use crate::middle::debugger_visualizer::DebuggerVisualizerFile;\n use crate::query::LocalCrate;\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n@@ -1165,11 +1166,26 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, _: LocalCrate) -> Svh {\n \n     source_file_names.sort_unstable();\n \n+    // We have to take care of debugger visualizers explicitly. The HIR (and\n+    // thus `hir_body_hash`) contains the #[debugger_visualizer] attributes but\n+    // these attributes only store the file path to the visualizer file, not\n+    // their content. Yet that content is exported into crate metadata, so any\n+    // changes to it need to be reflected in the crate hash.\n+    let debugger_visualizers: Vec<_> = tcx\n+        .debugger_visualizers(LOCAL_CRATE)\n+        .iter()\n+        // We ignore the path to the visualizer file since it's not going to be\n+        // encoded in crate metadata and we already hash the full contents of\n+        // the file.\n+        .map(DebuggerVisualizerFile::path_erased)\n+        .collect();\n+\n     let crate_hash: Fingerprint = tcx.with_stable_hashing_context(|mut hcx| {\n         let mut stable_hasher = StableHasher::new();\n         hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n         upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n         source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n+        debugger_visualizers.hash_stable(&mut hcx, &mut stable_hasher);\n         if tcx.sess.opts.incremental_relative_spans() {\n             let definitions = tcx.definitions_untracked();\n             let mut owner_spans: Vec<_> = krate"}, {"sha": "ac0b2844177f373da1ff41ae35a2e3c05d373423", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -10,6 +10,7 @@ use crate::query::Providers;\n use crate::ty::{EarlyBinder, ImplSubject, TyCtxt};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{par_for_each_in, DynSend, DynSync};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::*;\n use rustc_query_system::ich::StableHashingContext;\n@@ -110,6 +111,12 @@ impl<'tcx> TyCtxt<'tcx> {\n             None => self.type_of(def_id).map_bound(ImplSubject::Inherent),\n         }\n     }\n+\n+    /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n+    pub fn is_foreign_item(self, def_id: impl Into<DefId>) -> bool {\n+        self.opt_parent(def_id.into())\n+            .map_or(false, |parent| matches!(self.def_kind(parent), DefKind::ForeignMod))\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "56171314944cc6ba243fc2798e3101947352c074", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -280,7 +280,7 @@ pub struct QueryResponse<'tcx, R> {\n     /// should get its hidden type inferred. So we bubble the opaque type\n     /// and the type it was compared against upwards and let the query caller\n     /// handle it.\n-    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n     pub value: R,\n }\n "}, {"sha": "a0497d805dad06c447e0996563dae0807f8b5780", "filename": "compiler/rustc_middle/src/middle/debugger_visualizer.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fdebugger_visualizer.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,38 @@\n+use rustc_data_structures::sync::Lrc;\n+use std::path::PathBuf;\n+\n+#[derive(HashStable)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, Encodable, Decodable)]\n+pub enum DebuggerVisualizerType {\n+    Natvis,\n+    GdbPrettyPrinter,\n+}\n+\n+/// A single debugger visualizer file.\n+#[derive(HashStable)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable)]\n+pub struct DebuggerVisualizerFile {\n+    /// The complete debugger visualizer source.\n+    pub src: Lrc<[u8]>,\n+    /// Indicates which visualizer type this targets.\n+    pub visualizer_type: DebuggerVisualizerType,\n+    /// The file path to the visualizer file. This is used for reporting\n+    /// visualizer files in dep-info. Before it is written to crate metadata,\n+    /// the path is erased to `None`, so as not to emit potentially privacy\n+    /// sensitive data.\n+    pub path: Option<PathBuf>,\n+}\n+\n+impl DebuggerVisualizerFile {\n+    pub fn new(src: Lrc<[u8]>, visualizer_type: DebuggerVisualizerType, path: PathBuf) -> Self {\n+        DebuggerVisualizerFile { src, visualizer_type, path: Some(path) }\n+    }\n+\n+    pub fn path_erased(&self) -> Self {\n+        DebuggerVisualizerFile {\n+            src: self.src.clone(),\n+            visualizer_type: self.visualizer_type,\n+            path: None,\n+        }\n+    }\n+}"}, {"sha": "85c5af9ca13cbf73b9888be6fd84904a6960a192", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,5 @@\n pub mod codegen_fn_attrs;\n+pub mod debugger_visualizer;\n pub mod dependency_format;\n pub mod exported_symbols;\n pub mod lang_items;"}, {"sha": "5c71910a955d86cd8e2921320bbd033891a064fc", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n pub trait MirPass<'tcx> {\n-    fn name(&self) -> &str {\n+    fn name(&self) -> &'static str {\n         let name = std::any::type_name::<Self>();\n         if let Some((_, tail)) = name.rsplit_once(':') { tail } else { name }\n     }"}, {"sha": "21faf1958e9113541ad956e6f43a78403c88f7bb", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -749,6 +749,29 @@ pub enum TerminatorKind<'tcx> {\n     },\n }\n \n+impl TerminatorKind<'_> {\n+    /// Returns a simple string representation of a `TerminatorKind` variant, independent of any\n+    /// values it might hold (e.g. `TerminatorKind::Call` always returns `\"Call\"`).\n+    pub const fn name(&self) -> &'static str {\n+        match self {\n+            TerminatorKind::Goto { .. } => \"Goto\",\n+            TerminatorKind::SwitchInt { .. } => \"SwitchInt\",\n+            TerminatorKind::Resume => \"Resume\",\n+            TerminatorKind::Terminate => \"Terminate\",\n+            TerminatorKind::Return => \"Return\",\n+            TerminatorKind::Unreachable => \"Unreachable\",\n+            TerminatorKind::Drop { .. } => \"Drop\",\n+            TerminatorKind::Call { .. } => \"Call\",\n+            TerminatorKind::Assert { .. } => \"Assert\",\n+            TerminatorKind::Yield { .. } => \"Yield\",\n+            TerminatorKind::GeneratorDrop => \"GeneratorDrop\",\n+            TerminatorKind::FalseEdge { .. } => \"FalseEdge\",\n+            TerminatorKind::FalseUnwind { .. } => \"FalseUnwind\",\n+            TerminatorKind::InlineAsm { .. } => \"InlineAsm\",\n+        }\n+    }\n+}\n+\n /// Action to be taken when a stack unwind happens.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n #[derive(TypeFoldable, TypeVisitable)]"}, {"sha": "fd02a16130fc55a05bd054855f9349eed8eaa3ad", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -28,7 +28,7 @@ pub fn erase<T: EraseType>(src: T) -> Erase<T> {\n     };\n \n     Erased::<<T as EraseType>::Result> {\n-        // SAFETY: Is it safe to transmute to MaybeUninit for types with the same sizes.\n+        // SAFETY: It is safe to transmute to MaybeUninit for types with the same sizes.\n         data: unsafe { transmute_copy(&src) },\n     }\n }"}, {"sha": "f5b42c804871761ca3ea7491a820d95684ba0d5b", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -12,6 +12,7 @@ use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintExpectation;\n use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use crate::middle::debugger_visualizer::DebuggerVisualizerFile;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::EffectiveVisibilities;\n@@ -726,12 +727,6 @@ rustc_queries! {\n         desc { |tcx| \"checking if item is promotable: `{}`\", tcx.def_path_str(key) }\n     }\n \n-    /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n-    query is_foreign_item(key: DefId) -> bool {\n-        desc { |tcx| \"checking if `{}` is a foreign item\", tcx.def_path_str(key) }\n-        separate_provide_extern\n-    }\n-\n     /// Returns `Some(generator_kind)` if the node pointed to by `def_id` is a generator.\n     query generator_kind(def_id: DefId) -> Option<hir::GeneratorKind> {\n         desc { |tcx| \"looking up generator kind of `{}`\", tcx.def_path_str(def_id) }\n@@ -1790,12 +1785,18 @@ rustc_queries! {\n         desc { \"looking at the source for a crate\" }\n         separate_provide_extern\n     }\n+\n     /// Returns the debugger visualizers defined for this crate.\n-    query debugger_visualizers(_: CrateNum) -> &'tcx Vec<rustc_span::DebuggerVisualizerFile> {\n+    /// NOTE: This query has to be marked `eval_always` because it reads data\n+    ///       directly from disk that is not tracked anywhere else. I.e. it\n+    ///       represents a genuine input to the query system.\n+    query debugger_visualizers(_: CrateNum) -> &'tcx Vec<DebuggerVisualizerFile> {\n         arena_cache\n         desc { \"looking up the debugger visualizers for this crate\" }\n         separate_provide_extern\n+        eval_always\n     }\n+\n     query postorder_cnums(_: ()) -> &'tcx [CrateNum] {\n         eval_always\n         desc { \"generating a postorder list of CrateNums\" }"}, {"sha": "97edfc2fca27da9007a2905f77b1b5495d661fd0", "filename": "compiler/rustc_middle/src/query/plumbing.rs", "status": "modified", "additions": 80, "deletions": 111, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fplumbing.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -32,20 +32,12 @@ impl QueryKeyStringCache {\n     }\n }\n \n-#[derive(Clone, Copy)]\n-pub struct QueryStruct<'tcx> {\n-    pub try_collect_active_jobs: fn(TyCtxt<'tcx>, &mut QueryMap<DepKind>) -> Option<()>,\n-    pub alloc_self_profile_query_strings: fn(TyCtxt<'tcx>, &mut QueryKeyStringCache),\n-    pub encode_query_results:\n-        Option<fn(TyCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n-}\n-\n pub struct DynamicQuery<'tcx, C: QueryCache> {\n     pub name: &'static str,\n     pub eval_always: bool,\n-    pub dep_kind: rustc_middle::dep_graph::DepKind,\n+    pub dep_kind: DepKind,\n     pub handle_cycle_error: HandleCycleError,\n-    pub query_state: FieldOffset<QueryStates<'tcx>, QueryState<C::Key, crate::dep_graph::DepKind>>,\n+    pub query_state: FieldOffset<QueryStates<'tcx>, QueryState<C::Key, DepKind>>,\n     pub query_cache: FieldOffset<QueryCaches<'tcx>, C>,\n     pub cache_on_disk: fn(tcx: TyCtxt<'tcx>, key: &C::Key) -> bool,\n     pub execute_query: fn(tcx: TyCtxt<'tcx>, k: C::Key) -> C::Value,\n@@ -60,16 +52,14 @@ pub struct DynamicQuery<'tcx, C: QueryCache> {\n     pub loadable_from_disk:\n         fn(tcx: TyCtxt<'tcx>, key: &C::Key, index: SerializedDepNodeIndex) -> bool,\n     pub hash_result: HashResult<C::Value>,\n-    pub value_from_cycle_error:\n-        fn(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<crate::dep_graph::DepKind>]) -> C::Value,\n+    pub value_from_cycle_error: fn(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> C::Value,\n     pub format_value: fn(&C::Value) -> String,\n }\n \n pub struct QuerySystemFns<'tcx> {\n     pub engine: QueryEngine,\n     pub local_providers: Providers,\n     pub extern_providers: ExternProviders,\n-    pub query_structs: Vec<QueryStruct<'tcx>>,\n     pub encode_query_results: fn(\n         tcx: TyCtxt<'tcx>,\n         encoder: &mut CacheEncoder<'_, 'tcx>,\n@@ -221,8 +211,8 @@ macro_rules! separate_provide_extern_decl {\n     ([(separate_provide_extern) $($rest:tt)*][$name:ident]) => {\n         for<'tcx> fn(\n             TyCtxt<'tcx>,\n-            query_keys::$name<'tcx>,\n-        ) -> query_provided::$name<'tcx>\n+            queries::$name::Key<'tcx>,\n+        ) -> queries::$name::ProvidedValue<'tcx>\n     };\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n         separate_provide_extern_decl!([$($modifiers)*][$($args)*])\n@@ -252,60 +242,37 @@ macro_rules! define_callbacks {\n      $($(#[$attr:meta])*\n         [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n \n-        // HACK(eddyb) this is like the `impl QueryConfig for queries::$name`\n-        // below, but using type aliases instead of associated types, to bypass\n-        // the limitations around normalizing under HRTB - for example, this:\n-        // `for<'tcx> fn(...) -> <queries::$name<'tcx> as QueryConfig<TyCtxt<'tcx>>>::Value`\n-        // doesn't currently normalize to `for<'tcx> fn(...) -> query_values::$name<'tcx>`.\n-        // This is primarily used by the `provide!` macro in `rustc_metadata`.\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_keys {\n-            use super::*;\n-\n-            $(pub type $name<'tcx> = $($K)*;)*\n-        }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_keys_local {\n-            use super::*;\n-\n-            $(pub type $name<'tcx> = local_key_if_separate_extern!([$($modifiers)*] $($K)*);)*\n-        }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_values {\n-            use super::*;\n-\n-            $(pub type $name<'tcx> = $V;)*\n-        }\n+        #[allow(unused_lifetimes)]\n+        pub mod queries {\n+            $(pub mod $name {\n+                use super::super::*;\n \n-        /// This module specifies the type returned from query providers and the type used for\n-        /// decoding. For regular queries this is the declared returned type `V`, but\n-        /// `arena_cache` will use `<V as Deref>::Target` instead.\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_provided {\n-            use super::*;\n+                pub type Key<'tcx> = $($K)*;\n+                pub type Value<'tcx> = $V;\n \n-            $(\n-                pub type $name<'tcx> = query_if_arena!([$($modifiers)*] (<$V as Deref>::Target) ($V));\n-            )*\n-        }\n+                pub type LocalKey<'tcx> = local_key_if_separate_extern!([$($modifiers)*] $($K)*);\n \n-        /// This module has a function per query which takes a `query_provided` value and coverts\n-        /// it to a regular `V` value by allocating it on an arena if the query has the\n-        /// `arena_cache` modifier. This will happen when computing the query using a provider or\n-        /// decoding a stored result.\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_provided_to_value {\n-            use super::*;\n+                /// This type alias specifies the type returned from query providers and the type\n+                /// used for decoding. For regular queries this is the declared returned type `V`,\n+                /// but `arena_cache` will use `<V as Deref>::Target` instead.\n+                pub type ProvidedValue<'tcx> = query_if_arena!(\n+                    [$($modifiers)*]\n+                    (<$V as Deref>::Target)\n+                    ($V)\n+                );\n \n-            $(\n+                /// This function takes `ProvidedValue` and coverts it to an erased `Value` by\n+                /// allocating it on an arena if the query has the `arena_cache` modifier. The\n+                /// value is then erased and returned. This will happen when computing the query\n+                /// using a provider or decoding a stored result.\n                 #[inline(always)]\n-                pub fn $name<'tcx>(\n+                pub fn provided_to_erased<'tcx>(\n                     _tcx: TyCtxt<'tcx>,\n-                    value: query_provided::$name<'tcx>,\n-                ) -> Erase<query_values::$name<'tcx>> {\n+                    value: ProvidedValue<'tcx>,\n+                ) -> Erase<Value<'tcx>> {\n                     erase(query_if_arena!([$($modifiers)*]\n                         {\n-                            if mem::needs_drop::<query_provided::$name<'tcx>>() {\n+                            if mem::needs_drop::<ProvidedValue<'tcx>>() {\n                                 &*_tcx.query_system.arenas.$name.alloc(value)\n                             } else {\n                                 &*_tcx.arena.dropless.alloc(value)\n@@ -314,47 +281,41 @@ macro_rules! define_callbacks {\n                         (value)\n                     ))\n                 }\n-            )*\n-        }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_storage {\n-            use super::*;\n \n-            $(\n-                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, Erase<$V>>>::Cache;\n-            )*\n+                pub type Storage<'tcx> = <\n+                    <$($K)* as keys::Key>::CacheSelector as CacheSelector<'tcx, Erase<$V>>\n+                >::Cache;\n+\n+                // Ensure that keys grow no larger than 64 bytes\n+                #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+                const _: () = {\n+                    if mem::size_of::<Key<'static>>() > 64 {\n+                        panic!(\"{}\", concat!(\n+                            \"the query `\",\n+                            stringify!($name),\n+                            \"` has a key type `\",\n+                            stringify!($($K)*),\n+                            \"` that is too large\"\n+                        ));\n+                    }\n+                };\n+\n+                // Ensure that values grow no larger than 64 bytes\n+                #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+                const _: () = {\n+                    if mem::size_of::<Value<'static>>() > 64 {\n+                        panic!(\"{}\", concat!(\n+                            \"the query `\",\n+                            stringify!($name),\n+                            \"` has a value type `\",\n+                            stringify!($V),\n+                            \"` that is too large\"\n+                        ));\n+                    }\n+                };\n+            })*\n         }\n \n-        $(\n-            // Ensure that keys grow no larger than 64 bytes\n-            #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-            const _: () = {\n-                if mem::size_of::<query_keys::$name<'static>>() > 64 {\n-                    panic!(\"{}\", concat!(\n-                        \"the query `\",\n-                        stringify!($name),\n-                        \"` has a key type `\",\n-                        stringify!($($K)*),\n-                        \"` that is too large\"\n-                    ));\n-                }\n-            };\n-\n-            // Ensure that values grow no larger than 64 bytes\n-            #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-            const _: () = {\n-                if mem::size_of::<query_values::$name<'static>>() > 64 {\n-                    panic!(\"{}\", concat!(\n-                        \"the query `\",\n-                        stringify!($name),\n-                        \"` has a value type `\",\n-                        stringify!($V),\n-                        \"` that is too large\"\n-                    ));\n-                }\n-            };\n-        )*\n-\n         pub struct QueryArenas<'tcx> {\n             $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]\n                 (WorkerLocal<TypedArena<<$V as Deref>::Target>>)\n@@ -375,7 +336,7 @@ macro_rules! define_callbacks {\n \n         #[derive(Default)]\n         pub struct QueryCaches<'tcx> {\n-            $($(#[$attr])* pub $name: query_storage::$name<'tcx>,)*\n+            $($(#[$attr])* pub $name: queries::$name::Storage<'tcx>,)*\n         }\n \n         impl<'tcx> TyCtxtEnsure<'tcx> {\n@@ -433,7 +394,7 @@ macro_rules! define_callbacks {\n \n         pub struct DynamicQueries<'tcx> {\n             $(\n-                pub $name: DynamicQuery<'tcx, query_storage::$name<'tcx>>,\n+                pub $name: DynamicQuery<'tcx, queries::$name::Storage<'tcx>>,\n             )*\n         }\n \n@@ -447,8 +408,8 @@ macro_rules! define_callbacks {\n         pub struct Providers {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n-                query_keys_local::$name<'tcx>,\n-            ) -> query_provided::$name<'tcx>,)*\n+                queries::$name::LocalKey<'tcx>,\n+            ) -> queries::$name::ProvidedValue<'tcx>,)*\n         }\n \n         pub struct ExternProviders {\n@@ -493,7 +454,7 @@ macro_rules! define_callbacks {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n                 Span,\n-                query_keys::$name<'tcx>,\n+                queries::$name::Key<'tcx>,\n                 QueryMode,\n             ) -> Option<Erase<$V>>,)*\n         }\n@@ -517,11 +478,11 @@ macro_rules! define_feedable {\n         $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n             $(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, value: query_provided::$name<'tcx>) {\n+            pub fn $name(self, value: queries::$name::ProvidedValue<'tcx>) {\n                 let key = self.key().into_query_param();\n \n                 let tcx = self.tcx;\n-                let erased = query_provided_to_value::$name(tcx, value);\n+                let erased = queries::$name::provided_to_erased(tcx, value);\n                 let value = restore::<$V>(erased);\n                 let cache = &tcx.query_system.caches.$name;\n \n@@ -533,12 +494,20 @@ macro_rules! define_feedable {\n                             let (value_hash, old_hash): (Fingerprint, Fingerprint) = tcx.with_stable_hashing_context(|mut hcx|\n                                 (hasher(&mut hcx, &value), hasher(&mut hcx, &old))\n                             );\n-                            assert_eq!(\n-                                old_hash, value_hash,\n-                                \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n-                                stringify!($name),\n-                            )\n+                            if old_hash != value_hash {\n+                                // We have an inconsistency. This can happen if one of the two\n+                                // results is tainted by errors. In this case, delay a bug to\n+                                // ensure compilation is doomed, and keep the `old` value.\n+                                tcx.sess.delay_span_bug(DUMMY_SP, format!(\n+                                    \"Trying to feed an already recorded value for query {} key={key:?}:\\n\\\n+                                    old value: {old:?}\\nnew value: {value:?}\",\n+                                    stringify!($name),\n+                                ));\n+                            }\n                         } else {\n+                            // The query is `no_hash`, so we have no way to perform a sanity check.\n+                            // If feeding the same value multiple times needs to be supported,\n+                            // the query should not be marked `no_hash`.\n                             bug!(\n                                 \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n                                 stringify!($name),"}, {"sha": "5b0b40cbfd9bc04e68116671dfc204030364b3f1", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -701,9 +701,9 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     }\n \n     pub fn borrow_nested_obligations(&self) -> &[N] {\n-        match &self {\n-            ImplSource::UserDefined(i) => &i.nested[..],\n-            ImplSource::Param(n, _) => &n,\n+        match self {\n+            ImplSource::UserDefined(i) => &i.nested,\n+            ImplSource::Param(n, _) => n,\n             ImplSource::Builtin(i) => &i.nested,\n             ImplSource::AutoImpl(d) => &d.nested,\n             ImplSource::Closure(c) => &c.nested,\n@@ -717,6 +717,23 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n         }\n     }\n \n+    pub fn borrow_nested_obligations_mut(&mut self) -> &mut [N] {\n+        match self {\n+            ImplSource::UserDefined(i) => &mut i.nested,\n+            ImplSource::Param(n, _) => n,\n+            ImplSource::Builtin(i) => &mut i.nested,\n+            ImplSource::AutoImpl(d) => &mut d.nested,\n+            ImplSource::Closure(c) => &mut c.nested,\n+            ImplSource::Generator(c) => &mut c.nested,\n+            ImplSource::Future(c) => &mut c.nested,\n+            ImplSource::Object(d) => &mut d.nested,\n+            ImplSource::FnPointer(d) => &mut d.nested,\n+            ImplSource::TraitAlias(d) => &mut d.nested,\n+            ImplSource::TraitUpcasting(d) => &mut d.nested,\n+            ImplSource::ConstDestruct(i) => &mut i.nested,\n+        }\n+    }\n+\n     pub fn map<M, F>(self, f: F) -> ImplSource<'tcx, M>\n     where\n         F: FnMut(N) -> M,"}, {"sha": "1511c906d1e86854e4bb8178731dbda5d6f4b202", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n pub struct ExternalConstraintsData<'tcx> {\n     // FIXME: implement this.\n     pub region_constraints: QueryRegionConstraints<'tcx>,\n-    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n }\n \n // FIXME: Having to clone `region_constraints` for folding feels bad and"}, {"sha": "7c5c030c2764e86409554fc0faf01cc5551b396c", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -111,12 +111,30 @@ impl Ord for AdtDefData {\n     }\n }\n \n-/// There should be only one AdtDef for each `did`, therefore\n-/// it is fine to implement `PartialEq` only based on `did`.\n impl PartialEq for AdtDefData {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.did == other.did\n+        // There should be only one `AdtDefData` for each `def_id`, therefore\n+        // it is fine to implement `PartialEq` only based on `def_id`.\n+        //\n+        // Below, we exhaustively destructure `self` and `other` so that if the\n+        // definition of `AdtDefData` changes, a compile-error will be produced,\n+        // reminding us to revisit this assumption.\n+\n+        let Self { did: self_def_id, variants: _, flags: _, repr: _ } = self;\n+        let Self { did: other_def_id, variants: _, flags: _, repr: _ } = other;\n+\n+        let res = self_def_id == other_def_id;\n+\n+        // Double check that implicit assumption detailed above.\n+        if cfg!(debug_assertions) && res {\n+            let deep = self.flags == other.flags\n+                && self.repr == other.repr\n+                && self.variants == other.variants;\n+            assert!(deep, \"AdtDefData for the same def-id has differing data\");\n+        }\n+\n+        res\n     }\n }\n "}, {"sha": "bbea3e1412b00aa04974ae0ebaf241d9acbbfb3d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -700,7 +700,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n     /// ensure it gets used.\n     #[track_caller]\n-    pub fn ty_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Ty<'tcx> {\n+    pub fn ty_error_with_message<S: Into<MultiSpan>>(\n+        self,\n+        span: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> Ty<'tcx> {\n         let reported = self.sess.delay_span_bug(span, msg);\n         self.mk_ty_from_kind(Error(reported))\n     }\n@@ -2433,7 +2437,7 @@ impl<'tcx> TyCtxtAt<'tcx> {\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n     /// ensure it gets used.\n     #[track_caller]\n-    pub fn ty_error_with_message(self, msg: &str) -> Ty<'tcx> {\n+    pub fn ty_error_with_message(self, msg: impl Into<DiagnosticMessage>) -> Ty<'tcx> {\n         self.tcx.ty_error_with_message(self.span, msg)\n     }\n }"}, {"sha": "b5a743cfe343ee30241c6bb4c8b10ba55853fc92", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -269,7 +269,7 @@ pub struct LayoutCx<'tcx, C> {\n impl<'tcx> LayoutCalculator for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     type TargetDataLayoutRef = &'tcx TargetDataLayout;\n \n-    fn delay_bug(&self, txt: &str) {\n+    fn delay_bug(&self, txt: String) {\n         self.tcx.sess.delay_span_bug(DUMMY_SP, txt);\n     }\n "}, {"sha": "ecb191676c2b0c110987b154e82c496fb2e4c96d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1882,7 +1882,20 @@ impl PartialEq for VariantDef {\n \n         let Self { def_id: lhs_def_id, ctor: _, name: _, discr: _, fields: _, flags: _ } = &self;\n         let Self { def_id: rhs_def_id, ctor: _, name: _, discr: _, fields: _, flags: _ } = other;\n-        lhs_def_id == rhs_def_id\n+\n+        let res = lhs_def_id == rhs_def_id;\n+\n+        // Double check that implicit assumption detailed above.\n+        if cfg!(debug_assertions) && res {\n+            let deep = self.ctor == other.ctor\n+                && self.name == other.name\n+                && self.discr == other.discr\n+                && self.fields == other.fields\n+                && self.flags == other.flags;\n+            assert!(deep, \"VariantDef for the same def-id has differing data\");\n+        }\n+\n+        res\n     }\n }\n \n@@ -1937,7 +1950,15 @@ impl PartialEq for FieldDef {\n \n         let Self { did: rhs_did, name: _, vis: _ } = other;\n \n-        lhs_did == rhs_did\n+        let res = lhs_did == rhs_did;\n+\n+        // Double check that implicit assumption detailed above.\n+        if cfg!(debug_assertions) && res {\n+            let deep = self.name == other.name && self.vis == other.vis;\n+            assert!(deep, \"FieldDef for the same def-id has differing data\");\n+        }\n+\n+        res\n     }\n }\n "}, {"sha": "a2e77d9cdfe38588b19c1a924ddc2488dc8d766e", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -56,6 +56,7 @@ trivially_parameterized_over_tcx! {\n     std::string::String,\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n+    crate::middle::debugger_visualizer::DebuggerVisualizerFile,\n     crate::middle::exported_symbols::SymbolExportInfo,\n     crate::middle::resolve_bound_vars::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n@@ -91,7 +92,6 @@ trivially_parameterized_over_tcx! {\n     rustc_session::cstore::ForeignModule,\n     rustc_session::cstore::LinkagePreference,\n     rustc_session::cstore::NativeLib,\n-    rustc_span::DebuggerVisualizerFile,\n     rustc_span::ExpnData,\n     rustc_span::ExpnHash,\n     rustc_span::ExpnId,"}, {"sha": "c385b00692ff4530fd5f71539234c5f02d5fa5b2", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -481,10 +481,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }))))\n             }\n \n-            ExprKind::OffsetOf { container, fields } => block.and(Rvalue::NullaryOp(\n-                NullOp::OffsetOf(fields),\n-                this.tcx.erase_regions(container),\n-            )),\n+            ExprKind::OffsetOf { container, fields } => {\n+                block.and(Rvalue::NullaryOp(NullOp::OffsetOf(fields), container))\n+            }\n \n             ExprKind::Literal { .. }\n             | ExprKind::NamedConst { .. }"}, {"sha": "b01b6fbf22259f7447a5038ba654885b589f3bf0", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -644,24 +644,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         };\n \n-        if let Some(destination) = destination {\n-            if let Some(value) = value {\n+        match (destination, value) {\n+            (Some(destination), Some(value)) => {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n                 unpack!(block = self.expr_into_dest(destination, block, value));\n                 self.block_context.pop();\n-            } else {\n+            }\n+            (Some(destination), None) => {\n                 self.cfg.push_assign_unit(block, source_info, destination, self.tcx)\n             }\n-        } else {\n-            assert!(value.is_none(), \"`return` and `break` should have a destination\");\n-            if self.tcx.sess.instrument_coverage() {\n+            (None, Some(_)) => {\n+                panic!(\"`return`, `become` and `break` with value and must have a destination\")\n+            }\n+            (None, None) if self.tcx.sess.instrument_coverage() => {\n                 // Unlike `break` and `return`, which push an `Assign` statement to MIR, from which\n                 // a Coverage code region can be generated, `continue` needs no `Assign`; but\n                 // without one, the `InstrumentCoverage` MIR pass cannot generate a code region for\n                 // `continue`. Coverage will be missing unless we add a dummy `Assign` to MIR.\n                 self.add_dummy_assignment(span, block, source_info);\n             }\n+            (None, None) => {}\n         }\n \n         let region_scope = self.scopes.breakable_scopes[break_index].region_scope;\n@@ -671,12 +674,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             self.scopes.breakable_scopes[break_index].continue_drops.as_mut().unwrap()\n         };\n-        let mut drop_idx = ROOT_NODE;\n-        for scope in &self.scopes.scopes[scope_index + 1..] {\n-            for drop in &scope.drops {\n-                drop_idx = drops.add_drop(*drop, drop_idx);\n-            }\n-        }\n+\n+        let drop_idx = self.scopes.scopes[scope_index + 1..]\n+            .iter()\n+            .flat_map(|scope| &scope.drops)\n+            .fold(ROOT_NODE, |drop_idx, &drop| drops.add_drop(drop, drop_idx));\n+\n         drops.add_entry(block, drop_idx);\n \n         // `build_drop_trees` doesn't have access to our source_info, so we"}, {"sha": "c8648224ac1e89c135b2777f23bbf46dc5d6825b", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -130,6 +130,7 @@ impl<'tcx> Cx<'tcx> {\n                 ExprKind::Pointer { cast: PointerCast::Unsize, source: self.thir.exprs.push(expr) }\n             }\n             Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: self.thir.exprs.push(expr) },\n+            Adjust::NeverToAny if adjustment.target.is_never() => return expr,\n             Adjust::NeverToAny => ExprKind::NeverToAny { source: self.thir.exprs.push(expr) },\n             Adjust::Deref(None) => {\n                 adjust_span(&mut expr);"}, {"sha": "35e4c24dc462b7caeb20fb5bcf694c679a39b84c", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -118,7 +118,7 @@ use rustc_middle::mir::spanview::{self, SpanViewable};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::coverage::*;\n-use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n+use rustc_middle::mir::{self, BasicBlock};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n \n@@ -796,36 +796,15 @@ fn bcb_to_string_sections<'tcx>(\n     }\n     let non_term_blocks = bcb_data.basic_blocks[0..len - 1]\n         .iter()\n-        .map(|&bb| format!(\"{:?}: {}\", bb, term_type(&mir_body[bb].terminator().kind)))\n+        .map(|&bb| format!(\"{:?}: {}\", bb, mir_body[bb].terminator().kind.name()))\n         .collect::<Vec<_>>();\n     if non_term_blocks.len() > 0 {\n         sections.push(non_term_blocks.join(\"\\n\"));\n     }\n     sections.push(format!(\n         \"{:?}: {}\",\n         bcb_data.basic_blocks.last().unwrap(),\n-        term_type(&bcb_data.terminator(mir_body).kind)\n+        bcb_data.terminator(mir_body).kind.name(),\n     ));\n     sections\n }\n-\n-/// Returns a simple string representation of a `TerminatorKind` variant, independent of any\n-/// values it might hold.\n-pub(super) fn term_type(kind: &TerminatorKind<'_>) -> &'static str {\n-    match kind {\n-        TerminatorKind::Goto { .. } => \"Goto\",\n-        TerminatorKind::SwitchInt { .. } => \"SwitchInt\",\n-        TerminatorKind::Resume => \"Resume\",\n-        TerminatorKind::Terminate => \"Terminate\",\n-        TerminatorKind::Return => \"Return\",\n-        TerminatorKind::Unreachable => \"Unreachable\",\n-        TerminatorKind::Drop { .. } => \"Drop\",\n-        TerminatorKind::Call { .. } => \"Call\",\n-        TerminatorKind::Assert { .. } => \"Assert\",\n-        TerminatorKind::Yield { .. } => \"Yield\",\n-        TerminatorKind::GeneratorDrop => \"GeneratorDrop\",\n-        TerminatorKind::FalseEdge { .. } => \"FalseEdge\",\n-        TerminatorKind::FalseUnwind { .. } => \"FalseUnwind\",\n-        TerminatorKind::InlineAsm { .. } => \"InlineAsm\",\n-    }\n-}"}, {"sha": "14937912cc599dc368933a256c41e8de6ad25f35", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,3 @@\n-use super::debug::term_type;\n use super::graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph, START_BCB};\n \n use itertools::Itertools;\n@@ -40,7 +39,7 @@ impl CoverageStatement {\n                     \"{}: @{}.{}: {:?}\",\n                     source_range_no_file(tcx, span),\n                     bb.index(),\n-                    term_type(&term.kind),\n+                    term.kind.name(),\n                     term.kind\n                 )\n             }"}, {"sha": "90b58933df7c0a3d1f8837756320498302c6cfbf", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -25,7 +25,6 @@\n //! to: `rustc_span::create_default_session_globals_then(|| { test_here(); })`.\n \n use super::counters;\n-use super::debug;\n use super::graph;\n use super::spans;\n \n@@ -188,12 +187,12 @@ fn debug_basic_blocks(mir_body: &Body<'_>) -> String {\n                     | TerminatorKind::Goto { target }\n                     | TerminatorKind::InlineAsm { destination: Some(target), .. }\n                     | TerminatorKind::Yield { resume: target, .. } => {\n-                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), target)\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, kind.name(), target)\n                     }\n                     TerminatorKind::SwitchInt { targets, .. } => {\n-                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), targets)\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, kind.name(), targets)\n                     }\n-                    _ => format!(\"{}{:?}:{}\", sp, bb, debug::term_type(kind)),\n+                    _ => format!(\"{}{:?}:{}\", sp, bb, kind.name()),\n                 }\n             })\n             .collect::<Vec<_>>()\n@@ -215,7 +214,7 @@ fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n                         \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n                         bb,\n                         bb,\n-                        debug::term_type(&data.terminator().kind),\n+                        data.terminator().kind.name(),\n                         mir_body\n                             .basic_blocks\n                             .successors(bb)\n@@ -244,7 +243,7 @@ fn print_coverage_graphviz(\n                         \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n                         bcb,\n                         bcb,\n-                        debug::term_type(&bcb_data.terminator(mir_body).kind),\n+                        bcb_data.terminator(mir_body).kind.name(),\n                         basic_coverage_blocks\n                             .successors(bcb)\n                             .map(|successor| { format!(\"    {:?} -> {:?};\", bcb, successor) })"}, {"sha": "746e3d9652db6042848a465aa7572f6d1030f378", "filename": "compiler/rustc_mir_transform/src/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -12,7 +12,7 @@ use rustc_session::config::OutputType;\n pub struct Marker(pub &'static str);\n \n impl<'tcx> MirPass<'tcx> for Marker {\n-    fn name(&self) -> &str {\n+    fn name(&self) -> &'static str {\n         self.0\n     }\n "}, {"sha": "6c2e22a70b94377c76be5119d636c4232f3f54b1", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -168,6 +168,18 @@ impl<'tcx> Inliner<'tcx> {\n     ) -> Result<std::ops::Range<BasicBlock>, &'static str> {\n         let callee_attrs = self.tcx.codegen_fn_attrs(callsite.callee.def_id());\n         self.check_codegen_attributes(callsite, callee_attrs)?;\n+\n+        let terminator = caller_body[callsite.block].terminator.as_ref().unwrap();\n+        let TerminatorKind::Call { args, destination, .. } = &terminator.kind else { bug!() };\n+        let destination_ty = destination.ty(&caller_body.local_decls, self.tcx).ty;\n+        for arg in args {\n+            if !arg.ty(&caller_body.local_decls, self.tcx).is_sized(self.tcx, self.param_env) {\n+                // We do not allow inlining functions with unsized params. Inlining these functions\n+                // could create unsized locals, which are unsound and being phased out.\n+                return Err(\"Call has unsized argument\");\n+            }\n+        }\n+\n         self.check_mir_is_available(caller_body, &callsite.callee)?;\n         let callee_body = try_instance_mir(self.tcx, callsite.callee.def)?;\n         self.check_mir_body(callsite, callee_body, callee_attrs)?;\n@@ -189,9 +201,6 @@ impl<'tcx> Inliner<'tcx> {\n         // Check call signature compatibility.\n         // Normally, this shouldn't be required, but trait normalization failure can create a\n         // validation ICE.\n-        let terminator = caller_body[callsite.block].terminator.as_ref().unwrap();\n-        let TerminatorKind::Call { args, destination, .. } = &terminator.kind else { bug!() };\n-        let destination_ty = destination.ty(&caller_body.local_decls, self.tcx).ty;\n         let output_type = callee_body.return_ty();\n         if !util::is_subtype(self.tcx, self.param_env, output_type, destination_ty) {\n             trace!(?output_type, ?destination_ty);"}, {"sha": "710eed3ed380850dba1f697d4da55b4b06cd6f81", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -6,7 +6,7 @@ use crate::{validate, MirPass};\n \n /// Just like `MirPass`, except it cannot mutate `Body`.\n pub trait MirLint<'tcx> {\n-    fn name(&self) -> &str {\n+    fn name(&self) -> &'static str {\n         let name = std::any::type_name::<Self>();\n         if let Some((_, tail)) = name.rsplit_once(':') { tail } else { name }\n     }\n@@ -26,7 +26,7 @@ impl<'tcx, T> MirPass<'tcx> for Lint<T>\n where\n     T: MirLint<'tcx>,\n {\n-    fn name(&self) -> &str {\n+    fn name(&self) -> &'static str {\n         self.0.name()\n     }\n \n@@ -49,7 +49,7 @@ impl<'tcx, T> MirPass<'tcx> for WithMinOptLevel<T>\n where\n     T: MirPass<'tcx>,\n {\n-    fn name(&self) -> &str {\n+    fn name(&self) -> &'static str {\n         self.1.name()\n     }\n \n@@ -121,7 +121,7 @@ fn run_passes_inner<'tcx>(\n                 validate_body(tcx, body, format!(\"before pass {}\", name));\n             }\n \n-            pass.run_pass(tcx, body);\n+            tcx.sess.time(name, || pass.run_pass(tcx, body));\n \n             if dump_enabled {\n                 dump_mir_for_pass(tcx, body, &name, true);"}, {"sha": "e59219321b7ffe69a9b4300ed583ff4239a3a31b", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -74,7 +74,7 @@ pub fn simplify_cfg<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn name(&self) -> &str {\n+    fn name(&self) -> &'static str {\n         &self.name()\n     }\n "}, {"sha": "eafe57a0c02077b5b202671d193bfd75f3eecd1c", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -250,13 +250,13 @@ where\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &initial_partitioning.codegen_units);\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n         partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n-        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n+        debug_dump(tcx, \"POST MERGING\", &initial_partitioning.codegen_units);\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n@@ -272,7 +272,7 @@ where\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n+    debug_dump(tcx, \"POST INLINING\", &post_inlining.codegen_units);\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n@@ -322,6 +322,8 @@ where\n \n     result.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n+    debug_dump(tcx, \"FINAL\", &result);\n+\n     result\n }\n \n@@ -346,33 +348,37 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn debug_dump<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, label: &str, cgus: I)\n-where\n-    I: Iterator<Item = &'a CodegenUnit<'tcx>>,\n-    'tcx: 'a,\n-{\n+fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n     let dump = move || {\n         use std::fmt::Write;\n \n+        let num_cgus = cgus.len();\n+        let max = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n+        let min = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n+        let ratio = max as f64 / min as f64;\n+\n         let s = &mut String::new();\n-        let _ = writeln!(s, \"{label}\");\n+        let _ = writeln!(\n+            s,\n+            \"{label} ({num_cgus} CodegenUnits, max={max}, min={min}, max/min={ratio:.1}):\"\n+        );\n         for cgu in cgus {\n             let _ =\n-                writeln!(s, \"CodegenUnit {} estimated size {} :\", cgu.name(), cgu.size_estimate());\n+                writeln!(s, \"CodegenUnit {} estimated size {}:\", cgu.name(), cgu.size_estimate());\n \n             for (mono_item, linkage) in cgu.items() {\n                 let symbol_name = mono_item.symbol_name(tcx).name;\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n \n-                let _ = writeln!(\n+                let _ = with_no_trimmed_paths!(writeln!(\n                     s,\n                     \" - {} [{:?}] [{}] estimated size {}\",\n                     mono_item,\n                     linkage,\n                     symbol_hash,\n                     mono_item.size_estimate(tcx)\n-                );\n+                ));\n             }\n \n             let _ = writeln!(s);"}, {"sha": "c6e6b46e4551cdf1e8759278bca543fcabfd2a4d", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -662,7 +662,7 @@ impl<'a> StringReader<'a> {\n                 &RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX,\n                 prefix_span,\n                 ast::CRATE_NODE_ID,\n-                &format!(\"prefix `{prefix}` is unknown\"),\n+                format!(\"prefix `{prefix}` is unknown\"),\n                 BuiltinLintDiagnostics::ReservedPrefix(prefix_span),\n             );\n         }"}, {"sha": "bcef0f7185fbf43b273dcc4486cbc661548bdf1a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -238,6 +238,7 @@ impl<'a> DerefMut for SnapshotParser<'a> {\n \n impl<'a> Parser<'a> {\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,"}, {"sha": "54f9fc5d2b99964efadacf27d90df7b1339ae6dc", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -40,7 +40,8 @@ impl<'a> Parser<'a> {\n \n     /// If `force_collect` is [`ForceCollect::Yes`], forces collection of tokens regardless of whether\n     /// or not we have attributes\n-    pub(crate) fn parse_stmt_without_recovery(\n+    // Public for `cfg_eval` macro expansion.\n+    pub fn parse_stmt_without_recovery(\n         &mut self,\n         capture_semi: bool,\n         force_collect: ForceCollect,"}, {"sha": "928fdce313d9187c3e14a60127e5aa56ca1361d0", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -186,7 +186,7 @@ fn emit_malformed_attribute(\n         suggestions.push(code);\n     }\n     if should_warn(name) {\n-        sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, span, ast::CRATE_NODE_ID, &msg);\n+        sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, span, ast::CRATE_NODE_ID, msg);\n     } else {\n         sess.span_diagnostic\n             .struct_span_err(span, error_msg)"}, {"sha": "41f92227e7c2d21172fe93c1d12298eec3ecced0", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 5, "deletions": 48, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -8,7 +8,6 @@ use crate::{errors, fluent_generated as fluent};\n use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, IntoDiagnosticArg, MultiSpan};\n-use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -1916,6 +1915,10 @@ impl CheckAttrVisitor<'_> {\n \n     /// Checks if the items on the `#[debugger_visualizer]` attribute are valid.\n     fn check_debugger_visualizer(&self, attr: &Attribute, target: Target) -> bool {\n+        // Here we only check that the #[debugger_visualizer] attribute is attached\n+        // to nothing other than a module. All other checks are done in the\n+        // `debugger_visualizer` query where they need to be done for decoding\n+        // anyway.\n         match target {\n             Target::Mod => {}\n             _ => {\n@@ -1924,53 +1927,7 @@ impl CheckAttrVisitor<'_> {\n             }\n         }\n \n-        let Some(hints) = attr.meta_item_list() else {\n-            self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n-            return false;\n-        };\n-\n-        let hint = match hints.len() {\n-            1 => &hints[0],\n-            _ => {\n-                self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n-                return false;\n-            }\n-        };\n-\n-        let Some(meta_item) = hint.meta_item() else {\n-            self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n-            return false;\n-        };\n-\n-        let visualizer_path = match (meta_item.name_or_empty(), meta_item.value_str()) {\n-            (sym::natvis_file, Some(value)) => value,\n-            (sym::gdb_script_file, Some(value)) => value,\n-            (_, _) => {\n-                self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: meta_item.span });\n-                return false;\n-            }\n-        };\n-\n-        let file =\n-            match resolve_path(&self.tcx.sess.parse_sess, visualizer_path.as_str(), attr.span) {\n-                Ok(file) => file,\n-                Err(mut err) => {\n-                    err.emit();\n-                    return false;\n-                }\n-            };\n-\n-        match std::fs::File::open(&file) {\n-            Ok(_) => true,\n-            Err(error) => {\n-                self.tcx.sess.emit_err(errors::DebugVisualizerUnreadable {\n-                    span: meta_item.span,\n-                    file: &file,\n-                    error,\n-                });\n-                false\n-            }\n-        }\n+        true\n     }\n \n     /// Outputs an error for `#[allow_internal_unstable]` which can only be applied to macros."}, {"sha": "3483f7da528badd675f7b6720f1bdb7f45bda2ee", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,60 +1,69 @@\n //! Detecting usage of the `#[debugger_visualizer]` attribute.\n \n-use hir::CRATE_HIR_ID;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_ast::Attribute;\n use rustc_data_structures::sync::Lrc;\n use rustc_expand::base::resolve_path;\n-use rustc_hir as hir;\n-use rustc_hir::HirId;\n-use rustc_middle::query::{LocalCrate, Providers};\n-use rustc_middle::ty::TyCtxt;\n-use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n+use rustc_middle::{\n+    middle::debugger_visualizer::{DebuggerVisualizerFile, DebuggerVisualizerType},\n+    query::{LocalCrate, Providers},\n+    ty::TyCtxt,\n+};\n+use rustc_session::Session;\n+use rustc_span::sym;\n \n-use crate::errors::DebugVisualizerUnreadable;\n+use crate::errors::{DebugVisualizerInvalid, DebugVisualizerUnreadable};\n \n-fn check_for_debugger_visualizer(\n-    tcx: TyCtxt<'_>,\n-    hir_id: HirId,\n-    debugger_visualizers: &mut FxHashSet<DebuggerVisualizerFile>,\n-) {\n-    let attrs = tcx.hir().attrs(hir_id);\n-    for attr in attrs {\n+impl DebuggerVisualizerCollector<'_> {\n+    fn check_for_debugger_visualizer(&mut self, attr: &Attribute) {\n         if attr.has_name(sym::debugger_visualizer) {\n-            let Some(list) = attr.meta_item_list() else {\n-                continue\n+            let Some(hints) = attr.meta_item_list() else {\n+                self.sess.emit_err(DebugVisualizerInvalid { span: attr.span });\n+                return;\n             };\n \n-            let meta_item = match list.len() {\n-                1 => match list[0].meta_item() {\n-                    Some(meta_item) => meta_item,\n-                    _ => continue,\n-                },\n-                _ => continue,\n+            let hint = if hints.len() == 1 {\n+                &hints[0]\n+            } else {\n+                self.sess.emit_err(DebugVisualizerInvalid { span: attr.span });\n+                return;\n             };\n \n-            let visualizer_type = match meta_item.name_or_empty() {\n-                sym::natvis_file => DebuggerVisualizerType::Natvis,\n-                sym::gdb_script_file => DebuggerVisualizerType::GdbPrettyPrinter,\n-                _ => continue,\n+            let Some(meta_item) = hint.meta_item() else {\n+                self.sess.emit_err(DebugVisualizerInvalid { span: attr.span });\n+                return;\n             };\n \n-            let file = match meta_item.value_str() {\n-                Some(value) => {\n-                    match resolve_path(&tcx.sess.parse_sess, value.as_str(), attr.span) {\n-                        Ok(file) => file,\n-                        _ => continue,\n+            let (visualizer_type, visualizer_path) =\n+                match (meta_item.name_or_empty(), meta_item.value_str()) {\n+                    (sym::natvis_file, Some(value)) => (DebuggerVisualizerType::Natvis, value),\n+                    (sym::gdb_script_file, Some(value)) => {\n+                        (DebuggerVisualizerType::GdbPrettyPrinter, value)\n                     }\n-                }\n-                None => continue,\n-            };\n+                    (_, _) => {\n+                        self.sess.emit_err(DebugVisualizerInvalid { span: meta_item.span });\n+                        return;\n+                    }\n+                };\n+\n+            let file =\n+                match resolve_path(&self.sess.parse_sess, visualizer_path.as_str(), attr.span) {\n+                    Ok(file) => file,\n+                    Err(mut err) => {\n+                        err.emit();\n+                        return;\n+                    }\n+                };\n \n             match std::fs::read(&file) {\n                 Ok(contents) => {\n-                    debugger_visualizers\n-                        .insert(DebuggerVisualizerFile::new(Lrc::from(contents), visualizer_type));\n+                    self.visualizers.push(DebuggerVisualizerFile::new(\n+                        Lrc::from(contents),\n+                        visualizer_type,\n+                        file,\n+                    ));\n                 }\n                 Err(error) => {\n-                    tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                    self.sess.emit_err(DebugVisualizerUnreadable {\n                         span: meta_item.span,\n                         file: &file,\n                         error,\n@@ -65,29 +74,30 @@ fn check_for_debugger_visualizer(\n     }\n }\n \n-/// Traverses and collects the debugger visualizers for a specific crate.\n-fn debugger_visualizers(tcx: TyCtxt<'_>, _: LocalCrate) -> Vec<DebuggerVisualizerFile> {\n-    // Initialize the collector.\n-    let mut debugger_visualizers = FxHashSet::default();\n+struct DebuggerVisualizerCollector<'a> {\n+    sess: &'a Session,\n+    visualizers: Vec<DebuggerVisualizerFile>,\n+}\n \n-    // Collect debugger visualizers in this crate.\n-    tcx.hir().for_each_module(|id| {\n-        check_for_debugger_visualizer(\n-            tcx,\n-            tcx.hir().local_def_id_to_hir_id(id),\n-            &mut debugger_visualizers,\n-        )\n-    });\n+impl<'ast> rustc_ast::visit::Visitor<'ast> for DebuggerVisualizerCollector<'_> {\n+    fn visit_attribute(&mut self, attr: &'ast Attribute) {\n+        self.check_for_debugger_visualizer(attr);\n+        rustc_ast::visit::walk_attribute(self, attr);\n+    }\n+}\n \n-    // Collect debugger visualizers on the crate attributes.\n-    check_for_debugger_visualizer(tcx, CRATE_HIR_ID, &mut debugger_visualizers);\n+/// Traverses and collects the debugger visualizers for a specific crate.\n+fn debugger_visualizers(tcx: TyCtxt<'_>, _: LocalCrate) -> Vec<DebuggerVisualizerFile> {\n+    let resolver_and_krate = tcx.resolver_for_lowering(()).borrow();\n+    let krate = &*resolver_and_krate.1;\n \n-    // Extract out the found debugger_visualizer items.\n-    let mut visualizers = debugger_visualizers.into_iter().collect::<Vec<_>>();\n+    let mut visitor = DebuggerVisualizerCollector { sess: tcx.sess, visualizers: Vec::new() };\n+    rustc_ast::visit::Visitor::visit_crate(&mut visitor, krate);\n \n-    // Sort the visualizers so we always get a deterministic query result.\n-    visualizers.sort();\n-    visualizers\n+    // We are collecting visualizers in AST-order, which is deterministic,\n+    // so we don't need to do any explicit sorting in order to get a\n+    // deterministic query result\n+    visitor.visualizers\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "4cf0f1305a70901b84c46241adfbc3bd5a6903e1", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -15,20 +15,21 @@\n #[macro_use]\n extern crate rustc_middle;\n \n-use crate::plumbing::{encode_all_query_results, try_mark_green};\n+use crate::plumbing::{__rust_begin_short_backtrace, encode_all_query_results, try_mark_green};\n use field_offset::offset_of;\n use rustc_data_structures::stable_hasher::HashStable;\n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepNodeIndex;\n use rustc_middle::dep_graph::{self, DepKind, DepKindStruct};\n use rustc_middle::query::erase::{erase, restore, Erase};\n-use rustc_middle::query::on_disk_cache::OnDiskCache;\n-use rustc_middle::query::plumbing::{DynamicQuery, QuerySystem, QuerySystemFns};\n+use rustc_middle::query::on_disk_cache::{CacheEncoder, EncodedDepNodeIndex, OnDiskCache};\n+use rustc_middle::query::plumbing::{\n+    DynamicQuery, QueryKeyStringCache, QuerySystem, QuerySystemFns,\n+};\n use rustc_middle::query::AsLocalKey;\n use rustc_middle::query::{\n-    query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n-    DynamicQueries, ExternProviders, Providers, QueryCaches, QueryEngine, QueryStates,\n+    queries, DynamicQueries, ExternProviders, Providers, QueryCaches, QueryEngine, QueryStates,\n };\n use rustc_middle::ty::TyCtxt;\n use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n@@ -216,7 +217,6 @@ pub fn query_system<'tcx>(\n             engine: engine(incremental),\n             local_providers,\n             extern_providers,\n-            query_structs: make_dep_kind_array!(query_structs).to_vec(),\n             encode_query_results: encode_all_query_results,\n             try_mark_green: try_mark_green,\n         },"}, {"sha": "244f0e84b43d94dc6866ccf5fcc411742cd44a82", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 187, "deletions": 177, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -81,8 +81,8 @@ impl QueryContext for QueryCtxt<'_> {\n     fn try_collect_active_jobs(self) -> Option<QueryMap<DepKind>> {\n         let mut jobs = QueryMap::default();\n \n-        for query in &self.query_system.fns.query_structs {\n-            (query.try_collect_active_jobs)(self.tcx, &mut jobs);\n+        for collect in super::TRY_COLLECT_ACTIVE_JOBS.iter() {\n+            collect(self.tcx, &mut jobs);\n         }\n \n         Some(jobs)\n@@ -183,10 +183,8 @@ pub(super) fn encode_all_query_results<'tcx>(\n     encoder: &mut CacheEncoder<'_, 'tcx>,\n     query_result_index: &mut EncodedDepNodeIndex,\n ) {\n-    for query in &tcx.query_system.fns.query_structs {\n-        if let Some(encode) = query.encode_query_results {\n-            encode(tcx, encoder, query_result_index);\n-        }\n+    for encode in super::ENCODE_QUERY_RESULTS.iter().copied().filter_map(|e| e) {\n+        encode(tcx, encoder, query_result_index);\n     }\n }\n \n@@ -476,6 +474,16 @@ where\n     }\n }\n \n+macro_rules! item_if_cached {\n+    ([] $tokens:tt) => {};\n+    ([(cache) $($rest:tt)*] { $($tokens:tt)* }) => {\n+        $($tokens)*\n+    };\n+    ([$other:tt $($modifiers:tt)*] $tokens:tt) => {\n+        item_if_cached! { [$($modifiers)*] $tokens }\n+    };\n+}\n+\n macro_rules! expand_if_cached {\n     ([], $tokens:expr) => {{\n         None\n@@ -488,167 +496,227 @@ macro_rules! expand_if_cached {\n     };\n }\n \n+/// Don't show the backtrace for query system by default\n+/// use `RUST_BACKTRACE=full` to show all the backtraces\n+#[inline(never)]\n+pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\n+where\n+    F: FnOnce() -> T,\n+{\n+    let result = f();\n+    std::hint::black_box(());\n+    result\n+}\n+\n // NOTE: `$V` isn't used here, but we still need to match on it so it can be passed to other macros\n // invoked by `rustc_query_append`.\n macro_rules! define_queries {\n     (\n      $($(#[$attr:meta])*\n         [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-        mod get_query_incr {\n-            use super::*;\n \n-            $(\n-                #[inline(always)]\n-                #[tracing::instrument(level = \"trace\", skip(tcx))]\n-                pub(super) fn $name<'tcx>(\n+        pub(crate) mod query_impl { $(pub mod $name {\n+            use super::super::*;\n+            use std::marker::PhantomData;\n+\n+            pub mod get_query_incr {\n+                use super::*;\n+\n+                // Adding `__rust_end_short_backtrace` marker to backtraces so that we emit the frames\n+                // when `RUST_BACKTRACE=1`, add a new mod with `$name` here is to allow duplicate naming\n+                #[inline(never)]\n+                pub fn __rust_end_short_backtrace<'tcx>(\n                     tcx: TyCtxt<'tcx>,\n                     span: Span,\n-                    key: query_keys::$name<'tcx>,\n+                    key: queries::$name::Key<'tcx>,\n                     mode: QueryMode,\n-                ) -> Option<Erase<query_values::$name<'tcx>>> {\n+                ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n                     get_query_incr(\n-                        queries::$name::config(tcx),\n+                        QueryType::config(tcx),\n                         QueryCtxt::new(tcx),\n                         span,\n                         key,\n                         mode\n                     )\n                 }\n-            )*\n-        }\n+            }\n \n-        mod get_query_non_incr {\n-            use super::*;\n+            pub mod get_query_non_incr {\n+                use super::*;\n \n-            $(\n-                #[inline(always)]\n-                #[tracing::instrument(level = \"trace\", skip(tcx))]\n-                pub(super) fn $name<'tcx>(\n+                #[inline(never)]\n+                pub fn __rust_end_short_backtrace<'tcx>(\n                     tcx: TyCtxt<'tcx>,\n                     span: Span,\n-                    key: query_keys::$name<'tcx>,\n+                    key: queries::$name::Key<'tcx>,\n                     __mode: QueryMode,\n-                ) -> Option<Erase<query_values::$name<'tcx>>> {\n+                ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n                     Some(get_query_non_incr(\n-                        queries::$name::config(tcx),\n+                        QueryType::config(tcx),\n                         QueryCtxt::new(tcx),\n                         span,\n                         key,\n                     ))\n                 }\n-            )*\n-        }\n+            }\n \n-        pub(crate) fn engine(incremental: bool) -> QueryEngine {\n-            if incremental {\n-                QueryEngine {\n-                    $($name: get_query_incr::$name,)*\n-                }\n-            } else {\n-                QueryEngine {\n-                    $($name: get_query_non_incr::$name,)*\n+            pub fn dynamic_query<'tcx>() -> DynamicQuery<'tcx, queries::$name::Storage<'tcx>> {\n+                DynamicQuery {\n+                    name: stringify!($name),\n+                    eval_always: is_eval_always!([$($modifiers)*]),\n+                    dep_kind: dep_graph::DepKind::$name,\n+                    handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n+                    query_state: offset_of!(QueryStates<'tcx> => $name),\n+                    query_cache: offset_of!(QueryCaches<'tcx> => $name),\n+                    cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n+                    execute_query: |tcx, key| erase(tcx.$name(key)),\n+                    compute: |tcx, key| {\n+                        __rust_begin_short_backtrace(||\n+                            queries::$name::provided_to_erased(\n+                                tcx,\n+                                call_provider!([$($modifiers)*][tcx, $name, key])\n+                            )\n+                        )\n+                    },\n+                    can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n+                    try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n+                        |tcx, key, prev_index, index| {\n+                            if ::rustc_middle::query::cached::$name(tcx, key) {\n+                                let value = $crate::plumbing::try_load_from_disk::<\n+                                    queries::$name::ProvidedValue<'tcx>\n+                                >(\n+                                    tcx,\n+                                    prev_index,\n+                                    index,\n+                                );\n+                                value.map(|value| queries::$name::provided_to_erased(tcx, value))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    } {\n+                        |_tcx, _key, _prev_index, _index| None\n+                    }),\n+                    value_from_cycle_error: |tcx, cycle| {\n+                        let result: queries::$name::Value<'tcx> = Value::from_cycle_error(tcx, cycle);\n+                        erase(result)\n+                    },\n+                    loadable_from_disk: |_tcx, _key, _index| {\n+                        should_ever_cache_on_disk!([$($modifiers)*] {\n+                            ::rustc_middle::query::cached::$name(_tcx, _key) &&\n+                                $crate::plumbing::loadable_from_disk(_tcx, _index)\n+                        } {\n+                            false\n+                        })\n+                    },\n+                    hash_result: hash_result!([$($modifiers)*][queries::$name::Value<'tcx>]),\n+                    format_value: |value| format!(\"{:?}\", restore::<queries::$name::Value<'tcx>>(*value)),\n                 }\n             }\n-        }\n-\n-        #[allow(nonstandard_style)]\n-        mod queries {\n-            use std::marker::PhantomData;\n \n-            $(\n-                #[derive(Copy, Clone, Default)]\n-                pub struct $name<'tcx> {\n-                    data: PhantomData<&'tcx ()>\n-                }\n-            )*\n-        }\n+            #[derive(Copy, Clone, Default)]\n+            pub struct QueryType<'tcx> {\n+                data: PhantomData<&'tcx ()>\n+            }\n \n-        #[allow(nonstandard_style)]\n-        mod dynamic_query {\n-            use super::*;\n+            impl<'tcx> QueryConfigRestored<'tcx> for QueryType<'tcx> {\n+                type RestoredValue = queries::$name::Value<'tcx>;\n+                type Config = DynamicConfig<\n+                    'tcx,\n+                    queries::$name::Storage<'tcx>,\n+                    { is_anon!([$($modifiers)*]) },\n+                    { depth_limit!([$($modifiers)*]) },\n+                    { feedable!([$($modifiers)*]) },\n+                >;\n \n-            $(\n-                pub(super) fn $name<'tcx>() -> DynamicQuery<'tcx, query_storage::$name<'tcx>> {\n-                    DynamicQuery {\n-                        name: stringify!($name),\n-                        eval_always: is_eval_always!([$($modifiers)*]),\n-                        dep_kind: dep_graph::DepKind::$name,\n-                        handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n-                        query_state: offset_of!(QueryStates<'tcx> => $name),\n-                        query_cache: offset_of!(QueryCaches<'tcx> => $name),\n-                        cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n-                        execute_query: |tcx, key| erase(tcx.$name(key)),\n-                        compute: |tcx, key| query_provided_to_value::$name(\n-                            tcx,\n-                            call_provider!([$($modifiers)*][tcx, $name, key])\n-                        ),\n-                        can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n-                        try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n-                            |tcx, key, prev_index, index| {\n-                                if ::rustc_middle::query::cached::$name(tcx, key) {\n-                                    let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n-                                        tcx,\n-                                        prev_index,\n-                                        index,\n-                                    );\n-                                    value.map(|value| query_provided_to_value::$name(tcx, value))\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                        } {\n-                            |_tcx, _key, _prev_index, _index| None\n-                        }),\n-                        value_from_cycle_error: |tcx, cycle| {\n-                            let result: query_values::$name<'tcx> = Value::from_cycle_error(tcx, cycle);\n-                            erase(result)\n-                        },\n-                        loadable_from_disk: |_tcx, _key, _index| {\n-                            should_ever_cache_on_disk!([$($modifiers)*] {\n-                                ::rustc_middle::query::cached::$name(_tcx, _key) &&\n-                                    $crate::plumbing::loadable_from_disk(_tcx, _index)\n-                            } {\n-                                false\n-                            })\n-                        },\n-                        hash_result: hash_result!([$($modifiers)*][query_values::$name<'tcx>]),\n-                        format_value: |value| format!(\"{:?}\", restore::<query_values::$name<'tcx>>(*value)),\n+                #[inline(always)]\n+                fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n+                    DynamicConfig {\n+                        dynamic: &tcx.query_system.dynamic_queries.$name,\n                     }\n                 }\n-            )*\n-        }\n \n-        $(impl<'tcx> QueryConfigRestored<'tcx> for queries::$name<'tcx> {\n-            type RestoredValue = query_values::$name<'tcx>;\n-            type Config = DynamicConfig<\n-                'tcx,\n-                query_storage::$name<'tcx>,\n-                { is_anon!([$($modifiers)*]) },\n-                { depth_limit!([$($modifiers)*]) },\n-                { feedable!([$($modifiers)*]) },\n-            >;\n-\n-            #[inline(always)]\n-            fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n-                DynamicConfig {\n-                    dynamic: &tcx.query_system.dynamic_queries.$name,\n+                #[inline(always)]\n+                fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n+                    restore::<queries::$name::Value<'tcx>>(value)\n                 }\n             }\n \n-            #[inline(always)]\n-            fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n-                restore::<query_values::$name<'tcx>>(value)\n+            pub fn try_collect_active_jobs<'tcx>(tcx: TyCtxt<'tcx>, qmap: &mut QueryMap<DepKind>) {\n+                let make_query = |tcx, key| {\n+                    let kind = rustc_middle::dep_graph::DepKind::$name;\n+                    let name = stringify!($name);\n+                    $crate::plumbing::create_query_frame(tcx, rustc_middle::query::descs::$name, key, kind, name)\n+                };\n+                tcx.query_system.states.$name.try_collect_active_jobs(\n+                    tcx,\n+                    make_query,\n+                    qmap,\n+                ).unwrap();\n+            }\n+\n+            pub fn alloc_self_profile_query_strings<'tcx>(tcx: TyCtxt<'tcx>, string_cache: &mut QueryKeyStringCache) {\n+                $crate::profiling_support::alloc_self_profile_query_strings_for_query_cache(\n+                    tcx,\n+                    stringify!($name),\n+                    &tcx.query_system.caches.$name,\n+                    string_cache,\n+                )\n+            }\n+\n+            item_if_cached! { [$($modifiers)*] {\n+                pub fn encode_query_results<'tcx>(\n+                    tcx: TyCtxt<'tcx>,\n+                    encoder: &mut CacheEncoder<'_, 'tcx>,\n+                    query_result_index: &mut EncodedDepNodeIndex\n+                ) {\n+                    $crate::plumbing::encode_query_results::<query_impl::$name::QueryType<'tcx>>(\n+                        query_impl::$name::QueryType::config(tcx),\n+                        QueryCtxt::new(tcx),\n+                        encoder,\n+                        query_result_index,\n+                    )\n+                }\n+            }}\n+        })*}\n+\n+        pub(crate) fn engine(incremental: bool) -> QueryEngine {\n+            if incremental {\n+                QueryEngine {\n+                    $($name: query_impl::$name::get_query_incr::__rust_end_short_backtrace,)*\n+                }\n+            } else {\n+                QueryEngine {\n+                    $($name: query_impl::$name::get_query_non_incr::__rust_end_short_backtrace,)*\n+                }\n             }\n-        })*\n+        }\n \n         pub fn dynamic_queries<'tcx>() -> DynamicQueries<'tcx> {\n             DynamicQueries {\n                 $(\n-                    $name: dynamic_query::$name(),\n+                    $name: query_impl::$name::dynamic_query(),\n                 )*\n             }\n         }\n \n+        // These arrays are used for iteration and can't be indexed by `DepKind`.\n+\n+        const TRY_COLLECT_ACTIVE_JOBS: &[for<'tcx> fn(TyCtxt<'tcx>, &mut QueryMap<DepKind>)] =\n+            &[$(query_impl::$name::try_collect_active_jobs),*];\n+\n+        const ALLOC_SELF_PROFILE_QUERY_STRINGS: &[\n+            for<'tcx> fn(TyCtxt<'tcx>, &mut QueryKeyStringCache)\n+        ] = &[$(query_impl::$name::alloc_self_profile_query_strings),*];\n+\n+        const ENCODE_QUERY_RESULTS: &[\n+            Option<for<'tcx> fn(\n+                TyCtxt<'tcx>,\n+                &mut CacheEncoder<'_, 'tcx>,\n+                &mut EncodedDepNodeIndex)\n+            >\n+        ] = &[$(expand_if_cached!([$($modifiers)*], query_impl::$name::encode_query_results)),*];\n+\n         #[allow(nonstandard_style)]\n         mod query_callbacks {\n             use super::*;\n@@ -707,71 +775,13 @@ macro_rules! define_queries {\n             }\n \n             $(pub(crate) fn $name<'tcx>()-> DepKindStruct<'tcx> {\n-                $crate::plumbing::query_callback::<queries::$name<'tcx>>(\n+                $crate::plumbing::query_callback::<query_impl::$name::QueryType<'tcx>>(\n                     is_anon!([$($modifiers)*]),\n                     is_eval_always!([$($modifiers)*]),\n                 )\n             })*\n         }\n \n-        mod query_structs {\n-            use super::*;\n-            use rustc_middle::query::plumbing::{QueryKeyStringCache, QueryStruct};\n-            use rustc_middle::dep_graph::DepKind;\n-            use crate::QueryConfigRestored;\n-\n-            pub(super) const fn dummy_query_struct<'tcx>() -> QueryStruct<'tcx> {\n-                fn noop_try_collect_active_jobs(_: TyCtxt<'_>, _: &mut QueryMap<DepKind>) -> Option<()> {\n-                    None\n-                }\n-                fn noop_alloc_self_profile_query_strings(_: TyCtxt<'_>, _: &mut QueryKeyStringCache) {}\n-\n-                QueryStruct {\n-                    try_collect_active_jobs: noop_try_collect_active_jobs,\n-                    alloc_self_profile_query_strings: noop_alloc_self_profile_query_strings,\n-                    encode_query_results: None,\n-                }\n-            }\n-\n-            pub(super) use dummy_query_struct as Null;\n-            pub(super) use dummy_query_struct as Red;\n-            pub(super) use dummy_query_struct as TraitSelect;\n-            pub(super) use dummy_query_struct as CompileCodegenUnit;\n-            pub(super) use dummy_query_struct as CompileMonoItem;\n-\n-            $(\n-            pub(super) const fn $name<'tcx>() -> QueryStruct<'tcx> { QueryStruct {\n-                try_collect_active_jobs: |tcx, qmap| {\n-                    let make_query = |tcx, key| {\n-                        let kind = rustc_middle::dep_graph::DepKind::$name;\n-                        let name = stringify!($name);\n-                        $crate::plumbing::create_query_frame(tcx, rustc_middle::query::descs::$name, key, kind, name)\n-                    };\n-                    tcx.query_system.states.$name.try_collect_active_jobs(\n-                        tcx,\n-                        make_query,\n-                        qmap,\n-                    )\n-                },\n-                alloc_self_profile_query_strings: |tcx, string_cache| {\n-                    $crate::profiling_support::alloc_self_profile_query_strings_for_query_cache(\n-                        tcx,\n-                        stringify!($name),\n-                        &tcx.query_system.caches.$name,\n-                        string_cache,\n-                    )\n-                },\n-                encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n-                    $crate::plumbing::encode_query_results::<super::queries::$name<'tcx>>(\n-                        super::queries::$name::config(tcx),\n-                        QueryCtxt::new(tcx),\n-                        encoder,\n-                        query_result_index,\n-                    )\n-                ),\n-            }})*\n-        }\n-\n         pub fn query_callbacks<'tcx>(arena: &'tcx Arena<'tcx>) -> &'tcx [DepKindStruct<'tcx>] {\n             arena.alloc_from_iter(make_dep_kind_array!(query_callbacks))\n         }"}, {"sha": "fbc6db93e01ad2e4c6dd3ea536fc82e6ba125303", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -243,7 +243,7 @@ pub fn alloc_self_profile_query_strings(tcx: TyCtxt<'_>) {\n \n     let mut string_cache = QueryKeyStringCache::new();\n \n-    for query in &tcx.query_system.fns.query_structs {\n-        (query.alloc_self_profile_query_strings)(tcx, &mut string_cache);\n+    for alloc in super::ALLOC_SELF_PROFILE_QUERY_STRINGS.iter() {\n+        alloc(tcx, &mut string_cache)\n     }\n }"}, {"sha": "730e4c8d30db35ec1d2d6182fdf27ae067c6c1e6", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -433,16 +433,22 @@ where\n                 (hasher(&mut hcx, &cached_result), hasher(&mut hcx, &result))\n             });\n             let formatter = query.format_value();\n-            debug_assert_eq!(\n-                old_hash,\n-                new_hash,\n-                \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\n\\\n-                computed={:#?}\\nfed={:#?}\",\n-                query.dep_kind(),\n-                key,\n-                formatter(&result),\n-                formatter(&cached_result),\n-            );\n+            if old_hash != new_hash {\n+                // We have an inconsistency. This can happen if one of the two\n+                // results is tainted by errors. In this case, delay a bug to\n+                // ensure compilation is doomed.\n+                qcx.dep_context().sess().delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\n+                        \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\n\\\n+                        computed={:#?}\\nfed={:#?}\",\n+                        query.dep_kind(),\n+                        key,\n+                        formatter(&result),\n+                        formatter(&cached_result),\n+                    ),\n+                );\n+            }\n         }\n     }\n     job_owner.complete(cache, result, dep_node_index);"}, {"sha": "08b73ebb69470e6535a2dcd7eeef5a8c6eeeec51", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -9,12 +9,9 @@ use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n use crate::macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n-use crate::{\n-    errors, Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot,\n-};\n-use crate::{\n-    MacroData, NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError,\n-};\n+use crate::{errors, BindingKey, MacroData};\n+use crate::{Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError};\n use crate::{Resolver, ResolverArenas, Segment, ToNameBinding, VisResolutionError};\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n@@ -72,7 +69,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n-        let key = self.new_key(ident, ns);\n+        let key = self.new_disambiguated_key(ident, ns);\n         if let Err(old_binding) = self.try_define(parent, key, binding) {\n             self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n@@ -379,7 +376,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             ImportKind::Single { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| {\n                     if !type_ns_only || ns == TypeNS {\n-                        let key = this.new_key(target, ns);\n+                        let key = BindingKey::new(target, ns);\n                         let mut resolution = this.resolution(current_module, key).borrow_mut();\n                         resolution.add_single_import(import);\n                     }"}, {"sha": "ed0a792d3876309be8a3fb7eb9756f99e7d46e26", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -28,10 +28,10 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};\n use thin_vec::ThinVec;\n \n-use crate::errors as errs;\n use crate::imports::{Import, ImportKind};\n use crate::late::{PatternSource, Rib};\n use crate::path_names_to_string;\n+use crate::{errors as errs, BindingKey};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n use crate::{HasGenericParams, MacroRulesScope, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{LexicalScopeBinding, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n@@ -1832,7 +1832,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             (msg, None)\n         } else if ident.name == kw::SelfUpper {\n-            (\"`Self` is only available in impls, traits, and type definitions\".to_string(), None)\n+            // As mentioned above, `opt_ns` being `None` indicates a module path in import.\n+            // We can use this to improve a confusing error for, e.g. `use Self::Variant` in an\n+            // impl\n+            if opt_ns.is_none() {\n+                (\"`Self` cannot be used in imports\".to_string(), None)\n+            } else {\n+                (\n+                    \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n+                    None,\n+                )\n+            }\n         } else if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n             // Check whether the name refers to an item in the value namespace.\n             let binding = if let Some(ribs) = ribs {\n@@ -2081,7 +2091,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let resolutions = self.resolutions(crate_module).borrow();\n-        let resolution = resolutions.get(&self.new_key(ident, MacroNS))?;\n+        let binding_key = BindingKey::new(ident, MacroNS);\n+        let resolution = resolutions.get(&binding_key)?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();"}, {"sha": "945c7ce3a9b3276e73888f2f694acbedb4c09c14", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -18,6 +18,7 @@ use crate::late::{\n     ConstantHasGenerics, HasGenericParams, NoConstantGenericsReason, PathSource, Rib, RibKind,\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n+use crate::BindingKey;\n use crate::{errors, AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n use crate::{Import, ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n@@ -865,7 +866,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         };\n \n-        let key = self.new_key(ident, ns);\n+        let key = BindingKey::new(ident, ns);\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n "}, {"sha": "7c4c05d4b9452617b0fd9030c739db872f8644e6", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -405,17 +405,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         t\n     }\n \n-    // Define a dummy resolution containing a `Res::Err` as a placeholder for a failed resolution,\n-    // also mark such failed imports as used to avoid duplicate diagnostics.\n-    fn import_dummy_binding(&mut self, import: &'a Import<'a>) {\n+    // Define a dummy resolution containing a `Res::Err` as a placeholder for a failed\n+    // or indeterminate resolution, also mark such failed imports as used to avoid duplicate diagnostics.\n+    fn import_dummy_binding(&mut self, import: &'a Import<'a>, is_indeterminate: bool) {\n         if let ImportKind::Single { target, ref target_bindings, .. } = import.kind {\n-            if target_bindings.iter().any(|binding| binding.get().is_some()) {\n+            if !(is_indeterminate || target_bindings.iter().all(|binding| binding.get().is_none()))\n+            {\n                 return; // Has resolution, do not create the dummy binding\n             }\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, import);\n             self.per_ns(|this, ns| {\n-                let key = this.new_key(target, ns);\n+                let key = BindingKey::new(target, ns);\n                 let _ = this.try_define(import.parent_scope.module, key, dummy_binding);\n             });\n             self.record_use(target, dummy_binding, false);\n@@ -474,7 +475,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             // If this import is unresolved then create a dummy import\n             // resolution for it so that later resolve stages won't complain.\n-            self.import_dummy_binding(import);\n+            self.import_dummy_binding(import, is_indeterminate);\n \n             if let Some(err) = unresolved_import_error {\n                 if let ImportKind::Single { source, ref source_bindings, .. } = import.kind {\n@@ -712,7 +713,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 .span_label(import.span, \"cannot be imported directly\")\n                                 .emit();\n                         }\n-                        let key = this.new_key(target, ns);\n+                        let key = BindingKey::new(target, ns);\n                         this.update_resolution(parent, key, |_, resolution| {\n                             resolution.single_imports.remove(&Interned::new_unchecked(import));\n                         });"}, {"sha": "a1077615d9593f8034e181cc3da30cd952e28289", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -6,6 +6,7 @@\n //! If you wonder why there's no `early.rs`, that's because it's split into three files -\n //! `build_reduced_graph.rs`, `macros.rs` and `imports.rs`.\n \n+use crate::BindingKey;\n use crate::{path_names_to_string, rustdoc, BindingError, Finalize, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n@@ -2967,7 +2968,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         let Some((module, _)) = &self.current_trait_ref else { return; };\n         ident.span.normalize_to_macros_2_0_and_adjust(module.expansion);\n-        let key = self.r.new_key(ident, ns);\n+        let key = BindingKey::new(ident, ns);\n         let mut binding = self.r.resolution(module, key).try_borrow().ok().and_then(|r| r.binding);\n         debug!(?binding);\n         if binding.is_none() {\n@@ -2978,7 +2979,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 TypeNS => ValueNS,\n                 _ => ns,\n             };\n-            let key = self.r.new_key(ident, ns);\n+            let key = BindingKey::new(ident, ns);\n             binding = self.r.resolution(module, key).try_borrow().ok().and_then(|r| r.binding);\n             debug!(?binding);\n         }"}, {"sha": "3cdc3f0ecf89273762cb4c9219d788713f9af597", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -85,6 +85,7 @@ pub mod rustdoc;\n \n fluent_messages! { \"../messages.ftl\" }\n \n+#[derive(Debug)]\n enum Weak {\n     Yes,\n     No,\n@@ -469,6 +470,13 @@ struct BindingKey {\n     disambiguator: u32,\n }\n \n+impl BindingKey {\n+    fn new(ident: Ident, ns: Namespace) -> Self {\n+        let ident = ident.normalize_to_macros_2_0();\n+        BindingKey { ident, ns, disambiguator: 0 }\n+    }\n+}\n+\n type Resolutions<'a> = RefCell<FxIndexMap<BindingKey, &'a RefCell<NameResolution<'a>>>>;\n \n /// One node in the tree of modules.\n@@ -943,6 +951,7 @@ pub struct Resolver<'a, 'tcx> {\n     empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n     binding_parent_modules: FxHashMap<Interned<'a, NameBinding<'a>>, Module<'a>>,\n+\n     underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n@@ -1595,7 +1604,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         import_ids\n     }\n \n-    fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n+    fn new_disambiguated_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n         let ident = ident.normalize_to_macros_2_0();\n         let disambiguator = if ident.name == kw::Underscore {\n             self.underscore_disambiguator += 1;"}, {"sha": "a328447aca9ded1921086eee981d4df0e7878689", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -421,7 +421,7 @@ pub enum TrimmedDefPaths {\n     GoodPath,\n }\n \n-#[derive(Clone, Hash)]\n+#[derive(Clone, Hash, Debug)]\n pub enum ResolveDocLinks {\n     /// Do not resolve doc links.\n     None,\n@@ -1319,23 +1319,22 @@ pub(super) fn build_target_config(\n     let (target, target_warnings) = target_result.unwrap_or_else(|e| {\n         early_error(\n             opts.error_format,\n-            &format!(\n+            format!(\n                 \"Error loading target specification: {}. \\\n                  Run `rustc --print target-list` for a list of built-in targets\",\n                 e\n             ),\n         )\n     });\n     for warning in target_warnings.warning_messages() {\n-        early_warn(opts.error_format, &warning)\n+        early_warn(opts.error_format, warning)\n     }\n \n     if !matches!(target.pointer_width, 16 | 32 | 64) {\n         early_error(\n             opts.error_format,\n-            &format!(\n-                \"target specification was invalid: \\\n-             unrecognized target-pointer-width {}\",\n+            format!(\n+                \"target specification was invalid: unrecognized target-pointer-width {}\",\n                 target.pointer_width\n             ),\n         )\n@@ -1599,7 +1598,7 @@ pub fn get_cmd_lint_options(\n \n     let lint_cap = matches.opt_str(\"cap-lints\").map(|cap| {\n         lint::Level::from_str(&cap)\n-            .unwrap_or_else(|| early_error(error_format, &format!(\"unknown lint level: `{cap}`\")))\n+            .unwrap_or_else(|| early_error(error_format, format!(\"unknown lint level: `{cap}`\")))\n     });\n \n     (lint_opts, describe_lints, lint_cap)\n@@ -1616,7 +1615,7 @@ pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n \n         Some(arg) => early_error(\n             ErrorOutputType::default(),\n-            &format!(\n+            format!(\n                 \"argument for `--color` must be auto, \\\n                  always or never (instead was `{arg}`)\"\n             ),\n@@ -1691,7 +1690,7 @@ pub fn parse_json(matches: &getopts::Matches) -> JsonConfig {\n                 \"future-incompat\" => json_future_incompat = true,\n                 s => early_error(\n                     ErrorOutputType::default(),\n-                    &format!(\"unknown `--json` option `{s}`\"),\n+                    format!(\"unknown `--json` option `{s}`\"),\n                 ),\n             }\n         }\n@@ -1729,7 +1728,7 @@ pub fn parse_error_format(\n \n             Some(arg) => early_error(\n                 ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n-                &format!(\n+                format!(\n                     \"argument for `--error-format` must be `human`, `json` or \\\n                      `short` (instead was `{arg}`)\"\n                 ),\n@@ -1763,7 +1762,7 @@ pub fn parse_crate_edition(matches: &getopts::Matches) -> Edition {\n         Some(arg) => Edition::from_str(&arg).unwrap_or_else(|_| {\n             early_error(\n                 ErrorOutputType::default(),\n-                &format!(\n+                format!(\n                     \"argument for `--edition` must be one of: \\\n                      {EDITION_NAME_LIST}. (instead was `{arg}`)\"\n                 ),\n@@ -1782,7 +1781,7 @@ pub fn parse_crate_edition(matches: &getopts::Matches) -> Edition {\n         } else {\n             format!(\"edition {edition} is unstable and only available with -Z unstable-options\")\n         };\n-        early_error(ErrorOutputType::default(), &msg)\n+        early_error(ErrorOutputType::default(), msg)\n     }\n \n     edition\n@@ -1827,7 +1826,7 @@ fn parse_output_types(\n                 let output_type = OutputType::from_shorthand(shorthand).unwrap_or_else(|| {\n                     early_error(\n                         error_format,\n-                        &format!(\n+                        format!(\n                             \"unknown emission type: `{shorthand}` - expected one of: {display}\",\n                             display = OutputType::shorthands_display(),\n                         ),\n@@ -1866,7 +1865,7 @@ fn should_override_cgus_and_disable_thinlto(\n                     for ot in &incompatible {\n                         early_warn(\n                             error_format,\n-                            &format!(\n+                            format!(\n                                 \"`--emit={ot}` with `-o` incompatible with \\\n                                  `-C codegen-units=N` for N > 1\",\n                             ),\n@@ -1970,7 +1969,7 @@ fn collect_print_requests(\n                 let prints = prints.join(\", \");\n                 early_error(\n                     error_format,\n-                    &format!(\"unknown print request `{req}`. Valid print requests are: {prints}\"),\n+                    format!(\"unknown print request `{req}`. Valid print requests are: {prints}\"),\n                 );\n             }\n         }\n@@ -1987,7 +1986,7 @@ pub fn parse_target_triple(\n         Some(target) if target.ends_with(\".json\") => {\n             let path = Path::new(&target);\n             TargetTriple::from_path(path).unwrap_or_else(|_| {\n-                early_error(error_format, &format!(\"target file {path:?} does not exist\"))\n+                early_error(error_format, format!(\"target file {path:?} does not exist\"))\n             })\n         }\n         Some(target) => TargetTriple::TargetTriple(target),\n@@ -2028,7 +2027,7 @@ fn parse_opt_level(\n             arg => {\n                 early_error(\n                     error_format,\n-                    &format!(\n+                    format!(\n                         \"optimization level needs to be \\\n                             between 0-3, s or z (instead was `{arg}`)\"\n                     ),\n@@ -2059,7 +2058,7 @@ pub(crate) fn parse_assert_incr_state(\n         Some(s) if s.as_str() == \"loaded\" => Some(IncrementalStateAssertion::Loaded),\n         Some(s) if s.as_str() == \"not-loaded\" => Some(IncrementalStateAssertion::NotLoaded),\n         Some(s) => {\n-            early_error(error_format, &format!(\"unexpected incremental state assertion value: {s}\"))\n+            early_error(error_format, format!(\"unexpected incremental state assertion value: {s}\"))\n         }\n         None => None,\n     }\n@@ -2086,13 +2085,13 @@ fn parse_native_lib_kind(\n                 } else {\n                     \", the `-Z unstable-options` flag must also be passed to use it\"\n                 };\n-                early_error(error_format, &format!(\"library kind `link-arg` is unstable{why}\"))\n+                early_error(error_format, format!(\"library kind `link-arg` is unstable{why}\"))\n             }\n             NativeLibKind::LinkArg\n         }\n         _ => early_error(\n             error_format,\n-            &format!(\n+            format!(\n                 \"unknown library kind `{kind}`, expected one of: static, dylib, framework, link-arg\"\n             ),\n         ),\n@@ -2127,16 +2126,13 @@ fn parse_native_lib_modifiers(\n                 } else {\n                     \", the `-Z unstable-options` flag must also be passed to use it\"\n                 };\n-                early_error(\n-                    error_format,\n-                    &format!(\"linking modifier `{modifier}` is unstable{why}\"),\n-                )\n+                early_error(error_format, format!(\"linking modifier `{modifier}` is unstable{why}\"))\n             }\n         };\n         let assign_modifier = |dst: &mut Option<bool>| {\n             if dst.is_some() {\n                 let msg = format!(\"multiple `{modifier}` modifiers in a single `-l` option\");\n-                early_error(error_format, &msg)\n+                early_error(error_format, msg)\n             } else {\n                 *dst = Some(value);\n             }\n@@ -2173,7 +2169,7 @@ fn parse_native_lib_modifiers(\n             // string, like `modifiers = \"\"`.\n             _ => early_error(\n                 error_format,\n-                &format!(\n+                format!(\n                     \"unknown linking modifier `{modifier}`, expected one \\\n                      of: bundle, verbatim, whole-archive, as-needed\"\n                 ),\n@@ -2303,7 +2299,7 @@ pub fn parse_externs(\n                     }\n                     \"nounused\" => nounused_dep = true,\n                     \"force\" => force = true,\n-                    _ => early_error(error_format, &format!(\"unknown --extern option `{opt}`\")),\n+                    _ => early_error(error_format, format!(\"unknown --extern option `{opt}`\")),\n                 }\n             }\n         }\n@@ -2369,7 +2365,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(error_format, &e));\n+        .unwrap_or_else(|e| early_error(error_format, e));\n \n     let mut unstable_opts = UnstableOptions::build(matches, error_format);\n     let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n@@ -2597,7 +2593,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let working_dir = std::env::current_dir().unwrap_or_else(|e| {\n-        early_error(error_format, &format!(\"Current directory is invalid: {e}\"));\n+        early_error(error_format, format!(\"Current directory is invalid: {e}\"));\n     });\n \n     let remap = FilePathMapping::new(remap_path_prefix.clone());\n@@ -2669,7 +2665,7 @@ fn parse_pretty(unstable_opts: &UnstableOptions, efmt: ErrorOutputType) -> Optio\n         \"mir-cfg\" => MirCFG,\n         name => early_error(\n             efmt,\n-            &format!(\n+            format!(\n                 \"argument to `unpretty` must be one of `normal`, `identified`, \\\n                             `expanded`, `expanded,identified`, `expanded,hygiene`, \\\n                             `ast-tree`, `ast-tree,expanded`, `hir`, `hir,identified`, \\\n@@ -2747,7 +2743,7 @@ pub mod nightly_options {\n             if opt.name != \"Z\" && !has_z_unstable_option {\n                 early_error(\n                     ErrorOutputType::default(),\n-                    &format!(\n+                    format!(\n                         \"the `-Z unstable-options` flag must also be passed to enable \\\n                          the flag `{}`\",\n                         opt.name\n@@ -2760,11 +2756,10 @@ pub mod nightly_options {\n             match opt.stability {\n                 OptionStability::Unstable => {\n                     let msg = format!(\n-                        \"the option `{}` is only accepted on the \\\n-                         nightly compiler\",\n+                        \"the option `{}` is only accepted on the nightly compiler\",\n                         opt.name\n                     );\n-                    early_error(ErrorOutputType::default(), &msg);\n+                    early_error(ErrorOutputType::default(), msg);\n                 }\n                 OptionStability::Stable => {}\n             }"}, {"sha": "2c4c4a7a6ce29fa8049bb41d260550c3ff3b1501", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -329,21 +329,21 @@ fn build_options<O: Default>(\n                     match value {\n                         None => early_error(\n                             error_format,\n-                            &format!(\n+                            format!(\n                                 \"{0} option `{1}` requires {2} ({3} {1}=<value>)\",\n                                 outputname, key, type_desc, prefix\n                             ),\n                         ),\n                         Some(value) => early_error(\n                             error_format,\n-                            &format!(\n+                            format!(\n                                 \"incorrect value `{value}` for {outputname} option `{key}` - {type_desc} was expected\"\n                             ),\n                         ),\n                     }\n                 }\n             }\n-            None => early_error(error_format, &format!(\"unknown {outputname} option: `{key}`\")),\n+            None => early_error(error_format, format!(\"unknown {outputname} option: `{key}`\")),\n         }\n     }\n     return op;"}, {"sha": "7b396dde91ba166a6614f29667b0d31cbc252938", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -289,7 +289,7 @@ impl ParseSess {\n         lint: &'static Lint,\n         span: impl Into<MultiSpan>,\n         node_id: NodeId,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) {\n         self.buffered_lints.with_lock(|buffered_lints| {\n             buffered_lints.push(BufferedEarlyLint {\n@@ -307,7 +307,7 @@ impl ParseSess {\n         lint: &'static Lint,\n         span: impl Into<MultiSpan>,\n         node_id: NodeId,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n         self.buffered_lints.with_lock(|buffered_lints| {"}, {"sha": "4f593083b6f3a754d656779c336e351ed283f32a", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -211,6 +211,9 @@ pub struct Session {\n \n     /// Set of enabled features for the current target, including unstable ones.\n     pub unstable_target_features: FxIndexSet<Symbol>,\n+\n+    /// The version of the rustc process, possibly including a commit hash and description.\n+    pub cfg_version: &'static str,\n }\n \n pub struct PerfStats {\n@@ -490,20 +493,6 @@ impl Session {\n     }\n     #[rustc_lint_diagnostics]\n     #[track_caller]\n-    pub fn span_err_or_warn<S: Into<MultiSpan>>(\n-        &self,\n-        is_warning: bool,\n-        sp: S,\n-        msg: impl Into<DiagnosticMessage>,\n-    ) {\n-        if is_warning {\n-            self.span_warn(sp, msg);\n-        } else {\n-            self.span_err(sp, msg);\n-        }\n-    }\n-    #[rustc_lint_diagnostics]\n-    #[track_caller]\n     pub fn span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -1380,6 +1369,7 @@ pub fn build_session(\n     driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n     file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n     target_override: Option<Target>,\n+    cfg_version: &'static str,\n ) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -1400,10 +1390,10 @@ pub fn build_session(\n     let target_cfg = config::build_target_config(&sopts, target_override, &sysroot);\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let (host, target_warnings) = Target::search(&host_triple, &sysroot).unwrap_or_else(|e| {\n-        early_error(sopts.error_format, &format!(\"Error loading host specification: {e}\"))\n+        early_error(sopts.error_format, format!(\"Error loading host specification: {e}\"))\n     });\n     for warning in target_warnings.warning_messages() {\n-        early_warn(sopts.error_format, &warning)\n+        early_warn(sopts.error_format, warning)\n     }\n \n     let loader = file_loader.unwrap_or_else(|| Box::new(RealFileLoader));\n@@ -1445,7 +1435,7 @@ pub fn build_session(\n         match profiler {\n             Ok(profiler) => Some(Arc::new(profiler)),\n             Err(e) => {\n-                early_warn(sopts.error_format, &format!(\"failed to create profiler: {e}\"));\n+                early_warn(sopts.error_format, format!(\"failed to create profiler: {e}\"));\n                 None\n             }\n         }\n@@ -1524,6 +1514,7 @@ pub fn build_session(\n         asm_arch,\n         target_features: Default::default(),\n         unstable_target_features: Default::default(),\n+        cfg_version,\n     };\n \n     validate_commandline_args_with_session_available(&sess);\n@@ -1741,18 +1732,22 @@ fn early_error_handler(output: config::ErrorOutputType) -> rustc_errors::Handler\n \n #[allow(rustc::untranslatable_diagnostic)]\n #[allow(rustc::diagnostic_outside_of_impl)]\n-pub fn early_error_no_abort(output: config::ErrorOutputType, msg: &str) -> ErrorGuaranteed {\n+#[must_use = \"ErrorGuaranteed must be returned from `run_compiler` in order to exit with a non-zero status code\"]\n+pub fn early_error_no_abort(\n+    output: config::ErrorOutputType,\n+    msg: impl Into<DiagnosticMessage>,\n+) -> ErrorGuaranteed {\n     early_error_handler(output).struct_err(msg).emit()\n }\n \n #[allow(rustc::untranslatable_diagnostic)]\n #[allow(rustc::diagnostic_outside_of_impl)]\n-pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n+pub fn early_error(output: config::ErrorOutputType, msg: impl Into<DiagnosticMessage>) -> ! {\n     early_error_handler(output).struct_fatal(msg).emit()\n }\n \n #[allow(rustc::untranslatable_diagnostic)]\n #[allow(rustc::diagnostic_outside_of_impl)]\n-pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n+pub fn early_warn(output: config::ErrorOutputType, msg: impl Into<DiagnosticMessage>) {\n     early_error_handler(output).struct_warn(msg).emit()\n }"}, {"sha": "f65a6aa4fb21a196a24cc0342cabfaff284321be", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -146,7 +146,12 @@ pub struct StableCrateId(pub(crate) Hash64);\n impl StableCrateId {\n     /// Computes the stable ID for a crate with the given name and\n     /// `-Cmetadata` arguments.\n-    pub fn new(crate_name: Symbol, is_exe: bool, mut metadata: Vec<String>) -> StableCrateId {\n+    pub fn new(\n+        crate_name: Symbol,\n+        is_exe: bool,\n+        mut metadata: Vec<String>,\n+        cfg_version: &'static str,\n+    ) -> StableCrateId {\n         let mut hasher = StableHasher::new();\n         // We must hash the string text of the crate name, not the id, as the id is not stable\n         // across builds.\n@@ -180,7 +185,7 @@ impl StableCrateId {\n         if let Some(val) = std::env::var_os(\"RUSTC_FORCE_RUSTC_VERSION\") {\n             hasher.write(val.to_string_lossy().into_owned().as_bytes())\n         } else {\n-            hasher.write(option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\").as_bytes());\n+            hasher.write(cfg_version.as_bytes())\n         }\n \n         StableCrateId(hasher.finish())"}, {"sha": "8d70aa47f781e61ba08f73b07a4c8b3209b09ff1", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1257,29 +1257,6 @@ impl SourceFileHash {\n     }\n }\n \n-#[derive(HashStable_Generic)]\n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, Encodable, Decodable)]\n-pub enum DebuggerVisualizerType {\n-    Natvis,\n-    GdbPrettyPrinter,\n-}\n-\n-/// A single debugger visualizer file.\n-#[derive(HashStable_Generic)]\n-#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable)]\n-pub struct DebuggerVisualizerFile {\n-    /// The complete debugger visualizer source.\n-    pub src: Lrc<[u8]>,\n-    /// Indicates which visualizer type this targets.\n-    pub visualizer_type: DebuggerVisualizerType,\n-}\n-\n-impl DebuggerVisualizerFile {\n-    pub fn new(src: Lrc<[u8]>, visualizer_type: DebuggerVisualizerType) -> Self {\n-        DebuggerVisualizerFile { src, visualizer_type }\n-    }\n-}\n-\n #[derive(Clone)]\n pub enum SourceFileLines {\n     /// The source file lines, in decoded (random-access) form."}, {"sha": "51d508a580b928d74328c679137f1fe91d929a21", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 52, "deletions": 16, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -673,14 +673,21 @@ fn encode_ty<'tcx>(\n             typeid.push_str(&s);\n         }\n \n+        // Type parameters\n+        ty::Param(..) => {\n+            // u5param as vendor extended type\n+            let mut s = String::from(\"u5param\");\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n         // Unexpected types\n         ty::Bound(..)\n         | ty::Error(..)\n         | ty::GeneratorWitness(..)\n         | ty::GeneratorWitnessMIR(..)\n         | ty::Infer(..)\n         | ty::Alias(..)\n-        | ty::Param(..)\n         | ty::Placeholder(..) => {\n             bug!(\"encode_ty: unexpected `{:?}`\", ty.kind());\n         }\n@@ -689,6 +696,41 @@ fn encode_ty<'tcx>(\n     typeid\n }\n \n+/// Transforms predicates for being encoded and used in the substitution dictionary.\n+fn transform_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicates: &List<ty::PolyExistentialPredicate<'tcx>>,\n+    _options: EncodeTyOptions,\n+) -> &'tcx List<ty::PolyExistentialPredicate<'tcx>> {\n+    let predicates: Vec<ty::PolyExistentialPredicate<'tcx>> = predicates\n+        .iter()\n+        .map(|predicate| match predicate.skip_binder() {\n+            ty::ExistentialPredicate::Trait(trait_ref) => {\n+                let trait_ref = ty::TraitRef::identity(tcx, trait_ref.def_id);\n+                ty::Binder::dummy(ty::ExistentialPredicate::Trait(\n+                    ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref),\n+                ))\n+            }\n+            _ => predicate,\n+        })\n+        .collect();\n+    tcx.mk_poly_existential_predicates(&predicates)\n+}\n+\n+/// Transforms substs for being encoded and used in the substitution dictionary.\n+fn transform_substs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+    options: TransformTyOptions,\n+) -> SubstsRef<'tcx> {\n+    let substs = substs.iter().map(|subst| match subst.unpack() {\n+        GenericArgKind::Type(ty) if ty.is_c_void(tcx) => tcx.mk_unit().into(),\n+        GenericArgKind::Type(ty) => transform_ty(tcx, ty, options).into(),\n+        _ => subst,\n+    });\n+    tcx.mk_substs_from_iter(substs)\n+}\n+\n // Transforms a ty:Ty for being encoded and used in the substitution dictionary. It transforms all\n // c_void types into unit types unconditionally, generalizes pointers if\n // TransformTyOptions::GENERALIZE_POINTERS option is set, and normalizes integers if\n@@ -697,7 +739,7 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n     let mut ty = ty;\n \n     match ty.kind() {\n-        ty::Float(..) | ty::Char | ty::Str | ty::Never | ty::Foreign(..) | ty::Dynamic(..) => {}\n+        ty::Float(..) | ty::Char | ty::Str | ty::Never | ty::Foreign(..) => {}\n \n         ty::Bool => {\n             if options.contains(EncodeTyOptions::NORMALIZE_INTEGERS) {\n@@ -870,6 +912,14 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n             }\n         }\n \n+        ty::Dynamic(predicates, _region, kind) => {\n+            ty = tcx.mk_dynamic(\n+                transform_predicates(tcx, predicates, options),\n+                tcx.lifetimes.re_erased,\n+                *kind,\n+            );\n+        }\n+\n         ty::Bound(..)\n         | ty::Error(..)\n         | ty::GeneratorWitness(..)\n@@ -885,20 +935,6 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n     ty\n }\n \n-/// Transforms substs for being encoded and used in the substitution dictionary.\n-fn transform_substs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    substs: SubstsRef<'tcx>,\n-    options: TransformTyOptions,\n-) -> SubstsRef<'tcx> {\n-    let substs = substs.iter().map(|subst| match subst.unpack() {\n-        GenericArgKind::Type(ty) if ty.is_c_void(tcx) => tcx.mk_unit().into(),\n-        GenericArgKind::Type(ty) => transform_ty(tcx, ty, options).into(),\n-        _ => subst,\n-    });\n-    tcx.mk_substs_from_iter(substs)\n-}\n-\n /// Returns a type metadata identifier for the specified FnAbi using the Itanium C++ ABI with vendor\n /// extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n #[instrument(level = \"trace\", skip(tcx))]"}, {"sha": "d14e6244f7d0774335a413ce5649fe9adc796811", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -506,10 +506,12 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | ty::Param(_)\n             | ty::Placeholder(..)\n             | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+            | ty::Alias(ty::Inherent, _)\n             | ty::Error(_) => return,\n             ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_))\n             | ty::Bound(..) => bug!(\"unexpected self type for `{goal:?}`\"),\n-            ty::Alias(_, alias_ty) => alias_ty,\n+            // Excluding IATs here as they don't have meaningful item bounds.\n+            ty::Alias(ty::Projection | ty::Opaque, alias_ty) => alias_ty,\n         };\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)"}, {"sha": "10bd027b6848a1600da45c9f404e9a98cd08f8ba", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -306,6 +306,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n                 }\n             }\n+\n+            // `&[{integral}]` - `FromIterator` needs that.\n+            if let ty::Ref(_, ref_ty, rustc_ast::Mutability::Not) = self_ty.kind()\n+                && let ty::Slice(sty) = ref_ty.kind()\n+                && sty.is_integral()\n+            {\n+                flags.push((sym::_Self, Some(\"&[{integral}]\".to_owned())));\n+            }\n         });\n \n         if let Ok(Some(command)) = OnUnimplementedDirective::of_item(self.tcx, def_id) {"}, {"sha": "28dad8592a8551067395fd7533a5297b9f839023", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -143,35 +143,36 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n fn pred_known_to_hold_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    pred: impl ToPredicate<'tcx> + TypeVisitable<TyCtxt<'tcx>>,\n+    pred: impl ToPredicate<'tcx>,\n ) -> bool {\n-    let has_non_region_infer = pred.has_non_region_infer();\n     let obligation = Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, pred);\n \n     let result = infcx.evaluate_obligation_no_overflow(&obligation);\n     debug!(?result);\n \n-    if result.must_apply_modulo_regions() && !has_non_region_infer {\n+    if result.must_apply_modulo_regions() {\n         true\n     } else if result.may_apply() {\n-        // Because of inference \"guessing\", selection can sometimes claim\n-        // to succeed while the success requires a guess. To ensure\n-        // this function's result remains infallible, we must confirm\n-        // that guess. While imperfect, I believe this is sound.\n-\n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let ocx = ObligationCtxt::new(infcx);\n-        ocx.register_obligation(obligation);\n-        let errors = ocx.select_all_or_error();\n-        match errors.as_slice() {\n-            [] => true,\n-            errors => {\n-                debug!(?errors);\n-                false\n+        // Sometimes obligations are ambiguous because the recursive evaluator\n+        // is not smart enough, so we fall back to fulfillment when we're not certain\n+        // that an obligation holds or not. Even still, we must make sure that\n+        // the we do no inference in the process of checking this obligation.\n+        let goal = infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));\n+        infcx.probe(|_| {\n+            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+            ocx.register_obligation(obligation);\n+\n+            let errors = ocx.select_all_or_error();\n+            match errors.as_slice() {\n+                // Only known to hold if we did no inference.\n+                [] => infcx.shallow_resolve(goal) == goal,\n+\n+                errors => {\n+                    debug!(?errors);\n+                    false\n+                }\n             }\n-        }\n+        })\n     } else {\n         false\n     }"}, {"sha": "51069897120af6bb779a0ea5898454ade6316d32", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1543,7 +1543,10 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let bounds = match *obligation.predicate.self_ty().kind() {\n-        ty::Alias(_, ref data) => tcx.item_bounds(data.def_id).subst(tcx, data.substs),\n+        // Excluding IATs here as they don't have meaningful item bounds.\n+        ty::Alias(ty::Projection | ty::Opaque, ref data) => {\n+            tcx.item_bounds(data.def_id).subst(tcx, data.substs)\n+        }\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -2260,7 +2263,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n                 obligation, poly_cache_entry, e,\n             );\n             debug!(\"confirm_param_env_candidate: {}\", msg);\n-            let err = infcx.tcx.ty_error_with_message(obligation.cause.span, &msg);\n+            let err = infcx.tcx.ty_error_with_message(obligation.cause.span, msg);\n             Progress { term: err.into(), obligations: vec![] }\n         }\n     }"}, {"sha": "aa230936903f1ce75a1473539d07594ec77c078c", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -143,7 +143,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().kind() {\n-            ty::Alias(..) => {}\n+            // Excluding IATs here as they don't have meaningful item bounds.\n+            ty::Alias(ty::Projection | ty::Opaque, _) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(\n                     obligation.cause.span,"}, {"sha": "0d9f55d4c2edff766c9467fce640e90d63045557", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -132,6 +132,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n+        // The obligations returned by confirmation are recursively evaluated\n+        // so we need to make sure they have the correct depth.\n+        for subobligation in impl_src.borrow_nested_obligations_mut() {\n+            subobligation.set_depth_from_parent(obligation.recursion_depth);\n+        }\n+\n         if !obligation.predicate.is_const_if_const() {\n             // normalize nested predicates according to parent predicate's constness.\n             impl_src = impl_src.map(|mut o| {\n@@ -156,7 +162,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n-            ty::Alias(_, ty::AliasTy { def_id, substs, .. }) => (def_id, substs),\n+            // Excluding IATs here as they don't have meaningful item bounds.\n+            ty::Alias(ty::Projection | ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                (def_id, substs)\n+            }\n             _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n         };\n "}, {"sha": "b366bbd531bc132f2eac193aad01edc8132c71d9", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -537,14 +537,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            if this.tcx().trait_solver_next() {\n-                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])\n+            let goal =\n+                this.infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));\n+            let mut result = if this.tcx().trait_solver_next() {\n+                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])?\n             } else {\n                 this.evaluate_predicate_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n                     obligation.clone(),\n-                )\n+                )?\n+            };\n+            // If the predicate has done any inference, then downgrade the\n+            // result to ambiguous.\n+            if this.infcx.shallow_resolve(goal) != goal {\n+                result = result.max(EvaluatedToAmbig);\n             }\n+            Ok(result)\n         })\n     }\n \n@@ -1645,7 +1653,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n-            ty::Alias(_, ty::AliasTy { def_id, substs, .. }) => (def_id, substs),\n+            ty::Alias(ty::Projection | ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                (def_id, substs)\n+            }\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,"}, {"sha": "498fbd93288c8bf0765e2a3c7f45a6d1a542f223", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -2623,6 +2623,15 @@ impl ToString for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n+#[stable(feature = \"fmt_arguments_to_string_specialization\", since = \"CURRENT_RUSTC_VERSION\")]\n+impl ToString for fmt::Arguments<'_> {\n+    #[inline]\n+    fn to_string(&self) -> String {\n+        crate::fmt::format(*self)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<str> for String {\n     #[inline]"}, {"sha": "bfdb7a92beff68015ee090e3eb7056ef283994b7", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -502,6 +502,7 @@ impl<T> Arc<T> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[inline]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n     pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n@@ -535,6 +536,7 @@ impl<T> Arc<T> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[cfg(not(no_global_oom_handling))]\n+    #[inline]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n     pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n@@ -844,6 +846,7 @@ impl<T> Arc<[T]> {\n     /// assert_eq!(*values, [1, 2, 3])\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[inline]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n     pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n@@ -871,6 +874,7 @@ impl<T> Arc<[T]> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[cfg(not(no_global_oom_handling))]\n+    #[inline]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n     pub fn new_zeroed_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n@@ -1300,10 +1304,10 @@ impl<T: ?Sized> Arc<T> {\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n         let layout = arcinner_layout_for_value_layout(value_layout);\n-        unsafe {\n-            Arc::try_allocate_for_layout(value_layout, allocate, mem_to_arcinner)\n-                .unwrap_or_else(|_| handle_alloc_error(layout))\n-        }\n+\n+        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+\n+        unsafe { Self::initialize_arcinner(ptr, layout, mem_to_arcinner) }\n     }\n \n     /// Allocates an `ArcInner<T>` with sufficient space for\n@@ -1321,7 +1325,16 @@ impl<T: ?Sized> Arc<T> {\n \n         let ptr = allocate(layout)?;\n \n-        // Initialize the ArcInner\n+        let inner = unsafe { Self::initialize_arcinner(ptr, layout, mem_to_arcinner) };\n+\n+        Ok(inner)\n+    }\n+\n+    unsafe fn initialize_arcinner(\n+        ptr: NonNull<[u8]>,\n+        layout: Layout,\n+        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n+    ) -> *mut ArcInner<T> {\n         let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n         debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);\n \n@@ -1330,7 +1343,7 @@ impl<T: ?Sized> Arc<T> {\n             ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n         }\n \n-        Ok(inner)\n+        inner\n     }\n \n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value."}, {"sha": "5ecd0479971ea804b345f8a9585a35d5de974b73", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -178,7 +178,8 @@ where\n             )\n         };\n \n-        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n+        // SAFETY: `dst_buf` and `dst_end` are the start and end of the buffer.\n+        let len = unsafe { SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end) };\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };\n         // check if SourceIter contract was upheld\n@@ -239,15 +240,15 @@ trait SpecInPlaceCollect<T, I>: Iterator<Item = T> {\n     /// `Iterator::__iterator_get_unchecked` calls with a `TrustedRandomAccessNoCoerce` bound\n     /// on `I` which means the caller of this method must take the safety conditions\n     /// of that trait into consideration.\n-    fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n+    unsafe fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n }\n \n impl<T, I> SpecInPlaceCollect<T, I> for I\n where\n     I: Iterator<Item = T>,\n {\n     #[inline]\n-    default fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+    default unsafe fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n         // use try-fold since\n         // - it vectorizes better for some iterator adapters\n         // - unlike most internal iteration methods, it only takes a &mut self\n@@ -265,7 +266,7 @@ where\n     I: Iterator<Item = T> + TrustedRandomAccessNoCoerce,\n {\n     #[inline]\n-    fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+    unsafe fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n         let len = self.size();\n         let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n         for i in 0..len {"}, {"sha": "60ef83223d104c296740418463011e29845b92e0", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -404,7 +404,7 @@ fn bench_trusted_random_access_adapters(b: &mut Bencher) {\n \n /// Exercises the iter::Copied specialization for slice::Iter\n #[bench]\n-fn bench_copied_chunks(b: &mut Bencher) {\n+fn bench_next_chunk_copied(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n@@ -421,7 +421,7 @@ fn bench_copied_chunks(b: &mut Bencher) {\n \n /// Exercises the TrustedRandomAccess specialization in ArrayChunks\n #[bench]\n-fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n+fn bench_next_chunk_trusted_random_access(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n@@ -437,3 +437,45 @@ fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n             .sum::<Wrapping<u64>>()\n     })\n }\n+\n+#[bench]\n+fn bench_next_chunk_filter_even(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter(|&&i| i % 2 == 0).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_predictably_true(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter(|&&i| i < 100).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_mostly_false(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter(|&&i| i > 900).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_map_even(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter_map(|&i| (i % 2 == 0).then(|| i)).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_map_predictably_true(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter_map(|&i| (i < 100).then(|| i)).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_map_mostly_false(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter_map(|&i| (i > 900).then(|| i)).next_chunk::<32>())\n+}"}, {"sha": "ef8e4d098ed9562acc9f162c0999b34ee418f70d", "filename": "library/core/src/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fascii.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -91,7 +91,7 @@ pub struct EscapeDefault(escape::EscapeIterInner<4>);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn escape_default(c: u8) -> EscapeDefault {\n-    let mut data = [0; 4];\n+    let mut data = [Char::Null; 4];\n     let range = escape::escape_ascii_into(&mut data, c);\n     EscapeDefault(escape::EscapeIterInner::new(data, range))\n }"}, {"sha": "515b8d20ead86f92c4771b6a4dc7b92335d7bf1e", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -392,13 +392,13 @@ impl char {\n     #[inline]\n     pub(crate) fn escape_debug_ext(self, args: EscapeDebugExtArgs) -> EscapeDebug {\n         match self {\n-            '\\0' => EscapeDebug::backslash(b'0'),\n-            '\\t' => EscapeDebug::backslash(b't'),\n-            '\\r' => EscapeDebug::backslash(b'r'),\n-            '\\n' => EscapeDebug::backslash(b'n'),\n-            '\\\\' => EscapeDebug::backslash(b'\\\\'),\n-            '\"' if args.escape_double_quote => EscapeDebug::backslash(b'\"'),\n-            '\\'' if args.escape_single_quote => EscapeDebug::backslash(b'\\''),\n+            '\\0' => EscapeDebug::backslash(ascii::Char::Digit0),\n+            '\\t' => EscapeDebug::backslash(ascii::Char::SmallT),\n+            '\\r' => EscapeDebug::backslash(ascii::Char::SmallR),\n+            '\\n' => EscapeDebug::backslash(ascii::Char::SmallN),\n+            '\\\\' => EscapeDebug::backslash(ascii::Char::ReverseSolidus),\n+            '\\\"' if args.escape_double_quote => EscapeDebug::backslash(ascii::Char::QuotationMark),\n+            '\\'' if args.escape_single_quote => EscapeDebug::backslash(ascii::Char::Apostrophe),\n             _ if args.escape_grapheme_extended && self.is_grapheme_extended() => {\n                 EscapeDebug::from_unicode(self.escape_unicode())\n             }\n@@ -503,11 +503,11 @@ impl char {\n     #[inline]\n     pub fn escape_default(self) -> EscapeDefault {\n         match self {\n-            '\\t' => EscapeDefault::backslash(b't'),\n-            '\\r' => EscapeDefault::backslash(b'r'),\n-            '\\n' => EscapeDefault::backslash(b'n'),\n-            '\\\\' | '\\'' | '\"' => EscapeDefault::backslash(self as u8),\n-            '\\x20'..='\\x7e' => EscapeDefault::printable(self as u8),\n+            '\\t' => EscapeDefault::backslash(ascii::Char::SmallT),\n+            '\\r' => EscapeDefault::backslash(ascii::Char::SmallR),\n+            '\\n' => EscapeDefault::backslash(ascii::Char::SmallN),\n+            '\\\\' | '\\'' | '\"' => EscapeDefault::backslash(self.as_ascii().unwrap()),\n+            '\\x20'..='\\x7e' => EscapeDefault::printable(self.as_ascii().unwrap()),\n             _ => EscapeDefault::from_unicode(self.escape_unicode()),\n         }\n     }"}, {"sha": "5c42912874c66ec008ac41dedb713448b22432c5", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -38,6 +38,7 @@ pub use self::methods::encode_utf16_raw;\n #[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n pub use self::methods::encode_utf8_raw;\n \n+use crate::ascii;\n use crate::error::Error;\n use crate::escape;\n use crate::fmt::{self, Write};\n@@ -152,7 +153,7 @@ pub struct EscapeUnicode(escape::EscapeIterInner<10>);\n \n impl EscapeUnicode {\n     fn new(chr: char) -> Self {\n-        let mut data = [0; 10];\n+        let mut data = [ascii::Char::Null; 10];\n         let range = escape::escape_unicode_into(&mut data, chr);\n         Self(escape::EscapeIterInner::new(data, range))\n     }\n@@ -218,14 +219,14 @@ impl fmt::Display for EscapeUnicode {\n pub struct EscapeDefault(escape::EscapeIterInner<10>);\n \n impl EscapeDefault {\n-    fn printable(chr: u8) -> Self {\n-        let data = [chr, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n-        Self(escape::EscapeIterInner::new(data, 0..1))\n+    fn printable(chr: ascii::Char) -> Self {\n+        let data = [chr];\n+        Self(escape::EscapeIterInner::from_array(data))\n     }\n \n-    fn backslash(chr: u8) -> Self {\n-        let data = [b'\\\\', chr, 0, 0, 0, 0, 0, 0, 0, 0];\n-        Self(escape::EscapeIterInner::new(data, 0..2))\n+    fn backslash(chr: ascii::Char) -> Self {\n+        let data = [ascii::Char::ReverseSolidus, chr];\n+        Self(escape::EscapeIterInner::from_array(data))\n     }\n \n     fn from_unicode(esc: EscapeUnicode) -> Self {\n@@ -307,9 +308,9 @@ impl EscapeDebug {\n         Self(EscapeDebugInner::Char(chr))\n     }\n \n-    fn backslash(chr: u8) -> Self {\n-        let data = [b'\\\\', chr, 0, 0, 0, 0, 0, 0, 0, 0];\n-        let iter = escape::EscapeIterInner::new(data, 0..2);\n+    fn backslash(chr: ascii::Char) -> Self {\n+        let data = [ascii::Char::ReverseSolidus, chr];\n+        let iter = escape::EscapeIterInner::from_array(data);\n         Self(EscapeDebugInner::Bytes(iter))\n     }\n \n@@ -318,7 +319,7 @@ impl EscapeDebug {\n     }\n \n     fn clear(&mut self) {\n-        let bytes = escape::EscapeIterInner::new([0; 10], 0..0);\n+        let bytes = escape::EscapeIterInner::from_array([]);\n         self.0 = EscapeDebugInner::Bytes(bytes);\n     }\n }"}, {"sha": "3d471419bb8f112ba103a4c96d80752edfd594bf", "filename": "library/core/src/escape.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fescape.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,34 +1,41 @@\n //! Helper code for character escaping.\n \n+use crate::ascii;\n use crate::num::NonZeroUsize;\n use crate::ops::Range;\n \n-const HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n+const HEX_DIGITS: [ascii::Char; 16] = *b\"0123456789abcdef\".as_ascii().unwrap();\n \n /// Escapes a byte into provided buffer; returns length of escaped\n /// representation.\n-pub(crate) fn escape_ascii_into(output: &mut [u8; 4], byte: u8) -> Range<u8> {\n+pub(crate) fn escape_ascii_into(output: &mut [ascii::Char; 4], byte: u8) -> Range<u8> {\n+    #[inline]\n+    fn backslash(a: ascii::Char) -> ([ascii::Char; 4], u8) {\n+        ([ascii::Char::ReverseSolidus, a, ascii::Char::Null, ascii::Char::Null], 2)\n+    }\n+\n     let (data, len) = match byte {\n-        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n-        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n-        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n-        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n-        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n-        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20'..=b'\\x7e' => ([byte, 0, 0, 0], 1),\n-        _ => {\n+        b'\\t' => backslash(ascii::Char::SmallT),\n+        b'\\r' => backslash(ascii::Char::SmallR),\n+        b'\\n' => backslash(ascii::Char::SmallN),\n+        b'\\\\' => backslash(ascii::Char::ReverseSolidus),\n+        b'\\'' => backslash(ascii::Char::Apostrophe),\n+        b'\\\"' => backslash(ascii::Char::QuotationMark),\n+        _ => if let Some(a) = byte.as_ascii() && !byte.is_ascii_control() {\n+            ([a, ascii::Char::Null, ascii::Char::Null, ascii::Char::Null], 1)\n+        } else {\n             let hi = HEX_DIGITS[usize::from(byte >> 4)];\n             let lo = HEX_DIGITS[usize::from(byte & 0xf)];\n-            ([b'\\\\', b'x', hi, lo], 4)\n+            ([ascii::Char::ReverseSolidus, ascii::Char::SmallX, hi, lo], 4)\n         }\n     };\n     *output = data;\n-    0..(len as u8)\n+    0..len\n }\n \n /// Escapes a character into provided buffer using `\\u{NNNN}` representation.\n-pub(crate) fn escape_unicode_into(output: &mut [u8; 10], ch: char) -> Range<u8> {\n-    output[9] = b'}';\n+pub(crate) fn escape_unicode_into(output: &mut [ascii::Char; 10], ch: char) -> Range<u8> {\n+    output[9] = ascii::Char::RightCurlyBracket;\n \n     let ch = ch as u32;\n     output[3] = HEX_DIGITS[((ch >> 20) & 15) as usize];\n@@ -41,7 +48,8 @@ pub(crate) fn escape_unicode_into(output: &mut [u8; 10], ch: char) -> Range<u8>\n     // or-ing 1 ensures that for ch==0 the code computes that one digit should\n     // be printed.\n     let start = (ch | 1).leading_zeros() as usize / 4 - 2;\n-    output[start..start + 3].copy_from_slice(b\"\\\\u{\");\n+    const UNICODE_ESCAPE_PREFIX: &[ascii::Char; 3] = b\"\\\\u{\".as_ascii().unwrap();\n+    output[start..][..3].copy_from_slice(UNICODE_ESCAPE_PREFIX);\n \n     (start as u8)..10\n }\n@@ -52,41 +60,46 @@ pub(crate) fn escape_unicode_into(output: &mut [u8; 10], ch: char) -> Range<u8>\n /// limited to u8 to reduce size of the structure.\n #[derive(Clone, Debug)]\n pub(crate) struct EscapeIterInner<const N: usize> {\n-    // Invariant: data[alive] is all ASCII.\n-    pub(crate) data: [u8; N],\n+    // The element type ensures this is always ASCII, and thus also valid UTF-8.\n+    pub(crate) data: [ascii::Char; N],\n \n     // Invariant: alive.start <= alive.end <= N.\n     pub(crate) alive: Range<u8>,\n }\n \n impl<const N: usize> EscapeIterInner<N> {\n-    pub fn new(data: [u8; N], alive: Range<u8>) -> Self {\n+    pub fn new(data: [ascii::Char; N], alive: Range<u8>) -> Self {\n         const { assert!(N < 256) };\n         debug_assert!(alive.start <= alive.end && usize::from(alive.end) <= N, \"{alive:?}\");\n-        let this = Self { data, alive };\n-        debug_assert!(this.as_bytes().is_ascii(), \"Expected ASCII, got {:?}\", this.as_bytes());\n-        this\n+        Self { data, alive }\n+    }\n+\n+    pub fn from_array<const M: usize>(array: [ascii::Char; M]) -> Self {\n+        const { assert!(M <= N) };\n+\n+        let mut data = [ascii::Char::Null; N];\n+        data[..M].copy_from_slice(&array);\n+        Self::new(data, 0..M as u8)\n     }\n \n-    fn as_bytes(&self) -> &[u8] {\n+    pub fn as_ascii(&self) -> &[ascii::Char] {\n         &self.data[usize::from(self.alive.start)..usize::from(self.alive.end)]\n     }\n \n     pub fn as_str(&self) -> &str {\n-        // SAFETY: self.data[self.alive] is all ASCII characters.\n-        unsafe { crate::str::from_utf8_unchecked(self.as_bytes()) }\n+        self.as_ascii().as_str()\n     }\n \n     pub fn len(&self) -> usize {\n         usize::from(self.alive.end - self.alive.start)\n     }\n \n     pub fn next(&mut self) -> Option<u8> {\n-        self.alive.next().map(|i| self.data[usize::from(i)])\n+        self.alive.next().map(|i| self.data[usize::from(i)].as_u8())\n     }\n \n     pub fn next_back(&mut self) -> Option<u8> {\n-        self.alive.next_back().map(|i| self.data[usize::from(i)])\n+        self.alive.next_back().map(|i| self.data[usize::from(i)].as_u8())\n     }\n \n     pub fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {"}, {"sha": "3bbf5d8770bd2ba14bf1957e047c1e13c54098fe", "filename": "library/core/src/fmt/float.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -45,7 +45,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_exact_fixed_str` and `format_exact` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n@@ -71,7 +72,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_shortest_str` and `format_shortest` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n fn float_to_decimal_display<T>(fmt: &mut Formatter<'_>, num: &T) -> Result\n@@ -116,7 +118,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_exact_exp_str` and `format_exact` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n@@ -143,7 +146,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_shortest_exp_str` and `format_shortest` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n // Common code of floating point LowerExp and UpperExp."}, {"sha": "1786b309c5bd3ea77e1f5684b8b17eb334a10e83", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1415,7 +1415,11 @@ impl<'a> Formatter<'a> {\n     /// Takes the formatted parts and applies the padding.\n     /// Assumes that the caller already has rendered the parts with required precision,\n     /// so that `self.precision` can be ignored.\n-    fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n+    unsafe fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n         if let Some(mut width) = self.width {\n             // for the sign-aware zero padding, we render the sign first and\n             // behave as if we had no sign from the beginning.\n@@ -1438,31 +1442,35 @@ impl<'a> Formatter<'a> {\n             let len = formatted.len();\n             let ret = if width <= len {\n                 // no padding\n-                self.write_formatted_parts(&formatted)\n+                // SAFETY: Per the precondition.\n+                unsafe { self.write_formatted_parts(&formatted) }\n             } else {\n                 let post_padding = self.padding(width - len, Alignment::Right)?;\n-                self.write_formatted_parts(&formatted)?;\n+                // SAFETY: Per the precondition.\n+                unsafe {\n+                    self.write_formatted_parts(&formatted)?;\n+                }\n                 post_padding.write(self)\n             };\n             self.fill = old_fill;\n             self.align = old_align;\n             ret\n         } else {\n             // this is the common case and we take a shortcut\n-            self.write_formatted_parts(formatted)\n+            // SAFETY: Per the precondition.\n+            unsafe { self.write_formatted_parts(formatted) }\n         }\n     }\n \n-    fn write_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n-        fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n+    /// # Safety\n+    ///\n+    /// Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n+    unsafe fn write_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n+        unsafe fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n             // SAFETY: This is used for `numfmt::Part::Num` and `numfmt::Part::Copy`.\n             // It's safe to use for `numfmt::Part::Num` since every char `c` is between\n-            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n-            // It's also probably safe in practice to use for `numfmt::Part::Copy(buf)`\n-            // since `buf` should be plain ASCII, but it's possible for someone to pass\n-            // in a bad value for `buf` into `numfmt::to_shortest_str` since it is a\n-            // public function.\n-            // FIXME: Determine whether this could result in UB.\n+            // `b'0'` and `b'9'`, which means `s` is valid UTF-8. It's safe to use for\n+            // `numfmt::Part::Copy` due to this function's precondition.\n             buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n         }\n \n@@ -1489,11 +1497,15 @@ impl<'a> Formatter<'a> {\n                         *c = b'0' + (v % 10) as u8;\n                         v /= 10;\n                     }\n-                    write_bytes(self.buf, &s[..len])?;\n+                    // SAFETY: Per the precondition.\n+                    unsafe {\n+                        write_bytes(self.buf, &s[..len])?;\n+                    }\n                 }\n-                numfmt::Part::Copy(buf) => {\n+                // SAFETY: Per the precondition.\n+                numfmt::Part::Copy(buf) => unsafe {\n                     write_bytes(self.buf, buf)?;\n-                }\n+                },\n             }\n         }\n         Ok(())"}, {"sha": "4f42f73ebbaffd73cbf5f7f3c9f16bc98f1fea19", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -52,8 +52,12 @@ impl_int! { i8 i16 i32 i64 i128 isize }\n impl_uint! { u8 u16 u32 u64 u128 usize }\n \n /// A type that represents a specific radix\n+///\n+/// # Safety\n+///\n+/// `digit` must return an ASCII character.\n #[doc(hidden)]\n-trait GenericRadix: Sized {\n+unsafe trait GenericRadix: Sized {\n     /// The number of digits.\n     const BASE: u8;\n \n@@ -129,7 +133,7 @@ struct UpperHex;\n \n macro_rules! radix {\n     ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n-        impl GenericRadix for $T {\n+        unsafe impl GenericRadix for $T {\n             const BASE: u8 = $base;\n             const PREFIX: &'static str = $prefix;\n             fn digit(x: u8) -> u8 {\n@@ -407,7 +411,7 @@ macro_rules! impl_Exp {\n             let parts = &[\n                 numfmt::Part::Copy(buf_slice),\n                 numfmt::Part::Zero(added_precision),\n-                numfmt::Part::Copy(exp_slice)\n+                numfmt::Part::Copy(exp_slice),\n             ];\n             let sign = if !is_nonnegative {\n                 \"-\"\n@@ -416,8 +420,9 @@ macro_rules! impl_Exp {\n             } else {\n                 \"\"\n             };\n-            let formatted = numfmt::Formatted{sign, parts};\n-            f.pad_formatted_parts(&formatted)\n+            let formatted = numfmt::Formatted { sign, parts };\n+            // SAFETY: `buf_slice` and `exp_slice` contain only ASCII characters.\n+            unsafe { f.pad_formatted_parts(&formatted) }\n         }\n \n         $("}, {"sha": "3f35179ddc29b2fffaddef11c97b14658f7cd233", "filename": "library/core/src/future/join.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -4,7 +4,7 @@ use crate::cell::UnsafeCell;\n use crate::future::{poll_fn, Future};\n use crate::mem;\n use crate::pin::Pin;\n-use crate::task::{Context, Poll};\n+use crate::task::{ready, Context, Poll};\n \n /// Polls multiple futures simultaneously, returning a tuple\n /// of all results once complete.\n@@ -118,7 +118,7 @@ macro join_internal {\n                             fut\n                         })\n                     };\n-                    // Despite how tempting it may be to `let () = fut.poll(cx).ready()?;`\n+                    // Despite how tempting it may be to `let () = ready!(fut.poll(cx));`\n                     // doing so would defeat the point of `join!`: to start polling eagerly all\n                     // of the futures, to allow parallelizing the waits.\n                     done &= fut.poll(cx).is_ready();\n@@ -180,7 +180,7 @@ impl<F: Future> Future for MaybeDone<F> {\n             // Do not mix match ergonomics with unsafe.\n             match *self.as_mut().get_unchecked_mut() {\n                 MaybeDone::Future(ref mut f) => {\n-                    let val = Pin::new_unchecked(f).poll(cx).ready()?;\n+                    let val = ready!(Pin::new_unchecked(f).poll(cx));\n                     self.set(Self::Done(val));\n                 }\n                 MaybeDone::Done(_) => {}"}, {"sha": "723657b9e43e438706e7801efacfe7891e0511f6", "filename": "library/core/src/iter/adapters/filter.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,6 +1,9 @@\n use crate::fmt;\n use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n use crate::ops::Try;\n+use core::array;\n+use core::mem::{ManuallyDrop, MaybeUninit};\n+use core::ops::ControlFlow;\n \n /// An iterator that filters the elements of `iter` with `predicate`.\n ///\n@@ -56,6 +59,58 @@ where\n         self.iter.find(&mut self.predicate)\n     }\n \n+    #[inline]\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut array: [MaybeUninit<Self::Item>; N] = MaybeUninit::uninit_array();\n+\n+        struct Guard<'a, T> {\n+            array: &'a mut [MaybeUninit<T>],\n+            initialized: usize,\n+        }\n+\n+        impl<T> Drop for Guard<'_, T> {\n+            #[inline]\n+            fn drop(&mut self) {\n+                if const { crate::mem::needs_drop::<T>() } {\n+                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n+                    unsafe {\n+                        core::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                            self.array.get_unchecked_mut(..self.initialized),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut guard = Guard { array: &mut array, initialized: 0 };\n+\n+        let result = self.iter.try_for_each(|element| {\n+            let idx = guard.initialized;\n+            guard.initialized = idx + (self.predicate)(&element) as usize;\n+\n+            // SAFETY: Loop conditions ensure the index is in bounds.\n+            unsafe { guard.array.get_unchecked_mut(idx) }.write(element);\n+\n+            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n+        });\n+\n+        let guard = ManuallyDrop::new(guard);\n+\n+        match result {\n+            ControlFlow::Break(()) => {\n+                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n+                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n+            }\n+            ControlFlow::Continue(()) => {\n+                let initialized = guard.initialized;\n+                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n+                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();"}, {"sha": "693479977db51b4a36194d5bfe1aaa5f710612d9", "filename": "library/core/src/iter/adapters/filter_map.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,6 +1,7 @@\n-use crate::fmt;\n use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::mem::{ManuallyDrop, MaybeUninit};\n use crate::ops::{ControlFlow, Try};\n+use crate::{array, fmt};\n \n /// An iterator that uses `f` to both filter and map elements from `iter`.\n ///\n@@ -61,6 +62,65 @@ where\n         self.iter.find_map(&mut self.f)\n     }\n \n+    #[inline]\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut array: [MaybeUninit<Self::Item>; N] = MaybeUninit::uninit_array();\n+\n+        struct Guard<'a, T> {\n+            array: &'a mut [MaybeUninit<T>],\n+            initialized: usize,\n+        }\n+\n+        impl<T> Drop for Guard<'_, T> {\n+            #[inline]\n+            fn drop(&mut self) {\n+                if const { crate::mem::needs_drop::<T>() } {\n+                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n+                    unsafe {\n+                        core::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                            self.array.get_unchecked_mut(..self.initialized),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut guard = Guard { array: &mut array, initialized: 0 };\n+\n+        let result = self.iter.try_for_each(|element| {\n+            let idx = guard.initialized;\n+            let val = (self.f)(element);\n+            guard.initialized = idx + val.is_some() as usize;\n+\n+            // SAFETY: Loop conditions ensure the index is in bounds.\n+\n+            unsafe {\n+                let opt_payload_at = core::intrinsics::option_payload_ptr(&val);\n+                let dst = guard.array.as_mut_ptr().add(idx);\n+                crate::ptr::copy_nonoverlapping(opt_payload_at.cast(), dst, 1);\n+                crate::mem::forget(val);\n+            };\n+\n+            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n+        });\n+\n+        let guard = ManuallyDrop::new(guard);\n+\n+        match result {\n+            ControlFlow::Break(()) => {\n+                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n+                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n+            }\n+            ControlFlow::Continue(()) => {\n+                let initialized = guard.initialized;\n+                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n+                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();"}, {"sha": "0675e56358f9bd76b9cedaa9d875c1ef6f0837c6", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -94,6 +94,16 @@\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n+    on(\n+        _Self = \"&[{A}]\",\n+        message = \"a slice of type `{Self}` cannot be built since we need to store the elements somewhere\",\n+        label = \"try explicitly collecting into a `Vec<{A}>`\",\n+    ),\n+    on(\n+        all(A = \"{integer}\", any(_Self = \"&[{integral}]\",)),\n+        message = \"a slice of type `{Self}` cannot be built since we need to store the elements somewhere\",\n+        label = \"try explicitly collecting into a `Vec<{A}>`\",\n+    ),\n     on(\n         _Self = \"[{A}]\",\n         message = \"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\","}, {"sha": "6c419eb16f3b9b5cc708062ebbc022ce875967ae", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -216,6 +216,7 @@\n #![feature(intra_doc_pointers)]\n #![feature(intrinsics)]\n #![feature(lang_items)]\n+#![feature(let_chains)]\n #![feature(link_llvm_intrinsics)]\n #![feature(macro_metavar_expr)]\n #![feature(min_specialization)]"}, {"sha": "8dab8d1a6923f39272cb39a85b82c62fface5850", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -43,27 +43,17 @@ use crate::hash::Hasher;\n /// ```\n #[unstable(feature = \"internal_impls_macro\", issue = \"none\")]\n macro marker_impls {\n-    ( $(#[$($meta:tt)*])* $Trait:ident for $( $({$($bounds:tt)*})? $T:ty ),+ $(,)?) => {\n-        // This inner macro is needed because... idk macros are weird.\n-        // It allows repeating `meta` on all impls.\n-        #[unstable(feature = \"internal_impls_macro\", issue = \"none\")]\n-        macro _impl {\n-            ( $$({$$($$bounds_:tt)*})? $$T_:ty ) => {\n-                $(#[$($meta)*])* impl<$$($$($$bounds_)*)?> $Trait for $$T_ {}\n-            }\n-        }\n-        $( _impl! { $({$($bounds)*})? $T } )+\n+    ( $(#[$($meta:tt)*])* $Trait:ident for $({$($bounds:tt)*})? $T:ty $(, $($rest:tt)*)? ) => {\n+        $(#[$($meta)*])* impl< $($($bounds)*)? > $Trait for $T {}\n+        marker_impls! { $(#[$($meta)*])* $Trait for $($($rest)*)? }\n     },\n-    ( $(#[$($meta:tt)*])* unsafe $Trait:ident for $( $({$($bounds:tt)*})? $T:ty ),+ $(,)?) => {\n-        #[unstable(feature = \"internal_impls_macro\", issue = \"none\")]\n-        macro _impl {\n-            ( $$({$$($$bounds_:tt)*})? $$T_:ty ) => {\n-                $(#[$($meta)*])* unsafe impl<$$($$($$bounds_)*)?> $Trait for $$T_ {}\n-            }\n-        }\n+    ( $(#[$($meta:tt)*])* $Trait:ident for ) => {},\n \n-        $( _impl! { $({$($bounds)*})? $T } )+\n+    ( $(#[$($meta:tt)*])* unsafe $Trait:ident for $({$($bounds:tt)*})? $T:ty $(, $($rest:tt)*)? ) => {\n+        $(#[$($meta)*])* unsafe impl< $($($bounds)*)? > $Trait for $T {}\n+        marker_impls! { $(#[$($meta)*])* unsafe $Trait for $($($rest)*)? }\n     },\n+    ( $(#[$($meta:tt)*])* unsafe $Trait:ident for ) => {},\n }\n \n /// Types that can be transferred across thread boundaries.\n@@ -986,7 +976,7 @@ pub trait PointerLike {}\n #[rustc_on_unimplemented(message = \"`{Self}` can't be used as a const parameter type\")]\n pub trait ConstParamTy: StructuralEq {}\n \n-/// Derive macro generating an impl of the trait `Copy`.\n+/// Derive macro generating an impl of the trait `ConstParamTy`.\n #[rustc_builtin_macro]\n #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n #[cfg(not(bootstrap))]"}, {"sha": "afbfd6d362dc9c2d7092bcf445efb37ef6669751", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -968,7 +968,7 @@ pub const fn replace<T>(dest: &mut T, src: T) -> T {\n /// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n ///\n /// ```\n-/// # #![cfg_attr(not(bootstrap), allow(drop_copy))]\n+/// # #![cfg_attr(not(bootstrap), allow(dropping_copy_types))]\n /// #[derive(Copy, Clone)]\n /// struct Foo(u8);\n ///"}, {"sha": "20be60d35353e747ad1f2f3ee1475980e9cfcb73", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -28,13 +28,13 @@ pub macro panic_2015 {\n         $crate::panicking::panic($msg)\n     ),\n     // Use `panic_str` instead of `panic_display::<&str>` for non_fmt_panic lint.\n-    ($msg:expr $(,)?) => (\n-        $crate::panicking::panic_str($msg)\n-    ),\n+    ($msg:expr $(,)?) => ({\n+        $crate::panicking::panic_str($msg);\n+    }),\n     // Special-case the single-argument case for const_panic.\n-    (\"{}\", $arg:expr $(,)?) => (\n-        $crate::panicking::panic_display(&$arg)\n-    ),\n+    (\"{}\", $arg:expr $(,)?) => ({\n+        $crate::panicking::panic_display(&$arg);\n+    }),\n     ($fmt:expr, $($arg:tt)+) => ({\n         // Semicolon to prevent temporaries inside the formatting machinery from\n         // being considered alive in the caller after the panic_fmt call.\n@@ -52,9 +52,9 @@ pub macro panic_2021 {\n         $crate::panicking::panic(\"explicit panic\")\n     ),\n     // Special-case the single-argument case for const_panic.\n-    (\"{}\", $arg:expr $(,)?) => (\n-        $crate::panicking::panic_display(&$arg)\n-    ),\n+    (\"{}\", $arg:expr $(,)?) => ({\n+        $crate::panicking::panic_display(&$arg);\n+    }),\n     ($($t:tt)+) => ({\n         // Semicolon to prevent temporaries inside the formatting machinery from\n         // being considered alive in the caller after the panic_fmt call.\n@@ -73,9 +73,9 @@ pub macro unreachable_2015 {\n     ),\n     // Use of `unreachable_display` for non_fmt_panic lint.\n     // NOTE: the message (\"internal error ...\") is embedded directly in unreachable_display\n-    ($msg:expr $(,)?) => (\n-        $crate::panicking::unreachable_display(&$msg)\n-    ),\n+    ($msg:expr $(,)?) => ({\n+        $crate::panicking::unreachable_display(&$msg);\n+    }),\n     ($fmt:expr, $($arg:tt)*) => (\n         $crate::panic!($crate::concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n     ),"}, {"sha": "5ece1b78c0346fa38cc0deaf0a5af1c113421e08", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -995,7 +995,7 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n     #[inline]\n     #[must_use]\n-    pub unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n+    pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n         let this = self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n@@ -1043,7 +1043,7 @@ impl<T> [T] {\n     #[inline]\n     #[track_caller]\n     #[must_use]\n-    pub fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n+    pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n         assert!(N != 0, \"chunk size must be non-zero\");\n         let len = self.len() / N;\n         let (multiple_of_n, remainder) = self.split_at(len * N);\n@@ -1075,7 +1075,7 @@ impl<T> [T] {\n     #[inline]\n     #[track_caller]\n     #[must_use]\n-    pub fn as_rchunks<const N: usize>(&self) -> (&[T], &[[T; N]]) {\n+    pub const fn as_rchunks<const N: usize>(&self) -> (&[T], &[[T; N]]) {\n         assert!(N != 0, \"chunk size must be non-zero\");\n         let len = self.len() / N;\n         let (remainder, multiple_of_n) = self.split_at(self.len() - len * N);\n@@ -1152,7 +1152,7 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n     #[inline]\n     #[must_use]\n-    pub unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {\n+    pub const unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {\n         let this = &*self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n@@ -1195,7 +1195,7 @@ impl<T> [T] {\n     #[inline]\n     #[track_caller]\n     #[must_use]\n-    pub fn as_chunks_mut<const N: usize>(&mut self) -> (&mut [[T; N]], &mut [T]) {\n+    pub const fn as_chunks_mut<const N: usize>(&mut self) -> (&mut [[T; N]], &mut [T]) {\n         assert!(N != 0, \"chunk size must be non-zero\");\n         let len = self.len() / N;\n         let (multiple_of_n, remainder) = self.split_at_mut(len * N);\n@@ -1233,7 +1233,7 @@ impl<T> [T] {\n     #[inline]\n     #[track_caller]\n     #[must_use]\n-    pub fn as_rchunks_mut<const N: usize>(&mut self) -> (&mut [T], &mut [[T; N]]) {\n+    pub const fn as_rchunks_mut<const N: usize>(&mut self) -> (&mut [T], &mut [[T; N]]) {\n         assert!(N != 0, \"chunk size must be non-zero\");\n         let len = self.len() / N;\n         let (remainder, multiple_of_n) = self.split_at_mut(self.len() - len * N);"}, {"sha": "eb8595ca90d56601ef3bb39206f9acef2780cb5e", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1085,12 +1085,12 @@ where\n \n             // SAFETY: left and right must be valid and part of v same for out.\n             unsafe {\n-                let to_copy = if is_less(&*right, &**left) {\n-                    get_and_increment(&mut right)\n-                } else {\n-                    get_and_increment(left)\n-                };\n-                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+                let is_l = is_less(&*right, &**left);\n+                let to_copy = if is_l { right } else { *left };\n+                ptr::copy_nonoverlapping(to_copy, *out, 1);\n+                *out = out.add(1);\n+                right = right.add(is_l as usize);\n+                *left = left.add(!is_l as usize);\n             }\n         }\n     } else {\n@@ -1113,32 +1113,18 @@ where\n \n             // SAFETY: left and right must be valid and part of v same for out.\n             unsafe {\n-                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n-                    decrement_and_get(left)\n-                } else {\n-                    decrement_and_get(right)\n-                };\n-                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+                let is_l = is_less(&*right.sub(1), &*left.sub(1));\n+                *left = left.sub(is_l as usize);\n+                *right = right.sub(!is_l as usize);\n+                let to_copy = if is_l { *left } else { *right };\n+                out = out.sub(1);\n+                ptr::copy_nonoverlapping(to_copy, out, 1);\n             }\n         }\n     }\n     // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n     // it will now be copied into the hole in `v`.\n \n-    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-\n-        // SAFETY: ptr.add(1) must still be a valid pointer and part of `v`.\n-        *ptr = unsafe { ptr.add(1) };\n-        old\n-    }\n-\n-    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        // SAFETY: ptr.sub(1) must still be a valid pointer and part of `v`.\n-        *ptr = unsafe { ptr.sub(1) };\n-        *ptr\n-    }\n-\n     // When dropped, copies the range `start..end` into `dest..`.\n     struct MergeHole<T> {\n         start: *mut T,"}, {"sha": "3f0080e3832e197202683111b20a5d8217a76ebb", "filename": "library/core/src/task/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -13,5 +13,3 @@ pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n mod ready;\n #[stable(feature = \"ready_macro\", since = \"1.64.0\")]\n pub use ready::ready;\n-#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-pub use ready::Ready;"}, {"sha": "0a0f702f6fb75391527f0790569a59f8bbe8d3cd", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -3,7 +3,6 @@\n use crate::convert;\n use crate::ops::{self, ControlFlow};\n use crate::result::Result;\n-use crate::task::Ready;\n \n /// Indicates whether a value is available or if the current task has been\n /// scheduled to receive a wakeup instead.\n@@ -95,38 +94,6 @@ impl<T> Poll<T> {\n     pub const fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n-\n-    /// Extracts the successful type of a [`Poll<T>`].\n-    ///\n-    /// When combined with the `?` operator, this function will\n-    /// propagate any [`Poll::Pending`] values to the caller, and\n-    /// extract the `T` from [`Poll::Ready`].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// #![feature(poll_ready)]\n-    ///\n-    /// use std::task::{Context, Poll};\n-    /// use std::future::{self, Future};\n-    /// use std::pin::Pin;\n-    ///\n-    /// pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n-    ///     let mut fut = future::ready(42);\n-    ///     let fut = Pin::new(&mut fut);\n-    ///\n-    ///     let num = fut.poll(cx).ready()?;\n-    ///     # let _ = num; // to silence unused warning\n-    ///     // ... use num\n-    ///\n-    ///     Poll::Ready(())\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-    pub fn ready(self) -> Ready<T> {\n-        Ready(self)\n-    }\n }\n \n impl<T, E> Poll<Result<T, E>> {"}, {"sha": "495d72fd14be27af2f36842ccdca3ff87cb684a3", "filename": "library/core/src/task/ready.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ftask%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Fsrc%2Ftask%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fready.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,8 +1,3 @@\n-use core::convert;\n-use core::fmt;\n-use core::ops::{ControlFlow, FromResidual, Try};\n-use core::task::Poll;\n-\n /// Extracts the successful type of a [`Poll<T>`].\n ///\n /// This macro bakes in propagation of [`Pending`] signals by returning early.\n@@ -60,55 +55,3 @@ pub macro ready($e:expr) {\n         }\n     }\n }\n-\n-/// Extracts the successful type of a [`Poll<T>`].\n-///\n-/// See [`Poll::ready`] for details.\n-#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-pub struct Ready<T>(pub(crate) Poll<T>);\n-\n-#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-impl<T> Try for Ready<T> {\n-    type Output = T;\n-    type Residual = Ready<convert::Infallible>;\n-\n-    #[inline]\n-    fn from_output(output: Self::Output) -> Self {\n-        Ready(Poll::Ready(output))\n-    }\n-\n-    #[inline]\n-    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n-        match self.0 {\n-            Poll::Ready(v) => ControlFlow::Continue(v),\n-            Poll::Pending => ControlFlow::Break(Ready(Poll::Pending)),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-impl<T> FromResidual for Ready<T> {\n-    #[inline]\n-    fn from_residual(residual: Ready<convert::Infallible>) -> Self {\n-        match residual.0 {\n-            Poll::Pending => Ready(Poll::Pending),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-impl<T> FromResidual<Ready<convert::Infallible>> for Poll<T> {\n-    #[inline]\n-    fn from_residual(residual: Ready<convert::Infallible>) -> Self {\n-        match residual.0 {\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n-impl<T> fmt::Debug for Ready<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Ready\").finish()\n-    }\n-}"}, {"sha": "aee9c89b59544f0a7b051e28c2fa8a9e860186a3", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -386,6 +386,26 @@ fn offset_of() {\n     // Layout of tuples is unstable\n     assert!(offset_of!((u8, u16), 0) <= size_of::<(u8, u16)>() - 1);\n     assert!(offset_of!((u8, u16), 1) <= size_of::<(u8, u16)>() - 2);\n+\n+    #[repr(C)]\n+    struct Generic<T> {\n+        x: u8,\n+        y: u32,\n+        z: T\n+    }\n+\n+    trait Trait {}\n+\n+    // Ensure that this type of generics works\n+    fn offs_of_z<T>() -> usize {\n+        offset_of!(Generic<T>, z)\n+    }\n+\n+    assert_eq!(offset_of!(Generic<u8>, z), 8);\n+    assert_eq!(offs_of_z::<u8>(), 8);\n+\n+    // Ensure that it works with the implicit lifetime in `Box<dyn Trait + '_>`.\n+    assert_eq!(offset_of!(Generic<Box<dyn Trait>>, z), 8);\n }\n \n #[test]"}, {"sha": "89dfdfafdb179188170f0d4c08eb112a47b9477a", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -15,6 +15,7 @@ use crate::ffi::OsString;\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n+use crate::sealed::Sealed;\n use crate::sys::fs as fs_imp;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n use crate::time::SystemTime;\n@@ -1391,6 +1392,16 @@ impl FileTimes {\n     }\n }\n \n+impl AsInnerMut<fs_imp::FileTimes> for FileTimes {\n+    fn as_inner_mut(&mut self) -> &mut fs_imp::FileTimes {\n+        &mut self.0\n+    }\n+}\n+\n+// For implementing OS extension traits in `std::os`\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+impl Sealed for FileTimes {}\n+\n impl Permissions {\n     /// Returns `true` if these permissions describe a readonly (unwritable) file.\n     ///"}, {"sha": "e2480bcbbc729381e259441d74949de48594d518", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,15 +1,15 @@\n use crate::io::prelude::*;\n \n use crate::env;\n-use crate::fs::{self, File, OpenOptions};\n+use crate::fs::{self, File, FileTimes, OpenOptions};\n use crate::io::{BorrowedBuf, ErrorKind, SeekFrom};\n use crate::mem::MaybeUninit;\n use crate::path::Path;\n use crate::str;\n use crate::sync::Arc;\n use crate::sys_common::io::test::{tmpdir, TempDir};\n use crate::thread;\n-use crate::time::{Duration, Instant};\n+use crate::time::{Duration, Instant, SystemTime};\n \n use rand::RngCore;\n \n@@ -1633,3 +1633,53 @@ fn rename_directory() {\n     assert!(new_path.join(\"newdir\").is_dir());\n     assert!(new_path.join(\"newdir/temp.txt\").exists());\n }\n+\n+#[test]\n+fn test_file_times() {\n+    #[cfg(target_os = \"ios\")]\n+    use crate::os::ios::fs::FileTimesExt;\n+    #[cfg(target_os = \"macos\")]\n+    use crate::os::macos::fs::FileTimesExt;\n+    #[cfg(target_os = \"watchos\")]\n+    use crate::os::watchos::fs::FileTimesExt;\n+    #[cfg(windows)]\n+    use crate::os::windows::fs::FileTimesExt;\n+\n+    let tmp = tmpdir();\n+    let file = File::create(tmp.join(\"foo\")).unwrap();\n+    let mut times = FileTimes::new();\n+    let accessed = SystemTime::UNIX_EPOCH + Duration::from_secs(12345);\n+    let modified = SystemTime::UNIX_EPOCH + Duration::from_secs(54321);\n+    times = times.set_accessed(accessed).set_modified(modified);\n+    #[cfg(any(windows, target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+    let created = SystemTime::UNIX_EPOCH + Duration::from_secs(32123);\n+    #[cfg(any(windows, target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+    {\n+        times = times.set_created(created);\n+    }\n+    match file.set_times(times) {\n+        // Allow unsupported errors on platforms which don't support setting times.\n+        #[cfg(not(any(\n+            windows,\n+            all(\n+                unix,\n+                not(any(\n+                    target_os = \"android\",\n+                    target_os = \"redox\",\n+                    target_os = \"espidf\",\n+                    target_os = \"horizon\"\n+                ))\n+            )\n+        )))]\n+        Err(e) if e.kind() == ErrorKind::Unsupported => return,\n+        Err(e) => panic!(\"error setting file times: {e:?}\"),\n+        Ok(_) => {}\n+    }\n+    let metadata = file.metadata().unwrap();\n+    assert_eq!(metadata.accessed().unwrap(), accessed);\n+    assert_eq!(metadata.modified().unwrap(), modified);\n+    #[cfg(any(windows, target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+    {\n+        assert_eq!(metadata.created().unwrap(), created);\n+    }\n+}"}, {"sha": "141a18a42dde64a4f6b6770d0cebb9a621f78660", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -756,6 +756,15 @@ impl TcpListener {\n     /// ];\n     /// let listener = TcpListener::bind(&addrs[..]).unwrap();\n     /// ```\n+    ///\n+    /// Creates a TCP listener bound to a port assigned by the operating system\n+    /// at `127.0.0.1`.\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let socket = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)"}, {"sha": "5ca4ed832f3404e70b640da8c36eb7832daa1eb4", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -90,6 +90,15 @@ impl UdpSocket {\n     /// ];\n     /// let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n     /// ```\n+    ///\n+    /// Creates a UDP socket bound to a port assigned by the operating system\n+    /// at `127.0.0.1`.\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:0\").unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)"}, {"sha": "6d4d54b7c78c541fa172753923ce59e8d899b814", "filename": "library/std/src/os/ios/fs.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fios%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fios%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fios%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,7 +1,9 @@\n #![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n \n-use crate::fs::Metadata;\n-use crate::sys_common::AsInner;\n+use crate::fs::{self, Metadata};\n+use crate::sealed::Sealed;\n+use crate::sys_common::{AsInner, AsInnerMut, IntoInner};\n+use crate::time::SystemTime;\n \n #[allow(deprecated)]\n use crate::os::ios::raw;\n@@ -140,3 +142,19 @@ impl MetadataExt for Metadata {\n         self.as_inner().as_inner().st_lspare as u32\n     }\n }\n+\n+/// OS-specific extensions to [`fs::FileTimes`].\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+pub trait FileTimesExt: Sealed {\n+    /// Set the creation time of a file.\n+    #[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+    fn set_created(self, t: SystemTime) -> Self;\n+}\n+\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+impl FileTimesExt for fs::FileTimes {\n+    fn set_created(mut self, t: SystemTime) -> Self {\n+        self.as_inner_mut().set_created(t.into_inner());\n+        self\n+    }\n+}"}, {"sha": "fe82d03d869801f2bedb46012df4760e60702132", "filename": "library/std/src/os/macos/fs.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fmacos%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fmacos%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmacos%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,7 +1,9 @@\n #![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n \n-use crate::fs::Metadata;\n-use crate::sys_common::AsInner;\n+use crate::fs::{self, Metadata};\n+use crate::sealed::Sealed;\n+use crate::sys_common::{AsInner, AsInnerMut, IntoInner};\n+use crate::time::SystemTime;\n \n #[allow(deprecated)]\n use crate::os::macos::raw;\n@@ -146,3 +148,19 @@ impl MetadataExt for Metadata {\n         [qspare[0] as u64, qspare[1] as u64]\n     }\n }\n+\n+/// OS-specific extensions to [`fs::FileTimes`].\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+pub trait FileTimesExt: Sealed {\n+    /// Set the creation time of a file.\n+    #[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+    fn set_created(self, t: SystemTime) -> Self;\n+}\n+\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+impl FileTimesExt for fs::FileTimes {\n+    fn set_created(mut self, t: SystemTime) -> Self {\n+        self.as_inner_mut().set_created(t.into_inner());\n+        self\n+    }\n+}"}, {"sha": "2ecc4c68a962f2da829c557ac610ff63e12570ce", "filename": "library/std/src/os/watchos/fs.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fwatchos%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fwatchos%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwatchos%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,7 +1,9 @@\n #![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n \n-use crate::fs::Metadata;\n-use crate::sys_common::AsInner;\n+use crate::fs::{self, Metadata};\n+use crate::sealed::Sealed;\n+use crate::sys_common::{AsInner, AsInnerMut, IntoInner};\n+use crate::time::SystemTime;\n \n #[allow(deprecated)]\n use crate::os::watchos::raw;\n@@ -140,3 +142,19 @@ impl MetadataExt for Metadata {\n         self.as_inner().as_inner().st_lspare as u32\n     }\n }\n+\n+/// OS-specific extensions to [`fs::FileTimes`].\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+pub trait FileTimesExt: Sealed {\n+    /// Set the creation time of a file.\n+    #[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+    fn set_created(self, t: SystemTime) -> Self;\n+}\n+\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+impl FileTimesExt for fs::FileTimes {\n+    fn set_created(mut self, t: SystemTime) -> Self {\n+        self.as_inner_mut().set_created(t.into_inner());\n+        self\n+    }\n+}"}, {"sha": "94509e547964bdf5e82df54c1026f98ff4590488", "filename": "library/std/src/os/windows/fs.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -9,7 +9,8 @@ use crate::io;\n use crate::path::Path;\n use crate::sealed::Sealed;\n use crate::sys;\n-use crate::sys_common::{AsInner, AsInnerMut};\n+use crate::sys_common::{AsInner, AsInnerMut, IntoInner};\n+use crate::time::SystemTime;\n \n /// Windows-specific extensions to [`fs::File`].\n #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n@@ -526,6 +527,22 @@ impl FileTypeExt for fs::FileType {\n     }\n }\n \n+/// Windows-specific extensions to [`fs::FileTimes`].\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+pub trait FileTimesExt: Sealed {\n+    /// Set the creation time of a file.\n+    #[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+    fn set_created(self, t: SystemTime) -> Self;\n+}\n+\n+#[unstable(feature = \"file_set_times\", issue = \"98245\")]\n+impl FileTimesExt for fs::FileTimes {\n+    fn set_created(mut self, t: SystemTime) -> Self {\n+        self.as_inner_mut().set_created(t.into_inner());\n+        self\n+    }\n+}\n+\n /// Creates a new symlink to a non-directory file on the filesystem.\n ///\n /// The `link` path will be a file symbolic link pointing to the `original`"}, {"sha": "69a6f3e6d5ac43a83cb9369bb1b5d38bf0aa92d3", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -19,11 +19,11 @@ pub macro panic_2015 {\n         $crate::rt::begin_panic(\"explicit panic\")\n     }),\n     ($msg:expr $(,)?) => ({\n-        $crate::rt::begin_panic($msg)\n+        $crate::rt::begin_panic($msg);\n     }),\n     // Special-case the single-argument case for const_panic.\n     (\"{}\", $arg:expr $(,)?) => ({\n-        $crate::rt::panic_display(&$arg)\n+        $crate::rt::panic_display(&$arg);\n     }),\n     ($fmt:expr, $($arg:tt)+) => ({\n         // Semicolon to prevent temporaries inside the formatting machinery from"}, {"sha": "febdeb514634cd5c5edc12554f30606705b6d35c", "filename": "library/std/src/path.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -733,8 +733,9 @@ impl<'a> Components<'a> {\n         }\n     }\n \n-    // parse a given byte sequence into the corresponding path component\n-    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n+    // parse a given byte sequence following the OsStr encoding into the\n+    // corresponding path component\n+    unsafe fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n         match comp {\n             b\".\" if self.prefix_verbatim() => Some(Component::CurDir),\n             b\".\" => None, // . components are normalized away, except at\n@@ -754,7 +755,8 @@ impl<'a> Components<'a> {\n             None => (0, self.path),\n             Some(i) => (1, &self.path[..i]),\n         };\n-        (comp.len() + extra, self.parse_single_component(comp))\n+        // SAFETY: `comp` is a valid substring, since it is split on a separator.\n+        (comp.len() + extra, unsafe { self.parse_single_component(comp) })\n     }\n \n     // parse a component from the right, saying how many bytes to consume to\n@@ -766,7 +768,8 @@ impl<'a> Components<'a> {\n             None => (0, &self.path[start..]),\n             Some(i) => (1, &self.path[start + i + 1..]),\n         };\n-        (comp.len() + extra, self.parse_single_component(comp))\n+        // SAFETY: `comp` is a valid substring, since it is split on a separator.\n+        (comp.len() + extra, unsafe { self.parse_single_component(comp) })\n     }\n \n     // trim away repeated separators (i.e., empty components) on the left"}, {"sha": "09e9ae2720f5b5bb865518afebd09506ef89e50a", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -349,6 +349,8 @@ pub struct FilePermissions {\n pub struct FileTimes {\n     accessed: Option<SystemTime>,\n     modified: Option<SystemTime>,\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+    created: Option<SystemTime>,\n }\n \n #[derive(Copy, Clone, Eq, Debug)]\n@@ -591,6 +593,11 @@ impl FileTimes {\n     pub fn set_modified(&mut self, t: SystemTime) {\n         self.modified = Some(t);\n     }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+    pub fn set_created(&mut self, t: SystemTime) {\n+        self.created = Some(t);\n+    }\n }\n \n impl FileType {\n@@ -1215,26 +1222,41 @@ impl File {\n                     io::ErrorKind::Unsupported,\n                     \"setting file times not supported\",\n                 ))\n-            } else if #[cfg(any(target_os = \"android\", target_os = \"macos\"))] {\n+            } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))] {\n+                let mut buf = [mem::MaybeUninit::<libc::timespec>::uninit(); 3];\n+                let mut num_times = 0;\n+                let mut attrlist: libc::attrlist = unsafe { mem::zeroed() };\n+                attrlist.bitmapcount = libc::ATTR_BIT_MAP_COUNT;\n+                if times.created.is_some() {\n+                    buf[num_times].write(to_timespec(times.created)?);\n+                    num_times += 1;\n+                    attrlist.commonattr |= libc::ATTR_CMN_CRTIME;\n+                }\n+                if times.modified.is_some() {\n+                    buf[num_times].write(to_timespec(times.modified)?);\n+                    num_times += 1;\n+                    attrlist.commonattr |= libc::ATTR_CMN_MODTIME;\n+                }\n+                if times.accessed.is_some() {\n+                    buf[num_times].write(to_timespec(times.accessed)?);\n+                    num_times += 1;\n+                    attrlist.commonattr |= libc::ATTR_CMN_ACCTIME;\n+                }\n+                cvt(unsafe { libc::fsetattrlist(\n+                    self.as_raw_fd(),\n+                    (&attrlist as *const libc::attrlist).cast::<libc::c_void>().cast_mut(),\n+                    buf.as_ptr().cast::<libc::c_void>().cast_mut(),\n+                    num_times * mem::size_of::<libc::timespec>(),\n+                    0\n+                ) })?;\n+                Ok(())\n+            } else if #[cfg(target_os = \"android\")] {\n                 let times = [to_timespec(times.accessed)?, to_timespec(times.modified)?];\n-                // futimens requires macOS 10.13, and Android API level 19\n+                // futimens requires Android API level 19\n                 cvt(unsafe {\n                     weak!(fn futimens(c_int, *const libc::timespec) -> c_int);\n                     match futimens.get() {\n                         Some(futimens) => futimens(self.as_raw_fd(), times.as_ptr()),\n-                        #[cfg(target_os = \"macos\")]\n-                        None => {\n-                            fn ts_to_tv(ts: &libc::timespec) -> libc::timeval {\n-                                libc::timeval {\n-                                    tv_sec: ts.tv_sec,\n-                                    tv_usec: (ts.tv_nsec / 1000) as _\n-                                }\n-                            }\n-                            let timevals = [ts_to_tv(&times[0]), ts_to_tv(&times[1])];\n-                            libc::futimes(self.as_raw_fd(), timevals.as_ptr())\n-                        }\n-                        // futimes requires even newer Android.\n-                        #[cfg(target_os = \"android\")]\n                         None => return Err(io::const_io_error!(\n                             io::ErrorKind::Unsupported,\n                             \"setting file times requires Android API level >= 19\","}, {"sha": "21a65bc25f35880d26b85e654c3cee0999b0191c", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -88,8 +88,10 @@ pub struct FilePermissions {\n pub struct FileTimes {\n     accessed: Option<c::FILETIME>,\n     modified: Option<c::FILETIME>,\n+    created: Option<c::FILETIME>,\n }\n-impl core::fmt::Debug for c::FILETIME {\n+\n+impl fmt::Debug for c::FILETIME {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let time = ((self.dwHighDateTime as u64) << 32) | self.dwLowDateTime as u64;\n         f.debug_tuple(\"FILETIME\").field(&time).finish()\n@@ -582,26 +584,34 @@ impl File {\n \n     pub fn set_times(&self, times: FileTimes) -> io::Result<()> {\n         let is_zero = |t: c::FILETIME| t.dwLowDateTime == 0 && t.dwHighDateTime == 0;\n-        if times.accessed.map_or(false, is_zero) || times.modified.map_or(false, is_zero) {\n+        if times.accessed.map_or(false, is_zero)\n+            || times.modified.map_or(false, is_zero)\n+            || times.created.map_or(false, is_zero)\n+        {\n             return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n                 \"Cannot set file timestamp to 0\",\n             ));\n         }\n         let is_max =\n             |t: c::FILETIME| t.dwLowDateTime == c::DWORD::MAX && t.dwHighDateTime == c::DWORD::MAX;\n-        if times.accessed.map_or(false, is_max) || times.modified.map_or(false, is_max) {\n+        if times.accessed.map_or(false, is_max)\n+            || times.modified.map_or(false, is_max)\n+            || times.created.map_or(false, is_max)\n+        {\n             return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n                 \"Cannot set file timestamp to 0xFFFF_FFFF_FFFF_FFFF\",\n             ));\n         }\n         cvt(unsafe {\n+            let created =\n+                times.created.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());\n             let accessed =\n                 times.accessed.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());\n             let modified =\n                 times.modified.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());\n-            c::SetFileTime(self.as_raw_handle(), ptr::null_mut(), accessed, modified)\n+            c::SetFileTime(self.as_raw_handle(), created, accessed, modified)\n         })?;\n         Ok(())\n     }\n@@ -1005,6 +1015,10 @@ impl FileTimes {\n     pub fn set_modified(&mut self, t: SystemTime) {\n         self.modified = Some(t.into_inner());\n     }\n+\n+    pub fn set_created(&mut self, t: SystemTime) {\n+        self.created = Some(t.into_inner());\n+    }\n }\n \n impl FileType {"}, {"sha": "6f020940df12fd067a897c9ac5c39f50892151d6", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -68,13 +68,17 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n         }\n \n         let mut hit = false;\n-        let mut stop = false;\n         backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n             hit = true;\n+\n+            // Any frames between `__rust_begin_short_backtrace` and `__rust_end_short_backtrace`\n+            // are omitted from the backtrace in short mode, `__rust_end_short_backtrace` will be\n+            // called before the panic hook, so we won't ignore any frames if there is no\n+            // invoke of `__rust_begin_short_backtrace`.\n             if print_fmt == PrintFmt::Short {\n                 if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n                     if start && sym.contains(\"__rust_begin_short_backtrace\") {\n-                        stop = true;\n+                        start = false;\n                         return;\n                     }\n                     if sym.contains(\"__rust_end_short_backtrace\") {\n@@ -88,9 +92,6 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n                 res = bt_fmt.frame().symbol(frame, symbol);\n             }\n         });\n-        if stop {\n-            return false;\n-        }\n         #[cfg(target_os = \"nto\")]\n         if libc::__my_thread_exit as *mut libc::c_void == frame.ip() {\n             if !hit && start {"}, {"sha": "8f8778efee79693189f601643d0dfd7400ae9181", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -139,7 +139,7 @@ dependencies = [\n  \"heck\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 2.0.15\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]\n@@ -488,9 +488,9 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.29.0\"\n+version = \"0.31.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+checksum = \"8bda667d9f2b5051b8833f59f3bf748b28ef54f850f4fcb389a252aa383866d1\"\n dependencies = [\n  \"memchr\",\n ]\n@@ -654,19 +654,19 @@ checksum = \"bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.137\"\n+version = \"1.0.160\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n+checksum = \"bb2f3770c8bce3bcda7e149193a069a0f4365bda1fa5cd88e03bca26afc1216c\"\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.137\"\n+version = \"1.0.160\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n+checksum = \"291a097c63d8497e00160b166a967a4a79c64f3facdd01cbd7502231688d77df\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]\n@@ -704,9 +704,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"2.0.15\"\n+version = \"2.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a34fcf3e8b60f57e6a14301a2e916d323af98b0ea63c599441eec8558660c822\"\n+checksum = \"bcc02725fd69ab9f26eab07fad303e2497fad6fb9eba4f96c4d1687bdf704ad9\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "367c6190967c670eb83725e30b76873f694fc444", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -37,7 +37,7 @@ filetime = \"0.2\"\n cc = \"1.0.69\"\n libc = \"0.2\"\n hex = \"0.4\"\n-object = { version = \"0.29.0\", default-features = false, features = [\"archive\", \"coff\", \"read_core\", \"unaligned\"] }\n+object = { version = \"0.31.1\", default-features = false, features = [\"archive\", \"coff\", \"read_core\", \"unaligned\"] }\n serde = \"1.0.137\"\n # Directly use serde_derive rather than through the derive feature of serde to allow building both\n # in parallel and to allow serde_json and toml to start building as soon as serde has been built."}, {"sha": "50ace987193a2289e04c6b75d04d6c7f3676a865", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -109,7 +109,7 @@ def _download(path, url, probably_big, verbose, exception):\n                 \"-L\", # Follow redirect.\n                 \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n                 \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n-                \"--retry\", \"3\", \"-Sf\", url],\n+                \"--retry\", \"3\", \"-SRf\", url],\n                 stdout=outfile,    #Implements cli redirect operator '>'\n                 verbose=verbose,\n                 exception=True, # Will raise RuntimeError on failure"}, {"sha": "cf7c6596c02389d5668da9e2ea040cc0b14d5da5", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -942,7 +942,6 @@ impl<'a> Builder<'a> {\n         self.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), paths);\n     }\n \n-    /// NOTE: keep this in sync with `rustdoc::clean::utils::doc_rust_lang_org_channel`, or tests will fail on beta/stable.\n     pub fn doc_rust_lang_org_channel(&self) -> String {\n         let channel = match &*self.config.channel {\n             \"stable\" => &self.version,"}, {"sha": "edca8fe9b13afd2e51a624205f8fd046c61e8a75", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -146,6 +146,22 @@ fn alias_and_path_for_library() {\n     );\n }\n \n+#[test]\n+fn test_beta_rev_parsing() {\n+    use crate::extract_beta_rev;\n+\n+    // single digit revision\n+    assert_eq!(extract_beta_rev(\"1.99.9-beta.7 (xxxxxx)\"), Some(\"7\".to_string()));\n+    // multiple digits\n+    assert_eq!(extract_beta_rev(\"1.99.9-beta.777 (xxxxxx)\"), Some(\"777\".to_string()));\n+    // nightly channel (no beta revision)\n+    assert_eq!(extract_beta_rev(\"1.99.9-nightly (xxxxxx)\"), None);\n+    // stable channel (no beta revision)\n+    assert_eq!(extract_beta_rev(\"1.99.9 (xxxxxxx)\"), None);\n+    // invalid string\n+    assert_eq!(extract_beta_rev(\"invalid\"), None);\n+}\n+\n mod defaults {\n     use super::{configure, first, run_build};\n     use crate::builder::*;"}, {"sha": "25df5b2573b96bf1b9a4b6e9c0baf21ab3026873", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -219,7 +219,7 @@ impl Config {\n             \"30\", // timeout if cannot connect within 30 seconds\n             \"--retry\",\n             \"3\",\n-            \"-Sf\",\n+            \"-SRf\",\n         ]);\n         curl.arg(url);\n         let f = File::create(tempfile).unwrap();"}, {"sha": "d8b298b59a3f820960f7532874afa34a49f506c0", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -365,7 +365,7 @@ pub enum Subcommand {\n         #[arg(long)]\n         all: bool,\n     },\n-    /// Duild distribution artifacts\n+    /// Build distribution artifacts\n     Dist,\n     /// Install distribution artifacts\n     Install,"}, {"sha": "6ee50ee657399283b4e66b0c92d8dcb2d5232d78", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1324,7 +1324,7 @@ impl Build {\n         match &self.config.channel[..] {\n             \"stable\" => num.to_string(),\n             \"beta\" => {\n-                if self.rust_info().is_managed_git_subrepository() && !self.config.omit_git_hash {\n+                if !self.config.omit_git_hash {\n                     format!(\"{}-beta.{}\", num, self.beta_prerelease_version())\n                 } else {\n                     format!(\"{}-beta\", num)\n@@ -1336,18 +1336,28 @@ impl Build {\n     }\n \n     fn beta_prerelease_version(&self) -> u32 {\n+        fn extract_beta_rev_from_file<P: AsRef<Path>>(version_file: P) -> Option<String> {\n+            let version = fs::read_to_string(version_file).ok()?;\n+\n+            extract_beta_rev(&version)\n+        }\n+\n         if let Some(s) = self.prerelease_version.get() {\n             return s;\n         }\n \n-        // Figure out how many merge commits happened since we branched off master.\n-        // That's our beta number!\n-        // (Note that we use a `..` range, not the `...` symmetric difference.)\n-        let count =\n+        // First check if there is a version file available.\n+        // If available, we read the beta revision from that file.\n+        // This only happens when building from a source tarball when Git should not be used.\n+        let count = extract_beta_rev_from_file(self.src.join(\"version\")).unwrap_or_else(|| {\n+            // Figure out how many merge commits happened since we branched off master.\n+            // That's our beta number!\n+            // (Note that we use a `..` range, not the `...` symmetric difference.)\n             output(self.config.git().arg(\"rev-list\").arg(\"--count\").arg(\"--merges\").arg(format!(\n                 \"refs/remotes/origin/{}..HEAD\",\n                 self.config.stage0_metadata.config.nightly_branch\n-            )));\n+            )))\n+        });\n         let n = count.trim().parse().unwrap();\n         self.prerelease_version.set(Some(n));\n         n\n@@ -1707,6 +1717,17 @@ to download LLVM rather than building it.\n     }\n }\n \n+/// Extract the beta revision from the full version string.\n+///\n+/// The full version string looks like \"a.b.c-beta.y\". And we need to extract\n+/// the \"y\" part from the string.\n+pub fn extract_beta_rev(version: &str) -> Option<String> {\n+    let parts = version.splitn(2, \"-beta.\").collect::<Vec<_>>();\n+    let count = parts.get(1).and_then(|s| s.find(' ').map(|p| (&s[..p]).to_string()));\n+\n+    count\n+}\n+\n #[cfg(unix)]\n fn chmod(path: &Path, perms: u32) {\n     use std::os::unix::fs::*;"}, {"sha": "fa0a4806618b7b9f8826b8dc611c39a687b01571", "filename": "src/bootstrap/render_tests.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -168,9 +168,14 @@ impl<'a> Renderer<'a> {\n         if !self.failures.is_empty() {\n             println!(\"\\nfailures:\\n\");\n             for failure in &self.failures {\n-                if let Some(stdout) = &failure.stdout {\n+                if failure.stdout.is_some() || failure.message.is_some() {\n                     println!(\"---- {} stdout ----\", failure.name);\n-                    println!(\"{stdout}\");\n+                    if let Some(stdout) = &failure.stdout {\n+                        println!(\"{stdout}\");\n+                    }\n+                    if let Some(message) = &failure.message {\n+                        println!(\"note: {message}\");\n+                    }\n                 }\n             }\n "}, {"sha": "2b72d6c48eb75aab665c2a87b203d81937233d10", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -620,6 +620,8 @@ impl Step for Miri {\n             cargo.env(\"MIRIFLAGS\", \"-O -Zmir-opt-level=4 -Cdebug-assertions=yes\");\n             // Optimizations can change backtraces\n             cargo.env(\"MIRI_SKIP_UI_CHECKS\", \"1\");\n+            // `MIRI_SKIP_UI_CHECKS` and `MIRI_BLESS` are incompatible\n+            cargo.env_remove(\"MIRI_BLESS\");\n             // Optimizations can change error locations and remove UB so don't run `fail` tests.\n             cargo.args(&[\"tests/pass\", \"tests/panic\"]);\n "}, {"sha": "806935b827ff55b1395d32406839fdb78753dd88", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1 +1 @@\n-0.16.3\n\\ No newline at end of file\n+0.16.4\n\\ No newline at end of file"}, {"sha": "8d03d3759bf00dba0147a116b9102f2c1aee12ff", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -48,7 +48,6 @@\n \n LLVM_BOLT_CRATES = LLVM_PGO_CRATES\n \n-\n class Pipeline:\n     # Paths\n     def checkout_path(self) -> Path:\n@@ -451,6 +450,44 @@ def cmd(\n             )\n     return subprocess.run(args, env=environment, check=True)\n \n+class BenchmarkRunner:\n+    def run_rustc(self, pipeline: Pipeline):\n+        raise NotImplementedError\n+\n+    def run_llvm(self, pipeline: Pipeline):\n+        raise NotImplementedError\n+\n+    def run_bolt(self, pipeline: Pipeline):\n+        raise NotImplementedError\n+\n+class DefaultBenchmarkRunner(BenchmarkRunner):\n+    def run_rustc(self, pipeline: Pipeline):\n+        # Here we're profiling the `rustc` frontend, so we also include `Check`.\n+        # The benchmark set includes various stress tests that put the frontend under pressure.\n+        run_compiler_benchmarks(\n+            pipeline,\n+            profiles=[\"Check\", \"Debug\", \"Opt\"],\n+            scenarios=[\"All\"],\n+            crates=RUSTC_PGO_CRATES,\n+            env=dict(\n+                LLVM_PROFILE_FILE=str(pipeline.rustc_profile_template_path())\n+            )\n+        )\n+    def run_llvm(self, pipeline: Pipeline):\n+        run_compiler_benchmarks(\n+            pipeline,\n+            profiles=[\"Debug\", \"Opt\"],\n+            scenarios=[\"Full\"],\n+            crates=LLVM_PGO_CRATES\n+        )\n+\n+    def run_bolt(self, pipeline: Pipeline):\n+        run_compiler_benchmarks(\n+            pipeline,\n+            profiles=[\"Check\", \"Debug\", \"Opt\"],\n+            scenarios=[\"Full\"],\n+            crates=LLVM_BOLT_CRATES\n+        )\n \n def run_compiler_benchmarks(\n         pipeline: Pipeline,\n@@ -580,14 +617,10 @@ def create_pipeline() -> Pipeline:\n         raise Exception(f\"Optimized build is not supported for platform {sys.platform}\")\n \n \n-def gather_llvm_profiles(pipeline: Pipeline):\n+def gather_llvm_profiles(pipeline: Pipeline, runner: BenchmarkRunner):\n     LOGGER.info(\"Running benchmarks with PGO instrumented LLVM\")\n-    run_compiler_benchmarks(\n-        pipeline,\n-        profiles=[\"Debug\", \"Opt\"],\n-        scenarios=[\"Full\"],\n-        crates=LLVM_PGO_CRATES\n-    )\n+\n+    runner.run_llvm(pipeline)\n \n     profile_path = pipeline.llvm_profile_merged_file()\n     LOGGER.info(f\"Merging LLVM PGO profiles to {profile_path}\")\n@@ -609,20 +642,12 @@ def gather_llvm_profiles(pipeline: Pipeline):\n     delete_directory(pipeline.llvm_profile_dir_root())\n \n \n-def gather_rustc_profiles(pipeline: Pipeline):\n+def gather_rustc_profiles(pipeline: Pipeline, runner: BenchmarkRunner):\n     LOGGER.info(\"Running benchmarks with PGO instrumented rustc\")\n \n-    # Here we're profiling the `rustc` frontend, so we also include `Check`.\n-    # The benchmark set includes various stress tests that put the frontend under pressure.\n-    run_compiler_benchmarks(\n-        pipeline,\n-        profiles=[\"Check\", \"Debug\", \"Opt\"],\n-        scenarios=[\"All\"],\n-        crates=RUSTC_PGO_CRATES,\n-        env=dict(\n-            LLVM_PROFILE_FILE=str(pipeline.rustc_profile_template_path())\n-        )\n-    )\n+\n+    runner.run_rustc(pipeline)\n+\n \n     profile_path = pipeline.rustc_profile_merged_file()\n     LOGGER.info(f\"Merging Rustc PGO profiles to {profile_path}\")\n@@ -644,14 +669,10 @@ def gather_rustc_profiles(pipeline: Pipeline):\n     delete_directory(pipeline.rustc_profile_dir_root())\n \n \n-def gather_llvm_bolt_profiles(pipeline: Pipeline):\n+def gather_llvm_bolt_profiles(pipeline: Pipeline, runner: BenchmarkRunner):\n     LOGGER.info(\"Running benchmarks with BOLT instrumented LLVM\")\n-    run_compiler_benchmarks(\n-        pipeline,\n-        profiles=[\"Check\", \"Debug\", \"Opt\"],\n-        scenarios=[\"Full\"],\n-        crates=LLVM_BOLT_CRATES\n-    )\n+\n+    runner.run_bolt(pipeline)\n \n     merged_profile_path = pipeline.llvm_bolt_profile_merged_file()\n     profile_files_path = Path(\"/tmp/prof.fdata\")\n@@ -744,7 +765,7 @@ def record_metrics(pipeline: Pipeline, timer: Timer):\n     log_metrics(metrics)\n \n \n-def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: List[str]):\n+def execute_build_pipeline(timer: Timer, pipeline: Pipeline, runner: BenchmarkRunner, final_build_args: List[str]):\n     # Clear and prepare tmp directory\n     shutil.rmtree(pipeline.opt_artifacts(), ignore_errors=True)\n     os.makedirs(pipeline.opt_artifacts(), exist_ok=True)\n@@ -762,7 +783,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n             record_metrics(pipeline, rustc_build)\n \n         with stage1.section(\"Gather profiles\"):\n-            gather_llvm_profiles(pipeline)\n+            gather_llvm_profiles(pipeline, runner)\n         print_free_disk_space(pipeline)\n \n     clear_llvm_files(pipeline)\n@@ -781,7 +802,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n             record_metrics(pipeline, rustc_build)\n \n         with stage2.section(\"Gather profiles\"):\n-            gather_rustc_profiles(pipeline)\n+            gather_rustc_profiles(pipeline, runner)\n         print_free_disk_space(pipeline)\n \n     clear_llvm_files(pipeline)\n@@ -804,7 +825,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n                 record_metrics(pipeline, rustc_build)\n \n             with stage3.section(\"Gather profiles\"):\n-                gather_llvm_bolt_profiles(pipeline)\n+                gather_llvm_bolt_profiles(pipeline, runner)\n \n         # LLVM is not being cleared here, we want to reuse the previous build\n         print_free_disk_space(pipeline)\n@@ -819,7 +840,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n         record_metrics(pipeline, stage4)\n \n \n-if __name__ == \"__main__\":\n+def run(runner: BenchmarkRunner):\n     logging.basicConfig(\n         level=logging.DEBUG,\n         format=\"%(name)s %(levelname)-4s: %(message)s\",\n@@ -832,8 +853,9 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n \n     timer = Timer()\n     pipeline = create_pipeline()\n+\n     try:\n-        execute_build_pipeline(timer, pipeline, build_args)\n+        execute_build_pipeline(timer, pipeline, runner, build_args)\n     except BaseException as e:\n         LOGGER.error(\"The multi-stage build has failed\")\n         raise e\n@@ -842,3 +864,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n         print_free_disk_space(pipeline)\n \n     print_binary_sizes(pipeline)\n+\n+if __name__ == \"__main__\":\n+    runner = DefaultBenchmarkRunner()\n+    run(runner)"}, {"sha": "4eddd5cedf18e02e6bc6d90565608ed9c3c2bf9f", "filename": "src/etc/completions/x.py.fish", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fetc%2Fcompletions%2Fx.py.fish", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fetc%2Fcompletions%2Fx.py.fish", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcompletions%2Fx.py.fish?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -36,7 +36,7 @@ complete -c x.py -n \"__fish_use_subcommand\" -f -a \"doc\" -d 'Build documentation'\n complete -c x.py -n \"__fish_use_subcommand\" -f -a \"test\" -d 'Build and run some test suites'\n complete -c x.py -n \"__fish_use_subcommand\" -f -a \"bench\" -d 'Build and run some benchmarks'\n complete -c x.py -n \"__fish_use_subcommand\" -f -a \"clean\" -d 'Clean out build directories'\n-complete -c x.py -n \"__fish_use_subcommand\" -f -a \"dist\" -d 'Duild distribution artifacts'\n+complete -c x.py -n \"__fish_use_subcommand\" -f -a \"dist\" -d 'Build distribution artifacts'\n complete -c x.py -n \"__fish_use_subcommand\" -f -a \"install\" -d 'Install distribution artifacts'\n complete -c x.py -n \"__fish_use_subcommand\" -f -a \"run\" -d 'Run tools contained in this repository'\n complete -c x.py -n \"__fish_use_subcommand\" -f -a \"setup\" -d 'Set up the environment for development'"}, {"sha": "59fabf53f984bd34790625d8bedd54ca89e50a8e", "filename": "src/etc/completions/x.py.ps1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fetc%2Fcompletions%2Fx.py.ps1", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Fetc%2Fcompletions%2Fx.py.ps1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcompletions%2Fx.py.ps1?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -63,7 +63,7 @@ Register-ArgumentCompleter -Native -CommandName 'x.py' -ScriptBlock {\n             [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'Build and run some test suites')\n             [CompletionResult]::new('bench', 'bench', [CompletionResultType]::ParameterValue, 'Build and run some benchmarks')\n             [CompletionResult]::new('clean', 'clean', [CompletionResultType]::ParameterValue, 'Clean out build directories')\n-            [CompletionResult]::new('dist', 'dist', [CompletionResultType]::ParameterValue, 'Duild distribution artifacts')\n+            [CompletionResult]::new('dist', 'dist', [CompletionResultType]::ParameterValue, 'Build distribution artifacts')\n             [CompletionResult]::new('install', 'install', [CompletionResultType]::ParameterValue, 'Install distribution artifacts')\n             [CompletionResult]::new('run', 'run', [CompletionResultType]::ParameterValue, 'Run tools contained in this repository')\n             [CompletionResult]::new('setup', 'setup', [CompletionResultType]::ParameterValue, 'Set up the environment for development')"}, {"sha": "09e7ed293d473d81e5e9407dff7f0f6449fa0673", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -551,7 +551,15 @@ impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n }\n \n fn check_if_allowed_tag(t: &Tag<'_>) -> bool {\n-    matches!(t, Tag::Paragraph | Tag::Emphasis | Tag::Strong | Tag::Link(..) | Tag::BlockQuote)\n+    matches!(\n+        t,\n+        Tag::Paragraph\n+            | Tag::Emphasis\n+            | Tag::Strong\n+            | Tag::Strikethrough\n+            | Tag::Link(..)\n+            | Tag::BlockQuote\n+    )\n }\n \n fn is_forbidden_tag(t: &Tag<'_>) -> bool {\n@@ -773,7 +781,7 @@ impl<'tcx> ExtraInfo<'tcx> {\n         ExtraInfo { def_id, sp, tcx }\n     }\n \n-    fn error_invalid_codeblock_attr(&self, msg: &str, help: &str) {\n+    fn error_invalid_codeblock_attr(&self, msg: String, help: &str) {\n         if let Some(def_id) = self.def_id.as_local() {\n             self.tcx.struct_span_lint_hir(\n                 crate::lint::INVALID_CODEBLOCK_ATTRIBUTES,\n@@ -948,7 +956,7 @@ impl LangString {\n                     } {\n                         if let Some(extra) = extra {\n                             extra.error_invalid_codeblock_attr(\n-                                &format!(\"unknown attribute `{}`. Did you mean `{}`?\", x, flag),\n+                                format!(\"unknown attribute `{}`. Did you mean `{}`?\", x, flag),\n                                 help,\n                             );\n                         }"}, {"sha": "0a56916edcd9c1eb99a7b13be026312e2d5671fa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -192,11 +192,11 @@ fn init_logging() {\n         Ok(\"auto\") | Err(VarError::NotPresent) => io::stdout().is_terminal(),\n         Ok(value) => early_error(\n             ErrorOutputType::default(),\n-            &format!(\"invalid log color value '{}': expected one of always, never, or auto\", value),\n+            format!(\"invalid log color value '{}': expected one of always, never, or auto\", value),\n         ),\n         Err(VarError::NotUnicode(value)) => early_error(\n             ErrorOutputType::default(),\n-            &format!(\n+            format!(\n                 \"invalid log color value '{}': expected one of always, never, or auto\",\n                 value.to_string_lossy()\n             ),\n@@ -228,7 +228,7 @@ fn get_args() -> Option<Vec<String>> {\n                 .map_err(|arg| {\n                     early_warn(\n                         ErrorOutputType::default(),\n-                        &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg),\n+                        format!(\"Argument {} is not valid Unicode: {:?}\", i, arg),\n                     );\n                 })\n                 .ok()\n@@ -721,7 +721,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n     let matches = match options.parse(&args[1..]) {\n         Ok(m) => m,\n         Err(err) => {\n-            early_error(ErrorOutputType::default(), &err.to_string());\n+            early_error(ErrorOutputType::default(), err.to_string());\n         }\n     };\n "}, {"sha": "9381b3e0567a5c47df705a6b30b7dcbe6cc2a6a4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::{\n     fx::{FxHashMap, FxHashSet},\n     intern::Interned,\n };\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticMessage};\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n@@ -24,6 +24,7 @@ use rustc_span::BytePos;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n+use std::fmt::Display;\n use std::mem;\n use std::ops::Range;\n \n@@ -841,7 +842,7 @@ impl PreprocessingError {\n         match self {\n             PreprocessingError::MultipleAnchors => report_multiple_anchors(cx, diag_info),\n             PreprocessingError::Disambiguator(range, msg) => {\n-                disambiguator_error(cx, diag_info, range.clone(), msg)\n+                disambiguator_error(cx, diag_info, range.clone(), msg.as_str())\n             }\n             PreprocessingError::MalformedGenerics(err, path_str) => {\n                 report_malformed_generics(cx, diag_info, *err, path_str)\n@@ -1185,7 +1186,7 @@ impl LinkCollector<'_, '_> {\n             }\n             suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n         };\n-        report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, callback);\n+        report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, callback);\n     }\n \n     fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n@@ -1581,7 +1582,7 @@ impl Suggestion {\n fn report_diagnostic(\n     tcx: TyCtxt<'_>,\n     lint: &'static Lint,\n-    msg: &str,\n+    msg: impl Into<DiagnosticMessage> + Display,\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n     decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n ) {\n@@ -1649,7 +1650,7 @@ fn resolution_failure(\n     report_diagnostic(\n         tcx,\n         BROKEN_INTRA_DOC_LINKS,\n-        &format!(\"unresolved link to `{}`\", path_str),\n+        format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n         |diag, sp| {\n             let item = |res: Res| format!(\"the {} `{}`\", res.descr(), res.name(tcx),);\n@@ -1865,20 +1866,20 @@ fn resolution_failure(\n \n fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n     let msg = format!(\"`{}` contains multiple anchors\", diag_info.ori_link);\n-    anchor_failure(cx, diag_info, &msg, 1)\n+    anchor_failure(cx, diag_info, msg, 1)\n }\n \n fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, def_id: DefId) {\n     let (link, kind) = (diag_info.ori_link, Res::from_def_id(cx.tcx, def_id).descr());\n     let msg = format!(\"`{link}` contains an anchor, but links to {kind}s are already anchored\");\n-    anchor_failure(cx, diag_info, &msg, 0)\n+    anchor_failure(cx, diag_info, msg, 0)\n }\n \n /// Report an anchor failure.\n fn anchor_failure(\n     cx: &DocContext<'_>,\n     diag_info: DiagnosticInfo<'_>,\n-    msg: &str,\n+    msg: String,\n     anchor_idx: usize,\n ) {\n     report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp| {\n@@ -1898,7 +1899,7 @@ fn disambiguator_error(\n     cx: &DocContext<'_>,\n     mut diag_info: DiagnosticInfo<'_>,\n     disambiguator_range: Range<usize>,\n-    msg: &str,\n+    msg: impl Into<DiagnosticMessage> + Display,\n ) {\n     diag_info.link_range = disambiguator_range;\n     report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp| {\n@@ -1919,7 +1920,7 @@ fn report_malformed_generics(\n     report_diagnostic(\n         cx.tcx,\n         BROKEN_INTRA_DOC_LINKS,\n-        &format!(\"unresolved link to `{}`\", path_str),\n+        format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n         |diag, sp| {\n             let note = match err {\n@@ -1994,7 +1995,7 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n@@ -2046,7 +2047,7 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, &msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "a9d42159c4bac5c70d8dbe79a211360fa006cf44", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -39,7 +39,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Install toolchain\n       run: rustup show active-toolchain"}, {"sha": "30a156c925b07a6b435aeca9a788f63e12eddbde", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -27,7 +27,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n       with:\n         ref: ${{ github.ref }}\n \n@@ -83,7 +83,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -149,7 +149,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -173,7 +173,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -233,7 +233,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Install toolchain\n       run: rustup show active-toolchain"}, {"sha": "514706d64c8c0db45ec754bbaa6c983457bcad91", "filename": "src/tools/clippy/.github/workflows/clippy_dev.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -25,7 +25,7 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     # Run\n     - name: Build"}, {"sha": "f42928c2cd1169c13c76651111297393e223c5ef", "filename": "src/tools/clippy/.github/workflows/deploy.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fdeploy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fdeploy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fdeploy.yml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -21,10 +21,10 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n       with:\n         ref: ${{ env.TARGET_BRANCH }}\n         path: 'out'"}, {"sha": "7d25b6a2b79e77303324b0e4e45259a7c55bba07", "filename": "src/tools/clippy/.github/workflows/remark.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -16,10 +16,10 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v3.0.2\n+      uses: actions/checkout@v3\n \n     - name: Setup Node.js\n-      uses: actions/setup-node@v1.4.4\n+      uses: actions/setup-node@v3\n       with:\n         node-version: '14.x'\n "}, {"sha": "79f2a47110b9e6cf9494aaeeba1d07cd25ca6ea6", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -4620,6 +4620,7 @@ Released 2018-09-13\n [`else_if_without_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#else_if_without_else\n [`empty_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_drop\n [`empty_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_enum\n+[`empty_line_after_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_doc_comments\n [`empty_line_after_outer_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_outer_attr\n [`empty_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_loop\n [`empty_structs_with_brackets`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_structs_with_brackets\n@@ -4785,6 +4786,7 @@ Released 2018-09-13\n [`manual_main_separator_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_main_separator_str\n [`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n+[`manual_next_back`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_next_back\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n@@ -4897,6 +4899,7 @@ Released 2018-09-13\n [`no_effect_underscore_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect_underscore_binding\n [`no_mangle_with_rust_abi`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_mangle_with_rust_abi\n [`non_ascii_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_ascii_literal\n+[`non_minimal_cfg`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_minimal_cfg\n [`non_octal_unix_permissions`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_octal_unix_permissions\n [`non_send_fields_in_send_ty`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_send_fields_in_send_ty\n [`nonminimal_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonminimal_bool\n@@ -4978,6 +4981,7 @@ Released 2018-09-13\n [`ref_binding_to_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_binding_to_reference\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n+[`ref_patterns`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_patterns\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n [`repeat_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#repeat_once\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts"}, {"sha": "d712d3e675074131cb5abe470b2d547c6acaf6c5", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -278,7 +278,7 @@ If you want to contribute to Clippy, you can find more information in [CONTRIBUT\n \n <!-- REUSE-IgnoreStart -->\n \n-Copyright 2014-2022 The Rust Project Developers\n+Copyright 2014-2023 The Rust Project Developers\n \n Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n [https://www.apache.org/licenses/LICENSE-2.0](https://www.apache.org/licenses/LICENSE-2.0)> or the MIT license"}, {"sha": "d7c2775b89690383552bdd82031655d52e567029", "filename": "src/tools/clippy/book/src/development/type_checking.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Ftype_checking.md", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Ftype_checking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Ftype_checking.md?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -133,7 +133,7 @@ in this chapter:\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n-[Adt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Adt\n+[Adt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/sty/enum.TyKind.html#variant.Adt\n [AdtDef]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adt/struct.AdtDef.html\n [expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n [node_type]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.node_type\n@@ -142,9 +142,9 @@ in this chapter:\n [kind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.kind\n [LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n [LateLintPass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n-[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n+[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/typeck_results/struct.TypeckResults.html#method.pat_ty\n [Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n-[TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n+[TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/sty/enum.TyKind.html\n [TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n [middle_ty]: https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/ty/struct.Ty.html\n [hir_ty]: https://doc.rust-lang.org/beta/nightly-rustc/rustc_hir/struct.Ty.html"}, {"sha": "98e69c7fd264a1656dc8aceed060cd9a75ec1b18", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -17,7 +17,7 @@ if_chain = \"1.0\"\n itertools = \"0.10.1\"\n pulldown-cmark = { version = \"0.9\", default-features = false }\n quine-mc_cluskey = \"0.2\"\n-regex-syntax = \"0.6\"\n+regex-syntax = \"0.7\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", optional = true }\n tempfile = { version = \"3.2\", optional = true }"}, {"sha": "a8dc0cb3b58150c9458ff2701fda4d2ae89f033c", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n             _ => return,\n         };\n         let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn) else { return };\n-        let Some((Constant::Bool(val), _)) = constant(cx, cx.typeck_results(), condition) else { return };\n+        let Some(Constant::Bool(val)) = constant(cx, cx.typeck_results(), condition) else { return };\n         if val {\n             span_lint_and_help(\n                 cx,"}, {"sha": "897495ba1087473fb538394426282f5c8d99065b", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 136, "deletions": 8, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -176,6 +176,52 @@ declare_clippy_lint! {\n     \"empty line after outer attribute\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for empty lines after documenation comments.\n+    ///\n+    /// ### Why is this bad?\n+    /// The documentation comment was most likely meant to be an inner attribute or regular comment.\n+    /// If it was intended to be a documentation comment, then the empty line should be removed to\n+    /// be more idiomatic.\n+    ///\n+    /// ### Known problems\n+    /// Only detects empty lines immediately following the documentation. If the doc comment is followed\n+    /// by an attribute and then an empty line, this lint will not trigger. Use `empty_line_after_outer_attr`\n+    /// in combination with this lint to detect both cases.\n+    ///\n+    /// Does not detect empty lines after doc attributes (e.g. `#[doc = \"\"]`).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// /// Some doc comment with a blank line after it.\n+    ///\n+    /// fn not_quite_good_code() { }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// /// Good (no blank line)\n+    /// fn this_is_fine() { }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// // Good (convert to a regular comment)\n+    ///\n+    /// fn this_is_fine_too() { }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// //! Good (convert to a comment on an inner attribute)\n+    ///\n+    /// fn this_is_fine_as_well() { }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub EMPTY_LINE_AFTER_DOC_COMMENTS,\n+    nursery,\n+    \"empty line after documentation comments\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n@@ -292,6 +338,30 @@ declare_clippy_lint! {\n     \"ensures that all `allow` and `expect` attributes have a reason\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `any` and `all` combinators in `cfg` with only one condition.\n+    ///\n+    /// ### Why is this bad?\n+    /// If there is only one condition, no need to wrap it into `any` or `all` combinators.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// #[cfg(any(unix))]\n+    /// pub struct Bar;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// #[cfg(unix)]\n+    /// pub struct Bar;\n+    /// ```\n+    #[clippy::version = \"1.71.0\"]\n+    pub NON_MINIMAL_CFG,\n+    style,\n+    \"ensure that all `cfg(any())` and `cfg(all())` have more than one condition\"\n+}\n+\n declare_lint_pass!(Attributes => [\n     ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     INLINE_ALWAYS,\n@@ -604,6 +674,8 @@ impl_lint_pass!(EarlyAttributes => [\n     DEPRECATED_CFG_ATTR,\n     MISMATCHED_TARGET_OS,\n     EMPTY_LINE_AFTER_OUTER_ATTR,\n+    EMPTY_LINE_AFTER_DOC_COMMENTS,\n+    NON_MINIMAL_CFG,\n ]);\n \n impl EarlyLintPass for EarlyAttributes {\n@@ -614,15 +686,22 @@ impl EarlyLintPass for EarlyAttributes {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n         check_deprecated_cfg_attr(cx, attr, &self.msrv);\n         check_mismatched_target_os(cx, attr);\n+        check_minimal_cfg_condition(cx, attr);\n     }\n \n     extract_msrv_attr!(EarlyContext);\n }\n \n+/// Check for empty lines after outer attributes.\n+///\n+/// Attributes and documenation comments are both considered outer attributes\n+/// by the AST. However, the average user likely considers them to be different.\n+/// Checking for empty lines after each of these attributes is split into two different\n+/// lints but can share the same logic.\n fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::Item) {\n     let mut iter = item.attrs.iter().peekable();\n     while let Some(attr) = iter.next() {\n-        if matches!(attr.kind, AttrKind::Normal(..))\n+        if (matches!(attr.kind, AttrKind::Normal(..)) || matches!(attr.kind, AttrKind::DocComment(..)))\n             && attr.style == AttrStyle::Outer\n             && is_present_in_source(cx, attr.span)\n         {\n@@ -639,13 +718,20 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n                 let lines = without_block_comments(lines);\n \n                 if lines.iter().filter(|l| l.trim().is_empty()).count() > 2 {\n-                    span_lint(\n-                        cx,\n-                        EMPTY_LINE_AFTER_OUTER_ATTR,\n-                        begin_of_attr_to_item,\n-                        \"found an empty line after an outer attribute. \\\n-                        Perhaps you forgot to add a `!` to make it an inner attribute?\",\n-                    );\n+                    let (lint_msg, lint_type) = match attr.kind {\n+                        AttrKind::DocComment(..) => (\n+                            \"found an empty line after a doc comment. \\\n+                            Perhaps you need to use `//!` to make a comment on a module, remove the empty line, or make a regular comment with `//`?\",\n+                            EMPTY_LINE_AFTER_DOC_COMMENTS,\n+                        ),\n+                        AttrKind::Normal(..) => (\n+                            \"found an empty line after an outer attribute. \\\n+                            Perhaps you forgot to add a `!` to make it an inner attribute?\",\n+                            EMPTY_LINE_AFTER_OUTER_ATTR,\n+                        ),\n+                    };\n+\n+                    span_lint(cx, lint_type, begin_of_attr_to_item, lint_msg);\n                 }\n             }\n         }\n@@ -690,6 +776,48 @@ fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute, msrv: &Msr\n     }\n }\n \n+fn check_nested_cfg(cx: &EarlyContext<'_>, items: &[NestedMetaItem]) {\n+    for item in items.iter() {\n+        if let NestedMetaItem::MetaItem(meta) = item {\n+            if !meta.has_name(sym::any) && !meta.has_name(sym::all) {\n+                continue;\n+            }\n+            if let MetaItemKind::List(list) = &meta.kind {\n+                check_nested_cfg(cx, list);\n+                if list.len() == 1 {\n+                    span_lint_and_then(\n+                        cx,\n+                        NON_MINIMAL_CFG,\n+                        meta.span,\n+                        \"unneeded sub `cfg` when there is only one condition\",\n+                        |diag| {\n+                            if let Some(snippet) = snippet_opt(cx, list[0].span()) {\n+                                diag.span_suggestion(meta.span, \"try\", snippet, Applicability::MaybeIncorrect);\n+                            }\n+                        },\n+                    );\n+                } else if list.is_empty() && meta.has_name(sym::all) {\n+                    span_lint_and_then(\n+                        cx,\n+                        NON_MINIMAL_CFG,\n+                        meta.span,\n+                        \"unneeded sub `cfg` when there is no condition\",\n+                        |_| {},\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_minimal_cfg_condition(cx: &EarlyContext<'_>, attr: &Attribute) {\n+    if attr.has_name(sym::cfg) &&\n+        let Some(items) = attr.meta_item_list()\n+    {\n+        check_nested_cfg(cx, &items);\n+    }\n+}\n+\n fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n     fn find_os(name: &str) -> Option<&'static str> {\n         UNIX_SYSTEMS"}, {"sha": "814108ed8a7c2b1ef60c4e9888b7dc26ebae757d", "filename": "src/tools/clippy/clippy_lints/src/borrow_deref_ref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_deref_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_deref_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_deref_ref.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,5 +1,6 @@\n use crate::reference::DEREF_ADDROF;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_from_proc_macro;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{get_parent_expr, is_lint_allowed};\n@@ -47,8 +48,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BorrowDerefRef => [BORROW_DEREF_REF]);\n \n-impl LateLintPass<'_> for BorrowDerefRef {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &rustc_hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for BorrowDerefRef {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &rustc_hir::Expr<'tcx>) {\n         if_chain! {\n             if !e.span.from_expansion();\n             if let ExprKind::AddrOf(_, Mutability::Not, addrof_target) = e.kind;\n@@ -58,6 +59,7 @@ impl LateLintPass<'_> for BorrowDerefRef {\n             if !matches!(deref_target.kind, ExprKind::Unary(UnOp::Deref, ..) );\n             let ref_ty = cx.typeck_results().expr_ty(deref_target);\n             if let ty::Ref(_, inner_ty, Mutability::Not) = ref_ty.kind();\n+            if !is_from_proc_macro(cx, e);\n             then{\n \n                 if let Some(parent_expr) = get_parent_expr(cx, e){"}, {"sha": "e42c3fe24325694e8e75d5ac77086084f563e9db", "filename": "src/tools/clippy/clippy_lints/src/box_default.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbox_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbox_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbox_default.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -8,7 +8,9 @@ use rustc_hir::{\n     Block, Expr, ExprKind, Local, Node, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::{lint::in_external_macro, ty::print::with_forced_trimmed_paths};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::print::with_forced_trimmed_paths;\n+use rustc_middle::ty::IsSuggestable;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n \n@@ -49,7 +51,6 @@ impl LateLintPass<'_> for BoxDefault {\n             && path_def_id(cx, ty).map_or(false, |id| Some(id) == cx.tcx.lang_items().owned_box())\n             && is_default_equivalent(cx, arg)\n         {\n-            let arg_ty = cx.typeck_results().expr_ty(arg);\n             span_lint_and_sugg(\n                 cx,\n                 BOX_DEFAULT,\n@@ -58,8 +59,10 @@ impl LateLintPass<'_> for BoxDefault {\n                 \"try\",\n                 if is_plain_default(arg_path) || given_type(cx, expr) {\n                     \"Box::default()\".into()\n-                } else {\n+                } else if let Some(arg_ty) = cx.typeck_results().expr_ty(arg).make_suggestable(cx.tcx, true) {\n                     with_forced_trimmed_paths!(format!(\"Box::<{arg_ty}>::default()\"))\n+                } else {\n+                    return\n                 },\n                 Applicability::MachineApplicable\n             );"}, {"sha": "da756129db3ae34ed85720ee79b55109e922f7c3", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_nan_to_int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -21,8 +21,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n \n fn is_known_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     match constant(cx, cx.typeck_results(), e) {\n-        Some((Constant::F64(n), _)) => n.is_nan(),\n-        Some((Constant::F32(n), _)) => n.is_nan(),\n+        Some(Constant::F64(n)) => n.is_nan(),\n+        Some(Constant::F32(n)) => n.is_nan(),\n         _ => false,\n     }\n }"}, {"sha": "84b99ad5c243dd42ce19837b7cbd073774234c98", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -15,7 +15,7 @@ use rustc_target::abi::IntegerType;\n use super::{utils, CAST_ENUM_TRUNCATION, CAST_POSSIBLE_TRUNCATION};\n \n fn constant_int(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n-    if let Some((Constant::Int(c), _)) = constant(cx, cx.typeck_results(), expr) {\n+    if let Some(Constant::Int(c)) = constant(cx, cx.typeck_results(), expr) {\n         Some(c)\n     } else {\n         None"}, {"sha": "a83dfd94dc2268b9727a3d6dea33c1570562de97", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -29,7 +29,7 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             // Don't lint for positive constants.\n             let const_val = constant(cx, cx.typeck_results(), cast_op);\n             if_chain! {\n-                if let Some((Constant::Int(n), _)) = const_val;\n+                if let Some(Constant::Int(n)) = const_val;\n                 if let ty::Int(ity) = *cast_from.kind();\n                 if sext(cx.tcx, n, ity) >= 0;\n                 then {"}, {"sha": "ea17e7a6071046349a56dbc8a4dabf253f2da95e", "filename": "src/tools/clippy/clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -3,10 +3,10 @@ use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_in_cfg_test, is_in_test_function};\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{Expr, ExprKind, Node};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::sym;\n+use rustc_span::{sym, BytePos, Pos, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -31,6 +31,31 @@ declare_clippy_lint! {\n     \"`dbg!` macro is intended as a debugging tool\"\n }\n \n+/// Gets the span of the statement up to the next semicolon, if and only if the next\n+/// non-whitespace character actually is a semicolon.\n+/// E.g.\n+/// ```rust,ignore\n+/// \n+///    dbg!();\n+///    ^^^^^^^  this span is returned\n+///\n+///   foo!(dbg!());\n+///             no span is returned\n+/// ```\n+fn span_including_semi(cx: &LateContext<'_>, span: Span) -> Option<Span> {\n+    let sm = cx.sess().source_map();\n+    let sf = sm.lookup_source_file(span.hi());\n+    let src = sf.src.as_ref()?.get(span.hi().to_usize()..)?;\n+    let first_non_whitespace = src.find(|c: char| !c.is_whitespace())?;\n+\n+    if src.as_bytes()[first_non_whitespace] == b';' {\n+        let hi = span.hi() + BytePos::from_usize(first_non_whitespace + 1);\n+        Some(span.with_hi(hi))\n+    } else {\n+        None\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub struct DbgMacro {\n     allow_dbg_in_tests: bool,\n@@ -55,13 +80,25 @@ impl LateLintPass<'_> for DbgMacro {\n                 return;\n             }\n             let mut applicability = Applicability::MachineApplicable;\n-            let suggestion = match expr.peel_drop_temps().kind {\n+\n+            let (sugg_span, suggestion) = match expr.peel_drop_temps().kind {\n                 // dbg!()\n-                ExprKind::Block(_, _) => String::new(),\n-                // dbg!(1)\n-                ExprKind::Match(val, ..) => {\n-                    snippet_with_applicability(cx, val.span.source_callsite(), \"..\", &mut applicability).to_string()\n+                ExprKind::Block(..) => {\n+                    // If the `dbg!` macro is a \"free\" statement and not contained within other expressions,\n+                    // remove the whole statement.\n+                    if let Some(Node::Stmt(stmt)) = cx.tcx.hir().find_parent(expr.hir_id)\n+                        && let Some(span) = span_including_semi(cx, stmt.span.source_callsite())\n+                    {\n+                        (span, String::new())\n+                    } else {\n+                        (macro_call.span, String::from(\"()\"))\n+                    }\n                 },\n+                // dbg!(1)\n+                ExprKind::Match(val, ..) => (\n+                    macro_call.span,\n+                    snippet_with_applicability(cx, val.span.source_callsite(), \"..\", &mut applicability).to_string(),\n+                ),\n                 // dbg!(2, 3)\n                 ExprKind::Tup(\n                     [\n@@ -82,15 +119,15 @@ impl LateLintPass<'_> for DbgMacro {\n                         \"..\",\n                         &mut applicability,\n                     );\n-                    format!(\"({snippet})\")\n+                    (macro_call.span, format!(\"({snippet})\"))\n                 },\n                 _ => return,\n             };\n \n             span_lint_and_sugg(\n                 cx,\n                 DBG_MACRO,\n-                macro_call.span,\n+                sugg_span,\n                 \"the `dbg!` macro is intended as a debugging tool\",\n                 \"remove the invocation before committing it to a version control system\",\n                 suggestion,"}, {"sha": "423eee47742e00d9057d341befe1f0c730a8a605", "filename": "src/tools/clippy/clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -48,9 +48,11 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::attrs::BLANKET_CLIPPY_RESTRICTION_LINTS_INFO,\n     crate::attrs::DEPRECATED_CFG_ATTR_INFO,\n     crate::attrs::DEPRECATED_SEMVER_INFO,\n+    crate::attrs::EMPTY_LINE_AFTER_DOC_COMMENTS_INFO,\n     crate::attrs::EMPTY_LINE_AFTER_OUTER_ATTR_INFO,\n     crate::attrs::INLINE_ALWAYS_INFO,\n     crate::attrs::MISMATCHED_TARGET_OS_INFO,\n+    crate::attrs::NON_MINIMAL_CFG_INFO,\n     crate::attrs::USELESS_ATTRIBUTE_INFO,\n     crate::await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE_INFO,\n     crate::await_holding_invalid::AWAIT_HOLDING_LOCK_INFO,\n@@ -347,6 +349,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::methods::ITER_WITH_DRAIN_INFO,\n     crate::methods::MANUAL_FILTER_MAP_INFO,\n     crate::methods::MANUAL_FIND_MAP_INFO,\n+    crate::methods::MANUAL_NEXT_BACK_INFO,\n     crate::methods::MANUAL_OK_OR_INFO,\n     crate::methods::MANUAL_SATURATING_ARITHMETIC_INFO,\n     crate::methods::MANUAL_SPLIT_ONCE_INFO,\n@@ -485,7 +488,6 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::operators::FLOAT_EQUALITY_WITHOUT_ABS_INFO,\n     crate::operators::IDENTITY_OP_INFO,\n     crate::operators::INEFFECTIVE_BIT_MASK_INFO,\n-    crate::operators::INTEGER_ARITHMETIC_INFO,\n     crate::operators::INTEGER_DIVISION_INFO,\n     crate::operators::MISREFACTORED_ASSIGN_OP_INFO,\n     crate::operators::MODULO_ARITHMETIC_INFO,\n@@ -535,6 +537,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::redundant_slicing::REDUNDANT_SLICING_INFO,\n     crate::redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES_INFO,\n     crate::ref_option_ref::REF_OPTION_REF_INFO,\n+    crate::ref_patterns::REF_PATTERNS_INFO,\n     crate::reference::DEREF_ADDROF_INFO,\n     crate::regex::INVALID_REGEX_INFO,\n     crate::regex::TRIVIAL_REGEX_INFO,"}, {"sha": "9bd7a0dc0f3b88f01abbbeba191239051ecedde4", "filename": "src/tools/clippy/clippy_lints/src/default_constructed_unit_structs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_constructed_unit_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_constructed_unit_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_constructed_unit_structs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, is_from_proc_macro, match_def_path, paths};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, match_def_path, paths};\n use hir::{def::Res, ExprKind};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -55,7 +55,8 @@ impl LateLintPass<'_> for DefaultConstructedUnitStructs {\n             if let ty::Adt(def, ..) = cx.typeck_results().expr_ty(expr).kind();\n             if def.is_struct();\n             if let var @ ty::VariantDef { ctor: Some((hir::def::CtorKind::Const, _)), .. } = def.non_enum_variant();\n-            if !var.is_field_list_non_exhaustive() && !is_from_proc_macro(cx, expr);\n+            if !var.is_field_list_non_exhaustive();\n+            if !expr.span.from_expansion() && !qpath.span().from_expansion();\n             then {\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "9c60edb179415b62140008d8f9f60e4347d1fc4d", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n             let is_copy = is_copy(cx, arg_ty);\n             let drop_is_single_call_in_arm = is_single_call_in_arm(cx, arg, expr);\n             let (lint, msg) = match fn_name {\n-                // early return for uplifted lints: drop_ref, drop_copy, forget_ref, forget_copy\n+                // early return for uplifted lints: dropping_references, dropping_copy_types, forgetting_references, forgetting_copy_types\n                 sym::mem_drop if arg_ty.is_ref() && !drop_is_single_call_in_arm => return,\n                 sym::mem_forget if arg_ty.is_ref() => return,\n                 sym::mem_drop if is_copy && !drop_is_single_call_in_arm => return,"}, {"sha": "3c55a563af455e9b5ea96ca42e2ffb49edd1174f", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -114,7 +114,7 @@ declare_lint_pass!(FloatingPointArithmetic => [\n // Returns the specialized log method for a given base if base is constant\n // and is one of 2, 10 and e\n fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), base) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), base) {\n         if F32(2.0) == value || F64(2.0) == value {\n             return Some(\"log2\");\n         } else if F32(10.0) == value || F64(10.0) == value {\n@@ -193,8 +193,8 @@ fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n             constant(cx, cx.typeck_results(), lhs),\n             constant(cx, cx.typeck_results(), rhs),\n         ) {\n-            (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n-            (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n+            (Some(value), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n+            (_, Some(value)) if F32(1.0) == value || F64(1.0) == value => lhs,\n             _ => return,\n         };\n \n@@ -237,7 +237,7 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n \n fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), receiver) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), receiver) {\n         if let Some(method) = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             Some(\"exp\")\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -258,7 +258,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), &args[0]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n@@ -298,7 +298,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args:\n }\n \n fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), &args[0]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n@@ -384,8 +384,8 @@ fn detect_hypot(cx: &LateContext<'_>, receiver: &Expr<'_>) -> Option<String> {\n                 _\n             ) = &add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n-            if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), largs_1);\n-            if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), rargs_1);\n+            if let Some(lvalue) = constant(cx, cx.typeck_results(), largs_1);\n+            if let Some(rvalue) = constant(cx, cx.typeck_results(), rargs_1);\n             if Int(2) == lvalue && Int(2) == rvalue;\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, largs_0, \"..\").maybe_par(), Sugg::hir(cx, rargs_0, \"..\")));\n@@ -416,7 +416,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, lhs, rhs) = expr.kind;\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n-        if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n+        if let Some(value) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n         if let ExprKind::MethodCall(path, self_arg, ..) = &lhs.kind;\n         if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n@@ -669,8 +669,8 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             mul_lhs,\n             mul_rhs,\n         ) = &div_lhs.kind;\n-        if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), div_rhs);\n-        if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), mul_rhs);\n+        if let Some(rvalue) = constant(cx, cx.typeck_results(), div_rhs);\n+        if let Some(lvalue) = constant(cx, cx.typeck_results(), mul_rhs);\n         then {\n             // TODO: also check for constant values near PI/180 or 180/PI\n             if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&"}, {"sha": "521045a9fed8fb0f53dfd27253e70164aba508cf", "filename": "src/tools/clippy/clippy_lints/src/fn_null_check.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffn_null_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffn_null_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffn_null_check.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -89,11 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for FnNullCheck {\n \n                     // Catching:\n                     // (fn_ptr as *<const/mut> <ty>) == <const that evaluates to null_ptr>\n-                    _ if matches!(\n-                        constant(cx, cx.typeck_results(), to_check),\n-                        Some((Constant::RawPtr(0), _))\n-                    ) =>\n-                    {\n+                    _ if matches!(constant(cx, cx.typeck_results(), to_check), Some(Constant::RawPtr(0))) => {\n                         lint_expr(cx, expr);\n                     },\n "}, {"sha": "ee7973b82ab9708860f6bbec696fb39141a99e2e", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -101,10 +101,10 @@ fn get_int_max(ty: Ty<'_>) -> Option<u128> {\n fn get_const<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<(u128, BinOpKind, &'tcx Expr<'tcx>)> {\n     if let ExprKind::Binary(op, l, r) = expr.kind {\n         let tr = cx.typeck_results();\n-        if let Some((Constant::Int(c), _)) = constant(cx, tr, r) {\n+        if let Some(Constant::Int(c)) = constant(cx, tr, r) {\n             return Some((c, op.node, l));\n         };\n-        if let Some((Constant::Int(c), _)) = constant(cx, tr, l) {\n+        if let Some(Constant::Int(c)) = constant(cx, tr, l) {\n             return Some((c, invert_op(op.node)?, r));\n         }\n     }"}, {"sha": "7a269e98ff13b8674bfb11069bed70568202a911", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SliceIndexLintingVisitor<'a, 'tcx> {\n                 let parent_id = map.parent_id(expr.hir_id);\n                 if let Some(hir::Node::Expr(parent_expr)) = map.find(parent_id);\n                 if let hir::ExprKind::Index(_, index_expr) = parent_expr.kind;\n-                if let Some((Constant::Int(index_value), _)) = constant(cx, cx.typeck_results(), index_expr);\n+                if let Some(Constant::Int(index_value)) = constant(cx, cx.typeck_results(), index_expr);\n                 if let Ok(index_value) = index_value.try_into();\n                 if index_value < max_suggested_slice;\n "}, {"sha": "22c14d9b04dd13d4df26776c14633deeb4b9fa0d", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -191,18 +191,14 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n /// Returns a tuple of options with the start and end (exclusive) values of\n /// the range. If the start or end is not constant, None is returned.\n fn to_const_range(cx: &LateContext<'_>, range: higher::Range<'_>, array_size: u128) -> (Option<u128>, Option<u128>) {\n-    let s = range\n-        .start\n-        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n+    let s = range.start.map(|expr| constant(cx, cx.typeck_results(), expr));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => Some(x),\n         Some(_) => None,\n         None => Some(0),\n     };\n \n-    let e = range\n-        .end\n-        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n+    let e = range.end.map(|expr| constant(cx, cx.typeck_results(), expr));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => {\n             if range.limits == RangeLimits::Closed {"}, {"sha": "e661418092080f015e13189ca0494c956e470c0e", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,10 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_from_proc_macro;\n use clippy_utils::ty::{implements_trait, is_must_use_ty, match_type};\n use clippy_utils::{is_must_use_func_call, paths};\n-use rustc_hir::{ExprKind, Local, PatKind};\n+use rustc_hir::{Local, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::IsSuggestable;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{BytePos, Span};\n \n@@ -138,7 +140,7 @@ const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n ];\n \n impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n-    fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &Local<'tcx>) {\n         if !in_external_macro(cx.tcx.sess, local.span)\n             && let PatKind::Wild = local.pat.kind\n             && let Some(init) = local.init\n@@ -191,15 +193,17 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n             if local.pat.default_binding_modes && local.ty.is_none() {\n                 // When `default_binding_modes` is true, the `let` keyword is present.\n \n-\t\t\t\t// Ignore function calls that return impl traits...\n-\t\t\t\tif let Some(init) = local.init &&\n-\t\t\t\tmatches!(init.kind, ExprKind::Call(_, _) | ExprKind::MethodCall(_, _, _, _)) {\n-\t\t\t\t\tlet expr_ty = cx.typeck_results().expr_ty(init);\n-\t\t\t\t\tif expr_ty.is_impl_trait() {\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n+                // Ignore unnameable types\n+                if let Some(init) = local.init\n+                    && !cx.typeck_results().expr_ty(init).is_suggestable(cx.tcx, true)\n+                {\n+                    return;\n+                }\n \n+                // Ignore if it is from a procedural macro...\n+                if is_from_proc_macro(cx, init) {\n+                    return;\n+                }\n \n \t\t\t\tspan_lint_and_help(\n                     cx,"}, {"sha": "b442a4ac5f611065c4c8e8f227fb9559d2bd5d43", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -266,6 +266,7 @@ mod redundant_pub_crate;\n mod redundant_slicing;\n mod redundant_static_lifetimes;\n mod ref_option_ref;\n+mod ref_patterns;\n mod reference;\n mod regex;\n mod return_self_not_must_use;\n@@ -331,8 +332,11 @@ mod zero_div_zero;\n mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n-use crate::utils::conf::{format_error, TryConf};\n pub use crate::utils::conf::{lookup_conf_file, Conf};\n+use crate::utils::{\n+    conf::{format_error, metadata::get_configuration_metadata, TryConf},\n+    FindAll,\n+};\n \n /// Register all pre expansion lints\n ///\n@@ -471,7 +475,22 @@ pub(crate) struct LintInfo {\n pub fn explain(name: &str) {\n     let target = format!(\"clippy::{}\", name.to_ascii_uppercase());\n     match declared_lints::LINTS.iter().find(|info| info.lint.name == target) {\n-        Some(info) => print!(\"{}\", info.explanation),\n+        Some(info) => {\n+            println!(\"{}\", info.explanation);\n+            // Check if the lint has configuration\n+            let mdconf = get_configuration_metadata();\n+            if let Some(config_vec_positions) = mdconf\n+                .iter()\n+                .find_all(|cconf| cconf.lints.contains(&info.lint.name_lower()[8..].to_owned()))\n+            {\n+                // If it has, print it\n+                println!(\"### Configuration for {}:\\n\", info.lint.name_lower());\n+                for position in config_vec_positions {\n+                    let conf = &mdconf[position];\n+                    println!(\"  - {}: {} (default: {})\", conf.name, conf.doc, conf.default);\n+                }\n+            }\n+        },\n         None => println!(\"unknown lint: {name}\"),\n     }\n }\n@@ -971,6 +990,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(manual_slice_size_calculation::ManualSliceSizeCalculation));\n     store.register_early_pass(|| Box::new(suspicious_doc_comments::SuspiciousDocComments));\n     store.register_late_pass(|_| Box::new(items_after_test_module::ItemsAfterTestModule));\n+    store.register_early_pass(|| Box::new(ref_patterns::RefPatterns));\n     store.register_late_pass(|_| Box::new(default_constructed_unit_structs::DefaultConstructedUnitStructs));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }"}, {"sha": "09b2032e20fbe51ca21f3fc6cead521644a801f8", "filename": "src/tools/clippy/clippy_lints/src/lines_filter_map_ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flines_filter_map_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flines_filter_map_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flines_filter_map_ok.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -25,7 +25,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// This lint suggests replacing `filter_map()` or `flat_map()` applied to a `Lines`\n-    /// instance in all cases. There two cases where the suggestion might not be\n+    /// instance in all cases. There are two cases where the suggestion might not be\n     /// appropriate or necessary:\n     ///\n     /// - If the `Lines` instance can never produce any error, or if an error is produced"}, {"sha": "3f8b42ffe80532f44850730bfe149a5bec459b8b", "filename": "src/tools/clippy/clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -38,7 +38,6 @@ declare_clippy_lint! {\n     /// Could be written:\n     ///\n     /// ```rust\n-    /// # #![feature(let_else)]\n     /// # fn main () {\n     /// # let w = Some(0);\n     /// let Some(v) = w else { return };\n@@ -69,29 +68,23 @@ impl_lint_pass!(ManualLetElse => [MANUAL_LET_ELSE]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &'tcx Stmt<'tcx>) {\n-        let if_let_or_match = if_chain! {\n-            if self.msrv.meets(msrvs::LET_ELSE);\n-            if !in_external_macro(cx.sess(), stmt.span);\n-            if let StmtKind::Local(local) = stmt.kind;\n-            if let Some(init) = local.init;\n-            if local.els.is_none();\n-            if local.ty.is_none();\n-            if init.span.ctxt() == stmt.span.ctxt();\n-            if let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init);\n-            then {\n-                if_let_or_match\n-            } else {\n-                return;\n-            }\n-        };\n+        if !self.msrv.meets(msrvs::LET_ELSE) || in_external_macro(cx.sess(), stmt.span) {\n+            return;\n+        }\n \n+        if let StmtKind::Local(local) = stmt.kind &&\n+            let Some(init) = local.init &&\n+            local.els.is_none() &&\n+            local.ty.is_none() &&\n+            init.span.ctxt() == stmt.span.ctxt() &&\n+            let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init) {\n         match if_let_or_match {\n             IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n                 if expr_is_simple_identity(let_pat, if_then);\n                 if let Some(if_else) = if_else;\n                 if expr_diverges(cx, if_else);\n                 then {\n-                    emit_manual_let_else(cx, stmt.span, if_let_expr, let_pat, if_else);\n+                    emit_manual_let_else(cx, stmt.span, if_let_expr, local.pat, let_pat, if_else);\n                 }\n             },\n             IfLetOrMatch::Match(match_expr, arms, source) => {\n@@ -128,15 +121,23 @@ impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n                     return;\n                 }\n \n-                emit_manual_let_else(cx, stmt.span, match_expr, pat_arm.pat, diverging_arm.body);\n+                emit_manual_let_else(cx, stmt.span, match_expr, local.pat, pat_arm.pat, diverging_arm.body);\n             },\n         }\n+        };\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n \n-fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat: &Pat<'_>, else_body: &Expr<'_>) {\n+fn emit_manual_let_else(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    expr: &Expr<'_>,\n+    local: &Pat<'_>,\n+    pat: &Pat<'_>,\n+    else_body: &Expr<'_>,\n+) {\n     span_lint_and_then(\n         cx,\n         MANUAL_LET_ELSE,\n@@ -145,12 +146,11 @@ fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat:\n         |diag| {\n             // This is far from perfect, for example there needs to be:\n             // * mut additions for the bindings\n-            // * renamings of the bindings\n+            // * renamings of the bindings for `PatKind::Or`\n             // * unused binding collision detection with existing ones\n             // * putting patterns with at the top level | inside ()\n             // for this to be machine applicable.\n             let mut app = Applicability::HasPlaceholders;\n-            let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", &mut app);\n             let (sn_expr, _) = snippet_with_context(cx, expr.span, span.ctxt(), \"\", &mut app);\n             let (sn_else, _) = snippet_with_context(cx, else_body.span, span.ctxt(), \"\", &mut app);\n \n@@ -159,10 +159,21 @@ fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat:\n             } else {\n                 format!(\"{{ {sn_else} }}\")\n             };\n-            let sn_bl = if matches!(pat.kind, PatKind::Or(..)) {\n-                format!(\"({sn_pat})\")\n-            } else {\n-                sn_pat.into_owned()\n+            let sn_bl = match pat.kind {\n+                PatKind::Or(..) => {\n+                    let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", &mut app);\n+                    format!(\"({sn_pat})\")\n+                },\n+                // Replace the variable name iff `TupleStruct` has one argument like `Variant(v)`.\n+                PatKind::TupleStruct(ref w, args, ..) if args.len() == 1 => {\n+                    let sn_wrapper = cx.sess().source_map().span_to_snippet(w.span()).unwrap_or_default();\n+                    let (sn_inner, _) = snippet_with_context(cx, local.span, span.ctxt(), \"\", &mut app);\n+                    format!(\"{sn_wrapper}({sn_inner})\")\n+                },\n+                _ => {\n+                    let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", &mut app);\n+                    sn_pat.into_owned()\n+                },\n             };\n             let sugg = format!(\"let {sn_bl} = {sn_expr} else {else_bl};\");\n             diag.span_suggestion(span, \"consider writing\", sugg, app);"}, {"sha": "93d977a5c96b82a20b13ba66582a1c2aaddaa403", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -144,7 +144,7 @@ fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n \n // Returns the length of the `expr` if it's a constant string or char.\n fn constant_length(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n-    let (value, _) = constant(cx, cx.typeck_results(), expr)?;\n+    let value = constant(cx, cx.typeck_results(), expr)?;\n     match value {\n         Constant::Str(value) => Some(value.len() as u128),\n         Constant::Char(value) => Some(value.len_utf8() as u128),"}, {"sha": "0064619ef89d1bb4ec78d14abb972600e8f5b854", "filename": "src/tools/clippy/clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,10 +1,12 @@\n+use super::REDUNDANT_PATTERN_MATCHING;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lint_allowed;\n use clippy_utils::is_wild;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::span_contains_comment;\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat, PatKind, QPath};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n@@ -99,6 +101,14 @@ where\n                 }\n             }\n \n+            for arm in iter_without_last.clone() {\n+                if let Some(pat) = arm.1 {\n+                    if !is_lint_allowed(cx, REDUNDANT_PATTERN_MATCHING, pat.hir_id) && is_some(pat.kind) {\n+                        return false;\n+                    }\n+                }\n+            }\n+\n             // The suggestion may be incorrect, because some arms can have `cfg` attributes\n             // evaluated into `false` and so such arms will be stripped before.\n             let mut applicability = Applicability::MaybeIncorrect;\n@@ -170,3 +180,13 @@ fn find_bool_lit(ex: &ExprKind<'_>) -> Option<bool> {\n         _ => None,\n     }\n }\n+\n+fn is_some(path_kind: PatKind<'_>) -> bool {\n+    match path_kind {\n+        PatKind::TupleStruct(QPath::Resolved(_, path), [first, ..], _) if is_wild(first) => {\n+            let name = path.segments[0].ident;\n+            name.name == rustc_span::sym::Some\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "ae8262ace96874a4254e145fdca4cc95fdb139b7", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -282,9 +282,8 @@ impl<'a> NormalizedPat<'a> {\n                 // TODO: Handle negative integers. They're currently treated as a wild match.\n                 ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n-                    LitKind::ByteStr(ref bytes, _) => Self::LitBytes(bytes),\n+                    LitKind::ByteStr(ref bytes, _) | LitKind::CStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n-                    LitKind::CStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),\n                     LitKind::Bool(val) => Self::LitBool(val),"}, {"sha": "55ec9d4474f59de08eef3a39d1c7ed28c296e581", "filename": "src/tools/clippy/clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -25,9 +25,9 @@ mod wild_in_or_pats;\n \n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::{snippet_opt, walk_span_to_context};\n-use clippy_utils::{higher, in_constant, is_span_match};\n+use clippy_utils::{higher, in_constant, is_span_match, tokenize_with_text};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n-use rustc_lexer::{tokenize, TokenKind};\n+use rustc_lexer::TokenKind;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -1147,12 +1147,7 @@ fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n         // Assume true. This would require either an invalid span, or one which crosses file boundaries.\n         return true;\n     };\n-    let mut pos = 0usize;\n-    let mut iter = tokenize(&snip).map(|t| {\n-        let start = pos;\n-        pos += t.len as usize;\n-        (t.kind, start..pos)\n-    });\n+    let mut iter = tokenize_with_text(&snip);\n \n     // Search for the token sequence [`#`, `[`, `cfg`]\n     while iter.any(|(t, _)| matches!(t, TokenKind::Pound)) {\n@@ -1163,7 +1158,7 @@ fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n             )\n         });\n         if matches!(iter.next(), Some((TokenKind::OpenBracket, _)))\n-            && matches!(iter.next(), Some((TokenKind::Ident, range)) if &snip[range.clone()] == \"cfg\")\n+            && matches!(iter.next(), Some((TokenKind::Ident, \"cfg\")))\n         {\n             return true;\n         }"}, {"sha": "abf2525a61c68520b9511732e6f44d91645166b6", "filename": "src/tools/clippy/clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -34,7 +34,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n             if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs_const = match lhs {\n-                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?,\n                         None => {\n                             let min_val_const = ty.numeric_min_val(cx.tcx)?;\n                             let min_constant = mir::ConstantKind::from_value(\n@@ -45,7 +45,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                         },\n                     };\n                     let rhs_const = match rhs {\n-                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?,\n                         None => {\n                             let max_val_const = ty.numeric_max_val(cx.tcx)?;\n                             let max_constant = mir::ConstantKind::from_value("}, {"sha": "e81e09da42547a5be77f0d6841d5e7887cdd73b2", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 148, "deletions": 67, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -189,73 +189,7 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n \n-        let found_good_method = match node_pair {\n-            (\n-                PatKind::TupleStruct(ref path_left, patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, patterns_right, _),\n-            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                    find_good_method_for_match(\n-                        cx,\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        Item::Lang(ResultOk),\n-                        Item::Lang(ResultErr),\n-                        \"is_ok()\",\n-                        \"is_err()\",\n-                    )\n-                    .or_else(|| {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            Item::Diag(sym::IpAddr, sym!(V4)),\n-                            Item::Diag(sym::IpAddr, sym!(V6)),\n-                            \"is_ipv4()\",\n-                            \"is_ipv6()\",\n-                        )\n-                    })\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n-            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n-                if patterns.len() == 1 =>\n-            {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    find_good_method_for_match(\n-                        cx,\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        Item::Lang(OptionSome),\n-                        Item::Lang(OptionNone),\n-                        \"is_some()\",\n-                        \"is_none()\",\n-                    )\n-                    .or_else(|| {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            Item::Lang(PollReady),\n-                            Item::Lang(PollPending),\n-                            \"is_ready()\",\n-                            \"is_pending()\",\n-                        )\n-                    })\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(good_method) = found_good_method {\n+        if let Some(good_method) = found_good_method(cx, arms, node_pair) {\n             let span = expr.span.to(op.span);\n             let result_expr = match &op.kind {\n                 ExprKind::AddrOf(_, _, borrowed) => borrowed,\n@@ -279,6 +213,127 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n     }\n }\n \n+fn found_good_method<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    node: (&PatKind<'_>, &PatKind<'_>),\n+) -> Option<&'a str> {\n+    match node {\n+        (\n+            PatKind::TupleStruct(ref path_left, patterns_left, _),\n+            PatKind::TupleStruct(ref path_right, patterns_right, _),\n+        ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+            if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                find_good_method_for_match(\n+                    cx,\n+                    arms,\n+                    path_left,\n+                    path_right,\n+                    Item::Lang(ResultOk),\n+                    Item::Lang(ResultErr),\n+                    \"is_ok()\",\n+                    \"is_err()\",\n+                )\n+                .or_else(|| {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        Item::Diag(sym::IpAddr, sym!(V4)),\n+                        Item::Diag(sym::IpAddr, sym!(V6)),\n+                        \"is_ipv4()\",\n+                        \"is_ipv6()\",\n+                    )\n+                })\n+            } else {\n+                None\n+            }\n+        },\n+        (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+        | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n+            if patterns.len() == 1 =>\n+        {\n+            if let PatKind::Wild = patterns[0].kind {\n+                find_good_method_for_match(\n+                    cx,\n+                    arms,\n+                    path_left,\n+                    path_right,\n+                    Item::Lang(OptionSome),\n+                    Item::Lang(OptionNone),\n+                    \"is_some()\",\n+                    \"is_none()\",\n+                )\n+                .or_else(|| {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        Item::Lang(PollReady),\n+                        Item::Lang(PollPending),\n+                        \"is_ready()\",\n+                        \"is_pending()\",\n+                    )\n+                })\n+            } else {\n+                None\n+            }\n+        },\n+        (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Wild) if patterns.len() == 1 => {\n+            if let PatKind::Wild = patterns[0].kind {\n+                get_good_method(cx, arms, path_left)\n+            } else {\n+                None\n+            }\n+        },\n+        (PatKind::Path(ref path_left), PatKind::Wild) => get_good_method(cx, arms, path_left),\n+        _ => None,\n+    }\n+}\n+\n+fn get_ident(path: &QPath<'_>) -> Option<rustc_span::symbol::Ident> {\n+    match path {\n+        QPath::Resolved(_, path) => {\n+            let name = path.segments[0].ident;\n+            Some(name)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn get_good_method<'a>(cx: &LateContext<'_>, arms: &[Arm<'_>], path_left: &QPath<'_>) -> Option<&'a str> {\n+    if let Some(name) = get_ident(path_left) {\n+        return match name.as_str() {\n+            \"Ok\" => {\n+                find_good_method_for_matches_macro(cx, arms, path_left, Item::Lang(ResultOk), \"is_ok()\", \"is_err()\")\n+            },\n+            \"Err\" => {\n+                find_good_method_for_matches_macro(cx, arms, path_left, Item::Lang(ResultErr), \"is_err()\", \"is_ok()\")\n+            },\n+            \"Some\" => find_good_method_for_matches_macro(\n+                cx,\n+                arms,\n+                path_left,\n+                Item::Lang(OptionSome),\n+                \"is_some()\",\n+                \"is_none()\",\n+            ),\n+            \"None\" => find_good_method_for_matches_macro(\n+                cx,\n+                arms,\n+                path_left,\n+                Item::Lang(OptionNone),\n+                \"is_none()\",\n+                \"is_some()\",\n+            ),\n+            _ => None,\n+        };\n+    }\n+    None\n+}\n+\n #[derive(Clone, Copy)]\n enum Item {\n     Lang(LangItem),\n@@ -346,3 +401,29 @@ fn find_good_method_for_match<'a>(\n         _ => None,\n     }\n }\n+\n+fn find_good_method_for_matches_macro<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    path_left: &QPath<'_>,\n+    expected_item_left: Item,\n+    should_be_left: &'a str,\n+    should_be_right: &'a str,\n+) -> Option<&'a str> {\n+    let first_pat = arms[0].pat;\n+\n+    let body_node_pair = if is_pat_variant(cx, first_pat, path_left, expected_item_left) {\n+        (&arms[0].body.kind, &arms[1].body.kind)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(lit_left), ExprKind::Lit(lit_right)) => match (&lit_left.node, &lit_right.node) {\n+            (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+            (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "d1609eebfdca9dd5a66aa9ad3da342336762194a", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_nth_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -13,7 +13,7 @@ use super::ITER_NTH_ZERO;\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, expr, sym::Iterator);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg);\n+        if let Some(Constant::Int(0)) = constant(cx, cx.typeck_results(), arg);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg("}, {"sha": "b631cd00cda4349c5c8f6d7f598558345efb9dae", "filename": "src/tools/clippy/clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -9,7 +9,7 @@ use super::ITERATOR_STEP_BY_ZERO;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg) {\n+        if let Some(Constant::Int(0)) = constant(cx, cx.typeck_results(), arg) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,"}, {"sha": "5f3fec53827a9bae6f44e7504b2ea84ad05af633", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_next_back.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_next_back.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_next_back.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_next_back.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,38 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::ty::implements_trait;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    rev_call: &'tcx Expr<'_>,\n+    rev_recv: &'tcx Expr<'_>,\n+) {\n+    let rev_recv_ty = cx.typeck_results().expr_ty(rev_recv);\n+\n+    // check that the receiver of `rev` implements `DoubleEndedIterator` and\n+    // that `rev` and `next` come from `Iterator`\n+    if cx\n+        .tcx\n+        .get_diagnostic_item(sym::DoubleEndedIterator)\n+        .map_or(false, |double_ended_iterator| {\n+            implements_trait(cx, rev_recv_ty, double_ended_iterator, &[])\n+        })\n+        && is_trait_method(cx, rev_call, sym::Iterator)\n+        && is_trait_method(cx, expr, sym::Iterator)\n+    {\n+        span_lint_and_sugg(\n+            cx,\n+            super::MANUAL_NEXT_BACK,\n+            expr.span.with_lo(rev_recv.span.hi()),\n+            \"manual backwards iteration\",\n+            \"use\",\n+            String::from(\".next_back()\"),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "9a594d964ab22ea7bf7c64b9f4683df9998a9979", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -45,6 +45,7 @@ mod iter_overeager_cloned;\n mod iter_skip_next;\n mod iter_with_drain;\n mod iterator_step_by_zero;\n+mod manual_next_back;\n mod manual_ok_or;\n mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n@@ -3132,8 +3133,11 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust\n     /// # let iterator = vec![1].into_iter();\n-    /// let len = iterator.clone().collect::<Vec<_>>().len();\n-    /// // should be\n+    /// let len = iterator.collect::<Vec<_>>().len();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let iterator = vec![1].into_iter();\n     /// let len = iterator.count();\n     /// ```\n     #[clippy::version = \"1.30.0\"]\n@@ -3193,6 +3197,29 @@ declare_clippy_lint! {\n     \"calling `drain` in order to `clear` a container\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `.rev().next()` on a `DoubleEndedIterator`\n+    ///\n+    /// ### Why is this bad?\n+    /// `.next_back()` is cleaner.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let foo = [0; 10];\n+    /// foo.iter().rev().next();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let foo = [0; 10];\n+    /// foo.iter().next_back();\n+    /// ```\n+    #[clippy::version = \"1.71.0\"]\n+    pub MANUAL_NEXT_BACK,\n+    style,\n+    \"manual reverse iteration of `DoubleEndedIterator`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Msrv,\n@@ -3321,6 +3348,7 @@ impl_lint_pass!(Methods => [\n     NEEDLESS_COLLECT,\n     SUSPICIOUS_COMMAND_ARG_SPACE,\n     CLEAR_WITH_DRAIN,\n+    MANUAL_NEXT_BACK,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -3677,6 +3705,7 @@ impl Methods {\n                             (\"iter\", []) => iter_next_slice::check(cx, expr, recv2),\n                             (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv2, arg),\n                             (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n+                            (\"rev\", [])=> manual_next_back::check(cx, expr, recv, recv2),\n                             _ => {},\n                         }\n                     }\n@@ -3741,13 +3770,13 @@ impl Methods {\n                     unnecessary_sort_by::check(cx, expr, recv, arg, true);\n                 },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n-                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    if let Some(Constant::Int(count)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n                         str_splitn::check(cx, name, expr, recv, pat_arg, count, &self.msrv);\n                     }\n                 },\n                 (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    if let Some(Constant::Int(count)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n                     }\n                 },"}, {"sha": "6841aaf626ca53b2264edf31febdd28250264b9b", "filename": "src/tools/clippy/clippy_lints/src/methods/needless_collect.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,13 +1,13 @@\n use super::NEEDLESS_COLLECT;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n-use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, make_normalized_projection, make_projection};\n use clippy_utils::{\n     can_move_expr_to_closure, get_enclosing_block, get_parent_node, is_trait_method, path_to_local, path_to_local_id,\n     CaptureKind,\n };\n+use clippy_utils::{fn_def_id, higher};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n@@ -16,7 +16,7 @@ use rustc_hir::{\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, AssocKind, EarlyBinder, GenericArg, GenericArgKind, Ty};\n+use rustc_middle::ty::{self, AssocKind, Clause, EarlyBinder, GenericArg, GenericArgKind, PredicateKind, Ty};\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol};\n \n@@ -32,6 +32,8 @@ pub(super) fn check<'tcx>(\n     if let Some(parent) = get_parent_node(cx.tcx, collect_expr.hir_id) {\n         match parent {\n             Node::Expr(parent) => {\n+                check_collect_into_intoiterator(cx, parent, collect_expr, call_span, iter_expr);\n+\n                 if let ExprKind::MethodCall(name, _, args @ ([] | [_]), _) = parent.kind {\n                     let mut app = Applicability::MachineApplicable;\n                     let name = name.ident.as_str();\n@@ -134,6 +136,68 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n+/// checks for for collecting into a (generic) method or function argument\n+/// taking an `IntoIterator`\n+fn check_collect_into_intoiterator<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    parent: &'tcx Expr<'tcx>,\n+    collect_expr: &'tcx Expr<'tcx>,\n+    call_span: Span,\n+    iter_expr: &'tcx Expr<'tcx>,\n+) {\n+    if let Some(id) = fn_def_id(cx, parent) {\n+        let args = match parent.kind {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => args,\n+            _ => &[],\n+        };\n+        // find the argument index of the `collect_expr` in the\n+        // function / method call\n+        if let Some(arg_idx) = args.iter().position(|e| e.hir_id == collect_expr.hir_id).map(|i| {\n+            if matches!(parent.kind, ExprKind::MethodCall(_, _, _, _)) {\n+                i + 1\n+            } else {\n+                i\n+            }\n+        }) {\n+            // extract the input types of the function/method call\n+            // that contains `collect_expr`\n+            let inputs = cx\n+                .tcx\n+                .liberate_late_bound_regions(id, cx.tcx.fn_sig(id).subst_identity())\n+                .inputs();\n+\n+            // map IntoIterator generic bounds to their signature\n+            // types and check whether the argument type is an\n+            // `IntoIterator`\n+            if cx\n+                .tcx\n+                .param_env(id)\n+                .caller_bounds()\n+                .into_iter()\n+                .filter_map(|p| {\n+                    if let PredicateKind::Clause(Clause::Trait(t)) = p.kind().skip_binder()\n+                            && cx.tcx.is_diagnostic_item(sym::IntoIterator,t.trait_ref.def_id) {\n+                                Some(t.self_ty())\n+                            } else {\n+                                None\n+                            }\n+                })\n+                .any(|ty| ty == inputs[arg_idx])\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_COLLECT,\n+                    call_span.with_lo(iter_expr.span.hi()),\n+                    NEEDLESS_COLLECT_MSG,\n+                    \"remove this call\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n /// Checks if the given method call matches the expected signature of `([&[mut]] self) -> bool`\n fn is_is_empty_sig(cx: &LateContext<'_>, call_id: HirId) -> bool {\n     cx.typeck_results().type_dependent_def_id(call_id).map_or(false, |id| {"}, {"sha": "bb4cdd2a6fa10c7264c1eb89c7761ee23caf2e30", "filename": "src/tools/clippy/clippy_lints/src/methods/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_lang_item;\n@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     recv: &'tcx Expr<'_>,\n     repeat_arg: &'tcx Expr<'_>,\n ) {\n-    if constant_context(cx, cx.typeck_results()).expr(repeat_arg) == Some(Constant::Int(1)) {\n+    if constant(cx, cx.typeck_results(), repeat_arg) == Some(Constant::Int(1)) {\n         let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n         if ty.is_str() {\n             span_lint_and_sugg("}, {"sha": "5ea12c441840dfd91da132ef583445ca3f84142b", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -316,7 +316,7 @@ fn parse_iter_usage<'tcx>(\n                     };\n                 },\n                 (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                    if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                    if let Some(Constant::Int(idx)) = constant(cx, cx.typeck_results(), idx_expr) {\n                         let span = if name.ident.as_str() == \"nth\" {\n                             e.span\n                         } else {"}, {"sha": "303f0125690873570d17a251409d024a4fc1bdc0", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -16,9 +16,12 @@ use rustc_span::source_map::{ExpnKind, Span};\n \n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    get_parent_expr, in_constant, is_integer_literal, is_no_std_crate, iter_input_pats, last_path_segment, SpanlessEq,\n+    get_parent_expr, in_constant, is_integer_literal, is_lint_allowed, is_no_std_crate, iter_input_pats,\n+    last_path_segment, SpanlessEq,\n };\n \n+use crate::ref_patterns::REF_PATTERNS;\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for function arguments and let bindings denoted as\n@@ -162,6 +165,10 @@ impl<'tcx> LateLintPass<'tcx> for LintPass {\n             return;\n         }\n         for arg in iter_input_pats(decl, body) {\n+            // Do not emit if clippy::ref_patterns is not allowed to avoid having two lints for the same issue.\n+            if !is_lint_allowed(cx, REF_PATTERNS, arg.pat.hir_id) {\n+                return;\n+            }\n             if let PatKind::Binding(BindingAnnotation(ByRef::Yes, _), ..) = arg.pat.kind {\n                 span_lint(\n                     cx,\n@@ -180,6 +187,8 @@ impl<'tcx> LateLintPass<'tcx> for LintPass {\n             if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n+            // Do not emit if clippy::ref_patterns is not allowed to avoid having two lints for the same issue.\n+            if is_lint_allowed(cx, REF_PATTERNS, local.pat.hir_id);\n             then {\n                 let ctxt = local.span.ctxt();\n                 let mut app = Applicability::MachineApplicable;"}, {"sha": "62af42a3961f8383c1bd1e6dd203cdf66f788ab1", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -146,7 +146,7 @@ fn is_parent_stmt(cx: &LateContext<'_>, id: HirId) -> bool {\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n-        if e.span.from_expansion() {\n+        if e.span.from_expansion() || !span_extract_comment(cx.tcx.sess.source_map(), e.span).is_empty() {\n             return;\n         }\n         if let Some(higher::If {\n@@ -209,8 +209,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n             }\n             if let Some((lhs_a, a)) = fetch_assign(then) &&\n                 let Some((lhs_b, b)) = fetch_assign(r#else) &&\n-                SpanlessEq::new(cx).eq_expr(lhs_a, lhs_b) &&\n-                span_extract_comment(cx.tcx.sess.source_map(), e.span).is_empty()\n+                SpanlessEq::new(cx).eq_expr(lhs_a, lhs_b)\n             {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let cond = Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability);"}, {"sha": "f4863600ccc04c9bc2a15dc1df8fced9dc790b10", "filename": "src/tools/clippy/clippy_lints/src/operators/absurd_extreme_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -121,7 +121,7 @@ fn detect_absurd_comparison<'tcx>(\n fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     let ty = cx.typeck_results().expr_ty(expr);\n \n-    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n+    let cv = constant(cx, cx.typeck_results(), expr)?;\n \n     let which = match (ty.kind(), cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => ExtremeType::Minimum,"}, {"sha": "5c240276b76d195f4e62edbe907bd34028a89c68", "filename": "src/tools/clippy/clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -21,7 +21,7 @@ const HARD_CODED_ALLOWED_BINARY: &[[&str; 2]] = &[\n     [\"f64\", \"f64\"],\n     [\"std::num::Saturating\", \"std::num::Saturating\"],\n     [\"std::num::Wrapping\", \"std::num::Wrapping\"],\n-    [\"std::string::String\", \"&str\"],\n+    [\"std::string::String\", \"str\"],\n ];\n const HARD_CODED_ALLOWED_UNARY: &[&str] = &[\"f32\", \"f64\", \"std::num::Saturating\", \"std::num::Wrapping\"];\n const INTEGER_METHODS: &[&str] = &[\"saturating_div\", \"wrapping_div\", \"wrapping_rem\", \"wrapping_rem_euclid\"];\n@@ -113,7 +113,7 @@ impl ArithmeticSideEffects {\n         if let hir::ExprKind::Lit(lit) = actual.kind && let ast::LitKind::Int(n, _) = lit.node {\n             return Some(n)\n         }\n-        if let Some((Constant::Int(n), _)) = constant(cx, cx.typeck_results(), expr) {\n+        if let Some(Constant::Int(n)) = constant(cx, cx.typeck_results(), expr) {\n             return Some(n);\n         }\n         None\n@@ -144,8 +144,10 @@ impl ArithmeticSideEffects {\n         ) {\n             return;\n         };\n-        let lhs_ty = cx.typeck_results().expr_ty(lhs);\n-        let rhs_ty = cx.typeck_results().expr_ty(rhs);\n+        let (actual_lhs, lhs_ref_counter) = peel_hir_expr_refs(lhs);\n+        let (actual_rhs, rhs_ref_counter) = peel_hir_expr_refs(rhs);\n+        let lhs_ty = cx.typeck_results().expr_ty(actual_lhs).peel_refs();\n+        let rhs_ty = cx.typeck_results().expr_ty(actual_rhs).peel_refs();\n         if self.has_allowed_binary(lhs_ty, rhs_ty) {\n             return;\n         }\n@@ -154,8 +156,6 @@ impl ArithmeticSideEffects {\n                 // At least for integers, shifts are already handled by the CTFE\n                 return;\n             }\n-            let (actual_lhs, lhs_ref_counter) = peel_hir_expr_refs(lhs);\n-            let (actual_rhs, rhs_ref_counter) = peel_hir_expr_refs(rhs);\n             match (\n                 Self::literal_integer(cx, actual_lhs),\n                 Self::literal_integer(cx, actual_rhs),"}, {"sha": "1fddf0f50e322513d4599900e5316fdbd31c174d", "filename": "src/tools/clippy/clippy_lints/src/operators/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -166,7 +166,7 @@ fn check_ineffective_gt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op:\n }\n \n fn fetch_int_literal(cx: &LateContext<'_>, lit: &Expr<'_>) -> Option<u128> {\n-    match constant(cx, cx.typeck_results(), lit)?.0 {\n+    match constant(cx, cx.typeck_results(), lit)? {\n         Constant::Int(n) => Some(n),\n         _ => None,\n     }"}, {"sha": "e18064b7061bf3d6344571a2a77fd7d240a3bc17", "filename": "src/tools/clippy/clippy_lints/src/operators/cmp_nan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Exp\n }\n \n fn is_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), e) {\n+    if let Some(value) = constant(cx, cx.typeck_results(), e) {\n         match value {\n             Constant::F32(num) => num.is_nan(),\n             Constant::F64(num) => num.is_nan(),"}, {"sha": "f120be13836d87c2d715a3490f98520b82196215", "filename": "src/tools/clippy/clippy_lints/src/operators/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -19,7 +19,7 @@ pub(crate) fn check<'tcx>(\n     if op == BinOpKind::Div\n         && let ExprKind::MethodCall(method_path, self_arg, [], _) = left.kind\n         && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n-        && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n+        && let Some(Constant::Int(divisor)) = constant(cx, cx.typeck_results(), right)\n     {\n         let suggested_fn = match (method_path.ident.as_str(), divisor) {\n             (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\","}, {"sha": "15dff126be76e5eabd7ed88517806c489a7de969", "filename": "src/tools/clippy/clippy_lints/src/operators/float_cmp.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::consts::{constant_with_source, Constant};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::get_item_name;\n use clippy_utils::sugg::Sugg;\n@@ -18,9 +18,16 @@ pub(crate) fn check<'tcx>(\n     right: &'tcx Expr<'_>,\n ) {\n     if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-        if is_allowed(cx, left) || is_allowed(cx, right) {\n-            return;\n-        }\n+        let left_is_local = match constant_with_source(cx, cx.typeck_results(), left) {\n+            Some((c, s)) if !is_allowed(&c) => s.is_local(),\n+            Some(_) => return,\n+            None => true,\n+        };\n+        let right_is_local = match constant_with_source(cx, cx.typeck_results(), right) {\n+            Some((c, s)) if !is_allowed(&c) => s.is_local(),\n+            Some(_) => return,\n+            None => true,\n+        };\n \n         // Allow comparing the results of signum()\n         if is_signum(cx, left) && is_signum(cx, right) {\n@@ -34,10 +41,7 @@ pub(crate) fn check<'tcx>(\n             }\n         }\n         let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-        let (lint, msg) = get_lint_and_message(\n-            is_named_constant(cx, left) || is_named_constant(cx, right),\n-            is_comparing_arrays,\n-        );\n+        let (lint, msg) = get_lint_and_message(left_is_local && right_is_local, is_comparing_arrays);\n         span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n             let lhs = Sugg::hir(cx, left, \"..\");\n             let rhs = Sugg::hir(cx, right, \"..\");\n@@ -59,44 +63,33 @@ pub(crate) fn check<'tcx>(\n     }\n }\n \n-fn get_lint_and_message(\n-    is_comparing_constants: bool,\n-    is_comparing_arrays: bool,\n-) -> (&'static rustc_lint::Lint, &'static str) {\n-    if is_comparing_constants {\n+fn get_lint_and_message(is_local: bool, is_comparing_arrays: bool) -> (&'static rustc_lint::Lint, &'static str) {\n+    if is_local {\n         (\n-            FLOAT_CMP_CONST,\n+            FLOAT_CMP,\n             if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` constant arrays\"\n+                \"strict comparison of `f32` or `f64` arrays\"\n             } else {\n-                \"strict comparison of `f32` or `f64` constant\"\n+                \"strict comparison of `f32` or `f64`\"\n             },\n         )\n     } else {\n         (\n-            FLOAT_CMP,\n+            FLOAT_CMP_CONST,\n             if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` arrays\"\n+                \"strict comparison of `f32` or `f64` constant arrays\"\n             } else {\n-                \"strict comparison of `f32` or `f64`\"\n+                \"strict comparison of `f32` or `f64` constant\"\n             },\n         )\n     }\n }\n \n-fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n-        res\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.typeck_results(), expr) {\n-        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n+fn is_allowed(val: &Constant) -> bool {\n+    match val {\n+        &Constant::F32(f) => f == 0.0 || f.is_infinite(),\n+        &Constant::F64(f) => f == 0.0 || f.is_infinite(),\n+        Constant::Vec(vec) => vec.iter().all(|f| match f {\n             Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n             Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n             _ => false,"}, {"sha": "d63a836e73d6fcc8964baf8e775906e1e4c55884", "filename": "src/tools/clippy/clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -96,32 +96,6 @@ declare_clippy_lint! {\n     \"any arithmetic expression that can cause side effects like overflows or panics\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for integer arithmetic operations which could overflow or panic.\n-    ///\n-    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n-    /// of overflowing according to the [Rust\n-    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n-    /// attempted.\n-    ///\n-    /// ### Why is this bad?\n-    /// Integer overflow will trigger a panic in debug builds or will wrap in\n-    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n-    /// wants explicitly checked, wrapping or saturating arithmetic.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0;\n-    /// a + 1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INTEGER_ARITHMETIC,\n-    restriction,\n-    \"any integer arithmetic expression which could overflow or panic\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for float arithmetic.\n@@ -787,7 +761,6 @@ pub struct Operators {\n impl_lint_pass!(Operators => [\n     ABSURD_EXTREME_COMPARISONS,\n     ARITHMETIC_SIDE_EFFECTS,\n-    INTEGER_ARITHMETIC,\n     FLOAT_ARITHMETIC,\n     ASSIGN_OP_PATTERN,\n     MISREFACTORED_ASSIGN_OP,"}, {"sha": "a2c3a4d8ba7752d794d7656dfdecb12131bdfa6c", "filename": "src/tools/clippy/clippy_lints/src/operators/modulo_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -40,7 +40,7 @@ struct OperandInfo {\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n     match constant(cx, cx.typeck_results(), operand) {\n-        Some((Constant::Int(v), _)) => match *cx.typeck_results().expr_ty(expr).kind() {\n+        Some(Constant::Int(v)) => match *cx.typeck_results().expr_ty(expr).kind() {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {\n@@ -58,10 +58,10 @@ fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) ->\n             },\n             _ => {},\n         },\n-        Some((Constant::F32(f), _)) => {\n+        Some(Constant::F32(f)) => {\n             return Some(floating_point_operand_info(&f));\n         },\n-        Some((Constant::F64(f), _)) => {\n+        Some(Constant::F64(f)) => {\n             return Some(floating_point_operand_info(&f));\n         },\n         _ => {},"}, {"sha": "102845ceed095a16a4109293de18e13894581f21", "filename": "src/tools/clippy/clippy_lints/src/operators/numeric_arithmetic.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,8 +1,6 @@\n-use super::{FLOAT_ARITHMETIC, INTEGER_ARITHMETIC};\n+use super::FLOAT_ARITHMETIC;\n use clippy_utils::consts::constant_simple;\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_from_proc_macro;\n-use clippy_utils::is_integer_literal;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n@@ -45,31 +43,8 @@ impl Context {\n             _ => (),\n         }\n \n-        let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n-        if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n-            if is_from_proc_macro(cx, expr) {\n-                return;\n-            }\n-            match op {\n-                hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n-                    hir::ExprKind::Lit(_lit) => (),\n-                    hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n-                        if is_integer_literal(expr, 1) {\n-                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                            self.expr_id = Some(expr.hir_id);\n-                        }\n-                    },\n-                    _ => {\n-                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                        self.expr_id = Some(expr.hir_id);\n-                    },\n-                },\n-                _ => {\n-                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                    self.expr_id = Some(expr.hir_id);\n-                },\n-            }\n-        } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n+        let (_, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n+        if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n             span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n             self.expr_id = Some(expr.hir_id);\n         }\n@@ -80,17 +55,9 @@ impl Context {\n             return;\n         }\n         let ty = cx.typeck_results().expr_ty(arg);\n-        if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n-            if ty.is_integral() {\n-                if is_from_proc_macro(cx, expr) {\n-                    return;\n-                }\n-                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                self.expr_id = Some(expr.hir_id);\n-            } else if ty.is_floating_point() {\n-                span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                self.expr_id = Some(expr.hir_id);\n-            }\n+        if constant_simple(cx, cx.typeck_results(), expr).is_none() && ty.is_floating_point() {\n+            span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+            self.expr_id = Some(expr.hir_id);\n         }\n     }\n "}, {"sha": "aa6d40042688d55fa056663d63c31e8ea4aadd62", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -122,7 +122,7 @@ fn try_get_option_occurrence<'tcx>(\n         ExprKind::Unary(UnOp::Deref, inner_expr) | ExprKind::AddrOf(_, _, inner_expr) => inner_expr,\n         _ => expr,\n     };\n-    let inner_pat = try_get_inner_pat(cx, pat)?;\n+    let (inner_pat, is_result) = try_get_inner_pat_and_is_result(cx, pat)?;\n     if_chain! {\n         if let PatKind::Binding(bind_annotation, _, id, None) = inner_pat.kind;\n         if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n@@ -176,7 +176,7 @@ fn try_get_option_occurrence<'tcx>(\n                 ),\n                 none_expr: format!(\n                     \"{}{}\",\n-                    if method_sugg == \"map_or\" { \"\" } else { \"|| \" },\n+                    if method_sugg == \"map_or\" { \"\" } else if is_result { \"|_| \" } else { \"|| \"},\n                     Sugg::hir_with_context(cx, none_body, ctxt, \"..\", &mut app),\n                 ),\n             });\n@@ -186,11 +186,13 @@ fn try_get_option_occurrence<'tcx>(\n     None\n }\n \n-fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n+fn try_get_inner_pat_and_is_result<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<(&'tcx Pat<'tcx>, bool)> {\n     if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n         let res = cx.qpath_res(qpath, pat.hir_id);\n-        if is_res_lang_ctor(cx, res, OptionSome) || is_res_lang_ctor(cx, res, ResultOk) {\n-            return Some(inner_pat);\n+        if is_res_lang_ctor(cx, res, OptionSome) {\n+            return Some((inner_pat, false));\n+        } else if is_res_lang_ctor(cx, res, ResultOk) {\n+            return Some((inner_pat, true));\n         }\n     }\n     None"}, {"sha": "dd7ded491e792383cfb973c009f921dc1fca5997", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -319,7 +319,7 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n             _ => return None,\n         };\n         if let Some(id) = path_to_local(l) {\n-            if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n+            if let Some(c) = constant(cx, cx.typeck_results(), r) {\n                 return Some(RangeBounds {\n                     val: c,\n                     expr: r,\n@@ -331,7 +331,7 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n                 });\n             }\n         } else if let Some(id) = path_to_local(r) {\n-            if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n+            if let Some(c) = constant(cx, cx.typeck_results(), l) {\n                 return Some(RangeBounds {\n                     val: c,\n                     expr: l,\n@@ -451,8 +451,8 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::Range::hir(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind();\n-        if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);\n-        if let Some((end_idx, _)) = constant(cx, cx.typeck_results(), end);\n+        if let Some(start_idx) = constant(cx, cx.typeck_results(), start);\n+        if let Some(end_idx) = constant(cx, cx.typeck_results(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {"}, {"sha": "b1530eed1c11fe5183457e220e20d00ad558b71b", "filename": "src/tools/clippy/clippy_lints/src/ref_patterns.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_patterns.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_ast::ast::{BindingAnnotation, Pat, PatKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of the `ref` keyword.\n+    /// ### Why is this bad?\n+    /// The `ref` keyword can be confusing for people unfamiliar with it, and often\n+    /// it is more concise to use `&` instead.\n+    /// ### Example\n+    /// ```rust\n+    /// let opt = Some(5);\n+    /// if let Some(ref foo) = opt {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let opt = Some(5);\n+    /// if let Some(foo) = &opt {}\n+    /// ```\n+    #[clippy::version = \"1.71.0\"]\n+    pub REF_PATTERNS,\n+    restriction,\n+    \"use of a ref pattern, e.g. Some(ref value)\"\n+}\n+declare_lint_pass!(RefPatterns => [REF_PATTERNS]);\n+\n+impl EarlyLintPass for RefPatterns {\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n+        if let PatKind::Ident(BindingAnnotation::REF, _, _) = pat.kind\n+                && !pat.span.from_expansion()\n+        {\n+            span_lint_and_help(\n+                cx,\n+                REF_PATTERNS,\n+                pat.span,\n+                \"usage of ref pattern\",\n+                None,\n+                \"consider using `&` for clarity instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "ef19c6f4617295a4cef75847ee64064bc9a7550f", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -122,37 +122,39 @@ fn lint_syntax_error(cx: &LateContext<'_>, error: &regex_syntax::Error, unescape\n }\n \n fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n-    constant(cx, cx.typeck_results(), e).and_then(|(c, _)| match c {\n+    constant(cx, cx.typeck_results(), e).and_then(|c| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n     })\n }\n \n fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n-    use regex_syntax::hir::Anchor::{EndText, StartText};\n-    use regex_syntax::hir::HirKind::{Alternation, Anchor, Concat, Empty, Literal};\n+    use regex_syntax::hir::HirKind::{Alternation, Concat, Empty, Literal, Look};\n+    use regex_syntax::hir::Look as HirLook;\n \n     let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| matches!(*e.kind(), Literal(_)));\n \n     match *s.kind() {\n-        Empty | Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),\n+        Empty | Look(_) => Some(\"the regex is unlikely to be useful as it is\"),\n         Literal(_) => Some(\"consider using `str::contains`\"),\n         Alternation(ref exprs) => {\n-            if exprs.iter().all(|e| e.kind().is_empty()) {\n+            if exprs.iter().all(|e| matches!(e.kind(), Empty)) {\n                 Some(\"the regex is unlikely to be useful as it is\")\n             } else {\n                 None\n             }\n         },\n         Concat(ref exprs) => match (exprs[0].kind(), exprs[exprs.len() - 1].kind()) {\n-            (&Anchor(StartText), &Anchor(EndText)) if exprs[1..(exprs.len() - 1)].is_empty() => {\n+            (&Look(HirLook::Start), &Look(HirLook::End)) if exprs[1..(exprs.len() - 1)].is_empty() => {\n                 Some(\"consider using `str::is_empty`\")\n             },\n-            (&Anchor(StartText), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n+            (&Look(HirLook::Start), &Look(HirLook::End)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n                 Some(\"consider using `==` on `str`s\")\n             },\n-            (&Anchor(StartText), &Literal(_)) if is_literal(&exprs[1..]) => Some(\"consider using `str::starts_with`\"),\n-            (&Literal(_), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n+            (&Look(HirLook::Start), &Literal(_)) if is_literal(&exprs[1..]) => {\n+                Some(\"consider using `str::starts_with`\")\n+            },\n+            (&Literal(_), &Look(HirLook::End)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n                 Some(\"consider using `str::ends_with`\")\n             },\n             _ if is_literal(exprs) => Some(\"consider using `str::contains`\"),\n@@ -175,10 +177,7 @@ fn check_set<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n }\n \n fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n-    let mut parser = regex_syntax::ParserBuilder::new()\n-        .unicode(true)\n-        .allow_invalid_utf8(!utf8)\n-        .build();\n+    let mut parser = regex_syntax::ParserBuilder::new().unicode(true).utf8(!utf8).build();\n \n     if let ExprKind::Lit(lit) = expr.kind {\n         if let LitKind::Str(ref r, style) = lit.node {"}, {"sha": "b0db56bb417ea37a6d2fb04413ade1ebe686ed6a", "filename": "src/tools/clippy/clippy_lints/src/renamed_lints.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -15,6 +15,7 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::eval_order_dependence\", \"clippy::mixed_read_write_in_expression\"),\n     (\"clippy::identity_conversion\", \"clippy::useless_conversion\"),\n     (\"clippy::if_let_some_result\", \"clippy::match_result_ok\"),\n+    (\"clippy::integer_arithmetic\", \"clippy::arithmetic_side_effects\"),\n     (\"clippy::logic_bug\", \"clippy::overly_complex_bool_expr\"),\n     (\"clippy::new_without_default_derive\", \"clippy::new_without_default\"),\n     (\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\"),\n@@ -32,13 +33,13 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::zero_width_space\", \"clippy::invisible_characters\"),\n     (\"clippy::clone_double_ref\", \"suspicious_double_ref_op\"),\n     (\"clippy::drop_bounds\", \"drop_bounds\"),\n-    (\"clippy::drop_copy\", \"drop_copy\"),\n-    (\"clippy::drop_ref\", \"drop_ref\"),\n+    (\"clippy::drop_copy\", \"dropping_copy_types\"),\n+    (\"clippy::drop_ref\", \"dropping_references\"),\n     (\"clippy::for_loop_over_option\", \"for_loops_over_fallibles\"),\n     (\"clippy::for_loop_over_result\", \"for_loops_over_fallibles\"),\n     (\"clippy::for_loops_over_fallibles\", \"for_loops_over_fallibles\"),\n-    (\"clippy::forget_copy\", \"forget_copy\"),\n-    (\"clippy::forget_ref\", \"forget_ref\"),\n+    (\"clippy::forget_copy\", \"forgetting_copy_types\"),\n+    (\"clippy::forget_ref\", \"forgetting_references\"),\n     (\"clippy::into_iter_on_array\", \"array_into_iter\"),\n     (\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\"),\n     (\"clippy::invalid_ref\", \"invalid_value\"),"}, {"sha": "483f860a8b5e2c66360779ee94defeca531e00cc", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -132,7 +132,7 @@ declare_clippy_lint! {\n     /// Probably lots of false positives. If an index comes from a known valid position (e.g.\n     /// obtained via `char_indices` over the same string), it is totally OK.\n     ///\n-    /// # Example\n+    /// ### Example\n     /// ```rust,should_panic\n     /// &\"\u00d6lkanne\"[1..];\n     /// ```"}, {"sha": "4ccda15068bbbb5c7cceabb0d8db1b9a5f73d8f4", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -37,12 +37,12 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.38.0\"]\n     pub TYPE_REPETITION_IN_BOUNDS,\n     nursery,\n-    \"types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n+    \"types are repeated unnecessarily in trait bounds, use `+` instead of using `T: _, T: _`\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for cases where generics are being used and multiple\n+    /// Checks for cases where generics or trait objects are being used and multiple\n     /// syntax specifications for trait bounds are used simultaneously.\n     ///\n     /// ### Why is this bad?\n@@ -167,6 +167,61 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n             }\n         }\n     }\n+\n+    fn check_ty(&mut self, cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) {\n+        if_chain! {\n+            if let TyKind::Ref(.., mut_ty) = &ty.kind;\n+            if let TyKind::TraitObject(bounds, ..) = mut_ty.ty.kind;\n+            if bounds.len() > 2;\n+            then {\n+\n+                // Build up a hash of every trait we've seen\n+                // When we see a trait for the first time, add it to unique_traits\n+                // so we can later use it to build a string of all traits exactly once, without duplicates\n+\n+                let mut seen_def_ids = FxHashSet::default();\n+                let mut unique_traits = Vec::new();\n+\n+                // Iterate the bounds and add them to our seen hash\n+                // If we haven't yet seen it, add it to the fixed traits\n+                for bound in bounds.iter() {\n+                    let Some(def_id) = bound.trait_ref.trait_def_id() else { continue; };\n+\n+                    let new_trait = seen_def_ids.insert(def_id);\n+\n+                    if new_trait {\n+                        unique_traits.push(bound);\n+                    }\n+                }\n+\n+                // If the number of unique traits isn't the same as the number of traits in the bounds,\n+                // there must be 1 or more duplicates\n+                if bounds.len() != unique_traits.len() {\n+                    let mut bounds_span = bounds[0].span;\n+\n+                    for bound in bounds.iter().skip(1) {\n+                        bounds_span = bounds_span.to(bound.span);\n+                    }\n+\n+                    let fixed_trait_snippet = unique_traits\n+                        .iter()\n+                        .filter_map(|b| snippet_opt(cx, b.span))\n+                        .collect::<Vec<_>>()\n+                        .join(\" + \");\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TRAIT_DUPLICATION_IN_BOUNDS,\n+                        bounds_span,\n+                        \"this trait bound is already specified in trait declaration\",\n+                        \"try\",\n+                        fixed_trait_snippet,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n }\n \n impl TraitBounds {"}, {"sha": "4944381da24d59350effe1fbeab37eba24842bb7", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_null_to_fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -31,9 +31,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n     match arg.kind {\n         // Catching:\n         // transmute over constants that resolve to `null`.\n-        ExprKind::Path(ref _qpath)\n-            if matches!(constant(cx, cx.typeck_results(), arg), Some((Constant::RawPtr(0), _))) =>\n-        {\n+        ExprKind::Path(ref _qpath) if matches!(constant(cx, cx.typeck_results(), arg), Some(Constant::RawPtr(0))) => {\n             lint_expr(cx, expr);\n             true\n         },"}, {"sha": "770914e99e1689c193651a09efc0d33cad08d614", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmuting_null.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{is_integer_literal, is_path_diagnostic_item};\n use rustc_hir::{Expr, ExprKind};\n@@ -16,9 +16,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n     }\n \n     // Catching transmute over constants that resolve to `null`.\n-    let mut const_eval_context = constant_context(cx, cx.typeck_results());\n     if let ExprKind::Path(ref _qpath) = arg.kind &&\n-        let Some(Constant::RawPtr(0)) = const_eval_context.expr(arg)\n+        let Some(Constant::RawPtr(0)) = constant(cx, cx.typeck_results(), arg)\n     {\n         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n         return true;"}, {"sha": "28c3fc859e33227394bede57c02982234438519a", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::is_ty_alias;\n use clippy_utils::source::{snippet, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_copy, is_type_diagnostic_item, same_type_and_consts};\n@@ -138,6 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 if_chain! {\n                     if let ExprKind::Path(ref qpath) = path.kind;\n                     if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n+                    if !is_ty_alias(qpath);\n                     then {\n                         let a = cx.typeck_results().expr_ty(e);\n                         let b = cx.typeck_results().expr_ty(arg);"}, {"sha": "3c2bf5abab2b5783d2685cc7000b5ce4402d541e", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 bind!(self, vec);\n                 kind!(\"CStr(ref {vec})\");\n                 chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n-            }\n+            },\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n                 kind!(\"Str({s}, _)\");"}, {"sha": "f6de66bb5145b5c2d6c2692b96c55c0e6b204829", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -174,16 +174,15 @@ macro_rules! define_Conf {\n             }\n         }\n \n-        #[cfg(feature = \"internal\")]\n         pub mod metadata {\n-            use crate::utils::internal_lints::metadata_collector::ClippyConfiguration;\n+            use crate::utils::ClippyConfiguration;\n \n             macro_rules! wrap_option {\n                 () => (None);\n                 ($x:literal) => (Some($x));\n             }\n \n-            pub(crate) fn get_configuration_metadata() -> Vec<ClippyConfiguration> {\n+            pub fn get_configuration_metadata() -> Vec<ClippyConfiguration> {\n                 vec![\n                     $(\n                         {"}, {"sha": "7a1cd3effaef2ae79f48d1cf34734098f9b437fc", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 5, "deletions": 106, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -8,7 +8,11 @@\n //! a simple mistake)\n \n use crate::renamed_lints::RENAMED_LINTS;\n-use crate::utils::internal_lints::lint_without_lint_pass::{extract_clippy_version_value, is_lint_ref_type};\n+use crate::utils::{\n+    collect_configs,\n+    internal_lints::lint_without_lint_pass::{extract_clippy_version_value, is_lint_ref_type},\n+    ClippyConfiguration,\n+};\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};\n@@ -520,111 +524,6 @@ impl Serialize for ApplicabilityInfo {\n     }\n }\n \n-// ==================================================================\n-// Configuration\n-// ==================================================================\n-#[derive(Debug, Clone, Default)]\n-pub struct ClippyConfiguration {\n-    name: String,\n-    config_type: &'static str,\n-    default: String,\n-    lints: Vec<String>,\n-    doc: String,\n-    #[allow(dead_code)]\n-    deprecation_reason: Option<&'static str>,\n-}\n-\n-impl ClippyConfiguration {\n-    pub fn new(\n-        name: &'static str,\n-        config_type: &'static str,\n-        default: String,\n-        doc_comment: &'static str,\n-        deprecation_reason: Option<&'static str>,\n-    ) -> Self {\n-        let (lints, doc) = parse_config_field_doc(doc_comment)\n-            .unwrap_or_else(|| (vec![], \"[ERROR] MALFORMED DOC COMMENT\".to_string()));\n-\n-        Self {\n-            name: to_kebab(name),\n-            lints,\n-            doc,\n-            config_type,\n-            default,\n-            deprecation_reason,\n-        }\n-    }\n-\n-    fn to_markdown_paragraph(&self) -> String {\n-        format!(\n-            \"### {}\\n{}\\n\\n**Default Value:** `{}` (`{}`)\\n\\n{}\\n\\n\",\n-            self.name,\n-            self.doc\n-                .lines()\n-                .map(|line| line.strip_prefix(\"    \").unwrap_or(line))\n-                .join(\"\\n\"),\n-            self.default,\n-            self.config_type,\n-            self.lints\n-                .iter()\n-                .map(|name| name.to_string().split_whitespace().next().unwrap().to_string())\n-                .map(|name| format!(\"* [{name}](https://rust-lang.github.io/rust-clippy/master/index.html#{name})\"))\n-                .join(\"\\n\"),\n-        )\n-    }\n-\n-    fn to_markdown_table_entry(&self) -> String {\n-        format!(\"| [{}](#{}) | `{}` |\", self.name, self.name, self.default)\n-    }\n-}\n-\n-fn collect_configs() -> Vec<ClippyConfiguration> {\n-    crate::utils::conf::metadata::get_configuration_metadata()\n-}\n-\n-/// This parses the field documentation of the config struct.\n-///\n-/// ```rust, ignore\n-/// parse_config_field_doc(cx, \"Lint: LINT_NAME_1, LINT_NAME_2. Papa penguin, papa penguin\")\n-/// ```\n-///\n-/// Would yield:\n-/// ```rust, ignore\n-/// Some([\"lint_name_1\", \"lint_name_2\"], \"Papa penguin, papa penguin\")\n-/// ```\n-fn parse_config_field_doc(doc_comment: &str) -> Option<(Vec<String>, String)> {\n-    const DOC_START: &str = \" Lint: \";\n-    if_chain! {\n-        if doc_comment.starts_with(DOC_START);\n-        if let Some(split_pos) = doc_comment.find('.');\n-        then {\n-            let mut doc_comment = doc_comment.to_string();\n-            let mut documentation = doc_comment.split_off(split_pos);\n-\n-            // Extract lints\n-            doc_comment.make_ascii_lowercase();\n-            let lints: Vec<String> = doc_comment\n-                .split_off(DOC_START.len())\n-                .split(\", \")\n-                .map(str::to_string)\n-                .collect();\n-\n-            // Format documentation correctly\n-            // split off leading `.` from lint name list and indent for correct formatting\n-            documentation = documentation.trim_start_matches('.').trim().replace(\"\\n \", \"\\n    \");\n-\n-            Some((lints, documentation))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Transforms a given `snake_case_string` to a tasty `kebab-case-string`\n-fn to_kebab(config_name: &str) -> String {\n-    config_name.replace('_', \"-\")\n-}\n-\n impl fmt::Display for ClippyConfiguration {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n         writeln!("}, {"sha": "d3ea7cafa80c2f57b44db3d1b7f1d095c8b4e85e", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -4,3 +4,143 @@ pub mod dump_hir;\n pub mod format_args_collector;\n #[cfg(feature = \"internal\")]\n pub mod internal_lints;\n+#[cfg(feature = \"internal\")]\n+use itertools::Itertools;\n+\n+/// Transforms a given `snake_case_string` to a tasty `kebab-case-string`\n+fn to_kebab(config_name: &str) -> String {\n+    config_name.replace('_', \"-\")\n+}\n+\n+// ==================================================================\n+// Configuration\n+// ==================================================================\n+#[derive(Debug, Clone, Default)] //~ ERROR no such field\n+pub struct ClippyConfiguration {\n+    pub name: String,\n+    #[allow(dead_code)]\n+    config_type: &'static str,\n+    pub default: String,\n+    pub lints: Vec<String>,\n+    pub doc: String,\n+    #[allow(dead_code)]\n+    deprecation_reason: Option<&'static str>,\n+}\n+\n+impl ClippyConfiguration {\n+    pub fn new(\n+        name: &'static str,\n+        config_type: &'static str,\n+        default: String,\n+        doc_comment: &'static str,\n+        deprecation_reason: Option<&'static str>,\n+    ) -> Self {\n+        let (lints, doc) = parse_config_field_doc(doc_comment)\n+            .unwrap_or_else(|| (vec![], \"[ERROR] MALFORMED DOC COMMENT\".to_string()));\n+\n+        Self {\n+            name: to_kebab(name),\n+            lints,\n+            doc,\n+            config_type,\n+            default,\n+            deprecation_reason,\n+        }\n+    }\n+\n+    #[cfg(feature = \"internal\")]\n+    fn to_markdown_paragraph(&self) -> String {\n+        format!(\n+            \"### {}\\n{}\\n\\n**Default Value:** `{}` (`{}`)\\n\\n{}\\n\\n\",\n+            self.name,\n+            self.doc\n+                .lines()\n+                .map(|line| line.strip_prefix(\"    \").unwrap_or(line))\n+                .join(\"\\n\"),\n+            self.default,\n+            self.config_type,\n+            self.lints\n+                .iter()\n+                .map(|name| name.to_string().split_whitespace().next().unwrap().to_string())\n+                .map(|name| format!(\"* [{name}](https://rust-lang.github.io/rust-clippy/master/index.html#{name})\"))\n+                .join(\"\\n\"),\n+        )\n+    }\n+\n+    #[cfg(feature = \"internal\")]\n+    fn to_markdown_table_entry(&self) -> String {\n+        format!(\"| [{}](#{}) | `{}` |\", self.name, self.name, self.default)\n+    }\n+}\n+\n+#[cfg(feature = \"internal\")]\n+fn collect_configs() -> Vec<ClippyConfiguration> {\n+    crate::utils::conf::metadata::get_configuration_metadata()\n+}\n+\n+/// This parses the field documentation of the config struct.\n+///\n+/// ```rust, ignore\n+/// parse_config_field_doc(cx, \"Lint: LINT_NAME_1, LINT_NAME_2. Papa penguin, papa penguin\")\n+/// ```\n+///\n+/// Would yield:\n+/// ```rust, ignore\n+/// Some([\"lint_name_1\", \"lint_name_2\"], \"Papa penguin, papa penguin\")\n+/// ```\n+fn parse_config_field_doc(doc_comment: &str) -> Option<(Vec<String>, String)> {\n+    const DOC_START: &str = \" Lint: \";\n+    if_chain! {\n+        if doc_comment.starts_with(DOC_START);\n+        if let Some(split_pos) = doc_comment.find('.');\n+        then {\n+            let mut doc_comment = doc_comment.to_string();\n+            let mut documentation = doc_comment.split_off(split_pos);\n+\n+            // Extract lints\n+            doc_comment.make_ascii_lowercase();\n+            let lints: Vec<String> = doc_comment\n+                .split_off(DOC_START.len())\n+                .split(\", \")\n+                .map(str::to_string)\n+                .collect();\n+\n+            // Format documentation correctly\n+            // split off leading `.` from lint name list and indent for correct formatting\n+            documentation = documentation.trim_start_matches('.').trim().replace(\"\\n \", \"\\n    \");\n+\n+            Some((lints, documentation))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Shamelessly stolen from find_all (https://github.com/nectariner/find_all)\n+pub trait FindAll: Iterator + Sized {\n+    fn find_all<P>(&mut self, predicate: P) -> Option<Vec<usize>>\n+    where\n+        P: FnMut(&Self::Item) -> bool;\n+}\n+\n+impl<I> FindAll for I\n+where\n+    I: Iterator,\n+{\n+    fn find_all<P>(&mut self, mut predicate: P) -> Option<Vec<usize>>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        let mut occurences = Vec::<usize>::default();\n+        for (index, element) in self.enumerate() {\n+            if predicate(&element) {\n+                occurences.push(index);\n+            }\n+        }\n+\n+        match occurences.len() {\n+            0 => None,\n+            _ => Some(occurences),\n+        }\n+    }\n+}"}, {"sha": "7329e508106d988053af17c9549df8c110594d88", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -84,7 +84,7 @@ impl UselessVec {\n         let mut applicability = Applicability::MachineApplicable;\n         let snippet = match *vec_args {\n             higher::VecArgs::Repeat(elem, len) => {\n-                if let Some((Constant::Int(len_constant), _)) = constant(cx, cx.typeck_results(), len) {\n+                if let Some(Constant::Int(len_constant)) = constant(cx, cx.typeck_results(), len) {\n                     #[expect(clippy::cast_possible_truncation)]\n                     if len_constant as u64 * size_of(cx, elem) > self.too_large_for_stack {\n                         return;"}, {"sha": "a9089fba3c539764961f47f2c826ad2c281a4284", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::{\n     def::{DefKind, Res},\n     Item, ItemKind, PathSegment, UseKind,\n };\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::kw;\n@@ -117,6 +117,10 @@ impl_lint_pass!(WildcardImports => [ENUM_GLOB_USE, WILDCARD_IMPORTS]);\n \n impl LateLintPass<'_> for WildcardImports {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if cx.sess().is_test_crate() {\n+            return;\n+        }\n+\n         if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }"}, {"sha": "fb772644c0d64f4483cdf2da094fd959f550c4fe", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 75, "deletions": 35, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,18 +1,21 @@\n #![allow(clippy::float_cmp)]\n \n+use crate::source::{get_source_text, walk_span_to_context};\n use crate::{clip, is_direct_expn_of, sext, unsext};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind, Node, QPath, UnOp};\n+use rustc_lexer::tokenize;\n use rustc_lint::LateContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, EarlyBinder, FloatTy, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::ty::{List, SubstsRef};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::Symbol;\n+use rustc_span::SyntaxContext;\n use std::cmp::Ordering::{self, Equal};\n use std::hash::{Hash, Hasher};\n use std::iter;\n@@ -210,8 +213,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     match *lit {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n-        LitKind::ByteStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n-        LitKind::CStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::ByteStr(ref s, _) | LitKind::CStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n@@ -228,27 +230,46 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     }\n }\n \n+/// The source of a constant value.\n+pub enum ConstantSource {\n+    /// The value is determined solely from the expression.\n+    Local,\n+    /// The value is dependent on a defined constant.\n+    Constant,\n+}\n+impl ConstantSource {\n+    pub fn is_local(&self) -> bool {\n+        matches!(self, Self::Local)\n+    }\n+}\n+\n+/// Attempts to evaluate the expression as a constant.\n pub fn constant<'tcx>(\n     lcx: &LateContext<'tcx>,\n     typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n-) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: ty::List::empty(),\n-    };\n-    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n+) -> Option<Constant> {\n+    ConstEvalLateContext::new(lcx, typeck_results).expr(e)\n+}\n+\n+/// Attempts to evaluate the expression as a constant.\n+pub fn constant_with_source<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<(Constant, ConstantSource)> {\n+    let mut ctxt = ConstEvalLateContext::new(lcx, typeck_results);\n+    let res = ctxt.expr(e);\n+    res.map(|x| (x, ctxt.source))\n }\n \n+/// Attempts to evaluate an expression only if it's value is not dependent on other items.\n pub fn constant_simple<'tcx>(\n     lcx: &LateContext<'tcx>,\n     typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<Constant> {\n-    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+    constant_with_source(lcx, typeck_results, e).and_then(|(c, s)| s.is_local().then_some(c))\n }\n \n pub fn constant_full_int<'tcx>(\n@@ -297,29 +318,25 @@ impl Ord for FullInt {\n     }\n }\n \n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n-pub fn constant_context<'a, 'tcx>(\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> ConstEvalLateContext<'a, 'tcx> {\n-    ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: ty::List::empty(),\n-    }\n-}\n-\n pub struct ConstEvalLateContext<'a, 'tcx> {\n     lcx: &'a LateContext<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    needed_resolution: bool,\n+    source: ConstantSource,\n     substs: SubstsRef<'tcx>,\n }\n \n impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n+    fn new(lcx: &'a LateContext<'tcx>, typeck_results: &'a ty::TypeckResults<'tcx>) -> Self {\n+        Self {\n+            lcx,\n+            typeck_results,\n+            param_env: lcx.param_env,\n+            source: ConstantSource::Local,\n+            substs: List::empty(),\n+        }\n+    }\n+\n     /// Simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n         match e.kind {\n@@ -454,11 +471,9 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     .const_eval_resolve(self.param_env, mir::UnevaluatedConst::new(def_id, substs), None)\n                     .ok()\n                     .map(|val| rustc_middle::mir::ConstantKind::from_value(val, ty))?;\n-                let result = miri_to_const(self.lcx.tcx, result);\n-                if result.is_some() {\n-                    self.needed_resolution = true;\n-                }\n-                result\n+                let result = miri_to_const(self.lcx.tcx, result)?;\n+                self.source = ConstantSource::Constant;\n+                Some(result)\n             },\n             // FIXME: cover all usable cases.\n             _ => None,\n@@ -492,8 +507,33 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n \n     /// A block can only yield a constant if it only has one constant expression.\n     fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n-        if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|b| self.expr(b))\n+        if block.stmts.is_empty()\n+            && let Some(expr) = block.expr\n+        {\n+            // Try to detect any `cfg`ed statements or empty macro expansions.\n+            let span = block.span.data();\n+            if span.ctxt == SyntaxContext::root() {\n+                if let Some(expr_span) = walk_span_to_context(expr.span, span.ctxt)\n+                    && let expr_lo = expr_span.lo()\n+                    && expr_lo >= span.lo\n+                    && let Some(src) = get_source_text(self.lcx, span.lo..expr_lo)\n+                    && let Some(src) = src.as_str()\n+                {\n+                    use rustc_lexer::TokenKind::{Whitespace, LineComment, BlockComment, Semi, OpenBrace};\n+                    if !tokenize(src)\n+                        .map(|t| t.kind)\n+                        .filter(|t| !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. } | Semi))\n+                        .eq([OpenBrace])\n+                    {\n+                        self.source = ConstantSource::Constant;\n+                    }\n+                } else {\n+                    // Unable to access the source. Assume a non-local dependency.\n+                    self.source = ConstantSource::Constant;\n+                }\n+            }\n+\n+            self.expr(expr)\n         } else {\n             None\n         }"}, {"sha": "a49246a7832727a6c4c1d5d8854e71d5318f8b19", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 159, "deletions": 47, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::constant_simple;\n use crate::macros::macro_backtrace;\n-use crate::source::snippet_opt;\n+use crate::source::{get_source_text, snippet_opt, walk_span_to_context, SpanRange};\n+use crate::tokenize_with_text;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n@@ -13,8 +14,9 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::TypeckResults;\n-use rustc_span::{sym, Symbol};\n+use rustc_span::{sym, BytePos, ExpnKind, MacroKind, Symbol, SyntaxContext};\n use std::hash::{Hash, Hasher};\n+use std::ops::Range;\n \n /// Callback that is called when two expressions are not equal in the sense of `SpanlessEq`, but\n /// other conditions would make them equal.\n@@ -65,6 +67,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n         HirEqInterExpr {\n             inner: self,\n+            left_ctxt: SyntaxContext::root(),\n+            right_ctxt: SyntaxContext::root(),\n             locals: HirIdMap::default(),\n         }\n     }\n@@ -92,6 +96,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n     inner: &'a mut SpanlessEq<'b, 'tcx>,\n+    left_ctxt: SyntaxContext,\n+    right_ctxt: SyntaxContext,\n \n     // When binding are declared, the binding ID in the left expression is mapped to the one on the\n     // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n@@ -126,52 +132,88 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     /// Checks whether two blocks are the same.\n+    #[expect(clippy::similar_names)]\n     fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n-        match (left.stmts, left.expr, right.stmts, right.expr) {\n-            ([], None, [], None) => {\n-                // For empty blocks, check to see if the tokens are equal. This will catch the case where a macro\n-                // expanded to nothing, or the cfg attribute was used.\n-                let (Some(left), Some(right)) = (\n-                    snippet_opt(self.inner.cx, left.span),\n-                    snippet_opt(self.inner.cx, right.span),\n-                ) else { return true };\n-                let mut left_pos = 0;\n-                let left = tokenize(&left)\n-                    .map(|t| {\n-                        let end = left_pos + t.len as usize;\n-                        let s = &left[left_pos..end];\n-                        left_pos = end;\n-                        (t, s)\n-                    })\n-                    .filter(|(t, _)| {\n-                        !matches!(\n-                            t.kind,\n-                            TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n-                        )\n-                    })\n-                    .map(|(_, s)| s);\n-                let mut right_pos = 0;\n-                let right = tokenize(&right)\n-                    .map(|t| {\n-                        let end = right_pos + t.len as usize;\n-                        let s = &right[right_pos..end];\n-                        right_pos = end;\n-                        (t, s)\n-                    })\n-                    .filter(|(t, _)| {\n-                        !matches!(\n-                            t.kind,\n-                            TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n-                        )\n-                    })\n-                    .map(|(_, s)| s);\n-                left.eq(right)\n-            },\n-            _ => {\n-                over(left.stmts, right.stmts, |l, r| self.eq_stmt(l, r))\n-                    && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n-            },\n+        use TokenKind::{BlockComment, LineComment, Semi, Whitespace};\n+        if left.stmts.len() != right.stmts.len() {\n+            return false;\n+        }\n+        let lspan = left.span.data();\n+        let rspan = right.span.data();\n+        if lspan.ctxt != SyntaxContext::root() && rspan.ctxt != SyntaxContext::root() {\n+            // Don't try to check in between statements inside macros.\n+            return over(left.stmts, right.stmts, |left, right| self.eq_stmt(left, right))\n+                && both(&left.expr, &right.expr, |left, right| self.eq_expr(left, right));\n+        }\n+        if lspan.ctxt != rspan.ctxt {\n+            return false;\n         }\n+\n+        let mut lstart = lspan.lo;\n+        let mut rstart = rspan.lo;\n+\n+        for (left, right) in left.stmts.iter().zip(right.stmts) {\n+            if !self.eq_stmt(left, right) {\n+                return false;\n+            }\n+\n+            // Try to detect any `cfg`ed statements or empty macro expansions.\n+            let Some(lstmt_span) = walk_span_to_context(left.span, lspan.ctxt) else {\n+                return false;\n+            };\n+            let Some(rstmt_span) = walk_span_to_context(right.span, rspan.ctxt) else {\n+                return false;\n+            };\n+            let lstmt_span = lstmt_span.data();\n+            let rstmt_span = rstmt_span.data();\n+\n+            if lstmt_span.lo < lstart && rstmt_span.lo < rstart {\n+                // Can happen when macros expand to multiple statements, or rearrange statements.\n+                // Nothing in between the statements to check in this case.\n+                continue;\n+            }\n+            if lstmt_span.lo < lstart || rstmt_span.lo < rstart {\n+                // Only one of the blocks had a weird macro.\n+                return false;\n+            }\n+            if !eq_span_tokens(self.inner.cx, lstart..lstmt_span.lo, rstart..rstmt_span.lo, |t| {\n+                !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. } | Semi)\n+            }) {\n+                return false;\n+            }\n+\n+            lstart = lstmt_span.hi;\n+            rstart = rstmt_span.hi;\n+        }\n+\n+        let (lend, rend) = match (left.expr, right.expr) {\n+            (Some(left), Some(right)) => {\n+                if !self.eq_expr(left, right) {\n+                    return false;\n+                }\n+                let Some(lexpr_span) = walk_span_to_context(left.span, lspan.ctxt) else {\n+                    return false;\n+                };\n+                let Some(rexpr_span) = walk_span_to_context(right.span, rspan.ctxt) else {\n+                    return false;\n+                };\n+                (lexpr_span.lo(), rexpr_span.lo())\n+            },\n+            (None, None) => (lspan.hi, rspan.hi),\n+            (Some(_), None) | (None, Some(_)) => return false,\n+        };\n+\n+        if lend < lstart && rend < rstart {\n+            // Can happen when macros rearrange the input.\n+            // Nothing in between the statements to check in this case.\n+            return true;\n+        } else if lend < lstart || rend < rstart {\n+            // Only one of the blocks had a weird macro\n+            return false;\n+        }\n+        eq_span_tokens(self.inner.cx, lstart..lend, rstart..rend, |t| {\n+            !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. } | Semi)\n+        })\n     }\n \n     fn should_ignore(&mut self, expr: &Expr<'_>) -> bool {\n@@ -207,7 +249,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     #[expect(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.inner.allow_side_effects && left.span.ctxt() != right.span.ctxt() {\n+        if !self.check_ctxt(left.span.ctxt(), right.span.ctxt()) {\n             return false;\n         }\n \n@@ -440,6 +482,45 @@ impl HirEqInterExpr<'_, '_, '_> {\n     fn eq_type_binding(&mut self, left: &TypeBinding<'_>, right: &TypeBinding<'_>) -> bool {\n         left.ident.name == right.ident.name && self.eq_ty(left.ty(), right.ty())\n     }\n+\n+    fn check_ctxt(&mut self, left: SyntaxContext, right: SyntaxContext) -> bool {\n+        if self.left_ctxt == left && self.right_ctxt == right {\n+            return true;\n+        } else if self.left_ctxt == left || self.right_ctxt == right {\n+            // Only one context has changed. This can only happen if the two nodes are written differently.\n+            return false;\n+        } else if left != SyntaxContext::root() {\n+            let mut left_data = left.outer_expn_data();\n+            let mut right_data = right.outer_expn_data();\n+            loop {\n+                use TokenKind::{BlockComment, LineComment, Whitespace};\n+                if left_data.macro_def_id != right_data.macro_def_id\n+                    || (matches!(left_data.kind, ExpnKind::Macro(MacroKind::Bang, name) if name == sym::cfg)\n+                        && !eq_span_tokens(self.inner.cx, left_data.call_site, right_data.call_site, |t| {\n+                            !matches!(t, Whitespace | LineComment { .. } | BlockComment { .. })\n+                        }))\n+                {\n+                    // Either a different chain of macro calls, or different arguments to the `cfg` macro.\n+                    return false;\n+                }\n+                let left_ctxt = left_data.call_site.ctxt();\n+                let right_ctxt = right_data.call_site.ctxt();\n+                if left_ctxt == SyntaxContext::root() && right_ctxt == SyntaxContext::root() {\n+                    break;\n+                }\n+                if left_ctxt == SyntaxContext::root() || right_ctxt == SyntaxContext::root() {\n+                    // Different lengths for the expansion stack. This can only happen if nodes are written differently,\n+                    // or shouldn't be compared to start with.\n+                    return false;\n+                }\n+                left_data = left_ctxt.outer_expn_data();\n+                right_data = right_ctxt.outer_expn_data();\n+            }\n+        }\n+        self.left_ctxt = left;\n+        self.right_ctxt = right;\n+        true\n+    }\n }\n \n /// Some simple reductions like `{ return }` => `return`\n@@ -1038,3 +1119,34 @@ pub fn hash_expr(cx: &LateContext<'_>, e: &Expr<'_>) -> u64 {\n     h.hash_expr(e);\n     h.finish()\n }\n+\n+#[expect(clippy::similar_names)]\n+fn eq_span_tokens(\n+    cx: &LateContext<'_>,\n+    left: impl SpanRange,\n+    right: impl SpanRange,\n+    pred: impl Fn(TokenKind) -> bool,\n+) -> bool {\n+    fn f(cx: &LateContext<'_>, left: Range<BytePos>, right: Range<BytePos>, pred: impl Fn(TokenKind) -> bool) -> bool {\n+        if let Some(lsrc) = get_source_text(cx, left)\n+            && let Some(lsrc) = lsrc.as_str()\n+            && let Some(rsrc) = get_source_text(cx, right)\n+            && let Some(rsrc) = rsrc.as_str()\n+        {\n+            let pred = |t: &(_, _)| pred(t.0);\n+            let map = |(_, x)| x;\n+\n+            let ltok = tokenize_with_text(lsrc)\n+                .filter(pred)\n+                .map(map);\n+            let rtok = tokenize_with_text(rsrc)\n+                .filter(pred)\n+                .map(map);\n+            ltok.eq(rtok)\n+        } else {\n+            // Unable to access the source. Conservatively assume the blocks aren't equal.\n+            false\n+        }\n+    }\n+    f(cx, left.into_range(), right.into_range(), pred)\n+}"}, {"sha": "575c29a6b6f97f3b6783ab84bd5c26daf53e338a", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,5 +1,6 @@\n #![feature(array_chunks)]\n #![feature(box_patterns)]\n+#![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(lint_reasons)]\n #![feature(never_type)]\n@@ -76,6 +77,7 @@ use std::sync::OnceLock;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n+use itertools::Itertools;\n use rustc_ast::ast::{self, LitKind, RangeLimits};\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n@@ -282,6 +284,15 @@ pub fn is_wild(pat: &Pat<'_>) -> bool {\n     matches!(pat.kind, PatKind::Wild)\n }\n \n+/// Checks if the given `QPath` belongs to a type alias.\n+pub fn is_ty_alias(qpath: &QPath<'_>) -> bool {\n+    match *qpath {\n+        QPath::Resolved(_, path) => matches!(path.res, Res::Def(DefKind::TyAlias, ..)),\n+        QPath::TypeRelative(ty, _) if let TyKind::Path(qpath) = ty.kind => { is_ty_alias(&qpath) },\n+        _ => false,\n+    }\n+}\n+\n /// Checks if the method call given in `expr` belongs to the given trait.\n /// This is a deprecated function, consider using [`is_trait_method`].\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n@@ -1488,7 +1499,7 @@ pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Opti\n                 && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, min_val.to_valtree()))\n                 && let min_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n                 && let Some(min_const) = miri_to_const(cx.tcx, min_const_kind)\n-                && let Some((start_const, _)) = constant(cx, cx.typeck_results(), start)\n+                && let Some(start_const) = constant(cx, cx.typeck_results(), start)\n             {\n                 start_const == min_const\n             } else {\n@@ -1504,7 +1515,7 @@ pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Opti\n                         && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, max_val.to_valtree()))\n                         && let max_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n                         && let Some(max_const) = miri_to_const(cx.tcx, max_const_kind)\n-                        && let Some((end_const, _)) = constant(cx, cx.typeck_results(), end)\n+                        && let Some(end_const) = constant(cx, cx.typeck_results(), end)\n                     {\n                         end_const == max_const\n                     } else {\n@@ -1536,7 +1547,7 @@ pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool\n         return true;\n     }\n     let enclosing_body = cx.tcx.hir().enclosing_body_owner(e.hir_id);\n-    if let Some((Constant::Int(v), _)) = constant(cx, cx.tcx.typeck(enclosing_body), e) {\n+    if let Some(Constant::Int(v)) = constant(cx, cx.tcx.typeck(enclosing_body), e) {\n         return value == v;\n     }\n     false\n@@ -2480,6 +2491,17 @@ pub fn walk_to_expr_usage<'tcx, T>(\n     None\n }\n \n+/// Tokenizes the input while keeping the text associated with each token.\n+pub fn tokenize_with_text(s: &str) -> impl Iterator<Item = (TokenKind, &str)> {\n+    let mut pos = 0;\n+    tokenize(s).map(move |t| {\n+        let end = pos + t.len;\n+        let range = pos as usize..end as usize;\n+        pos = end;\n+        (t.kind, s.get(range).unwrap_or_default())\n+    })\n+}\n+\n /// Checks whether a given span has any comment token\n /// This checks for all types of comment: line \"//\", block \"/**\", doc \"///\" \"//!\"\n pub fn span_contains_comment(sm: &SourceMap, span: Span) -> bool {\n@@ -2496,23 +2518,11 @@ pub fn span_contains_comment(sm: &SourceMap, span: Span) -> bool {\n /// Comments are returned wrapped with their relevant delimiters\n pub fn span_extract_comment(sm: &SourceMap, span: Span) -> String {\n     let snippet = sm.span_to_snippet(span).unwrap_or_default();\n-    let mut comments_buf: Vec<String> = Vec::new();\n-    let mut index: usize = 0;\n-\n-    for token in tokenize(&snippet) {\n-        let token_range = index..(index + token.len as usize);\n-        index += token.len as usize;\n-        match token.kind {\n-            TokenKind::BlockComment { .. } | TokenKind::LineComment { .. } => {\n-                if let Some(comment) = snippet.get(token_range) {\n-                    comments_buf.push(comment.to_string());\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    comments_buf.join(\"\\n\")\n+    let res = tokenize_with_text(&snippet)\n+        .filter(|(t, _)| matches!(t, TokenKind::BlockComment { .. } | TokenKind::LineComment { .. }))\n+        .map(|(_, s)| s)\n+        .join(\"\\n\");\n+    res\n }\n \n pub fn span_find_starting_semi(sm: &SourceMap, span: Span) -> Span {"}, {"sha": "0f60290644a18daba5232f76b4502961756e57d5", "filename": "src/tools/clippy/clippy_utils/src/source.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -2,14 +2,64 @@\n \n #![allow(clippy::module_name_repetitions)]\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_session::Session;\n-use rustc_span::hygiene;\n use rustc_span::source_map::{original_sp, SourceMap};\n+use rustc_span::{hygiene, SourceFile};\n use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext, DUMMY_SP};\n use std::borrow::Cow;\n+use std::ops::Range;\n+\n+/// A type which can be converted to the range portion of a `Span`.\n+pub trait SpanRange {\n+    fn into_range(self) -> Range<BytePos>;\n+}\n+impl SpanRange for Span {\n+    fn into_range(self) -> Range<BytePos> {\n+        let data = self.data();\n+        data.lo..data.hi\n+    }\n+}\n+impl SpanRange for SpanData {\n+    fn into_range(self) -> Range<BytePos> {\n+        self.lo..self.hi\n+    }\n+}\n+impl SpanRange for Range<BytePos> {\n+    fn into_range(self) -> Range<BytePos> {\n+        self\n+    }\n+}\n+\n+pub struct SourceFileRange {\n+    pub sf: Lrc<SourceFile>,\n+    pub range: Range<usize>,\n+}\n+impl SourceFileRange {\n+    /// Attempts to get the text from the source file. This can fail if the source text isn't\n+    /// loaded.\n+    pub fn as_str(&self) -> Option<&str> {\n+        self.sf.src.as_ref().and_then(|x| x.get(self.range.clone()))\n+    }\n+}\n+\n+/// Gets the source file, and range in the file, of the given span. Returns `None` if the span\n+/// extends through multiple files, or is malformed.\n+pub fn get_source_text(cx: &impl LintContext, sp: impl SpanRange) -> Option<SourceFileRange> {\n+    fn f(sm: &SourceMap, sp: Range<BytePos>) -> Option<SourceFileRange> {\n+        let start = sm.lookup_byte_offset(sp.start);\n+        let end = sm.lookup_byte_offset(sp.end);\n+        if !Lrc::ptr_eq(&start.sf, &end.sf) || start.pos > end.pos {\n+            return None;\n+        }\n+        let range = start.pos.to_usize()..end.pos.to_usize();\n+        Some(SourceFileRange { sf: start.sf, range })\n+    }\n+    f(cx.sess().source_map(), sp.into_range())\n+}\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n pub fn expr_block<T: LintContext>("}, {"sha": "bc7fb711ed8b8f8ee63c995f52c49dde2ecf8318", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-05-05\"\n+channel = \"nightly-2023-05-20\"\n components = [\"cargo\", \"llvm-tools\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "99ce7028390943396480e23b7a7439625bd76524", "filename": "src/tools/clippy/tests/ui-internal/custom_ice_message.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcustom_ice_message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcustom_ice_message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcustom_ice_message.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -3,6 +3,7 @@\n //@normalize-stderr-test: \"produce_ice.rs:\\d*:\\d*\" -> \"produce_ice.rs\"\n //@normalize-stderr-test: \"', .*clippy_lints\" -> \"', clippy_lints\"\n //@normalize-stderr-test: \"'rustc'\" -> \"'<unnamed>'\"\n+//@normalize-stderr-test: \"running on .*\" -> \"running on <target>\"\n //@normalize-stderr-test: \"(?ms)query stack during panic:\\n.*end of query stack\\n\" -> \"\"\n \n #![deny(clippy::internal)]"}, {"sha": "0fc385cd6935aa7a5fdedf85cab2e87f24f908d0", "filename": "src/tools/clippy/tests/ui-internal/custom_ice_message.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcustom_ice_message.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,12 +1,14 @@\n thread '<unnamed>' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints/produce_ice.rs\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n+error: the compiler unexpectedly panicked. this is a bug.\n \n note: we would appreciate a bug report: https://github.com/rust-lang/rust-clippy/issues/new\n \n+note: rustc 1.71.0-nightly (521f4dae1 2023-05-19) running on <target>\n+\n+note: compiler flags: -C prefer-dynamic -Z ui-testing\n+\n note: Clippy version: foo\n \n thread panicked while panicking. aborting."}, {"sha": "f95af1017bcbbfc01efcd64fa1466a0dd915d6ac", "filename": "src/tools/clippy/tests/ui/arithmetic_side_effects.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Farithmetic_side_effects.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -458,4 +458,12 @@ pub fn issue_10583(a: u16) -> u16 {\n     10 / a\n }\n \n+pub fn issue_10767() {\n+    let n = &1.0;\n+    n + n;\n+    3.1_f32 + &1.2_f32;\n+    &3.4_f32 + 1.5_f32;\n+    &3.5_f32 + &1.3_f32;\n+}\n+\n fn main() {}"}, {"sha": "755264617920eb5385523b0e93a5bb918f3a3e6c", "filename": "src/tools/clippy/tests/ui/borrow_deref_ref.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,7 +1,11 @@\n //@run-rustfix\n+//@aux-build: proc_macros.rs\n \n #![allow(dead_code, unused_variables)]\n \n+extern crate proc_macros;\n+use proc_macros::with_span;\n+\n fn main() {}\n \n mod should_lint {\n@@ -47,6 +51,17 @@ mod should_not_lint2 {\n     }\n }\n \n+with_span!(\n+    span\n+\n+    fn just_returning(x: &u32) -> &u32 {\n+        x\n+    }\n+\n+    fn dont_lint_proc_macro() {\n+        let a = &mut &*just_returning(&12);\n+    }\n+);\n // this mod explains why we should not lint `& &* (&T)`\n mod false_negative {\n     fn foo() {"}, {"sha": "e319d365f7e77f283ca9e43f3f8989c75cd35138", "filename": "src/tools/clippy/tests/ui/borrow_deref_ref.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,7 +1,11 @@\n //@run-rustfix\n+//@aux-build: proc_macros.rs\n \n #![allow(dead_code, unused_variables)]\n \n+extern crate proc_macros;\n+use proc_macros::with_span;\n+\n fn main() {}\n \n mod should_lint {\n@@ -47,6 +51,17 @@ mod should_not_lint2 {\n     }\n }\n \n+with_span!(\n+    span\n+\n+    fn just_returning(x: &u32) -> &u32 {\n+        x\n+    }\n+\n+    fn dont_lint_proc_macro() {\n+        let a = &mut &*just_returning(&12);\n+    }\n+);\n // this mod explains why we should not lint `& &* (&T)`\n mod false_negative {\n     fn foo() {"}, {"sha": "1e47cda6796019d05627f364a9fc2a78f5b623d6", "filename": "src/tools/clippy/tests/ui/borrow_deref_ref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_deref_ref.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,19 +1,19 @@\n error: deref on an immutable reference\n-  --> $DIR/borrow_deref_ref.rs:10:17\n+  --> $DIR/borrow_deref_ref.rs:14:17\n    |\n LL |         let b = &*a;\n    |                 ^^^ help: if you would like to reborrow, try removing `&*`: `a`\n    |\n    = note: `-D clippy::borrow-deref-ref` implied by `-D warnings`\n \n error: deref on an immutable reference\n-  --> $DIR/borrow_deref_ref.rs:12:22\n+  --> $DIR/borrow_deref_ref.rs:16:22\n    |\n LL |         let b = &mut &*bar(&12);\n    |                      ^^^^^^^^^^ help: if you would like to reborrow, try removing `&*`: `bar(&12)`\n \n error: deref on an immutable reference\n-  --> $DIR/borrow_deref_ref.rs:55:23\n+  --> $DIR/borrow_deref_ref.rs:70:23\n    |\n LL |         let addr_y = &&*x as *const _ as usize; // assert ok\n    |                       ^^^ help: if you would like to reborrow, try removing `&*`: `x`"}, {"sha": "840902b5323e771aa9468e6e86a36b35e46737e9", "filename": "src/tools/clippy/tests/ui/box_default.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -35,6 +35,13 @@ fn main() {\n     let _more = ret_ty_fn();\n     call_ty_fn(Box::default());\n     issue_10381();\n+\n+    // `Box::<Option<_>>::default()` would be valid here, but not `Box::default()` or\n+    // `Box::<Option<[closure@...]>::default()`\n+    //\n+    // Would have a suggestion after https://github.com/rust-lang/rust/blob/fdd030127cc68afec44a8d3f6341525dd34e50ae/compiler/rustc_middle/src/ty/diagnostics.rs#L554-L563\n+    let mut unnameable = Box::new(Option::default());\n+    let _ = unnameable.insert(|| {});\n }\n \n fn ret_ty_fn() -> Box<bool> {"}, {"sha": "3618486a4732e531f0f34d38cad76800feef531b", "filename": "src/tools/clippy/tests/ui/box_default.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -35,6 +35,13 @@ fn main() {\n     let _more = ret_ty_fn();\n     call_ty_fn(Box::new(u8::default()));\n     issue_10381();\n+\n+    // `Box::<Option<_>>::default()` would be valid here, but not `Box::default()` or\n+    // `Box::<Option<[closure@...]>::default()`\n+    //\n+    // Would have a suggestion after https://github.com/rust-lang/rust/blob/fdd030127cc68afec44a8d3f6341525dd34e50ae/compiler/rustc_middle/src/ty/diagnostics.rs#L554-L563\n+    let mut unnameable = Box::new(Option::default());\n+    let _ = unnameable.insert(|| {});\n }\n \n fn ret_ty_fn() -> Box<bool> {"}, {"sha": "13dfc5ae48a22f7e9acf1bfb9aa99d1e91406ef1", "filename": "src/tools/clippy/tests/ui/box_default.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -73,25 +73,25 @@ LL |     call_ty_fn(Box::new(u8::default()));\n    |                ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:41:5\n+  --> $DIR/box_default.rs:48:5\n    |\n LL |     Box::new(bool::default())\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<bool>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:58:28\n+  --> $DIR/box_default.rs:65:28\n    |\n LL |     let _: Box<dyn Read> = Box::new(ImplementsDefault::default());\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<ImplementsDefault>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:67:17\n+  --> $DIR/box_default.rs:74:17\n    |\n LL |         let _ = Box::new(WeirdPathed::default());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<WeirdPathed>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:79:18\n+  --> $DIR/box_default.rs:86:18\n    |\n LL |             Some(Box::new(Foo::default()))\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<Foo>::default()`"}, {"sha": "c6514a559340ceeb61e54aa43b1f4c32ba8b7451", "filename": "src/tools/clippy/tests/ui/collapsible_if.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,5 +1,10 @@\n //@run-rustfix\n-#![allow(clippy::assertions_on_constants, clippy::equatable_if_let)]\n+#![allow(\n+    clippy::assertions_on_constants,\n+    clippy::equatable_if_let,\n+    clippy::nonminimal_bool,\n+    clippy::eq_op\n+)]\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]"}, {"sha": "2c85b68df632c8209cd1b56104d59c3ddcf4bdf4", "filename": "src/tools/clippy/tests/ui/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,5 +1,10 @@\n //@run-rustfix\n-#![allow(clippy::assertions_on_constants, clippy::equatable_if_let)]\n+#![allow(\n+    clippy::assertions_on_constants,\n+    clippy::equatable_if_let,\n+    clippy::nonminimal_bool,\n+    clippy::eq_op\n+)]\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]"}, {"sha": "c687bae1acc524b033abda01444080b19958b9b1", "filename": "src/tools/clippy/tests/ui/collapsible_if.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,5 +1,5 @@\n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:9:5\n+  --> $DIR/collapsible_if.rs:14:5\n    |\n LL | /     if x == \"hello\" {\n LL | |         if y == \"world\" {\n@@ -17,7 +17,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:15:5\n+  --> $DIR/collapsible_if.rs:20:5\n    |\n LL | /     if x == \"hello\" || x == \"world\" {\n LL | |         if y == \"world\" || y == \"hello\" {\n@@ -34,7 +34,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:21:5\n+  --> $DIR/collapsible_if.rs:26:5\n    |\n LL | /     if x == \"hello\" && x == \"world\" {\n LL | |         if y == \"world\" || y == \"hello\" {\n@@ -51,7 +51,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:27:5\n+  --> $DIR/collapsible_if.rs:32:5\n    |\n LL | /     if x == \"hello\" || x == \"world\" {\n LL | |         if y == \"world\" && y == \"hello\" {\n@@ -68,7 +68,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:33:5\n+  --> $DIR/collapsible_if.rs:38:5\n    |\n LL | /     if x == \"hello\" && x == \"world\" {\n LL | |         if y == \"world\" && y == \"hello\" {\n@@ -85,7 +85,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:39:5\n+  --> $DIR/collapsible_if.rs:44:5\n    |\n LL | /     if 42 == 1337 {\n LL | |         if 'a' != 'A' {\n@@ -102,7 +102,7 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:95:5\n+  --> $DIR/collapsible_if.rs:100:5\n    |\n LL | /     if x == \"hello\" {\n LL | |         if y == \"world\" { // Collapsible\n@@ -119,15 +119,15 @@ LL +     }\n    |\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:154:5\n+  --> $DIR/collapsible_if.rs:159:5\n    |\n LL | /     if matches!(true, true) {\n LL | |         if matches!(true, true) {}\n LL | |     }\n    | |_____^ help: collapse nested if block: `if matches!(true, true) && matches!(true, true) {}`\n \n error: this `if` statement can be collapsed\n-  --> $DIR/collapsible_if.rs:159:5\n+  --> $DIR/collapsible_if.rs:164:5\n    |\n LL | /     if matches!(true, true) && truth() {\n LL | |         if matches!(true, true) {}"}, {"sha": "10788d4048164576db1953db18cc8fb1c26ab5b4", "filename": "src/tools/clippy/tests/ui/dbg_macro.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdbg_macro.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -4,6 +4,7 @@\n fn foo(n: u32) -> u32 {\n     if let Some(n) = dbg!(n.checked_sub(4)) { n } else { n }\n }\n+fn bar(_: ()) {}\n \n fn factorial(n: u32) -> u32 {\n     if dbg!(n <= 1) {\n@@ -21,6 +22,32 @@ fn main() {\n     dbg!(1, 2, 3, 4, 5);\n }\n \n+fn issue9914() {\n+    macro_rules! foo {\n+        ($x:expr) => {\n+            $x;\n+        };\n+    }\n+    macro_rules! foo2 {\n+        ($x:expr) => {\n+            $x;\n+        };\n+    }\n+    macro_rules! expand_to_dbg {\n+        () => {\n+            dbg!();\n+        };\n+    }\n+\n+    dbg!();\n+    #[allow(clippy::let_unit_value)]\n+    let _ = dbg!();\n+    bar(dbg!());\n+    foo!(dbg!());\n+    foo2!(foo!(dbg!()));\n+    expand_to_dbg!();\n+}\n+\n mod issue7274 {\n     trait Thing<'b> {\n         fn foo(&self);"}, {"sha": "530e766331777dd24c074c129ec962e8289953ba", "filename": "src/tools/clippy/tests/ui/dbg_macro.stderr", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdbg_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdbg_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdbg_macro.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -11,7 +11,7 @@ LL |     if let Some(n) = n.checked_sub(4) { n } else { n }\n    |                      ~~~~~~~~~~~~~~~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:9:8\n+  --> $DIR/dbg_macro.rs:10:8\n    |\n LL |     if dbg!(n <= 1) {\n    |        ^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ LL |     if n <= 1 {\n    |        ~~~~~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:10:9\n+  --> $DIR/dbg_macro.rs:11:9\n    |\n LL |         dbg!(1)\n    |         ^^^^^^^\n@@ -33,7 +33,7 @@ LL |         1\n    |\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:12:9\n+  --> $DIR/dbg_macro.rs:13:9\n    |\n LL |         dbg!(n * factorial(n - 1))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL |         n * factorial(n - 1)\n    |\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:17:5\n+  --> $DIR/dbg_macro.rs:18:5\n    |\n LL |     dbg!(42);\n    |     ^^^^^^^^\n@@ -55,7 +55,7 @@ LL |     42;\n    |     ~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:18:5\n+  --> $DIR/dbg_macro.rs:19:5\n    |\n LL |     dbg!(dbg!(dbg!(42)));\n    |     ^^^^^^^^^^^^^^^^^^^^\n@@ -66,7 +66,7 @@ LL |     dbg!(dbg!(42));\n    |     ~~~~~~~~~~~~~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:19:14\n+  --> $DIR/dbg_macro.rs:20:14\n    |\n LL |     foo(3) + dbg!(factorial(4));\n    |              ^^^^^^^^^^^^^^^^^^\n@@ -77,7 +77,7 @@ LL |     foo(3) + factorial(4);\n    |              ~~~~~~~~~~~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:20:5\n+  --> $DIR/dbg_macro.rs:21:5\n    |\n LL |     dbg!(1, 2, dbg!(3, 4));\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -88,7 +88,7 @@ LL |     (1, 2, dbg!(3, 4));\n    |     ~~~~~~~~~~~~~~~~~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:21:5\n+  --> $DIR/dbg_macro.rs:22:5\n    |\n LL |     dbg!(1, 2, 3, 4, 5);\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -99,7 +99,63 @@ LL |     (1, 2, 3, 4, 5);\n    |     ~~~~~~~~~~~~~~~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:41:9\n+  --> $DIR/dbg_macro.rs:42:5\n+   |\n+LL |     dbg!();\n+   |     ^^^^^^^\n+   |\n+help: remove the invocation before committing it to a version control system\n+   |\n+LL -     dbg!();\n+LL +     \n+   |\n+\n+error: the `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:44:13\n+   |\n+LL |     let _ = dbg!();\n+   |             ^^^^^^\n+   |\n+help: remove the invocation before committing it to a version control system\n+   |\n+LL |     let _ = ();\n+   |             ~~\n+\n+error: the `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:45:9\n+   |\n+LL |     bar(dbg!());\n+   |         ^^^^^^\n+   |\n+help: remove the invocation before committing it to a version control system\n+   |\n+LL |     bar(());\n+   |         ~~\n+\n+error: the `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:46:10\n+   |\n+LL |     foo!(dbg!());\n+   |          ^^^^^^\n+   |\n+help: remove the invocation before committing it to a version control system\n+   |\n+LL |     foo!(());\n+   |          ~~\n+\n+error: the `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:47:16\n+   |\n+LL |     foo2!(foo!(dbg!()));\n+   |                ^^^^^^\n+   |\n+help: remove the invocation before committing it to a version control system\n+   |\n+LL |     foo2!(foo!(()));\n+   |                ~~\n+\n+error: the `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:68:9\n    |\n LL |         dbg!(2);\n    |         ^^^^^^^\n@@ -110,7 +166,7 @@ LL |         2;\n    |         ~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:47:5\n+  --> $DIR/dbg_macro.rs:74:5\n    |\n LL |     dbg!(1);\n    |     ^^^^^^^\n@@ -121,7 +177,7 @@ LL |     1;\n    |     ~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:52:5\n+  --> $DIR/dbg_macro.rs:79:5\n    |\n LL |     dbg!(1);\n    |     ^^^^^^^\n@@ -132,7 +188,7 @@ LL |     1;\n    |     ~\n \n error: the `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:58:9\n+  --> $DIR/dbg_macro.rs:85:9\n    |\n LL |         dbg!(1);\n    |         ^^^^^^^\n@@ -142,5 +198,5 @@ help: remove the invocation before committing it to a version control system\n LL |         1;\n    |         ~\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 18 previous errors\n "}, {"sha": "e1012f38bba2adafee4cad0adb715e37e02ff2da", "filename": "src/tools/clippy/tests/ui/default_constructed_unit_structs.fixed", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -105,6 +105,7 @@ fn main() {\n     // should lint\n     let _ = PhantomData::<usize>;\n     let _: PhantomData<i32> = PhantomData;\n+    let _: PhantomData<i32> = std::marker::PhantomData;\n     let _ = UnitStruct;\n \n     // should not lint\n@@ -116,4 +117,21 @@ fn main() {\n     let _ = EmptyStruct::default();\n     let _ = FakeDefault::default();\n     let _ = <FakeDefault as Default>::default();\n+\n+    macro_rules! in_macro {\n+        ($i:ident) => {{\n+            let _ = UnitStruct::default();\n+            let _ = $i::default();\n+        }};\n+    }\n+\n+    in_macro!(UnitStruct);\n+\n+    macro_rules! struct_from_macro {\n+        () => {\n+            UnitStruct\n+        };\n+    }\n+\n+    let _ = <struct_from_macro!()>::default();\n }"}, {"sha": "c7b4313dbf0c92fdb9d5222acba3a19f78516b37", "filename": "src/tools/clippy/tests/ui/default_constructed_unit_structs.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -105,6 +105,7 @@ fn main() {\n     // should lint\n     let _ = PhantomData::<usize>::default();\n     let _: PhantomData<i32> = PhantomData::default();\n+    let _: PhantomData<i32> = std::marker::PhantomData::default();\n     let _ = UnitStruct::default();\n \n     // should not lint\n@@ -116,4 +117,21 @@ fn main() {\n     let _ = EmptyStruct::default();\n     let _ = FakeDefault::default();\n     let _ = <FakeDefault as Default>::default();\n+\n+    macro_rules! in_macro {\n+        ($i:ident) => {{\n+            let _ = UnitStruct::default();\n+            let _ = $i::default();\n+        }};\n+    }\n+\n+    in_macro!(UnitStruct);\n+\n+    macro_rules! struct_from_macro {\n+        () => {\n+            UnitStruct\n+        };\n+    }\n+\n+    let _ = <struct_from_macro!()>::default();\n }"}, {"sha": "61a32fb10e53b0ca39568d4ffc49e8f4f20983e2", "filename": "src/tools/clippy/tests/ui/default_constructed_unit_structs.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -25,10 +25,16 @@ LL |     let _: PhantomData<i32> = PhantomData::default();\n    |                                          ^^^^^^^^^^^ help: remove this call to `default`\n \n error: use of `default` to create a unit struct\n-  --> $DIR/default_constructed_unit_structs.rs:108:23\n+  --> $DIR/default_constructed_unit_structs.rs:108:55\n+   |\n+LL |     let _: PhantomData<i32> = std::marker::PhantomData::default();\n+   |                                                       ^^^^^^^^^^^ help: remove this call to `default`\n+\n+error: use of `default` to create a unit struct\n+  --> $DIR/default_constructed_unit_structs.rs:109:23\n    |\n LL |     let _ = UnitStruct::default();\n    |                       ^^^^^^^^^^^ help: remove this call to `default`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "e843770f578543465a47b900709493647e758b6b", "filename": "src/tools/clippy/tests/ui/empty_line_after_doc_comments.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_line_after_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_line_after_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_line_after_doc_comments.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,132 @@\n+//@aux-build:proc_macro_attr.rs\n+#![warn(clippy::empty_line_after_doc_comments)]\n+#![allow(clippy::assertions_on_constants)]\n+#![feature(custom_inner_attributes)]\n+#![rustfmt::skip]\n+\n+#[macro_use]\n+extern crate proc_macro_attr;\n+\n+mod some_mod {\n+    //! This doc comment should *NOT* produce a warning\n+\n+    mod some_inner_mod {\n+        fn some_noop() {}\n+    }\n+}\n+\n+/// This should produce a warning\n+\n+fn with_doc_and_newline() { assert!(true)}\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+\n+/// some comment\n+fn with_one_newline_and_comment() { assert!(true) }\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+/// some comment\n+fn with_no_newline_and_comment() { assert!(true) }\n+\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+\n+fn with_one_newline() { assert!(true) }\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+\n+\n+fn with_two_newlines() { assert!(true) }\n+\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+\n+enum Baz {\n+    One,\n+    Two\n+}\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+\n+struct Foo {\n+    one: isize,\n+    two: isize\n+}\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+\n+mod foo {\n+}\n+\n+/// This doc comment should produce a warning\n+\n+/** This is also a doc comment and should produce a warning\n+ */\n+\n+// This should *NOT* produce a warning\n+#[allow(non_camel_case_types)]\n+#[allow(missing_docs)]\n+#[allow(missing_docs)]\n+fn three_attributes() { assert!(true) }\n+\n+// This should *NOT* produce a warning\n+#[doc = \"\n+Returns the escaped value of the textual representation of\n+\n+\"]\n+pub fn function() -> bool {\n+    true\n+}\n+\n+// This should *NOT* produce a warning\n+#[derive(Clone, Copy)]\n+pub enum FooFighter {\n+    Bar1,\n+\n+    Bar2,\n+\n+    Bar3,\n+\n+    Bar4\n+}\n+\n+// This should *NOT* produce a warning because the empty line is inside a block comment\n+#[crate_type = \"lib\"]\n+/*\n+\n+*/\n+pub struct S;\n+\n+// This should *NOT* produce a warning\n+#[crate_type = \"lib\"]\n+/* test */\n+pub struct T;\n+\n+// This should *NOT* produce a warning\n+// See https://github.com/rust-lang/rust-clippy/issues/5567\n+#[fake_async_trait]\n+pub trait Bazz {\n+    fn foo() -> Vec<u8> {\n+        let _i = \"\";\n+\n+\n+\n+        vec![]\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+#[dummy(string = \"first line\n+\n+second line\n+\")]\n+pub struct Args;\n+\n+fn main() {}"}, {"sha": "2ca1b51679ed132e4f1c362f5d14d9adf022dfb1", "filename": "src/tools/clippy/tests/ui/empty_line_after_doc_comments.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_line_after_doc_comments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_line_after_doc_comments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_line_after_doc_comments.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,36 @@\n+error: found an empty line after a doc comment. Perhaps you need to use `//!` to make a comment on a module, remove the empty line, or make a regular comment with `//`?\n+  --> $DIR/empty_line_after_doc_comments.rs:18:1\n+   |\n+LL | / /// This should produce a warning\n+LL | |\n+LL | | fn with_doc_and_newline() { assert!(true)}\n+   | |_\n+   |\n+   = note: `-D clippy::empty-line-after-doc-comments` implied by `-D warnings`\n+\n+error: found an empty line after a doc comment. Perhaps you need to use `//!` to make a comment on a module, remove the empty line, or make a regular comment with `//`?\n+  --> $DIR/empty_line_after_doc_comments.rs:68:1\n+   |\n+LL | / /// This doc comment should produce a warning\n+LL | |\n+LL | | /** This is also a doc comment and should produce a warning\n+LL | |  */\n+...  |\n+LL | | #[allow(missing_docs)]\n+LL | | fn three_attributes() { assert!(true) }\n+   | |_\n+\n+error: found an empty line after a doc comment. Perhaps you need to use `//!` to make a comment on a module, remove the empty line, or make a regular comment with `//`?\n+  --> $DIR/empty_line_after_doc_comments.rs:70:1\n+   |\n+LL | / /** This is also a doc comment and should produce a warning\n+LL | |  */\n+LL | |\n+LL | | // This should *NOT* produce a warning\n+...  |\n+LL | | #[allow(missing_docs)]\n+LL | | fn three_attributes() { assert!(true) }\n+   | |_\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "a928c35e8bc9934c7c8b54885e760dee1b1ec0b7", "filename": "src/tools/clippy/tests/ui/float_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloat_arithmetic.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,4 +1,4 @@\n-#![warn(clippy::integer_arithmetic, clippy::float_arithmetic)]\n+#![warn(clippy::arithmetic_side_effects, clippy::float_arithmetic)]\n #![allow(\n     unused,\n     clippy::shadow_reuse,"}, {"sha": "ab9b6094c2c1d153adab746cee20e995ece8cf86", "filename": "src/tools/clippy/tests/ui/integer_arithmetic.rs", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a43c5d8591f25063a0adeddbc961e86249dfb764/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43c5d8591f25063a0adeddbc961e86249dfb764/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs?ref=a43c5d8591f25063a0adeddbc961e86249dfb764", "patch": "@@ -1,109 +0,0 @@\n-//@aux-build:proc_macro_derive.rs\n-\n-#![warn(clippy::integer_arithmetic, clippy::float_arithmetic)]\n-#![allow(clippy::no_effect, clippy::unnecessary_operation, clippy::op_ref)]\n-\n-extern crate proc_macro_derive;\n-\n-#[derive(proc_macro_derive::ShadowDerive)]\n-pub struct Nothing;\n-\n-#[rustfmt::skip]\n-fn main() {\n-    let mut i = 1i32;\n-    let mut var1 = 13i32;\n-    let mut var2 = -1i32;\n-    1 + i;\n-    i * 2;\n-    1 %\n-    i / 2; // no error, this is part of the expression in the preceding line\n-    i - 2 + 2 - i;\n-    -i;\n-    i >> 1;\n-    i << 1;\n-\n-    // no error, overflows are checked by `overflowing_literals`\n-    -1;\n-    -(-1);\n-\n-    i & 1; // no wrapping\n-    i | 1;\n-    i ^ 1;\n-\n-    i += 1;\n-    i -= 1;\n-    i *= 2;\n-    i /= 2;\n-    i /= 0;\n-    i /= -1;\n-    i /= var1;\n-    i /= var2;\n-    i %= 2;\n-    i %= 0;\n-    i %= -1;\n-    i %= var1;\n-    i %= var2;\n-    i <<= 3;\n-    i >>= 2;\n-\n-    // no errors\n-    i |= 1;\n-    i &= 1;\n-    i ^= i;\n-\n-    // No errors for the following items because they are constant expressions\n-    enum Foo {\n-        Bar = -2,\n-    }\n-    struct Baz([i32; 1 + 1]);\n-    union Qux {\n-        field: [i32; 1 + 1],\n-    }\n-    type Alias = [i32; 1 + 1];\n-\n-    const FOO: i32 = -2;\n-    static BAR: i32 = -2;\n-\n-    let _: [i32; 1 + 1] = [0, 0];\n-\n-    let _: [i32; 1 + 1] = {\n-        let a: [i32; 1 + 1] = [0, 0];\n-        a\n-    };\n-\n-    trait Trait {\n-        const ASSOC: i32 = 1 + 1;\n-    }\n-\n-    impl Trait for Foo {\n-        const ASSOC: i32 = {\n-            let _: [i32; 1 + 1];\n-            fn foo() {}\n-            1 + 1\n-        };\n-    }\n-}\n-\n-// warn on references as well! (#5328)\n-pub fn int_arith_ref() {\n-    3 + &1;\n-    &3 + 1;\n-    &3 + &1;\n-}\n-\n-pub fn foo(x: &i32) -> i32 {\n-    let a = 5;\n-    a + x\n-}\n-\n-pub fn bar(x: &i32, y: &i32) -> i32 {\n-    x + y\n-}\n-\n-pub fn baz(x: i32, y: &i32) -> i32 {\n-    x + y\n-}\n-\n-pub fn qux(x: i32, y: i32) -> i32 {\n-    (&x + &y)\n-}"}, {"sha": "add3b6b90fa26108cb534a9f93e11cc8b167582c", "filename": "src/tools/clippy/tests/ui/integer_arithmetic.stderr", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a43c5d8591f25063a0adeddbc961e86249dfb764/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a43c5d8591f25063a0adeddbc961e86249dfb764/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.stderr?ref=a43c5d8591f25063a0adeddbc961e86249dfb764", "patch": "@@ -1,169 +0,0 @@\n-error: this operation will panic at runtime\n-  --> $DIR/integer_arithmetic.rs:37:5\n-   |\n-LL |     i /= 0;\n-   |     ^^^^^^ attempt to divide `_` by zero\n-   |\n-   = note: `#[deny(unconditional_panic)]` on by default\n-\n-error: this operation will panic at runtime\n-  --> $DIR/integer_arithmetic.rs:42:5\n-   |\n-LL |     i %= 0;\n-   |     ^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:16:5\n-   |\n-LL |     1 + i;\n-   |     ^^^^^\n-   |\n-   = note: `-D clippy::integer-arithmetic` implied by `-D warnings`\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:17:5\n-   |\n-LL |     i * 2;\n-   |     ^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:18:5\n-   |\n-LL | /     1 %\n-LL | |     i / 2; // no error, this is part of the expression in the preceding line\n-   | |_____^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:20:5\n-   |\n-LL |     i - 2 + 2 - i;\n-   |     ^^^^^^^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:21:5\n-   |\n-LL |     -i;\n-   |     ^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:22:5\n-   |\n-LL |     i >> 1;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:23:5\n-   |\n-LL |     i << 1;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:33:5\n-   |\n-LL |     i += 1;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:34:5\n-   |\n-LL |     i -= 1;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:35:5\n-   |\n-LL |     i *= 2;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:38:11\n-   |\n-LL |     i /= -1;\n-   |           ^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:39:5\n-   |\n-LL |     i /= var1;\n-   |     ^^^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:40:5\n-   |\n-LL |     i /= var2;\n-   |     ^^^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:43:11\n-   |\n-LL |     i %= -1;\n-   |           ^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:44:5\n-   |\n-LL |     i %= var1;\n-   |     ^^^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:45:5\n-   |\n-LL |     i %= var2;\n-   |     ^^^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:46:5\n-   |\n-LL |     i <<= 3;\n-   |     ^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:47:5\n-   |\n-LL |     i >>= 2;\n-   |     ^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:89:5\n-   |\n-LL |     3 + &1;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:90:5\n-   |\n-LL |     &3 + 1;\n-   |     ^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:91:5\n-   |\n-LL |     &3 + &1;\n-   |     ^^^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:96:5\n-   |\n-LL |     a + x\n-   |     ^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:100:5\n-   |\n-LL |     x + y\n-   |     ^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:104:5\n-   |\n-LL |     x + y\n-   |     ^^^^^\n-\n-error: integer arithmetic detected\n-  --> $DIR/integer_arithmetic.rs:108:5\n-   |\n-LL |     (&x + &y)\n-   |     ^^^^^^^^^\n-\n-error: aborting due to 27 previous errors\n-"}, {"sha": "b65e6c7261a57b3ed339abe49f97f8854b649c60", "filename": "src/tools/clippy/tests/ui/issue-111399.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fissue-111399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fissue-111399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fissue-111399.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,13 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Check that rustc doesn't crash on the trait bound `Self::Ty: std::marker::Freeze`.\n+\n+pub struct Struct;\n+\n+impl Struct {\n+    pub type Ty = usize;\n+    pub const CT: Self::Ty = 42;\n+}\n+\n+fn main() {}"}, {"sha": "2c313ff35d59dd114213d614f7e7a611e868bc91", "filename": "src/tools/clippy/tests/ui/let_underscore_untyped.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,6 +1,12 @@\n+//@aux-build: proc_macros.rs\n+\n #![allow(unused)]\n #![warn(clippy::let_underscore_untyped)]\n \n+extern crate proc_macros;\n+use proc_macros::with_span;\n+\n+use clippy_utils::is_from_proc_macro;\n use std::future::Future;\n use std::{boxed::Box, fmt::Display};\n \n@@ -32,6 +38,14 @@ fn g() -> impl Fn() {\n     || {}\n }\n \n+with_span!(\n+    span\n+\n+    fn dont_lint_proc_macro() {\n+        let _ = a();\n+    }\n+);\n+\n fn main() {\n     let _ = a();\n     let _ = b(1);\n@@ -40,6 +54,7 @@ fn main() {\n     let _ = e();\n     let _ = f();\n     let _ = g();\n+    let closure = || {};\n \n     _ = a();\n     _ = b(1);"}, {"sha": "bbf2508af10b7439bf6e8cd7cda3b5bc73511125", "filename": "src/tools/clippy/tests/ui/let_underscore_untyped.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,60 +1,60 @@\n error: non-binding `let` without a type annotation\n-  --> $DIR/let_underscore_untyped.rs:36:5\n+  --> $DIR/let_underscore_untyped.rs:50:5\n    |\n LL |     let _ = a();\n    |     ^^^^^^^^^^^^\n    |\n help: consider adding a type annotation\n-  --> $DIR/let_underscore_untyped.rs:36:10\n+  --> $DIR/let_underscore_untyped.rs:50:10\n    |\n LL |     let _ = a();\n    |          ^\n    = note: `-D clippy::let-underscore-untyped` implied by `-D warnings`\n \n error: non-binding `let` without a type annotation\n-  --> $DIR/let_underscore_untyped.rs:37:5\n+  --> $DIR/let_underscore_untyped.rs:51:5\n    |\n LL |     let _ = b(1);\n    |     ^^^^^^^^^^^^^\n    |\n help: consider adding a type annotation\n-  --> $DIR/let_underscore_untyped.rs:37:10\n+  --> $DIR/let_underscore_untyped.rs:51:10\n    |\n LL |     let _ = b(1);\n    |          ^\n \n error: non-binding `let` without a type annotation\n-  --> $DIR/let_underscore_untyped.rs:39:5\n+  --> $DIR/let_underscore_untyped.rs:53:5\n    |\n LL |     let _ = d(&1);\n    |     ^^^^^^^^^^^^^^\n    |\n help: consider adding a type annotation\n-  --> $DIR/let_underscore_untyped.rs:39:10\n+  --> $DIR/let_underscore_untyped.rs:53:10\n    |\n LL |     let _ = d(&1);\n    |          ^\n \n error: non-binding `let` without a type annotation\n-  --> $DIR/let_underscore_untyped.rs:40:5\n+  --> $DIR/let_underscore_untyped.rs:54:5\n    |\n LL |     let _ = e();\n    |     ^^^^^^^^^^^^\n    |\n help: consider adding a type annotation\n-  --> $DIR/let_underscore_untyped.rs:40:10\n+  --> $DIR/let_underscore_untyped.rs:54:10\n    |\n LL |     let _ = e();\n    |          ^\n \n error: non-binding `let` without a type annotation\n-  --> $DIR/let_underscore_untyped.rs:41:5\n+  --> $DIR/let_underscore_untyped.rs:55:5\n    |\n LL |     let _ = f();\n    |     ^^^^^^^^^^^^\n    |\n help: consider adding a type annotation\n-  --> $DIR/let_underscore_untyped.rs:41:10\n+  --> $DIR/let_underscore_untyped.rs:55:10\n    |\n LL |     let _ = f();\n    |          ^"}, {"sha": "3996d775f55f47e263b31a21fc61907a419643f0", "filename": "src/tools/clippy/tests/ui/manual_let_else.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -8,6 +8,12 @@\n )]\n #![warn(clippy::manual_let_else)]\n \n+enum Variant {\n+    A(usize, usize),\n+    B(usize),\n+    C,\n+}\n+\n fn g() -> Option<()> {\n     None\n }\n@@ -135,6 +141,15 @@ fn fire() {\n         };\n     }\n     create_binding_if_some!(w, g());\n+\n+    fn e() -> Variant {\n+        Variant::A(0, 0)\n+    }\n+\n+    // Should not be renamed\n+    let v = if let Variant::A(a, 0) = e() { a } else { return };\n+    // Should be renamed\n+    let v = if let Variant::B(b) = e() { b } else { return };\n }\n \n fn not_fire() {"}, {"sha": "f6f56f7b00e5127facad2405fdd0ae479d21228a", "filename": "src/tools/clippy/tests/ui/manual_let_else.stderr", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -1,13 +1,13 @@\n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:18:5\n+  --> $DIR/manual_let_else.rs:24:5\n    |\n LL |     let v = if let Some(v_some) = g() { v_some } else { return };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { return };`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { return };`\n    |\n    = note: `-D clippy::manual-let-else` implied by `-D warnings`\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:19:5\n+  --> $DIR/manual_let_else.rs:25:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -18,13 +18,13 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         return;\n LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:25:5\n+  --> $DIR/manual_let_else.rs:31:5\n    |\n LL | /     let v = if let Some(v) = g() {\n LL | |         // Blocks around the identity should have no impact\n@@ -45,25 +45,25 @@ LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:38:9\n+  --> $DIR/manual_let_else.rs:44:9\n    |\n LL |         let v = if let Some(v_some) = g() { v_some } else { continue };\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { continue };`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { continue };`\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:39:9\n+  --> $DIR/manual_let_else.rs:45:9\n    |\n LL |         let v = if let Some(v_some) = g() { v_some } else { break };\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { break };`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { break };`\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:43:5\n+  --> $DIR/manual_let_else.rs:49:5\n    |\n LL |     let v = if let Some(v_some) = g() { v_some } else { panic!() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { panic!() };`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { panic!() };`\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:46:5\n+  --> $DIR/manual_let_else.rs:52:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -74,13 +74,13 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         std::process::abort()\n LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:53:5\n+  --> $DIR/manual_let_else.rs:59:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -91,13 +91,13 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         if true { return } else { panic!() }\n LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:60:5\n+  --> $DIR/manual_let_else.rs:66:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -109,14 +109,14 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         if true {}\n LL +         panic!();\n LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:70:5\n+  --> $DIR/manual_let_else.rs:76:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -129,7 +129,7 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         match () {\n LL +             _ if panic!() => {},\n LL +             _ => panic!(),\n@@ -138,13 +138,13 @@ LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:80:5\n+  --> $DIR/manual_let_else.rs:86:5\n    |\n LL |     let v = if let Some(v_some) = g() { v_some } else { if panic!() {} };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { if panic!() {} };`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { if panic!() {} };`\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:83:5\n+  --> $DIR/manual_let_else.rs:89:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -157,15 +157,15 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         match panic!() {\n LL +             _ => {},\n LL +         }\n LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:92:5\n+  --> $DIR/manual_let_else.rs:98:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -178,15 +178,15 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else { if true {\n+LL ~     let Some(v) = g() else { if true {\n LL +         return;\n LL +     } else {\n LL +         panic!(\"diverge\");\n LL +     } };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:101:5\n+  --> $DIR/manual_let_else.rs:107:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n LL | |         v_some\n@@ -199,7 +199,7 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g() else {\n+LL ~     let Some(v) = g() else {\n LL +         match (g(), g()) {\n LL +             (Some(_), None) => return,\n LL +             (None, Some(_)) => {\n@@ -215,7 +215,7 @@ LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:118:5\n+  --> $DIR/manual_let_else.rs:124:5\n    |\n LL | /     let (v, w) = if let Some(v_some) = g().map(|v| (v, 42)) {\n LL | |         v_some\n@@ -226,13 +226,13 @@ LL | |     };\n    |\n help: consider writing\n    |\n-LL ~     let Some(v_some) = g().map(|v| (v, 42)) else {\n+LL ~     let Some((v, w)) = g().map(|v| (v, 42)) else {\n LL +         return;\n LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:125:5\n+  --> $DIR/manual_let_else.rs:131:5\n    |\n LL | /     let v = if let (Some(v_some), w_some) = (g(), 0) {\n LL | |         (w_some, v_some)\n@@ -249,24 +249,36 @@ LL +     };\n    |\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:134:13\n+  --> $DIR/manual_let_else.rs:140:13\n    |\n LL |             let $n = if let Some(v) = $e { v } else { return };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { return };`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some($n) = g() else { return };`\n ...\n LL |     create_binding_if_some!(w, g());\n    |     ------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `create_binding_if_some` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:247:5\n+  --> $DIR/manual_let_else.rs:150:5\n+   |\n+LL |     let v = if let Variant::A(a, 0) = e() { a } else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::A(a, 0) = e() else { return };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:152:5\n+   |\n+LL |     let v = if let Variant::B(b) = e() { b } else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::B(v) = e() else { return };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:262:5\n    |\n LL | /     let _ = match ff {\n LL | |         Some(value) => value,\n LL | |         _ => macro_call!(),\n LL | |     };\n-   | |______^ help: consider writing: `let Some(value) = ff else { macro_call!() };`\n+   | |______^ help: consider writing: `let Some(_) = ff else { macro_call!() };`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "bacc14dc967203f321818083baf01124f93439c4", "filename": "src/tools/clippy/tests/ui/manual_let_else_match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_let_else_match.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -5,7 +5,7 @@ LL | /     let v = match g() {\n LL | |         Some(v_some) => v_some,\n LL | |         None => return,\n LL | |     };\n-   | |______^ help: consider writing: `let Some(v_some) = g() else { return };`\n+   | |______^ help: consider writing: `let Some(v) = g() else { return };`\n    |\n    = note: `-D clippy::manual-let-else` implied by `-D warnings`\n \n@@ -16,7 +16,7 @@ LL | /     let v = match g() {\n LL | |         Some(v_some) => v_some,\n LL | |         _ => return,\n LL | |     };\n-   | |______^ help: consider writing: `let Some(v_some) = g() else { return };`\n+   | |______^ help: consider writing: `let Some(v) = g() else { return };`\n \n error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:44:9"}, {"sha": "e8a47063ad61343a8ed691eedee1ba3e6b8e9b2a", "filename": "src/tools/clippy/tests/ui/manual_next_back.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,36 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::manual_next_back)]\n+\n+struct FakeIter(std::ops::Range<i32>);\n+\n+impl FakeIter {\n+    fn rev(self) -> Self {\n+        self\n+    }\n+\n+    fn next(&self) {}\n+}\n+\n+impl DoubleEndedIterator for FakeIter {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.0.next_back()\n+    }\n+}\n+\n+impl Iterator for FakeIter {\n+    type Item = i32;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+fn main() {\n+    // should not lint\n+    FakeIter(0..10).rev().next();\n+\n+    // should lint\n+    let _ = (0..10).next_back().unwrap();\n+    let _ = \"something\".bytes().next_back();\n+}"}, {"sha": "9ec89242241c82ae5d9b5b67aa8408340e6cfcac", "filename": "src/tools/clippy/tests/ui/manual_next_back.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,36 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::manual_next_back)]\n+\n+struct FakeIter(std::ops::Range<i32>);\n+\n+impl FakeIter {\n+    fn rev(self) -> Self {\n+        self\n+    }\n+\n+    fn next(&self) {}\n+}\n+\n+impl DoubleEndedIterator for FakeIter {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.0.next_back()\n+    }\n+}\n+\n+impl Iterator for FakeIter {\n+    type Item = i32;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+fn main() {\n+    // should not lint\n+    FakeIter(0..10).rev().next();\n+\n+    // should lint\n+    let _ = (0..10).rev().next().unwrap();\n+    let _ = \"something\".bytes().rev().next();\n+}"}, {"sha": "94ccaa9e4cc3fcbcb3e7728c3a208024251b8f16", "filename": "src/tools/clippy/tests/ui/manual_next_back.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_next_back.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,16 @@\n+error: manual backwards iteration\n+  --> $DIR/manual_next_back.rs:34:20\n+   |\n+LL |     let _ = (0..10).rev().next().unwrap();\n+   |                    ^^^^^^^^^^^^^ help: use: `.next_back()`\n+   |\n+   = note: `-D clippy::manual-next-back` implied by `-D warnings`\n+\n+error: manual backwards iteration\n+  --> $DIR/manual_next_back.rs:35:32\n+   |\n+LL |     let _ = \"something\".bytes().rev().next();\n+   |                                ^^^^^^^^^^^^^ help: use: `.next_back()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "60f590661735cc0d20a117bb73f1be3d614db7c1", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let _y = matches!(x, Some(0));\n \n     // Lint\n-    let _w = matches!(x, Some(_));\n+    let _w = x.is_some();\n \n     // Turn into is_none\n     let _z = x.is_none();"}, {"sha": "b72fe10b748042a0965eec5a086051fea7219090", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -10,15 +10,17 @@ LL | |     };\n    |\n    = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n \n-error: match expression looks like `matches!` macro\n+error: redundant pattern matching, consider using `is_some()`\n   --> $DIR/match_expr_like_matches_macro.rs:21:14\n    |\n LL |       let _w = match x {\n    |  ______________^\n LL | |         Some(_) => true,\n LL | |         _ => false,\n LL | |     };\n-   | |_____^ help: try this: `matches!(x, Some(_))`\n+   | |_____^ help: try this: `x.is_some()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_none()`\n   --> $DIR/match_expr_like_matches_macro.rs:27:14\n@@ -29,8 +31,6 @@ LL | |         Some(_) => false,\n LL | |         None => true,\n LL | |     };\n    | |_____^ help: try this: `x.is_none()`\n-   |\n-   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: match expression looks like `matches!` macro\n   --> $DIR/match_expr_like_matches_macro.rs:33:15"}, {"sha": "3914b45464c719f3b3b48627f347a3292a75f489", "filename": "src/tools/clippy/tests/ui/match_same_arms.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -53,4 +53,84 @@ mod issue4244 {\n     }\n }\n \n-fn main() {}\n+macro_rules! m {\n+    (foo) => {};\n+    (bar) => {};\n+}\n+macro_rules! foo {\n+    () => {\n+        1\n+    };\n+}\n+macro_rules! bar {\n+    () => {\n+        1\n+    };\n+}\n+\n+fn main() {\n+    let x = 0;\n+    let _ = match 0 {\n+        0 => {\n+            m!(foo);\n+            x\n+        },\n+        1 => {\n+            m!(bar);\n+            x\n+        },\n+        _ => 1,\n+    };\n+\n+    let _ = match 0 {\n+        0 => {\n+            m!(foo);\n+            0\n+        },\n+        1 => {\n+            m!(bar);\n+            0\n+        },\n+        _ => 1,\n+    };\n+\n+    let _ = match 0 {\n+        0 => {\n+            let mut x = 0;\n+            #[cfg(not_enabled)]\n+            {\n+                x = 5;\n+            }\n+            #[cfg(not(not_enabled))]\n+            {\n+                x = 6;\n+            }\n+            x\n+        },\n+        1 => {\n+            let mut x = 0;\n+            #[cfg(also_not_enabled)]\n+            {\n+                x = 5;\n+            }\n+            #[cfg(not(also_not_enabled))]\n+            {\n+                x = 6;\n+            }\n+            x\n+        },\n+        _ => 0,\n+    };\n+\n+    let _ = match 0 {\n+        0 => foo!(),\n+        1 => bar!(),\n+        _ => 1,\n+    };\n+\n+    let _ = match 0 {\n+        0 => cfg!(not_enabled),\n+        1 => cfg!(also_not_enabled),\n+        _ => false,\n+    };\n+}"}, {"sha": "60b2975be04543f9649fde236d3a9c30cd257491", "filename": "src/tools/clippy/tests/ui/match_same_arms2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -239,4 +239,10 @@ fn main() {\n         3 => core::convert::identity::<u32>(todo!()),\n         _ => 5,\n     };\n+\n+    let _ = match 0 {\n+        0 => cfg!(not_enable),\n+        1 => cfg!(not_enable),\n+        _ => false,\n+    };\n }"}, {"sha": "8fb461bd28667e65f60981eccb6b49ef407a3e87", "filename": "src/tools/clippy/tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -192,5 +192,20 @@ note: other arm here\n LL |         Some(Bar { x: 0, y: 5, .. }) => 1,\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:245:9\n+   |\n+LL |         1 => cfg!(not_enable),\n+   |         -^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `1 | 0`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:244:9\n+   |\n+LL |         0 => cfg!(not_enable),\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "edb9d87d032ec9e7bb6958e08983bb30adff5891", "filename": "src/tools/clippy/tests/ui/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_forget.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -5,7 +5,7 @@ use std::mem as memstuff;\n use std::mem::forget as forgetSomething;\n \n #[warn(clippy::mem_forget)]\n-#[allow(forget_copy)]\n+#[allow(forgetting_copy_types)]\n fn main() {\n     let five: i32 = 5;\n     forgetSomething(five);"}, {"sha": "4ef6f0ca92f2dae22939a1ab32a22efa426b1908", "filename": "src/tools/clippy/tests/ui/multiple_unsafe_ops_per_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmultiple_unsafe_ops_per_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmultiple_unsafe_ops_per_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmultiple_unsafe_ops_per_block.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -2,7 +2,7 @@\n #![allow(unused)]\n #![allow(deref_nullptr)]\n #![allow(clippy::unnecessary_operation)]\n-#![allow(drop_copy)]\n+#![allow(dropping_copy_types)]\n #![warn(clippy::multiple_unsafe_ops_per_block)]\n \n extern crate proc_macros;"}, {"sha": "bf1911881c8a9434e5c6086edf60ea338da4547d", "filename": "src/tools/clippy/tests/ui/needless_bool/fixable.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -63,6 +63,13 @@ fn main() {\n     needless_bool2(x);\n     needless_bool3(x);\n     needless_bool_condition();\n+\n+    if a == b {\n+        true\n+    } else {\n+        // Do not lint as this comment might be important\n+        false\n+    };\n }\n \n fn bool_ret3(x: bool) -> bool {"}, {"sha": "a6c465d4fbd11c16b41cde966c0757a0a104d402", "filename": "src/tools/clippy/tests/ui/needless_bool/fixable.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -99,6 +99,13 @@ fn main() {\n     needless_bool2(x);\n     needless_bool3(x);\n     needless_bool_condition();\n+\n+    if a == b {\n+        true\n+    } else {\n+        // Do not lint as this comment might be important\n+        false\n+    };\n }\n \n fn bool_ret3(x: bool) -> bool {"}, {"sha": "fa906374fb3ba1d503a4cddf469e967e672e5c6b", "filename": "src/tools/clippy/tests/ui/needless_bool/fixable.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool%2Ffixable.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -91,7 +91,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `a < b`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:105:5\n+  --> $DIR/fixable.rs:112:5\n    |\n LL | /     if x {\n LL | |         return true;\n@@ -101,7 +101,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:113:5\n+  --> $DIR/fixable.rs:120:5\n    |\n LL | /     if x {\n LL | |         return false;\n@@ -111,7 +111,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return !x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:121:5\n+  --> $DIR/fixable.rs:128:5\n    |\n LL | /     if x && y {\n LL | |         return true;\n@@ -121,7 +121,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return x && y`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:129:5\n+  --> $DIR/fixable.rs:136:5\n    |\n LL | /     if x && y {\n LL | |         return false;\n@@ -131,33 +131,33 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return !(x && y)`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/fixable.rs:137:8\n+  --> $DIR/fixable.rs:144:8\n    |\n LL |     if x == true {};\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n    |\n    = note: `-D clippy::bool-comparison` implied by `-D warnings`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/fixable.rs:141:8\n+  --> $DIR/fixable.rs:148:8\n    |\n LL |     if x == false {};\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/fixable.rs:151:8\n+  --> $DIR/fixable.rs:158:8\n    |\n LL |     if x == true {};\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/fixable.rs:152:8\n+  --> $DIR/fixable.rs:159:8\n    |\n LL |     if x == false {};\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:161:12\n+  --> $DIR/fixable.rs:168:12\n    |\n LL |       } else if returns_bool() {\n    |  ____________^\n@@ -168,7 +168,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `{ !returns_bool() }`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:174:5\n+  --> $DIR/fixable.rs:181:5\n    |\n LL | /     if unsafe { no(4) } & 1 != 0 {\n LL | |         true\n@@ -178,13 +178,13 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `(unsafe { no(4) } & 1 != 0)`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:179:30\n+  --> $DIR/fixable.rs:186:30\n    |\n LL |     let _brackets_unneeded = if unsafe { no(4) } & 1 != 0 { true } else { false };\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `unsafe { no(4) } & 1 != 0`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:182:9\n+  --> $DIR/fixable.rs:189:9\n    |\n LL |         if unsafe { no(4) } & 1 != 0 { true } else { false }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `(unsafe { no(4) } & 1 != 0)`"}, {"sha": "b7e80af501547e6f896d736d4f921a63557174f7", "filename": "src/tools/clippy/tests/ui/needless_collect.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -62,4 +62,16 @@ fn main() {\n \n     let _ = sample.iter().next().is_none();\n     let _ = sample.iter().any(|x| x == &0);\n+\n+    #[allow(clippy::double_parens)]\n+    {\n+        Vec::<u8>::new().extend((0..10));\n+        foo((0..10));\n+        bar((0..10).collect::<Vec<_>>(), (0..10));\n+        baz((0..10), (), ('a'..='z'))\n+    }\n }\n+\n+fn foo(_: impl IntoIterator<Item = usize>) {}\n+fn bar<I: IntoIterator<Item = usize>>(_: Vec<usize>, _: I) {}\n+fn baz<I: IntoIterator<Item = usize>>(_: I, _: (), _: impl IntoIterator<Item = char>) {}"}, {"sha": "680b6fa5b55f53b0684fbceffa3a9b38fb18b6f1", "filename": "src/tools/clippy/tests/ui/needless_collect.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -62,4 +62,16 @@ fn main() {\n \n     let _ = sample.iter().collect::<VecWrapper<_>>().is_empty();\n     let _ = sample.iter().collect::<VecWrapper<_>>().contains(&&0);\n+\n+    #[allow(clippy::double_parens)]\n+    {\n+        Vec::<u8>::new().extend((0..10).collect::<Vec<_>>());\n+        foo((0..10).collect::<Vec<_>>());\n+        bar((0..10).collect::<Vec<_>>(), (0..10).collect::<Vec<_>>());\n+        baz((0..10), (), ('a'..='z').collect::<Vec<_>>())\n+    }\n }\n+\n+fn foo(_: impl IntoIterator<Item = usize>) {}\n+fn bar<I: IntoIterator<Item = usize>>(_: Vec<usize>, _: I) {}\n+fn baz<I: IntoIterator<Item = usize>>(_: I, _: (), _: impl IntoIterator<Item = char>) {}"}, {"sha": "ad22a7b057e0f9898c863efb63c6b1837f5f2d51", "filename": "src/tools/clippy/tests/ui/needless_collect.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -90,5 +90,29 @@ error: avoid using `collect()` when not needed\n LL |     let _ = sample.iter().collect::<VecWrapper<_>>().contains(&&0);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == &0)`\n \n-error: aborting due to 15 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:68:40\n+   |\n+LL |         Vec::<u8>::new().extend((0..10).collect::<Vec<_>>());\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ help: remove this call\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:69:20\n+   |\n+LL |         foo((0..10).collect::<Vec<_>>());\n+   |                    ^^^^^^^^^^^^^^^^^^^^ help: remove this call\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:70:49\n+   |\n+LL |         bar((0..10).collect::<Vec<_>>(), (0..10).collect::<Vec<_>>());\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^ help: remove this call\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:71:37\n+   |\n+LL |         baz((0..10), (), ('a'..='z').collect::<Vec<_>>())\n+   |                                     ^^^^^^^^^^^^^^^^^^^^ help: remove this call\n+\n+error: aborting due to 19 previous errors\n "}, {"sha": "d49ae5d8636f50ce43dbd34141bcee5dca2d5edf", "filename": "src/tools/clippy/tests/ui/needless_return.fixed", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -231,8 +231,9 @@ fn needless_return_macro() -> String {\n }\n \n fn issue_9361() -> i32 {\n-    #[allow(clippy::integer_arithmetic)]\n-    return 1 + 2;\n+    let n = 1;\n+    #[allow(clippy::arithmetic_side_effects)]\n+    return n + n;\n }\n \n fn issue8336(x: i32) -> bool {"}, {"sha": "367638261746ccdc0a464d8c9524283338a40420", "filename": "src/tools/clippy/tests/ui/needless_return.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -239,8 +239,9 @@ fn needless_return_macro() -> String {\n }\n \n fn issue_9361() -> i32 {\n-    #[allow(clippy::integer_arithmetic)]\n-    return 1 + 2;\n+    let n = 1;\n+    #[allow(clippy::arithmetic_side_effects)]\n+    return n + n;\n }\n \n fn issue8336(x: i32) -> bool {"}, {"sha": "05f6038cd255342ebf30b8edd3ce6669d4aa4bba", "filename": "src/tools/clippy/tests/ui/needless_return.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -328,63 +328,63 @@ LL |     return format!(\"Hello {}\", \"world!\");\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:249:9\n+  --> $DIR/needless_return.rs:250:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:251:9\n+  --> $DIR/needless_return.rs:252:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:258:13\n+  --> $DIR/needless_return.rs:259:13\n    |\n LL |             return 10;\n    |             ^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:261:13\n+  --> $DIR/needless_return.rs:262:13\n    |\n LL |             return 100;\n    |             ^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:269:9\n+  --> $DIR/needless_return.rs:270:9\n    |\n LL |         return 0;\n    |         ^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:276:13\n+  --> $DIR/needless_return.rs:277:13\n    |\n LL |             return *(x as *const isize);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:278:13\n+  --> $DIR/needless_return.rs:279:13\n    |\n LL |             return !*(x as *const isize);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:285:20\n+  --> $DIR/needless_return.rs:286:20\n    |\n LL |           let _ = 42;\n    |  ____________________^\n@@ -395,39 +395,39 @@ LL | |         return;\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:292:20\n+  --> $DIR/needless_return.rs:293:20\n    |\n LL |         let _ = 42; return;\n    |                    ^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:304:9\n+  --> $DIR/needless_return.rs:305:9\n    |\n LL |         return Ok(format!(\"ok!\"));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:306:9\n+  --> $DIR/needless_return.rs:307:9\n    |\n LL |         return Err(format!(\"err!\"));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:312:9\n+  --> $DIR/needless_return.rs:313:9\n    |\n LL |         return if true { 1 } else { 2 };\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:316:9\n+  --> $DIR/needless_return.rs:317:9\n    |\n LL |         return if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 };\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "430caafb33e12fb0814cc30b927864f2218da6f9", "filename": "src/tools/clippy/tests/ui/non_minimal_cfg.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_minimal_cfg.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_minimal_cfg.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_minimal_cfg.fixed?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,17 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+\n+#[cfg(windows)]\n+fn hermit() {}\n+\n+#[cfg(windows)]\n+fn wasi() {}\n+\n+#[cfg(all(unix, not(windows)))]\n+fn the_end() {}\n+\n+#[cfg(any())]\n+fn any() {}\n+\n+fn main() {}"}, {"sha": "a38ce1c21d6e3528b32dac35afcfe64e0743e75e", "filename": "src/tools/clippy/tests/ui/non_minimal_cfg.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_minimal_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e52e8fdd5a469f2121538804bed4c392e837c0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_minimal_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_minimal_cfg.rs?ref=32e52e8fdd5a469f2121538804bed4c392e837c0", "patch": "@@ -0,0 +1,17 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+\n+#[cfg(all(windows))]\n+fn hermit() {}\n+\n+#[cfg(any(windows))]\n+fn wasi() {}\n+\n+#[cfg(all(any(unix), all(not(windows))))]\n+fn the_end() {}\n+\n+#[cfg(any())]\n+fn any() {}\n+\n+fn main() {}"}]}