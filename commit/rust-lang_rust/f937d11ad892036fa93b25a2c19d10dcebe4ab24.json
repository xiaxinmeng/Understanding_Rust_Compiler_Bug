{"sha": "f937d11ad892036fa93b25a2c19d10dcebe4ab24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MzdkMTFhZDg5MjAzNmZhOTNiMjVhMmMxOWQxMGRjZWJlNGFiMjQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-17T13:56:22Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-17T13:56:22Z"}, "message": "Merge #843\n\n843: Impl generics r=matklad a=flodiebold\n\nThis handles type parameters on impls when typing method calls.\r\n\r\n~One remaining problem is that the autoderefs aren't applied during the unification of the method receiver type with the actual receiver type, which means that the type parameters are only correctly inferred if no autoderefs happened.~\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "71f3719509f3fb46f5d2ce5a93da42ea67b23b70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f3719509f3fb46f5d2ce5a93da42ea67b23b70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f937d11ad892036fa93b25a2c19d10dcebe4ab24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f937d11ad892036fa93b25a2c19d10dcebe4ab24", "html_url": "https://github.com/rust-lang/rust/commit/f937d11ad892036fa93b25a2c19d10dcebe4ab24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f937d11ad892036fa93b25a2c19d10dcebe4ab24/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "edd4c1d8a6c270fe39ae881c23c722c658c87c32", "url": "https://api.github.com/repos/rust-lang/rust/commits/edd4c1d8a6c270fe39ae881c23c722c658c87c32", "html_url": "https://github.com/rust-lang/rust/commit/edd4c1d8a6c270fe39ae881c23c722c658c87c32"}, {"sha": "3c7c7e5a04306f8b68dffef2b5ca84628ed81ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7c7e5a04306f8b68dffef2b5ca84628ed81ce2", "html_url": "https://github.com/rust-lang/rust/commit/3c7c7e5a04306f8b68dffef2b5ca84628ed81ce2"}], "stats": {"total": 374, "additions": 290, "deletions": 84}, "files": [{"sha": "26ebc445bfc8d1f9149cea6cc3a453eb48303f07", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -463,7 +463,7 @@ impl Function {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+    pub fn module(&self, db: &impl PersistentHirDatabase) -> Module {\n         self.id.module(db)\n     }\n \n@@ -497,6 +497,12 @@ impl Function {\n         db.generic_params((*self).into())\n     }\n \n+    /// The containing impl block, if this is a method.\n+    pub fn impl_block(&self, db: &impl PersistentHirDatabase) -> Option<ImplBlock> {\n+        let module_impls = db.impls_in_module(self.module(db));\n+        ImplBlock::containing(module_impls, (*self).into())\n+    }\n+\n     // TODO: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n@@ -527,6 +533,16 @@ impl Const {\n     pub fn source(&self, db: &impl PersistentHirDatabase) -> (HirFileId, TreeArc<ast::ConstDef>) {\n         self.id.source(db)\n     }\n+\n+    pub fn module(&self, db: &impl PersistentHirDatabase) -> Module {\n+        self.id.module(db)\n+    }\n+\n+    /// The containing impl block, if this is a method.\n+    pub fn impl_block(&self, db: &impl PersistentHirDatabase) -> Option<ImplBlock> {\n+        let module_impls = db.impls_in_module(self.module(db));\n+        ImplBlock::containing(module_impls, (*self).into())\n+    }\n }\n \n impl Docs for Const {\n@@ -544,6 +560,10 @@ impl Static {\n     pub fn source(&self, db: &impl PersistentHirDatabase) -> (HirFileId, TreeArc<ast::StaticDef>) {\n         self.id.source(db)\n     }\n+\n+    pub fn module(&self, db: &impl PersistentHirDatabase) -> Module {\n+        self.id.module(db)\n+    }\n }\n \n impl Docs for Static {\n@@ -562,6 +582,10 @@ impl Trait {\n         self.id.source(db)\n     }\n \n+    pub fn module(&self, db: &impl PersistentHirDatabase) -> Module {\n+        self.id.module(db)\n+    }\n+\n     pub fn generic_params(&self, db: &impl PersistentHirDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n@@ -586,6 +610,16 @@ impl Type {\n     pub fn generic_params(&self, db: &impl PersistentHirDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n+\n+    pub fn module(&self, db: &impl PersistentHirDatabase) -> Module {\n+        self.id.module(db)\n+    }\n+\n+    /// The containing impl block, if this is a method.\n+    pub fn impl_block(&self, db: &impl PersistentHirDatabase) -> Option<ImplBlock> {\n+        let module_impls = db.impls_in_module(self.module(db));\n+        ImplBlock::containing(module_impls, (*self).into())\n+    }\n }\n \n impl Docs for Type {"}, {"sha": "c401528c6080b995ba80a6a5d5887a64a67038d0", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -3,22 +3,11 @@ use std::sync::Arc;\n use ra_syntax::ast::{self, NameOwner};\n \n use crate::{\n-    HirDatabase, Name, AsName, Function, FnSignature,\n+    Name, AsName, Function, FnSignature,\n     type_ref::{TypeRef, Mutability},\n     PersistentHirDatabase,\n-    impl_block::ImplBlock,\n };\n \n-impl Function {\n-    // TODO impl_block should probably also be part of the code model API?\n-\n-    /// The containing impl block, if this is a method.\n-    pub(crate) fn impl_block(&self, db: &impl HirDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n-    }\n-}\n-\n impl FnSignature {\n     pub(crate) fn fn_signature_query(\n         db: &impl PersistentHirDatabase,"}, {"sha": "e9db8282f5a040600dde49a7b9edee36ccc598d8", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     name::AsName,\n     type_ref::{Mutability, TypeRef},\n };\n-use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n+use crate::{ path::GenericArgs, ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy}};\n \n pub use self::scope::{ExprScopes, ScopesWithSyntaxMapping, ScopeEntryWithSyntax};\n \n@@ -193,6 +193,7 @@ pub enum Expr {\n         receiver: ExprId,\n         method_name: Name,\n         args: Vec<ExprId>,\n+        generic_args: Option<GenericArgs>,\n     },\n     Match {\n         expr: ExprId,\n@@ -597,7 +598,11 @@ impl ExprCollector {\n                     Vec::new()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                self.alloc_expr(Expr::MethodCall { receiver, method_name, args }, syntax_ptr)\n+                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n+                self.alloc_expr(\n+                    Expr::MethodCall { receiver, method_name, args, generic_args },\n+                    syntax_ptr,\n+                )\n             }\n             ast::ExprKind::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());"}, {"sha": "fcc5133535d89356a83c245214aa4c7b2c82738c", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n \n use ra_syntax::ast::{self, NameOwner, TypeParamsOwner};\n \n-use crate::{db::PersistentHirDatabase, Name, AsName, Function, Struct, Enum, Trait, Type};\n+use crate::{db::PersistentHirDatabase, Name, AsName, Function, Struct, Enum, Trait, Type, ImplBlock};\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -20,6 +20,7 @@ pub struct GenericParam {\n /// Data about the generic parameters of a function, struct, impl, etc.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct GenericParams {\n+    pub(crate) parent_params: Option<Arc<GenericParams>>,\n     pub(crate) params: Vec<GenericParam>,\n }\n \n@@ -30,41 +31,60 @@ pub enum GenericDef {\n     Enum(Enum),\n     Trait(Trait),\n     Type(Type),\n+    ImplBlock(ImplBlock),\n }\n-impl_froms!(GenericDef: Function, Struct, Enum, Trait, Type);\n+impl_froms!(GenericDef: Function, Struct, Enum, Trait, Type, ImplBlock);\n \n impl GenericParams {\n     pub(crate) fn generic_params_query(\n         db: &impl PersistentHirDatabase,\n         def: GenericDef,\n     ) -> Arc<GenericParams> {\n         let mut generics = GenericParams::default();\n+        let parent = match def {\n+            GenericDef::Function(it) => it.impl_block(db),\n+            GenericDef::Type(it) => it.impl_block(db),\n+            GenericDef::Struct(_) | GenericDef::Enum(_) | GenericDef::Trait(_) => None,\n+            GenericDef::ImplBlock(_) => None,\n+        };\n+        generics.parent_params = parent.map(|p| p.generic_params(db));\n+        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         match def {\n-            GenericDef::Function(it) => generics.fill(&*it.source(db).1),\n-            GenericDef::Struct(it) => generics.fill(&*it.source(db).1),\n-            GenericDef::Enum(it) => generics.fill(&*it.source(db).1),\n-            GenericDef::Trait(it) => generics.fill(&*it.source(db).1),\n-            GenericDef::Type(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Function(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::Struct(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::Enum(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::Trait(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::Type(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::ImplBlock(it) => generics.fill(&*it.source(db).1, start),\n         }\n \n         Arc::new(generics)\n     }\n \n-    fn fill(&mut self, node: &impl TypeParamsOwner) {\n+    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(params)\n+            self.fill_params(params, start)\n         }\n     }\n \n-    fn fill_params(&mut self, params: &ast::TypeParamList) {\n+    fn fill_params(&mut self, params: &ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param.name().map(AsName::as_name).unwrap_or_else(Name::missing);\n-            let param = GenericParam { idx: idx as u32, name };\n+            let param = GenericParam { idx: idx as u32 + start, name };\n             self.params.push(param);\n         }\n     }\n \n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n         self.params.iter().find(|p| &p.name == name)\n     }\n+\n+    pub fn count_parent_params(&self) -> usize {\n+        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n+    }\n+\n+    pub fn count_params_including_parent(&self) -> usize {\n+        let parent_count = self.count_parent_params();\n+        parent_count + self.params.len()\n+    }\n }"}, {"sha": "6df037859dd67ad1f98bd4617f2a7451cf1a867a", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -9,7 +9,6 @@ use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n \n use crate::{\n-    HirDatabase,\n     Module,\n     PersistentHirDatabase,\n };\n@@ -215,7 +214,7 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n             N::cast(&syntax).unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw)).to_owned();\n         (loc.raw.file_id, ast)\n     }\n-    fn module(self, db: &impl HirDatabase) -> Module {\n+    fn module(self, db: &impl PersistentHirDatabase) -> Module {\n         let int = Self::interner(db.as_ref());\n         let loc = int.id2loc(self);\n         loc.module"}, {"sha": "7ecf8c368dc3fee0916099bbaf4b578f50b3c5e0", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -13,7 +13,7 @@ use crate::{\n     type_ref::TypeRef,\n     ids::LocationCtx,\n     resolve::Resolver,\n-    ty::Ty,\n+    ty::Ty, generics::GenericParams\n };\n \n use crate::code_model_api::{Module, ModuleSource};\n@@ -38,7 +38,7 @@ impl ImplSourceMap {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ImplBlock {\n     module: Module,\n     impl_id: ImplId,\n@@ -58,7 +58,7 @@ impl ImplBlock {\n     }\n \n     /// Returns the syntax of the impl block\n-    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::ImplBlock>) {\n+    pub fn source(&self, db: &impl PersistentHirDatabase) -> (HirFileId, TreeArc<ast::ImplBlock>) {\n         let source_map = db.impls_in_module_source_map(self.module);\n         let (file_id, source) = self.module.definition_source(db);\n         (file_id, source_map.get(&source, self.impl_id))\n@@ -72,11 +72,11 @@ impl ImplBlock {\n         self.module\n     }\n \n-    pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TypeRef> {\n+    pub fn target_trait_ref(&self, db: &impl PersistentHirDatabase) -> Option<TypeRef> {\n         db.impls_in_module(self.module).impls[self.impl_id].target_trait().cloned()\n     }\n \n-    pub fn target_type(&self, db: &impl HirDatabase) -> TypeRef {\n+    pub fn target_type(&self, db: &impl PersistentHirDatabase) -> TypeRef {\n         db.impls_in_module(self.module).impls[self.impl_id].target_type().clone()\n     }\n \n@@ -96,13 +96,19 @@ impl ImplBlock {\n         None\n     }\n \n-    pub fn items(&self, db: &impl HirDatabase) -> Vec<ImplItem> {\n+    pub fn items(&self, db: &impl PersistentHirDatabase) -> Vec<ImplItem> {\n         db.impls_in_module(self.module).impls[self.impl_id].items().to_vec()\n     }\n \n+    pub fn generic_params(&self, db: &impl PersistentHirDatabase) -> Arc<GenericParams> {\n+        db.generic_params((*self).into())\n+    }\n+\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         let r = self.module().resolver(db);\n-        // TODO: add generics\n+        // add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         let r = r.push_impl_block_scope(self.clone());\n         r\n     }"}, {"sha": "6ca373e34ff3149f7c9378e0c264c4656570f664", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -129,7 +129,7 @@ impl Path {\n }\n \n impl GenericArgs {\n-    fn from_ast(node: &ast::TypeArgList) -> Option<GenericArgs> {\n+    pub(crate) fn from_ast(node: &ast::TypeArgList) -> Option<GenericArgs> {\n         let mut args = Vec::new();\n         for type_arg in node.type_args() {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());"}, {"sha": "562ad1f4961ba8322515d60000bbc41270fa8986", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -165,6 +165,17 @@ impl Substs {\n     pub fn empty() -> Substs {\n         Substs(Arc::new([]))\n     }\n+\n+    /// Replaces the end of the substitutions by other ones.\n+    pub(crate) fn replace_tail(self, replace_by: Vec<Ty>) -> Substs {\n+        // again missing Arc::make_mut_slice...\n+        let len = replace_by.len().min(self.0.len());\n+        let parent_len = self.0.len() - len;\n+        let mut result = Vec::with_capacity(parent_len + len);\n+        result.extend(self.0.iter().take(parent_len).cloned());\n+        result.extend(replace_by);\n+        Substs(result.into())\n+    }\n }\n \n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n@@ -421,7 +432,8 @@ impl Ty {\n                 (var.parent_enum(db).generic_params(db), segment)\n             }\n         };\n-        // substs_from_path\n+        let parent_param_count = def_generics.count_parent_params();\n+        substs.extend((0..parent_param_count).map(|_| Ty::Unknown));\n         if let Some(generic_args) = &segment.args_and_bindings {\n             // if args are provided, it should be all of them, but we can't rely on that\n             let param_count = def_generics.params.len();\n@@ -436,9 +448,8 @@ impl Ty {\n         }\n         // add placeholders for args that were not provided\n         // TODO: handle defaults\n-        let supplied_params =\n-            segment.args_and_bindings.as_ref().map(|ga| ga.args.len()).unwrap_or(0);\n-        for _ in supplied_params..def_generics.params.len() {\n+        let supplied_params = substs.len();\n+        for _ in supplied_params..def_generics.count_params_including_parent() {\n             substs.push(Ty::Unknown);\n         }\n         assert_eq!(substs.len(), def_generics.params.len());\n@@ -666,7 +677,12 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n-    Substs(generics.params.iter().map(|_p| Ty::Unknown).collect::<Vec<_>>().into())\n+    Substs(\n+        (0..generics.count_params_including_parent())\n+            .map(|_p| Ty::Unknown)\n+            .collect::<Vec<_>>()\n+            .into(),\n+    )\n }\n \n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n@@ -1362,15 +1378,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 ret_ty\n             }\n-            Expr::MethodCall { receiver, args, method_name } => {\n+            Expr::MethodCall { receiver, args, method_name, generic_args } => {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n-                let method_ty = match resolved {\n-                    Some(func) => {\n+                let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n+                    Some((ty, func)) => {\n                         self.write_method_resolution(tgt_expr, func);\n-                        self.db.type_for_def(func.into())\n+                        (ty, self.db.type_for_def(func.into()), Some(func.generic_params(self.db)))\n+                    }\n+                    None => (Ty::Unknown, receiver_ty, None),\n+                };\n+                // handle provided type arguments\n+                let method_ty = if let Some(generic_args) = generic_args {\n+                    // if args are provided, it should be all of them, but we can't rely on that\n+                    let param_count = def_generics.map(|g| g.params.len()).unwrap_or(0);\n+                    let mut new_substs = Vec::with_capacity(generic_args.args.len());\n+                    for arg in generic_args.args.iter().take(param_count) {\n+                        match arg {\n+                            GenericArg::Type(type_ref) => {\n+                                let ty = self.make_ty(type_ref);\n+                                new_substs.push(ty);\n+                            }\n+                        }\n                     }\n-                    None => Ty::Unknown,\n+                    let substs = method_ty.substs().unwrap_or_else(Substs::empty);\n+                    let substs = substs.replace_tail(new_substs);\n+                    method_ty.apply_substs(substs)\n+                } else {\n+                    method_ty\n                 };\n                 let method_ty = self.insert_type_vars(method_ty);\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n@@ -1394,9 +1429,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n                 };\n-                // TODO we would have to apply the autoderef/autoref steps here\n-                // to get the correct receiver type to unify...\n-                self.unify(&expected_receiver_ty, &receiver_ty);\n+                // Apply autoref so the below unification works correctly\n+                let actual_receiver_ty = match expected_receiver_ty {\n+                    Ty::Ref(_, mutability) => Ty::Ref(Arc::new(derefed_receiver_ty), mutability),\n+                    _ => derefed_receiver_ty,\n+                };\n+                self.unify(&expected_receiver_ty, &actual_receiver_ty);\n+\n                 let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n                 for (arg, param) in args.iter().zip(param_iter) {\n                     self.infer_expr(*arg, &Expectation::has_type(param));"}, {"sha": "94b757af2102ddbb830f102f7101a62aec7735e7", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -118,11 +118,13 @@ impl Ty {\n     // TODO: cache this as a query?\n     // - if so, what signature? (TyFingerprint, Name)?\n     // - or maybe cache all names and def_ids of methods per fingerprint?\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<Function> {\n-        self.iterate_methods(db, |f| {\n+    /// Look up the method with the given name, returning the actual autoderefed\n+    /// receiver type (but without autoref applied yet).\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<(Ty, Function)> {\n+        self.iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n-                Some(f)\n+                Some((ty.clone(), f))\n             } else {\n                 None\n             }\n@@ -134,7 +136,7 @@ impl Ty {\n     pub fn iterate_methods<T>(\n         self,\n         db: &impl HirDatabase,\n-        mut callback: impl FnMut(Function) -> Option<T>,\n+        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n         // For method calls, rust first does any number of autoderef, and then one\n         // autoref (i.e. when the method takes &self or &mut self). We just ignore\n@@ -156,7 +158,7 @@ impl Ty {\n                 for item in impl_block.items(db) {\n                     match item {\n                         ImplItem::Method(f) => {\n-                            if let Some(result) = callback(f) {\n+                            if let Some(result) = callback(&derefed_ty, f) {\n                                 return Some(result);\n                             }\n                         }"}, {"sha": "d1ce87b0a2ccbffc53a4f58fdfa1117f2eaf3f8b", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_generic_chain.snap", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -1,36 +1,36 @@\n ---\n-created: \"2019-01-27T14:52:29.938713255+00:00\"\n-creator: insta@0.5.2\n-expression: \"&result\"\n+created: \"2019-02-16T20:53:59.655361804Z\"\n+creator: insta@0.6.2\n source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n ---\n-[53; 57) 'self': A<[unknown]>\n-[65; 87) '{     ...     }': [unknown]\n-[75; 79) 'self': A<[unknown]>\n-[75; 81) 'self.x': [unknown]\n+[53; 57) 'self': A<T2>\n+[65; 87) '{     ...     }': T2\n+[75; 79) 'self': A<T2>\n+[75; 81) 'self.x': T2\n [99; 100) 't': T\n [110; 115) '{ t }': T\n [112; 113) 't': T\n [135; 261) '{     ....x() }': i128\n-[146; 147) 'x': i32\n-[150; 151) '1': i32\n-[162; 163) 'y': i32\n-[166; 168) 'id': fn id<i32>(T) -> T\n-[166; 171) 'id(x)': i32\n-[169; 170) 'x': i32\n-[182; 183) 'a': A<i32>\n-[186; 200) 'A { x: id(y) }': A<i32>\n-[193; 195) 'id': fn id<i32>(T) -> T\n-[193; 198) 'id(y)': i32\n-[196; 197) 'y': i32\n-[211; 212) 'z': i32\n-[215; 217) 'id': fn id<i32>(T) -> T\n-[215; 222) 'id(a.x)': i32\n-[218; 219) 'a': A<i32>\n-[218; 221) 'a.x': i32\n-[233; 234) 'b': A<i32>\n-[237; 247) 'A { x: z }': A<i32>\n-[244; 245) 'z': i32\n-[254; 255) 'b': A<i32>\n+[146; 147) 'x': i128\n+[150; 151) '1': i128\n+[162; 163) 'y': i128\n+[166; 168) 'id': fn id<i128>(T) -> T\n+[166; 171) 'id(x)': i128\n+[169; 170) 'x': i128\n+[182; 183) 'a': A<i128>\n+[186; 200) 'A { x: id(y) }': A<i128>\n+[193; 195) 'id': fn id<i128>(T) -> T\n+[193; 198) 'id(y)': i128\n+[196; 197) 'y': i128\n+[211; 212) 'z': i128\n+[215; 217) 'id': fn id<i128>(T) -> T\n+[215; 222) 'id(a.x)': i128\n+[218; 219) 'a': A<i128>\n+[218; 221) 'a.x': i128\n+[233; 234) 'b': A<i128>\n+[237; 247) 'A { x: z }': A<i128>\n+[244; 245) 'z': i128\n+[254; 255) 'b': A<i128>\n [254; 259) 'b.x()': i128\n "}, {"sha": "44f00a52eb62e15d36c8ba319f851e2a7e2744dc", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_impl_generics.snap", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_impl_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_impl_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_impl_generics.snap?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -0,0 +1,39 @@\n+---\n+created: \"2019-02-16T21:58:14.029368845Z\"\n+creator: insta@0.6.2\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[74; 78) 'self': A<X, Y>\n+[85; 107) '{     ...     }': X\n+[95; 99) 'self': A<X, Y>\n+[95; 101) 'self.x': X\n+[117; 121) 'self': A<X, Y>\n+[128; 150) '{     ...     }': Y\n+[138; 142) 'self': A<X, Y>\n+[138; 144) 'self.y': Y\n+[163; 167) 'self': A<X, Y>\n+[169; 170) 't': T\n+[188; 223) '{     ...     }': (X, Y, T)\n+[198; 217) '(self.....y, t)': (X, Y, T)\n+[199; 203) 'self': A<X, Y>\n+[199; 205) 'self.x': X\n+[207; 211) 'self': A<X, Y>\n+[207; 213) 'self.y': Y\n+[215; 216) 't': T\n+[245; 342) '{     ...(1); }': ()\n+[255; 256) 'a': A<u64, i64>\n+[259; 281) 'A { x:...1i64 }': A<u64, i64>\n+[266; 270) '1u64': u64\n+[275; 279) '1i64': i64\n+[287; 288) 'a': A<u64, i64>\n+[287; 292) 'a.x()': u64\n+[298; 299) 'a': A<u64, i64>\n+[298; 303) 'a.y()': i64\n+[309; 310) 'a': A<u64, i64>\n+[309; 319) 'a.z(1i128)': (u64, i64, i128)\n+[313; 318) '1i128': i128\n+[325; 326) 'a': A<u64, i64>\n+[325; 339) 'a.z::<u128>(1)': (u64, i64, u128)\n+[337; 338) '1': u128\n+"}, {"sha": "f609eaf7ccc05768dd6d64290323257d1dd97c03", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_impl_generics_with_autoderef.snap", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_impl_generics_with_autoderef.snap", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_impl_generics_with_autoderef.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_impl_generics_with_autoderef.snap?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -0,0 +1,16 @@\n+---\n+created: \"2019-02-17T13:35:06.385679926Z\"\n+creator: insta@0.6.2\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[78; 82) 'self': &Option<T>\n+[98; 100) '{}': ()\n+[111; 112) 'o': Option<u32>\n+[127; 165) '{     ...f(); }': ()\n+[133; 146) '(&o).as_ref()': Option<&u32>\n+[134; 136) '&o': &Option<u32>\n+[135; 136) 'o': Option<u32>\n+[152; 153) 'o': Option<u32>\n+[152; 162) 'o.as_ref()': Option<&u32>\n+"}, {"sha": "5eb9c4f5bcc8c7de160167f902ddeab9017624ba", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -506,6 +506,58 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_impl_generics() {\n+    check_inference(\n+        \"infer_impl_generics\",\n+        r#\"\n+struct A<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+impl<Y, X> A<X, Y> {\n+    fn x(self) -> X {\n+        self.x\n+    }\n+    fn y(self) -> Y {\n+        self.y\n+    }\n+    fn z<T>(self, t: T) -> (X, Y, T) {\n+        (self.x, self.y, t)\n+    }\n+}\n+\n+fn test() -> i128 {\n+    let a = A { x: 1u64, y: 1i64 };\n+    a.x();\n+    a.y();\n+    a.z(1i128);\n+    a.z::<u128>(1);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_impl_generics_with_autoderef() {\n+    check_inference(\n+        \"infer_impl_generics_with_autoderef\",\n+        r#\"\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+impl<T> Option<T> {\n+    fn as_ref(&self) -> Option<&T> {}\n+}\n+fn test(o: Option<u32>) {\n+    (&o).as_ref();\n+    o.as_ref();\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_generic_chain() {\n     check_inference("}, {"sha": "20fa323ce9903f821a1c888f6bda5b009d78c48c", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -63,7 +63,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n }\n \n fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n-    receiver.iterate_methods(ctx.db, |func| {\n+    receiver.iterate_methods(ctx.db, |_ty, func| {\n         let sig = func.signature(ctx.db);\n         if sig.has_self_param() {\n             CompletionItem::new("}, {"sha": "dd91b5063542cb07c1f669279f9289d639e19590", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -1352,6 +1352,7 @@ impl ToOwned for ImplBlock {\n }\n \n \n+impl ast::TypeParamsOwner for ImplBlock {}\n impl ImplBlock {\n     pub fn item_list(&self) -> Option<&ItemList> {\n         super::child_opt(self)\n@@ -2094,6 +2095,10 @@ impl MethodCallExpr {\n     pub fn name_ref(&self) -> Option<&NameRef> {\n         super::child_opt(self)\n     }\n+\n+    pub fn type_arg_list(&self) -> Option<&TypeArgList> {\n+        super::child_opt(self)\n+    }\n }\n \n // Module"}, {"sha": "27a1236813de1ac174509ea29d6ebd5065e1024b", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/f937d11ad892036fa93b25a2c19d10dcebe4ab24/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=f937d11ad892036fa93b25a2c19d10dcebe4ab24", "patch": "@@ -322,7 +322,7 @@ Grammar(\n             ],\n             options: [\"TypeRef\"]\n         ),\n-        \"ImplBlock\": (options: [\"ItemList\"]),\n+        \"ImplBlock\": (options: [\"ItemList\"], traits: [\"TypeParamsOwner\"]),\n \n         \"ParenType\": (options: [\"TypeRef\"]),\n         \"TupleType\": ( collections: [[\"fields\", \"TypeRef\"]] ),\n@@ -431,7 +431,7 @@ Grammar(\n         ),\n         \"MethodCallExpr\": (\n             traits: [\"ArgListOwner\"],\n-            options: [ \"Expr\", \"NameRef\" ],\n+            options: [ \"Expr\", \"NameRef\", \"TypeArgList\" ],\n         ),\n         \"IndexExpr\": (),\n         \"FieldExpr\": (options: [\"Expr\", \"NameRef\"]),"}]}