{"sha": "c0a42aecbc85298fb6351253c4cd1824567b7a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYTQyYWVjYmM4NTI5OGZiNjM1MTI1M2M0Y2QxODI0NTY3YjdhNDI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-28T05:34:39Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-30T08:29:45Z"}, "message": "WIP refactor expansion of decorators and move derive to MultiDecorator", "tree": {"sha": "e0a195bfbacb4bf2385f5e98fde07429e9d1d211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a195bfbacb4bf2385f5e98fde07429e9d1d211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a42aecbc85298fb6351253c4cd1824567b7a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a42aecbc85298fb6351253c4cd1824567b7a42", "html_url": "https://github.com/rust-lang/rust/commit/c0a42aecbc85298fb6351253c4cd1824567b7a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a42aecbc85298fb6351253c4cd1824567b7a42/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a4f9a26962d85d57a0b603ad324bd86fdd474cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4f9a26962d85d57a0b603ad324bd86fdd474cf", "html_url": "https://github.com/rust-lang/rust/commit/0a4f9a26962d85d57a0b603ad324bd86fdd474cf"}], "stats": {"total": 576, "additions": 299, "deletions": 277}, "files": [{"sha": "2ecefef51045e85885f27f8f1a5dd9a1c276c269", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -123,6 +123,16 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn map_item_or<F, G>(self, mut f: F, mut or: G) -> Annotatable\n+        where F: FnMut(P<ast::Item>) -> P<ast::Item>,\n+              G: FnMut(Annotatable) -> Annotatable\n+    {\n+        match self {\n+            Annotatable::Item(i) => Annotatable::Item(f(i)),\n+            _ => or(self)\n+        }\n+    }\n+\n     pub fn expect_trait_item(self) -> P<ast::TraitItem> {\n         match self {\n             Annotatable::TraitItem(i) => i,\n@@ -144,18 +154,18 @@ pub trait MultiItemDecorator {\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n-              item: &Annotatable,\n-              push:  &mut FnMut(Annotatable));\n+              item: Annotatable,\n+              push: &mut FnMut(Annotatable));\n }\n \n impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut FnMut(Annotatable))\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, Annotatable, &mut FnMut(Annotatable))\n {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n-              item: &Annotatable,\n+              item: Annotatable,\n               push: &mut FnMut(Annotatable)) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n@@ -433,6 +443,7 @@ pub enum SyntaxExtension {\n     /// based upon it.\n     #[unstable(feature = \"rustc_private\")]\n     #[deprecated(since = \"1.0.0\", reason = \"replaced by MultiDecorator\")]\n+    #[allow(deprecated)]\n     Decorator(Box<ItemDecorator + 'static>),\n \n     /// A syntax extension that is attached to an item and creates new items\n@@ -445,6 +456,7 @@ pub enum SyntaxExtension {\n     /// in-place.\n     #[unstable(feature = \"rustc_private\")]\n     #[deprecated(since = \"1.0.0\", reason = \"replaced by MultiModifier\")]\n+    #[allow(deprecated)]\n     Modifier(Box<ItemModifier + 'static>),\n \n     /// A syntax extension that is attached to an item and modifies it"}, {"sha": "1300eb7ff3f459009269707934d2a6e4c3f1e3db", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,27 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item};\n+use ast::MetaItem;\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-use ptr::P;\n \n pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n                                     span: Span,\n                                     _: &MetaItem,\n-                                    _: &Item,\n-                                    _: &mut FnMut(P<Item>))\n+                                    _: Annotatable,\n+                                    _: &mut FnMut(Annotatable))\n {\n     cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n }\n \n pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: &Item,\n-                            push: &mut FnMut(P<Item>))\n+                            item: Annotatable,\n+                            push: &mut FnMut(Annotatable))\n {\n     let path = Path::new(vec![\n         if cx.use_std { \"std\" } else { \"core\" },"}, {"sha": "935f0ae8a5ef43b7030fe3d55768929727f3b99f", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n-                             item: &Item,\n-                             push: &mut FnMut(P<Item>))\n+                             item: Annotatable,\n+                             push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "d7142d657d408ba5b003b762091ec8f5af389fe8", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n-                          item: &Item,\n-                          push: &mut FnMut(P<Item>))\n+                          item: Annotatable,\n+                          push: &mut FnMut(Annotatable))\n {\n     fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_same_method("}, {"sha": "6e52da2f332a619d165f2b8bc43b71b276821270", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -21,8 +21,8 @@ use ptr::P;\n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n-                           item: &Item,\n-                           push: &mut FnMut(P<Item>))\n+                           item: Annotatable,\n+                           push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "c31c91760e0c5d4fc85266e7c2e898f78804f41d", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr, self};\n+use ast::{MetaItem, Expr, self};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   mitem: &MetaItem,\n-                                  item: &Item,\n-                                  push: &mut FnMut(P<Item>))\n+                                  item: Annotatable,\n+                                  push: &mut FnMut(Annotatable))\n {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different"}, {"sha": "9097e984dd6af190340b7c3ce5be0b33d9f80489", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -11,9 +11,9 @@\n pub use self::OrderingOp::*;\n \n use ast;\n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -23,8 +23,8 @@ use ptr::P;\n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    span: Span,\n                                    mitem: &MetaItem,\n-                                   item: &Item,\n-                                   push: &mut FnMut(P<Item>))\n+                                   item: Annotatable,\n+                                   push: &mut FnMut(Annotatable))\n {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {"}, {"sha": "1ab51865652a71e7740b65d22b1c8d396e8510ea", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -11,9 +11,9 @@\n //! The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more.\n \n use ast;\n-use ast::{MetaItem, Item, Expr, MutMutable};\n+use ast::{MetaItem, Expr, MutMutable};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -24,26 +24,26 @@ use ptr::P;\n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n-                                       item: &Item,\n-                                       push: &mut FnMut(P<Item>))\n+                                       item: Annotatable,\n+                                       push: &mut FnMut(Annotatable))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>))\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>),\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable),\n                                  krate: &'static str)\n {\n     if !cx.use_std {"}, {"sha": "b7b741290af1b03273a3cb389e577b2b9406a36c", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n-                               item: &Item,\n-                               push: &mut FnMut(P<Item>))\n+                               item: Annotatable,\n+                               push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "47acedbcb8a665c6aaa41f44ad0727bd7bfc3e05", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -88,9 +88,9 @@\n //! }\n //! ```\n \n-use ast::{MetaItem, Item, Expr, ExprRet, MutMutable};\n+use ast::{MetaItem, Expr, ExprRet, MutMutable};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt,Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -100,26 +100,26 @@ use ptr::P;\n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n-                                       item: &Item,\n-                                       push: &mut FnMut(P<Item>))\n+                                       item: Annotatable,\n+                                       push: &mut FnMut(Annotatable))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>))\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>),\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable),\n                                  krate: &'static str)\n {\n     if !cx.use_std {"}, {"sha": "222bbe2df6d21bfdf4ea8209de95dccb8d367c42", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -197,7 +197,7 @@ use ast::{EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n use attr;\n use attr::AttrMetaMethods;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use codemap::{self, DUMMY_SP};\n use codemap::Span;\n@@ -378,41 +378,48 @@ impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n                   mitem: &ast::MetaItem,\n-                  item: &ast::Item,\n-                  push: &mut FnMut(P<ast::Item>))\n+                  item: Annotatable,\n+                  push: &mut FnMut(Annotatable))\n     {\n-        let newitem = match item.node {\n-            ast::ItemStruct(ref struct_def, ref generics) => {\n-                self.expand_struct_def(cx,\n-                                       &**struct_def,\n-                                       item.ident,\n-                                       generics)\n-            }\n-            ast::ItemEnum(ref enum_def, ref generics) => {\n-                self.expand_enum_def(cx,\n-                                     enum_def,\n-                                     &item.attrs[..],\n-                                     item.ident,\n-                                     generics)\n+        match item {\n+            Annotatable::Item(item) => {\n+                let newitem = match item.node {\n+                    ast::ItemStruct(ref struct_def, ref generics) => {\n+                        self.expand_struct_def(cx,\n+                                               &**struct_def,\n+                                               item.ident,\n+                                               generics)\n+                    }\n+                    ast::ItemEnum(ref enum_def, ref generics) => {\n+                        self.expand_enum_def(cx,\n+                                             enum_def,\n+                                             &item.attrs[..],\n+                                             item.ident,\n+                                             generics)\n+                    }\n+                    _ => {\n+                        cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");\n+                        return;\n+                    }\n+                };\n+                // Keep the lint attributes of the previous item to control how the\n+                // generated implementations are linted\n+                let mut attrs = newitem.attrs.clone();\n+                attrs.extend(item.attrs.iter().filter(|a| {\n+                    match &a.name()[..] {\n+                        \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n+                        _ => false,\n+                    }\n+                }).cloned());\n+                push(Annotatable::Item(P(ast::Item {\n+                    attrs: attrs,\n+                    ..(*newitem).clone()\n+                })))\n             }\n             _ => {\n-                cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");\n-                return;\n-            }\n-        };\n-        // Keep the lint attributes of the previous item to control how the\n-        // generated implementations are linted\n-        let mut attrs = newitem.attrs.clone();\n-        attrs.extend(item.attrs.iter().filter(|a| {\n-            match &a.name()[..] {\n-                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n-                _ => false,\n+                cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");                \n             }\n-        }).cloned());\n-        push(P(ast::Item {\n-            attrs: attrs,\n-            ..(*newitem).clone()\n-        }))\n+        }\n     }\n \n     /// Given that we are deriving a trait `DerivedTrait` for a type like:"}, {"sha": "b1ec3f564f5747d2ca726041624cde1d84cb4a42", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr, MutMutable};\n+use ast::{MetaItem, Expr, MutMutable};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -19,8 +19,8 @@ use ptr::P;\n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: &Item,\n-                            push: &mut FnMut(P<Item>))\n+                            item: Annotatable,\n+                            push: &mut FnMut(Annotatable))\n {\n \n     let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None,"}, {"sha": "61848cca059ce3c0c02f7093933ad91872f71d45", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -13,14 +13,13 @@\n //! FIXME (#2810): hygiene. Search for \"__\" strings (in other files too). We also assume \"extra\" is\n //! the standard library, and \"std\" is the core library.\n \n-use ast::{Item, MetaItem, MetaWord, MetaList, MetaNameValue};\n+use ast::{MetaItem, MetaWord};\n use attr::AttrMetaMethods;\n-use ext::base::{ExtCtxt, SyntaxEnv, Decorator, ItemDecorator, Modifier, Annotatable};\n+use ext::base::{ExtCtxt, SyntaxEnv, MultiDecorator, MultiItemDecorator, MultiModifier, Annotatable};\n use ext::build::AstBuilder;\n use feature_gate;\n use codemap::Span;\n use parse::token::{intern, intern_and_get_ident};\n-use ptr::P;\n \n macro_rules! pathvec {\n     ($($x:ident)::+) => (\n@@ -80,41 +79,46 @@ pub mod generic;\n fn expand_derive(cx: &mut ExtCtxt,\n                  span: Span,\n                  mitem: &MetaItem,\n-                 item: P<Item>)\n-                 -> P<Item> {\n-    item.map(|mut item| {\n-        if mitem.value_str().is_some() {\n-            cx.span_err(mitem.span, \"unexpected value in `derive`\");\n-        }\n+                 annotatable: Annotatable)\n+                 -> Annotatable {\n+    annotatable.map_item_or(|item| {\n+        item.map(|mut item| {\n+            if mitem.value_str().is_some() {\n+                cx.span_err(mitem.span, \"unexpected value in `derive`\");\n+            }\n \n-        let traits = mitem.meta_item_list().unwrap_or(&[]);\n-        if traits.is_empty() {\n-            cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n-        }\n+            let traits = mitem.meta_item_list().unwrap_or(&[]);\n+            if traits.is_empty() {\n+                cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n+            }\n \n-        for titem in traits.iter().rev() {\n-            let tname = match titem.node {\n-                MetaWord(ref tname) => tname,\n-                _ => {\n-                    cx.span_err(titem.span, \"malformed `derive` entry\");\n+            for titem in traits.iter().rev() {\n+                let tname = match titem.node {\n+                    MetaWord(ref tname) => tname,\n+                    _ => {\n+                        cx.span_err(titem.span, \"malformed `derive` entry\");\n+                        continue;\n+                    }\n+                };\n+\n+                if !(is_builtin_trait(tname) || cx.ecfg.enable_custom_derive()) {\n+                    feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                                   \"custom_derive\",\n+                                                   titem.span,\n+                                                   feature_gate::EXPLAIN_CUSTOM_DERIVE);\n                     continue;\n                 }\n-            };\n-\n-            if !(is_builtin_trait(tname) || cx.ecfg.enable_custom_derive()) {\n-                feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n-                                               \"custom_derive\",\n-                                               titem.span,\n-                                               feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-                continue;\n-            }\n \n-            // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n-            item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n-                intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n-        }\n+                // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n+                item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n+                    intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n+            }\n \n-        item\n+            item\n+        })\n+    }, |a| {\n+        cx.span_err(span, \"`derive` can only be applied to items\");\n+        a\n     })\n }\n \n@@ -125,24 +129,24 @@ macro_rules! derive_traits {\n             $({\n                 struct DeriveExtension;\n \n-                impl ItemDecorator for DeriveExtension {\n+                impl MultiItemDecorator for DeriveExtension {\n                     fn expand(&self,\n                               ecx: &mut ExtCtxt,\n                               sp: Span,\n                               mitem: &MetaItem,\n-                              item: &Item,\n-                              push: &mut FnMut(P<Item>)) {\n+                              annotatable: Annotatable,\n+                              push: &mut FnMut(Annotatable)) {\n                         warn_if_deprecated(ecx, sp, $name);\n-                        $func(ecx, sp, mitem, item, push);\n+                        $func(ecx, sp, mitem, annotatable, push);\n                     }\n                 }\n \n                 env.insert(intern(concat!(\"derive_\", $name)),\n-                           Decorator(Box::new(DeriveExtension)));\n+                           MultiDecorator(Box::new(DeriveExtension)));\n             })+\n \n             env.insert(intern(\"derive\"),\n-                       Modifier(Box::new(expand_derive)));\n+                       MultiModifier(Box::new(expand_derive)));\n         }\n \n         fn is_builtin_trait(name: &str) -> bool {"}, {"sha": "d218b8df153113ff93bcd619ff9127589c78eac4", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use ast;\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -21,8 +21,8 @@ use ptr::P;\n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n                                       mitem: &MetaItem,\n-                                      item: &Item,\n-                                      push: &mut FnMut(P<Item>))\n+                                      item: Annotatable,\n+                                      push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "5ace1b45b065b4b51877e526ea4dca8d8c45ac18", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, Item, Expr,};\n+use ast::{MetaItem, Expr,};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -21,8 +21,8 @@ use ptr::P;\n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: &Item,\n-                            push: &mut FnMut(P<Item>))\n+                            item: Annotatable,\n+                            push: &mut FnMut(Annotatable))\n {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(Box::new(Literal(path_std!(cx, core::fmt::Formatter))),"}, {"sha": "5033f406da0477408248810695bc0ddaaa3d6db3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 144, "deletions": 144, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -477,59 +477,6 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-#[allow(deprecated)] // This is needed because the `ItemModifier` trait is used\n-fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n-                         -> P<ast::Item> {\n-    // partition the attributes into ItemModifiers and others\n-    let (modifiers, other_attrs) = modifiers(&it.attrs, fld);\n-\n-    // update the attrs, leave everything else alone. Is this mutation really a good idea?\n-    it = P(ast::Item {\n-        attrs: other_attrs,\n-        ..(*it).clone()\n-    });\n-\n-    if modifiers.is_empty() {\n-        let it = expand_item_multi_modifier(Annotatable::Item(it), fld);\n-        return it.expect_item();\n-    }\n-\n-    for attr in &modifiers {\n-        let mname = attr.name();\n-\n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n-            Some(rc) => match *rc {\n-                Modifier(ref mac) => {\n-                    attr::mark_used(attr);\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n-                            span: None,\n-                            // attributes can do whatever they like,\n-                            // for now\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n-                    fld.cx.bt_pop();\n-                }\n-                _ => unreachable!()\n-            },\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    // Expansion may have added new ItemModifiers.\n-    // It is possible, that an item modifier could expand to a multi-modifier or\n-    // vice versa. In this case we will expand all modifiers before multi-modifiers,\n-    // which might give an odd ordering. However, I think it is unlikely that the\n-    // two kinds will be mixed, and I old-style multi-modifiers should be deprecated\n-    // anyway.\n-    expand_item_modifiers(it, fld)\n-}\n-\n /// Expand item_underscore\n fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n     match item {\n@@ -1083,81 +1030,14 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n     }\n }\n \n-#[allow(deprecated)] // This is needed because the `Decorator` variant is used\n fn expand_annotatable(a: Annotatable,\n                       fld: &mut MacroExpander)\n                       -> SmallVector<Annotatable> {\n     let a = expand_item_multi_modifier(a, fld);\n \n     let mut decorator_items = SmallVector::zero();\n     let mut new_attrs = Vec::new();\n-    for attr in a.attrs() {\n-        let mname = attr.name();\n-\n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n-            Some(rc) => match *rc {\n-                Decorator(ref dec) => {\n-                    let it = match a {\n-                        Annotatable::Item(ref it) => it,\n-                        // ItemDecorators are only implemented for Items.\n-                        _ => break,\n-                    };\n-\n-                    attr::mark_used(attr);\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n-                            span: Some(attr.span),\n-                            // attributes can do whatever they like,\n-                            // for now.\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-\n-                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n-                    // but that double-mut-borrows fld\n-                    let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n-                    dec.expand(fld.cx, attr.span, &*attr.node.value, &**it,\n-                               &mut |item| items.push(item));\n-                    decorator_items.extend(items.into_iter()\n-                        .flat_map(|item| expand_item(item, fld).into_iter()\n-                                                               .map(|i| Annotatable::Item(i))));\n-\n-                    fld.cx.bt_pop();\n-                }\n-                MultiDecorator(ref dec) => {\n-                    attr::mark_used(attr);\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n-                            span: Some(attr.span),\n-                            // attributes can do whatever they like,\n-                            // for now.\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-\n-                    // we'd ideally decorator_items.push_all(expand_annotatable(ann, fld)),\n-                    // but that double-mut-borrows fld\n-                    let mut anns: SmallVector<Annotatable> = SmallVector::zero();\n-                    dec.expand(fld.cx, attr.span, &*attr.node.value, &a,\n-                               &mut |ann| anns.push(ann));\n-                    decorator_items.extend(anns.into_iter()\n-                        .flat_map(|ann| expand_annotatable(ann, fld).into_iter()));\n-\n-                    fld.cx.bt_pop();\n-                }\n-                _ => new_attrs.push((*attr).clone()),\n-            },\n-            _ => new_attrs.push((*attr).clone()),\n-        }\n-    }\n+    expand_decorators(a.clone(), fld, &mut decorator_items, &mut new_attrs);\n \n     let mut new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n@@ -1215,34 +1095,101 @@ fn expand_annotatable(a: Annotatable,\n     new_items\n }\n \n-// partition the attributes into ItemModifiers and others\n-fn modifiers(attrs: &Vec<ast::Attribute>,\n-             fld: &MacroExpander)\n-             -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n-    attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(&attr.name())) {\n-            Some(rc) => match *rc {\n-                Modifier(_) => true,\n-                _ => false\n-            },\n-            _ => false\n+// Partition a set of attributes into one kind of attribute, and other kinds.\n+macro_rules! partition {\n+    ($fn_name: ident, $variant: ident) => {\n+        #[allow(deprecated)] // The `allow` is needed because the `Modifier` variant might be used.\n+        fn $fn_name(attrs: &[ast::Attribute],\n+                    fld: &MacroExpander)\n+                     -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n+            attrs.iter().cloned().partition(|attr| {\n+                match fld.cx.syntax_env.find(&intern(&attr.name())) {\n+                    Some(rc) => match *rc {\n+                        $variant(..) => true,\n+                        _ => false\n+                    },\n+                    _ => false\n+                }\n+            })\n         }\n-    })\n+    }\n }\n \n-// partition the attributes into MultiModifiers and others\n-fn multi_modifiers(attrs: &[ast::Attribute],\n-                   fld: &MacroExpander)\n-                   -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n-    attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(&attr.name())) {\n+partition!(modifiers, Modifier);\n+partition!(multi_modifiers, MultiModifier);\n+\n+\n+#[allow(deprecated)] // The `allow` is needed because the `Decorator` variant is used.\n+fn expand_decorators(a: Annotatable,\n+                     fld: &mut MacroExpander,\n+                     decorator_items: &mut SmallVector<Annotatable>,\n+                     new_attrs: &mut Vec<ast::Attribute>)\n+{\n+    for attr in a.attrs() {\n+        let mname = attr.name();\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n             Some(rc) => match *rc {\n-                MultiModifier(_) => true,\n-                _ => false\n+                Decorator(ref dec) => {\n+                    attr::mark_used(&attr);\n+\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.to_string(),\n+                            format: MacroAttribute,\n+                            span: Some(attr.span),\n+                            // attributes can do whatever they like,\n+                            // for now.\n+                            allow_internal_unstable: true,\n+                        }\n+                    });\n+\n+                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<Annotatable> = SmallVector::zero();\n+                    dec.expand(fld.cx,\n+                               attr.span,\n+                               &attr.node.value,\n+                               &a.clone().expect_item(),\n+                               &mut |item| items.push(Annotatable::Item(item)));\n+                    decorator_items.extend(items.into_iter()\n+                        .flat_map(|ann| expand_annotatable(ann, fld).into_iter()));\n+\n+                    fld.cx.bt_pop();\n+                }\n+                MultiDecorator(ref dec) => {\n+                    attr::mark_used(&attr);\n+\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.to_string(),\n+                            format: MacroAttribute,\n+                            span: Some(attr.span),\n+                            // attributes can do whatever they like,\n+                            // for now.\n+                            allow_internal_unstable: true,\n+                        }\n+                    });\n+\n+                    // we'd ideally decorator_items.push_all(expand_annotatable(ann, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<Annotatable> = SmallVector::zero();\n+                    dec.expand(fld.cx,\n+                               attr.span,\n+                               &attr.node.value,\n+                               a.clone(),\n+                               &mut |ann| items.push(ann));\n+                    decorator_items.extend(items.into_iter()\n+                        .flat_map(|ann| expand_annotatable(ann, fld).into_iter()));\n+\n+                    fld.cx.bt_pop();\n+                }\n+                _ => new_attrs.push((*attr).clone()),\n             },\n-            _ => false\n+            _ => new_attrs.push((*attr).clone()),\n         }\n-    })\n+    }\n }\n \n fn expand_item_multi_modifier(mut it: Annotatable,\n@@ -1269,7 +1216,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n                         callee: NameAndSpan {\n                             name: mname.to_string(),\n                             format: MacroAttribute,\n-                            span: None,\n+                            span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now\n                             allow_internal_unstable: true,\n@@ -1288,6 +1235,59 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     expand_item_multi_modifier(it, fld)\n }\n \n+#[allow(deprecated)] // This is needed because the `ItemModifier` trait is used\n+fn expand_item_modifiers(mut it: P<ast::Item>,\n+                         fld: &mut MacroExpander)\n+                         -> P<ast::Item> {\n+    // partition the attributes into ItemModifiers and others\n+    let (modifiers, other_attrs) = modifiers(&it.attrs, fld);\n+\n+    // update the attrs, leave everything else alone. Is this mutation really a good idea?\n+    it = P(ast::Item {\n+        attrs: other_attrs,\n+        ..(*it).clone()\n+    });\n+\n+    if modifiers.is_empty() {\n+        let it = expand_item_multi_modifier(Annotatable::Item(it), fld);\n+        return it.expect_item();\n+    }\n+\n+    for attr in &modifiers {\n+        let mname = attr.name();\n+\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n+            Some(rc) => match *rc {\n+                Modifier(ref mac) => {\n+                    attr::mark_used(attr);\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.to_string(),\n+                            format: MacroAttribute,\n+                            span: Some(attr.span),\n+                            // attributes can do whatever they like,\n+                            // for now\n+                            allow_internal_unstable: true,\n+                        }\n+                    });\n+                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n+                    fld.cx.bt_pop();\n+                }\n+                _ => unreachable!()\n+            },\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    // Expansion may have added new ItemModifiers.\n+    // It is possible, that an item modifier could expand to a multi-modifier or\n+    // vice versa. In this case we will expand all modifiers before multi-modifiers,\n+    // which might give an odd ordering. However, I think it is unlikely that the\n+    // two kinds will be mixed, and old-style multi-modifiers are deprecated.\n+    expand_item_modifiers(it, fld)\n+}\n+\n fn expand_impl_item(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n                  -> SmallVector<P<ast::ImplItem>> {\n     match ii.node {"}]}