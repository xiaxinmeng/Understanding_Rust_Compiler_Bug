{"sha": "b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZDc0NGM5ZjUxYjZiYjQyYzdjZWJlYjhmN2ZjZWZhYzg3NzhkMWU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-03-27T20:54:52Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-03-27T21:50:48Z"}, "message": "add `unused_braces`, lint anon_const", "tree": {"sha": "a939e28a92cbbe2076df6ce1f600a3f2912b70de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a939e28a92cbbe2076df6ce1f600a3f2912b70de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e", "html_url": "https://github.com/rust-lang/rust/commit/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0a08351a23d06903badd6f79d0971d2adf1b645", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a08351a23d06903badd6f79d0971d2adf1b645", "html_url": "https://github.com/rust-lang/rust/commit/e0a08351a23d06903badd6f79d0971d2adf1b645"}], "stats": {"total": 495, "additions": 366, "deletions": 129}, "files": [{"sha": "1b92e7755850524b82c649f4970c196a9827e299", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e", "patch": "@@ -104,6 +104,7 @@ macro_rules! early_lint_passes {\n             $args,\n             [\n                 UnusedParens: UnusedParens,\n+                UnusedBraces: UnusedBraces,\n                 UnusedImportBraces: UnusedImportBraces,\n                 UnsafeCode: UnsafeCode,\n                 AnonymousParameters: AnonymousParameters,\n@@ -275,6 +276,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         UNUSED_FEATURES,\n         UNUSED_LABELS,\n         UNUSED_PARENS,\n+        UNUSED_BRACES,\n         REDUNDANT_SEMICOLONS\n     );\n "}, {"sha": "67e86c480a30f21385d7a853f5ad0cbd852238a0", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 364, "deletions": 129, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b3d744c9f51b6bb42c7cebeb8f7fcefac8778d1e", "patch": "@@ -1,7 +1,9 @@\n+use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::ty::adjustment;\n use rustc::ty::{self, Ty};\n use rustc_ast::ast;\n+use rustc_ast::ast::{ExprKind, StmtKind};\n use rustc_ast::attr;\n use rustc_ast::util::parser;\n use rustc_ast_pretty::pprust;\n@@ -318,123 +320,109 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     }\n }\n \n-declare_lint! {\n-    pub(super) UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum UnusedDelimsCtx {\n+    FunctionArg,\n+    MethodArg,\n+    AssignedValue,\n+    IfCond,\n+    WhileCond,\n+    ForHeadExpr,\n+    MatchHeadExpr,\n+    ReturnValue,\n+    BlockRetValue,\n+    LetHeadExpr,\n+    ArrayLenExpr,\n+    AnonConst,\n }\n \n-declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+impl From<UnusedDelimsCtx> for &'static str {\n+    fn from(ctx: UnusedDelimsCtx) -> &'static str {\n+        match ctx {\n+            UnusedDelimsCtx::FunctionArg => \"function argument\",\n+            UnusedDelimsCtx::MethodArg => \"method argument\",\n+            UnusedDelimsCtx::AssignedValue => \"assigned value\",\n+            UnusedDelimsCtx::IfCond => \"`if` condition\",\n+            UnusedDelimsCtx::WhileCond => \"`while` condition\",\n+            UnusedDelimsCtx::ForHeadExpr => \"`for` head expression\",\n+            UnusedDelimsCtx::MatchHeadExpr => \"`match` head expression\",\n+            UnusedDelimsCtx::ReturnValue => \"`return` value\",\n+            UnusedDelimsCtx::BlockRetValue => \"block return value\",\n+            UnusedDelimsCtx::LetHeadExpr => \"`let` head expression\",\n+            UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n+        }\n+    }\n+}\n \n-impl UnusedParens {\n-    fn is_expr_parens_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n+/// Used by both `UnusedParens` and `UnusedBraces` to prevent code duplication.\n+trait UnusedDelimLint {\n+    const DELIM_STR: &'static str;\n+\n+    // this cannot be a constant is it refers to a static.\n+    fn lint(&self) -> &'static Lint;\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    );\n+\n+    fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n         followed_by_block\n             && match inner.kind {\n                 ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n                 _ => parser::contains_exterior_struct_lit(&inner),\n             }\n     }\n \n-    fn check_unused_parens_expr(\n+    fn emit_unused_delims_expr(\n         &self,\n         cx: &EarlyContext<'_>,\n         value: &ast::Expr,\n-        msg: &str,\n-        followed_by_block: bool,\n+        ctx: UnusedDelimsCtx,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n     ) {\n-        match value.kind {\n-            ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_parens_necessary(inner, followed_by_block)\n-                    && value.attrs.is_empty()\n-                    && !value.span.from_expansion()\n-                {\n-                    let expr_text =\n-                        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                            snippet\n-                        } else {\n-                            pprust::expr_to_string(value)\n-                        };\n-                    let keep_space = (\n-                        left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n-                        right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n-                    );\n-                    Self::remove_outer_parens(cx, value.span, &expr_text, msg, keep_space);\n-                }\n-            }\n-            ast::ExprKind::Let(_, ref expr) => {\n-                // FIXME(#60336): Properly handle `let true = (false && true)`\n-                // actually needing the parenthesis.\n-                self.check_unused_parens_expr(\n-                    cx,\n-                    expr,\n-                    \"`let` head expression\",\n-                    followed_by_block,\n-                    None,\n-                    None,\n-                );\n-            }\n-            _ => {}\n-        }\n+        let expr_text = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+            snippet\n+        } else {\n+            pprust::expr_to_string(value)\n+        };\n+        let keep_space = (\n+            left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n+            right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n+        );\n+        self.emit_unused_delims(cx, value.span, &expr_text, ctx.into(), keep_space);\n     }\n \n-    fn check_unused_parens_pat(\n+    /// emits a lint\n+    fn emit_unused_delims(\n         &self,\n-        cx: &EarlyContext<'_>,\n-        value: &ast::Pat,\n-        avoid_or: bool,\n-        avoid_mut: bool,\n-    ) {\n-        use ast::{BindingMode, Mutability, PatKind};\n-\n-        if let PatKind::Paren(inner) = &value.kind {\n-            match inner.kind {\n-                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n-                // any range pattern no matter where it occurs in the pattern. For something like\n-                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n-                // that if there are unnecessary parens they serve a purpose of readability.\n-                PatKind::Range(..) => return,\n-                // Avoid `p0 | .. | pn` if we should.\n-                PatKind::Or(..) if avoid_or => return,\n-                // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n-                // Otherwise proceed with linting.\n-                _ => {}\n-            }\n-\n-            let pattern_text =\n-                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                    snippet\n-                } else {\n-                    pprust::pat_to_string(value)\n-                };\n-            Self::remove_outer_parens(cx, value.span, &pattern_text, \"pattern\", (false, false));\n-        }\n-    }\n-\n-    fn remove_outer_parens(\n         cx: &EarlyContext<'_>,\n         span: Span,\n         pattern: &str,\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        cx.struct_span_lint(UNUSED_PARENS, span, |lint| {\n-            let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+        cx.struct_span_lint(self.lint(), span, |lint| {\n+            let span_msg = format!(\"unnecessary {} around {}\", Self::DELIM_STR, msg);\n             let mut err = lint.build(&span_msg);\n             let mut ate_left_paren = false;\n             let mut ate_right_paren = false;\n             let parens_removed = pattern.trim_matches(|c| match c {\n-                '(' => {\n+                '(' | '{' => {\n                     if ate_left_paren {\n                         false\n                     } else {\n                         ate_left_paren = true;\n                         true\n                     }\n                 }\n-                ')' => {\n+                ')' | '}' => {\n                     if ate_right_paren {\n                         false\n                     } else {\n@@ -460,61 +448,51 @@ impl UnusedParens {\n                 replace\n             };\n \n-            err.span_suggestion_short(\n-                span,\n-                \"remove these parentheses\",\n-                replace,\n-                Applicability::MachineApplicable,\n-            );\n+            let suggestion = format!(\"remove these {}\", Self::DELIM_STR);\n+\n+            err.span_suggestion_short(span, &suggestion, replace, Applicability::MachineApplicable);\n             err.emit();\n         });\n     }\n-}\n \n-impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use rustc_ast::ast::ExprKind::*;\n-        let (value, msg, followed_by_block, left_pos, right_pos) = match e.kind {\n-            Let(ref pat, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                return;\n-            }\n-\n+        let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n             If(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n-                (cond, \"`if` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n             }\n \n             While(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n-                (cond, \"`while` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right))\n             }\n \n-            ForLoop(ref pat, ref cond, ref block, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                (cond, \"`for` head expression\", true, None, Some(block.span.lo()))\n+            ForLoop(_, ref cond, ref block, ..) => {\n+                (cond, UnusedDelimsCtx::ForHeadExpr, true, None, Some(block.span.lo()))\n             }\n \n             Match(ref head, _) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n-                (head, \"`match` head expression\", true, Some(left), None)\n+                (head, UnusedDelimsCtx::MatchHeadExpr, true, Some(left), None)\n             }\n \n             Ret(Some(ref value)) => {\n                 let left = e.span.lo() + rustc_span::BytePos(3);\n-                (value, \"`return` value\", false, Some(left), None)\n+                (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n             }\n \n-            Assign(_, ref value, _) => (value, \"assigned value\", false, None, None),\n-            AssignOp(.., ref value) => (value, \"assigned value\", false, None, None),\n+            Assign(_, ref value, _) | AssignOp(.., ref value) => {\n+                (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n+            }\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n-                let (args_to_check, call_kind) = match *call_or_other {\n-                    Call(_, ref args) => (&args[..], \"function\"),\n-                    // first \"argument\" is self (which sometimes needs parens)\n-                    MethodCall(_, ref args) => (&args[1..], \"method\"),\n+                let (args_to_check, ctx) = match *call_or_other {\n+                    Call(_, ref args) => (&args[..], UnusedDelimsCtx::FunctionArg),\n+                    // first \"argument\" is self (which sometimes needs delims)\n+                    MethodCall(_, ref args) => (&args[1..], UnusedDelimsCtx::MethodArg),\n                     // actual catch-all arm\n                     _ => {\n                         return;\n@@ -527,14 +505,152 @@ impl EarlyLintPass for UnusedParens {\n                 if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n                     return;\n                 }\n-                let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {\n-                    self.check_unused_parens_expr(cx, arg, &msg, false, None, None);\n+                    self.check_unused_delims_expr(cx, arg, ctx, false, None, None);\n                 }\n                 return;\n             }\n         };\n-        self.check_unused_parens_expr(cx, &value, msg, followed_by_block, left_pos, right_pos);\n+        self.check_unused_delims_expr(cx, &value, ctx, followed_by_block, left_pos, right_pos);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        match s.kind {\n+            StmtKind::Local(ref local) => {\n+                if let Some(ref value) = local.init {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &value,\n+                        UnusedDelimsCtx::AssignedValue,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n+            }\n+            StmtKind::Expr(ref expr) => {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &expr,\n+                    UnusedDelimsCtx::BlockRetValue,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        use ast::ItemKind::*;\n+\n+        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n+            self.check_unused_delims_expr(\n+                cx,\n+                expr,\n+                UnusedDelimsCtx::AssignedValue,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub(super) UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+\n+impl UnusedDelimLint for UnusedParens {\n+    const DELIM_STR: &'static str = \"parentheses\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_PARENS\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Paren(ref inner) => {\n+                if !Self::is_expr_delims_necessary(inner, followed_by_block)\n+                    && value.attrs.is_empty()\n+                    && !value.span.from_expansion()\n+                {\n+                    self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetHeadExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl UnusedParens {\n+    fn check_unused_parens_pat(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Pat,\n+        avoid_or: bool,\n+        avoid_mut: bool,\n+    ) {\n+        use ast::{BindingMode, Mutability, PatKind};\n+\n+        if let PatKind::Paren(inner) = &value.kind {\n+            match inner.kind {\n+                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n+                // any range pattern no matter where it occurs in the pattern. For something like\n+                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n+                // that if there are unnecessary parens they serve a purpose of readability.\n+                PatKind::Range(..) => return,\n+                // Avoid `p0 | .. | pn` if we should.\n+                PatKind::Or(..) if avoid_or => return,\n+                // Avoid `mut x` and `mut x @ p` if we should:\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n+                // Otherwise proceed with linting.\n+                _ => {}\n+            }\n+\n+            let pattern_text =\n+                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+                    snippet\n+                } else {\n+                    pprust::pat_to_string(value)\n+                };\n+            self.emit_unused_delims(cx, value.span, &pattern_text, \"pattern\", (false, false));\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ExprKind::Let(ref pat, ..) | ExprKind::ForLoop(ref pat, ..) = e.kind {\n+            self.check_unused_parens_pat(cx, pat, false, false);\n+        }\n+\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n@@ -559,22 +675,16 @@ impl EarlyLintPass for UnusedParens {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n-        use ast::StmtKind::*;\n-\n-        match s.kind {\n-            Local(ref local) => {\n-                self.check_unused_parens_pat(cx, &local.pat, false, false);\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n \n-                if let Some(ref value) = local.init {\n-                    self.check_unused_parens_expr(cx, &value, \"assigned value\", false, None, None);\n-                }\n-            }\n-            Expr(ref expr) => {\n-                self.check_unused_parens_expr(cx, &expr, \"block return value\", false, None, None);\n-            }\n-            _ => {}\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        if let StmtKind::Local(ref local) = s.kind {\n+            self.check_unused_parens_pat(cx, &local.pat, false, false);\n         }\n+\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n@@ -590,6 +700,16 @@ impl EarlyLintPass for UnusedParens {\n             match &r.kind {\n                 &ast::TyKind::TraitObject(..) => {}\n                 &ast::TyKind::ImplTrait(_, ref bounds) if bounds.len() > 1 => {}\n+                &ast::TyKind::Array(_, ref len) => {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &len.value,\n+                        UnusedDelimsCtx::ArrayLenExpr,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n                 _ => {\n                     let pattern_text =\n                         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(ty.span) {\n@@ -598,19 +718,134 @@ impl EarlyLintPass for UnusedParens {\n                             pprust::ty_to_string(ty)\n                         };\n \n-                    Self::remove_outer_parens(cx, ty.span, &pattern_text, \"type\", (false, false));\n+                    self.emit_unused_delims(cx, ty.span, &pattern_text, \"type\", (false, false));\n                 }\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        use ast::ItemKind::*;\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n+}\n \n-        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n-            self.check_unused_parens_expr(cx, expr, \"assigned value\", false, None, None);\n+declare_lint! {\n+    pub(super) UNUSED_BRACES,\n+    Warn,\n+    \"suggests removing `{` and `}`  in case they are not necessary\"\n+}\n+\n+declare_lint_pass!(UnusedBraces => [UNUSED_BRACES]);\n+\n+impl UnusedDelimLint for UnusedBraces {\n+    const DELIM_STR: &'static str = \"braces\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_BRACES\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Block(ref inner, None)\n+                if inner.rules == ast::BlockCheckMode::Default =>\n+            {\n+                // emit a warning under the following conditions:\n+                //\n+                // - the block does not have a label\n+                // - the block is not `unsafe`\n+                // - the block contains exactly one expression (do not lint `{ expr; }`)\n+                // - `followed_by_block` is true and the internal expr may contain a `{`\n+                // - the block is not multiline (do not lint multiline match arms)\n+                //      ```\n+                //      match expr {\n+                //          Pattern => {\n+                //              somewhat_long_expression\n+                //          }\n+                //          // ...\n+                //      }\n+                //      ```\n+                // - the block has no attribute and was not created inside a macro\n+                // - if the block is an `anon_const`, the inner expr must be a literal\n+                //      (do not lint `struct A<const N: usize>; let _: A<{ 2 + 3 }>;`)\n+                //\n+                // FIXME(const_generics): handle paths when #67075 is fixed.\n+                if let [stmt] = inner.stmts.as_slice() {\n+                    if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n+                        if !Self::is_expr_delims_necessary(expr, followed_by_block)\n+                            && (ctx != UnusedDelimsCtx::AnonConst\n+                                || matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            // array length expressions are checked during `check_anon_const` and `check_ty`,\n+                            // once as `ArrayLenExpr` and once as `AnonConst`.\n+                            //\n+                            // As we do not want to lint this twice, we do not emit an error for\n+                            // `ArrayLenExpr` if `AnonConst` would do the same.\n+                            && (ctx != UnusedDelimsCtx::ArrayLenExpr\n+                                || !matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            && !cx.sess().source_map().is_multiline(value.span)\n+                            && value.attrs.is_empty()\n+                            && !value.span.from_expansion()\n+                        {\n+                            self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                        }\n+                    }\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetHeadExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedBraces {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n+    }\n+\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n+    }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n+        if let &ast::TyKind::Paren(ref r) = &ty.kind {\n+            if let ast::TyKind::Array(_, ref len) = r.kind {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &len.value,\n+                    UnusedDelimsCtx::ArrayLenExpr,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n }\n \n declare_lint! {"}]}