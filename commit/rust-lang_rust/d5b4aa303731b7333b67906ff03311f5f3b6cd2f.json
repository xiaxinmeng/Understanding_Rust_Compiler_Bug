{"sha": "d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "node_id": "C_kwDOAAsO6NoAKGQ1YjRhYTMwMzczMWI3MzMzYjY3OTA2ZmYwMzMxMWY1ZjNiNmNkMmY", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-12-23T06:24:58Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-12-23T06:24:58Z"}, "message": "Remove server download and update checks", "tree": {"sha": "f6056001238b54f7eab83399db0896a84394d09a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6056001238b54f7eab83399db0896a84394d09a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "html_url": "https://github.com/rust-lang/rust/commit/d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45d22629637664a83ad477ffa94c9c411f150bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/45d22629637664a83ad477ffa94c9c411f150bf1", "html_url": "https://github.com/rust-lang/rust/commit/45d22629637664a83ad477ffa94c9c411f150bf1"}], "stats": {"total": 232, "additions": 2, "deletions": 230}, "files": [{"sha": "06e231a9732f2617420f338911cf8d6e804f4621", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 2, "deletions": 185, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "patch": "@@ -5,9 +5,8 @@ import * as commands from './commands';\n import { activateInlayHints } from './inlay_hints';\n import { Ctx } from './ctx';\n import { Config } from './config';\n-import { log, assert, isValidExecutable, isRustDocument } from './util';\n+import { log, isValidExecutable, isRustDocument } from './util';\n import { PersistentState } from './persistent_state';\n-import { fetchRelease, download } from './net';\n import { activateTaskProvider } from './tasks';\n import { setContextValue } from './util';\n import { exec, spawnSync } from 'child_process';\n@@ -111,10 +110,6 @@ async function initCommonContext(context: vscode.ExtensionContext, ctx: Ctx) {\n         await activate(context).catch(log.error);\n     });\n \n-    ctx.registerCommand('updateGithubToken', ctx => async () => {\n-        await queryForGithubToken(new PersistentState(ctx.globalState));\n-    });\n-\n     ctx.registerCommand('analyzerStatus', commands.analyzerStatus);\n     ctx.registerCommand('memoryUsage', commands.memoryUsage);\n     ctx.registerCommand('shuffleCrateGraph', commands.shuffleCrateGraph);\n@@ -163,95 +158,10 @@ export async function deactivate() {\n \n async function bootstrap(config: Config, state: PersistentState): Promise<string> {\n     await vscode.workspace.fs.createDirectory(config.globalStorageUri).then();\n-\n-    if (!config.currentExtensionIsNightly) {\n-        await state.updateNightlyReleaseId(undefined);\n-    }\n-    await bootstrapExtension(config, state);\n     const path = await bootstrapServer(config, state);\n     return path;\n }\n \n-async function bootstrapExtension(config: Config, state: PersistentState): Promise<void> {\n-    if (config.package.releaseTag === null) return;\n-    if (config.channel === \"stable\") {\n-        if (config.currentExtensionIsNightly) {\n-            void vscode.window.showWarningMessage(\n-                `You are running a nightly version of rust-analyzer extension. ` +\n-                `To switch to stable, uninstall the extension and re-install it from the marketplace`\n-            );\n-        }\n-        return;\n-    };\n-    if (serverPath(config)) return;\n-\n-    const now = Date.now();\n-    const isInitialNightlyDownload = state.nightlyReleaseId === undefined;\n-    if (config.currentExtensionIsNightly) {\n-        // Check if we should poll github api for the new nightly version\n-        // if we haven't done it during the past hour\n-        const lastCheck = state.lastCheck;\n-\n-        const anHour = 60 * 60 * 1000;\n-        const shouldCheckForNewNightly = isInitialNightlyDownload || (now - (lastCheck ?? 0)) > anHour;\n-\n-        if (!shouldCheckForNewNightly) return;\n-    }\n-\n-    const latestNightlyRelease = await downloadWithRetryDialog(state, async () => {\n-        return await fetchRelease(\"nightly\", state.githubToken, config.proxySettings);\n-    }).catch(async (e) => {\n-        log.error(e);\n-        if (isInitialNightlyDownload) {\n-            await vscode.window.showErrorMessage(`Failed to download rust-analyzer nightly: ${e}`);\n-        }\n-        return;\n-    });\n-    if (latestNightlyRelease === undefined) {\n-        if (isInitialNightlyDownload) {\n-            await vscode.window.showErrorMessage(\"Failed to download rust-analyzer nightly: empty release contents returned\");\n-        }\n-        return;\n-    }\n-    if (config.currentExtensionIsNightly && latestNightlyRelease.id === state.nightlyReleaseId) return;\n-\n-    const userResponse = await vscode.window.showInformationMessage(\n-        \"New version of rust-analyzer (nightly) is available (requires reload).\",\n-        \"Update\"\n-    );\n-    if (userResponse !== \"Update\") return;\n-\n-    let arch = process.arch;\n-    if (arch === \"ia32\") {\n-        arch = \"x64\";\n-    }\n-    let platform = process.platform as string;\n-    if (platform === \"linux\" && isMusl()) {\n-        platform = \"alpine\";\n-    }\n-    const artifactName = `rust-analyzer-${platform}-${arch}.vsix`;\n-\n-    const artifact = latestNightlyRelease.assets.find(artifact => artifact.name === artifactName);\n-    assert(!!artifact, `Bad release: ${JSON.stringify(latestNightlyRelease)}`);\n-    const dest = vscode.Uri.joinPath(config.globalStorageUri, \"rust-analyzer.vsix\");\n-\n-    await downloadWithRetryDialog(state, async () => {\n-        await download({\n-            url: artifact.browser_download_url,\n-            dest,\n-            progressTitle: \"Downloading rust-analyzer extension\",\n-            proxySettings: config.proxySettings,\n-        });\n-    });\n-\n-    await vscode.commands.executeCommand(\"workbench.extensions.installExtension\", dest);\n-    await vscode.workspace.fs.delete(dest);\n-\n-    await state.updateNightlyReleaseId(latestNightlyRelease.id);\n-    await state.updateLastCheck(now);\n-    await vscode.commands.executeCommand(\"workbench.action.reloadWindow\");\n-}\n-\n async function bootstrapServer(config: Config, state: PersistentState): Promise<string> {\n     const path = await getServer(config, state);\n     if (!path) {\n@@ -356,56 +266,16 @@ async function getServer(config: Config, state: PersistentState): Promise<string\n     const dest = vscode.Uri.joinPath(config.globalStorageUri, `rust-analyzer-${platform}${ext}`);\n     const bundled = vscode.Uri.joinPath(config.installUri, \"server\", `rust-analyzer${ext}`);\n     const bundledExists = await vscode.workspace.fs.stat(bundled).then(() => true, () => false);\n-    let exists = await vscode.workspace.fs.stat(dest).then(() => true, () => false);\n+    const exists = await vscode.workspace.fs.stat(dest).then(() => true, () => false);\n     if (bundledExists) {\n-        await state.updateServerVersion(config.package.version);\n         if (!await isNixOs()) {\n             return bundled.fsPath;\n         }\n         if (!exists) {\n             await vscode.workspace.fs.copy(bundled, dest);\n             await patchelf(dest);\n-            exists = true;\n         }\n     }\n-    if (!exists) {\n-        await state.updateServerVersion(undefined);\n-    }\n-\n-    if (state.serverVersion === config.package.version) return dest.fsPath;\n-\n-    if (config.askBeforeDownload) {\n-        const userResponse = await vscode.window.showInformationMessage(\n-            `Language server version ${config.package.version} for rust-analyzer is not installed.`,\n-            \"Download now\"\n-        );\n-        if (userResponse !== \"Download now\") return dest.fsPath;\n-    }\n-\n-    const releaseTag = config.package.releaseTag;\n-    const release = await downloadWithRetryDialog(state, async () => {\n-        return await fetchRelease(releaseTag, state.githubToken, config.proxySettings);\n-    });\n-    const artifact = release.assets.find(artifact => artifact.name === `rust-analyzer-${platform}.gz`);\n-    assert(!!artifact, `Bad release: ${JSON.stringify(release)}`);\n-\n-    await downloadWithRetryDialog(state, async () => {\n-        await download({\n-            url: artifact.browser_download_url,\n-            dest,\n-            progressTitle: \"Downloading rust-analyzer server\",\n-            gunzip: true,\n-            mode: 0o755,\n-            proxySettings: config.proxySettings,\n-        });\n-    });\n-\n-    // Patching executable if that's NixOS.\n-    if (await isNixOs()) {\n-        await patchelf(dest);\n-    }\n-\n-    await state.updateServerVersion(config.package.version);\n     return dest.fsPath;\n }\n \n@@ -429,59 +299,6 @@ function isMusl(): boolean {\n     return res.stderr != null && res.stderr.indexOf(\"musl libc\") >= 0;\n }\n \n-async function downloadWithRetryDialog<T>(state: PersistentState, downloadFunc: () => Promise<T>): Promise<T> {\n-    while (true) {\n-        try {\n-            return await downloadFunc();\n-        } catch (e) {\n-            const selected = await vscode.window.showErrorMessage(\"Failed to download: \" + e.message, {}, {\n-                title: \"Update Github Auth Token\",\n-                updateToken: true,\n-            }, {\n-                title: \"Retry download\",\n-                retry: true,\n-            }, {\n-                title: \"Dismiss\",\n-            });\n-\n-            if (selected?.updateToken) {\n-                await queryForGithubToken(state);\n-                continue;\n-            } else if (selected?.retry) {\n-                continue;\n-            }\n-            throw e;\n-        };\n-    }\n-}\n-\n-async function queryForGithubToken(state: PersistentState): Promise<void> {\n-    const githubTokenOptions: vscode.InputBoxOptions = {\n-        value: state.githubToken,\n-        password: true,\n-        prompt: `\n-            This dialog allows to store a Github authorization token.\n-            The usage of an authorization token will increase the rate\n-            limit on the use of Github APIs and can thereby prevent getting\n-            throttled.\n-            Auth tokens can be created at https://github.com/settings/tokens`,\n-    };\n-\n-    const newToken = await vscode.window.showInputBox(githubTokenOptions);\n-    if (newToken === undefined) {\n-        // The user aborted the dialog => Do not update the stored token\n-        return;\n-    }\n-\n-    if (newToken === \"\") {\n-        log.info(\"Clearing github token\");\n-        await state.updateGithubToken(undefined);\n-    } else {\n-        log.info(\"Storing new github token\");\n-        await state.updateGithubToken(newToken);\n-    }\n-}\n-\n function warnAboutExtensionConflicts() {\n     const conflicting = [\n         [\"rust-analyzer\", \"matklad.rust-analyzer\"],"}, {"sha": "f6d0a3d015f7069ea7db5d29b5eec6b1ba0d4968", "filename": "editors/code/src/persistent_state.ts", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/editors%2Fcode%2Fsrc%2Fpersistent_state.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d5b4aa303731b7333b67906ff03311f5f3b6cd2f/editors%2Fcode%2Fsrc%2Fpersistent_state.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fpersistent_state.ts?ref=d5b4aa303731b7333b67906ff03311f5f3b6cd2f", "patch": "@@ -3,50 +3,5 @@ import { log } from './util';\n \n export class PersistentState {\n     constructor(private readonly globalState: vscode.Memento) {\n-        const { lastCheck, nightlyReleaseId, serverVersion } = this;\n-        log.info(\"PersistentState:\", { lastCheck, nightlyReleaseId, serverVersion });\n-    }\n-\n-    /**\n-     * Used to check for *nightly* updates once an hour.\n-     */\n-    get lastCheck(): number | undefined {\n-        return this.globalState.get(\"lastCheck\");\n-    }\n-    async updateLastCheck(value: number) {\n-        await this.globalState.update(\"lastCheck\", value);\n-    }\n-\n-    /**\n-     * Release id of the *nightly* extension.\n-     * Used to check if we should update.\n-     */\n-    get nightlyReleaseId(): number | undefined {\n-        return this.globalState.get(\"releaseId\");\n-    }\n-    async updateNightlyReleaseId(value: number | undefined) {\n-        await this.globalState.update(\"releaseId\", value);\n-    }\n-\n-    /**\n-     * Version of the extension that installed the server.\n-     * Used to check if we need to update the server.\n-     */\n-    get serverVersion(): string | undefined {\n-        return this.globalState.get(\"serverVersion\");\n-    }\n-    async updateServerVersion(value: string | undefined) {\n-        await this.globalState.update(\"serverVersion\", value);\n-    }\n-\n-    /**\n-     * Github authorization token.\n-     * This is used for API requests against the Github API.\n-     */\n-    get githubToken(): string | undefined {\n-        return this.globalState.get(\"githubToken\");\n-    }\n-    async updateGithubToken(value: string | undefined) {\n-        await this.globalState.update(\"githubToken\", value);\n     }\n }"}]}