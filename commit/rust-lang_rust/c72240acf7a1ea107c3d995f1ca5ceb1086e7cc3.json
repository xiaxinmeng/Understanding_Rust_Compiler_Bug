{"sha": "c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MjI0MGFjZjdhMWVhMTA3YzNkOTk1ZjFjYTVjZWIxMDg2ZTdjYzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-12T15:28:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-17T16:41:43Z"}, "message": "rustc_trans: Refactor collection to use tcx\n\nThis commit refactors the `collect_crate_translation_items` function to only\nrequire the `TyCtxt` instead of a `SharedCrateContext` in preparation for\nquery-ifying this portion of trans.", "tree": {"sha": "2b29afb9961f1b5ed4cda4f180c76cc0252a07bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b29afb9961f1b5ed4cda4f180c76cc0252a07bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "html_url": "https://github.com/rust-lang/rust/commit/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cdd68922d143c6d1f18f66572251b7078e9e850", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cdd68922d143c6d1f18f66572251b7078e9e850", "html_url": "https://github.com/rust-lang/rust/commit/1cdd68922d143c6d1f18f66572251b7078e9e850"}], "stats": {"total": 321, "additions": 166, "deletions": 155}, "files": [{"sha": "8e933d5ac88749ea0c964219b0b4fe440f6b1363", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -612,7 +612,7 @@ pub struct FnType<'tcx> {\n impl<'a, 'tcx> FnType<'tcx> {\n     pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n-        let fn_ty = instance_ty(ccx.shared(), &instance);\n+        let fn_ty = instance_ty(ccx.tcx(), &instance);\n         let sig = ty_fn_sig(ccx, fn_ty);\n         let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n         Self::new(ccx, sig, &[])"}, {"sha": "216c05b4b0a85ce2184be6e406135829f3547704", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -578,7 +578,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n+    let fn_ty = common::instance_ty(ccx.tcx(), &instance);\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n@@ -1424,7 +1424,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     let (items, inlining_map) =\n         time(time_passes, \"translation item collection\", || {\n-            collector::collect_crate_translation_items(&scx,\n+            collector::collect_crate_translation_items(scx.tcx(),\n                                                        exported_symbols,\n                                                        collection_mode)\n     });"}, {"sha": "ffdd76dd68731e5cf9d510e326541c92efae0c79", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -45,7 +45,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert!(!instance.substs.has_escaping_regions());\n     assert!(!instance.substs.has_param_types());\n \n-    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n+    let fn_ty = common::instance_ty(ccx.tcx(), &instance);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return llfn;\n     }\n@@ -148,5 +148,5 @@ pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     substs: &'tcx Substs<'tcx>)\n                                     -> ValueRef\n {\n-    get_fn(ccx, monomorphize::resolve(ccx.shared(), def_id, substs))\n+    get_fn(ccx, monomorphize::resolve(ccx.tcx(), def_id, substs))\n }"}, {"sha": "bda035fc343c8027aa3e63ccfb5d14dcb0d332fe", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 93, "deletions": 95, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -202,8 +202,7 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use context::SharedCrateContext;\n-use common::{def_ty, instance_ty};\n+use common::{def_ty, instance_ty, type_is_sized};\n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n@@ -294,23 +293,23 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  exported_symbols: &ExportedSymbols,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n-    scx.tcx().dep_graph.with_ignore(|| {\n-        let roots = collect_roots(scx, exported_symbols, mode);\n+    tcx.dep_graph.with_ignore(|| {\n+        let roots = collect_roots(tcx, exported_symbols, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FxHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut inlining_map = InliningMap::new();\n \n         for root in roots {\n-            collect_items_rec(scx,\n+            collect_items_rec(tcx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n@@ -323,7 +322,7 @@ pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            exported_symbols: &ExportedSymbols,\n                            mode: TransItemCollectionMode)\n                            -> Vec<TransItem<'tcx>> {\n@@ -332,25 +331,25 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     {\n         let mut visitor = RootCollector {\n-            scx,\n+            tcx,\n             mode,\n             exported_symbols,\n             output: &mut roots,\n         };\n \n-        scx.tcx().hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n     }\n \n     // We can only translate items that are instantiable - items all of\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip translating them.\n-    roots.retain(|root| root.is_instantiable(scx.tcx()));\n+    roots.retain(|root| root.is_instantiable(tcx));\n \n     roots\n }\n \n // Collect all monomorphized translation items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FxHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n@@ -359,54 +358,54 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(tcx));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     match starting_point {\n         TransItem::Static(node_id) => {\n-            let def_id = scx.tcx().hir.local_def_id(node_id);\n-            let instance = Instance::mono(scx.tcx(), def_id);\n+            let def_id = tcx.hir.local_def_id(node_id);\n+            let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n+            debug_assert!(should_trans_locally(tcx, &instance));\n \n-            let ty = instance_ty(scx, &instance);\n-            visit_drop_use(scx, ty, true, &mut neighbors);\n+            let ty = instance_ty(tcx, &instance);\n+            visit_drop_use(tcx, ty, true, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(scx, instance, true, &mut neighbors);\n+            collect_neighbours(tcx, instance, true, &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n+            debug_assert!(should_trans_locally(tcx, &instance));\n \n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n+            recursion_depth_reset = Some(check_recursion_limit(tcx,\n                                                                instance,\n                                                                recursion_depths));\n-            check_type_length_limit(scx.tcx(), instance);\n+            check_type_length_limit(tcx, instance);\n \n-            collect_neighbours(scx, instance, false, &mut neighbors);\n+            collect_neighbours(tcx, instance, false, &mut neighbors);\n         }\n         TransItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n         }\n     }\n \n-    record_accesses(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n+    record_accesses(tcx, starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n+        collect_items_rec(tcx, neighbour, visited, recursion_depths, inlining_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx));\n }\n \n fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -494,7 +493,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<TransItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>,\n@@ -511,49 +510,49 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                        &target_ty);\n-                let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                        &source_ty);\n-                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n+                let target_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                                  &target_ty);\n+                let source_ty = operand.ty(self.mir, self.tcx);\n+                let source_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                                  &source_ty);\n+                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.tcx,\n                                                                             source_ty,\n                                                                             target_ty);\n                 // This could also be a different Unsize instruction, like\n                 // from a fixed sized array to a slice. But we are only\n                 // interested in things that produce a vtable.\n                 if target_ty.is_trait() && !source_ty.is_trait() {\n-                    create_trans_items_for_vtable_methods(self.scx,\n+                    create_trans_items_for_vtable_methods(self.tcx,\n                                                           target_ty,\n                                                           source_ty,\n                                                           self.output);\n                 }\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n-                let fn_ty = operand.ty(self.mir, self.scx.tcx());\n-                let fn_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                    &fn_ty);\n-                visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n+                let fn_ty = operand.ty(self.mir, self.tcx);\n+                let fn_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                              &fn_ty);\n+                visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n-                let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                        &source_ty);\n+                let source_ty = operand.ty(self.mir, self.tcx);\n+                let source_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                                  &source_ty);\n                 match source_ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n-                            self.scx, def_id, substs, ty::ClosureKind::FnOnce);\n+                            self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                         self.output.push(create_fn_trans_item(instance));\n                     }\n                     _ => bug!(),\n                 }\n             }\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n-                let tcx = self.scx.tcx();\n+                let tcx = self.tcx;\n                 let exchange_malloc_fn_def_id = tcx\n                     .lang_items()\n                     .require(ExchangeMallocFnLangItem)\n-                    .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n+                    .unwrap_or_else(|e| tcx.sess.fatal(&e));\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n                 if should_trans_locally(tcx, &instance) {\n                     self.output.push(create_fn_trans_item(instance));\n@@ -569,10 +568,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n         if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n-            let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                 &substs);\n-            let instance = monomorphize::resolve(self.scx, def_id, substs);\n-            collect_neighbours(self.scx, instance, true, self.output);\n+            let substs = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                           &substs);\n+            let instance = monomorphize::resolve(self.tcx, def_id, substs);\n+            collect_neighbours(self.tcx, instance, true, self.output);\n         }\n \n         self.super_const(constant);\n@@ -584,15 +583,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                              location: Location) {\n         debug!(\"visiting terminator {:?} @ {:?}\", kind, location);\n \n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n                 let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n \n                 let constness = match (self.const_context, &callee_ty.sty) {\n-                    (true, &ty::TyFnDef(def_id, substs)) if self.scx.tcx().is_const_fn(def_id) => {\n-                        let instance = monomorphize::resolve(self.scx, def_id, substs);\n+                    (true, &ty::TyFnDef(def_id, substs)) if self.tcx.is_const_fn(def_id) => {\n+                        let instance = monomorphize::resolve(self.tcx, def_id, substs);\n                         Some(instance)\n                     }\n                     _ => None\n@@ -602,20 +601,20 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // If this is a const fn, called from a const context, we\n                     // have to visit its body in order to find any fn reifications\n                     // it might contain.\n-                    collect_neighbours(self.scx,\n+                    collect_neighbours(self.tcx,\n                                        const_fn_instance,\n                                        true,\n                                        self.output);\n                 } else {\n-                    visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+                    visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n                 }\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.scx.tcx())\n-                    .to_ty(self.scx.tcx());\n+                let ty = location.ty(self.mir, self.tcx)\n+                    .to_ty(self.tcx);\n                 let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n-                visit_drop_use(self.scx, ty, true, self.output);\n+                visit_drop_use(self.tcx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. } |\n             mir::TerminatorKind::SwitchInt { .. } |\n@@ -636,7 +635,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     location: Location) {\n         debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n \n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         let instance = Instance::mono(tcx, static_.def_id);\n         if should_trans_locally(tcx, &instance) {\n             let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n@@ -647,33 +646,33 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn visit_drop_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             is_direct_call: bool,\n                             output: &mut Vec<TransItem<'tcx>>)\n {\n-    let instance = monomorphize::resolve_drop_in_place(scx, ty);\n-    visit_instance_use(scx, instance, is_direct_call, output);\n+    let instance = monomorphize::resolve_drop_in_place(tcx, ty);\n+    visit_instance_use(tcx, instance, is_direct_call, output);\n }\n \n-fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n     if let ty::TyFnDef(def_id, substs) = ty.sty {\n-        let instance = monomorphize::resolve(scx, def_id, substs);\n-        visit_instance_use(scx, instance, is_direct_call, output);\n+        let instance = monomorphize::resolve(tcx, def_id, substs);\n+        visit_instance_use(tcx, instance, is_direct_call, output);\n     }\n }\n \n-fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: ty::Instance<'tcx>,\n                                 is_direct_call: bool,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n-    if !should_trans_locally(scx.tcx(), &instance) {\n+    if !should_trans_locally(tcx, &instance) {\n         return\n     }\n \n@@ -775,15 +774,15 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g. for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             source_ty: Ty<'tcx>,\n                                             target_ty: Ty<'tcx>)\n                                             -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n-        if !scx.type_is_sized(inner_source) {\n+        if !type_is_sized(tcx, inner_source) {\n             (inner_source, inner_target)\n         } else {\n-            scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n+            tcx.struct_lockstep_tails(inner_source, inner_target)\n         }\n     };\n     match (&source_ty.sty, &target_ty.sty) {\n@@ -804,7 +803,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             assert_eq!(source_adt_def, target_adt_def);\n \n             let kind =\n-                monomorphize::custom_coerce_unsize_info(scx, source_ty, target_ty);\n+                monomorphize::custom_coerce_unsize_info(tcx, source_ty, target_ty);\n \n             let coerce_index = match kind {\n                 CustomCoerceUnsized::Struct(i) => i\n@@ -816,10 +815,10 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             assert!(coerce_index < source_fields.len() &&\n                     source_fields.len() == target_fields.len());\n \n-            find_vtable_types_for_unsizing(scx,\n-                                           source_fields[coerce_index].ty(scx.tcx(),\n+            find_vtable_types_for_unsizing(tcx,\n+                                           source_fields[coerce_index].ty(tcx,\n                                                                           source_substs),\n-                                           target_fields[coerce_index].ty(scx.tcx(),\n+                                           target_fields[coerce_index].ty(tcx,\n                                                                           target_substs))\n         }\n         _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n@@ -835,7 +834,7 @@ fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                    trait_ty: Ty<'tcx>,\n                                                    impl_ty: Ty<'tcx>,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n@@ -844,19 +843,19 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n \n     if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n-            let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n+            let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n             assert!(!poly_trait_ref.has_escaping_regions());\n \n             // Walk all methods of the trait, including those of its supertraits\n-            let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n+            let methods = traits::get_vtable_methods(tcx, poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .map(|(def_id, substs)| monomorphize::resolve(scx, def_id, substs))\n-                .filter(|&instance| should_trans_locally(scx.tcx(), &instance))\n+                .map(|(def_id, substs)| monomorphize::resolve(tcx, def_id, substs))\n+                .filter(|&instance| should_trans_locally(tcx, &instance))\n                 .map(|instance| create_fn_trans_item(instance));\n             output.extend(methods);\n         }\n         // Also add the destructor\n-        visit_drop_use(scx, impl_ty, false, output);\n+        visit_drop_use(tcx, impl_ty, false, output);\n     }\n }\n \n@@ -865,7 +864,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n //=-----------------------------------------------------------------------------\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n-    scx: &'b SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     exported_symbols: &'b ExportedSymbols,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n@@ -886,7 +885,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n \n             hir::ItemImpl(..) => {\n                 if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.scx,\n+                    create_trans_items_for_default_impls(self.tcx,\n                                                          item,\n                                                          self.output);\n                 }\n@@ -897,33 +896,33 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n                     if self.mode == TransItemCollectionMode::Eager {\n-                        let def_id = self.scx.tcx().hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.scx.tcx(), def_id));\n+                               def_id_to_string(self.tcx, def_id));\n \n-                        let ty = def_ty(self.scx, def_id, Substs::empty());\n-                        visit_drop_use(self.scx, ty, true, self.output);\n+                        let ty = def_ty(self.tcx, def_id, Substs::empty());\n+                        visit_drop_use(self.tcx, ty, true, self.output);\n                     }\n                 }\n             }\n             hir::ItemGlobalAsm(..) => {\n                 debug!(\"RootCollector: ItemGlobalAsm({})\",\n-                       def_id_to_string(self.scx.tcx(),\n-                                        self.scx.tcx().hir.local_def_id(item.id)));\n+                       def_id_to_string(self.tcx,\n+                                        self.tcx.hir.local_def_id(item.id)));\n                 self.output.push(TransItem::GlobalAsm(item.id));\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.scx.tcx(),\n-                                        self.scx.tcx().hir.local_def_id(item.id)));\n+                       def_id_to_string(self.tcx,\n+                                        self.tcx.hir.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n                 // const items only generate translation items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n             hir::ItemFn(..) => {\n-                let tcx = self.scx.tcx();\n+                let tcx = self.tcx;\n                 let def_id = tcx.hir.local_def_id(item.id);\n \n                 if (self.mode == TransItemCollectionMode::Eager ||\n@@ -949,7 +948,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n-                let tcx = self.scx.tcx();\n+                let tcx = self.tcx;\n                 let def_id = tcx.hir.local_def_id(ii.id);\n \n                 if (self.mode == TransItemCollectionMode::Eager ||\n@@ -973,10 +972,9 @@ fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     generics.parent_types as usize + generics.types.len() > 0\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   item: &'tcx hir::Item,\n                                                   output: &mut Vec<TransItem<'tcx>>) {\n-    let tcx = scx.tcx();\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1009,7 +1007,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                     }\n \n                     let instance =\n-                        monomorphize::resolve(scx, method.def_id, callee_substs);\n+                        monomorphize::resolve(tcx, method.def_id, callee_substs);\n \n                     let trans_item = create_fn_trans_item(instance);\n                     if trans_item.is_instantiable(tcx) && should_trans_locally(tcx, &instance) {\n@@ -1025,15 +1023,15 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n }\n \n /// Scan the MIR in order to find function calls, closures, and drop-glue\n-fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 const_context: bool,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n-    let mir = scx.tcx().instance_mir(instance.def);\n+    let mir = tcx.instance_mir(instance.def);\n \n     let mut visitor = MirNeighborCollector {\n-        scx,\n+        tcx,\n         mir: &mir,\n         output,\n         param_substs: instance.substs,"}, {"sha": "52607904f73c48c11ee83856fe052fa959099737", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -26,6 +26,7 @@ use machine;\n use monomorphize;\n use type_::Type;\n use value::Value;\n+use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -37,7 +38,7 @@ use std::iter;\n use syntax::abi::Abi;\n use syntax::attr;\n use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub use context::{CrateContext, SharedCrateContext};\n \n@@ -140,6 +141,18 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     !layout.is_unsized() && layout.size(ccx).bytes() == 0\n }\n \n+pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n+}\n+\n+pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+}\n+\n+pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_freeze(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+}\n+\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *\n@@ -573,20 +586,20 @@ pub fn is_inline_instance<'a, 'tcx>(\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type.\n-pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         def_id: DefId,\n                         substs: &'tcx Substs<'tcx>)\n                         -> Ty<'tcx>\n {\n-    let ty = shared.tcx().type_of(def_id);\n-    shared.tcx().trans_apply_param_substs(substs, &ty)\n+    let ty = tcx.type_of(def_id);\n+    tcx.trans_apply_param_substs(substs, &ty)\n }\n \n /// Return the substituted type of an instance.\n-pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+pub fn instance_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              instance: &ty::Instance<'tcx>)\n                              -> Ty<'tcx>\n {\n-    let ty = instance.def.def_ty(shared.tcx());\n-    shared.tcx().trans_apply_param_substs(instance.substs, &ty)\n+    let ty = instance.def.def_ty(tcx);\n+    tcx.trans_apply_param_substs(instance.substs, &ty)\n }"}, {"sha": "a566cddde566b66735fa37a1c2af1c920b82ddef", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -109,7 +109,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = common::instance_ty(ccx.shared(), &instance);\n+    let ty = common::instance_ty(ccx.tcx(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -269,7 +269,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = common::instance_ty(ccx.shared(), &instance);\n+        let ty = common::instance_ty(ccx.tcx(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "3ad96d482f1165f54badabd6cd6b164765910027", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use common;\n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::{DepGraph, DepGraphSafe};\n@@ -39,7 +40,6 @@ use std::str;\n use std::sync::Arc;\n use std::marker::PhantomData;\n use syntax::symbol::InternedString;\n-use syntax_pos::DUMMY_SP;\n use abi::Abi;\n \n #[derive(Clone, Default)]\n@@ -319,15 +319,15 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     }\n \n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx, ty::ParamEnv::empty(traits::Reveal::All))\n+        common::type_needs_drop(self.tcx, ty)\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+        common::type_is_sized(self.tcx, ty)\n     }\n \n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+        common::type_is_freeze(self.tcx, ty)\n     }\n \n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "333f7b1c029c136ca03fddf23fb140ceb9d5425c", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -1803,7 +1803,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = common::def_ty(cx.shared(), node_def_id, Substs::empty());\n+    let variable_type = common::def_ty(cx.tcx(), node_def_id, Substs::empty());\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "7e2ac95cd845cdab9d60d40b2fca2bd57d2ba8c1", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -428,7 +428,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n                 let impl_self_ty =\n-                    common::def_ty(cx.shared(), impl_def_id, instance.substs);\n+                    common::def_ty(cx.tcx(), impl_def_id, instance.substs);\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`)."}, {"sha": "1572f1dc230c1a9e6329ec162813c363bcdbef63", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -14,15 +14,16 @@\n \n use std;\n \n-use llvm;\n-use llvm::{ValueRef};\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutTyper;\n+use builder::Builder;\n use common::*;\n+use llvm::{ValueRef};\n+use llvm;\n use meth;\n use monomorphize;\n+use rustc::traits;\n+use rustc::ty::layout::LayoutTyper;\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n use value::Value;\n-use builder::Builder;\n \n pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {"}, {"sha": "88407947f0ef40cf306ccba38a61013f72bf1f4a", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -80,7 +80,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n \n     let mut components: Vec<_> = [\n-        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n+        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx(), ty)),\n         C_usize(ccx, ccx.size_of(ty)),\n         C_usize(ccx, ccx.align_of(ty) as u64)\n     ].iter().cloned().collect();"}, {"sha": "9246822b339202a94d3e7a97bd9fcd38dbe786da", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.shared(), ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.tcx(), ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n@@ -429,7 +429,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let (instance, mut llfn) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n-                        (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n+                        (Some(monomorphize::resolve(bcx.ccx.tcx(), def_id, substs)),\n                          None)\n                     }\n                     ty::TyFnPtr(_) => {\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n \n                     let callee_ty = common::instance_ty(\n-                        bcx.ccx.shared(), instance.as_ref().unwrap());\n+                        bcx.ccx.tcx(), instance.as_ref().unwrap());\n                     trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &llargs, dest,\n                                          terminator.source_info.span);\n "}, {"sha": "9232d73f832e7e37cbda33cae0ea1bafb547a597", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n+        let instance = monomorphize::resolve(ccx.tcx(), def_id, substs);\n         let mir = ccx.tcx().instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }"}, {"sha": "822431eba42f156eb3563681350c11ac2ce518c1", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bcx.ccx.shared(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                    bcx.ccx.tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {"}, {"sha": "e62924a54d757ca496b286aaf48dc64ee52f997b", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -85,27 +85,26 @@ fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n }\n \n pub fn resolve_closure<'a, 'tcx> (\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n     requested_kind: ty::ClosureKind)\n     -> Instance<'tcx>\n {\n-    let actual_kind = scx.tcx().closure_kind(def_id);\n+    let actual_kind = tcx.closure_kind(def_id);\n \n     match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n-        Ok(true) => fn_once_adapter_instance(scx.tcx(), def_id, substs),\n+        Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n         _ => Instance::new(def_id, substs.substs)\n     }\n }\n \n fn resolve_associated_item<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n ) -> Instance<'tcx> {\n-    let tcx = scx.tcx();\n     let def_id = trait_item.def_id;\n     debug!(\"resolve_associated_item(trait_item={:?}, \\\n                                     trait_id={:?}, \\\n@@ -132,7 +131,7 @@ fn resolve_associated_item<'a, 'tcx>(\n         }\n         traits::VtableClosure(closure_data) => {\n             let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n-            resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,\n+            resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n                             trait_closure_kind)\n         }\n         traits::VtableFnPointer(ref data) => {\n@@ -163,21 +162,21 @@ fn resolve_associated_item<'a, 'tcx>(\n /// The point where linking happens. Resolve a (def_id, substs)\n /// pair to an instance.\n pub fn resolve<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     substs: &'tcx Substs<'tcx>\n ) -> Instance<'tcx> {\n     debug!(\"resolve(def_id={:?}, substs={:?})\",\n            def_id, substs);\n-    let result = if let Some(trait_def_id) = scx.tcx().trait_of_item(def_id) {\n+    let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n         debug!(\" => associated item, attempting to find impl\");\n-        let item = scx.tcx().associated_item(def_id);\n-        resolve_associated_item(scx, &item, trait_def_id, substs)\n+        let item = tcx.associated_item(def_id);\n+        resolve_associated_item(tcx, &item, trait_def_id, substs)\n     } else {\n-        let item_type = def_ty(scx, def_id, substs);\n+        let item_type = def_ty(tcx, def_id, substs);\n         let def = match item_type.sty {\n             ty::TyFnDef(..) if {\n-                    let f = item_type.fn_sig(scx.tcx());\n+                    let f = item_type.fn_sig(tcx);\n                     f.abi() == Abi::RustIntrinsic ||\n                     f.abi() == Abi::PlatformIntrinsic\n                 } =>\n@@ -186,9 +185,9 @@ pub fn resolve<'a, 'tcx>(\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n             _ => {\n-                if Some(def_id) == scx.tcx().lang_items().drop_in_place_fn() {\n+                if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n                     let ty = substs.type_at(0);\n-                    if scx.type_needs_drop(ty) {\n+                    if common::type_needs_drop(tcx, ty) {\n                         debug!(\" => nontrivial drop glue\");\n                         ty::InstanceDef::DropGlue(def_id, Some(ty))\n                     } else {\n@@ -209,27 +208,27 @@ pub fn resolve<'a, 'tcx>(\n }\n \n pub fn resolve_drop_in_place<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>)\n     -> ty::Instance<'tcx>\n {\n-    let def_id = scx.tcx().require_lang_item(DropInPlaceFnLangItem);\n-    let substs = scx.tcx().intern_substs(&[Kind::from(ty)]);\n-    resolve(scx, def_id, substs)\n+    let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n+    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    resolve(tcx, def_id, substs)\n }\n \n-pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n-                                             source_ty: Ty<'tcx>,\n-                                             target_ty: Ty<'tcx>)\n-                                             -> CustomCoerceUnsized {\n+pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           source_ty: Ty<'tcx>,\n+                                           target_ty: Ty<'tcx>)\n+                                           -> CustomCoerceUnsized {\n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: scx.tcx().lang_items().coerce_unsized_trait().unwrap(),\n-        substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n+        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+        substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match scx.tcx().trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n+    match tcx.trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n+            tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n         vtable => {\n             bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);"}, {"sha": "782a00648ce21e3dfde099448b3d6e5a9a665332", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -621,7 +621,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = common::def_ty(scx, impl_def_id, instance.substs);\n+                let impl_self_ty = common::def_ty(scx.tcx(), impl_def_id, instance.substs);\n                 if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                     return Some(def_id);\n                 }"}, {"sha": "5a51f690c45f11cb4a98a5f2243327cc52748592", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=c72240acf7a1ea107c3d995f1ca5ceb1086e7cc3", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().hir.local_def_id(node_id);\n         let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = common::instance_ty(ccx.shared(), &instance);\n+        let ty = common::instance_ty(ccx.tcx(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let mono_ty = common::instance_ty(ccx.shared(), &instance);\n+        let mono_ty = common::instance_ty(ccx.tcx(), &instance);\n         let attrs = instance.def.attrs(ccx.tcx());\n         let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, linkage) };"}]}