{"sha": "4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "node_id": "C_kwDOAAsO6NoAKDRjMjdkMzQ4ZWM5YTVhZjlhYzg5MzdkNGIzNWRkOGIyNDU1NzkyY2Y", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-01-11T18:32:01Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-01-17T16:32:21Z"}, "message": "directly use ConstValue for single literals in blocks", "tree": {"sha": "8bd6698618727d9dcfcc58d2e9a5683cc162d39f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bd6698618727d9dcfcc58d2e9a5683cc162d39f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "html_url": "https://github.com/rust-lang/rust/commit/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc65bf3ded93352fd4693a9c58b84a60721637a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc65bf3ded93352fd4693a9c58b84a60721637a6", "html_url": "https://github.com/rust-lang/rust/commit/cc65bf3ded93352fd4693a9c58b84a60721637a6"}], "stats": {"total": 32, "additions": 15, "deletions": 17}, "files": [{"sha": "7d02f5d1681574ea114e5c6d47d51d8c86ad424e", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "patch": "@@ -36,6 +36,7 @@ impl<'tcx> Const<'tcx> {\n         Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n \n+    #[instrument(skip(tcx), level = \"debug\")]\n     pub fn from_opt_const_arg_anon_const(\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n@@ -53,6 +54,7 @@ impl<'tcx> Const<'tcx> {\n         };\n \n         let expr = &tcx.hir().body(body_id).value;\n+        debug!(?expr);\n \n         let ty = tcx.type_of(def.def_id_for_type_of());\n \n@@ -69,11 +71,21 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n+    #[instrument(skip(tcx), level = \"debug\")]\n     fn try_eval_lit_or_param(\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Option<&'tcx Self> {\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n         let lit_input = match expr.kind {\n             hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n             hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n@@ -95,15 +107,6 @@ impl<'tcx> Const<'tcx> {\n             }\n         }\n \n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.kind {\n-            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n-                block.expr.as_ref().unwrap()\n-            }\n-            _ => expr,\n-        };\n-\n         use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n         match expr.kind {\n             ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {"}, {"sha": "297216446a24329bc4767a333289739a87e6f647", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "patch": "@@ -53,6 +53,7 @@ pub fn add_placeholder_note(err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n /// If there are types that satisfy both impls, invokes `on_overlap`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n+#[instrument(skip(tcx, skip_leak_check, on_overlap, no_overlap), level = \"debug\")]\n pub fn overlapping_impls<F1, F2, R>(\n     tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n@@ -65,12 +66,6 @@ where\n     F1: FnOnce(OverlapResult<'_>) -> R,\n     F2: FnOnce() -> R,\n {\n-    debug!(\n-        \"overlapping_impls(\\\n-           impl1_def_id={:?}, \\\n-           impl2_def_id={:?})\",\n-        impl1_def_id, impl2_def_id,\n-    );\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n@@ -85,6 +80,7 @@ where\n     .any(|(ty1, ty2)| {\n         let t1 = fast_reject::simplify_type(tcx, ty1, SimplifyParams::No, StripReferences::No);\n         let t2 = fast_reject::simplify_type(tcx, ty2, SimplifyParams::No, StripReferences::No);\n+\n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully\n             t1 != t2"}, {"sha": "cd2e0f18e0cc0f6404c801f1a20941f209f6e74f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c27d348ec9a5af9ac8937d4b35dd8b2455792cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4c27d348ec9a5af9ac8937d4b35dd8b2455792cf", "patch": "@@ -117,9 +117,8 @@ pub fn translate_substs<'a, 'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n+#[instrument(skip(tcx), level = \"debug\")]\n pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId, DefId)) -> bool {\n-    debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n-\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     let features = tcx.features();"}]}