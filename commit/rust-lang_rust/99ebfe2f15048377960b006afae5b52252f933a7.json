{"sha": "99ebfe2f15048377960b006afae5b52252f933a7", "node_id": "C_kwDOAAsO6NoAKDk5ZWJmZTJmMTUwNDgzNzc5NjBiMDA2YWZhZTViNTIyNTJmOTMzYTc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-19T11:06:46Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-24T13:53:37Z"}, "message": "move index code around", "tree": {"sha": "9ad25d3c82f0f6e80684ee23d359e0d785779fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ad25d3c82f0f6e80684ee23d359e0d785779fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99ebfe2f15048377960b006afae5b52252f933a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99ebfe2f15048377960b006afae5b52252f933a7", "html_url": "https://github.com/rust-lang/rust/commit/99ebfe2f15048377960b006afae5b52252f933a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99ebfe2f15048377960b006afae5b52252f933a7/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e496fbec922b22d9b506ba55386c482b4bf06378", "url": "https://api.github.com/repos/rust-lang/rust/commits/e496fbec922b22d9b506ba55386c482b4bf06378", "html_url": "https://github.com/rust-lang/rust/commit/e496fbec922b22d9b506ba55386c482b4bf06378"}], "stats": {"total": 199, "additions": 100, "deletions": 99}, "files": [{"sha": "8eae079e2f80d4e07ec3e459456e0632a7d54631", "filename": "compiler/rustc_index/src/slice.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/99ebfe2f15048377960b006afae5b52252f933a7/compiler%2Frustc_index%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebfe2f15048377960b006afae5b52252f933a7/compiler%2Frustc_index%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fslice.rs?ref=99ebfe2f15048377960b006afae5b52252f933a7", "patch": "@@ -5,7 +5,7 @@ use std::{\n     slice,\n };\n \n-use crate::{idx::Idx, vec::IndexVec};\n+use crate::{Idx, IndexVec};\n \n /// A view into contiguous `T`s, indexed by `I` rather than by `usize`.\n ///\n@@ -140,6 +140,17 @@ impl<I: Idx, T> IndexSlice<I, T> {\n         let ptr = self.raw.as_mut_ptr();\n         unsafe { (&mut *ptr.add(ai), &mut *ptr.add(bi), &mut *ptr.add(ci)) }\n     }\n+\n+    #[inline]\n+    pub fn binary_search(&self, value: &T) -> Result<I, I>\n+    where\n+        T: Ord,\n+    {\n+        match self.raw.binary_search(value) {\n+            Ok(i) => Ok(Idx::new(i)),\n+            Err(i) => Err(Idx::new(i)),\n+        }\n+    }\n }\n \n impl<I: Idx, J: Idx> IndexSlice<I, J> {\n@@ -172,20 +183,6 @@ impl<I: Idx, J: Idx> IndexSlice<I, J> {\n     }\n }\n \n-impl<I: Idx, T: Ord> IndexSlice<I, T> {\n-    #[inline]\n-    pub fn binary_search(&self, value: &T) -> Result<I, I> {\n-        match self.raw.binary_search(value) {\n-            Ok(i) => Ok(Idx::new(i)),\n-            Err(i) => Err(Idx::new(i)),\n-        }\n-    }\n-}\n-\n-// Whether `IndexSlice` is `Send` depends only on the data,\n-// not the phantom data.\n-unsafe impl<I: Idx, T> Send for IndexSlice<I, T> where T: Send {}\n-\n impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexSlice<I, T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.raw, fmt)\n@@ -208,6 +205,26 @@ impl<I: Idx, T> IndexMut<I> for IndexSlice<I, T> {\n     }\n }\n \n+impl<'a, I: Idx, T> IntoIterator for &'a IndexSlice<I, T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.raw.iter()\n+    }\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a mut IndexSlice<I, T> {\n+    type Item = &'a mut T;\n+    type IntoIter = slice::IterMut<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::IterMut<'a, T> {\n+        self.raw.iter_mut()\n+    }\n+}\n+\n impl<I: Idx, T: Clone> ToOwned for IndexSlice<I, T> {\n     type Owned = IndexVec<I, T>;\n \n@@ -234,22 +251,6 @@ impl<I: Idx, T> Default for &mut IndexSlice<I, T> {\n     }\n }\n \n-impl<'a, I: Idx, T> IntoIterator for &'a IndexSlice<I, T> {\n-    type Item = &'a T;\n-    type IntoIter = slice::Iter<'a, T>;\n-\n-    #[inline]\n-    fn into_iter(self) -> slice::Iter<'a, T> {\n-        self.raw.iter()\n-    }\n-}\n-\n-impl<'a, I: Idx, T> IntoIterator for &'a mut IndexSlice<I, T> {\n-    type Item = &'a mut T;\n-    type IntoIter = slice::IterMut<'a, T>;\n-\n-    #[inline]\n-    fn into_iter(self) -> slice::IterMut<'a, T> {\n-        self.raw.iter_mut()\n-    }\n-}\n+// Whether `IndexSlice` is `Send` depends only on the data,\n+// not the phantom data.\n+unsafe impl<I: Idx, T> Send for IndexSlice<I, T> where T: Send {}"}, {"sha": "dce5334461eac81ca660bbee8ef6ae7a7f7889e5", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/99ebfe2f15048377960b006afae5b52252f933a7/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebfe2f15048377960b006afae5b52252f933a7/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=99ebfe2f15048377960b006afae5b52252f933a7", "patch": "@@ -9,8 +9,7 @@ use std::ops::{Deref, DerefMut, RangeBounds};\n use std::slice;\n use std::vec;\n \n-use crate::idx::Idx;\n-use crate::slice::IndexSlice;\n+use crate::{Idx, IndexSlice};\n \n /// An owned contiguous collection of `T`s, indexed by `I` rather than by `usize`.\n ///\n@@ -25,30 +24,6 @@ pub struct IndexVec<I: Idx, T> {\n     _marker: PhantomData<fn(&I)>,\n }\n \n-// Whether `IndexVec` is `Send` depends only on the data,\n-// not the phantom data.\n-unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n-\n-#[cfg(feature = \"rustc_serialize\")]\n-impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n-    fn encode(&self, s: &mut S) {\n-        Encodable::encode(&self.raw, s);\n-    }\n-}\n-\n-#[cfg(feature = \"rustc_serialize\")]\n-impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n-    fn decode(d: &mut D) -> Self {\n-        IndexVec { raw: Decodable::decode(d), _marker: PhantomData }\n-    }\n-}\n-\n-impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexVec<I, T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(&self.raw, fmt)\n-    }\n-}\n-\n impl<I: Idx, T> IndexVec<I, T> {\n     #[inline]\n     pub fn new() -> Self {\n@@ -183,13 +158,45 @@ impl<I: Idx, T> IndexVec<I, T> {\n         &mut self[elem]\n     }\n \n+    #[inline]\n+    pub fn resize(&mut self, new_len: usize, value: T)\n+    where\n+        T: Clone,\n+    {\n+        self.raw.resize(new_len, value)\n+    }\n+\n     #[inline]\n     pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n         let min_new_len = elem.index() + 1;\n         self.raw.resize_with(min_new_len, fill_value);\n     }\n }\n \n+/// `IndexVec` is often used as a map, so it provides some map-like APIs.\n+impl<I: Idx, T> IndexVec<I, Option<T>> {\n+    #[inline]\n+    pub fn insert(&mut self, index: I, value: T) -> Option<T> {\n+        self.ensure_contains_elem(index, || None).replace(value)\n+    }\n+\n+    #[inline]\n+    pub fn get_or_insert_with(&mut self, index: I, value: impl FnOnce() -> T) -> &mut T {\n+        self.ensure_contains_elem(index, || None).get_or_insert_with(value)\n+    }\n+\n+    #[inline]\n+    pub fn remove(&mut self, index: I) -> Option<T> {\n+        self.get_mut(index)?.take()\n+    }\n+}\n+\n+impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexVec<I, T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.raw, fmt)\n+    }\n+}\n+\n impl<I: Idx, T> Deref for IndexVec<I, T> {\n     type Target = IndexSlice<I, T>;\n \n@@ -218,38 +225,6 @@ impl<I: Idx, T> BorrowMut<IndexSlice<I, T>> for IndexVec<I, T> {\n     }\n }\n \n-/// `IndexVec` is often used as a map, so it provides some map-like APIs.\n-impl<I: Idx, T> IndexVec<I, Option<T>> {\n-    #[inline]\n-    pub fn insert(&mut self, index: I, value: T) -> Option<T> {\n-        self.ensure_contains_elem(index, || None).replace(value)\n-    }\n-\n-    #[inline]\n-    pub fn get_or_insert_with(&mut self, index: I, value: impl FnOnce() -> T) -> &mut T {\n-        self.ensure_contains_elem(index, || None).get_or_insert_with(value)\n-    }\n-\n-    #[inline]\n-    pub fn remove(&mut self, index: I) -> Option<T> {\n-        self.get_mut(index)?.take()\n-    }\n-}\n-\n-impl<I: Idx, T: Clone> IndexVec<I, T> {\n-    #[inline]\n-    pub fn resize(&mut self, new_len: usize, value: T) {\n-        self.raw.resize(new_len, value)\n-    }\n-}\n-\n-impl<I: Idx, T> Default for IndexVec<I, T> {\n-    #[inline]\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     #[inline]\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n@@ -279,13 +254,6 @@ impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {\n     }\n }\n \n-impl<I: Idx, T, const N: usize> From<[T; N]> for IndexVec<I, T> {\n-    #[inline]\n-    fn from(array: [T; N]) -> Self {\n-        IndexVec::from_raw(array.into())\n-    }\n-}\n-\n impl<I: Idx, T> IntoIterator for IndexVec<I, T> {\n     type Item = T;\n     type IntoIter = vec::IntoIter<T>;\n@@ -316,5 +284,37 @@ impl<'a, I: Idx, T> IntoIterator for &'a mut IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T> Default for IndexVec<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<I: Idx, T, const N: usize> From<[T; N]> for IndexVec<I, T> {\n+    #[inline]\n+    fn from(array: [T; N]) -> Self {\n+        IndexVec::from_raw(array.into())\n+    }\n+}\n+\n+#[cfg(feature = \"rustc_serialize\")]\n+impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n+    fn encode(&self, s: &mut S) {\n+        Encodable::encode(&self.raw, s);\n+    }\n+}\n+\n+#[cfg(feature = \"rustc_serialize\")]\n+impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n+    fn decode(d: &mut D) -> Self {\n+        IndexVec { raw: Decodable::decode(d), _marker: PhantomData }\n+    }\n+}\n+\n+// Whether `IndexVec` is `Send` depends only on the data,\n+// not the phantom data.\n+unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n+\n #[cfg(test)]\n mod tests;"}]}