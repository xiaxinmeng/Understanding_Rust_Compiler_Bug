{"sha": "96607d45936c80eead2b1ac89b2c6a658a19489e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NjA3ZDQ1OTM2YzgwZWVhZDJiMWFjODliMmM2YTY1OGExOTQ4OWU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-01-31T09:36:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-01-31T09:36:27Z"}, "message": "document our packed struct strategy", "tree": {"sha": "7a1685e6b95387f63368a70e3902eb6e44c89f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a1685e6b95387f63368a70e3902eb6e44c89f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96607d45936c80eead2b1ac89b2c6a658a19489e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96607d45936c80eead2b1ac89b2c6a658a19489e", "html_url": "https://github.com/rust-lang/rust/commit/96607d45936c80eead2b1ac89b2c6a658a19489e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96607d45936c80eead2b1ac89b2c6a658a19489e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93a75f954252f009572321e96a3ed7a1f991e3cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/93a75f954252f009572321e96a3ed7a1f991e3cb", "html_url": "https://github.com/rust-lang/rust/commit/93a75f954252f009572321e96a3ed7a1f991e3cb"}], "stats": {"total": 50, "additions": 42, "deletions": 8}, "files": [{"sha": "47ed4fd0cebfb2559c08b7a93cd4705d8283eed8", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96607d45936c80eead2b1ac89b2c6a658a19489e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96607d45936c80eead2b1ac89b2c6a658a19489e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=96607d45936c80eead2b1ac89b2c6a658a19489e", "patch": "@@ -5,7 +5,6 @@\n     i128_type,\n     pub_restricted,\n     rustc_private,\n-    collections_bound,\n )]\n \n // From rustc."}, {"sha": "12345b87804c0cbdae72303516a2502073fe2c00", "filename": "src/memory.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/96607d45936c80eead2b1ac89b2c6a658a19489e/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96607d45936c80eead2b1ac89b2c6a658a19489e/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=96607d45936c80eead2b1ac89b2c6a658a19489e", "patch": "@@ -121,6 +121,14 @@ pub struct Memory<'a, 'tcx> {\n     next_id: AllocId,\n     pub layout: &'a TargetDataLayout,\n     /// List of memory regions containing packed structures\n+    /// We mark memory as \"packed\" or \"unaligned\" for a single statement, and clear the marking afterwards.\n+    /// In the case where no packed structs are present, it's just a single emptyness check of a set\n+    /// instead of heavily influencing all memory access code as other solutions would.\n+    ///\n+    /// One disadvantage of this solution is the fact that you can cast a pointer to a packed struct\n+    /// to a pointer to a normal struct and if you access a field of both in the same MIR statement,\n+    /// the normal struct access will succeed even though it shouldn't.\n+    /// But even with mir optimizations, that situation is hard/impossible to produce.\n     packed: BTreeSet<Entry>,\n }\n \n@@ -285,11 +293,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx, ()> {\n         let alloc = self.get(ptr.alloc_id)?;\n-        // check whether the memory was marked as aligned\n-        let start = Entry(ptr.alloc_id, 0, ptr.offset + len);\n-        let end = Entry(ptr.alloc_id, ptr.offset + len, 0);\n-        for &Entry(_, start, end) in self.packed.range(start..end) {\n-            if start <= ptr.offset && (ptr.offset + len) <= end {\n+        // check whether the memory was marked as packed\n+        // we select all elements that have the correct alloc_id and are within\n+        // the range given by the offset into the allocation and the length\n+        let start = Entry {\n+            alloc_id: ptr.alloc_id,\n+            packed_start: 0,\n+            packed_end: ptr.offset + len,\n+        };\n+        let end = Entry {\n+            alloc_id: ptr.alloc_id,\n+            packed_start: ptr.offset + len,\n+            packed_end: 0,\n+        };\n+        for &Entry { packed_start, packed_end, .. } in self.packed.range(start..end) {\n+            // if the region we are checking is covered by a region in `packed`\n+            // ignore the actual alignment\n+            if packed_start <= ptr.offset && (ptr.offset + len) <= packed_end {\n                 return Ok(());\n             }\n         }\n@@ -310,16 +330,31 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub(crate) fn mark_packed(&mut self, ptr: Pointer, len: u64) {\n-        self.packed.insert(Entry(ptr.alloc_id, ptr.offset, ptr.offset + len));\n+        self.packed.insert(Entry {\n+            alloc_id: ptr.alloc_id,\n+            packed_start: ptr.offset,\n+            packed_end: ptr.offset + len,\n+        });\n     }\n \n     pub(crate) fn clear_packed(&mut self) {\n         self.packed.clear();\n     }\n }\n \n+// The derived `Ord` impl sorts first by the first field, then, if the fields are the same\n+// by the second field, and if those are the same, too, then by the third field.\n+// This is exactly what we need for our purposes, since a range within an allocation\n+// will give us all `Entry`s that have that `AllocId`, and whose `packed_start` is <= than\n+// the one we're looking for, but not > the end of the range we're checking.\n+// At the same time the `packed_end` is irrelevant for the sorting and range searching, but used for the check.\n+// This kind of search breaks, if `packed_end < packed_start`, so don't do that!\n #[derive(Eq, PartialEq, Ord, PartialOrd)]\n-struct Entry(AllocId, u64, u64);\n+struct Entry {\n+    alloc_id: AllocId,\n+    packed_start: u64,\n+    packed_end: u64,\n+}\n \n /// Allocation accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {"}]}