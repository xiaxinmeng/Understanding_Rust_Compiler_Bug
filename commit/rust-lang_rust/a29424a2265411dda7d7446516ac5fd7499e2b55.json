{"sha": "a29424a2265411dda7d7446516ac5fd7499e2b55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyOTQyNGEyMjY1NDExZGRhN2Q3NDQ2NTE2YWM1ZmQ3NDk5ZTJiNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-07T17:47:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-07T17:47:11Z"}, "message": "Auto merge of #68933 - Dylan-DPC:rollup-akz13kj, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #68164 (Selectively disable sanitizer instrumentation)\n - #68413 (Add GitHub issue templates)\n - #68889 (Move the `hir().krate()` method to a query and remove the `Krate` dep node)\n - #68909 (Respect --nocapture in panic=abort test mode)\n - #68910 (Add myself to .mailmap)\n - #68919 (Remove HashStable impl for ast::Lifetime)\n - #68928 (clean up E0276 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4642f87dd4f6a664038e9609e5f8a5090daf4bf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4642f87dd4f6a664038e9609e5f8a5090daf4bf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a29424a2265411dda7d7446516ac5fd7499e2b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a29424a2265411dda7d7446516ac5fd7499e2b55", "html_url": "https://github.com/rust-lang/rust/commit/a29424a2265411dda7d7446516ac5fd7499e2b55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a29424a2265411dda7d7446516ac5fd7499e2b55/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb29dfcc9ada6ed10308b6e7f405569f61a9af0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb29dfcc9ada6ed10308b6e7f405569f61a9af0b", "html_url": "https://github.com/rust-lang/rust/commit/fb29dfcc9ada6ed10308b6e7f405569f61a9af0b"}, {"sha": "9681544f38fa8ffb8a601330e7e96272c92bf38f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9681544f38fa8ffb8a601330e7e96272c92bf38f", "html_url": "https://github.com/rust-lang/rust/commit/9681544f38fa8ffb8a601330e7e96272c92bf38f"}], "stats": {"total": 883, "additions": 680, "deletions": 203}, "files": [{"sha": "9aef3ebe637a1d1b325266165389786032876f93", "filename": ".github/ISSUE_TEMPLATE/blank_issue.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,4 @@\n+---\n+name: Blank Issue\n+about: Create a blank issue.\n+---"}, {"sha": "5675579bc964a6aab3827db3b3c519c731f98143", "filename": ".github/ISSUE_TEMPLATE/bug_report.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,44 @@\n+---\n+name: Bug Report\n+about: Create a bug report for Rust.\n+labels: C-bug\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+-->\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary>Backtrace</summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>"}, {"sha": "bd7dc0ac95c1fc6a4c96c7357315f779daf77aef", "filename": ".github/ISSUE_TEMPLATE/config.yml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fconfig.yml?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,5 @@\n+blank_issues_enabled: true\n+contact_links:\n+  - name: Rust Programming Language Forum\n+    url: https://users.rust-lang.org\n+    about: Please ask and answer questions about Rust here."}, {"sha": "e669e4912f8c95c2b54a6beea4d428407a2cbd18", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,52 @@\n+---\n+name: Internal Compiler Error\n+about: Create a report for an internal compiler error in rustc.\n+labels: C-bug, I-ICE, T-compiler\n+---\n+<!--\n+Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n+a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n+how to create smaller examples.\n+\n+http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n+\n+-->\n+\n+### Code\n+\n+```\n+<code>\n+```\n+\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+### Error output\n+\n+```\n+<output>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary><strong>Backtrace</strong></summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>\n+"}, {"sha": "f93591204cd98cbdff70b5c4341c60d56c105995", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,58 @@\n+---\n+name: Tracking Issue\n+about: A tracking issue for a feature in Rust.\n+title: Tracking Issue for XXX\n+labels: C-tracking-issue\n+---\n+<!--\n+Thank you for creating a tracking issue! \ud83d\udcdc Tracking issues are for tracking a\n+feature from implementation to stabilisation. Make sure to include the relevant\n+RFC for the feature if it has one. Otherwise provide a short summary of the\n+feature and link any relevant PRs or issues, and remove any sections that are\n+not relevant to the feature.\n+\n+Remember to add team labels to the tracking issue.\n+For a language team feature, this would e.g., be `T-lang`.\n+Such a feature should also be labeled with e.g., `F-my_feature`.\n+This label is used to associate issues (e.g., bugs and design questions) to the feature.\n+-->\n+\n+This is a tracking issue for the RFC \"XXX\" (rust-lang/rfcs#NNN).\n+The feature gate for the issue is `#![feature(FFF)]`.\n+\n+### About tracking issues\n+\n+Tracking issues are used to record the overall progress of implementation.\n+They are also uses as hubs connecting to other relevant issues, e.g., bugs or open design questions.\n+A tracking issue is however *not* meant for large scale discussion, questions, or bug reports about a feature.\n+Instead, open a dedicated issue for the specific matter and add the relevant feature gate label.\n+\n+### Steps\n+<!--\n+Include each step required to complete the feature. Typically this is a PR\n+implementing a feature, followed by a PR that stabilises the feature. However\n+for larger features an implementation could be broken up into multiple PRs.\n+-->\n+\n+- [ ] Implement the RFC (cc @rust-lang/XXX -- can anyone write up mentoring\n+      instructions?)\n+- [ ] Adjust documentation ([see instructions on rustc-guide][doc-guide])\n+- [ ] Stabilization PR ([see instructions on rustc-guide][stabilization-guide])\n+\n+[stabilization-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#stabilization-pr\n+[doc-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#documentation-prs\n+\n+### Unresolved Questions\n+<!--\n+Include any open questions that need to be answered before the feature can be\n+stabilised.\n+-->\n+\n+XXX --- list all the \"unresolved questions\" found in the RFC to ensure they are\n+not forgotten\n+\n+### Implementation history\n+\n+<!--\n+Include a list of all the PRs that were involved in implementing the feature.\n+-->"}, {"sha": "14797092475a296a37cf7ef92f35e2f2425e6cee", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -100,6 +100,7 @@ Graydon Hoare <graydon@pobox.com> Graydon Hoare <graydon@mozilla.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com> ggomez <ggomez@ggo.ifr.lan>\n Guillaume Gomez <guillaume1.gomez@gmail.com> Guillaume Gomez <ggomez@ggo.ifr.lan>\n+Hanna Kruppe <hanna.kruppe@gmail.com> <robin.kruppe@gmail.com>\n Heather <heather@cynede.net> <Cynede@Gentoo.org>\n Heather <heather@cynede.net> <Heather@cynede.net>\n Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtke@gmail.com>"}, {"sha": "28c683934d4ed10d0454f039418e7c2d2ed1b603", "filename": "src/doc/unstable-book/src/language-features/no-sanitize.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,29 @@\n+# `no_sanitize`\n+\n+The tracking issue for this feature is: [#39699]\n+\n+[#39699]: https://github.com/rust-lang/rust/issues/39699\n+\n+------------------------\n+\n+The `no_sanitize` attribute can be used to selectively disable sanitizer\n+instrumentation in an annotated function. This might be useful to: avoid\n+instrumentation overhead in a performance critical function, or avoid\n+instrumenting code that contains constructs unsupported by given sanitizer.\n+\n+The precise effect of this annotation depends on particular sanitizer in use.\n+For example, with `no_sanitize(thread)`, the thread sanitizer will no longer\n+instrument non-atomic store / load operations, but it will instrument atomic\n+operations to avoid reporting false positives and provide meaning full stack\n+traces.\n+\n+## Examples\n+\n+``` rust\n+#![feature(no_sanitize)]\n+\n+#[no_sanitize(address)]\n+fn foo() {\n+  // ...\n+}\n+```"}, {"sha": "dd242686d26f202aa82c7cf7027b09f73e1d946f", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -127,7 +127,7 @@ macro_rules! arena_types {\n             [] tys: rustc::ty::TyS<$tcx>,\n \n             // HIR types\n-            [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n+            [few] hir_krate: rustc_hir::Crate<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,"}, {"sha": "29b94986a5f3a00b6effa877341231b78011b645", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -35,7 +35,7 @@\n //! \"infer\" some properties for each kind of `DepNode`:\n //!\n //! * Whether a `DepNode` of a given kind has any parameters at all. Some\n-//!   `DepNode`s, like `Krate`, represent global concepts with only one value.\n+//!   `DepNode`s, like `AllLocalTraitImpls`, represent global concepts with only one value.\n //! * Whether it is possible, in principle, to reconstruct a query key from a\n //!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n //!   in which case it is possible to map the node's fingerprint back to the\n@@ -400,19 +400,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n \n-    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    // distinct from the krate module). This is basically a hash of\n-    // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.hir().krate()`), we will have to assume that any change\n-    // means that you need to be recompiled. This is because the\n-    // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.hir().krate()`; instead, prefer\n-    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    // access to the krate, but you must remember to add suitable\n-    // edges yourself for the individual items that you read.\n-    [eval_always] Krate,\n-\n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n     [eval_always] HirBody(DefId),"}, {"sha": "4c922654e02d57bd7ca836a5d4d780eb15806e87", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -223,12 +223,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             (commandline_args_hash, crate_disambiguator.to_fingerprint()),\n         );\n \n-        let (_, crate_hash) = input_dep_node_and_hash(\n-            self.dep_graph,\n-            &mut self.hcx,\n-            DepNode::new_no_params(DepKind::Krate),\n-            crate_hash_input,\n-        );\n+        let mut stable_hasher = StableHasher::new();\n+        crate_hash_input.hash_stable(&mut self.hcx, &mut stable_hasher);\n+        let crate_hash: Fingerprint = stable_hasher.finish();\n \n         let svh = Svh::new(crate_hash.to_smaller_hash());\n         (self.map, svh)"}, {"sha": "c721faafbecaf408ea04765882477834001be719", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -12,7 +12,7 @@ pub fn check_crate(hir_map: &Map<'_>) {\n \n     let errors = Lock::new(Vec::new());\n \n-    par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n+    par_iter(&hir_map.krate.modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n             local_def_id,"}, {"sha": "1645420892a7531c7eebb061f989c4f66f06d0a9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 31, "deletions": 67, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -129,30 +129,6 @@ impl<'hir> Entry<'hir> {\n     }\n }\n \n-/// Stores a crate and any number of inlined items from other crates.\n-pub struct Forest<'hir> {\n-    krate: Crate<'hir>,\n-    pub dep_graph: DepGraph,\n-}\n-\n-impl Forest<'hir> {\n-    pub fn new(krate: Crate<'hir>, dep_graph: &DepGraph) -> Forest<'hir> {\n-        Forest { krate, dep_graph: dep_graph.clone() }\n-    }\n-\n-    pub fn krate(&self) -> &Crate<'hir> {\n-        self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n-        &self.krate\n-    }\n-\n-    /// This is used internally in the dependency tracking system.\n-    /// Use the `krate` method to ensure your dependency on the\n-    /// crate is tracked.\n-    pub fn untracked_krate(&self) -> &Crate<'hir> {\n-        &self.krate\n-    }\n-}\n-\n /// This type is effectively a `HashMap<HirId, Entry<'hir>>`,\n /// but it is implemented as 2 layers of arrays.\n /// - first we have `A = IndexVec<DefIndex, B>` mapping `DefIndex`s to an inner value\n@@ -162,11 +138,8 @@ pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Opt\n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n-    /// The backing storage for all the AST nodes.\n-    pub forest: &'hir Forest<'hir>,\n+    krate: &'hir Crate<'hir>,\n \n-    /// Same as the dep_graph in forest, just available with one fewer\n-    /// deref. This is a gratuitous micro-optimization.\n     pub dep_graph: DepGraph,\n \n     /// The SVH of the local crate.\n@@ -217,6 +190,13 @@ impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n }\n \n impl<'hir> Map<'hir> {\n+    /// This is used internally in the dependency tracking system.\n+    /// Use the `krate` method to ensure your dependency on the\n+    /// crate is tracked.\n+    pub fn untracked_krate(&self) -> &Crate<'hir> {\n+        &self.krate\n+    }\n+\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n         let local_map = self.map.get(id.owner)?;\n@@ -401,40 +381,36 @@ impl<'hir> Map<'hir> {\n         self.lookup(id).cloned()\n     }\n \n-    pub fn krate(&self) -> &'hir Crate<'hir> {\n-        self.forest.krate()\n-    }\n-\n     pub fn item(&self, id: HirId) -> &'hir Item<'hir> {\n         self.read(id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.item(id)\n+        self.krate.item(id)\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.trait_item(id)\n+        self.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.impl_item(id)\n+        self.krate.impl_item(id)\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.body(id)\n+        self.krate.body(id)\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n@@ -530,9 +506,9 @@ impl<'hir> Map<'hir> {\n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [HirId] {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n+        self.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     /// Gets the attributes on the crate. This is preferable to\n@@ -542,15 +518,15 @@ impl<'hir> Map<'hir> {\n         let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n \n         self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-        &self.forest.krate.attrs\n+        &self.krate.attrs\n     }\n \n     pub fn get_module(&self, module: DefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n-            Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n+            Node::Crate => (&self.krate.module, self.krate.span, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -567,7 +543,7 @@ impl<'hir> Map<'hir> {\n         // in the expect_* calls the loops below\n         self.read(hir_id);\n \n-        let module = &self.forest.krate.modules[&hir_id];\n+        let module = &self.krate.modules[&hir_id];\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));\n@@ -984,7 +960,7 @@ impl<'hir> Map<'hir> {\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n             Some(Node::Ctor(..)) => return self.attrs(self.get_parent_item(id)),\n-            Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n+            Some(Node::Crate) => Some(&self.krate.attrs[..]),\n             _ => None,\n         };\n         attrs.unwrap_or(&[])\n@@ -1063,7 +1039,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(Node::Local(local)) => local.span,\n             Some(Node::MacroDef(macro_def)) => macro_def.span,\n-            Some(Node::Crate) => self.forest.krate.span,\n+            Some(Node::Crate) => self.krate.span,\n             None => bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id),\n         }\n     }\n@@ -1231,7 +1207,8 @@ impl Named for ImplItem<'_> {\n pub fn map_crate<'hir>(\n     sess: &rustc_session::Session,\n     cstore: &CrateStoreDyn,\n-    forest: &'hir Forest<'hir>,\n+    krate: &'hir Crate<'hir>,\n+    dep_graph: DepGraph,\n     definitions: Definitions,\n ) -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n@@ -1244,31 +1221,18 @@ pub fn map_crate<'hir>(\n         .collect();\n \n     let (map, crate_hash) = {\n-        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, &definitions, cstore);\n-\n-        let mut collector = NodeCollector::root(\n-            sess,\n-            &forest.krate,\n-            &forest.dep_graph,\n-            &definitions,\n-            &hir_to_node_id,\n-            hcx,\n-        );\n-        intravisit::walk_crate(&mut collector, &forest.krate);\n+        let hcx = crate::ich::StableHashingContext::new(sess, krate, &definitions, cstore);\n+\n+        let mut collector =\n+            NodeCollector::root(sess, krate, &dep_graph, &definitions, &hir_to_node_id, hcx);\n+        intravisit::walk_crate(&mut collector, krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, cstore, cmdline_args)\n     };\n \n-    let map = Map {\n-        forest,\n-        dep_graph: forest.dep_graph.clone(),\n-        crate_hash,\n-        map,\n-        hir_to_node_id,\n-        definitions,\n-    };\n+    let map = Map { krate, dep_graph, crate_hash, map, hir_to_node_id, definitions };\n \n     sess.time(\"validate_HIR_map\", || {\n         hir_id_validator::check_crate(&map);"}, {"sha": "2e7e8fdd724916614e618c59b7cf8711f1414cda", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -7,7 +7,48 @@ pub mod exports;\n pub mod map;\n \n use crate::ty::query::Providers;\n+use crate::ty::TyCtxt;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::print;\n+use rustc_hir::Crate;\n+use std::ops::Deref;\n+\n+/// A wrapper type which allows you to access HIR.\n+#[derive(Clone)]\n+pub struct Hir<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    map: &'tcx map::Map<'tcx>,\n+}\n+\n+impl<'tcx> Hir<'tcx> {\n+    pub fn krate(&self) -> &'tcx Crate<'tcx> {\n+        self.tcx.hir_crate(LOCAL_CRATE)\n+    }\n+}\n+\n+impl<'tcx> Deref for Hir<'tcx> {\n+    type Target = &'tcx map::Map<'tcx>;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &Self::Target {\n+        &self.map\n+    }\n+}\n+\n+impl<'hir> print::PpAnn for Hir<'hir> {\n+    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n+        self.map.nested(state, nested)\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline(always)]\n+    pub fn hir(self) -> Hir<'tcx> {\n+        Hir { tcx: self, map: &self.hir_map }\n+    }\n+}\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    providers.hir_crate = |tcx, _| tcx.hir_map.untracked_krate();\n     map::provide(providers);\n }"}, {"sha": "d1815d5e320dba01023e2e1d16f0dc1616e388e0", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -12,13 +12,6 @@ use smallvec::SmallVec;\n \n impl<'ctx> rustc_target::HashStableContext for StableHashingContext<'ctx> {}\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Lifetime {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.id.hash_stable(hcx, hasher);\n-        self.ident.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if self.len() == 0 {"}, {"sha": "82adcfddc289ed5891d90ce31e4d699299ee5c99", "filename": "src/librustc/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -72,6 +72,14 @@ bitflags! {\n         const FFI_RETURNS_TWICE         = 1 << 10;\n         /// `#[track_caller]`: allow access to the caller location\n         const TRACK_CALLER              = 1 << 11;\n+        /// `#[no_sanitize(address)]`: disables address sanitizer instrumentation\n+        const NO_SANITIZE_ADDRESS = 1 << 12;\n+        /// `#[no_sanitize(memory)]`: disables memory sanitizer instrumentation\n+        const NO_SANITIZE_MEMORY  = 1 << 13;\n+        /// `#[no_sanitize(thread)]`: disables thread sanitizer instrumentation\n+        const NO_SANITIZE_THREAD  = 1 << 14;\n+        /// All `#[no_sanitize(...)]` attributes.\n+        const NO_SANITIZE_ANY = Self::NO_SANITIZE_ADDRESS.bits | Self::NO_SANITIZE_MEMORY.bits | Self::NO_SANITIZE_THREAD.bits;\n     }\n }\n "}, {"sha": "d1bccb961c48bbd3ebf6f5cf012a26829f672fd6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -43,6 +43,18 @@ rustc_queries! {\n     }\n \n     Other {\n+        // Represents crate as a whole (as distinct from the top-level crate module).\n+        // If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n+        // we will have to assume that any change means that you need to be recompiled.\n+        // This is because the `hir_crate` query gives you access to all other items.\n+        // To avoid this fate, do not call `tcx.hir().krate()`; instead,\n+        // prefer wrappers like `tcx.visit_all_items_in_krate()`.\n+        query hir_crate(key: CrateNum) -> &'tcx Crate<'tcx> {\n+            eval_always\n+            no_hash\n+            desc { \"get the crate HIR\" }\n+        }\n+\n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n             cache_on_disk_if { key.is_local() }"}, {"sha": "8386058f72ac7e692e57de3e350ad3d6aa7b63fd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -966,7 +966,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n \n-    hir_map: hir_map::Map<'tcx>,\n+    /// This should usually be accessed with the `tcx.hir()` method.\n+    pub(crate) hir_map: hir_map::Map<'tcx>,\n \n     /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n@@ -1019,11 +1020,6 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline(always)]\n-    pub fn hir(self) -> &'tcx hir_map::Map<'tcx> {\n-        &self.hir_map\n-    }\n-\n     pub fn alloc_steal_mir(self, mir: BodyAndCache<'tcx>) -> &'tcx Steal<BodyAndCache<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }\n@@ -1328,7 +1324,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let krate = self.gcx.hir_map.forest.untracked_krate();\n+        let krate = self.gcx.hir_map.untracked_krate();\n \n         StableHashingContext::new(self.sess, krate, self.hir().definitions(), &*self.cstore)\n     }"}, {"sha": "e7b95af103cc939e2b45c51adabb547835ce99c4", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -45,7 +45,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex};\n-use rustc_hir::{HirIdSet, ItemLocalId, TraitCandidate};\n+use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n use rustc_index::vec::IndexVec;\n use rustc_target::spec::PanicStrategy;\n "}, {"sha": "6d9fff351e9b80d5bb21d4e3a963498fa5352cd6", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1177,7 +1177,6 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n         DepKind::AllLocalTraitImpls |\n-        DepKind::Krate |\n         DepKind::CrateMetadata |\n         DepKind::HirBody |\n         DepKind::Hir |"}, {"sha": "a9e4fdba030366ee60a2d104da1290cdcd68ae14", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -46,6 +46,31 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     };\n }\n \n+/// Apply LLVM sanitize attributes.\n+#[inline]\n+pub fn sanitize(cx: &CodegenCx<'ll, '_>, codegen_fn_flags: CodegenFnAttrFlags, llfn: &'ll Value) {\n+    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n+        match *sanitizer {\n+            Sanitizer::Address => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {\n+                    llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Memory => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_MEMORY) {\n+                    llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Thread => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_THREAD) {\n+                    llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Leak => {}\n+        }\n+    }\n+}\n+\n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n@@ -288,6 +313,7 @@ pub fn from_fn_attrs(\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::ALLOCATOR) {\n         Attribute::NoAlias.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n     }\n+    sanitize(cx, codegen_fn_attrs.flags, llfn);\n \n     unwind(\n         llfn,"}, {"sha": "04c084e459eab662f2b441eafcc2ba5715b76ca4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -15,6 +15,7 @@\n \n use super::ModuleLlvm;\n \n+use crate::attributes;\n use crate::builder::Builder;\n use crate::common;\n use crate::context::CodegenCx;\n@@ -23,7 +24,7 @@ use crate::metadata;\n use crate::value::Value;\n \n use rustc::dep_graph;\n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::exported_symbols;\n use rustc::mir::mono::{Linkage, Visibility};\n@@ -131,7 +132,9 @@ pub fn compile_codegen_unit(\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx);\n+            if let Some(entry) = maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx) {\n+                attributes::sanitize(&cx, CodegenFnAttrFlags::empty(), entry);\n+            }\n \n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {"}, {"sha": "691f32dd85a05b8faee5ebc835fa9960107e7ee7", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -19,7 +19,6 @@ use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n use log::debug;\n-use rustc::session::config::Sanitizer;\n use rustc::ty::Ty;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -47,21 +46,6 @@ fn declare_raw_fn(\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n-    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n-        match *sanitizer {\n-            Sanitizer::Address => {\n-                llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n-            }\n-            Sanitizer::Memory => {\n-                llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n-            }\n-            Sanitizer::Thread => {\n-                llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     attributes::default_optimisation_attrs(cx.tcx.sess, llfn);\n     attributes::non_lazy_bind(cx.sess(), llfn);\n     llfn"}, {"sha": "900150913842c5f20e76aaa9d031463491358264", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -391,36 +391,36 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n /// Creates the `main` function which will initialize the rust runtime and call\n /// users main function.\n-pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'a Bx::CodegenCx) {\n+pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+) -> Option<Bx::Function> {\n     let (main_def_id, span) = match cx.tcx().entry_fn(LOCAL_CRATE) {\n         Some((def_id, _)) => (def_id, cx.tcx().def_span(def_id)),\n-        None => return,\n+        None => return None,\n     };\n \n     let instance = Instance::mono(cx.tcx(), main_def_id);\n \n     if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n-        return;\n+        return None;\n     }\n \n     let main_llfn = cx.get_fn_addr(instance);\n \n-    let et = cx.tcx().entry_fn(LOCAL_CRATE).map(|e| e.1);\n-    match et {\n-        Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n-        Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n-        None => {} // Do nothing.\n-    }\n+    return cx.tcx().entry_fn(LOCAL_CRATE).map(|(_, et)| {\n+        let use_start_lang_item = EntryFnType::Start != et;\n+        create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, use_start_lang_item)\n+    });\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         sp: Span,\n         rust_main: Bx::Value,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-    ) {\n+    ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n         // depending on whether the target needs `argc` and `argv` to be passed in.\n         let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n@@ -481,6 +481,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         let result = bx.call(start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n+\n+        llfn\n     }\n }\n "}, {"sha": "d4f014904994102a7d30f06754104628b6fe08c9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -69,19 +69,19 @@ where\n     match *ppmode {\n         PpmNormal => {\n             let annotation = NoAnn { sess: tcx.sess, tcx: Some(tcx) };\n-            f(&annotation, tcx.hir().forest.krate())\n+            f(&annotation, tcx.hir().krate())\n         }\n \n         PpmIdentified => {\n             let annotation = IdentifiedAnnotation { sess: tcx.sess, tcx: Some(tcx) };\n-            f(&annotation, tcx.hir().forest.krate())\n+            f(&annotation, tcx.hir().krate())\n         }\n         PpmTyped => {\n             abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n \n             let empty_tables = ty::TypeckTables::empty(None);\n             let annotation = TypedAnnotation { tcx, tables: Cell::new(&empty_tables) };\n-            tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().forest.krate()))\n+            tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n         }\n         _ => panic!(\"Should use call_with_pp_support\"),\n     }\n@@ -143,7 +143,7 @@ impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n-        self.tcx.map(|tcx| tcx.hir())\n+        self.tcx.map(|tcx| *tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -155,7 +155,7 @@ impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(*tcx.hir(), state, nested)\n         }\n     }\n }\n@@ -217,7 +217,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n-        self.tcx.map(|tcx| tcx.hir())\n+        self.tcx.map(|tcx| *tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -228,7 +228,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(ref tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(*tcx.hir(), state, nested)\n         }\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested);\n+        pprust_hir::PpAnn::nested(*self.tcx.hir(), state, nested);\n         self.tables.set(old_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {"}, {"sha": "ad76968c5897d7f772473c758ae7725e94fb13ba", "filename": "src/librustc_error_codes/error_codes/E0276.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1,5 +1,6 @@\n-This error occurs when a bound in an implementation of a trait does not match\n-the bounds specified in the original trait. For example:\n+A trait implementation has stricter requirements than the trait definition.\n+\n+Erroneous code example:\n \n ```compile_fail,E0276\n trait Foo {"}, {"sha": "d7fd15a8a7b5fd681bd7928f62c0e2c6e382d525", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -541,6 +541,9 @@ declare_features! (\n     /// Allows `T: ?const Trait` syntax in bounds.\n     (active, const_trait_bound_opt_out, \"1.42.0\", Some(67794), None),\n \n+    /// Allows the use of `no_sanitize` attribute.\n+    (active, no_sanitize, \"1.42.0\", Some(39699), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "e2e061c185c03f58adfa29f42f02d94b0da9ac1b", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -261,6 +261,11 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(cold, Whitelisted, template!(Word)),\n     ungated!(no_builtins, Whitelisted, template!(Word)),\n     ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n+    gated!(\n+        no_sanitize, Whitelisted,\n+        template!(List: \"address, memory, thread\"),\n+        experimental!(no_sanitize)\n+    ),\n \n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     ungated!(doc, Whitelisted, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),"}, {"sha": "6224c4654d695df818e05ad25ec31082bc3e9e62", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -25,6 +25,7 @@ use rustc_data_structures::{box_region_allow_access, declare_box_region_type, pa\n use rustc_errors::PResult;\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_hir::Crate;\n use rustc_lint::LintStore;\n use rustc_mir as mir;\n use rustc_mir_build as mir_build;\n@@ -422,7 +423,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n     dep_graph: &'res DepGraph,\n     krate: &'res ast::Crate,\n     arena: &'tcx Arena<'tcx>,\n-) -> Result<map::Forest<'tcx>> {\n+) -> Crate<'tcx> {\n     // Lower AST to HIR.\n     let hir_crate = rustc_ast_lowering::lower_crate(\n         sess,\n@@ -437,8 +438,6 @@ pub fn lower_to_hir<'res, 'tcx>(\n         hir_stats::print_hir_stats(&hir_crate);\n     }\n \n-    let hir_forest = map::Forest::new(hir_crate, &dep_graph);\n-\n     sess.time(\"early_lint_checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n@@ -455,7 +454,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n         rustc_span::hygiene::clear_syntax_context_map();\n     }\n \n-    Ok(hir_forest)\n+    hir_crate\n }\n \n // Returns all the paths that correspond to generated files.\n@@ -705,7 +704,8 @@ impl<'tcx> QueryContext<'tcx> {\n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n     lint_store: Lrc<LintStore>,\n-    hir_forest: &'tcx map::Forest<'tcx>,\n+    krate: &'tcx Crate<'tcx>,\n+    dep_graph: DepGraph,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n@@ -716,7 +716,7 @@ pub fn create_global_ctxt<'tcx>(\n     let defs = mem::take(&mut resolver_outputs.definitions);\n \n     // Construct the HIR map.\n-    let hir_map = map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs);\n+    let hir_map = map::map_crate(sess, &*resolver_outputs.cstore, krate, dep_graph, defs);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n "}, {"sha": "720d162ac819e439e3ece957dd6df9031faf527c", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -3,7 +3,6 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n-use rustc::hir::map;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n@@ -12,6 +11,7 @@ use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::Crate;\n use rustc_incremental::DepGraphFuture;\n use rustc_lint::LintStore;\n use std::any::Any;\n@@ -74,7 +74,7 @@ pub struct Queries<'tcx> {\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(&'tcx map::Forest<'tcx>, Steal<ResolverOutputs>)>,\n+    lower_to_hir: Query<(&'tcx Crate<'tcx>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -207,24 +207,22 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn lower_to_hir(\n-        &'tcx self,\n-    ) -> Result<&Query<(&'tcx map::Forest<'tcx>, Steal<ResolverOutputs>)>> {\n+    pub fn lower_to_hir(&'tcx self) -> Result<&Query<(&'tcx Crate<'tcx>, Steal<ResolverOutputs>)>> {\n         self.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n             let resolver = peeked.1.steal();\n             let lint_store = &peeked.2;\n             let hir = resolver.borrow_mut().access(|resolver| {\n-                passes::lower_to_hir(\n+                Ok(passes::lower_to_hir(\n                     self.session(),\n                     lint_store,\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate,\n                     &self.arena,\n-                )\n+                ))\n             })?;\n             let hir = self.arena.alloc(hir);\n             Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n@@ -253,12 +251,14 @@ impl<'tcx> Queries<'tcx> {\n             let outputs = self.prepare_outputs()?.peek().clone();\n             let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?.peek();\n-            let (ref hir_forest, ref resolver_outputs) = &*hir;\n+            let dep_graph = self.dep_graph()?.peek().clone();\n+            let (ref krate, ref resolver_outputs) = &*hir;\n             let _timer = self.session().timer(\"create_global_ctxt\");\n             Ok(passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n-                hir_forest,\n+                krate,\n+                dep_graph,\n                 resolver_outputs.steal(),\n                 outputs,\n                 &crate_name,"}, {"sha": "4133047af78fed193724f18fffb5a40667a33b96", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -796,7 +796,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered =\n-                    hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n+                    hir::print::to_string(&self.tcx.hir(), |s| s.print_trait_item(ast_item));\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(\n@@ -1009,7 +1009,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n         let body = self.tcx.hir().body(body_id);\n-        let rendered = hir::print::to_string(self.tcx.hir(), |s| s.print_expr(&body.value));\n+        let rendered = hir::print::to_string(&self.tcx.hir(), |s| s.print_expr(&body.value));\n         let rendered_const = &RenderedConst(rendered);\n         self.lazy(rendered_const)\n     }"}, {"sha": "b6802505df73f0b255f27c3b5c45e630e8f06baa", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -8,6 +8,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::mir::visit::*;\n use rustc::mir::*;\n+use rustc::session::config::Sanitizer;\n use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n \n@@ -228,6 +229,28 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n+        // Avoid inlining functions marked as no_sanitize if sanitizer is enabled,\n+        // since instrumentation might be enabled and performed on the caller.\n+        match self.tcx.sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => {\n+                if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {\n+                    return false;\n+                }\n+            }\n+            Some(Sanitizer::Memory) => {\n+                if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_MEMORY) {\n+                    return false;\n+                }\n+            }\n+            Some(Sanitizer::Thread) => {\n+                if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_THREAD) {\n+                    return false;\n+                }\n+            }\n+            Some(Sanitizer::Leak) => {}\n+            None => {}\n+        }\n+\n         let hinted = match codegen_fn_attrs.inline {\n             // Just treat inline(always) as a hint for now,\n             // there are cases that prevent inlining that we"}, {"sha": "b178110f4f954104881f2a5fcd0b22e884aa618a", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -8,6 +8,7 @@\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n use rustc::hir::map::Map;\n+use rustc::hir::Hir;\n use rustc::session::config::nightly_options;\n use rustc::session::parse::feature_err;\n use rustc::ty::query::Providers;\n@@ -74,7 +75,7 @@ enum ConstKind {\n }\n \n impl ConstKind {\n-    fn for_body(body: &hir::Body<'_>, hir_map: &Map<'_>) -> Option<Self> {\n+    fn for_body(body: &hir::Body<'_>, hir_map: Hir<'_>) -> Option<Self> {\n         let is_const_fn = |id| hir_map.fn_sig_by_hir_id(id).unwrap().header.is_const();\n \n         let owner = hir_map.body_owner(body.id());"}, {"sha": "ebd93e9ab85b813db0ca9c3249ef68f9ab261a79", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::map as hir_map;\n+use rustc::hir::Hir;\n use rustc::session::config::EntryFnType;\n use rustc::session::{config, Session};\n use rustc::ty::query::Providers;\n@@ -15,7 +15,7 @@ use syntax::entry::EntryPointType;\n struct EntryContext<'a, 'tcx> {\n     session: &'a Session,\n \n-    map: &'a hir_map::Map<'tcx>,\n+    map: Hir<'tcx>,\n \n     /// The top-level function called `main`.\n     main_fn: Option<(HirId, Span)>,"}, {"sha": "87522d28d1e80fab52e2c292ddce4a36518d647d", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -612,7 +612,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n-                                let krate = self.tcx.hir().forest.krate();\n+                                let krate = self.tcx.hir().krate();\n \n                                 if !(krate.items.contains_key(&parent_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)"}, {"sha": "a61ab5b5e17559f20f9561a13f2d1ccc29d47d57", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -474,6 +474,12 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    pub INLINE_NO_SANITIZE,\n+    Warn,\n+    \"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -537,5 +543,6 @@ declare_lint_pass! {\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n+        INLINE_NO_SANITIZE,\n     ]\n }"}, {"sha": "931a3c15cf08ec2ca1a8f3adf620feabc95a47d4", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -120,6 +120,7 @@ symbols! {\n         abi_vectorcall,\n         abi_x86_interrupt,\n         aborts,\n+        address,\n         add_with_overflow,\n         advanced_slice_patterns,\n         adx_target_feature,\n@@ -445,6 +446,7 @@ symbols! {\n         mem_uninitialized,\n         mem_zeroed,\n         member_constraints,\n+        memory,\n         message,\n         meta,\n         min_align_of,\n@@ -487,6 +489,7 @@ symbols! {\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n+        no_sanitize,\n         no_stack_check,\n         no_start,\n         no_std,\n@@ -721,6 +724,7 @@ symbols! {\n         test_removed_feature,\n         test_runner,\n         then_with,\n+        thread,\n         thread_local,\n         tool_attributes,\n         tool_lints,"}, {"sha": "7e5d27d93b3cb2bfcc6bb87d20ef6196ce29eee7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -2598,7 +2598,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &\n         E0533,\n         \"expected unit struct, unit variant or constant, found {} `{}`\",\n         res.descr(),\n-        hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false))\n+        hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false))\n     )\n     .emit();\n }"}, {"sha": "47baae68608963eea32a097bf3522cee8a0a5968", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -693,7 +693,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let msg = format!(\n                 \"expected tuple struct or tuple variant, found {} `{}`\",\n                 res.descr(),\n-                hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)),\n+                hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false)),\n             );\n             let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n             match (res, &pat.kind) {"}, {"sha": "040b85b98ed8a515ad681c7797e25faf85c58c6a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-filelength\n+\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -2743,6 +2745,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n \n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n+    let mut no_sanitize_span = None;\n     for attr in attrs.iter() {\n         if attr.check_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n@@ -2832,6 +2835,24 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n                 codegen_fn_attrs.link_ordinal = ordinal;\n             }\n+        } else if attr.check_name(sym::no_sanitize) {\n+            no_sanitize_span = Some(attr.span);\n+            if let Some(list) = attr.meta_item_list() {\n+                for item in list.iter() {\n+                    if item.check_name(sym::address) {\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_SANITIZE_ADDRESS;\n+                    } else if item.check_name(sym::memory) {\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_SANITIZE_MEMORY;\n+                    } else if item.check_name(sym::thread) {\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_SANITIZE_THREAD;\n+                    } else {\n+                        tcx.sess\n+                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                            .note(\"expected one of: `address`, `memory` or `thread`\")\n+                            .emit();\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -2911,7 +2932,6 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     // purpose functions as they wouldn't have the right target features\n     // enabled. For that reason we also forbid #[inline(always)] as it can't be\n     // respected.\n-\n     if codegen_fn_attrs.target_features.len() > 0 {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let Some(span) = inline_span {\n@@ -2924,6 +2944,22 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         }\n     }\n \n+    if codegen_fn_attrs.flags.intersects(CodegenFnAttrFlags::NO_SANITIZE_ANY) {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n+                let hir_id = tcx.hir().as_local_hir_id(id).unwrap();\n+                tcx.struct_span_lint_hir(\n+                    lint::builtin::INLINE_NO_SANITIZE,\n+                    hir_id,\n+                    no_sanitize_span,\n+                    \"`no_sanitize` will have no effect after inlining\",\n+                )\n+                .span_note(inline_span, \"inlining requested here\")\n+                .emit();\n+            }\n+        }\n+    }\n+\n     // Weak lang items have the same semantics as \"std internal\" symbols in the\n     // sense that they're preserved through all our LTO passes and only\n     // strippable by the linker."}, {"sha": "0c7dfa1417a97812266a7bc5101bdee20b49b5cf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -87,7 +87,7 @@ pub fn run(options: Options) -> i32 {\n         compiler.enter(|queries| {\n             let lower_to_hir = queries.lower_to_hir()?;\n \n-            let mut opts = scrape_test_config(lower_to_hir.peek().0.krate());\n+            let mut opts = scrape_test_config(lower_to_hir.peek().0);\n             opts.display_warnings |= options.display_warnings;\n             let enable_per_target_ignores = options.enable_per_target_ignores;\n             let mut collector = Collector::new(\n@@ -107,7 +107,7 @@ pub fn run(options: Options) -> i32 {\n                 let mut hir_collector = HirCollector {\n                     sess: compiler.session(),\n                     collector: &mut collector,\n-                    map: tcx.hir(),\n+                    map: *tcx.hir(),\n                     codes: ErrorCodes::from(\n                         compiler.session().opts.unstable_features.is_nightly_build(),\n                     ),"}, {"sha": "de001cacbe19591cfd2dcf3e423a48fd1e920e17", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -63,8 +63,7 @@ use std::{\n     env, io,\n     io::prelude::Write,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n-    process,\n-    process::{Command, Termination},\n+    process::{self, Command, Termination},\n     sync::mpsc::{channel, Sender},\n     sync::{Arc, Mutex},\n     thread,\n@@ -457,9 +456,13 @@ pub fn run_test(\n                 monitor_ch,\n                 opts.time,\n             ),\n-            RunStrategy::SpawnPrimary => {\n-                spawn_test_subprocess(desc, opts.time.is_some(), monitor_ch, opts.time)\n-            }\n+            RunStrategy::SpawnPrimary => spawn_test_subprocess(\n+                desc,\n+                opts.nocapture,\n+                opts.time.is_some(),\n+                monitor_ch,\n+                opts.time,\n+            ),\n         };\n \n         // If the platform is single-threaded we're just going to run\n@@ -558,6 +561,7 @@ fn run_test_in_process(\n \n fn spawn_test_subprocess(\n     desc: TestDesc,\n+    nocapture: bool,\n     report_time: bool,\n     monitor_ch: Sender<CompletedTest>,\n     time_opts: Option<time::TestTimeOptions>,\n@@ -566,11 +570,15 @@ fn spawn_test_subprocess(\n         let args = env::args().collect::<Vec<_>>();\n         let current_exe = &args[0];\n \n+        let mut command = Command::new(current_exe);\n+        command.env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice());\n+        if nocapture {\n+            command.stdout(process::Stdio::inherit());\n+            command.stderr(process::Stdio::inherit());\n+        }\n+\n         let start = report_time.then(Instant::now);\n-        let output = match Command::new(current_exe)\n-            .env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice())\n-            .output()\n-        {\n+        let output = match command.output() {\n             Ok(out) => out,\n             Err(e) => {\n                 let err = format!(\"Failed to spawn {} as child for test: {:?}\", args[0], e);"}, {"sha": "d96e76618d32501e33f91ac03276b177563ddf8c", "filename": "src/test/codegen/sanitizer-no-sanitize-inlining.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,32 @@\n+// Verifies that no_sanitize attribute prevents inlining when\n+// given sanitizer is enabled, but has no effect on inlining otherwise.\n+//\n+// needs-sanitizer-support\n+// only-x86_64\n+//\n+// revisions: ASAN LSAN\n+//\n+//[ASAN] compile-flags: -Zsanitizer=address -C opt-level=3 -Z mir-opt-level=3\n+//[LSAN] compile-flags: -Zsanitizer=leak    -C opt-level=3 -Z mir-opt-level=3\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_sanitize)]\n+\n+// ASAN-LABEL: define void @test\n+// ASAN:         tail call fastcc void @random_inline\n+// ASAN:       }\n+//\n+// LSAN-LABEL: define void @test\n+// LSAN-NO:      call\n+// LSAN:       }\n+#[no_mangle]\n+pub fn test(n: &mut u32) {\n+    random_inline(n);\n+}\n+\n+#[no_sanitize(address)]\n+#[inline]\n+#[no_mangle]\n+pub fn random_inline(n: &mut u32) {\n+    *n = 42;\n+}"}, {"sha": "dfceb28c8dd107eaaa01eb5c87021c5241c9fe85", "filename": "src/test/codegen/sanitizer-no-sanitize.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,29 @@\n+// Verifies that no_sanitze attribute can be used to\n+// selectively disable sanitizer instrumentation.\n+//\n+// needs-sanitizer-support\n+// compile-flags: -Zsanitizer=address\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_sanitize)]\n+\n+// CHECK-LABEL: ; sanitizer_no_sanitize::unsanitized\n+// CHECK-NEXT:  ; Function Attrs:\n+// CHECK-NOT:   sanitize_address\n+// CHECK:       start:\n+// CHECK-NOT:   call void @__asan_report_load\n+// CHECK:       }\n+#[no_sanitize(address)]\n+pub fn unsanitized(b: &mut u8) -> u8 {\n+    *b\n+}\n+\n+// CHECK-LABEL: ; sanitizer_no_sanitize::sanitized\n+// CHECK-NEXT:  ; Function Attrs:\n+// CHECK:       sanitize_address\n+// CHECK:       start:\n+// CHECK:       call void @__asan_report_load\n+// CHECK:       }\n+pub fn sanitized(b: &mut u8) -> u8 {\n+    *b\n+}"}, {"sha": "6e06e67b6682db41050e410695c07b8304f00f8d", "filename": "src/test/incremental/crate_hash_reorder.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -7,11 +7,9 @@\n \n // Check that reordering otherwise identical items is not considered a\n // change at all.\n-#[rustc_clean(label=\"Krate\", cfg=\"rpass2\")]\n-\n+#[rustc_clean(label = \"hir_crate\", cfg = \"rpass2\")]\n // But removing an item, naturally, is.\n-#[rustc_dirty(label=\"Krate\", cfg=\"rpass3\")]\n-\n+#[rustc_dirty(label = \"hir_crate\", cfg = \"rpass3\")]\n #[cfg(rpass1)]\n pub struct X {\n     pub x: u32,\n@@ -26,4 +24,4 @@ pub struct X {\n     pub x: u32,\n }\n \n-pub fn main() { }\n+pub fn main() {}"}, {"sha": "20d4d4200bc1eefa008d49ee77352cd904152cfe", "filename": "src/test/incremental/issue-38222.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fissue-38222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fissue-38222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-38222.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1,18 +1,14 @@\n-// Test that debuginfo does not introduce a dependency edge to the Krate\n+// Test that debuginfo does not introduce a dependency edge to the hir_crate\n // dep-node.\n \n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n-\n #![feature(rustc_attrs)]\n-\n-\n-#![rustc_partition_reused(module=\"issue_38222-mod1\", cfg=\"rpass2\")]\n-\n-// If codegen had added a dependency edge to the Krate dep-node, nothing would\n+#![rustc_partition_reused(module = \"issue_38222-mod1\", cfg = \"rpass2\")]\n+// If codegen had added a dependency edge to the hir_crate dep-node, nothing would\n // be re-used, so checking that this module was re-used is sufficient.\n-#![rustc_partition_reused(module=\"issue_38222\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module = \"issue_38222\", cfg = \"rpass2\")]\n \n //[rpass1] compile-flags: -C debuginfo=1\n //[rpass2] compile-flags: -C debuginfo=1"}, {"sha": "2c04e110525a653d15f903ab526fc98617d4ddf1", "filename": "src/test/incremental/krate-inherent.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inherent.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -4,20 +4,20 @@\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n-#![rustc_partition_reused(module=\"krate_inherent-x\", cfg=\"cfail2\")]\n+#![rustc_partition_reused(module = \"krate_inherent-x\", cfg = \"cfail2\")]\n #![crate_type = \"rlib\"]\n \n pub mod x {\n     pub struct Foo;\n     impl Foo {\n-        pub fn foo(&self) { }\n+        pub fn foo(&self) {}\n     }\n \n     pub fn method() {\n         let x: Foo = Foo;\n-        x.foo(); // inherent methods used to add an edge from Krate\n+        x.foo(); // inherent methods used to add an edge from hir_crate\n     }\n }\n \n #[cfg(cfail1)]\n-pub fn bar() { } // remove this unrelated fn in cfail2, which should not affect `x::method`\n+pub fn bar() {} // remove this unrelated fn in cfail2, which should not affect `x::method`"}, {"sha": "6b1db74a37c66f43a33e84ff0df9c8cb7dc4d3f4", "filename": "src/test/incremental/krate-inlined.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inlined.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1,13 +1,13 @@\n // Regr. test that using HIR inlined from another krate does *not* add\n-// a dependency from the local Krate node. We can't easily test that\n+// a dependency from the local hir_crate node. We can't easily test that\n // directly anymore, so now we test that we get reuse.\n \n // revisions: rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n-#![rustc_partition_reused(module=\"krate_inlined-x\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module = \"krate_inlined-x\", cfg = \"rpass2\")]\n \n fn main() {\n     x::method();"}, {"sha": "927ea5597783a5f716399e9ef318e2a2feb057f0", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -6,17 +6,16 @@\n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-\n-fn main() { }\n+#![rustc_if_this_changed(hir_crate)]\n+fn main() {}\n \n struct Foo<T> {\n-    f: T\n+    f: T,\n }\n \n-#[rustc_if_this_changed(Krate)]\n type TypeAlias<T> = Foo<T>;\n \n #[rustc_then_this_would_need(variances_of)] //~ ERROR OK\n struct Use<T> {\n-    x: TypeAlias<T>\n+    x: TypeAlias<T>,\n }"}, {"sha": "2422cb9bb2f52ed93695bd62f1a8f2c388299e30", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -1,5 +1,5 @@\n error: OK\n-  --> $DIR/dep-graph-variance-alias.rs:19:1\n+  --> $DIR/dep-graph-variance-alias.rs:18:1\n    |\n LL | #[rustc_then_this_would_need(variances_of)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "66a9263e13a53168bf032ff971cad46deeab3343", "filename": "src/test/ui/feature-gates/feature-gate-no_sanitize.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,4 @@\n+#[no_sanitize(address)]\n+//~^ the `#[no_sanitize]` attribute is an experimental feature\n+fn main() {\n+}"}, {"sha": "7359cf03652bcdb93cb4f08fc650d9dadf2107c0", "filename": "src/test/ui/feature-gates/feature-gate-no_sanitize.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.stderr?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: the `#[no_sanitize]` attribute is an experimental feature\n+  --> $DIR/feature-gate-no_sanitize.rs:1:1\n+   |\n+LL | #[no_sanitize(address)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/39699\n+   = help: add `#![feature(no_sanitize)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "b52e3cc83fab2715aa43bce8a7e6189d6d192af5", "filename": "src/test/ui/invalid/invalid-no-sanitize.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,5 @@\n+#![feature(no_sanitize)]\n+\n+#[no_sanitize(brontosaurus)] //~ ERROR invalid argument\n+fn main() {\n+}"}, {"sha": "e9983e5fbd24d71da68f80504f06bb1adfff9634", "filename": "src/test/ui/invalid/invalid-no-sanitize.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.stderr?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,10 @@\n+error: invalid argument for `no_sanitize`\n+  --> $DIR/invalid-no-sanitize.rs:3:15\n+   |\n+LL | #[no_sanitize(brontosaurus)]\n+   |               ^^^^^^^^^^^^\n+   |\n+   = note: expected one of: `address`, `memory` or `thread`\n+\n+error: aborting due to previous error\n+"}, {"sha": "52dc5578180396198a400f9ae4d1307a58185a1d", "filename": "src/test/ui/sanitize-inline-always.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fsanitize-inline-always.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fsanitize-inline-always.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize-inline-always.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+#![feature(no_sanitize)]\n+\n+#[inline(always)]\n+//~^ NOTE inlining requested here\n+#[no_sanitize(address)]\n+//~^ WARN will have no effect after inlining\n+//~| NOTE on by default\n+fn x() {\n+}\n+\n+fn main() {\n+    x()\n+}"}, {"sha": "50b9474baa2d66c6175c929f4905a0da99778929", "filename": "src/test/ui/sanitize-inline-always.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fsanitize-inline-always.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Fsanitize-inline-always.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize-inline-always.stderr?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,13 @@\n+warning: `no_sanitize` will have no effect after inlining\n+  --> $DIR/sanitize-inline-always.rs:7:1\n+   |\n+LL | #[no_sanitize(address)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(inline_no_sanitize)]` on by default\n+note: inlining requested here\n+  --> $DIR/sanitize-inline-always.rs:5:1\n+   |\n+LL | #[inline(always)]\n+   | ^^^^^^^^^^^^^^^^^\n+"}, {"sha": "75f798386502047e867c223409f8246fce90e72b", "filename": "src/test/ui/test-panic-abort-nocapture.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.rs?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,39 @@\n+// no-prefer-dynamic\n+// compile-flags: --test -Cpanic=abort -Zpanic_abort_tests\n+// run-flags: --test-threads=1 --nocapture\n+// run-fail\n+// check-run-results\n+// exec-env:RUST_BACKTRACE=0\n+\n+// ignore-wasm no panic or subprocess support\n+// ignore-emscripten no panic or subprocess support\n+\n+#![cfg(test)]\n+\n+use std::io::Write;\n+\n+#[test]\n+fn it_works() {\n+    println!(\"about to succeed\");\n+    assert_eq!(1 + 1, 2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn it_panics() {\n+    println!(\"about to panic\");\n+    assert_eq!(1 + 1, 4);\n+}\n+\n+#[test]\n+fn it_fails() {\n+    println!(\"about to fail\");\n+    assert_eq!(1 + 1, 4);\n+}\n+\n+#[test]\n+fn it_writes_to_stdio() {\n+    println!(\"hello, world\");\n+    writeln!(std::io::stdout(), \"testing123\").unwrap();\n+    writeln!(std::io::stderr(), \"testing321\").unwrap();\n+}"}, {"sha": "37fbe3d3ff21f7d6897a67bcf5289192c69c40fd", "filename": "src/test/ui/test-panic-abort-nocapture.run.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.run.stderr?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,9 @@\n+thread 'main' panicked at 'assertion failed: `(left == right)`\n+  left: `2`,\n+ right: `4`', $DIR/test-panic-abort-nocapture.rs:31:5\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+thread 'main' panicked at 'assertion failed: `(left == right)`\n+  left: `2`,\n+ right: `4`', $DIR/test-panic-abort-nocapture.rs:25:5\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+testing321"}, {"sha": "87a246db5e07b3234e041c34fa07d4632ae01b45", "filename": "src/test/ui/test-panic-abort-nocapture.run.stdout", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a29424a2265411dda7d7446516ac5fd7499e2b55/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort-nocapture.run.stdout?ref=a29424a2265411dda7d7446516ac5fd7499e2b55", "patch": "@@ -0,0 +1,23 @@\n+\n+running 4 tests\n+test it_fails ... about to fail\n+FAILED\n+test it_panics ... about to panic\n+ok\n+test it_works ... about to succeed\n+ok\n+test it_writes_to_stdio ... hello, world\n+testing123\n+ok\n+\n+failures:\n+\n+---- it_fails stdout ----\n+---- it_fails stderr ----\n+\n+\n+failures:\n+    it_fails\n+\n+test result: FAILED. 3 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}]}