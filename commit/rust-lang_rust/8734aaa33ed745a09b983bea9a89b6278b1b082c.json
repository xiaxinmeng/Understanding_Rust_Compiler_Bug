{"sha": "8734aaa33ed745a09b983bea9a89b6278b1b082c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MzRhYWEzM2VkNzQ1YTA5Yjk4M2JlYTlhODliNjI3OGIxYjA4MmM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-19T20:49:01Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:02Z"}, "message": "rustc_metadata: move more RBML tags to auto-serialization.", "tree": {"sha": "31faaa8d3e61710aba8d648052a8bd16655dd0b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31faaa8d3e61710aba8d648052a8bd16655dd0b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8734aaa33ed745a09b983bea9a89b6278b1b082c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8734aaa33ed745a09b983bea9a89b6278b1b082c", "html_url": "https://github.com/rust-lang/rust/commit/8734aaa33ed745a09b983bea9a89b6278b1b082c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8734aaa33ed745a09b983bea9a89b6278b1b082c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "html_url": "https://github.com/rust-lang/rust/commit/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd"}], "stats": {"total": 3209, "additions": 1077, "deletions": 2132}, "files": [{"sha": "3cf7548e3209a5f209a114150b8ece6f13a80bd6", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -103,18 +103,13 @@ pub enum DepNode<D: Clone + Debug> {\n     // table in the tcx (or elsewhere) maps to one of these\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`). Other\n-    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n-    // might be mergable are kept distinct because the sets of def-ids\n-    // to which they apply are disjoint, and hence we might as well\n-    // have distinct labels for easier debugging.\n+    // predicates for an item wind up in `ItemSignature`).\n     ImplOrTraitItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    TraitItemDefIds(D),\n+    ImplOrTraitItemIds(D),\n     InherentImpls(D),\n-    ImplItems(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,9 +157,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems,\n             ItemSignature,\n             FieldTy,\n-            TraitItemDefIds,\n+            ImplOrTraitItemIds,\n             InherentImpls,\n-            ImplItems,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -231,9 +225,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n+            ImplOrTraitItemIds(ref d) => op(d).map(ImplOrTraitItemIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n-            ImplItems(ref d) => op(d).map(ImplItems),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "fddf09c990566ab8f8d1e8b92021e19c5e7f3f3e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -92,7 +92,7 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     pub name: ast::Name,    // The name of the target.\n     pub def_id: DefId, // The definition of the target."}, {"sha": "b351bd427acbc26de10d8a477d7b10473b09ac9a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -580,22 +580,24 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> &'ast VariantData {\n+    pub fn expect_variant_data(&self, id: NodeId) -> &'ast VariantData {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct\")\n+                    ItemStruct(ref struct_def, _) |\n+                    ItemUnion(ref struct_def, _) => struct_def,\n+                    _ => {\n+                        bug!(\"struct ID bound to non-struct {}\",\n+                             self.node_to_string(id));\n+                    }\n                 }\n             }\n-            Some(NodeVariant(variant)) => {\n-                if variant.node.data.is_struct() {\n-                    &variant.node.data\n-                } else {\n-                    bug!(\"struct ID bound to enum variant that isn't struct-like\")\n-                }\n+            Some(NodeStructCtor(data)) => data,\n+            Some(NodeVariant(variant)) => &variant.node.data,\n+            _ => {\n+                bug!(\"expected struct or variant, found {}\",\n+                     self.node_to_string(id));\n             }\n-            _ => bug!(\"expected struct, found {}\", self.node_to_string(id)),\n         }\n     }\n "}, {"sha": "52cadd76c64cbeeeb68a66229200185c1509ce6a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 16, "deletions": 54, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -28,14 +28,13 @@ use hir::map as hir_map;\n use hir::map::definitions::DefKey;\n use hir::svh::Svh;\n use middle::lang_items;\n-use ty::{self, Ty, TyCtxt, VariantKind};\n+use ty::{self, Ty, TyCtxt};\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;\n use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n-use std::rc::Rc;\n+use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n@@ -47,7 +46,6 @@ use rustc_back::target::Target;\n use hir;\n use hir::intravisit::Visitor;\n \n-pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n // lonely orphan structs and enums looking for a better home\n@@ -67,27 +65,17 @@ pub struct CrateSource {\n     pub cnum: CrateNum,\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone)]\n+#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub enum NativeLibraryKind {\n-        NativeStatic,    // native static library (.a archive)\n-        NativeFramework, // OSX-specific\n-        NativeUnknown,   // default way to specify a dynamic library\n-    }\n-}\n-\n-// Something that a name can resolve to.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefLike {\n-    DlDef(Def),\n-    DlImpl(DefId),\n-    DlField\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum NativeLibraryKind {\n+    NativeStatic,    // native static library (.a archive)\n+    NativeFramework, // OSX-specific\n+    NativeUnknown,   // default way to specify a dynamic library\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -110,7 +98,7 @@ pub enum InlinedItemRef<'a> {\n \n #[derive(Copy, Clone)]\n pub struct ChildItem {\n-    pub def: DefLike,\n+    pub def: Def,\n     pub name: ast::Name,\n     pub vis: ty::Visibility,\n }\n@@ -166,21 +154,15 @@ pub trait CrateStore<'tcx> {\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>>;\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId>;\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n@@ -191,12 +173,10 @@ pub trait CrateStore<'tcx> {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n-    fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n-    fn is_typedef(&self, did: DefId) -> bool;\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -218,8 +198,6 @@ pub trait CrateStore<'tcx> {\n     fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n     fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n-    fn crate_struct_field_attrs(&self, cnum: CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>;\n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n@@ -232,12 +210,10 @@ pub trait CrateStore<'tcx> {\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n-    fn crate_top_level_items(&self, cnum: CrateNum) -> Vec<ChildItem>;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -344,11 +320,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n     fn def_index_for_def_key(&self,\n                              cnum: CrateNum,\n                              def: DefKey)\n@@ -357,16 +329,14 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-        { bug!(\"impl_items\") }\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n+        { bug!(\"impl_or_trait_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n@@ -377,13 +347,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n-    fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n-    fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -411,9 +379,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n     fn crate_disambiguator(&self, cnum: CrateNum)\n                            -> InternedString { bug!(\"crate_disambiguator\") }\n-    fn crate_struct_field_attrs(&self, cnum: CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n-        { bug!(\"crate_struct_field_attrs\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n@@ -426,15 +391,12 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n         bug!(\"relative_def_path\")\n     }\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { bug!(\"variant_kind\") }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { bug!(\"struct_ctor_def_id\") }\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n         { bug!(\"tuple_struct_definition_if_ctor\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n-    fn crate_top_level_items(&self, cnum: CrateNum) -> Vec<ChildItem>\n-        { bug!(\"crate_top_level_items\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)"}, {"sha": "2c952e9f8634964a0d5ba9ce0307e22495c77a1d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -470,7 +470,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             for impl_did in impl_list.iter() {"}, {"sha": "078cce9c49ff4410121b4893e48f31f0eb308fa3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -43,7 +43,7 @@ macro_rules! language_item_table {\n \n \n enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n     pub enum LangItem {\n         $($variant,)*\n     }"}, {"sha": "8dd5d4d45f7a40e263319849fdd5f9c80de235f4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -493,7 +493,7 @@ impl Passes {\n     }\n }\n \n-#[derive(Clone, PartialEq, Hash)]\n+#[derive(Clone, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,"}, {"sha": "9d7131dc96cc5c31bedf67f55e5e4548288b4b01", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -814,7 +814,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if let ImplCandidate(def_id) = candidate {\n-            if self.tcx().trait_impl_polarity(def_id) == Some(hir::ImplPolarity::Negative) {\n+            if self.tcx().trait_impl_polarity(def_id) == hir::ImplPolarity::Negative {\n                 return Err(Unimplemented)\n             }\n         }"}, {"sha": "4339b1a254f2046566e925e7ef0b19cac09994e3", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell;\n use std::rc::Rc;\n \n use super::{OverlapError, specializes};\n@@ -287,21 +286,10 @@ impl<'a, 'gcx, 'tcx> Node {\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n     pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n-        match *self {\n-            Node::Impl(impl_def_id) => {\n-                NodeItems::Impl {\n-                    tcx: tcx.global_tcx(),\n-                    items: cell::Ref::map(tcx.impl_items.borrow(),\n-                                          |impl_items| &impl_items[&impl_def_id]),\n-                    idx: 0,\n-                }\n-            }\n-            Node::Trait(trait_def_id) => {\n-                NodeItems::Trait {\n-                    items: tcx.trait_items(trait_def_id).clone(),\n-                    idx: 0,\n-                }\n-            }\n+        NodeItems {\n+            tcx: tcx.global_tcx(),\n+            items: tcx.impl_or_trait_items(self.def_id()),\n+            idx: 0,\n         }\n     }\n \n@@ -314,42 +302,23 @@ impl<'a, 'gcx, 'tcx> Node {\n }\n \n /// An iterator over the items defined within a trait or impl.\n-pub enum NodeItems<'a, 'tcx: 'a> {\n-    Impl {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n-        idx: usize,\n-    },\n-    Trait {\n-        items: Rc<Vec<ImplOrTraitItem<'tcx>>>,\n-        idx: usize,\n-    },\n+pub struct NodeItems<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    items: Rc<Vec<ty::ImplOrTraitItemId>>,\n+    idx: usize\n }\n \n impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n     type Item = ImplOrTraitItem<'tcx>;\n     fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n-        match *self {\n-            NodeItems::Impl { tcx, ref items, ref mut idx } => {\n-                let items_table = tcx.impl_or_trait_items.borrow();\n-                if *idx < items.len() {\n-                    let item_def_id = items[*idx].def_id();\n-                    let item = items_table[&item_def_id].clone();\n-                    *idx += 1;\n-                    Some(item)\n-                } else {\n-                    None\n-                }\n-            }\n-            NodeItems::Trait { ref items, ref mut idx } => {\n-                if *idx < items.len() {\n-                    let item = items[*idx].clone();\n-                    *idx += 1;\n-                    Some(item)\n-                } else {\n-                    None\n-                }\n-            }\n+        if self.idx < self.items.len() {\n+            let item_def_id = self.items[self.idx].def_id();\n+            let items_table = self.tcx.impl_or_trait_items.borrow();\n+            let item = items_table[&item_def_id].clone();\n+            self.idx += 1;\n+            Some(item)\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "0d6beb34c69023944dcc64a8fda12d49455da8a9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -330,8 +330,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n \n-    /// Maps from a trait def-id to a list of the def-ids of its trait items\n-    pub trait_item_def_ids: RefCell<DepTrackingMap<maps::TraitItemDefIds<'tcx>>>,\n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    pub impl_or_trait_item_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemIds<'tcx>>>,\n \n     /// A cache for the trait_items() routine; note that the routine\n     /// itself pushes the `TraitItems` dependency node.\n@@ -392,12 +392,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Methods in these implementations don't need to be exported.\n     pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n \n-    /// Maps a DefId of an impl to a list of its items.\n-    /// Note that this contains all of the impls that we know about,\n-    /// including ones in other crates. It's not clear that this is the best\n-    /// way to do it.\n-    pub impl_items: RefCell<DepTrackingMap<maps::ImplItems<'tcx>>>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -734,13 +728,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            impl_or_trait_item_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n             used_trait_imports: RefCell::new(NodeSet()),\n@@ -1401,7 +1394,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n-            let def_ids = self.trait_item_def_ids(trait_did);\n+            let def_ids = self.impl_or_trait_items(trait_did);\n             Rc::new(def_ids.iter()\n                            .map(|d| self.impl_or_trait_item(d.def_id()))\n                            .collect())"}, {"sha": "5e029cf98dc6260a8dd02ff325c26c28e6fa2733", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -34,13 +34,13 @@ dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }\n+dep_map_ty! { ImplOrTraitItemIds: ImplOrTraitItemIds(DefId)\n+                                    -> Rc<Vec<ty::ImplOrTraitItemId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }"}, {"sha": "3eb9f8593e3af8e9eab9703d76f6a310889f7472", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 125, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -50,7 +50,6 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n \n use hir;\n-use hir::{ItemImpl, ItemTrait, PatKind};\n use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n@@ -251,7 +250,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable)]\n pub enum ImplOrTraitItemId {\n     ConstTraitItemId(DefId),\n     MethodTraitItemId(DefId),\n@@ -268,7 +267,7 @@ impl ImplOrTraitItemId {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Copy)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -346,34 +345,12 @@ pub struct Method<'tcx> {\n     pub explicit_self: ExplicitSelfCategory<'tcx>,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n+    pub has_body: bool,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n impl<'tcx> Method<'tcx> {\n-    pub fn new(name: Name,\n-               generics: &'tcx ty::Generics<'tcx>,\n-               predicates: GenericPredicates<'tcx>,\n-               fty: &'tcx BareFnTy<'tcx>,\n-               explicit_self: ExplicitSelfCategory<'tcx>,\n-               vis: Visibility,\n-               defaultness: hir::Defaultness,\n-               def_id: DefId,\n-               container: ImplOrTraitItemContainer)\n-               -> Method<'tcx> {\n-        Method {\n-            name: name,\n-            generics: generics,\n-            predicates: predicates,\n-            fty: fty,\n-            explicit_self: explicit_self,\n-            vis: vis,\n-            defaultness: defaultness,\n-            def_id: def_id,\n-            container: container,\n-        }\n-    }\n-\n     pub fn container_id(&self) -> DefId {\n         match self.container {\n             TraitContainer(id) => id,\n@@ -2236,7 +2213,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n+                    hir::PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n@@ -2299,84 +2276,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            if let ItemTrait(.., ref ms) = self.map.expect_item(id).node {\n-                ms.iter().filter_map(|ti| {\n-                    if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n-                        match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n-                            MethodTraitItem(m) => Some(m),\n-                            _ => {\n-                                bug!(\"provided_trait_methods(): \\\n-                                      non-method item found from \\\n-                                      looking up provided method?!\")\n-                            }\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }).collect()\n-            } else {\n-                bug!(\"provided_trait_methods: `{:?}` is not a trait\", id)\n+        self.impl_or_trait_items(id).iter().filter_map(|id| {\n+            match self.impl_or_trait_item(id.def_id()) {\n+                MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n+                _ => None\n             }\n-        } else {\n-            self.sess.cstore.provided_trait_methods(self.global_tcx(), id)\n-        }\n+        }).collect()\n     }\n \n-    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'gcx>>> {\n+    pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.expect_item(id).node {\n-                ItemTrait(.., ref tis) => {\n-                    tis.iter().filter_map(|ti| {\n-                        if let hir::ConstTraitItem(..) = ti.node {\n-                            match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n-                                ConstTraitItem(ac) => Some(ac),\n-                                _ => {\n-                                    bug!(\"associated_consts(): \\\n-                                          non-const item found from \\\n-                                          looking up a constant?!\")\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }).collect()\n-                }\n-                ItemImpl(.., ref iis) => {\n-                    iis.iter().filter_map(|ii| {\n-                        if let hir::ImplItemKind::Const(..) = ii.node {\n-                            match self.impl_or_trait_item(self.map.local_def_id(ii.id)) {\n-                                ConstTraitItem(ac) => Some(ac),\n-                                _ => {\n-                                    bug!(\"associated_consts(): \\\n-                                          non-const item found from \\\n-                                          looking up a constant?!\")\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }).collect()\n-                }\n-                _ => {\n-                    bug!(\"associated_consts: `{:?}` is not a trait or impl\", id)\n-                }\n-            }\n-        } else {\n-            self.sess.cstore.associated_consts(self.global_tcx(), id)\n-        }\n-    }\n-\n-    pub fn trait_impl_polarity(self, id: DefId) -> Option<hir::ImplPolarity> {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            match self.map.find(id) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        hir::ItemImpl(_, polarity, ..) => Some(polarity),\n-                        _ => None\n-                    }\n-                }\n-                _ => None\n+                hir::ItemImpl(_, polarity, ..) => polarity,\n+                ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n             }\n         } else {\n             self.sess.cstore.impl_polarity(id)\n@@ -2409,10 +2321,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n-    pub fn trait_item_def_ids(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n         lookup_locally_or_in_crate_store(\n-            \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n-            || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n+            \"impl_or_trait_items\", id, &self.impl_or_trait_item_ids,\n+            || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n@@ -2423,20 +2335,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n-    /// Returns whether this DefId refers to an impl\n-    pub fn is_impl(self, id: DefId) -> bool {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            if let Some(ast_map::NodeItem(\n-                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            self.sess.cstore.is_impl(id)\n-        }\n-    }\n-\n     /// Returns a path resolution for node id if it exists, panics otherwise.\n     pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n         *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n@@ -2699,10 +2597,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n                primitive_def_id);\n \n-        let impl_items = self.sess.cstore.impl_items(primitive_def_id);\n+        let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n \n         // Store the implementation info.\n-        self.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n+        self.impl_or_trait_item_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n         self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n     }\n \n@@ -2728,8 +2626,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n         for &impl_def_id in &inherent_impls {\n             // Store the implementation info.\n-            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n-            self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n+            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n+            self.impl_or_trait_item_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n@@ -2758,8 +2656,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.record_trait_has_default_impl(trait_id);\n         }\n \n-        for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n-            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n+        for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n+            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n@@ -2779,7 +2677,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // Store the implementation info.\n-            self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n+            self.impl_or_trait_item_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -3012,7 +2910,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n /// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n+#[derive(Clone, Copy, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ExplicitSelfCategory<'tcx> {\n     Static,\n     ByValue,"}, {"sha": "fe3c498d184bebf0e746a19ef6cd40a5e82ae33a", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -1080,9 +1080,17 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                match tcx.associated_consts(impl_data.impl_def_id)\n-                        .iter().find(|ic| ic.name == ti.name) {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                let ac = tcx.impl_or_trait_items(impl_data.impl_def_id)\n+                    .iter().filter_map(|id| {\n+                        match *id {\n+                            ty::ConstTraitItemId(def_id) => {\n+                                Some(tcx.impl_or_trait_item(def_id))\n+                            }\n+                            _ => None\n+                        }\n+                    }).find(|ic| ic.name() == ti.name);\n+                match ac {\n+                    Some(ic) => lookup_const_by_id(tcx, ic.def_id(), None),\n                     None => match ti.node {\n                         hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n                             Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))"}, {"sha": "94581a3fc89768f6ba02ac695c13c12f391eacb0", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -10,13 +10,38 @@\n \n #![allow(non_camel_case_types, non_upper_case_globals)]\n \n+use rustc::ty;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum Family {\n+    ImmStatic,\n+    MutStatic,\n+    Fn,\n+    Method,\n+    AssociatedType,\n+    Type,\n+    Mod,\n+    ForeignMod,\n+    Enum,\n+    Variant(ty::VariantKind),\n+    Impl,\n+    DefaultImpl,\n+    Trait,\n+    Struct(ty::VariantKind),\n+    Union,\n+    PublicField,\n+    InheritedField,\n+    Const,\n+    AssociatedConst,\n+}\n+\n // GAP 0x00...0x19\n \n pub const tag_items: usize = 0x100; // top-level only\n \n pub const tag_paths_data_name: usize = 0x20;\n \n-pub const tag_def_id: usize = 0x21;\n+pub const tag_def_index: usize = 0x21;\n \n pub const tag_items_data: usize = 0x22;\n \n@@ -26,9 +51,7 @@ pub const tag_items_data_item_family: usize = 0x24;\n \n pub const tag_items_data_item_type: usize = 0x25;\n \n-// GAP 0x26\n-\n-pub const tag_items_data_item_variant: usize = 0x27;\n+// GAP 0x26, 0x27\n \n pub const tag_items_data_parent_item: usize = 0x28;\n \n@@ -47,19 +70,11 @@ pub const tag_attributes: usize = 0x101; // top-level only\n \n // The list of crates that this crate depends on\n pub const tag_crate_deps: usize = 0x102; // top-level only\n-\n-// A single crate dependency\n-pub const tag_crate_dep: usize = 0x35;\n-\n pub const tag_crate_hash: usize = 0x103; // top-level only\n pub const tag_crate_crate_name: usize = 0x104; // top-level only\n pub const tag_crate_disambiguator: usize = 0x113; // top-level only\n \n-pub const tag_crate_dep_crate_name: usize = 0x36;\n-pub const tag_crate_dep_hash: usize = 0x37;\n-pub const tag_crate_dep_explicitly_linked: usize = 0x38; // top-level only\n-\n-pub const tag_item_trait_item: usize = 0x3a;\n+// GAP 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a\n \n pub const tag_item_trait_ref: usize = 0x3b;\n \n@@ -68,26 +83,13 @@ pub const tag_disr_val: usize = 0x3c;\n \n // GAP 0x3d, 0x3e, 0x3f, 0x40\n \n-pub const tag_item_field: usize = 0x41;\n+pub const tag_item_fields: usize = 0x41;\n // GAP 0x42\n pub const tag_item_variances: usize = 0x43;\n-/*\n-  trait items contain tag_item_trait_item elements,\n-  impl items contain tag_item_impl_item elements, and classes\n-  have both. That's because some code treats classes like traits,\n-  and other code treats them like impls. Because classes can contain\n-  both, tag_item_trait_item and tag_item_impl_item have to be two\n-  different tags.\n- */\n-pub const tag_item_impl_item: usize = 0x44;\n+// GAP 0x44\n pub const tag_item_trait_method_explicit_self: usize = 0x45;\n \n-\n-// Reexports are found within module tags. Each reexport contains def_ids\n-// and names.\n-pub const tag_items_data_item_reexport: usize = 0x46;\n-pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n-pub const tag_items_data_item_reexport_name: usize = 0x48;\n+// GAP 0x46, 0x47, 0x48\n \n // used to encode crate_ctxt side tables\n pub const tag_ast: usize = 0x50;\n@@ -98,58 +100,58 @@ pub const tag_mir: usize = 0x52;\n \n // GAP 0x53...0x6a\n \n-pub const tag_item_trait_item_sort: usize = 0x70;\n+pub const tag_item_trait_item_has_body: usize = 0x70;\n \n pub const tag_crate_triple: usize = 0x105; // top-level only\n \n pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n \n-// Language items are a top-level directory (for speed). Hierarchy:\n-//\n-// tag_lang_items\n-// - tag_lang_items_item\n-//   - tag_lang_items_item_id: u32\n-//   - tag_lang_items_item_index: u32\n-\n pub const tag_lang_items: usize = 0x107; // top-level only\n-pub const tag_lang_items_item: usize = 0x73;\n-pub const tag_lang_items_item_id: usize = 0x74;\n-pub const tag_lang_items_item_index: usize = 0x75;\n-pub const tag_lang_items_missing: usize = 0x76;\n \n-pub const tag_item_unnamed_field: usize = 0x77;\n+// GAP 0x73, 0x74, 0x75\n+\n+pub const tag_lang_items_missing: usize = 0x76; // top-level only\n+\n+// GAP 0x77\n+\n pub const tag_items_data_item_visibility: usize = 0x78;\n-pub const tag_items_data_item_inherent_impl: usize = 0x79;\n+pub const tag_items_data_item_inherent_impls: usize = 0x79;\n+\n // GAP 0x7a\n-pub const tag_mod_child: usize = 0x7b;\n+\n+// GAP 0x7c\n+pub const tag_mod_children: usize = 0x7b;\n+\n+// GAP 0x108 // top-level only\n+\n // GAP 0x7c\n \n // GAP 0x108\n pub const tag_impls: usize = 0x109; // top-level only\n-pub const tag_impls_trait: usize = 0x7d;\n-pub const tag_impls_trait_impl: usize = 0x7e;\n \n-// GAP 0x7f, 0x80, 0x81\n+// GAP 0x7d, 0x7e, 0x7f, 0x80, 0x81\n \n pub const tag_native_libraries: usize = 0x10a; // top-level only\n-pub const tag_native_libraries_lib: usize = 0x82;\n-pub const tag_native_libraries_name: usize = 0x83;\n-pub const tag_native_libraries_kind: usize = 0x84;\n+\n+// GAP 0x82, 0x83, 0x84\n \n pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n \n pub const tag_method_argument_names: usize = 0x85;\n-pub const tag_method_argument_name: usize = 0x86;\n+\n+// GAP 0x86\n \n pub const tag_reachable_ids: usize = 0x10c; // top-level only\n-pub const tag_reachable_id: usize = 0x87;\n+\n+// GAP 0x87\n \n pub const tag_items_data_item_stability: usize = 0x88;\n \n pub const tag_items_data_item_repr: usize = 0x89;\n \n-pub const tag_struct_fields: usize = 0x10d; // top-level only\n-pub const tag_struct_field: usize = 0x8a;\n+// GAP 0x10d // top-level only\n+\n+// GAP 0x8a\n \n pub const tag_items_data_item_struct_ctor: usize = 0x8b;\n pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n@@ -160,10 +162,7 @@ pub const tag_item_generics: usize = 0x8f;\n // GAP 0x90, 0x91, 0x92, 0x93, 0x94\n \n pub const tag_item_predicates: usize = 0x95;\n-// GAP 0x96\n-\n-pub const tag_predicate: usize = 0x97;\n-// GAP 0x98, 0x99\n+// GAP 0x96, 0x97, 0x98, 0x99\n \n pub const tag_unsafety: usize = 0x9a;\n \n@@ -173,15 +172,14 @@ pub const tag_associated_type_name: usize = 0x9c;\n pub const tag_polarity: usize = 0x9d;\n \n pub const tag_macro_defs: usize = 0x10e; // top-level only\n-pub const tag_macro_def: usize = 0x9e;\n-pub const tag_macro_def_body: usize = 0x9f;\n-pub const tag_macro_def_span_lo: usize = 0xa8;\n-pub const tag_macro_def_span_hi: usize = 0xa9;\n+\n+// GAP 0x9e, 0x9f\n \n pub const tag_paren_sugar: usize = 0xa0;\n \n pub const tag_codemap: usize = 0xa1;\n-pub const tag_codemap_filemap: usize = 0xa2;\n+\n+// GAP 0xa2\n \n pub const tag_item_super_predicates: usize = 0xa3;\n "}, {"sha": "7b6ed4e6b76489c59a1fe00d2db8af47f712e4bd", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -264,7 +264,7 @@ impl<'a> CrateReader<'a> {\n \n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == crate_name &&\n-           self.sess.local_crate_disambiguator() == disambiguator {\n+           self.sess.local_crate_disambiguator() == &disambiguator[..] {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n@@ -320,7 +320,6 @@ impl<'a> CrateReader<'a> {\n         let loader::Library { dylib, rlib, metadata } = lib;\n \n         let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n-        let staged_api = self.is_staged_api(metadata.as_slice());\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n@@ -332,7 +331,6 @@ impl<'a> CrateReader<'a> {\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n-            staged_api: staged_api,\n             explicitly_linked: Cell::new(explicitly_linked),\n         });\n \n@@ -352,16 +350,6 @@ impl<'a> CrateReader<'a> {\n         (cnum, cmeta, source)\n     }\n \n-    fn is_staged_api(&self, data: &[u8]) -> bool {\n-        let attrs = decoder::get_crate_attributes(data);\n-        for attr in &attrs {\n-            if attr.name() == \"stable\" || attr.name() == \"unstable\" {\n-                return true\n-            }\n-        }\n-        false\n-    }\n-\n     fn resolve_crate(&mut self,\n                      root: &Option<CratePaths>,\n                      ident: &str,"}, {"sha": "38b18fa63e3eb40ff0703e56d36974ecf232362b", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 25, "deletions": 89, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -14,22 +14,21 @@ use decoder;\n use encoder;\n use loader;\n \n-use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate, DefLike};\n+use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n use middle::lang_items;\n-use rustc::ty::{self, Ty, TyCtxt, VariantKind};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n use rustc::mir::repr::Mir;\n use rustc::mir::mir_map::MirMap;\n-use rustc::util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc::session::config::PanicStrategy;\n \n-use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n@@ -166,42 +165,27 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n+        if let Some(def_id) = filter {\n+            self.dep_graph.read(DepNode::MetaData(def_id));\n+        }\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n-            decoder::each_implementation_for_trait(cdata, def_id, &mut |iid| {\n+            decoder::each_implementation_for_trait(cdata, filter, &mut |iid| {\n                 result.push(iid)\n             })\n         });\n         result\n     }\n \n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_provided_trait_methods(&cdata, def.index, tcx)\n-    }\n-\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_trait_item_def_ids(&cdata, def.index)\n-    }\n-\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(impl_def_id));\n-        let cdata = self.get_crate_data(impl_def_id.krate);\n-        decoder::get_impl_items(&cdata, impl_def_id.index)\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<ty::ImplOrTraitItemId> {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::get_impl_or_trait_items(&cdata, def_id.index)\n     }\n \n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n@@ -224,14 +208,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_custom_coerce_unsized_kind(&cdata, def.index)\n     }\n \n-    // FIXME: killme\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_associated_consts(&cdata, def.index, tcx)\n-    }\n-\n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n         let cdata = self.get_crate_data(impl_def.krate);\n@@ -266,13 +242,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_defaulted_trait(&cdata, trait_def_id.index)\n     }\n \n-    fn is_impl(&self, did: DefId) -> bool\n-    {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_impl(&cdata, did.index)\n-    }\n-\n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(impl_did));\n         let cdata = self.get_crate_data(impl_did.krate);\n@@ -295,12 +264,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_is_statically_included_foreign_item(id)\n     }\n \n-    fn is_typedef(&self, did: DefId) -> bool {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_typedef(&cdata, did.index)\n-    }\n-\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                 -> Vec<(CrateNum, LinkagePreference)>\n     {\n@@ -310,12 +273,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n-        let mut result = vec![];\n         let crate_data = self.get_crate_data(cnum);\n-        decoder::each_lang_item(&crate_data, |did, lid| {\n-            result.push((did, lid)); true\n-        });\n-        result\n+        decoder::get_lang_items(&crate_data)\n     }\n \n     fn missing_lang_items(&self, cnum: CrateNum)\n@@ -327,7 +286,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn is_staged_api(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).staged_api\n+        self.get_crate_data(cnum).is_staged_api()\n     }\n \n     fn is_explicitly_linked(&self, cnum: CrateNum) -> bool\n@@ -355,7 +314,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>\n     {\n-        decoder::get_crate_attributes(self.get_crate_data(cnum).data())\n+        decoder::get_item_attrs(&self.get_crate_data(cnum), CRATE_DEF_INDEX)\n     }\n \n     fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n@@ -382,13 +341,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n     {\n         let cdata = self.get_crate_data(cnum);\n-        token::intern_and_get_ident(decoder::get_crate_disambiguator(cdata.data()))\n-    }\n-\n-    fn crate_struct_field_attrs(&self, cnum: CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n-    {\n-        decoder::get_struct_field_attrs(&self.get_crate_data(cnum))\n+        token::intern_and_get_ident(&decoder::get_crate_disambiguator(cdata.data()))\n     }\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n@@ -447,12 +400,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::def_path(&cdata, def.index)\n     }\n \n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_variant_kind(&cdata, def_id.index)\n-    }\n-\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n     {\n         self.dep_graph.read(DepNode::MetaData(struct_def_id));\n@@ -486,17 +433,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn crate_top_level_items(&self, cnum: CrateNum) -> Vec<ChildItem>\n-    {\n-        let mut result = vec![];\n-        let crate_data = self.get_crate_data(cnum);\n-        let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_top_level_item_of_crate(&crate_data, get_crate_data, |def, name, vis| {\n-            result.push(ChildItem { def: def, name: name, vis: vis });\n-        });\n-        result\n-    }\n-\n     fn maybe_get_item_ast<'a>(&'tcx self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n@@ -726,9 +662,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n             let mut bfs_queue = &mut VecDeque::new();\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: ChildItem, parent: DefId| {\n-                let child = match child.def {\n-                    DefLike::DlDef(def) if child.vis == ty::Visibility::Public => def.def_id(),\n-                    _ => return,\n+                let child = if child.vis == ty::Visibility::Public {\n+                    child.def.def_id()\n+                } else {\n+                    return;\n                 };\n \n                 match visible_parent_map.entry(child) {\n@@ -746,10 +683,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 }\n             };\n \n-            let croot = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-            for child in self.crate_top_level_items(cnum) {\n-                add_child(bfs_queue, child, croot);\n-            }\n+            bfs_queue.push_back(DefId {\n+                krate: cnum,\n+                index: CRATE_DEF_INDEX\n+            });\n             while let Some(def) = bfs_queue.pop_front() {\n                 for child in self.item_children(def) {\n                     add_child(bfs_queue, child, def);\n@@ -760,4 +697,3 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         visible_parent_map\n     }\n }\n-"}, {"sha": "7aa4677353bb2260d2bee04087465a32fe382e0e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -22,7 +22,7 @@ use index;\n use loader;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{CrateNum, DefIndex, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n@@ -77,7 +77,6 @@ pub struct CrateMetadata {\n     pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n-    pub staged_api: bool,\n \n     pub index: index::Index,\n     pub xref_index: index::DenseIndex,\n@@ -300,9 +299,9 @@ impl CStore {\n \n impl CrateMetadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n-    pub fn name(&self) -> &str { decoder::get_crate_name(self.data()) }\n+    pub fn name(&self) -> String { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n-    pub fn disambiguator(&self) -> &str {\n+    pub fn disambiguator(&self) -> String {\n         decoder::get_crate_disambiguator(self.data())\n     }\n     pub fn imported_filemaps<'a>(&'a self, codemap: &codemap::CodeMap)\n@@ -320,23 +319,30 @@ impl CrateMetadata {\n         }\n     }\n \n+    pub fn is_staged_api(&self) -> bool {\n+        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n+        attrs.iter().any(|attr| {\n+            attr.name() == \"stable\" || attr.name() == \"unstable\"\n+        })\n+    }\n+\n     pub fn is_allocator(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"allocator\")\n     }\n \n     pub fn needs_allocator(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n     pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n     pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n "}, {"sha": "507e6414181b81bedeecde01cdd7ea21b1f58c9d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 296, "deletions": 703, "changes": 999, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -12,13 +12,11 @@\n \n #![allow(non_camel_case_types)]\n \n-use self::Family::*;\n-\n use astencode::decode_inlined_item;\n use cstore::{self, CrateMetadata};\n use common::*;\n+use common::Family::*;\n use def_key;\n-use encoder::def_to_u64;\n use index;\n \n use rustc::hir::def_id::CRATE_DEF_INDEX;\n@@ -31,12 +29,11 @@ use rustc::hir::intravisit::IdRange;\n use rustc::session::config::PanicStrategy;\n \n use middle::cstore::{InlinedItem, LinkagePreference};\n-use middle::cstore::{DefLike, DlDef, DlField, DlImpl};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use middle::lang_items;\n use rustc::ty::{ImplContainer, TraitContainer};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, VariantKind};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n@@ -52,12 +49,9 @@ use std::u32;\n use rbml::reader;\n use rbml;\n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n-use rustc_serialize as serialize;\n use syntax::attr;\n-use syntax::parse::token;\n use syntax::ast::{self, NodeId};\n-use syntax::print::pprust;\n-use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n+use syntax_pos::{self, Span, BytePos};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     pub opaque: opaque::Decoder<'a>,\n@@ -94,6 +88,25 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     pub fn cdata(&self) -> &'a cstore::CrateMetadata {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n+\n+    pub fn decode<T: Decodable>(&mut self) -> T {\n+        T::decode(self).unwrap()\n+    }\n+\n+    /// Iterate over the indices of a sequence.\n+    /// This will work solely because of `serialize::opaque`'s\n+    /// simple encoding of `n: usize` followed by `n` elements.\n+    pub fn seq<T: Decodable>(mut self) -> impl Iterator<Item=T> {\n+        (0..self.read_usize().unwrap()).map(move |_| {\n+            self.decode()\n+        })\n+    }\n+\n+    pub fn seq_mut<'b, T: Decodable>(&'b mut self) -> impl Iterator<Item=T> + 'b {\n+        (0..self.read_usize().unwrap()).map(move |_| {\n+            self.decode()\n+        })\n+    }\n }\n \n macro_rules! decoder_methods {\n@@ -104,8 +117,8 @@ macro_rules! decoder_methods {\n     }\n }\n \n-impl<'doc, 'tcx> serialize::Decoder for ::decoder::DecodeContext<'doc, 'tcx> {\n-    type Error = <opaque::Decoder<'doc> as serialize::Decoder>::Error;\n+impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n+    type Error = <opaque::Decoder<'doc> as Decoder>::Error;\n \n     decoder_methods! {\n         read_nil -> ();\n@@ -311,175 +324,70 @@ impl CrateMetadata {\n }\n \n pub fn load_index(data: &[u8]) -> index::Index {\n-    let index = reader::get_doc(rbml::Doc::new(data), tag_index);\n-    index::Index::from_rbml(index)\n+    index::Index::from_rbml(rbml::Doc::new(data).get(tag_index))\n }\n \n pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n     let doc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(doc, tag_rustc_version).map(|s| s.to_string())\n+    reader::maybe_get_doc(doc, tag_rustc_version).map(|s| {\n+        str::from_utf8(&s.data[s.start..s.end]).unwrap().to_string()\n+    })\n }\n \n pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n-    let index = reader::get_doc(rbml::Doc::new(data), tag_xref_index);\n+    let index = rbml::Doc::new(data).get(tag_xref_index);\n     index::DenseIndex::from_buf(index.data, index.start, index.end)\n }\n \n // Go through each item in the metadata and create a map from that\n // item's def-key to the item's DefIndex.\n pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n-    let root_doc = rbml::Doc::new(data);\n-    let items_doc = reader::get_doc(root_doc, tag_items);\n-    let items_data_doc = reader::get_doc(items_doc, tag_items_data);\n-    reader::docs(items_data_doc)\n-        .filter(|&(tag, _)| tag == tag_items_data_item)\n-        .map(|(_, item_doc)| {\n-            // load def-key from item\n-            let key = item_def_key(item_doc);\n-\n-            // load def-index from item; we only encode the full def-id,\n-            // so just pull out the index\n-            let def_id_doc = reader::get_doc(item_doc, tag_def_id);\n-            let def_id = untranslated_def_id(def_id_doc);\n-            assert!(def_id.is_local()); // local to the crate we are decoding, that is\n-\n-            (key, def_id.index)\n-        })\n-        .collect()\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum Family {\n-    ImmStatic,             // c\n-    MutStatic,             // b\n-    Fn,                    // f\n-    StaticMethod,          // F\n-    Method,                // h\n-    Type,                  // y\n-    Mod,                   // m\n-    ForeignMod,            // n\n-    Enum,                  // t\n-    Variant(VariantKind),  // V, v, w\n-    Impl,                  // i\n-    DefaultImpl,           // d\n-    Trait,                 // I\n-    Struct(VariantKind),   // S, s, u\n-    Union,                 // U\n-    PublicField,           // g\n-    InheritedField,        // N\n-    Constant,              // C\n+    rbml::Doc::new(data).get(tag_items).get(tag_items_data).children().map(|item_doc| {\n+        // load def-key from item\n+        let key = item_def_key(item_doc);\n+\n+        // load def-index from item\n+        (key, item_doc.get(tag_def_index).decoder().decode())\n+    }).collect()\n }\n \n fn item_family(item: rbml::Doc) -> Family {\n-    let fam = reader::get_doc(item, tag_items_data_item_family);\n-    match reader::doc_as_u8(fam) as char {\n-      'C' => Constant,\n-      'c' => ImmStatic,\n-      'b' => MutStatic,\n-      'f' => Fn,\n-      'F' => StaticMethod,\n-      'h' => Method,\n-      'y' => Type,\n-      'm' => Mod,\n-      'n' => ForeignMod,\n-      't' => Enum,\n-      'V' => Variant(VariantKind::Struct),\n-      'v' => Variant(VariantKind::Tuple),\n-      'w' => Variant(VariantKind::Unit),\n-      'i' => Impl,\n-      'd' => DefaultImpl,\n-      'I' => Trait,\n-      'S' => Struct(VariantKind::Struct),\n-      's' => Struct(VariantKind::Tuple),\n-      'u' => Struct(VariantKind::Unit),\n-      'U' => Union,\n-      'g' => PublicField,\n-      'N' => InheritedField,\n-       c => bug!(\"unexpected family char: {}\", c)\n-    }\n+    item.get(tag_items_data_item_family).decoder().decode()\n }\n \n fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n         None => ty::Visibility::Public,\n-        Some(visibility_doc) => {\n-            match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => ty::Visibility::Public,\n-                'i' => ty::Visibility::PrivateExternal,\n-                _ => bug!(\"unknown visibility character\")\n-            }\n-        }\n-    }\n-}\n-\n-fn fn_constness(item: rbml::Doc) -> hir::Constness {\n-    match reader::maybe_get_doc(item, tag_items_data_item_constness) {\n-        None => hir::Constness::NotConst,\n-        Some(constness_doc) => {\n-            match reader::doc_as_u8(constness_doc) as char {\n-                'c' => hir::Constness::Const,\n-                'n' => hir::Constness::NotConst,\n-                _ => bug!(\"unknown constness character\")\n-            }\n-        }\n+        Some(visibility_doc) => visibility_doc.decoder().decode()\n     }\n }\n \n fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n     match reader::maybe_get_doc(item, tag_items_data_item_defaultness) {\n         None => hir::Defaultness::Default, // should occur only for default impls on traits\n-        Some(defaultness_doc) => {\n-            match reader::doc_as_u8(defaultness_doc) as char {\n-                'd' => hir::Defaultness::Default,\n-                'f' => hir::Defaultness::Final,\n-                _ => bug!(\"unknown defaultness character\")\n-            }\n-        }\n-    }\n-}\n-\n-fn item_sort(item: rbml::Doc) -> Option<char> {\n-    reader::tagged_docs(item, tag_item_trait_item_sort).nth(0).map(|doc| {\n-        doc.as_str().as_bytes()[0] as char\n-    })\n-}\n-\n-fn untranslated_def_id(d: rbml::Doc) -> DefId {\n-    let id = reader::doc_as_u64(d);\n-    DefId {\n-        krate: CrateNum::from_u32((id >> 32) as u32),\n-        index: DefIndex::from_u32((id & 0xFFFF_FFFF) as u32)\n+        Some(defaultness_doc) => defaultness_doc.decoder().decode()\n     }\n }\n \n-fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n-    let def_id = untranslated_def_id(d);\n-    translate_def_id(cdata, def_id)\n-}\n-\n fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n-    reader::tagged_docs(d, tag_items_data_parent_item).nth(0).map(|did| {\n-        translated_def_id(cdata, did)\n+    reader::maybe_get_doc(d, tag_items_data_parent_item).map(|did| {\n+        let mut dcx = did.decoder();\n+        dcx.cdata = Some(cdata);\n+        dcx.decode()\n     })\n }\n \n fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> DefId {\n-    translated_def_id(cdata, reader::get_doc(d, tag_items_data_parent_item))\n+    let mut dcx = d.get(tag_items_data_parent_item).decoder();\n+    dcx.cdata = Some(cdata);\n+    dcx.decode()\n }\n \n fn item_def_id(d: rbml::Doc, cdata: Cmd) -> DefId {\n-    translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n-}\n-\n-fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n-    reader::tagged_docs(d, tag_items_data_item_reexport)\n-}\n-\n-fn variant_disr_val(d: rbml::Doc) -> u64 {\n-    let val_doc = reader::get_doc(d, tag_disr_val);\n-    reader::with_doc_data(val_doc, |data| {\n-        str::from_utf8(data).unwrap().parse().unwrap()\n-    })\n+    DefId {\n+        krate: cdata.cnum,\n+        index: d.get(tag_def_index).decoder().decode()\n+    }\n }\n \n fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n@@ -492,7 +400,7 @@ fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n         let mut dcx = tp.decoder();\n         dcx.tcx = Some(tcx);\n         dcx.cdata = Some(cdata);\n-        Decodable::decode(&mut dcx).unwrap()\n+        dcx.decode()\n     })\n }\n \n@@ -501,13 +409,7 @@ fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: C\n     let mut dcx = doc.decoder();\n     dcx.tcx = Some(tcx);\n     dcx.cdata = Some(cdata);\n-    Decodable::decode(&mut dcx).unwrap()\n-}\n-\n-fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                            -> ty::TraitRef<'tcx> {\n-    let tp = reader::get_doc(doc, tag_item_trait_ref);\n-    doc_trait_ref(tp, tcx, cdata)\n+    dcx.decode()\n }\n \n fn item_name(item: rbml::Doc) -> ast::Name {\n@@ -516,95 +418,43 @@ fn item_name(item: rbml::Doc) -> ast::Name {\n \n fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n     reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n-        let string = name.as_str();\n-        token::intern(string)\n+        name.decoder().decode()\n     })\n }\n \n-fn family_to_variant_kind<'tcx>(family: Family) -> Option<ty::VariantKind> {\n-    match family {\n-        Struct(VariantKind::Struct) | Variant(VariantKind::Struct) | Union =>\n-            Some(ty::VariantKind::Struct),\n-        Struct(VariantKind::Tuple) | Variant(VariantKind::Tuple) =>\n-            Some(ty::VariantKind::Tuple),\n-        Struct(VariantKind::Unit) | Variant(VariantKind::Unit) =>\n-            Some(ty::VariantKind::Unit),\n-        _ => None,\n-    }\n-}\n-\n-fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n-    let fam = item_family(item);\n-    match fam {\n-        Constant  => {\n-            // Check whether we have an associated const item.\n-            match item_sort(item) {\n-                Some('C') | Some('c') => {\n-                    DlDef(Def::AssociatedConst(did))\n-                }\n-                _ => {\n-                    // Regular const item.\n-                    DlDef(Def::Const(did))\n-                }\n-            }\n-        }\n-        ImmStatic => DlDef(Def::Static(did, false)),\n-        MutStatic => DlDef(Def::Static(did, true)),\n-        Struct(..) => DlDef(Def::Struct(did)),\n-        Union => DlDef(Def::Union(did)),\n-        Fn        => DlDef(Def::Fn(did)),\n-        Method | StaticMethod => {\n-            DlDef(Def::Method(did))\n+fn item_to_def(cdata: Cmd, item: rbml::Doc, did: DefId) -> Option<Def> {\n+    Some(match item_family(item) {\n+        Family::Const  => Def::Const(did),\n+        Family::AssociatedConst => Def::AssociatedConst(did),\n+        Family::ImmStatic => Def::Static(did, false),\n+        Family::MutStatic => Def::Static(did, true),\n+        Family::Struct(..) => Def::Struct(did),\n+        Family::Union => Def::Union(did),\n+        Family::Fn  => Def::Fn(did),\n+        Family::Method => Def::Method(did),\n+        Family::Type => Def::TyAlias(did),\n+        Family::AssociatedType => {\n+            Def::AssociatedTy(item_require_parent_item(cdata, item), did)\n         }\n-        Type => {\n-            if item_sort(item) == Some('t') {\n-                let trait_did = item_require_parent_item(cdata, item);\n-                DlDef(Def::AssociatedTy(trait_did, did))\n-            } else {\n-                DlDef(Def::TyAlias(did))\n-            }\n+        Family::Mod => Def::Mod(did),\n+        Family::ForeignMod => Def::ForeignMod(did),\n+        Family::Variant(..) => {\n+            Def::Variant(item_require_parent_item(cdata, item), did)\n         }\n-        Mod => DlDef(Def::Mod(did)),\n-        ForeignMod => DlDef(Def::ForeignMod(did)),\n-        Variant(..) => {\n-            let enum_did = item_require_parent_item(cdata, item);\n-            DlDef(Def::Variant(enum_did, did))\n+        Family::Trait => Def::Trait(did),\n+        Family::Enum => Def::Enum(did),\n+\n+        Family::Impl |\n+        Family::DefaultImpl |\n+        Family::PublicField |\n+        Family::InheritedField => {\n+            return None\n         }\n-        Trait => DlDef(Def::Trait(did)),\n-        Enum => DlDef(Def::Enum(did)),\n-        Impl | DefaultImpl => DlImpl(did),\n-        PublicField | InheritedField => DlField,\n-    }\n-}\n-\n-fn parse_unsafety(item_doc: rbml::Doc) -> hir::Unsafety {\n-    let unsafety_doc = reader::get_doc(item_doc, tag_unsafety);\n-    if reader::doc_as_u8(unsafety_doc) != 0 {\n-        hir::Unsafety::Unsafe\n-    } else {\n-        hir::Unsafety::Normal\n-    }\n-}\n-\n-fn parse_paren_sugar(item_doc: rbml::Doc) -> bool {\n-    let paren_sugar_doc = reader::get_doc(item_doc, tag_paren_sugar);\n-    reader::doc_as_u8(paren_sugar_doc) != 0\n-}\n-\n-fn parse_polarity(item_doc: rbml::Doc) -> hir::ImplPolarity {\n-    let polarity_doc = reader::get_doc(item_doc, tag_polarity);\n-    if reader::doc_as_u8(polarity_doc) != 0 {\n-        hir::ImplPolarity::Negative\n-    } else {\n-        hir::ImplPolarity::Positive\n-    }\n+    })\n }\n \n fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n-    let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n-    reader::tagged_docs(names_doc, tag_associated_type_name)\n-        .map(|name_doc| token::intern(name_doc.as_str()))\n-        .collect()\n+    item_doc.get(tag_associated_type_names).decoder().decode()\n }\n \n pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n@@ -613,15 +463,16 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata);\n-    let unsafety = parse_unsafety(item_doc);\n+    let unsafety = item_doc.get(tag_unsafety).decoder().decode();\n     let associated_type_names = parse_associated_type_names(item_doc);\n-    let paren_sugar = parse_paren_sugar(item_doc);\n+    let paren_sugar = item_doc.get(tag_paren_sugar).decoder().decode();\n+    let trait_ref = doc_trait_ref(item_doc.get(tag_item_trait_ref), tcx, cdata);\n     let def_path = def_path(cdata, item_id).unwrap();\n \n     ty::TraitDef::new(unsafety,\n                       paren_sugar,\n                       generics,\n-                      item_trait_ref(item_doc, tcx, cdata),\n+                      trait_ref,\n                       associated_type_names,\n                       def_path.deterministic_hash(tcx))\n }\n@@ -632,16 +483,19 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n                              -> ty::AdtDefMaster<'tcx>\n {\n     fn expect_variant_kind(family: Family) -> ty::VariantKind {\n-        match family_to_variant_kind(family) {\n-            Some(kind) => kind,\n+        match family {\n+            Struct(kind) | Variant(kind) => kind,\n+            Union => ty::VariantKind::Struct,\n             _ => bug!(\"unexpected family: {:?}\", family),\n         }\n     }\n     fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n-        reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n-            let did = translated_def_id(cdata, p);\n+        let mut dcx = doc.get(tag_mod_children).decoder();\n+        dcx.cdata = Some(cdata);\n+\n+        dcx.seq().map(|did: DefId| {\n             let item = cdata.lookup_item(did.index);\n-            let disr = variant_disr_val(item);\n+            let disr = item.get(tag_disr_val).decoder().decode();\n             ty::VariantDefData {\n                 did: did,\n                 name: item_name(item),\n@@ -652,23 +506,18 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         }).collect()\n     }\n     fn get_variant_fields<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n-        let mut index = 0;\n-        reader::tagged_docs(doc, tag_item_field).map(|f| {\n-            let ff = item_family(f);\n-            match ff {\n-                PublicField | InheritedField => {},\n-                _ => bug!(\"expected field, found {:?}\", ff)\n+        let mut dcx = doc.get(tag_item_fields).decoder();\n+        dcx.cdata = Some(cdata);\n+\n+        dcx.seq().map(|did: DefId| {\n+            let f = cdata.lookup_item(did.index);\n+            let vis = match item_family(f) {\n+                PublicField => ty::Visibility::Public,\n+                InheritedField => ty::Visibility::PrivateExternal,\n+                _ => bug!()\n             };\n-            ty::FieldDefData::new(item_def_id(f, cdata),\n-                                  item_name(f),\n-                                  struct_field_family_to_visibility(ff))\n-        }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n-            let ff = item_family(f);\n-            let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n-            index += 1;\n-            ty::FieldDefData::new(item_def_id(f, cdata), name,\n-                                  struct_field_family_to_visibility(ff))\n-        })).collect()\n+            ty::FieldDefData::new(did, item_name(f), vis)\n+        }).collect()\n     }\n     fn get_struct_variant<'tcx>(cdata: Cmd,\n                                 doc: rbml::Doc,\n@@ -692,7 +541,9 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         Struct(..) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n-                translated_def_id(cdata, ctor_doc)\n+                let mut dcx = ctor_doc.decoder();\n+                dcx.cdata = Some(cdata);\n+                dcx.decode()\n             });\n             (AdtKind::Struct, vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n         }\n@@ -784,14 +635,14 @@ pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n-        Decodable::decode(&mut doc.decoder()).unwrap()\n+        doc.decoder().decode()\n     })\n }\n \n pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_deprecation).map(|doc| {\n-        Decodable::decode(&mut doc.decoder()).unwrap()\n+        doc.decoder().decode()\n     })\n }\n \n@@ -802,26 +653,21 @@ pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_parent_impl).map(|doc| {\n-        translated_def_id(cdata, doc)\n+        let mut dcx = doc.decoder();\n+        dcx.cdata = Some(cdata);\n+        dcx.decode()\n     })\n }\n \n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_repr).map_or(vec![], |doc| {\n-        Decodable::decode(&mut doc.decoder()).unwrap()\n+        doc.decoder().decode()\n     })\n }\n \n-pub fn get_impl_polarity(cdata: Cmd, id: DefIndex) -> Option<hir::ImplPolarity> {\n-    let item_doc = cdata.lookup_item(id);\n-    let fam = item_family(item_doc);\n-    match fam {\n-        Family::Impl => {\n-            Some(parse_polarity(item_doc))\n-        }\n-        _ => None\n-    }\n+pub fn get_impl_polarity(cdata: Cmd, id: DefIndex) -> hir::ImplPolarity {\n+    cdata.lookup_item(id).get(tag_polarity).decoder().decode()\n }\n \n pub fn get_custom_coerce_unsized_kind(\n@@ -831,7 +677,7 @@ pub fn get_custom_coerce_unsized_kind(\n {\n     let item_doc = cdata.lookup_item(id);\n     reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n-        Decodable::decode(&mut kind_doc.decoder()).unwrap()\n+        kind_doc.decoder().decode()\n     })\n }\n \n@@ -841,44 +687,38 @@ pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n                                 -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = cdata.lookup_item(id);\n-    let fam = item_family(item_doc);\n-    match fam {\n-        Family::Impl | Family::DefaultImpl => {\n-            reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-                doc_trait_ref(tp, tcx, cdata)\n-            })\n-        }\n-        _ => None\n-    }\n+    reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n+        doc_trait_ref(tp, tcx, cdata)\n+    })\n }\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n-    F: FnMut(DefIndex, usize) -> bool,\n-{\n-    let root = rbml::Doc::new(cdata.data());\n-    let lang_items = reader::get_doc(root, tag_lang_items);\n-    reader::tagged_docs(lang_items, tag_lang_items_item).all(|item_doc| {\n-        let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n-        let id = reader::doc_as_u32(id_doc) as usize;\n-        let index_doc = reader::get_doc(item_doc, tag_lang_items_item_index);\n-        let index = DefIndex::from_u32(reader::doc_as_u32(index_doc));\n-\n-        f(index, id)\n-    })\n+pub fn get_lang_items(cdata: Cmd) -> Vec<(DefIndex, usize)> {\n+    rbml::Doc::new(cdata.data()).get(tag_lang_items).decoder().decode()\n }\n \n-fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n-                                     item_doc: rbml::Doc,\n-                                     mut get_crate_data: G,\n-                                     mut callback: F) where\n-    F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n+\n+/// Iterates over each child of the given item.\n+pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n+                                mut get_crate_data: G,\n+                                mut callback: F)\n+    where F: FnMut(Def, ast::Name, ty::Visibility),\n+          G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n {\n-    // Iterate over all children.\n-    for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n-        let child_def_id = translated_def_id(cdata, child_info_doc);\n+    // Find the item.\n+    let item_doc = match cdata.get_item(id) {\n+        None => return,\n+        Some(item_doc) => item_doc,\n+    };\n+\n+    let mut dcx = match reader::maybe_get_doc(item_doc, tag_mod_children) {\n+        Some(doc) => doc.decoder(),\n+        None => return\n+    };\n+    dcx.cdata = Some(cdata);\n \n+    // Iterate over all children.\n+    for child_def_id in dcx.seq_mut::<DefId>() {\n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n         let crate_data = if child_def_id.krate == cdata.cnum {\n@@ -894,66 +734,38 @@ fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n         // Get the item.\n         if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n             // Hand off the item to the callback.\n-            let child_name = item_name(child_item_doc);\n-            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n-            let visibility = item_visibility(child_item_doc);\n-            callback(def_like, child_name, visibility);\n+            if let Some(def) = item_to_def(crate_data, child_item_doc, child_def_id) {\n+                let child_name = item_name(child_item_doc);\n+                let visibility = item_visibility(child_item_doc);\n+                callback(def, child_name, visibility);\n+            }\n         }\n     }\n \n-    for reexport_doc in reexports(item_doc) {\n-        let def_id_doc = reader::get_doc(reexport_doc,\n-                                         tag_items_data_item_reexport_def_id);\n-        let child_def_id = translated_def_id(cdata, def_id_doc);\n-\n-        let name_doc = reader::get_doc(reexport_doc,\n-                                       tag_items_data_item_reexport_name);\n-        let name = name_doc.as_str();\n-\n+    for exp in dcx.seq_mut::<def::Export>() {\n         // This reexport may be in yet another crate.\n-        let crate_data = if child_def_id.krate == cdata.cnum {\n+        let crate_data = if exp.def_id.krate == cdata.cnum {\n             None\n         } else {\n-            Some(get_crate_data(child_def_id.krate))\n+            Some(get_crate_data(exp.def_id.krate))\n         };\n         let crate_data = match crate_data {\n             Some(ref cdata) => &**cdata,\n             None => cdata\n         };\n \n         // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n+        if let Some(child_item_doc) = crate_data.get_item(exp.def_id.index) {\n             // Hand off the item to the callback.\n-            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n-            // These items have a public visibility because they're part of\n-            // a public re-export.\n-            callback(def_like, token::intern(name), ty::Visibility::Public);\n+            if let Some(def) = item_to_def(crate_data, child_item_doc, exp.def_id) {\n+                // These items have a public visibility because they're part of\n+                // a public re-export.\n+                callback(def, exp.name, ty::Visibility::Public);\n+            }\n         }\n     }\n }\n \n-/// Iterates over each child of the given item.\n-pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex, get_crate_data: G, callback: F)\n-    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n-          G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n-{\n-    // Find the item.\n-    let item_doc = match cdata.get_item(id) {\n-        None => return,\n-        Some(item_doc) => item_doc,\n-    };\n-\n-    each_child_of_item_or_crate(cdata, item_doc, get_crate_data, callback)\n-}\n-\n-/// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate<F, G>(cdata: Cmd, get_crate_data: G, callback: F)\n-    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n-          G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n-{\n-    each_child_of_item(cdata, CRATE_DEF_INDEX, get_crate_data, callback)\n-}\n-\n pub fn get_item_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n     item_name(cdata.lookup_item(id))\n }\n@@ -1030,48 +842,31 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n         let mut dcx = mir_doc.decoder();\n         dcx.tcx = Some(tcx);\n         dcx.cdata = Some(cdata);\n-        Decodable::decode(&mut dcx).unwrap()\n+        dcx.decode()\n     })\n }\n \n-fn get_explicit_self<'a, 'tcx>(item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+fn get_explicit_self<'a, 'tcx>(cdata: Cmd, item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                -> ty::ExplicitSelfCategory<'tcx> {\n-    fn get_mutability(ch: u8) -> hir::Mutability {\n-        match ch as char {\n-            'i' => hir::MutImmutable,\n-            'm' => hir::MutMutable,\n-            _ => bug!(\"unknown mutability character: `{}`\", ch as char),\n-        }\n-    }\n+    let mut dcx = item.get(tag_item_trait_method_explicit_self).decoder();\n+    dcx.cdata = Some(cdata);\n+    dcx.tcx = Some(tcx);\n \n-    let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n-    let string = explicit_self_doc.as_str();\n-\n-    let explicit_self_kind = string.as_bytes()[0];\n-    match explicit_self_kind as char {\n-        's' => ty::ExplicitSelfCategory::Static,\n-        'v' => ty::ExplicitSelfCategory::ByValue,\n-        '~' => ty::ExplicitSelfCategory::ByBox,\n-        // FIXME(#4846) expl. region\n-        '&' => {\n-            ty::ExplicitSelfCategory::ByReference(\n-                tcx.mk_region(ty::ReEmpty),\n-                get_mutability(string.as_bytes()[1]))\n-        }\n-        _ => bug!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n-    }\n+    dcx.decode()\n }\n \n /// Returns the def IDs of all the items in the given implementation.\n-pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n-                      -> Vec<ty::ImplOrTraitItemId> {\n-    reader::tagged_docs(cdata.lookup_item(impl_id), tag_item_impl_item).map(|doc| {\n-        let def_id = item_def_id(doc, cdata);\n-        match item_sort(doc) {\n-            Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n-            Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n-            Some('t') => ty::TypeTraitItemId(def_id),\n-            _ => bug!(\"unknown impl item sort\"),\n+pub fn get_impl_or_trait_items(cdata: Cmd, impl_id: DefIndex)\n+                               -> Vec<ty::ImplOrTraitItemId> {\n+    let item = cdata.lookup_item(impl_id);\n+    let mut dcx = item.get(tag_mod_children).decoder();\n+    dcx.cdata = Some(cdata);\n+    dcx.seq().map(|def_id: DefId| {\n+        match item_to_def(cdata, cdata.lookup_item(def_id.index), def_id) {\n+            Some(Def::AssociatedConst(def_id)) => ty::ConstTraitItemId(def_id),\n+            Some(Def::Method(def_id)) => ty::MethodTraitItemId(def_id),\n+            Some(Def::AssociatedTy(_, def_id)) => ty::TypeTraitItemId(def_id),\n+            def => bug!(\"get_impl_or_trait_items: invalid def {:?}\", def)\n         }\n     }).collect()\n }\n@@ -1092,8 +887,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n     } else {\n         return None;\n     };\n-    let container_doc = cdata.lookup_item(container_id.index);\n-    let container = match item_family(container_doc) {\n+    let container = match item_family(cdata.lookup_item(container_id.index)) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n     };\n@@ -1102,8 +896,8 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n     let vis = item_visibility(item_doc);\n     let defaultness = item_defaultness(item_doc);\n \n-    Some(match item_sort(item_doc) {\n-        sort @ Some('C') | sort @ Some('c') => {\n+    Some(match item_family(item_doc) {\n+        Family::AssociatedConst => {\n             let ty = doc_type(item_doc, tcx, cdata);\n             ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n                 name: name,\n@@ -1112,10 +906,10 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                 defaultness: defaultness,\n                 def_id: def_id,\n                 container: container,\n-                has_value: sort == Some('C')\n+                has_value: item_doc.get(tag_item_trait_item_has_body).decoder().decode(),\n             }))\n         }\n-        Some('r') | Some('p') => {\n+        Family::Method => {\n             let generics = doc_generics(item_doc, tcx, cdata);\n             let predicates = doc_predicates(item_doc, tcx, cdata, tag_item_predicates);\n             let ity = tcx.lookup_item_type(def_id).ty;\n@@ -1125,19 +919,22 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name)\n             };\n-            let explicit_self = get_explicit_self(item_doc, tcx);\n-\n-            ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n-                                                        generics,\n-                                                        predicates,\n-                                                        fty,\n-                                                        explicit_self,\n-                                                        vis,\n-                                                        defaultness,\n-                                                        def_id,\n-                                                        container)))\n+            let explicit_self = get_explicit_self(cdata, item_doc, tcx);\n+\n+            ty::MethodTraitItem(Rc::new(ty::Method {\n+                name: name,\n+                generics: generics,\n+                predicates: predicates,\n+                fty: fty,\n+                explicit_self: explicit_self,\n+                vis: vis,\n+                defaultness: defaultness,\n+                has_body: item_doc.get(tag_item_trait_item_has_body).decoder().decode(),\n+                def_id: def_id,\n+                container: container,\n+            }))\n         }\n-        Some('t') => {\n+        Family::AssociatedType => {\n             let ty = maybe_doc_type(item_doc, tcx, cdata);\n             ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n                 name: name,\n@@ -1152,84 +949,19 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n     })\n }\n \n-pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n-                              -> Vec<ty::ImplOrTraitItemId> {\n-    let item = cdata.lookup_item(id);\n-    reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n-        let def_id = item_def_id(mth, cdata);\n-        match item_sort(mth) {\n-            Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n-            Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n-            Some('t') => ty::TypeTraitItemId(def_id),\n-            _ => bug!(\"unknown trait item sort\"),\n-        }\n-    }).collect()\n-}\n-\n pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n     let item_doc = cdata.lookup_item(id);\n-    let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n-    Decodable::decode(&mut variance_doc.decoder()).unwrap()\n-}\n-\n-pub fn get_provided_trait_methods<'a, 'tcx>(cdata: Cmd,\n-                                            id: DefIndex,\n-                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                            -> Vec<Rc<ty::Method<'tcx>>> {\n-    let item = cdata.lookup_item(id);\n-\n-    reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n-        let did = item_def_id(mth_id, cdata);\n-        let mth = cdata.lookup_item(did.index);\n-\n-        if item_sort(mth) == Some('p') {\n-            let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n-            if let Some(ty::MethodTraitItem(ref method)) = trait_item {\n-                Some((*method).clone())\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }).collect()\n-}\n-\n-pub fn get_associated_consts<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                       -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n-    let item = cdata.lookup_item(id);\n-\n-    [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n-        reader::tagged_docs(item, tag).filter_map(|ac_id| {\n-            let did = item_def_id(ac_id, cdata);\n-            let ac_doc = cdata.lookup_item(did.index);\n-\n-            match item_sort(ac_doc) {\n-                Some('C') | Some('c') => {\n-                    let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n-                    if let Some(ty::ConstTraitItem(ref ac)) = trait_item {\n-                        Some((*ac).clone())\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None\n-            }\n-        })\n-    }).collect()\n-}\n-\n-pub fn get_variant_kind(cdata: Cmd, node_id: DefIndex) -> Option<VariantKind>\n-{\n-    let item = cdata.lookup_item(node_id);\n-    family_to_variant_kind(item_family(item))\n+    item_doc.get(tag_item_variances).decoder().decode()\n }\n \n pub fn get_struct_ctor_def_id(cdata: Cmd, node_id: DefIndex) -> Option<DefId>\n {\n     let item = cdata.lookup_item(node_id);\n-    reader::maybe_get_doc(item, tag_items_data_item_struct_ctor).\n-        map(|ctor_doc| translated_def_id(cdata, ctor_doc))\n+    reader::maybe_get_doc(item, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n+        let mut dcx = ctor_doc.decoder();\n+        dcx.cdata = Some(cdata);\n+        dcx.decode()\n+    })\n }\n \n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n@@ -1239,8 +971,12 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     -> Option<DefId>\n {\n     let item = cdata.lookup_item(node_id);\n-    reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor).next().map(|_| {\n-        item_require_parent_item(cdata, item)\n+    reader::maybe_get_doc(item, tag_items_data_item_is_tuple_struct_ctor).and_then(|doc| {\n+        if doc.decoder().decode() {\n+            Some(item_require_parent_item(cdata, item))\n+        } else {\n+            None\n+        }\n     })\n }\n \n@@ -1256,39 +992,18 @@ pub fn get_item_attrs(cdata: Cmd,\n     get_attributes(item)\n }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n-    let data = rbml::Doc::new(cdata.data());\n-    let fields = reader::get_doc(data, tag_struct_fields);\n-    reader::tagged_docs(fields, tag_struct_field).map(|field| {\n-        let def_id = translated_def_id(cdata, reader::get_doc(field, tag_def_id));\n-        let attrs = get_attributes(field);\n-        (def_id, attrs)\n-    }).collect()\n-}\n-\n-fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n-    match family {\n-        PublicField => ty::Visibility::Public,\n-        InheritedField => ty::Visibility::PrivateExternal,\n-        _ => bug!()\n-    }\n-}\n-\n pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n-    let item = cdata.lookup_item(id);\n-    let mut index = 0;\n-    reader::tagged_docs(item, tag_item_field).map(|an_item| {\n-        item_name(an_item)\n-    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n-        let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n-        index += 1;\n-        name\n-    })).collect()\n+    let mut dcx = cdata.lookup_item(id).get(tag_item_fields).decoder();\n+    dcx.cdata = Some(cdata);\n+\n+    dcx.seq().map(|did: DefId| {\n+        item_name(cdata.lookup_item(did.index))\n+    }).collect()\n }\n \n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n     reader::maybe_get_doc(md, tag_attributes).map_or(vec![], |attrs_doc| {\n-        let mut attrs = Vec::<ast::Attribute>::decode(&mut attrs_doc.decoder()).unwrap();\n+        let mut attrs = attrs_doc.decoder().decode::<Vec<ast::Attribute>>();\n \n         // Need new unique IDs: old thread-local IDs won't map to new threads.\n         for attr in attrs.iter_mut() {\n@@ -1299,22 +1014,6 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n     })\n }\n \n-fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n-                         out: &mut io::Write) -> io::Result<()> {\n-    write!(out, \"=Crate Attributes ({})=\\n\", *hash)?;\n-\n-    let r = get_attributes(md);\n-    for attr in &r {\n-        write!(out, \"{}\\n\", pprust::attribute_to_string(attr))?;\n-    }\n-\n-    write!(out, \"\\n\\n\")\n-}\n-\n-pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n-    get_attributes(rbml::Doc::new(data))\n-}\n-\n #[derive(Clone)]\n pub struct CrateDep {\n     pub cnum: CrateNum,\n@@ -1324,19 +1023,9 @@ pub struct CrateDep {\n }\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n-    let cratedoc = rbml::Doc::new(data);\n-    let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n+    let dcx = rbml::Doc::new(data).get(tag_crate_deps).decoder();\n \n-    fn docstr(doc: rbml::Doc, tag_: usize) -> String {\n-        let d = reader::get_doc(doc, tag_);\n-        d.as_str().to_string()\n-    }\n-\n-    reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n-        let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(reader::doc_as_u64(reader::get_doc(depdoc, tag_crate_dep_hash)));\n-        let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n-        let explicitly_linked = reader::doc_as_u8(doc) != 0;\n+    dcx.seq().enumerate().map(|(crate_num, (name, hash, explicitly_linked))| {\n         CrateDep {\n             cnum: CrateNum::new(crate_num + 1),\n             name: name,\n@@ -1358,63 +1047,39 @@ fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n-        Svh::new(reader::doc_as_u64(doc))\n+        doc.decoder().decode()\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    let cratedoc = rbml::Doc::new(data);\n-    let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    Svh::new(reader::doc_as_u64(hashdoc))\n+    rbml::Doc::new(data).get(tag_crate_hash).decoder().decode()\n }\n \n-pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {\n+pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n-        doc.as_str()\n+        doc.decoder().decode()\n     })\n }\n \n-pub fn get_crate_disambiguator<'a>(data: &'a [u8]) -> &'a str {\n-    let crate_doc = rbml::Doc::new(data);\n-    let disambiguator_doc = reader::get_doc(crate_doc, tag_crate_disambiguator);\n-    let slice: &'a str = disambiguator_doc.as_str();\n-    slice\n+pub fn get_crate_disambiguator(data: &[u8]) -> String {\n+    rbml::Doc::new(data).get(tag_crate_disambiguator).decoder().decode()\n }\n \n pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n     let cratedoc = rbml::Doc::new(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n-    triple_doc.map(|s| s.as_str().to_string())\n+    triple_doc.map(|s| s.decoder().decode())\n }\n \n-pub fn get_crate_name(data: &[u8]) -> &str {\n+pub fn get_crate_name(data: &[u8]) -> String {\n     maybe_get_crate_name(data).expect(\"no crate name in crate\")\n }\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()> {\n-    let hash = get_crate_hash(bytes);\n-    let md = rbml::Doc::new(bytes);\n-    list_crate_attributes(md, &hash, out)?;\n     list_crate_deps(bytes, out)\n }\n \n-// Translates a def_id from an external crate to a def_id for the current\n-// compilation environment. We use this when trying to load types from\n-// external crates - if those types further refer to types in other crates\n-// then we must translate the crate number from that encoded in the external\n-// crate to the correct local crate number.\n-pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n-    if did.is_local() {\n-        return DefId { krate: cdata.cnum, index: did.index };\n-    }\n-\n-    DefId {\n-        krate: cdata.cnum_map.borrow()[did.krate],\n-        index: did.index\n-    }\n-}\n-\n // Translate a DefId from the current compilation environment to a DefId\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n@@ -1433,32 +1098,41 @@ pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n     where F: FnMut(DefId),\n {\n     let item_doc = cdata.lookup_item(id);\n-    for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl) {\n-        if reader::maybe_get_doc(impl_doc, tag_item_trait_ref).is_none() {\n-            callback(item_def_id(impl_doc, cdata));\n-        }\n+    let mut dcx = item_doc.get(tag_items_data_item_inherent_impls).decoder();\n+    dcx.cdata = Some(cdata);\n+\n+    for impl_def_id in dcx.seq() {\n+        callback(impl_def_id);\n     }\n }\n \n pub fn each_implementation_for_trait<F>(cdata: Cmd,\n-                                        def_id: DefId,\n+                                        filter: Option<DefId>,\n                                         mut callback: F) where\n     F: FnMut(DefId),\n {\n     // Do a reverse lookup beforehand to avoid touching the crate_num\n     // hash map in the loop below.\n-    if let Some(crate_local_did) = reverse_translate_def_id(cdata, def_id) {\n-        let def_id_u64 = def_to_u64(crate_local_did);\n+    let filter = match filter.map(|def_id| reverse_translate_def_id(cdata, def_id)) {\n+        Some(Some(def_id)) => Some(def_id),\n+        Some(None) => return,\n+        None => None\n+    };\n+\n+    // FIXME(eddyb) Make this O(1) instead of O(n).\n+    for trait_doc in rbml::Doc::new(cdata.data()).get(tag_impls).children() {\n+        let mut dcx = trait_doc.decoder();\n+        dcx.cdata = Some(cdata);\n \n-        let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-        for trait_doc in reader::tagged_docs(impls_doc, tag_impls_trait) {\n-            let trait_def_id = reader::get_doc(trait_doc, tag_def_id);\n-            if reader::doc_as_u64(trait_def_id) != def_id_u64 {\n+        let (krate, index) = dcx.decode();\n+        if let Some(local_did) = filter {\n+            if (local_did.krate.as_u32(), local_did.index) != (krate, index) {\n                 continue;\n             }\n-            for impl_doc in reader::tagged_docs(trait_doc, tag_impls_trait_impl) {\n-                callback(translated_def_id(cdata, impl_doc));\n-            }\n+        }\n+\n+        for impl_def_id in dcx.seq() {\n+            callback(impl_def_id);\n         }\n     }\n }\n@@ -1479,120 +1153,73 @@ pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n \n pub fn get_native_libraries(cdata: Cmd)\n                             -> Vec<(cstore::NativeLibraryKind, String)> {\n-    let libraries = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                    tag_native_libraries);\n-    reader::tagged_docs(libraries, tag_native_libraries_lib).map(|lib_doc| {\n-        let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n-        let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n-        let kind: cstore::NativeLibraryKind =\n-            cstore::NativeLibraryKind::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n-        let name = name_doc.as_str().to_string();\n-        (kind, name)\n-    }).collect()\n+    rbml::Doc::new(cdata.data()).get(tag_native_libraries).decoder().decode()\n }\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n+        .map(|doc| doc.decoder().decode())\n }\n \n pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n {\n-    let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n-    for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n-        let name = item_name(macro_doc);\n-        let attrs = get_attributes(macro_doc);\n-        let span = get_macro_span(macro_doc);\n-        let body = reader::get_doc(macro_doc, tag_macro_def_body);\n-        if !f(name, attrs, span, body.as_str().to_string()) {\n+    let dcx = rbml::Doc::new(data).get(tag_macro_defs).decoder();\n+    for (name, attrs, span, body) in dcx.seq() {\n+        if !f(name, attrs, span, body) {\n             break;\n         }\n     }\n }\n \n pub fn get_derive_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_macro_derive_registrar)\n-        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n-}\n-\n-pub fn get_macro_span(doc: rbml::Doc) -> Span {\n-    let lo_doc = reader::get_doc(doc, tag_macro_def_span_lo);\n-    let lo = BytePos(reader::doc_as_u32(lo_doc));\n-    let hi_doc = reader::get_doc(doc, tag_macro_def_span_hi);\n-    let hi = BytePos(reader::doc_as_u32(hi_doc));\n-    return Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n+        .map(|doc| doc.decoder().decode())\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(CrateNum, LinkagePreference)>\n {\n-    let formats = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                  tag_dylib_dependency_formats);\n-    let mut result = Vec::new();\n-\n-    debug!(\"found dylib deps: {}\", formats.as_str());\n-    for spec in formats.as_str().split(',') {\n-        if spec.is_empty() { continue }\n-        let mut split = spec.split(':');\n-        let cnum = split.next().unwrap();\n-        let link = split.next().unwrap();\n-        let cnum = CrateNum::new(cnum.parse().unwrap());\n-        let cnum = cdata.cnum_map.borrow()[cnum];\n-        result.push((cnum, if link == \"d\" {\n-            LinkagePreference::RequireDynamic\n-        } else {\n-            LinkagePreference::RequireStatic\n-        }));\n-    }\n-    return result;\n-}\n+    let dcx = rbml::Doc::new(cdata.data()).get(tag_dylib_dependency_formats).decoder();\n \n-pub fn get_missing_lang_items(cdata: Cmd)\n-    -> Vec<lang_items::LangItem>\n-{\n-    let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_lang_items);\n-    reader::tagged_docs(items, tag_lang_items_missing).map(|missing_docs| {\n-        lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap()\n+    dcx.seq::<Option<_>>().enumerate().flat_map(|(i, link)| {\n+        let cnum = CrateNum::new(i + 1);\n+        link.map(|link| (cdata.cnum_map.borrow()[cnum], link))\n     }).collect()\n }\n \n+pub fn get_missing_lang_items(cdata: Cmd) -> Vec<lang_items::LangItem> {\n+    rbml::Doc::new(cdata.data()).get(tag_lang_items_missing).decoder().decode()\n+}\n+\n pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n     let method_doc = cdata.lookup_item(id);\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n-        Some(args_doc) => {\n-            reader::tagged_docs(args_doc, tag_method_argument_name).map(|name_doc| {\n-                name_doc.as_str().to_string()\n-            }).collect()\n-        },\n+        Some(args_doc) => args_doc.decoder().decode(),\n         None => vec![],\n     }\n }\n \n pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n-    let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                tag_reachable_ids);\n-    reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n+    let dcx = rbml::Doc::new(cdata.data()).get(tag_reachable_ids).decoder();\n+\n+    dcx.seq().map(|index| {\n         DefId {\n             krate: cdata.cnum,\n-            index: DefIndex::from_u32(reader::doc_as_u32(doc)),\n+            index: index,\n         }\n     }).collect()\n }\n \n-pub fn is_typedef(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    match item_family(item_doc) {\n-        Type => true,\n-        _ => false,\n-    }\n-}\n-\n pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    match fn_constness(item_doc) {\n-        hir::Constness::Const => true,\n-        hir::Constness::NotConst => false,\n+    match reader::maybe_get_doc(cdata.lookup_item(id), tag_items_data_item_constness) {\n+        None => false,\n+        Some(doc) => {\n+            match doc.decoder().decode() {\n+                hir::Constness::Const => true,\n+                hir::Constness::NotConst => false,\n+            }\n+        }\n     }\n }\n \n@@ -1628,40 +1255,15 @@ pub fn is_foreign_item(cdata: Cmd, id: DefIndex) -> bool {\n     item_family(parent_item_doc) == ForeignMod\n }\n \n-pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    match item_family(item_doc) {\n-        Impl => true,\n-        _ => false,\n-    }\n-}\n-\n fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           cdata: Cmd)\n                           -> &'tcx ty::Generics<'tcx>\n {\n-    let mut dcx = reader::get_doc(base_doc, tag_item_generics).decoder();\n-    dcx.tcx = Some(tcx);\n-    dcx.cdata = Some(cdata);\n-    tcx.alloc_generics(Decodable::decode(&mut dcx).unwrap())\n-}\n-\n-fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n-                           doc: rbml::Doc,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                           -> ty::Predicate<'tcx>\n-{\n-    let predicate_pos = cdata.xref_index.lookup(\n-        cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n-    let mut dcx = rbml::Doc {\n-        data: cdata.data(),\n-        start: predicate_pos,\n-        end: cdata.data().len(),\n-    }.decoder();\n+    let mut dcx = base_doc.get(tag_item_generics).decoder();\n     dcx.tcx = Some(tcx);\n     dcx.cdata = Some(cdata);\n-    Decodable::decode(&mut dcx).unwrap()\n+    tcx.alloc_generics(dcx.decode())\n }\n \n fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n@@ -1670,51 +1272,50 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n                             tag: usize)\n                             -> ty::GenericPredicates<'tcx>\n {\n-    let doc = reader::get_doc(base_doc, tag);\n+    let mut dcx = base_doc.get(tag).decoder();\n+    dcx.cdata = Some(cdata);\n \n     ty::GenericPredicates {\n-        parent: item_parent_item(cdata, doc),\n-        predicates: reader::tagged_docs(doc, tag_predicate).map(|predicate_doc| {\n-            doc_predicate(cdata, predicate_doc, tcx)\n+        parent: dcx.decode(),\n+        predicates: dcx.seq().map(|offset| {\n+            let predicate_pos = cdata.xref_index.lookup(\n+                cdata.data(), offset).unwrap() as usize;\n+            let mut dcx = rbml::Doc {\n+                data: cdata.data(),\n+                start: predicate_pos,\n+                end: cdata.data().len(),\n+            }.decoder();\n+            dcx.tcx = Some(tcx);\n+            dcx.cdata = Some(cdata);\n+            dcx.decode()\n         }).collect()\n     }\n }\n \n pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n-    let trait_doc = cdata.lookup_item(trait_id);\n-    assert!(item_family(trait_doc) == Family::Trait);\n-    let defaulted_doc = reader::get_doc(trait_doc, tag_defaulted_trait);\n-    reader::doc_as_u8(defaulted_doc) != 0\n+    cdata.lookup_item(trait_id).get(tag_defaulted_trait).decoder().decode()\n }\n \n pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n-    let impl_doc = cdata.lookup_item(impl_id);\n-    item_family(impl_doc) == Family::DefaultImpl\n+    item_family(cdata.lookup_item(impl_id)) == Family::DefaultImpl\n }\n \n pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n-    let crate_doc = rbml::Doc::new(metadata);\n-    let cm_doc = reader::get_doc(crate_doc, tag_codemap);\n-\n-    reader::tagged_docs(cm_doc, tag_codemap_filemap).map(|filemap_doc| {\n-        Decodable::decode(&mut filemap_doc.decoder()).unwrap()\n-    }).collect()\n+    rbml::Doc::new(metadata).get(tag_codemap).decoder().decode()\n }\n \n pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n-    let closure_doc = cdata.lookup_item(closure_id);\n-    let closure_kind_doc = reader::get_doc(closure_doc, tag_items_closure_kind);\n-    ty::ClosureKind::decode(&mut closure_kind_doc.decoder()).unwrap()\n+    cdata.lookup_item(closure_id).get(tag_items_closure_kind).decoder().decode()\n }\n \n pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                             -> ty::ClosureTy<'tcx> {\n     let closure_doc = cdata.lookup_item(closure_id);\n-    let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n+    let closure_ty_doc = closure_doc.get(tag_items_closure_ty);\n     let mut dcx = closure_ty_doc.decoder();\n     dcx.tcx = Some(tcx);\n     dcx.cdata = Some(cdata);\n-    Decodable::decode(&mut dcx).unwrap()\n+    dcx.decode()\n }\n \n pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n@@ -1726,10 +1327,8 @@ pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n     match reader::maybe_get_doc(item_doc, tag_def_key) {\n         Some(def_key_doc) => {\n-            let simple_key = def_key::DefKey::decode(&mut def_key_doc.decoder()).unwrap();\n-            let name = reader::maybe_get_doc(item_doc, tag_paths_data_name).map(|name| {\n-                token::intern(name.as_str()).as_str()\n-            });\n+            let simple_key = def_key_doc.decoder().decode();\n+            let name = maybe_item_name(item_doc).map(|name| name.as_str());\n             def_key::recover_def_key(simple_key, name)\n         }\n         None => {\n@@ -1753,11 +1352,5 @@ pub fn def_path(cdata: Cmd, id: DefIndex) -> Option<hir_map::DefPath> {\n }\n \n pub fn get_panic_strategy(data: &[u8]) -> PanicStrategy {\n-    let crate_doc = rbml::Doc::new(data);\n-    let strat_doc = reader::get_doc(crate_doc, tag_panic_strategy);\n-    match reader::doc_as_u8(strat_doc) {\n-        b'U' => PanicStrategy::Unwind,\n-        b'A' => PanicStrategy::Abort,\n-        b => panic!(\"unknown panic strategy in metadata: {}\", b),\n-    }\n+    rbml::Doc::new(data).get(tag_panic_strategy).decoder().decode()\n }"}, {"sha": "7b4a6972d221be6241c52074d922db396b68ca89", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 374, "deletions": 566, "changes": 940, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -20,52 +20,56 @@ use decoder;\n use def_key;\n use index::{self, IndexData};\n \n-use middle::cstore::{InlinedItemRef, LinkMeta};\n+use middle::cstore::{InlinedItemRef, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use rustc::dep_graph::DepNode;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n-use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n+use rustc::session::config::{self, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n-use rustc_serialize as serialize;\n use std::cell::RefCell;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n+use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID};\n use syntax::attr;\n use syntax;\n-use syntax_pos::BytePos;\n use rbml;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n use rustc::hir::map::DefKey;\n \n-use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, Untracked, XRef};\n+use super::index_builder::{FromId, IndexBuilder, Untracked};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     rbml_w: rbml::writer::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     reexports: &'a def::ExportMap,\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n-    type_shorthands: RefCell<FnvHashMap<Ty<'tcx>, usize>>,\n     reachable: &'a NodeSet,\n     mir_map: &'a MirMap<'tcx>,\n+\n+    type_shorthands: RefCell<FnvHashMap<Ty<'tcx>, usize>>,\n+    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n }\n \n+/// \"interned\" entries referenced by id\n+#[derive(PartialEq, Eq, Hash)]\n+enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n+\n impl<'a, 'tcx> Deref for EncodeContext<'a, 'tcx> {\n     type Target = rbml::writer::Encoder<'a>;\n     fn deref(&self) -> &Self::Target {\n@@ -87,8 +91,8 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'a, 'tcx> serialize::Encoder for ::encoder::EncodeContext<'a, 'tcx> {\n-    type Error = <opaque::Encoder<'a> as serialize::Encoder>::Error;\n+impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n+    type Error = <opaque::Encoder<'a> as Encoder>::Error;\n \n     fn emit_nil(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n@@ -146,12 +150,35 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    fn seq<I, F, T>(&mut self, iter: I, mut f: F)\n+    where I: IntoIterator,\n+          I::IntoIter: ExactSizeIterator,\n+          F: FnMut(&mut Self, I::Item) -> T,\n+          T: Encodable {\n+        let iter = iter.into_iter();\n+        self.emit_seq(iter.len(), move |ecx| {\n+            for (i, elem) in iter.enumerate() {\n+                ecx.emit_seq_elt(i, |ecx| {\n+                    f(ecx, elem).encode(ecx)\n+                })?;\n+            }\n+            Ok(())\n+        }).unwrap();\n+    }\n+}\n+\n fn encode_name(ecx: &mut EncodeContext, name: Name) {\n-    ecx.wr_tagged_str(tag_paths_data_name, &name.as_str());\n+    ecx.start_tag(tag_paths_data_name);\n+    name.encode(ecx).unwrap();\n+    ecx.end_tag();\n }\n \n-fn encode_def_id(ecx: &mut EncodeContext, id: DefId) {\n-    ecx.wr_tagged_u64(tag_def_id, def_to_u64(id));\n+fn encode_def_id(ecx: &mut EncodeContext, def_id: DefId) {\n+    assert!(def_id.is_local());\n+    ecx.start_tag(tag_def_index);\n+    def_id.index.encode(ecx).unwrap();\n+    ecx.end_tag();\n }\n \n fn encode_def_key(ecx: &mut EncodeContext, key: DefKey) {\n@@ -178,16 +205,10 @@ fn encode_trait_ref<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n }\n \n // Item info table encoding\n-fn encode_family(ecx: &mut EncodeContext, c: char) {\n-    ecx.wr_tagged_u8(tag_items_data_item_family, c as u8);\n-}\n-\n-pub fn def_to_u64(did: DefId) -> u64 {\n-    (did.krate.as_u32() as u64) << 32 | (did.index.as_u32() as u64)\n-}\n-\n-pub fn def_to_string(_tcx: TyCtxt, did: DefId) -> String {\n-    format!(\"{}:{}\", did.krate, did.index.as_usize())\n+fn encode_family(ecx: &mut EncodeContext, f: Family) {\n+    ecx.start_tag(tag_items_data_item_family);\n+    f.encode(ecx).unwrap();\n+    ecx.end_tag();\n }\n \n fn encode_item_variances(ecx: &mut EncodeContext, id: NodeId) {\n@@ -197,7 +218,7 @@ fn encode_item_variances(ecx: &mut EncodeContext, id: NodeId) {\n     ecx.end_tag();\n }\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_bounds_and_type_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n         self.encode_bounds_and_type(&tcx.lookup_item_type(def_id),\n@@ -210,44 +231,31 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         self.encode_generics(&scheme.generics, &predicates);\n         self.encode_type(scheme.ty);\n     }\n-}\n-\n-fn encode_variant_id(ecx: &mut EncodeContext, vid: DefId) {\n-    let id = def_to_u64(vid);\n-    ecx.wr_tagged_u64(tag_items_data_item_variant, id);\n-    ecx.wr_tagged_u64(tag_mod_child, id);\n-}\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_type(&mut self, typ: Ty<'tcx>) {\n         self.start_tag(tag_items_data_item_type);\n-        typ.encode(self.ecx).unwrap();\n+        typ.encode(self).unwrap();\n         self.end_tag();\n     }\n \n     fn encode_disr_val(&mut self,\n                        disr_val: ty::Disr) {\n-        // convert to u64 so just the number is printed, without any type info\n-        self.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n+        self.start_tag(tag_disr_val);\n+        disr_val.to_u64_unchecked().encode(self).unwrap();\n+        self.end_tag();\n     }\n \n     fn encode_parent_item(&mut self, id: DefId) {\n-        self.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n+        self.start_tag(tag_items_data_parent_item);\n+        id.encode(self).unwrap();\n+        self.end_tag();\n     }\n \n-    fn encode_struct_fields(&mut self,\n-                            variant: ty::VariantDef) {\n-        for f in &variant.fields {\n-            if variant.kind == ty::VariantKind::Tuple {\n-                self.start_tag(tag_item_unnamed_field);\n-            } else {\n-                self.start_tag(tag_item_field);\n-                encode_name(self, f.name);\n-            }\n-            self.encode_struct_field_family(f.vis);\n-            encode_def_id(self, f.did);\n-            self.end_tag();\n-        }\n+    fn encode_variant_fields(&mut self,\n+                             variant: ty::VariantDef) {\n+        self.start_tag(tag_item_fields);\n+        self.seq(&variant.fields, |_, f| f.did);\n+        self.end_tag();\n     }\n }\n \n@@ -258,13 +266,13 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         self.encode_fields(enum_did);\n         for (i, variant) in def.variants.iter().enumerate() {\n             self.record(variant.did,\n-                        ItemContentBuilder::encode_enum_variant_info,\n+                        EncodeContext::encode_enum_variant_info,\n                         (enum_did, Untracked(i)));\n         }\n     }\n }\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Encode data for the given variant of the given ADT. The\n     /// index of the variant is untracked: this is ok because we\n     /// will have to lookup the adt-def by its id, and that gives us\n@@ -278,11 +286,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         let variant = &def.variants[index];\n         let vid = variant.did;\n         encode_def_id_and_key(self, vid);\n-        encode_family(self, match variant.kind {\n-            ty::VariantKind::Struct => 'V',\n-            ty::VariantKind::Tuple => 'v',\n-            ty::VariantKind::Unit => 'w',\n-        });\n+        encode_family(self, Family::Variant(variant.kind));\n         encode_name(self, variant.name);\n         self.encode_parent_item(enum_did);\n \n@@ -299,51 +303,35 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_stability(self, stab);\n         encode_deprecation(self, depr);\n \n-        self.encode_struct_fields(variant);\n+        self.encode_variant_fields(variant);\n         self.encode_disr_val(variant.disr_val);\n         self.encode_bounds_and_type_for_item(vid);\n     }\n }\n \n-fn encode_reexports(ecx: &mut EncodeContext, id: NodeId) {\n-    debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    match ecx.reexports.get(&id) {\n-        Some(exports) => {\n-            debug!(\"(encoding info for module) found reexports for {}\", id);\n-            for exp in exports {\n-                debug!(\"(encoding info for module) reexport '{}' ({:?}) for \\\n-                        {}\",\n-                       exp.name,\n-                       exp.def_id,\n-                       id);\n-                ecx.start_tag(tag_items_data_item_reexport);\n-                ecx.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n-                                  def_to_u64(exp.def_id));\n-                ecx.wr_tagged_str(tag_items_data_item_reexport_name,\n-                                  &exp.name.as_str());\n-                ecx.end_tag();\n-            }\n-        },\n-        None => debug!(\"(encoding info for module) found no reexports for {}\", id),\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_mod(&mut self,\n                            FromId(id, (md, attrs, name, vis)):\n                            FromId<(&hir::Mod, &[ast::Attribute], Name, &hir::Visibility)>) {\n         let tcx = self.tcx;\n \n         encode_def_id_and_key(self, tcx.map.local_def_id(id));\n-        encode_family(self, 'm');\n+        encode_family(self, Family::Mod);\n         encode_name(self, name);\n         debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n         // Encode info about all the module children.\n-        for item_id in &md.item_ids {\n-            self.wr_tagged_u64(tag_mod_child,\n-                               def_to_u64(tcx.map.local_def_id(item_id.id)));\n+        self.start_tag(tag_mod_children);\n+        self.seq(&md.item_ids, |_, item_id| {\n+            tcx.map.local_def_id(item_id.id)\n+        });\n+\n+        // Encode the reexports of this module, if this module is public.\n+        match self.reexports.get(&id) {\n+            Some(exports) if *vis == hir::Public => exports.encode(self).unwrap(),\n+            _ => <[def::Export]>::encode(&[], self).unwrap()\n         }\n+        self.end_tag();\n \n         self.encode_visibility(vis);\n \n@@ -352,22 +340,27 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_stability(self, stab);\n         encode_deprecation(self, depr);\n \n-        // Encode the reexports of this module, if this module is public.\n-        if *vis == hir::Public {\n-            debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-            encode_reexports(self, id);\n-        }\n         encode_attributes(self, attrs);\n     }\n \n     fn encode_struct_field_family(&mut self,\n                                   visibility: ty::Visibility) {\n-        encode_family(self, if visibility.is_public() { 'g' } else { 'N' });\n+        encode_family(self, if visibility.is_public() {\n+            Family::PublicField\n+        } else {\n+            Family::InheritedField\n+        });\n     }\n \n     fn encode_visibility<T: HasVisibility>(&mut self, visibility: T) {\n-        let ch = if visibility.is_public() { 'y' } else { 'i' };\n-        self.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+        let vis = if visibility.is_public() {\n+            ty::Visibility::Public\n+        } else {\n+            ty::Visibility::PrivateExternal\n+        };\n+        self.start_tag(tag_items_data_item_visibility);\n+        vis.encode(self).unwrap();\n+        self.end_tag();\n     }\n }\n \n@@ -389,54 +382,14 @@ impl HasVisibility for ty::Visibility {\n \n fn encode_constness(ecx: &mut EncodeContext, constness: hir::Constness) {\n     ecx.start_tag(tag_items_data_item_constness);\n-    let ch = match constness {\n-        hir::Constness::Const => 'c',\n-        hir::Constness::NotConst => 'n',\n-    };\n-    ecx.wr_str(&ch.to_string());\n+    constness.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n fn encode_defaultness(ecx: &mut EncodeContext, defaultness: hir::Defaultness) {\n-    let ch = match defaultness {\n-        hir::Defaultness::Default => 'd',\n-        hir::Defaultness::Final => 'f',\n-    };\n-    ecx.wr_tagged_u8(tag_items_data_item_defaultness, ch as u8);\n-}\n-\n-fn encode_explicit_self(ecx: &mut EncodeContext,\n-                        explicit_self: &ty::ExplicitSelfCategory) {\n-    let tag = tag_item_trait_method_explicit_self;\n-\n-    // Encode the base self type.\n-    match *explicit_self {\n-        ty::ExplicitSelfCategory::Static => {\n-            ecx.wr_tagged_bytes(tag, &['s' as u8]);\n-        }\n-        ty::ExplicitSelfCategory::ByValue => {\n-            ecx.wr_tagged_bytes(tag, &['v' as u8]);\n-        }\n-        ty::ExplicitSelfCategory::ByBox => {\n-            ecx.wr_tagged_bytes(tag, &['~' as u8]);\n-        }\n-        ty::ExplicitSelfCategory::ByReference(_, m) => {\n-            // FIXME(#4846) encode custom lifetime\n-            let ch = encode_mutability(m);\n-            ecx.wr_tagged_bytes(tag, &['&' as u8, ch]);\n-        }\n-    }\n-\n-    fn encode_mutability(m: hir::Mutability) -> u8 {\n-        match m {\n-            hir::MutImmutable => 'i' as u8,\n-            hir::MutMutable => 'm' as u8,\n-        }\n-    }\n-}\n-\n-fn encode_item_sort(ecx: &mut EncodeContext, sort: char) {\n-    ecx.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n+    ecx.start_tag(tag_items_data_item_defaultness);\n+    defaultness.encode(ecx).unwrap();\n+    ecx.end_tag();\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -446,14 +399,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n-                            ItemContentBuilder::encode_field,\n+                            EncodeContext::encode_field,\n                             (adt_def_id, Untracked((variant_index, field_index))));\n             }\n         }\n     }\n }\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Encode data for the given field of the given variant of the\n     /// given ADT. The indices of the variant/field are untracked:\n     /// this is ok because we will have to lookup the adt-def by its\n@@ -476,6 +429,10 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         self.encode_bounds_and_type_for_item(field.did);\n         encode_def_id_and_key(self, field.did);\n \n+        let variant_id = tcx.map.as_local_node_id(variant.did).unwrap();\n+        let variant_data = tcx.map.expect_variant_data(variant_id);\n+        encode_attributes(self, &variant_data.fields()[field_index].attrs);\n+\n         let stab = tcx.lookup_stability(field.did);\n         let depr = tcx.lookup_deprecation(field.did);\n         encode_stability(self, stab);\n@@ -491,11 +448,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         let item = tcx.map.expect_item(struct_node_id);\n         let ctor_def_id = tcx.map.local_def_id(ctor_node_id);\n         encode_def_id_and_key(self, ctor_def_id);\n-        encode_family(self, match variant.kind {\n-            ty::VariantKind::Struct => 'S',\n-            ty::VariantKind::Tuple => 's',\n-            ty::VariantKind::Unit => 'u',\n-        });\n+        encode_family(self, Family::Struct(variant.kind));\n         self.encode_bounds_and_type_for_item(ctor_def_id);\n         encode_name(self, item.name);\n         self.encode_parent_item(struct_def_id);\n@@ -510,15 +463,17 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         // definition, but without this there is no way for them\n         // to tell that they actually have a ctor rather than a\n         // normal function\n-        self.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+        self.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n+        true.encode(self).unwrap();\n+        self.end_tag();\n     }\n \n     fn encode_generics(&mut self,\n                        generics: &ty::Generics<'tcx>,\n                        predicates: &ty::GenericPredicates<'tcx>)\n     {\n         self.start_tag(tag_item_generics);\n-        generics.encode(self.ecx).unwrap();\n+        generics.encode(self).unwrap();\n         self.end_tag();\n         self.encode_predicates(predicates, tag_item_predicates);\n     }\n@@ -527,13 +482,10 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                          predicates: &ty::GenericPredicates<'tcx>,\n                          tag: usize) {\n         self.start_tag(tag);\n-        if let Some(def_id) = predicates.parent {\n-            self.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n-        }\n-        for predicate in &predicates.predicates {\n-            let xref = self.add_xref(XRef::Predicate(predicate.clone()));\n-            self.wr_tagged_u32(tag_predicate, xref);\n-        }\n+        predicates.parent.encode(self).unwrap();\n+        self.seq(&predicates.predicates, |ecx, predicate| {\n+            ecx.add_xref(XRef::Predicate(predicate.clone()))\n+        });\n         self.end_tag();\n     }\n \n@@ -542,13 +494,12 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_name(self, method_ty.name);\n         self.encode_generics(&method_ty.generics, &method_ty.predicates);\n         self.encode_visibility(method_ty.vis);\n-        encode_explicit_self(self, &method_ty.explicit_self);\n-        match method_ty.explicit_self {\n-            ty::ExplicitSelfCategory::Static => {\n-                encode_family(self, STATIC_METHOD_FAMILY);\n-            }\n-            _ => encode_family(self, METHOD_FAMILY)\n-        }\n+\n+        self.start_tag(tag_item_trait_method_explicit_self);\n+        method_ty.explicit_self.encode(self).unwrap();\n+        self.end_tag();\n+\n+        encode_family(self, Family::Method);\n     }\n \n     fn encode_info_for_trait_item(&mut self,\n@@ -563,79 +514,47 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_stability(self, stab);\n         encode_deprecation(self, depr);\n \n-        let trait_item_type =\n-            tcx.impl_or_trait_item(item_def_id);\n-        let is_nonstatic_method;\n-        match trait_item_type {\n+        match tcx.impl_or_trait_item(item_def_id) {\n             ty::ConstTraitItem(associated_const) => {\n                 encode_name(self, associated_const.name);\n-                encode_def_id_and_key(self, associated_const.def_id);\n+                encode_def_id_and_key(self, item_def_id);\n                 self.encode_visibility(associated_const.vis);\n \n-                encode_family(self, 'C');\n-\n-                self.encode_bounds_and_type_for_item(associated_const.def_id);\n-\n-                is_nonstatic_method = false;\n+                encode_family(self, Family::AssociatedConst);\n+                self.encode_bounds_and_type_for_item(item_def_id);\n             }\n             ty::MethodTraitItem(method_ty) => {\n-                let method_def_id = item_def_id;\n-\n                 self.encode_method_ty_fields(&method_ty);\n-\n-                match method_ty.explicit_self {\n-                    ty::ExplicitSelfCategory::Static => {\n-                        encode_family(self, STATIC_METHOD_FAMILY);\n-                    }\n-                    _ => {\n-                        encode_family(self, METHOD_FAMILY);\n-                    }\n-                }\n-                self.encode_bounds_and_type_for_item(method_def_id);\n-\n-                is_nonstatic_method = method_ty.explicit_self !=\n-                    ty::ExplicitSelfCategory::Static;\n+                self.encode_bounds_and_type_for_item(item_def_id);\n             }\n             ty::TypeTraitItem(associated_type) => {\n                 encode_name(self, associated_type.name);\n-                encode_def_id_and_key(self, associated_type.def_id);\n-                encode_item_sort(self, 't');\n-                encode_family(self, 'y');\n+                encode_def_id_and_key(self, item_def_id);\n+                encode_family(self, Family::AssociatedType);\n \n                 if let Some(ty) = associated_type.ty {\n                     self.encode_type(ty);\n                 }\n-\n-                is_nonstatic_method = false;\n             }\n         }\n \n         encode_attributes(self, &trait_item.attrs);\n         match trait_item.node {\n             hir::ConstTraitItem(_, ref default) => {\n-                if default.is_some() {\n-                    encode_item_sort(self, 'C');\n-                } else {\n-                    encode_item_sort(self, 'c');\n-                }\n+                self.start_tag(tag_item_trait_item_has_body);\n+                default.is_some().encode(self).unwrap();\n+                self.end_tag();\n \n                 encode_inlined_item(self,\n                                     InlinedItemRef::TraitItem(trait_def_id, trait_item));\n                 self.encode_mir(item_def_id);\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n-                // If this is a static method, we've already\n-                // encoded self.\n-                if is_nonstatic_method {\n-                    self.encode_bounds_and_type_for_item(item_def_id);\n-                }\n+                self.start_tag(tag_item_trait_item_has_body);\n+                body.is_some().encode(self).unwrap();\n+                self.end_tag();\n \n-                if body.is_some() {\n-                    encode_item_sort(self, 'p');\n-                    self.encode_mir(item_def_id);\n-                } else {\n-                    encode_item_sort(self, 'r');\n-                }\n+                self.encode_mir(item_def_id);\n                 self.encode_method_argument_names(&sig.decl);\n             }\n \n@@ -654,7 +573,6 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n             }\n             ty::MethodTraitItem(ref method_type) => {\n                 self.encode_info_for_method(&method_type,\n-                                            false,\n                                             impl_id,\n                                             ast_item)\n             }\n@@ -678,10 +596,13 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_def_id_and_key(self, associated_const.def_id);\n         encode_name(self, associated_const.name);\n         self.encode_visibility(associated_const.vis);\n-        encode_family(self, 'C');\n+        encode_family(self, Family::AssociatedConst);\n \n         self.encode_parent_item(tcx.map.local_def_id(parent_id));\n-        encode_item_sort(self, 'C');\n+\n+        self.start_tag(tag_item_trait_item_has_body);\n+        true.encode(self).unwrap();\n+        self.end_tag();\n \n         self.encode_bounds_and_type_for_item(associated_const.def_id);\n \n@@ -702,7 +623,6 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_method(&mut self,\n                               m: &ty::Method<'tcx>,\n-                              is_default_impl: bool,\n                               parent_id: NodeId,\n                               impl_item_opt: Option<&hir::ImplItem>) {\n         let tcx = self.tcx;\n@@ -711,7 +631,10 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                m.name);\n         self.encode_method_ty_fields(m);\n         self.encode_parent_item(tcx.map.local_def_id(parent_id));\n-        encode_item_sort(self, 'r');\n+\n+        self.start_tag(tag_item_trait_item_has_body);\n+        true.encode(self).unwrap();\n+        self.end_tag();\n \n         let stab = tcx.lookup_stability(m.def_id);\n         let depr = tcx.lookup_deprecation(m.def_id);\n@@ -725,8 +648,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 encode_attributes(self, &impl_item.attrs);\n                 let generics = tcx.lookup_generics(m.def_id);\n                 let types = generics.parent_types as usize + generics.types.len();\n-                let needs_inline = types > 0 || is_default_impl ||\n-                    attr::requests_inline(&impl_item.attrs);\n+                let needs_inline = types > 0 || attr::requests_inline(&impl_item.attrs);\n                 if sig.constness == hir::Constness::Const {\n                     encode_inlined_item(\n                         self,\n@@ -755,9 +677,8 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_def_id_and_key(self, associated_type.def_id);\n         encode_name(self, associated_type.name);\n         self.encode_visibility(associated_type.vis);\n-        encode_family(self, 'y');\n+        encode_family(self, Family::AssociatedType);\n         self.encode_parent_item(tcx.map.local_def_id(parent_id));\n-        encode_item_sort(self, 't');\n \n         let stab = tcx.lookup_stability(associated_type.def_id);\n         let depr = tcx.lookup_deprecation(associated_type.def_id);\n@@ -777,15 +698,15 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_method_argument_names(&mut self,\n                                     decl: &hir::FnDecl) {\n         self.start_tag(tag_method_argument_names);\n-        for arg in &decl.inputs {\n-            let tag = tag_method_argument_name;\n+\n+        self.seq(&decl.inputs, |_, arg| {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n-                let name = path1.node.as_str();\n-                self.wr_tagged_bytes(tag, name.as_bytes());\n+                path1.node\n             } else {\n-                self.wr_tagged_bytes(tag, &[]);\n+                syntax::parse::token::intern(\"\")\n             }\n-        }\n+        });\n+\n         self.end_tag();\n     }\n \n@@ -797,36 +718,28 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                                                     attr));\n         }\n         self.start_tag(tag_items_data_item_repr);\n-        repr_attrs.encode(self.ecx);\n+        repr_attrs.encode(self);\n         self.end_tag();\n     }\n \n     fn encode_mir(&mut self, def_id: DefId) {\n         if let Some(mir) = self.mir_map.map.get(&def_id) {\n             self.start_tag(tag_mir as usize);\n-            mir.encode(self.ecx);\n+            mir.encode(self);\n             self.end_tag();\n         }\n     }\n }\n \n-const FN_FAMILY: char = 'f';\n-const STATIC_METHOD_FAMILY: char = 'F';\n-const METHOD_FAMILY: char = 'h';\n-\n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &mut EncodeContext,\n                                    def_id: DefId) {\n+    ecx.start_tag(tag_items_data_item_inherent_impls);\n     match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n-        None => {}\n-        Some(implementations) => {\n-            for &impl_def_id in implementations.iter() {\n-                ecx.start_tag(tag_items_data_item_inherent_impl);\n-                encode_def_id(ecx, impl_def_id);\n-                ecx.end_tag();\n-            }\n-        }\n+        None => <[DefId]>::encode(&[], ecx).unwrap(),\n+        Some(implementations) => implementations.encode(ecx).unwrap()\n     }\n+    ecx.end_tag();\n }\n \n fn encode_stability(ecx: &mut EncodeContext, stab_opt: Option<&attr::Stability>) {\n@@ -845,37 +758,35 @@ fn encode_deprecation(ecx: &mut EncodeContext, depr_opt: Option<attr::Deprecatio\n     });\n }\n \n-fn encode_parent_impl(ecx: &mut EncodeContext, parent_opt: Option<DefId>) {\n-    parent_opt.map(|parent| {\n-        ecx.wr_tagged_u64(tag_items_data_parent_impl, def_to_u64(parent));\n-    });\n-}\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n+        let old_len = self.xrefs.len() as u32;\n+        *self.xrefs.entry(xref).or_insert(old_len)\n+    }\n \n-fn encode_xrefs<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n-                          xrefs: FnvHashMap<XRef<'tcx>, u32>)\n-{\n-    let mut xref_positions = vec![0; xrefs.len()];\n+    fn encode_xrefs(&mut self) {\n+        let xrefs = mem::replace(&mut self.xrefs, Default::default());\n+        let mut xref_positions = vec![0; xrefs.len()];\n \n-    // Encode XRefs sorted by their ID\n-    let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n-    sorted_xrefs.sort_by_key(|&(_, id)| id);\n+        // Encode XRefs sorted by their ID\n+        let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n+        sorted_xrefs.sort_by_key(|&(_, id)| id);\n \n-    ecx.start_tag(tag_xref_data);\n-    for (xref, id) in sorted_xrefs.into_iter() {\n-        xref_positions[id as usize] = ecx.mark_stable_position() as u32;\n-        match xref {\n-            XRef::Predicate(p) => p.encode(ecx).unwrap()\n+        self.start_tag(tag_xref_data);\n+        for (xref, id) in sorted_xrefs.into_iter() {\n+            xref_positions[id as usize] = self.mark_stable_position() as u32;\n+            match xref {\n+                XRef::Predicate(p) => p.encode(self).unwrap()\n+            }\n         }\n-    }\n-    ecx.mark_stable_position();\n-    ecx.end_tag();\n+        self.mark_stable_position();\n+        self.end_tag();\n \n-    ecx.start_tag(tag_xref_index);\n-    index::write_dense_index(xref_positions, &mut ecx.opaque.cursor);\n-    ecx.end_tag();\n-}\n+        self.start_tag(tag_xref_index);\n+        index::write_dense_index(xref_positions, &mut self.opaque.cursor);\n+        self.end_tag();\n+    }\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_item(&mut self,\n                             (def_id, item): (DefId, &hir::Item)) {\n         let tcx = self.tcx;\n@@ -893,11 +804,11 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         match item.node {\n             hir::ItemStatic(_, m, _) => {\n                 encode_def_id_and_key(self, def_id);\n-                if m == hir::MutMutable {\n-                    encode_family(self, 'b');\n+                encode_family(self, if m == hir::MutMutable {\n+                    Family::MutStatic\n                 } else {\n-                    encode_family(self, 'c');\n-                }\n+                    Family::ImmStatic\n+                });\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, item.name);\n                 self.encode_visibility(vis);\n@@ -907,7 +818,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n             }\n             hir::ItemConst(..) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'C');\n+                encode_family(self, Family::Const);\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, item.name);\n                 encode_attributes(self, &item.attrs);\n@@ -919,7 +830,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n             }\n             hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, FN_FAMILY);\n+                encode_family(self, Family::Fn);\n                 let tps_len = generics.ty_params.len();\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, item.name);\n@@ -942,22 +853,24 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n             }\n             hir::ItemForeignMod(ref fm) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'n');\n+                encode_family(self, Family::ForeignMod);\n                 encode_name(self, item.name);\n \n                 // Encode all the items in self module.\n-                for foreign_item in &fm.items {\n-                    self.wr_tagged_u64(\n-                        tag_mod_child,\n-                        def_to_u64(tcx.map.local_def_id(foreign_item.id)));\n-                }\n+                self.start_tag(tag_mod_children);\n+                self.seq(&fm.items, |_, foreign_item| {\n+                    tcx.map.local_def_id(foreign_item.id)\n+                });\n+                <[def::Export]>::encode(&[], self).unwrap();\n+                self.end_tag();\n+\n                 self.encode_visibility(vis);\n                 encode_stability(self, stab);\n                 encode_deprecation(self, depr);\n             }\n             hir::ItemTy(..) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'y');\n+                encode_family(self, Family::Type);\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, item.name);\n                 self.encode_visibility(vis);\n@@ -966,15 +879,19 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 't');\n+                encode_family(self, Family::Enum);\n                 encode_item_variances(self, item.id);\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, item.name);\n                 encode_attributes(self, &item.attrs);\n                 self.encode_repr_attrs(&item.attrs);\n-                for v in &enum_definition.variants {\n-                    encode_variant_id(self, tcx.map.local_def_id(v.node.data.id()));\n-                }\n+\n+                self.start_tag(tag_mod_children);\n+                self.seq(&enum_definition.variants, |_, v| {\n+                    tcx.map.local_def_id(v.node.data.id())\n+                });\n+                <[def::Export]>::encode(&[], self).unwrap();\n+                self.end_tag();\n \n                 // Encode inherent implementations for self enumeration.\n                 encode_inherent_implementations(self, def_id);\n@@ -990,11 +907,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n \n                 /* Now, make an item for the class itself */\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, match *struct_def {\n-                    hir::VariantData::Struct(..) => 'S',\n-                    hir::VariantData::Tuple(..) => 's',\n-                    hir::VariantData::Unit(..) => 'u',\n-                });\n+                encode_family(self, Family::Struct(variant.kind));\n                 self.encode_bounds_and_type_for_item(def_id);\n \n                 encode_item_variances(self, item.id);\n@@ -1008,23 +921,24 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 /* Encode def_ids for each field and method\n                 for methods, write all the stuff get_trait_method\n                 needs to know*/\n-                self.encode_struct_fields(variant);\n+                self.encode_variant_fields(variant);\n \n                 // Encode inherent implementations for self structure.\n                 encode_inherent_implementations(self, def_id);\n \n                 if !struct_def.is_struct() {\n                     let ctor_did = tcx.map.local_def_id(struct_def.id());\n-                    self.wr_tagged_u64(tag_items_data_item_struct_ctor,\n-                                       def_to_u64(ctor_did));\n+                    self.start_tag(tag_items_data_item_struct_ctor);\n+                    ctor_did.encode(self).unwrap();\n+                    self.end_tag();\n                 }\n             }\n             hir::ItemUnion(..) => {\n                 let def = self.tcx.lookup_adt_def(def_id);\n                 let variant = def.struct_variant();\n \n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'U');\n+                encode_family(self, Family::Union);\n                 self.encode_bounds_and_type_for_item(def_id);\n \n                 encode_item_variances(self, item.id);\n@@ -1038,36 +952,32 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 /* Encode def_ids for each field and method\n                 for methods, write all the stuff get_trait_method\n                 needs to know*/\n-                self.encode_struct_fields(variant);\n+                self.encode_variant_fields(variant);\n \n                 encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n                 self.encode_mir(def_id);\n \n                 // Encode inherent implementations for self union.\n                 encode_inherent_implementations(self, def_id);\n             }\n-            hir::ItemDefaultImpl(unsafety, _) => {\n+            hir::ItemDefaultImpl(..) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'd');\n+                encode_family(self, Family::DefaultImpl);\n                 encode_name(self, item.name);\n-                encode_unsafety(self, unsafety);\n \n                 let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(item.id)).unwrap();\n                 encode_trait_ref(self, trait_ref, tag_item_trait_ref);\n             }\n-            hir::ItemImpl(unsafety, polarity, ..) => {\n-                // We need to encode information about the default methods we\n-                // have inherited, so we drive self based on the impl structure.\n-                let impl_items = tcx.impl_items.borrow();\n-                let items = &impl_items[&def_id];\n-\n+            hir::ItemImpl(_, polarity, ..) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'i');\n+                encode_family(self, Family::Impl);\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, item.name);\n                 encode_attributes(self, &item.attrs);\n-                encode_unsafety(self, unsafety);\n-                encode_polarity(self, polarity);\n+\n+                self.start_tag(tag_polarity);\n+                polarity.encode(self).unwrap();\n+                self.end_tag();\n \n                 match\n                     tcx.custom_coerce_unsized_kinds\n@@ -1076,30 +986,17 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 {\n                     Some(&kind) => {\n                         self.start_tag(tag_impl_coerce_unsized_kind);\n-                        kind.encode(self.ecx);\n+                        kind.encode(self);\n                         self.end_tag();\n                     }\n                     None => {}\n                 }\n \n-                for &item_def_id in items {\n-                    self.start_tag(tag_item_impl_item);\n-                    match item_def_id {\n-                        ty::ConstTraitItemId(item_def_id) => {\n-                            encode_def_id(self, item_def_id);\n-                            encode_item_sort(self, 'C');\n-                        }\n-                        ty::MethodTraitItemId(item_def_id) => {\n-                            encode_def_id(self, item_def_id);\n-                            encode_item_sort(self, 'r');\n-                        }\n-                        ty::TypeTraitItemId(item_def_id) => {\n-                            encode_def_id(self, item_def_id);\n-                            encode_item_sort(self, 't');\n-                        }\n-                    }\n-                    self.end_tag();\n-                }\n+                self.start_tag(tag_mod_children);\n+                let items = tcx.impl_or_trait_items(def_id);\n+                self.seq(&items[..], |_, id| id.def_id());\n+                <[def::Export]>::encode(&[], self).unwrap();\n+                self.end_tag();\n \n                 let did = tcx.map.local_def_id(item.id);\n                 if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n@@ -1114,20 +1011,34 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                                                   Some(parent),\n                                               _ => None,\n                                           });\n-                    encode_parent_impl(self, parent);\n+                    parent.map(|parent| {\n+                        self.start_tag(tag_items_data_parent_impl);\n+                        parent.encode(self).unwrap();\n+                        self.end_tag();\n+                    });\n                 }\n                 encode_stability(self, stab);\n                 encode_deprecation(self, depr);\n             }\n             hir::ItemTrait(..) => {\n                 encode_def_id_and_key(self, def_id);\n-                encode_family(self, 'I');\n+                encode_family(self, Family::Trait);\n                 encode_item_variances(self, item.id);\n                 let trait_def = tcx.lookup_trait_def(def_id);\n                 let trait_predicates = tcx.lookup_predicates(def_id);\n-                encode_unsafety(self, trait_def.unsafety);\n-                encode_paren_sugar(self, trait_def.paren_sugar);\n-                encode_defaulted(self, tcx.trait_has_default_impl(def_id));\n+\n+                self.start_tag(tag_unsafety);\n+                trait_def.unsafety.encode(self).unwrap();\n+                self.end_tag();\n+\n+                self.start_tag(tag_paren_sugar);\n+                trait_def.paren_sugar.encode(self).unwrap();\n+                self.end_tag();\n+\n+                self.start_tag(tag_defaulted_trait);\n+                tcx.trait_has_default_impl(def_id).encode(self).unwrap();\n+                self.end_tag();\n+\n                 encode_associated_type_names(self, &trait_def.associated_type_names);\n                 self.encode_generics(&trait_def.generics, &trait_predicates);\n                 self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n@@ -1138,27 +1049,12 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 self.encode_visibility(vis);\n                 encode_stability(self, stab);\n                 encode_deprecation(self, depr);\n-                for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-                    self.start_tag(tag_item_trait_item);\n-                    match method_def_id {\n-                        ty::ConstTraitItemId(const_def_id) => {\n-                            encode_def_id(self, const_def_id);\n-                            encode_item_sort(self, 'C');\n-                        }\n-                        ty::MethodTraitItemId(method_def_id) => {\n-                            encode_def_id(self, method_def_id);\n-                            encode_item_sort(self, 'r');\n-                        }\n-                        ty::TypeTraitItemId(type_def_id) => {\n-                            encode_def_id(self, type_def_id);\n-                            encode_item_sort(self, 't');\n-                        }\n-                    }\n-                    self.end_tag();\n \n-                    self.wr_tagged_u64(tag_mod_child,\n-                                       def_to_u64(method_def_id.def_id()));\n-                }\n+                self.start_tag(tag_mod_children);\n+                let items = tcx.impl_or_trait_items(def_id);\n+                self.seq(&items[..], |_, id| id.def_id());\n+                <[def::Export]>::encode(&[], self).unwrap();\n+                self.end_tag();\n \n                 // Encode inherent implementations for self trait.\n                 encode_inherent_implementations(self, def_id);\n@@ -1227,7 +1123,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 // Foo()` and `struct Foo`\n                 let ctor_def_id = self.tcx.map.local_def_id(struct_node_id);\n                 self.record(ctor_def_id,\n-                            ItemContentBuilder::encode_struct_ctor,\n+                            EncodeContext::encode_struct_ctor,\n                             (def_id, item.id, struct_node_id));\n             }\n         }\n@@ -1241,8 +1137,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                              def_id: DefId,\n                              impl_id: ast::NodeId,\n                              ast_items: &[hir::ImplItem]) {\n-        let impl_items = self.tcx.impl_items.borrow();\n-        let items = &impl_items[&def_id];\n+        let items = self.tcx.impl_or_trait_items(def_id);\n \n         // Iterate down the trait items, emitting them. We rely on the\n         // assumption that all of the actually implemented trait items\n@@ -1258,7 +1153,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n             let trait_item_def_id = trait_item_def_id.def_id();\n             self.record(trait_item_def_id,\n-                        ItemContentBuilder::encode_info_for_impl_item,\n+                        EncodeContext::encode_info_for_impl_item,\n                         (impl_id, trait_item_def_id, ast_item));\n         }\n     }\n@@ -1267,19 +1162,18 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                               def_id: DefId,\n                               trait_items: &[hir::TraitItem]) {\n         // Now output the trait item info for each trait item.\n-        let tcx = self.tcx;\n-        let r = tcx.trait_item_def_ids(def_id);\n+        let r = self.tcx.impl_or_trait_items(def_id);\n         for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n             let item_def_id = item_def_id.def_id();\n             assert!(item_def_id.is_local());\n             self.record(item_def_id,\n-                        ItemContentBuilder::encode_info_for_trait_item,\n+                        EncodeContext::encode_info_for_trait_item,\n                         (def_id, item_def_id, trait_item));\n         }\n     }\n }\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_foreign_item(&mut self,\n                                     (def_id, nitem): (DefId, &hir::ForeignItem)) {\n         let tcx = self.tcx;\n@@ -1292,7 +1186,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         self.encode_visibility(&nitem.vis);\n         match nitem.node {\n             hir::ForeignItemFn(ref fndecl, _) => {\n-                encode_family(self, FN_FAMILY);\n+                encode_family(self, Family::Fn);\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_name(self, nitem.name);\n                 encode_attributes(self, &nitem.attrs);\n@@ -1303,11 +1197,11 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 self.encode_method_argument_names(&fndecl);\n             }\n             hir::ForeignItemStatic(_, mutbl) => {\n-                if mutbl {\n-                    encode_family(self, 'b');\n+                encode_family(self, if mutbl {\n+                    Family::MutStatic\n                 } else {\n-                    encode_family(self, 'c');\n-                }\n+                    Family::ImmStatic\n+                });\n                 self.encode_bounds_and_type_for_item(def_id);\n                 encode_attributes(self, &nitem.attrs);\n                 let stab = tcx.lookup_stability(tcx.map.local_def_id(nitem.id));\n@@ -1335,7 +1229,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         match item.node {\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n             _ => self.index.record(def_id,\n-                                   ItemContentBuilder::encode_info_for_item,\n+                                   EncodeContext::encode_info_for_item,\n                                    (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n@@ -1344,7 +1238,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.index.tcx.map.local_def_id(ni.id);\n         self.index.record(def_id,\n-                          ItemContentBuilder::encode_info_for_foreign_item,\n+                          EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n@@ -1358,7 +1252,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = self.tcx.map.local_def_id(ty.id);\n             self.record(def_id,\n-                        ItemContentBuilder::encode_info_for_anon_ty,\n+                        EncodeContext::encode_info_for_anon_ty,\n                         def_id);\n         }\n     }\n@@ -1368,18 +1262,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ExprClosure(..) => {\n                 let def_id = self.tcx.map.local_def_id(expr.id);\n                 self.record(def_id,\n-                            ItemContentBuilder::encode_info_for_closure,\n+                            EncodeContext::encode_info_for_closure,\n                             def_id);\n             }\n             _ => { }\n         }\n     }\n }\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) {\n         encode_def_id_and_key(self, def_id);\n-        encode_family(self, 'y');\n         self.encode_bounds_and_type_for_item(def_id);\n     }\n \n@@ -1389,42 +1282,41 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_name(self, syntax::parse::token::intern(\"<closure>\"));\n \n         self.start_tag(tag_items_closure_ty);\n-        tcx.tables.borrow().closure_tys[&def_id].encode(self.ecx).unwrap();\n+        tcx.tables.borrow().closure_tys[&def_id].encode(self).unwrap();\n         self.end_tag();\n \n         self.start_tag(tag_items_closure_kind);\n-        tcx.closure_kind(def_id).encode(self.ecx).unwrap();\n+        tcx.closure_kind(def_id).encode(self).unwrap();\n         self.end_tag();\n \n         assert!(self.mir_map.map.contains_key(&def_id));\n         self.encode_mir(def_id);\n     }\n }\n \n-fn encode_info_for_items<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>)\n-                                   -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n+fn encode_info_for_items(ecx: &mut EncodeContext) -> IndexData {\n     let krate = ecx.tcx.map.krate();\n \n     ecx.start_tag(tag_items_data);\n \n-    let fields = {\n+    let items = {\n         let mut index = IndexBuilder::new(ecx);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n-                     ItemContentBuilder::encode_info_for_mod,\n+                     EncodeContext::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module,\n-                                            &[],\n+                                            &krate.attrs,\n                                             syntax::parse::token::intern(&ecx.link_meta.crate_name),\n                                             &hir::Public)));\n         let mut visitor = EncodeVisitor {\n             index: index,\n         };\n         krate.visit_all_items(&mut visitor);\n-        visitor.index.into_fields()\n+        visitor.index.into_items()\n     };\n \n     ecx.end_tag();\n \n-    fields\n+    items\n }\n \n fn encode_item_index(ecx: &mut EncodeContext, index: IndexData) {\n@@ -1439,40 +1331,12 @@ fn encode_attributes(ecx: &mut EncodeContext, attrs: &[ast::Attribute]) {\n     ecx.end_tag();\n }\n \n-fn encode_unsafety(ecx: &mut EncodeContext, unsafety: hir::Unsafety) {\n-    let byte: u8 = match unsafety {\n-        hir::Unsafety::Normal => 0,\n-        hir::Unsafety::Unsafe => 1,\n-    };\n-    ecx.wr_tagged_u8(tag_unsafety, byte);\n-}\n-\n-fn encode_paren_sugar(ecx: &mut EncodeContext, paren_sugar: bool) {\n-    let byte: u8 = if paren_sugar {1} else {0};\n-    ecx.wr_tagged_u8(tag_paren_sugar, byte);\n-}\n-\n-fn encode_defaulted(ecx: &mut EncodeContext, is_defaulted: bool) {\n-    let byte: u8 = if is_defaulted {1} else {0};\n-    ecx.wr_tagged_u8(tag_defaulted_trait, byte);\n-}\n-\n fn encode_associated_type_names(ecx: &mut EncodeContext, names: &[Name]) {\n     ecx.start_tag(tag_associated_type_names);\n-    for &name in names {\n-        ecx.wr_tagged_str(tag_associated_type_name, &name.as_str());\n-    }\n+    names.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n-fn encode_polarity(ecx: &mut EncodeContext, polarity: hir::ImplPolarity) {\n-    let byte: u8 = match polarity {\n-        hir::ImplPolarity::Positive => 0,\n-        hir::ImplPolarity::Negative => 1,\n-    };\n-    ecx.wr_tagged_u8(tag_polarity, byte);\n-}\n-\n fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n                         -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n@@ -1500,133 +1364,112 @@ fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ecx.start_tag(tag_crate_deps);\n-    for (_cnum, dep) in get_ordered_deps(cstore) {\n-        encode_crate_dep(ecx, &dep);\n-    }\n+    ecx.seq(&get_ordered_deps(cstore), |_, &(_, ref dep)| {\n+        (dep.name(), decoder::get_crate_hash(dep.data()),\n+         dep.explicitly_linked.get())\n+    });\n     ecx.end_tag();\n }\n \n fn encode_lang_items(ecx: &mut EncodeContext) {\n-    ecx.start_tag(tag_lang_items);\n-\n-    for (i, &opt_def_id) in ecx.tcx.lang_items.items().iter().enumerate() {\n-        if let Some(def_id) = opt_def_id {\n-            if def_id.is_local() {\n-                ecx.start_tag(tag_lang_items_item);\n-                ecx.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n-                ecx.wr_tagged_u32(tag_lang_items_item_index, def_id.index.as_u32());\n-                ecx.end_tag();\n+    let tcx = ecx.tcx;\n+    let lang_items = || {\n+        tcx.lang_items.items().iter().enumerate().filter_map(|(i, &opt_def_id)| {\n+            if let Some(def_id) = opt_def_id {\n+                if def_id.is_local() {\n+                    return Some((def_id.index, i));\n+                }\n             }\n-        }\n-    }\n+            None\n+        })\n+    };\n \n-    for i in &ecx.tcx.lang_items.missing {\n-        ecx.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n-    }\n+    let count = lang_items().count();\n+    let mut lang_items = lang_items();\n \n-    ecx.end_tag();   // tag_lang_items\n+    ecx.start_tag(tag_lang_items);\n+    ecx.seq(0..count, |_, _| lang_items.next().unwrap());\n+    ecx.end_tag();\n+\n+    ecx.start_tag(tag_lang_items_missing);\n+    tcx.lang_items.missing.encode(ecx).unwrap();\n+    ecx.end_tag();\n }\n \n fn encode_native_libraries(ecx: &mut EncodeContext) {\n-    ecx.start_tag(tag_native_libraries);\n-\n-    for &(ref lib, kind) in ecx.tcx.sess.cstore.used_libraries().iter() {\n-        match kind {\n-            cstore::NativeStatic => {} // these libraries are not propagated\n-            cstore::NativeFramework | cstore::NativeUnknown => {\n-                ecx.start_tag(tag_native_libraries_lib);\n-                ecx.wr_tagged_u32(tag_native_libraries_kind, kind as u32);\n-                ecx.wr_tagged_str(tag_native_libraries_name, lib);\n-                ecx.end_tag();\n+    let used_libraries = ecx.tcx.sess.cstore.used_libraries();\n+    let libs = || {\n+        used_libraries.iter().filter_map(|&(ref lib, kind)| {\n+            match kind {\n+                cstore::NativeStatic => None, // these libraries are not propagated\n+                cstore::NativeFramework | cstore::NativeUnknown => {\n+                    Some((kind, lib))\n+                }\n             }\n-        }\n-    }\n+        })\n+    };\n+\n+    let count = libs().count();\n+    let mut libs = libs();\n \n+    ecx.start_tag(tag_native_libraries);\n+    ecx.seq(0..count, |_, _| libs.next().unwrap());\n     ecx.end_tag();\n }\n \n fn encode_plugin_registrar_fn(ecx: &mut EncodeContext) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n         Some(id) => {\n             let def_id = ecx.tcx.map.local_def_id(id);\n-            ecx.wr_tagged_u32(tag_plugin_registrar_fn, def_id.index.as_u32());\n+            ecx.start_tag(tag_plugin_registrar_fn);\n+            def_id.index.encode(ecx).unwrap();\n+            ecx.end_tag();\n         }\n         None => {}\n     }\n }\n \n fn encode_codemap(ecx: &mut EncodeContext) {\n-    ecx.start_tag(tag_codemap);\n     let codemap = ecx.tcx.sess.codemap();\n+    let all_filemaps = codemap.files.borrow();\n+    let filemaps = || {\n+        // No need to export empty filemaps, as they can't contain spans\n+        // that need translation.\n+        // Also no need to re-export imported filemaps, as any downstream\n+        // crate will import them from their original source.\n+        all_filemaps.iter().filter(|filemap| {\n+            !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+        })\n+    };\n \n-    for filemap in &codemap.files.borrow()[..] {\n-\n-        if filemap.lines.borrow().is_empty() || filemap.is_imported() {\n-            // No need to export empty filemaps, as they can't contain spans\n-            // that need translation.\n-            // Also no need to re-export imported filemaps, as any downstream\n-            // crate will import them from their original source.\n-            continue;\n-        }\n-\n-        ecx.start_tag(tag_codemap_filemap);\n-        filemap.encode(ecx).unwrap();\n-        ecx.end_tag();\n-    }\n+    let count = filemaps().count();\n+    let mut filemaps = filemaps();\n \n+    ecx.start_tag(tag_codemap);\n+    ecx.seq(0..count, |_, _| filemaps.next().unwrap());\n     ecx.end_tag();\n }\n \n /// Serialize the text of the exported macros\n-fn encode_macro_defs(ecx: &mut EncodeContext,\n-                     krate: &hir::Crate) {\n+fn encode_macro_defs(ecx: &mut EncodeContext) {\n+    let tcx = ecx.tcx;\n     ecx.start_tag(tag_macro_defs);\n-    for def in &krate.exported_macros {\n-        ecx.start_tag(tag_macro_def);\n-\n-        encode_name(ecx, def.name);\n-        encode_attributes(ecx, &def.attrs);\n-        let &BytePos(lo) = &def.span.lo;\n-        let &BytePos(hi) = &def.span.hi;\n-        ecx.wr_tagged_u32(tag_macro_def_span_lo, lo);\n-        ecx.wr_tagged_u32(tag_macro_def_span_hi, hi);\n-\n-        ecx.wr_tagged_str(tag_macro_def_body,\n-                          &::syntax::print::pprust::tts_to_string(&def.body));\n-\n-        ecx.end_tag();\n-    }\n+    ecx.seq(&tcx.map.krate().exported_macros, |_, def| {\n+        let body = ::syntax::print::pprust::tts_to_string(&def.body);\n+        (def.name, &def.attrs, def.span, body)\n+    });\n     ecx.end_tag();\n \n     if ecx.tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro) {\n         let id = ecx.tcx.sess.derive_registrar_fn.get().unwrap();\n         let did = ecx.tcx.map.local_def_id(id);\n-        ecx.wr_tagged_u32(tag_macro_derive_registrar, did.index.as_u32());\n-    }\n-}\n \n-fn encode_struct_field_attrs(ecx: &mut EncodeContext, krate: &hir::Crate) {\n-    struct StructFieldVisitor<'a, 'b:'a, 'tcx:'b> {\n-        ecx: &'a mut EncodeContext<'b, 'tcx>\n-    }\n-\n-    impl<'a, 'b, 'tcx, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b, 'tcx> {\n-        fn visit_struct_field(&mut self, field: &hir::StructField) {\n-            self.ecx.start_tag(tag_struct_field);\n-            let def_id = self.ecx.tcx.map.local_def_id(field.id);\n-            encode_def_id(self.ecx, def_id);\n-            encode_attributes(self.ecx, &field.attrs);\n-            self.ecx.end_tag();\n-        }\n+        ecx.start_tag(tag_macro_derive_registrar);\n+        did.index.encode(ecx).unwrap();\n+        ecx.end_tag();\n     }\n-\n-    ecx.start_tag(tag_struct_fields);\n-    krate.visit_all_items(&mut StructFieldVisitor { ecx: ecx });\n-    ecx.end_tag();\n }\n \n-\n-\n struct ImplVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     impls: FnvHashMap<DefId, Vec<DefId>>\n@@ -1646,20 +1489,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n }\n \n /// Encodes an index, mapping each trait to its (local) implementations.\n-fn encode_impls(ecx: &mut EncodeContext, krate: &hir::Crate) {\n+fn encode_impls(ecx: &mut EncodeContext) {\n     let mut visitor = ImplVisitor {\n         tcx: ecx.tcx,\n         impls: FnvHashMap()\n     };\n-    krate.visit_all_items(&mut visitor);\n+    ecx.tcx.map.krate().visit_all_items(&mut visitor);\n \n     ecx.start_tag(tag_impls);\n-    for (trait_, trait_impls) in visitor.impls {\n-        ecx.start_tag(tag_impls_trait);\n-        encode_def_id(ecx, trait_);\n-        for impl_ in trait_impls {\n-            ecx.wr_tagged_u64(tag_impls_trait_impl, def_to_u64(impl_));\n-        }\n+    for (trait_def_id, trait_impls) in visitor.impls {\n+        // FIXME(eddyb) Avoid wrapping the entries in docs.\n+        ecx.start_tag(0);\n+        (trait_def_id.krate.as_u32(), trait_def_id.index).encode(ecx).unwrap();\n+        trait_impls.encode(ecx).unwrap();\n         ecx.end_tag();\n     }\n     ecx.end_tag();\n@@ -1673,74 +1515,32 @@ fn encode_impls(ecx: &mut EncodeContext, krate: &hir::Crate) {\n // definition (as that's not defined in this crate).\n fn encode_reachable(ecx: &mut EncodeContext) {\n     ecx.start_tag(tag_reachable_ids);\n-    for &id in ecx.reachable {\n-        let def_id = ecx.tcx.map.local_def_id(id);\n-        ecx.wr_tagged_u32(tag_reachable_id, def_id.index.as_u32());\n-    }\n-    ecx.end_tag();\n-}\n-\n-fn encode_crate_dep(ecx: &mut EncodeContext,\n-                    dep: &cstore::CrateMetadata) {\n-    ecx.start_tag(tag_crate_dep);\n-    ecx.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n-    let hash = decoder::get_crate_hash(dep.data());\n-    ecx.wr_tagged_u64(tag_crate_dep_hash, hash.as_u64());\n-    ecx.wr_tagged_u8(tag_crate_dep_explicitly_linked,\n-                     dep.explicitly_linked.get() as u8);\n-    ecx.end_tag();\n-}\n-\n-fn encode_hash(ecx: &mut EncodeContext, hash: &Svh) {\n-    ecx.wr_tagged_u64(tag_crate_hash, hash.as_u64());\n-}\n-\n-fn encode_rustc_version(ecx: &mut EncodeContext) {\n-    ecx.wr_tagged_str(tag_rustc_version, &rustc_version());\n-}\n \n-fn encode_crate_name(ecx: &mut EncodeContext, crate_name: &str) {\n-    ecx.wr_tagged_str(tag_crate_crate_name, crate_name);\n-}\n+    let reachable = ecx.reachable;\n+    ecx.seq(reachable, |ecx, &id| ecx.tcx.map.local_def_id(id).index);\n \n-fn encode_crate_disambiguator(ecx: &mut EncodeContext, crate_disambiguator: &str) {\n-    ecx.wr_tagged_str(tag_crate_disambiguator, crate_disambiguator);\n-}\n-\n-fn encode_crate_triple(ecx: &mut EncodeContext, triple: &str) {\n-    ecx.wr_tagged_str(tag_crate_triple, triple);\n+    ecx.end_tag();\n }\n \n fn encode_dylib_dependency_formats(ecx: &mut EncodeContext) {\n-    let tag = tag_dylib_dependency_formats;\n+    ecx.start_tag(tag_dylib_dependency_formats);\n     match ecx.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n-            let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n-                let kind = match *slot {\n+            ecx.seq(arr, |_, slot| {\n+                match *slot {\n                     Linkage::NotLinked |\n-                    Linkage::IncludedFromDylib => return None,\n-                    Linkage::Dynamic => \"d\",\n-                    Linkage::Static => \"s\",\n-                };\n-                Some(format!(\"{}:{}\", i + 1, kind))\n-            }).collect::<Vec<String>>();\n-            ecx.wr_tagged_str(tag, &s.join(\",\"));\n-        }\n-        None => {\n-            ecx.wr_tagged_str(tag, \"\");\n-        }\n-    }\n-}\n+                    Linkage::IncludedFromDylib => None,\n \n-fn encode_panic_strategy(ecx: &mut EncodeContext) {\n-    match ecx.tcx.sess.opts.cg.panic {\n-        PanicStrategy::Unwind => {\n-            ecx.wr_tagged_u8(tag_panic_strategy, b'U');\n+                    Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n+                    Linkage::Static => Some(LinkagePreference::RequireStatic),\n+                }\n+            });\n         }\n-        PanicStrategy::Abort => {\n-            ecx.wr_tagged_u8(tag_panic_strategy, b'A');\n+        None => {\n+            <[Option<LinkagePreference>]>::encode(&[], ecx).unwrap();\n         }\n     }\n+    ecx.end_tag();\n }\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1764,6 +1564,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable: reachable,\n         mir_map: mir_map,\n         type_shorthands: Default::default(),\n+        xrefs: Default::default()\n     });\n \n     // RBML compacts the encoded bytes whenever appropriate,\n@@ -1806,24 +1607,34 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn encode_metadata_inner(ecx: &mut EncodeContext) {\n-    encode_rustc_version(ecx);\n+    ecx.wr_tagged_str(tag_rustc_version, &rustc_version());\n \n     let tcx = ecx.tcx;\n     let link_meta = ecx.link_meta;\n-    encode_crate_name(ecx, &link_meta.crate_name);\n-    encode_crate_triple(ecx, &tcx.sess.opts.target_triple);\n-    encode_hash(ecx, &link_meta.crate_hash);\n-    encode_crate_disambiguator(ecx, &tcx.sess.local_crate_disambiguator());\n+\n+    ecx.start_tag(tag_crate_crate_name);\n+    link_meta.crate_name.encode(ecx).unwrap();\n+    ecx.end_tag();\n+\n+    ecx.start_tag(tag_crate_triple);\n+    tcx.sess.opts.target_triple.encode(ecx).unwrap();\n+    ecx.end_tag();\n+\n+    ecx.start_tag(tag_crate_hash);\n+    link_meta.crate_hash.encode(ecx).unwrap();\n+    ecx.end_tag();\n+\n+    ecx.start_tag(tag_crate_disambiguator);\n+    tcx.sess.local_crate_disambiguator().encode(ecx).unwrap();\n+    ecx.end_tag();\n+\n     encode_dylib_dependency_formats(ecx);\n-    encode_panic_strategy(ecx);\n \n-    let krate = tcx.map.krate();\n+    ecx.start_tag(tag_panic_strategy);\n+    ecx.tcx.sess.opts.cg.panic.encode(ecx);\n+    ecx.end_tag();\n \n     let mut i = ecx.position();\n-    encode_attributes(ecx, &krate.attrs);\n-    let attr_bytes = ecx.position() - i;\n-\n-    i = ecx.position();\n     encode_crate_deps(ecx, ecx.cstore);\n     let dep_bytes = ecx.position() - i;\n \n@@ -1849,12 +1660,12 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n \n     // Encode macro definitions\n     i = ecx.position();\n-    encode_macro_defs(ecx, krate);\n+    encode_macro_defs(ecx);\n     let macro_defs_bytes = ecx.position() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = ecx.position();\n-    encode_impls(ecx, krate);\n+    encode_impls(ecx);\n     let impl_bytes = ecx.position() - i;\n \n     // Encode reachability info.\n@@ -1865,7 +1676,7 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     // Encode and index the items.\n     ecx.start_tag(tag_items);\n     i = ecx.position();\n-    let (items, xrefs) = encode_info_for_items(ecx);\n+    let items = encode_info_for_items(ecx);\n     let item_bytes = ecx.position() - i;\n     ecx.end_tag();\n \n@@ -1874,11 +1685,9 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     let index_bytes = ecx.position() - i;\n \n     i = ecx.position();\n-    encode_xrefs(ecx, xrefs);\n+    ecx.encode_xrefs();\n     let xref_bytes = ecx.position() - i;\n \n-    encode_struct_field_attrs(ecx, krate);\n-\n     let total_bytes = ecx.position();\n \n     if ecx.tcx.sess.meta_stats() {\n@@ -1890,7 +1699,6 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n         }\n \n         println!(\"metadata stats:\");\n-        println!(\"       attribute bytes: {}\", attr_bytes);\n         println!(\"             dep bytes: {}\", dep_bytes);\n         println!(\"       lang item bytes: {}\", lang_item_bytes);\n         println!(\"          native bytes: {}\", native_lib_bytes);"}, {"sha": "2cfa6f8d5d1154b833314c5a6b9c7aeb8d61dbac", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 13, "deletions": 54, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -38,17 +38,11 @@\n //!\n //! What record will do is to (a) record the current offset, (b) emit\n //! the `common::data_item` tag, and then call `callback_fn` with the\n-//! given data as well as an `ItemContentBuilder`. Once `callback_fn`\n+//! given data as well as the `EncodingContext`. Once `callback_fn`\n //! returns, the `common::data_item` tag will be closed.\n //!\n-//! The `ItemContentBuilder` is another type that just offers access\n-//! to the `ecx` that was given in, as well as maintaining a list of\n-//! `xref` instances, which are used to extract common data so it is\n-//! not re-serialized.\n-//!\n-//! `ItemContentBuilder` is a distinct type which does not offer the\n-//! `record` method, so that we can ensure that `common::data_item` elements\n-//! are never nested.\n+//! `EncodingContext` does not offer the `record` method, so that we\n+//! can ensure that `common::data_item` elements are never nested.\n //!\n //! In addition, while the `callback_fn` is executing, we will push a\n //! task `MetaData(some_def_id)`, which can then observe the\n@@ -67,8 +61,7 @@ use index::IndexData;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n@@ -77,54 +70,27 @@ use std::ops::{Deref, DerefMut};\n /// Item encoding cannot be nested.\n pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n     items: IndexData,\n-    builder: ItemContentBuilder<'a, 'b, 'tcx>,\n-}\n-\n-/// Builder that can encode the content of items, but can't start a\n-/// new item itself. Most code is attached to here.\n-pub struct ItemContentBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n     pub ecx: &'a mut EncodeContext<'b, 'tcx>,\n }\n \n impl<'a, 'b, 'tcx> Deref for IndexBuilder<'a, 'b, 'tcx> {\n-    type Target = EncodeContext<'b, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.builder.ecx\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.builder.ecx\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> Deref for ItemContentBuilder<'a, 'b, 'tcx> {\n     type Target = EncodeContext<'b, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n         self.ecx\n     }\n }\n \n-impl<'a, 'b, 'tcx> DerefMut for ItemContentBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         self.ecx\n     }\n }\n \n-/// \"interned\" entries referenced by id\n-#[derive(PartialEq, Eq, Hash)]\n-pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n-\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n             items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n-            builder: ItemContentBuilder {\n-                ecx: ecx,\n-                xrefs: FnvHashMap(),\n-            },\n+            ecx: ecx,\n         }\n     }\n \n@@ -147,28 +113,21 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// content system.\n     pub fn record<DATA>(&mut self,\n                         id: DefId,\n-                        op: fn(&mut ItemContentBuilder<'a, 'b, 'tcx>, DATA),\n+                        op: fn(&mut EncodeContext<'b, 'tcx>, DATA),\n                         data: DATA)\n         where DATA: DepGraphRead\n     {\n-        let position = self.builder.ecx.mark_stable_position();\n+        let position = self.ecx.mark_stable_position();\n         self.items.record(id, position);\n         let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        self.builder.ecx.start_tag(tag_items_data_item).unwrap();\n+        self.ecx.start_tag(tag_items_data_item).unwrap();\n         data.read(self.tcx);\n-        op(&mut self.builder, data);\n-        self.builder.ecx.end_tag().unwrap();\n-    }\n-\n-    pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n-        (self.items, self.builder.xrefs)\n+        op(&mut self.ecx, data);\n+        self.ecx.end_tag().unwrap();\n     }\n-}\n \n-impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n-    pub fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n-        let old_len = self.xrefs.len() as u32;\n-        *self.xrefs.entry(xref).or_insert(old_len)\n+    pub fn into_items(self) -> IndexData {\n+        self.items\n     }\n }\n "}, {"sha": "b7125daa4ad5773b0b0a84bbf46b4a42db6ac051", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -17,6 +17,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(conservative_impl_trait)]\n #![feature(core_intrinsics)]\n #![feature(box_patterns)]\n #![feature(dotdot_in_tuple_patterns)]"}, {"sha": "24a0329602beb0becc3440aa120a05f0fa711cca", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "modified", "additions": 14, "deletions": 118, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -80,19 +80,16 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn get(&self, tag: usize) -> Doc<'doc> {\n-        get_doc(*self, tag)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.start == self.end\n-    }\n-\n-    pub fn as_str(&self) -> &'doc str {\n-        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n+        match maybe_get_doc(*self, tag) {\n+            Some(d) => d,\n+            None => {\n+                bug!(\"failed to find block with tag {:?}\", tag);\n+            }\n+        }\n     }\n \n-    pub fn to_string(&self) -> String {\n-        self.as_str().to_string()\n+    pub fn children(self) -> DocsIterator<'doc> {\n+        DocsIterator { d: self }\n     }\n }\n \n@@ -129,7 +126,7 @@ pub struct Res {\n     pub next: usize,\n }\n \n-pub fn tag_at(data: &[u8], start: usize) -> Result<Res, Error> {\n+fn tag_at(data: &[u8], start: usize) -> Result<Res, Error> {\n     let v = data[start] as usize;\n     if v < 0xf0 {\n         Ok(Res {\n@@ -180,7 +177,7 @@ fn vuint_at_slow(data: &[u8], start: usize) -> Result<Res, Error> {\n     Err(Error::IntTooBig(a as usize))\n }\n \n-pub fn vuint_at(data: &[u8], start: usize) -> Result<Res, Error> {\n+fn vuint_at(data: &[u8], start: usize) -> Result<Res, Error> {\n     if data.len() - start < 4 {\n         return vuint_at_slow(data, start);\n     }\n@@ -234,7 +231,7 @@ pub fn vuint_at(data: &[u8], start: usize) -> Result<Res, Error> {\n     }\n }\n \n-pub fn tag_len_at(data: &[u8], next: usize) -> Result<Res, Error> {\n+fn tag_len_at(data: &[u8], next: usize) -> Result<Res, Error> {\n     vuint_at(data, next)\n }\n \n@@ -255,27 +252,14 @@ pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n     None\n }\n \n-pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n-    match maybe_get_doc(d, tg) {\n-        Some(d) => d,\n-        None => {\n-            bug!(\"failed to find block with tag {:?}\", tg);\n-        }\n-    }\n-}\n-\n-pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n-    DocsIterator { d: d }\n-}\n-\n pub struct DocsIterator<'a> {\n     d: Doc<'a>,\n }\n \n impl<'a> Iterator for DocsIterator<'a> {\n-    type Item = (usize, Doc<'a>);\n+    type Item = Doc<'a>;\n \n-    fn next(&mut self) -> Option<(usize, Doc<'a>)> {\n+    fn next(&mut self) -> Option<Doc<'a>> {\n         if self.d.start >= self.d.end {\n             return None;\n         }\n@@ -297,98 +281,10 @@ impl<'a> Iterator for DocsIterator<'a> {\n         };\n \n         self.d.start = end;\n-        return Some((elt_tag.val, doc));\n-    }\n-}\n-\n-pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n-    TaggedDocsIterator {\n-        iter: docs(d),\n-        tag: tag,\n+        return Some(doc);\n     }\n }\n \n-pub struct TaggedDocsIterator<'a> {\n-    iter: DocsIterator<'a>,\n-    tag: usize,\n-}\n-\n-impl<'a> Iterator for TaggedDocsIterator<'a> {\n-    type Item = Doc<'a>;\n-\n-    fn next(&mut self) -> Option<Doc<'a>> {\n-        while let Some((tag, doc)) = self.iter.next() {\n-            if tag == self.tag {\n-                return Some(doc);\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n-    where F: FnOnce(&[u8]) -> T\n-{\n-    f(&d.data[d.start..d.end])\n-}\n-\n-pub fn doc_as_u8(d: Doc) -> u8 {\n-    assert_eq!(d.end, d.start + 1);\n-    d.data[d.start]\n-}\n-\n-pub fn doc_as_u64(d: Doc) -> u64 {\n-    if d.end >= 8 {\n-        // For performance, we read 8 big-endian bytes,\n-        // and mask off the junk if there is any. This\n-        // obviously won't work on the first 8 bytes\n-        // of a file - we will fall of the start\n-        // of the page and segfault.\n-\n-        let mut b = [0; 8];\n-        b.copy_from_slice(&d.data[d.end - 8..d.end]);\n-        let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n-        let len = d.end - d.start;\n-        if len < 8 {\n-            data & ((1 << (len * 8)) - 1)\n-        } else {\n-            data\n-        }\n-    } else {\n-        let mut result = 0;\n-        for b in &d.data[d.start..d.end] {\n-            result = (result << 8) + (*b as u64);\n-        }\n-        result\n-    }\n-}\n-\n-#[inline]\n-pub fn doc_as_u16(d: Doc) -> u16 {\n-    doc_as_u64(d) as u16\n-}\n-#[inline]\n-pub fn doc_as_u32(d: Doc) -> u32 {\n-    doc_as_u64(d) as u32\n-}\n-\n-#[inline]\n-pub fn doc_as_i8(d: Doc) -> i8 {\n-    doc_as_u8(d) as i8\n-}\n-#[inline]\n-pub fn doc_as_i16(d: Doc) -> i16 {\n-    doc_as_u16(d) as i16\n-}\n-#[inline]\n-pub fn doc_as_i32(d: Doc) -> i32 {\n-    doc_as_u32(d) as i32\n-}\n-#[inline]\n-pub fn doc_as_i64(d: Doc) -> i64 {\n-    doc_as_u64(d) as i64\n-}\n-\n #[test]\n fn test_vuint_at() {\n     let data = &["}, {"sha": "46b63cb134031ac413b396dd6d7f7f44bb8d4a5e", "filename": "src/librustc_metadata/rbml/writer.rs", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mem;\n use std::io::prelude::*;\n use std::io::{self, SeekFrom, Cursor};\n \n@@ -112,50 +111,10 @@ impl<'a> Encoder<'a> {\n         Ok(())\n     }\n \n-    pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n-        where F: FnOnce() -> EncodeResult\n-    {\n-        self.start_tag(tag_id)?;\n-        blk()?;\n-        self.end_tag()\n-    }\n-\n-    pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-        write_tag(&mut self.opaque.cursor, tag_id)?;\n-        write_vuint(&mut self.opaque.cursor, b.len())?;\n-        self.opaque.cursor.write_all(b)\n-    }\n-\n-    pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-        let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-        // tagged integers are emitted in big-endian, with no\n-        // leading zeros.\n-        let leading_zero_bytes = v.leading_zeros() / 8;\n-        self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n-    }\n-\n-    #[inline]\n-    pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-        self.wr_tagged_u64(tag_id, v as u64)\n-    }\n-\n-    #[inline]\n-    pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-        self.wr_tagged_bytes(tag_id, &[v])\n-    }\n-\n     pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n-        self.wr_tagged_bytes(tag_id, v.as_bytes())\n-    }\n-\n-    pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-        debug!(\"Write {:?} bytes\", b.len());\n-        self.opaque.cursor.write_all(b)\n-    }\n-\n-    pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-        debug!(\"Write str: {:?}\", s);\n-        self.opaque.cursor.write_all(s.as_bytes())\n+        write_tag(&mut self.opaque.cursor, tag_id)?;\n+        write_vuint(&mut self.opaque.cursor, v.len())?;\n+        self.opaque.cursor.write_all(v.as_bytes())\n     }\n \n     pub fn position(&mut self) -> usize {"}, {"sha": "3df3a2decba3ba0dd6edf89c6d2a08ebc9d793a9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -21,10 +21,10 @@ use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::{ChildItem, DlDef};\n+use rustc::middle::cstore::ChildItem;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::ty::{self, VariantKind};\n+use rustc::ty;\n \n use std::cell::Cell;\n \n@@ -201,7 +201,7 @@ impl<'b> Resolver<'b> {\n                     let module = self.new_extern_crate_module(parent_link, def, item.id);\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n-                    self.build_reduced_graph_for_external_crate(module);\n+                    self.populate_module_if_necessary(module);\n                 }\n             }\n \n@@ -388,22 +388,18 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, xcdef: ChildItem) {\n-        let def = match xcdef.def {\n-            DlDef(def) => def,\n-            _ => return,\n-        };\n-\n-        if let Def::ForeignMod(def_id) = def {\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: ChildItem) {\n+        if let Def::ForeignMod(def_id) = child.def {\n             // Foreign modules have no names. Recur and populate eagerly.\n             for child in self.session.cstore.item_children(def_id) {\n                 self.build_reduced_graph_for_external_crate_def(parent, child);\n             }\n             return;\n         }\n \n-        let name = xcdef.name;\n-        let vis = if parent.is_trait() { ty::Visibility::Public } else { xcdef.vis };\n+        let def = child.def;\n+        let name = child.name;\n+        let vis = if parent.is_trait() { ty::Visibility::Public } else { child.vis };\n \n         match def {\n             Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n@@ -413,16 +409,12 @@ impl<'b> Resolver<'b> {\n                 let module = self.new_module(parent_link, Some(def), None);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n-            Def::Variant(_, variant_id) => {\n+            Def::Variant(..) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n                 let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n-                if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n-                    // Not adding fields for variants as they are not accessed with a self receiver\n-                    self.structs.insert(variant_id, Vec::new());\n-                }\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n@@ -439,7 +431,7 @@ impl<'b> Resolver<'b> {\n                 // If this is a trait, add all the trait item names to the trait\n                 // info.\n \n-                let trait_item_def_ids = self.session.cstore.trait_item_def_ids(def_id);\n+                let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n                 for trait_item_def in &trait_item_def_ids {\n                     let trait_item_name =\n                         self.session.cstore.item_name(trait_item_def.def_id());\n@@ -493,15 +485,6 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    /// Builds the reduced graph rooted at the 'use' directive for an external\n-    /// crate.\n-    fn build_reduced_graph_for_external_crate(&mut self, root: Module<'b>) {\n-        let root_cnum = root.def_id().unwrap().krate;\n-        for child in self.session.cstore.crate_top_level_items(root_cnum) {\n-            self.build_reduced_graph_for_external_crate_def(root, child);\n-        }\n-    }\n-\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {"}, {"sha": "b03e76c829a3e9f4d6bd6741665c1d89e0083ca5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -1275,6 +1275,7 @@ impl<'a> Resolver<'a> {\n                                -> Module<'a> {\n         let mut module = ModuleS::new(parent_link, Some(def), Some(local_node_id));\n         module.extern_crate_id = Some(local_node_id);\n+        module.populated.set(false);\n         self.arenas.modules.alloc(module)\n     }\n "}, {"sha": "186183a8ad4d4f37765ca008e833d4b1e0e74bc2", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -543,10 +543,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 .map(|mr| mr.def_id())\n                         }\n                         ty::ImplContainer(def_id) => {\n-                            let impl_items = self.tcx.impl_items.borrow();\n-                            Some(impl_items.get(&def_id)\n-                                           .unwrap()\n-                                           .iter()\n+                            let impl_items = self.tcx.impl_or_trait_items(def_id);\n+                            Some(impl_items.iter()\n                                            .find(|mr| {\n                                                self.tcx.impl_or_trait_item(mr.def_id()).name() ==\n                                                ti.name()"}, {"sha": "b9449eeecf427f260c649187d796eb98f8d5cd0e", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -627,25 +627,23 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n-            if !match tcx.lookup_item_type(def_id).ty.sty {\n-                ty::TyFnDef(def_id, ..) => {\n+            match tcx.lookup_item_type(def_id).ty.sty {\n+                ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n                     // translation item. Same for FFI functions.\n-                    match tcx.map.get_if_local(def_id) {\n-                        Some(hir_map::NodeVariant(_))    |\n-                        Some(hir_map::NodeStructCtor(_)) |\n-                        Some(hir_map::NodeForeignItem(_)) => false,\n-                        Some(_) => true,\n-                        None => {\n-                            tcx.sess.cstore.variant_kind(def_id).is_none()\n+                    if let Some(hir_map::NodeForeignItem(_)) = tcx.map.get_if_local(def_id) {\n+                        return false;\n+                    }\n+\n+                    if let Some(adt_def) = f.sig.output().skip_binder().ty_adt_def() {\n+                        if adt_def.variants.iter().any(|v| def_id == v.did) {\n+                            return false;\n                         }\n                     }\n                 }\n-                ty::TyClosure(..) => true,\n-                _ => false\n-            } {\n-                return false;\n+                ty::TyClosure(..) => {}\n+                _ => return false\n             }\n \n             can_have_local_instance(tcx, def_id)"}, {"sha": "9db5020747e1f39619a2c49db9eb733955007dfb", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -230,7 +230,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n-    let trait_item_def_ids = tcx.trait_item_def_ids(trait_id);\n+    let trait_item_def_ids = tcx.impl_or_trait_items(trait_id);\n     trait_item_def_ids\n         .iter()\n "}, {"sha": "999433db2407182d22204d96adbb6aa29b209c05", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -247,11 +247,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n-                for ac in ccx.tcx().associated_consts(vtable_impl.impl_def_id) {\n-                    if ac.name == name {\n-                        instance = Instance::new(ac.def_id, vtable_impl.substs);\n-                        break;\n-                    }\n+                let ac = ccx.tcx().impl_or_trait_items(vtable_impl.impl_def_id)\n+                    .iter().filter_map(|id| {\n+                        match *id {\n+                            ty::ConstTraitItemId(def_id) => {\n+                                Some(ccx.tcx().impl_or_trait_item(def_id))\n+                            }\n+                            _ => None\n+                        }\n+                    }).find(|ic| ic.name() == name);\n+                if let Some(ac) = ac {\n+                    instance = Instance::new(ac.def_id(), vtable_impl.substs);\n                 }\n             }\n         }"}, {"sha": "71219d82668e4f4822ceb2eec27e9ee5f93a06e5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n+        let method_item = self.impl_or_trait_item(trait_def_id, m_name).unwrap();\n         let method_ty = method_item.as_opt_method().unwrap();\n         assert_eq!(method_ty.generics.types.len(), 0);\n         assert_eq!(method_ty.generics.regions.len(), 0);\n@@ -359,27 +359,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(def)\n     }\n \n-    /// Find item with name `item_name` defined in `trait_def_id`\n-    /// and return it, or `None`, if no such item.\n-    pub fn trait_item(&self,\n-                      trait_def_id: DefId,\n-                      item_name: ast::Name)\n-                      -> Option<ty::ImplOrTraitItem<'tcx>>\n+    /// Find item with name `item_name` defined in impl/trait `def_id`\n+    /// and return it, or `None`, if no such item was defined there.\n+    pub fn impl_or_trait_item(&self,\n+                              def_id: DefId,\n+                              item_name: ast::Name)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n-        let trait_items = self.tcx.trait_items(trait_def_id);\n-        trait_items.iter()\n-                   .find(|item| item.name() == item_name)\n-                   .cloned()\n-    }\n-\n-    pub fn impl_item(&self,\n-                     impl_def_id: DefId,\n-                     item_name: ast::Name)\n-                     -> Option<ty::ImplOrTraitItem<'tcx>>\n-    {\n-        let impl_items = self.tcx.impl_items.borrow();\n-        let impl_items = impl_items.get(&impl_def_id).unwrap();\n-        impl_items\n+        self.tcx.impl_or_trait_items(def_id)\n             .iter()\n             .map(|&did| self.tcx.impl_or_trait_item(did.def_id()))\n             .find(|m| m.name() == item_name)"}, {"sha": "9fba9bcb757b6a78149d03e1dd0565fe7f7e0fba", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -403,7 +403,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match self.impl_item(impl_def_id) {\n+        let item = match self.impl_or_trait_item(impl_def_id) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match self.trait_item(bound_trait_ref.def_id()) {\n+            let item = match self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -1292,18 +1292,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n-    fn impl_item(&self, impl_def_id: DefId)\n-                 -> Option<ty::ImplOrTraitItem<'tcx>>\n+    /// Find item with name `item_name` defined in impl/trait `def_id`\n+    /// and return it, or `None`, if no such item was defined there.\n+    fn impl_or_trait_item(&self, def_id: DefId)\n+                          -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n-        self.fcx.impl_item(impl_def_id, self.item_name)\n-    }\n-\n-    /// Find item with name `item_name` defined in `trait_def_id`\n-    /// and return it, or `None`, if no such item.\n-    fn trait_item(&self, trait_def_id: DefId)\n-                  -> Option<ty::ImplOrTraitItem<'tcx>>\n-    {\n-        self.fcx.trait_item(trait_def_id, self.item_name)\n+        self.fcx.impl_or_trait_item(def_id, self.item_name)\n     }\n }\n "}, {"sha": "7ec4918070233eb94e720922531c43997166f606", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -16,9 +16,8 @@ use CrateCtxt;\n use check::{FnCtxt};\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use middle::cstore;\n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n use rustc::traits::{Obligation, SelectionContext};\n@@ -92,9 +91,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = self.impl_item(impl_did, item_name)\n+                        let item = self.impl_or_trait_item(impl_did, item_name)\n                             .or_else(|| {\n-                                self.trait_item(\n+                                self.impl_or_trait_item(\n                                     self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n \n                                     item_name\n@@ -127,7 +126,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = self.trait_item(trait_did, item_name).unwrap();\n+                        let item = self.impl_or_trait_item(trait_did, item_name).unwrap();\n                         let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n                         span_note!(err, item_span,\n                                    \"candidate #{} is defined in the trait `{}`\",\n@@ -321,7 +320,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 (type_is_local || info.def_id.is_local())\n-                    && self.trait_item(info.def_id, item_name).is_some()\n+                    && self.impl_or_trait_item(info.def_id, item_name).is_some()\n             })\n             .collect::<Vec<_>>();\n \n@@ -449,34 +448,30 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n \n         // Cross-crate:\n         let mut external_mods = FnvHashSet();\n-        fn handle_external_def(traits: &mut AllTraitsVec,\n+        fn handle_external_def(ccx: &CrateCtxt,\n+                               traits: &mut AllTraitsVec,\n                                external_mods: &mut FnvHashSet<DefId>,\n-                               ccx: &CrateCtxt,\n-                               cstore: &for<'a> cstore::CrateStore<'a>,\n-                               dl: cstore::DefLike) {\n-            match dl {\n-                cstore::DlDef(Def::Trait(did)) => {\n+                               def: Def) {\n+            match def {\n+                Def::Trait(did) => {\n                     traits.push(TraitInfo::new(did));\n                 }\n-                cstore::DlDef(Def::Mod(did)) => {\n+                Def::Mod(did) => {\n                     if !external_mods.insert(did) {\n                         return;\n                     }\n-                    for child in cstore.item_children(did) {\n-                        handle_external_def(traits, external_mods,\n-                                            ccx, cstore, child.def)\n+                    for child in ccx.tcx.sess.cstore.item_children(did) {\n+                        handle_external_def(ccx, traits, external_mods, child.def)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-        let cstore = &*ccx.tcx.sess.cstore;\n-\n         for cnum in ccx.tcx.sess.cstore.crates() {\n-            for child in cstore.crate_top_level_items(cnum) {\n-                handle_external_def(&mut traits, &mut external_mods,\n-                                    ccx, cstore, child.def)\n-            }\n+            handle_external_def(ccx, &mut traits, &mut external_mods, Def::Mod(DefId {\n+                krate: cnum,\n+                index: CRATE_DEF_INDEX\n+            }));\n         }\n \n         *ccx.all_traits.borrow_mut() = Some(traits);"}, {"sha": "fb077d279c99875b84e54fda5d99fec2d5ed9310", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -39,6 +39,8 @@ use rustc::hir::intravisit;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n+use std::rc::Rc;\n+\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -156,7 +158,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        tcx.impl_items.borrow_mut().insert(impl_did, impl_items);\n+        tcx.impl_or_trait_item_ids.borrow_mut().insert(impl_did, Rc::new(impl_items));\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n@@ -208,7 +210,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n-        let impl_items = tcx.impl_items.borrow();\n+        let impl_items = tcx.impl_or_trait_item_ids.borrow();\n \n         drop_trait.for_each_impl(tcx, |impl_did| {\n             let items = impl_items.get(&impl_did).unwrap();"}, {"sha": "9d072491cc28b532871b54723f54dcb55150fa08", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -55,12 +55,12 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             })\n         }\n \n-        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_ids.borrow();\n \n-        for item1 in &impl_items[&impl1] {\n+        for item1 in &impl_items[&impl1][..] {\n             let (name, namespace) = name_and_namespace(self.tcx, item1);\n \n-            for item2 in &impl_items[&impl2] {\n+            for item2 in &impl_items[&impl2][..] {\n                 if (name, namespace) == name_and_namespace(self.tcx, item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n                     let node_id = self.tcx.map.as_local_node_id(item1.def_id()).unwrap();"}, {"sha": "fa052bec7be3d6f1eab92d9e221feb62b432b815", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -563,6 +563,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             vis: &hir::Visibility,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n+                            has_body: bool,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n     let def_id = ccx.tcx.map.local_def_id(id);\n@@ -580,15 +581,18 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               sig, untransformed_rcvr_ty, anon_scope)\n     };\n \n-    let ty_method = ty::Method::new(name,\n-                                    ty_generics,\n-                                    ty_generic_predicates,\n-                                    fty,\n-                                    explicit_self_category,\n-                                    ty::Visibility::from_hir(vis, id, ccx.tcx),\n-                                    defaultness,\n-                                    def_id,\n-                                    container);\n+    let ty_method = ty::Method {\n+        name: name,\n+        generics: ty_generics,\n+        predicates: ty_generic_predicates,\n+        fty: fty,\n+        explicit_self: explicit_self_category,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n+        defaultness: defaultness,\n+        has_body: has_body,\n+        def_id: def_id,\n+        container: container,\n+    };\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.map.span(id), def_id);\n@@ -843,7 +847,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, selfty,\n+                                   sig, impl_item.defaultness, true, selfty,\n                                    &ty_predicates);\n                 }\n             }\n@@ -905,14 +909,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Convert all the methods\n             for trait_item in trait_items {\n-                if let hir::MethodTraitItem(ref sig, _) = trait_item.node {\n+                if let hir::MethodTraitItem(ref sig, ref body) = trait_item.node {\n                     convert_method(ccx,\n                                    container,\n                                    trait_item.name,\n                                    trait_item.id,\n                                    &hir::Inherited,\n                                    sig,\n                                    hir::Defaultness::Default,\n+                                   body.is_some(),\n                                    tcx.mk_self_type(),\n                                    &trait_predicates);\n \n@@ -928,8 +933,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::TypeTraitItem(..) => ty::TypeTraitItemId(def_id)\n                 }\n             }).collect());\n-            tcx.trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                       trait_item_def_ids);\n+            tcx.impl_or_trait_item_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                           trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {"}, {"sha": "e992861b77bc6c29df444e4e32c15622f1068033", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -15,7 +15,6 @@ use std::iter::once;\n use syntax::ast;\n use rustc::hir;\n \n-use rustc::middle::cstore;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n@@ -96,12 +95,12 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeTypedef);\n             ret.extend(build_impls(cx, tcx, did));\n-            build_type(cx, tcx, did)\n+            clean::TypedefItem(build_type_alias(cx, tcx, did), false)\n         }\n         Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did));\n-            build_type(cx, tcx, did)\n+            clean::EnumItem(build_enum(cx, tcx, did))\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n@@ -200,6 +199,18 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n+fn build_enum<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        did: DefId) -> clean::Enum {\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n+\n+    clean::Enum {\n+        generics: (t.generics, &predicates).clean(cx),\n+        variants_stripped: false,\n+        variants: tcx.lookup_adt_def(did).variants.clean(cx),\n+    }\n+}\n+\n fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId) -> clean::Struct {\n     let t = tcx.lookup_item_type(did);\n@@ -232,25 +243,15 @@ fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        did: DefId) -> clean::ItemEnum {\n+fn build_type_alias<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              did: DefId) -> clean::Typedef {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n-    match t.ty.sty {\n-        ty::TyAdt(edef, _) if edef.is_enum() && !tcx.sess.cstore.is_typedef(did) => {\n-            return clean::EnumItem(clean::Enum {\n-                generics: (t.generics, &predicates).clean(cx),\n-                variants_stripped: false,\n-                variants: edef.variants.clean(cx),\n-            })\n-        }\n-        _ => {}\n-    }\n \n-    clean::TypedefItem(clean::Typedef {\n+    clean::Typedef {\n         type_: t.ty.clean(cx),\n         generics: (t.generics, &predicates).clean(cx),\n-    }, false)\n+    }\n }\n \n pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n@@ -264,32 +265,49 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n             build_impl(cx, tcx, did, &mut impls);\n         }\n     }\n-\n-    // If this is the first time we've inlined something from this crate, then\n-    // we inline *all* impls from the crate into this crate. Note that there's\n+    // If this is the first time we've inlined something from another crate, then\n+    // we inline *all* impls from all the crates into this crate. Note that there's\n     // currently no way for us to filter this based on type, and we likely need\n     // many impls for a variety of reasons.\n     //\n     // Primarily, the impls will be used to populate the documentation for this\n     // type being inlined, but impls can also be used when generating\n     // documentation for primitives (no way to find those specifically).\n-    if cx.populated_crate_impls.borrow_mut().insert(did.krate) {\n-        for item in tcx.sess.cstore.crate_top_level_items(did.krate) {\n-            populate_impls(cx, tcx, item.def, &mut impls);\n-        }\n+    if cx.populated_all_crate_impls.get() {\n+        return impls;\n+    }\n \n-        fn populate_impls<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def: cstore::DefLike,\n-                                    impls: &mut Vec<clean::Item>) {\n-            match def {\n-                cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n-                cstore::DlDef(Def::Mod(did)) => {\n-                    for item in tcx.sess.cstore.item_children(did) {\n-                        populate_impls(cx, tcx, item.def, impls)\n-                    }\n-                }\n-                _ => {}\n-            }\n+    cx.populated_all_crate_impls.set(true);\n+\n+    for did in tcx.sess.cstore.implementations_of_trait(None) {\n+        build_impl(cx, tcx, did, &mut impls);\n+    }\n+\n+    // Also try to inline primitive impls from other crates.\n+    let primitive_impls = [\n+        tcx.lang_items.isize_impl(),\n+        tcx.lang_items.i8_impl(),\n+        tcx.lang_items.i16_impl(),\n+        tcx.lang_items.i32_impl(),\n+        tcx.lang_items.i64_impl(),\n+        tcx.lang_items.usize_impl(),\n+        tcx.lang_items.u8_impl(),\n+        tcx.lang_items.u16_impl(),\n+        tcx.lang_items.u32_impl(),\n+        tcx.lang_items.u64_impl(),\n+        tcx.lang_items.f32_impl(),\n+        tcx.lang_items.f64_impl(),\n+        tcx.lang_items.char_impl(),\n+        tcx.lang_items.str_impl(),\n+        tcx.lang_items.slice_impl(),\n+        tcx.lang_items.slice_impl(),\n+        tcx.lang_items.const_ptr_impl()\n+    ];\n+\n+    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n+        if !def_id.is_local() {\n+            tcx.populate_implementations_for_primitive_if_necessary(def_id);\n+            build_impl(cx, tcx, def_id, &mut impls);\n         }\n     }\n \n@@ -348,7 +366,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     }\n \n     let predicates = tcx.lookup_predicates(did);\n-    let trait_items = tcx.sess.cstore.impl_items(did)\n+    let trait_items = tcx.sess.cstore.impl_or_trait_items(did)\n             .iter()\n             .filter_map(|did| {\n         let did = did.def_id();\n@@ -453,7 +471,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             for_: for_,\n             generics: (ty.generics, &predicates).clean(cx),\n             items: trait_items,\n-            polarity: polarity.map(|p| { p.clean(cx) }),\n+            polarity: Some(polarity.clean(cx)),\n         }),\n         source: clean::Span::empty(),\n         name: None,\n@@ -482,19 +500,17 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut visited = FnvHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n             match item.def {\n-                cstore::DlDef(Def::ForeignMod(did)) => {\n+                Def::ForeignMod(did) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n-                cstore::DlDef(def) if item.vis == ty::Visibility::Public => {\n-                    if !visited.insert(def) { continue }\n-                    if let Some(i) = try_inline_def(cx, tcx, def) {\n-                        items.extend(i)\n+                def => {\n+                    if item.vis == ty::Visibility::Public {\n+                        if !visited.insert(def) { continue }\n+                        if let Some(i) = try_inline_def(cx, tcx, def) {\n+                            items.extend(i)\n+                        }\n                     }\n                 }\n-                cstore::DlDef(..) => {}\n-                // All impls were inlined above\n-                cstore::DlImpl(..) => {}\n-                cstore::DlField => panic!(\"unimplemented field\"),\n             }\n         }\n     }"}, {"sha": "f9d7eb50edaec59ff10e6447b19d14d93a65c141", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -33,7 +33,6 @@ use syntax::print::pprust as syntax_pprust;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n-use rustc::middle::cstore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::Def;\n@@ -239,9 +238,10 @@ impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n         cx.tcx_opt().map(|tcx| {\n-            for item in tcx.sess.cstore.crate_top_level_items(self.0) {\n+            let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n+            for item in tcx.sess.cstore.item_children(root) {\n                 let did = match item.def {\n-                    cstore::DlDef(Def::Mod(did)) => did,\n+                    Def::Mod(did) => did,\n                     _ => continue\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n@@ -1877,11 +1877,9 @@ impl Clean<Item> for hir::StructField {\n \n impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        // FIXME: possible O(n^2)-ness! Not my fault.\n-        let attr_map = cx.tcx().sess.cstore.crate_struct_field_attrs(self.did.krate);\n         Item {\n             name: Some(self.name).clean(cx),\n-            attrs: attr_map.get(&self.did).unwrap_or(&Vec::new()).clean(cx),\n+            attrs: cx.tcx().get_attrs(self.did).clean(cx),\n             source: Span::empty(),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),"}, {"sha": "c52497dc89bd6b7c824ff2b3acc0010afddee7ab", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -13,13 +13,13 @@ use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n-use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::FnvHashMap;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -53,7 +53,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n-    pub populated_crate_impls: RefCell<FnvHashSet<CrateNum>>,\n+    pub populated_all_crate_impls: Cell<bool>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n     pub deref_mut_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n@@ -205,7 +205,7 @@ pub fn run_core(search_paths: SearchPaths,\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n-            populated_crate_impls: Default::default(),\n+            populated_all_crate_impls: Cell::new(false),\n             deref_trait_did: Cell::new(None),\n             deref_mut_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),"}, {"sha": "4518945dd9857ffd99bed3791eb02f264dee4341", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -106,8 +106,8 @@ pub fn run(input: &str,\n         map: &map,\n         maybe_typed: core::NotTyped(&sess),\n         input: input,\n+        populated_all_crate_impls: Cell::new(false),\n         external_traits: Default::default(),\n-        populated_crate_impls: Default::default(),\n         deref_trait_did: Cell::new(None),\n         deref_mut_trait_did: Cell::new(None),\n         access_levels: Default::default(),"}, {"sha": "da11f652b4b34d6df44e51077ef682a4e01af1db", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8734aaa33ed745a09b983bea9a89b6278b1b082c/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=8734aaa33ed745a09b983bea9a89b6278b1b082c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::cstore::{CrateStore, ChildItem, DefLike};\n+use rustc::middle::cstore::{CrateStore, ChildItem};\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -66,39 +66,32 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n \n     pub fn visit_mod(&mut self, did: DefId) {\n         for item in self.cstore.item_children(did) {\n-            if let DefLike::DlDef(def) = item.def {\n-                match def {\n-                    Def::Mod(did) |\n-                    Def::ForeignMod(did) |\n-                    Def::Trait(did) |\n-                    Def::Struct(did) |\n-                    Def::Union(did) |\n-                    Def::Enum(did) |\n-                    Def::TyAlias(did) |\n-                    Def::Fn(did) |\n-                    Def::Method(did) |\n-                    Def::Static(did, _) |\n-                    Def::Const(did) => self.visit_item(did, item),\n-                    _ => {}\n-                }\n+            match item.def {\n+                Def::Mod(did) |\n+                Def::ForeignMod(did) |\n+                Def::Trait(did) |\n+                Def::Struct(did) |\n+                Def::Union(did) |\n+                Def::Enum(did) |\n+                Def::TyAlias(did) |\n+                Def::Fn(did) |\n+                Def::Method(did) |\n+                Def::Static(did, _) |\n+                Def::Const(did) => self.visit_item(did, item),\n+                _ => {}\n             }\n         }\n     }\n \n     fn visit_item(&mut self, did: DefId, item: ChildItem) {\n         let inherited_item_level = match item.def {\n-            DefLike::DlImpl(..) | DefLike::DlField => unreachable!(),\n-            DefLike::DlDef(def) => {\n-                match def {\n-                    Def::ForeignMod(..) => self.prev_level,\n-                    _ => if item.vis == Visibility::Public { self.prev_level } else { None }\n-                }\n-            }\n+            Def::ForeignMod(..) => self.prev_level,\n+            _ => if item.vis == Visibility::Public { self.prev_level } else { None }\n         };\n \n         let item_level = self.update(did, inherited_item_level);\n \n-        if let DefLike::DlDef(Def::Mod(did)) = item.def {\n+        if let Def::Mod(did) = item.def {\n             let orig_level = self.prev_level;\n \n             self.prev_level = item_level;"}]}