{"sha": "51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYTVhNGFkMGUyNTAxYjI2MGE4MDU5YTcyZTRiMGVlYmU3OGQ2Zjk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-04T01:48:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-04T01:49:44Z"}, "message": "rustc: Translate repeated vector syntax", "tree": {"sha": "f20c14d139f490c7f6e8642f47b831531f8ecd4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20c14d139f490c7f6e8642f47b831531f8ecd4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "html_url": "https://github.com/rust-lang/rust/commit/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488ece05b59b68a7d25c1fc59388438a78bb0b52", "url": "https://api.github.com/repos/rust-lang/rust/commits/488ece05b59b68a7d25c1fc59388438a78bb0b52", "html_url": "https://github.com/rust-lang/rust/commit/488ece05b59b68a7d25c1fc59388438a78bb0b52"}], "stats": {"total": 151, "additions": 106, "deletions": 45}, "files": [{"sha": "13f3cf72f5f6d5f207638fbab4d06fed8ee57cf1", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "patch": "@@ -3636,8 +3636,13 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           }\n           ast::expr_lit(lit) { return trans_lit(bcx, e, *lit, dest); }\n           ast::expr_vec(args, _) {\n-            return tvec::trans_evec(bcx, args, ast::vstore_fixed(none),\n-                                 e.id, dest);\n+            return tvec::trans_evec(bcx, tvec::individual_evec(args),\n+                                    ast::vstore_fixed(none), e.id, dest);\n+          }\n+          ast::expr_repeat(element, count_expr, _) {\n+            let count = ty::eval_repeat_count(bcx.tcx(), count_expr, e.span);\n+            return tvec::trans_evec(bcx, tvec::repeating_evec(element, count),\n+                                    ast::vstore_fixed(none), e.id, dest);\n           }\n           ast::expr_binary(op, lhs, rhs) {\n             return trans_binary(bcx, op, lhs, rhs, dest, e);"}, {"sha": "f85ca19a4b67b9d640c7b75978dfd6aaba63681c", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "patch": "@@ -5,7 +5,7 @@ import back::abi;\n import base::{call_memmove,\n               INIT, copy_val, load_if_immediate, get_tydesc,\n               sub_block, do_spill_noroot,\n-              dest, bcx_icx, non_gc_box_cast};\n+              dest, bcx_icx, non_gc_box_cast, move_val, lval_owned};\n import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;\n@@ -118,18 +118,39 @@ fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n     } else { bcx }\n }\n \n-fn trans_evec(bcx: block, args: ~[@ast::expr],\n+enum evec_elements {\n+    individual_evec(~[@ast::expr]),\n+    repeating_evec(@ast::expr, uint)\n+}\n+\n+fn trans_evec(bcx: block, elements: evec_elements,\n               vst: ast::vstore, id: ast::node_id, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(~\"tvec::trans_evec\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n+\n+    // Handle the ignored case.\n     if dest == base::ignore {\n-        for vec::each(args) |arg| {\n-            bcx = base::trans_expr(bcx, arg, base::ignore);\n+        match elements {\n+            individual_evec(args) => {\n+                for vec::each(args) |arg| {\n+                    bcx = base::trans_expr(bcx, arg, base::ignore);\n+                }\n+            }\n+            repeating_evec(element, _) => {\n+                bcx = base::trans_expr(bcx, element, base::ignore);\n+            }\n         }\n         return bcx;\n     }\n \n+    // Figure out the number of elements we need.\n+    let count;\n+    match elements {\n+        individual_evec(args) => count = args.len(),\n+        repeating_evec(_, len) => count = len\n+    }\n+\n     let vec_ty = node_id_type(bcx, id);\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -151,13 +172,12 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n             {bcx: bcx, val: v, dataptr: v}\n           }\n           ast::vstore_slice(_) {\n-            let n = vec::len(args);\n             // Make a fake type to use for the cleanup\n             let ty = ty::mk_evec(bcx.tcx(),\n                                  {ty: unit_ty, mutbl: ast::m_mutbl},\n-                                 ty::vstore_fixed(n));\n+                                 ty::vstore_fixed(count));\n \n-            let n = C_uint(ccx, n);\n+            let n = C_uint(ccx, count);\n             let vp = base::arrayalloca(bcx, llunitty, n);\n             add_clean(bcx, vp, ty);\n \n@@ -171,15 +191,13 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n             {bcx: bcx, val: p, dataptr: vp}\n           }\n           ast::vstore_uniq {\n-            let {bcx, val} = alloc_vec(bcx, unit_ty, args.len(),\n-                                       heap_exchange);\n+            let {bcx, val} = alloc_vec(bcx, unit_ty, count, heap_exchange);\n             add_clean_free(bcx, val, heap_exchange);\n             let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n-            let {bcx, val} = alloc_vec(bcx, unit_ty, args.len(),\n-                                       heap_shared);\n+            let {bcx, val} = alloc_vec(bcx, unit_ty, count, heap_shared);\n             add_clean_free(bcx, val, heap_shared);\n             let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n             {bcx: bcx, val: val, dataptr: dataptr}\n@@ -192,12 +210,38 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n     debug!{\"trans_evec: v: %s, dataptr: %s\",\n            val_str(ccx.tn, val),\n            val_str(ccx.tn, dataptr)};\n-    for vec::each(args) |e| {\n-        let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n-        bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n-        add_clean_temp_mem(bcx, lleltptr, unit_ty);\n-        vec::push(temp_cleanups, lleltptr);\n-        i += 1u;\n+    match elements {\n+        individual_evec(args) => {\n+            for vec::each(args) |e| {\n+                let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n+                bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n+                add_clean_temp_mem(bcx, lleltptr, unit_ty);\n+                vec::push(temp_cleanups, lleltptr);\n+                i += 1u;\n+            }\n+        }\n+        repeating_evec(e, len) => {\n+            // We make temporary space in the hope that this will be\n+            // friendlier to LLVM alias analysis.\n+            let lltmpspace = base::alloca(bcx, llunitty);\n+            bcx = base::trans_expr_save_in(bcx, e, lltmpspace);\n+            add_clean_temp_mem(bcx, lltmpspace, unit_ty);\n+            vec::push(temp_cleanups, lltmpspace);\n+            for len.timesi |i| {\n+                let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n+                if i == len - 1 {\n+                    // Move the last one in.\n+                    bcx = move_val(bcx, INIT, lleltptr,\n+                                   lval_owned(bcx, lltmpspace), unit_ty);\n+                } else {\n+                    // Copy all but the last one in.\n+                    let llval = load_if_immediate(bcx, lltmpspace, unit_ty);\n+                    bcx = copy_val(bcx, INIT, lleltptr, llval, unit_ty);\n+                }\n+                add_clean_temp_mem(bcx, lleltptr, unit_ty);\n+                vec::push(temp_cleanups, lleltptr);\n+            }\n+        }\n     }\n \n     for vec::each(temp_cleanups) |cln| { revoke_clean(bcx, cln); }\n@@ -219,13 +263,17 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n fn trans_vstore(bcx: block, e: @ast::expr,\n                 v: ast::vstore, dest: dest) -> block {\n     alt e.node {\n-      ast::expr_lit(@{node: ast::lit_str(s), span: _}) {\n+      ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n         return trans_estr(bcx, s, some(v), dest);\n       }\n-      ast::expr_vec(es, mutbl) {\n-        return trans_evec(bcx, es, v, e.id, dest);\n+      ast::expr_vec(es, mutbl) => {\n+        return trans_evec(bcx, individual_evec(es), v, e.id, dest);\n       }\n-      _ {\n+      ast::expr_repeat(element, count_expr, mutbl) => {\n+        let count = ty::eval_repeat_count(bcx.tcx(), count_expr, e.span);\n+        return trans_evec(bcx, repeating_evec(element, count), v, e.id, dest);\n+      }\n+      _ => {\n         bcx.sess().span_bug(e.span, ~\"vstore on non-sequence type\");\n       }\n     }"}, {"sha": "29dbccc43f5ed7d6d7cb9eb54e9158e160813e93", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "patch": "@@ -169,6 +169,7 @@ export terr_proto_mismatch;\n export terr_ret_style_mismatch;\n export purity_to_str;\n export param_tys_in_type;\n+export eval_repeat_count;\n \n // Data types\n \n@@ -3170,6 +3171,26 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n     return t_norm;\n }\n \n+// Returns the repeat count for a repeating vector expression.\n+fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr, span: span) -> uint {\n+    match const_eval::eval_const_expr(tcx, count_expr) {\n+        const_eval::const_int(count) => return count as uint,\n+        const_eval::const_uint(count) => return count as uint,\n+        const_eval::const_float(count) => {\n+            tcx.sess.span_err(span,\n+                              ~\"expected signed or unsigned integer for \\\n+                                repeat count but found float\");\n+            return count as uint;\n+        }\n+        const_eval::const_str(_) => {\n+            tcx.sess.span_err(span,\n+                              ~\"expected signed or unsigned integer for \\\n+                                repeat count but found string\");\n+            return 0;\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "1297a39c5208ac71bbb61b44358f900702c73572", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "patch": "@@ -1150,26 +1150,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                  is_loop_body, some(fcx));\n     }\n \n-    fn eval_repeat_count(fcx: @fn_ctxt, count_expr: @ast::expr, span: span)\n-                      -> uint {\n-        let tcx = fcx.ccx.tcx;\n-        match const_eval::eval_const_expr(tcx, count_expr) {\n-            const_eval::const_int(count) => return count as uint,\n-            const_eval::const_uint(count) => return count as uint,\n-            const_eval::const_float(count) => {\n-                tcx.sess.span_err(span,\n-                                  ~\"expected signed or unsigned integer for \\\n-                                    repeat count but found float\");\n-                return count as uint;\n-            }\n-            const_eval::const_str(_) => {\n-                tcx.sess.span_err(span,\n-                                  ~\"expected signed or unsigned integer for \\\n-                                    repeat count but found string\");\n-                return 0;\n-            }\n-        }\n-    }\n \n     // Check field access expressions\n     fn check_field(fcx: @fn_ctxt, expr: @ast::expr, is_callee: bool,\n@@ -1284,7 +1264,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n-            let count = eval_repeat_count(fcx, count_expr, expr.span);\n+            let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n             fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n             let t: ty::t = fcx.infcx.next_ty_var();\n@@ -1642,7 +1622,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_repeat(element, count_expr, mutbl) {\n-        let count = eval_repeat_count(fcx, count_expr, expr.span);\n+        let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n         fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n         let t: ty::t = fcx.infcx.next_ty_var();\n         bot |= check_expr_with(fcx, element, t);"}, {"sha": "e6b9e2b408a536a194b05184e41cf33fda2b7f13", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=51a5a4ad0e2501b260a8059a72e4b0eebe78d6f9", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let x = [ @[true], ..512 ];\n+    let y = [ 0, ..1 ];\n+    error!(\"%?\", x);\n+    error!(\"%?\", y);\n+}\n+"}]}