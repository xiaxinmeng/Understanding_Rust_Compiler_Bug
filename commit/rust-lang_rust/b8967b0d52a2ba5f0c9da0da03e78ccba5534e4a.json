{"sha": "b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "node_id": "C_kwDOAAsO6NoAKGI4OTY3YjBkNTJhMmJhNWYwYzlkYTBkYTAzZTc4Y2NiYTU1MzRlNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-21T22:53:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-21T22:53:45Z"}, "message": "Auto merge of #94225 - matthiaskrgr:rollup-0728x8n, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #91192 (Some improvements to the async docs)\n - #94143 (rustc_const_eval: adopt let else in more places)\n - #94156 (Gracefully handle non-UTF-8 string slices when pretty printing)\n - #94186 (Update pin_static_ref stabilization version.)\n - #94189 (Implement LowerHex on Scalar to clean up their display in rustdoc)\n - #94190 (Use Metadata::modified instead of FileTime::from_last_modification_ti\u2026)\n - #94203 (CTFE engine: Scalar: expose size-generic to_(u)int methods)\n - #94211 (Better error if the user tries to do assignment ... else)\n - #94215 (trait system: comments and small nonfunctional changes)\n - #94220 (Correctly handle miniz_oxide extern crate declaration)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e712e87edb0359b0731802431e9cebb88c47d82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e712e87edb0359b0731802431e9cebb88c47d82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "html_url": "https://github.com/rust-lang/rust/commit/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a8cc7df1d65554a4d40825b0490c93ac0f0236", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a8cc7df1d65554a4d40825b0490c93ac0f0236", "html_url": "https://github.com/rust-lang/rust/commit/03a8cc7df1d65554a4d40825b0490c93ac0f0236"}, {"sha": "ed3530925e8ddad97b152274948675a3eb8bb6ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3530925e8ddad97b152274948675a3eb8bb6ae", "html_url": "https://github.com/rust-lang/rust/commit/ed3530925e8ddad97b152274948675a3eb8bb6ae"}], "stats": {"total": 504, "additions": 260, "deletions": 244}, "files": [{"sha": "533c32f807df6d5fbb1325a21401f6f63bb4fc88", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -231,9 +231,8 @@ pub fn eval_to_const_value_raw_provider<'tcx>(\n     // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n     if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n         let ty = key.value.instance.ty(tcx, key.param_env);\n-        let substs = match ty.kind() {\n-            ty::FnDef(_, substs) => substs,\n-            _ => bug!(\"intrinsic with type {:?}\", ty),\n+        let ty::FnDef(_, substs) = ty.kind() else {\n+            bug!(\"intrinsic with type {:?}\", ty);\n         };\n         return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n             let span = tcx.def_span(def_id);"}, {"sha": "b2019ce40c3eaa2d2889d70ab2568b07d99d148b", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -318,15 +318,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n \n         // CTFE-specific intrinsics.\n-        let (dest, ret) = match ret {\n-            None => {\n-                return Err(ConstEvalErrKind::NeedsRfc(format!(\n-                    \"calling intrinsic `{}`\",\n-                    intrinsic_name\n-                ))\n-                .into());\n-            }\n-            Some(p) => p,\n+        let Some((dest, ret)) = ret else {\n+            return Err(ConstEvalErrKind::NeedsRfc(format!(\n+                \"calling intrinsic `{}`\",\n+                intrinsic_name\n+            ))\n+            .into());\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {"}, {"sha": "ab50c709143fd0dc0590f086fd1c491bc145f82d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -631,15 +631,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n-                let (unsized_size, unsized_align) =\n-                    match self.size_and_align_of(metadata, &field)? {\n-                        Some(size_and_align) => size_and_align,\n-                        None => {\n-                            // A field with an extern type. We don't know the actual dynamic size\n-                            // or the alignment.\n-                            return Ok(None);\n-                        }\n-                    };\n+                let Some((unsized_size, unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n+                    // A field with an extern type. We don't know the actual dynamic size\n+                    // or the alignment.\n+                    return Ok(None);\n+                };\n \n                 // FIXME (#26403, #27023): We should be adding padding\n                 // to `sized_size` (to accommodate the `unsized_align`"}, {"sha": "b1f50bc56c908c88a2c5d5afa682692b04d8e0a7", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -84,22 +84,19 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     trace!(\"intern_shallow {:?} with {:?}\", alloc_id, mode);\n     // remove allocation\n     let tcx = ecx.tcx;\n-    let (kind, mut alloc) = match ecx.memory.alloc_map.remove(&alloc_id) {\n-        Some(entry) => entry,\n-        None => {\n-            // Pointer not found in local memory map. It is either a pointer to the global\n-            // map, or dangling.\n-            // If the pointer is dangling (neither in local nor global memory), we leave it\n-            // to validation to error -- it has the much better error messages, pointing out where\n-            // in the value the dangling reference lies.\n-            // The `delay_span_bug` ensures that we don't forget such a check in validation.\n-            if tcx.get_global_alloc(alloc_id).is_none() {\n-                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n-            }\n-            // treat dangling pointers like other statics\n-            // just to stop trying to recurse into them\n-            return Some(IsStaticOrFn);\n+    let Some((kind, mut alloc)) = ecx.memory.alloc_map.remove(&alloc_id) else {\n+        // Pointer not found in local memory map. It is either a pointer to the global\n+        // map, or dangling.\n+        // If the pointer is dangling (neither in local nor global memory), we leave it\n+        // to validation to error -- it has the much better error messages, pointing out where\n+        // in the value the dangling reference lies.\n+        // The `delay_span_bug` ensures that we don't forget such a check in validation.\n+        if tcx.get_global_alloc(alloc_id).is_none() {\n+            tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n         }\n+        // treat dangling pointers like other statics\n+        // just to stop trying to recurse into them\n+        return Some(IsStaticOrFn);\n     };\n     // This match is just a canary for future changes to `MemoryKind`, which most likely need\n     // changes in this function."}, {"sha": "73e7d862ad64186cacb0a7d6f22b4c167f79d600", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -291,21 +291,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             );\n         }\n \n-        let (alloc_kind, mut alloc) = match self.alloc_map.remove(&alloc_id) {\n-            Some(alloc) => alloc,\n-            None => {\n-                // Deallocating global memory -- always an error\n-                return Err(match self.tcx.get_global_alloc(alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => {\n-                        err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n-                    }\n-                    Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                        err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n-                    }\n-                    None => err_ub!(PointerUseAfterFree(alloc_id)),\n+        let Some((alloc_kind, mut alloc)) = self.alloc_map.remove(&alloc_id) else {\n+            // Deallocating global memory -- always an error\n+            return Err(match self.tcx.get_global_alloc(alloc_id) {\n+                Some(GlobalAlloc::Function(..)) => {\n+                    err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n                 }\n-                .into());\n+                Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n+                    err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n+                }\n+                None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n+            .into());\n         };\n \n         if alloc.mutability == Mutability::Not {\n@@ -957,9 +954,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        let alloc_ref = match self.get(ptr, size, Align::ONE)? {\n-            Some(a) => a,\n-            None => return Ok(&[]), // zero-sized access\n+        let Some(alloc_ref) = self.get(ptr, size, Align::ONE)? else {\n+            // zero-sized access\n+            return Ok(&[]);\n         };\n         // Side-step AllocRef and directly access the underlying bytes more efficiently.\n         // (We are staying inside the bounds here so all is good.)\n@@ -983,17 +980,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n \n         let size = Size::from_bytes(len);\n-        let alloc_ref = match self.get_mut(ptr, size, Align::ONE)? {\n-            Some(alloc_ref) => alloc_ref,\n-            None => {\n-                // zero-sized access\n-                assert_matches!(\n-                    src.next(),\n-                    None,\n-                    \"iterator said it was empty but returned an element\"\n-                );\n-                return Ok(());\n-            }\n+        let Some(alloc_ref) = self.get_mut(ptr, size, Align::ONE)? else {\n+            // zero-sized access\n+            assert_matches!(\n+                src.next(),\n+                None,\n+                \"iterator said it was empty but returned an element\"\n+            );\n+            return Ok(());\n         };\n \n         // Side-step AllocRef and directly access the underlying bytes more efficiently.\n@@ -1043,18 +1037,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let (src_alloc_id, src_offset, src) = match src_parts {\n-            None => return Ok(()), // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n-            Some(src_ptr) => src_ptr,\n+        let Some((src_alloc_id, src_offset, src)) = src_parts else {\n+            // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n+            return Ok(());\n         };\n         let src_alloc = self.get_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n         M::memory_read(&self.extra, &src_alloc.extra, src.provenance, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let (dest_alloc_id, dest_offset, dest) = match dest_parts {\n-            None => return Ok(()), // Zero-sized *destiantion*.\n-            Some(dest_ptr) => dest_ptr,\n+        let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n+            // Zero-sized *destination*.\n+            return Ok(());\n         };\n \n         // This checks relocation edges on the src, which needs to happen before"}, {"sha": "60e915a7eee113ae26becdc2e30edc132c209a8a", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -258,15 +258,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let alloc = match self.get_alloc(mplace)? {\n-            Some(ptr) => ptr,\n-            None => {\n-                return Ok(Some(ImmTy {\n-                    // zero-sized type\n-                    imm: Scalar::ZST.into(),\n-                    layout: mplace.layout,\n-                }));\n-            }\n+        let Some(alloc) = self.get_alloc(mplace)? else {\n+            return Ok(Some(ImmTy {\n+                // zero-sized type\n+                imm: Scalar::ZST.into(),\n+                layout: mplace.layout,\n+            }));\n         };\n \n         match mplace.layout.abi {"}, {"sha": "e9b2df53a331370f1a42ccc1f24b3766eda0b044", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -420,9 +420,8 @@ where\n     ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n-        let stride = match base.layout.fields {\n-            FieldsShape::Array { stride, .. } => stride,\n-            _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n+        let FieldsShape::Array { stride, .. } = base.layout.fields else {\n+            span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\");\n         };\n         let layout = base.layout.field(self, 0);\n         let dl = &self.tcx.data_layout;\n@@ -747,9 +746,9 @@ where\n \n         // Invalid places are a thing: the return place of a diverging function\n         let tcx = *self.tcx;\n-        let mut alloc = match self.get_alloc_mut(dest)? {\n-            Some(a) => a,\n-            None => return Ok(()), // zero-sized access\n+        let Some(mut alloc) = self.get_alloc_mut(dest)? else {\n+            // zero-sized access\n+            return Ok(());\n         };\n \n         // FIXME: We should check that there are dest.layout.size many bytes available in"}, {"sha": "0701e0ded9703f89a2af1cb0fd746fe192168f77", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -46,15 +46,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let loc = match self.frame().loc {\n-            Ok(loc) => loc,\n-            Err(_) => {\n-                // We are unwinding and this fn has no cleanup code.\n-                // Just go on unwinding.\n-                trace!(\"unwinding: skipping frame\");\n-                self.pop_stack_frame(/* unwinding */ true)?;\n-                return Ok(true);\n-            }\n+        let Ok(loc) = self.frame().loc else {\n+            // We are unwinding and this fn has no cleanup code.\n+            // Just go on unwinding.\n+            trace!(\"unwinding: skipping frame\");\n+            self.pop_stack_frame(/* unwinding */ true)?;\n+            return Ok(true);\n         };\n         let basic_block = &self.body().basic_blocks()[loc.block];\n "}, {"sha": "8094bf0cf2e2f7361ec1819a40ce85e74dc09641", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -321,10 +321,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let (body, instance) =\n-                    match M::find_mir_or_eval_fn(self, instance, caller_abi, args, ret, unwind)? {\n-                        Some(body) => body,\n-                        None => return Ok(()),\n+                let Some((body, instance)) =\n+                    M::find_mir_or_eval_fn(self, instance, caller_abi, args, ret, unwind)? else {\n+                        return Ok(());\n                     };\n \n                 // Compute callee information using the `instance` returned by"}, {"sha": "19c6449078d5b236d9a6b40b22ad6eae0ad8c098", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -697,7 +697,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 this.ecx.read_discriminant(op),\n                 this.path,\n                 err_ub!(InvalidTag(val)) =>\n-                    { \"{}\", val } expected { \"a valid enum tag\" },\n+                    { \"{:x}\", val } expected { \"a valid enum tag\" },\n                 err_ub!(InvalidUninitBytes(None)) =>\n                     { \"uninitialized bytes\" } expected { \"a valid enum tag\" },\n                 err_unsup!(ReadPointerAsBytes) =>\n@@ -851,12 +851,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path.\n-                let alloc = match self.ecx.memory.get(mplace.ptr, size, mplace.align)? {\n-                    Some(a) => a,\n-                    None => {\n-                        // Size 0, nothing more to check.\n-                        return Ok(());\n-                    }\n+                let Some(alloc) = self.ecx.memory.get(mplace.ptr, size, mplace.align)? else {\n+                    // Size 0, nothing more to check.\n+                    return Ok(());\n                 };\n \n                 let allow_uninit_and_ptr = !M::enforce_number_validity(self.ecx);"}, {"sha": "652f1c94a6149f06d406a512c1cab6b9c9834e49", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -134,11 +134,8 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n             .find(|(_, block)| matches!(block.terminator().kind, TerminatorKind::Return))\n             .map(|(bb, _)| bb);\n \n-        let return_block = match return_block {\n-            None => {\n-                return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty(), tainted_by_errors);\n-            }\n-            Some(bb) => bb,\n+        let Some(return_block) = return_block else {\n+            return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty(), tainted_by_errors);\n         };\n \n         let return_loc = ccx.body.terminator_loc(return_block);"}, {"sha": "30764f689c95c379df9a00ac94c4027044c56c1a", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -747,15 +747,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n-                let rhs = match statement.kind {\n-                    StatementKind::Assign(box (_, ref mut rhs)) => rhs,\n-                    _ => {\n-                        span_bug!(\n-                            statement.source_info.span,\n-                            \"{:?} is not an assignment\",\n-                            statement\n-                        );\n-                    }\n+                let StatementKind::Assign(box (_, ref mut rhs)) = statement.kind else {\n+                    span_bug!(\n+                        statement.source_info.span,\n+                        \"{:?} is not an assignment\",\n+                        statement\n+                    );\n                 };\n \n                 ("}, {"sha": "e4528b68907838120b98a9909ce029bb42cda750", "filename": "compiler/rustc_const_eval/src/util/alignment.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -15,12 +15,9 @@ where\n     L: HasLocalDecls<'tcx>,\n {\n     debug!(\"is_disaligned({:?})\", place);\n-    let pack = match is_within_packed(tcx, local_decls, place) {\n-        None => {\n-            debug!(\"is_disaligned({:?}) - not within packed\", place);\n-            return false;\n-        }\n-        Some(pack) => pack,\n+    let Some(pack) = is_within_packed(tcx, local_decls, place) else {\n+        debug!(\"is_disaligned({:?}) - not within packed\", place);\n+        return false;\n     };\n \n     let ty = place.ty(local_decls, tcx).ty;"}, {"sha": "5fe2a1fb84bd76a8521db89806ed981c53308325", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -132,11 +132,11 @@ type ObligationTreeIdGenerator =\n     std::iter::Map<std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n \n pub struct ObligationForest<O: ForestObligation> {\n-    /// The list of obligations. In between calls to `process_obligations`,\n+    /// The list of obligations. In between calls to [Self::process_obligations],\n     /// this list only contains nodes in the `Pending` or `Waiting` state.\n     ///\n     /// `usize` indices are used here and throughout this module, rather than\n-    /// `rustc_index::newtype_index!` indices, because this code is hot enough\n+    /// [`rustc_index::newtype_index!`] indices, because this code is hot enough\n     /// that the `u32`-to-`usize` conversions that would be required are\n     /// significant, and space considerations are not important.\n     nodes: Vec<Node<O>>,\n@@ -146,10 +146,11 @@ pub struct ObligationForest<O: ForestObligation> {\n \n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n-    /// comments in `process_obligation` for details.\n+    /// comments in [`Self::process_obligation` for details.\n     active_cache: FxHashMap<O::CacheKey, usize>,\n \n-    /// A vector reused in compress() and find_cycles_from_node(), to avoid allocating new vectors.\n+    /// A vector reused in [Self::compress()] and [Self::find_cycles_from_node()],\n+    /// to avoid allocating new vectors.\n     reused_node_vec: Vec<usize>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,"}, {"sha": "652f5abab151f6659b6bf277ba8bd6e7f51cb358", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -123,7 +123,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         result\n     }\n \n-    /// See `infer::region_constraints::RegionConstraintCollector::leak_check`.\n+    /// See [RegionConstraintCollector::leak_check][1].\n+    ///\n+    /// [1]: crate::infer::region_constraints::RegionConstraintCollector::leak_check\n     pub fn leak_check(\n         &self,\n         overly_polymorphic: bool,"}, {"sha": "817aaf10053efdf1812244e07f0fde928e6da47b", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -100,6 +100,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n struct LeakCheck<'me, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     universe_at_start_of_snapshot: ty::UniverseIndex,\n+    /// Only used when reporting region errors.\n     overly_polymorphic: bool,\n     mini_graph: &'me MiniGraph<'tcx>,\n     rcc: &'me RegionConstraintCollector<'me, 'tcx>,"}, {"sha": "c5866924eda43d2408b7a5a9a0d804779f095560", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -370,7 +370,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidChar(c) => {\n                 write!(f, \"interpreting an invalid 32-bit value as a char: 0x{:08x}\", c)\n             }\n-            InvalidTag(val) => write!(f, \"enum value has invalid tag: {}\", val),\n+            InvalidTag(val) => write!(f, \"enum value has invalid tag: {:x}\", val),\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {:?} as function pointer but it does not point to a function\", p)\n             }"}, {"sha": "acf7847de54169453403e57d5a37b5f4bab963d7", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -153,7 +153,16 @@ impl<Tag: Provenance> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n-            Scalar::Int(int) => write!(f, \"{:?}\", int),\n+            Scalar::Int(int) => write!(f, \"{}\", int),\n+        }\n+    }\n+}\n+\n+impl<Tag: Provenance> fmt::LowerHex for Scalar<Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n+            Scalar::Int(int) => write!(f, \"0x{:x}\", int),\n         }\n     }\n }\n@@ -370,78 +379,82 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         }\n     }\n \n+    /// Converts the scalar to produce an unsigned integer of the given size.\n+    /// Fails if the scalar is a pointer.\n     #[inline]\n-    fn to_unsigned_with_bit_width(self, bits: u64) -> InterpResult<'static, u128> {\n-        let sz = Size::from_bits(bits);\n-        self.to_bits(sz)\n+    pub fn to_uint(self, size: Size) -> InterpResult<'static, u128> {\n+        self.to_bits(size)\n     }\n \n     /// Converts the scalar to produce a `u8`. Fails if the scalar is a pointer.\n     pub fn to_u8(self) -> InterpResult<'static, u8> {\n-        self.to_unsigned_with_bit_width(8).map(|v| u8::try_from(v).unwrap())\n+        self.to_uint(Size::from_bits(8)).map(|v| u8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce a `u16`. Fails if the scalar is a pointer.\n     pub fn to_u16(self) -> InterpResult<'static, u16> {\n-        self.to_unsigned_with_bit_width(16).map(|v| u16::try_from(v).unwrap())\n+        self.to_uint(Size::from_bits(16)).map(|v| u16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce a `u32`. Fails if the scalar is a pointer.\n     pub fn to_u32(self) -> InterpResult<'static, u32> {\n-        self.to_unsigned_with_bit_width(32).map(|v| u32::try_from(v).unwrap())\n+        self.to_uint(Size::from_bits(32)).map(|v| u32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce a `u64`. Fails if the scalar is a pointer.\n     pub fn to_u64(self) -> InterpResult<'static, u64> {\n-        self.to_unsigned_with_bit_width(64).map(|v| u64::try_from(v).unwrap())\n+        self.to_uint(Size::from_bits(64)).map(|v| u64::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce a `u128`. Fails if the scalar is a pointer.\n     pub fn to_u128(self) -> InterpResult<'static, u128> {\n-        self.to_unsigned_with_bit_width(128)\n+        self.to_uint(Size::from_bits(128))\n     }\n \n+    /// Converts the scalar to produce a machine-pointer-sized unsigned integer.\n+    /// Fails if the scalar is a pointer.\n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n-        let b = self.to_bits(cx.data_layout().pointer_size)?;\n+        let b = self.to_uint(cx.data_layout().pointer_size)?;\n         Ok(u64::try_from(b).unwrap())\n     }\n \n+    /// Converts the scalar to produce a signed integer of the given size.\n+    /// Fails if the scalar is a pointer.\n     #[inline]\n-    fn to_signed_with_bit_width(self, bits: u64) -> InterpResult<'static, i128> {\n-        let sz = Size::from_bits(bits);\n-        let b = self.to_bits(sz)?;\n-        Ok(sz.sign_extend(b) as i128)\n+    pub fn to_int(self, size: Size) -> InterpResult<'static, i128> {\n+        let b = self.to_bits(size)?;\n+        Ok(size.sign_extend(b) as i128)\n     }\n \n     /// Converts the scalar to produce an `i8`. Fails if the scalar is a pointer.\n     pub fn to_i8(self) -> InterpResult<'static, i8> {\n-        self.to_signed_with_bit_width(8).map(|v| i8::try_from(v).unwrap())\n+        self.to_int(Size::from_bits(8)).map(|v| i8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i16`. Fails if the scalar is a pointer.\n     pub fn to_i16(self) -> InterpResult<'static, i16> {\n-        self.to_signed_with_bit_width(16).map(|v| i16::try_from(v).unwrap())\n+        self.to_int(Size::from_bits(16)).map(|v| i16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i32`. Fails if the scalar is a pointer.\n     pub fn to_i32(self) -> InterpResult<'static, i32> {\n-        self.to_signed_with_bit_width(32).map(|v| i32::try_from(v).unwrap())\n+        self.to_int(Size::from_bits(32)).map(|v| i32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i64`. Fails if the scalar is a pointer.\n     pub fn to_i64(self) -> InterpResult<'static, i64> {\n-        self.to_signed_with_bit_width(64).map(|v| i64::try_from(v).unwrap())\n+        self.to_int(Size::from_bits(64)).map(|v| i64::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i128`. Fails if the scalar is a pointer.\n     pub fn to_i128(self) -> InterpResult<'static, i128> {\n-        self.to_signed_with_bit_width(128)\n+        self.to_int(Size::from_bits(128))\n     }\n \n+    /// Converts the scalar to produce a machine-pointer-sized signed integer.\n+    /// Fails if the scalar is a pointer.\n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n-        let sz = cx.data_layout().pointer_size;\n-        let b = self.to_bits(sz)?;\n-        let b = sz.sign_extend(b) as i128;\n+        let b = self.to_int(cx.data_layout().pointer_size)?;\n         Ok(i64::try_from(b).unwrap())\n     }\n \n@@ -456,11 +469,6 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         // Going through `u64` to check size and truncation.\n         Ok(Double::from_bits(self.to_u64()?.into()))\n     }\n-\n-    // FIXME: Replace current `impl Display for Scalar` with `impl LowerHex`.\n-    pub fn rustdoc_display(&self) -> String {\n-        if let Scalar::Int(int) = self { int.to_string() } else { self.to_string() }\n-    }\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n@@ -494,7 +502,7 @@ impl<Tag: Provenance> fmt::Display for ScalarMaybeUninit<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUninit::Uninit => write!(f, \"uninitialized bytes\"),\n-            ScalarMaybeUninit::Scalar(s) => write!(f, \"{}\", s),\n+            ScalarMaybeUninit::Scalar(s) => write!(f, \"{:x}\", s),\n         }\n     }\n }"}, {"sha": "359e4f5e58147c4e2f28d42e507459504273a541", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1435,8 +1435,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // relocations (we have an active `str` reference here). We don't use this\n                 // result to affect interpreter execution.\n                 let slice = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-                p!(write(\"{:?}\", s));\n+                p!(write(\"{:?}\", String::from_utf8_lossy(slice)));\n                 Ok(self)\n             }\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {"}, {"sha": "965e6a6ca3f2727c8a8ec50019c6ea94e68ed695", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -103,6 +103,16 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n             }?;\n+            if matches!(e.kind, ExprKind::Assign(..)) && self.eat_keyword(kw::Else) {\n+                let bl = self.parse_block()?;\n+                // Destructuring assignment ... else.\n+                // This is not allowed, but point it out in a nice way.\n+                let mut err = self.struct_span_err(\n+                    e.span.to(bl.span),\n+                    \"<assignment> ... else { ... } is not allowed\",\n+                );\n+                err.emit();\n+            }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n             self.error_outer_attrs(&attrs.take_for_recovery());"}, {"sha": "8b76f3f7151063de3cd84d48bce7b9e8642f772e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -160,20 +160,12 @@ fn overlap<'cx, 'tcx>(\n     );\n \n     selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(\n-            selcx,\n-            skip_leak_check,\n-            impl1_def_id,\n-            impl2_def_id,\n-            overlap_mode,\n-            snapshot,\n-        )\n+        overlap_within_probe(selcx, impl1_def_id, impl2_def_id, overlap_mode, snapshot)\n     })\n }\n \n fn overlap_within_probe<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n-    skip_leak_check: SkipLeakCheck,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     overlap_mode: OverlapMode,\n@@ -207,11 +199,11 @@ fn overlap_within_probe<'cx, 'tcx>(\n         }\n     }\n \n-    if !skip_leak_check.is_yes() {\n-        if infcx.leak_check(true, snapshot).is_err() {\n-            debug!(\"overlap: leak check failed\");\n-            return None;\n-        }\n+    // We disable the leak when when creating the `snapshot` by using\n+    // `infcx.probe_maybe_disable_leak_check`.\n+    if infcx.leak_check(true, snapshot).is_err() {\n+        debug!(\"overlap: leak check failed\");\n+        return None;\n     }\n \n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();"}, {"sha": "362d669f867e01ac8d86d147553a417b8e3479fa", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             return ProcessResult::Unchanged;\n         }\n \n-        self.progress_changed_obligations(pending_obligation)\n+        self.process_changed_obligations(pending_obligation)\n     }\n \n     fn process_backedge<'c, I>(\n@@ -338,7 +338,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     // actually uses this, so move this part of the code\n     // out of that loop.\n     #[inline(never)]\n-    fn progress_changed_obligations(\n+    fn process_changed_obligations(\n         &mut self,\n         pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {"}, {"sha": "4d7c9ef89e62b4915e80d762b3ae8f2db8e9da3a", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -389,7 +389,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         for bound in matching_bounds {\n             // FIXME(oli-obk): it is suspicious that we are dropping the constness and\n             // polarity here.\n-            let wc = self.evaluate_where_clause(stack, bound.map_bound(|t| t.trait_ref))?;\n+            let wc = self.where_clause_may_apply(stack, bound.map_bound(|t| t.trait_ref))?;\n             if wc.may_apply() {\n                 candidates.vec.push(ParamCandidate(bound));\n             }"}, {"sha": "5b646c6d4477c55231f62cec6548468992ce810e", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1481,7 +1481,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|_| ())\n     }\n \n-    fn evaluate_where_clause<'o>(\n+    fn where_clause_may_apply<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n         where_clause_trait_ref: ty::PolyTraitRef<'tcx>,"}, {"sha": "f29d3e1e98b724777673fef70d399b4408eb2baa", "filename": "library/core/src/future/future.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -5,7 +5,7 @@ use crate::ops;\n use crate::pin::Pin;\n use crate::task::{Context, Poll};\n \n-/// A future represents an asynchronous computation.\n+/// A future represents an asynchronous computation obtained by use of [`async`].\n ///\n /// A future is a value that might not have finished computing yet. This kind of\n /// \"asynchronous value\" makes it possible for a thread to continue doing useful\n@@ -23,6 +23,7 @@ use crate::task::{Context, Poll};\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `.await` the value.\n ///\n+/// [`async`]: ../../std/keyword.async.html\n /// [`Waker`]: crate::task::Waker\n #[doc(notable_trait)]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]"}, {"sha": "9b89f766c67bf648779c63e1ddd4df8a555232dc", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1,6 +1,13 @@\n #![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n-//! Asynchronous values.\n+//! Asynchronous basic functionality.\n+//!\n+//! Please see the fundamental [`async`] and [`await`] keywords and the [async book]\n+//! for more information on asynchronous programming in Rust.\n+//!\n+//! [`async`]: ../../std/keyword.async.html\n+//! [`await`]: ../../std/keyword.await.html\n+//! [async book]: https://rust-lang.github.io/async-book/\n \n use crate::{\n     ops::{Generator, GeneratorState},"}, {"sha": "e2b0e90e2bf7ddfcfae9d6e3d18faa39dcb0a76e", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -805,7 +805,7 @@ impl<T: ?Sized> Pin<&'static T> {\n     ///\n     /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n     /// never ends.\n-    #[stable(feature = \"pin_static_ref\", since = \"1.60.0\")]\n+    #[stable(feature = \"pin_static_ref\", since = \"1.61.0\")]\n     #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n     pub const fn static_ref(r: &'static T) -> Pin<&'static T> {\n         // SAFETY: The 'static borrow guarantees the data will not be\n@@ -858,7 +858,7 @@ impl<T: ?Sized> Pin<&'static mut T> {\n     ///\n     /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n     /// never ends.\n-    #[stable(feature = \"pin_static_ref\", since = \"1.60.0\")]\n+    #[stable(feature = \"pin_static_ref\", since = \"1.61.0\")]\n     #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n     pub const fn static_mut(r: &'static mut T) -> Pin<&'static mut T> {\n         // SAFETY: The 'static borrow guarantees the data will not be"}, {"sha": "5b76259afc11de8c0bf7f6830e1c33be675fae3e", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -2203,37 +2203,39 @@ mod where_keyword {}\n ///\n /// Use `async` in front of `fn`, `closure`, or a `block` to turn the marked code into a `Future`.\n /// As such the code will not be run immediately, but will only be evaluated when the returned\n-/// future is `.await`ed.\n+/// future is [`.await`]ed.\n ///\n-/// We have written an [async book] detailing async/await and trade-offs compared to using threads.\n+/// We have written an [async book] detailing `async`/`await` and trade-offs compared to using threads.\n ///\n /// ## Editions\n ///\n /// `async` is a keyword from the 2018 edition onwards.\n ///\n-/// It is available for use in stable rust from version 1.39 onwards.\n+/// It is available for use in stable Rust from version 1.39 onwards.\n ///\n /// [`Future`]: future::Future\n+/// [`.await`]: ../std/keyword.await.html\n /// [async book]: https://rust-lang.github.io/async-book/\n mod async_keyword {}\n \n #[doc(keyword = \"await\")]\n //\n /// Suspend execution until the result of a [`Future`] is ready.\n ///\n-/// `.await`ing a future will suspend the current function's execution until the `executor`\n+/// `.await`ing a future will suspend the current function's execution until the executor\n /// has run the future to completion.\n ///\n-/// Read the [async book] for details on how async/await and executors work.\n+/// Read the [async book] for details on how [`async`]/`await` and executors work.\n ///\n /// ## Editions\n ///\n /// `await` is a keyword from the 2018 edition onwards.\n ///\n-/// It is available for use in stable rust from version 1.39 onwards.\n+/// It is available for use in stable Rust from version 1.39 onwards.\n ///\n /// [`Future`]: future::Future\n /// [async book]: https://rust-lang.github.io/async-book/\n+/// [`async`]: ../std/keyword.async.html\n mod await_keyword {}\n \n #[doc(keyword = \"dyn\")]"}, {"sha": "5dc586d3a2adf61ab1fc87f01cb7c26d598064d4", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -366,6 +366,7 @@ extern crate unwind;\n \n #[doc(masked)]\n #[allow(unused_extern_crates)]\n+#[cfg(feature = \"miniz_oxide\")]\n extern crate miniz_oxide;\n \n // During testing, this crate is not actually the \"real\" std library, but rather"}, {"sha": "53226977fd881fae5cb06e4e0f2d6301e3bcaa3f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -17,7 +17,6 @@ use std::process::{exit, Command, Stdio};\n use std::str;\n \n use build_helper::{output, t, up_to_date};\n-use filetime::FileTime;\n use serde::Deserialize;\n \n use crate::builder::Cargo;\n@@ -1334,8 +1333,9 @@ pub fn run_cargo(\n                     .map(|s| s.starts_with('-') && s.ends_with(&extension[..]))\n                     .unwrap_or(false)\n         });\n-        let max = candidates\n-            .max_by_key(|&&(_, _, ref metadata)| FileTime::from_last_modification_time(metadata));\n+        let max = candidates.max_by_key(|&&(_, _, ref metadata)| {\n+            metadata.modified().expect(\"mtime should be available on all relevant OSes\")\n+        });\n         let path_to_add = match max {\n             Some(triple) => triple.0.to_str().unwrap(),\n             None => panic!(\"no output generated for {:?} {:?}\", prefix, extension),"}, {"sha": "20eea32560b27fdb5f00c5a0e87d2f7a441f9fc0", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -302,11 +302,7 @@ fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> S\n     // For all other types, fallback to the original `pretty_print_const`.\n     match (ct.val(), ct.ty().kind()) {\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n-            format!(\n-                \"{}{}\",\n-                format_integer_with_underscore_sep(&int.rustdoc_display()),\n-                ui.name_str()\n-            )\n+            format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n             let ty = tcx.lift(ct.ty()).unwrap();"}, {"sha": "9480566897f8d1003e0d6dbd2f0416ae0868ec34", "filename": "src/test/mir-opt/const_prop/invalid_constant.main.ConstProp.diff", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -2,63 +2,69 @@\n + // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/invalid_constant.rs:13:11: 13:11\n-      let _1: main::InvalidChar;           // in scope 0 at $DIR/invalid_constant.rs:19:9: 19:22\n-      let mut _3: main::InvalidTag;        // in scope 0 at $DIR/invalid_constant.rs:26:25: 26:46\n-      let mut _5: main::NoVariants;        // in scope 0 at $DIR/invalid_constant.rs:33:35: 33:56\n+      let mut _0: ();                      // return place in scope 0 at $DIR/invalid_constant.rs:15:11: 15:11\n+      let _1: main::InvalidChar;           // in scope 0 at $DIR/invalid_constant.rs:21:9: 21:22\n+      let mut _3: main::InvalidTag;        // in scope 0 at $DIR/invalid_constant.rs:28:25: 28:46\n+      let mut _5: main::NoVariants;        // in scope 0 at $DIR/invalid_constant.rs:35:35: 35:56\n       scope 1 {\n-          debug _invalid_char => _1;       // in scope 1 at $DIR/invalid_constant.rs:19:9: 19:22\n-          let _2: [main::InvalidTag; 1];   // in scope 1 at $DIR/invalid_constant.rs:26:9: 26:21\n+          debug _invalid_char => _1;       // in scope 1 at $DIR/invalid_constant.rs:21:9: 21:22\n+          let _2: [main::InvalidTag; 1];   // in scope 1 at $DIR/invalid_constant.rs:28:9: 28:21\n           scope 2 {\n-              debug _invalid_tag => _2;    // in scope 2 at $DIR/invalid_constant.rs:26:9: 26:21\n-              let _4: [main::NoVariants; 1]; // in scope 2 at $DIR/invalid_constant.rs:33:9: 33:31\n+              debug _invalid_tag => _2;    // in scope 2 at $DIR/invalid_constant.rs:28:9: 28:21\n+              let _4: [main::NoVariants; 1]; // in scope 2 at $DIR/invalid_constant.rs:35:9: 35:31\n               scope 3 {\n-                  debug _enum_without_variants => _4; // in scope 3 at $DIR/invalid_constant.rs:33:9: 33:31\n+                  debug _enum_without_variants => _4; // in scope 3 at $DIR/invalid_constant.rs:35:9: 35:31\n+                  let _6: main::Str<\"\ufffd\ufffd\ufffd\">; // in scope 3 at $DIR/invalid_constant.rs:39:9: 39:22\n+                  scope 4 {\n+                      debug _non_utf8_str => _6; // in scope 4 at $DIR/invalid_constant.rs:39:9: 39:22\n+                  }\n               }\n           }\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/invalid_constant.rs:19:9: 19:22\n--         _1 = const { InvalidChar { int: 0x110001 } }; // scope 0 at $DIR/invalid_constant.rs:19:25: 19:64\n-+         _1 = const InvalidChar { int: 1114113_u32, chr: {transmute(0x00110001): char} }; // scope 0 at $DIR/invalid_constant.rs:19:25: 19:64\n+          StorageLive(_1);                 // scope 0 at $DIR/invalid_constant.rs:21:9: 21:22\n+-         _1 = const { InvalidChar { int: 0x110001 } }; // scope 0 at $DIR/invalid_constant.rs:21:25: 21:64\n++         _1 = const InvalidChar { int: 1114113_u32, chr: {transmute(0x00110001): char} }; // scope 0 at $DIR/invalid_constant.rs:21:25: 21:64\n                                            // ty::Const\n                                            // + ty: main::InvalidChar\n -                                          // + val: Unevaluated(main::{constant#0}, [main::InvalidChar], None)\n +                                          // + val: Value(Scalar(0x00110001))\n                                            // mir::Constant\n-                                           // + span: $DIR/invalid_constant.rs:19:25: 19:64\n+                                           // + span: $DIR/invalid_constant.rs:21:25: 21:64\n -                                          // + literal: Const { ty: main::InvalidChar, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:7 ~ invalid_constant[726d]::main::{constant#0}), const_param_did: None }, substs: [main::InvalidChar], promoted: None }) }\n +                                          // + literal: Const { ty: main::InvalidChar, val: Value(Scalar(0x00110001)) }\n-          StorageLive(_2);                 // scope 1 at $DIR/invalid_constant.rs:26:9: 26:21\n-          StorageLive(_3);                 // scope 1 at $DIR/invalid_constant.rs:26:25: 26:46\n-          (_3.0: u32) = const 4_u32;       // scope 1 at $DIR/invalid_constant.rs:26:25: 26:46\n--         _2 = [move _3];                  // scope 1 at $DIR/invalid_constant.rs:26:24: 26:47\n-+         _2 = [const InvalidTag { int: 4_u32, e: Scalar(0x00000004): E }]; // scope 1 at $DIR/invalid_constant.rs:26:24: 26:47\n+          StorageLive(_2);                 // scope 1 at $DIR/invalid_constant.rs:28:9: 28:21\n+          StorageLive(_3);                 // scope 1 at $DIR/invalid_constant.rs:28:25: 28:46\n+          (_3.0: u32) = const 4_u32;       // scope 1 at $DIR/invalid_constant.rs:28:25: 28:46\n+-         _2 = [move _3];                  // scope 1 at $DIR/invalid_constant.rs:28:24: 28:47\n++         _2 = [const InvalidTag { int: 4_u32, e: Scalar(0x00000004): E }]; // scope 1 at $DIR/invalid_constant.rs:28:24: 28:47\n +                                          // ty::Const\n +                                          // + ty: main::InvalidTag\n +                                          // + val: Value(Scalar(0x00000004))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/invalid_constant.rs:26:24: 26:47\n++                                          // + span: $DIR/invalid_constant.rs:28:24: 28:47\n +                                          // + literal: Const { ty: main::InvalidTag, val: Value(Scalar(0x00000004)) }\n-          StorageDead(_3);                 // scope 1 at $DIR/invalid_constant.rs:26:46: 26:47\n-          StorageLive(_4);                 // scope 2 at $DIR/invalid_constant.rs:33:9: 33:31\n-          StorageLive(_5);                 // scope 2 at $DIR/invalid_constant.rs:33:35: 33:56\n-          (_5.0: u32) = const 0_u32;       // scope 2 at $DIR/invalid_constant.rs:33:35: 33:56\n--         _4 = [move _5];                  // scope 2 at $DIR/invalid_constant.rs:33:34: 33:57\n-+         _4 = [const NoVariants { int: 0_u32, empty: Scalar(<ZST>): Empty }]; // scope 2 at $DIR/invalid_constant.rs:33:34: 33:57\n+          StorageDead(_3);                 // scope 1 at $DIR/invalid_constant.rs:28:46: 28:47\n+          StorageLive(_4);                 // scope 2 at $DIR/invalid_constant.rs:35:9: 35:31\n+          StorageLive(_5);                 // scope 2 at $DIR/invalid_constant.rs:35:35: 35:56\n+          (_5.0: u32) = const 0_u32;       // scope 2 at $DIR/invalid_constant.rs:35:35: 35:56\n+-         _4 = [move _5];                  // scope 2 at $DIR/invalid_constant.rs:35:34: 35:57\n++         _4 = [const NoVariants { int: 0_u32, empty: Scalar(<ZST>): Empty }]; // scope 2 at $DIR/invalid_constant.rs:35:34: 35:57\n +                                          // ty::Const\n +                                          // + ty: main::NoVariants\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/invalid_constant.rs:33:34: 33:57\n++                                          // + span: $DIR/invalid_constant.rs:35:34: 35:57\n +                                          // + literal: Const { ty: main::NoVariants, val: Value(Scalar(0x00000000)) }\n-          StorageDead(_5);                 // scope 2 at $DIR/invalid_constant.rs:33:56: 33:57\n-          nop;                             // scope 0 at $DIR/invalid_constant.rs:13:11: 34:2\n-          StorageDead(_4);                 // scope 2 at $DIR/invalid_constant.rs:34:1: 34:2\n-          StorageDead(_2);                 // scope 1 at $DIR/invalid_constant.rs:34:1: 34:2\n-          StorageDead(_1);                 // scope 0 at $DIR/invalid_constant.rs:34:1: 34:2\n-          return;                          // scope 0 at $DIR/invalid_constant.rs:34:2: 34:2\n+          StorageDead(_5);                 // scope 2 at $DIR/invalid_constant.rs:35:56: 35:57\n+          StorageLive(_6);                 // scope 3 at $DIR/invalid_constant.rs:39:9: 39:22\n+          nop;                             // scope 0 at $DIR/invalid_constant.rs:15:11: 42:2\n+          StorageDead(_6);                 // scope 3 at $DIR/invalid_constant.rs:42:1: 42:2\n+          StorageDead(_4);                 // scope 2 at $DIR/invalid_constant.rs:42:1: 42:2\n+          StorageDead(_2);                 // scope 1 at $DIR/invalid_constant.rs:42:1: 42:2\n+          StorageDead(_1);                 // scope 0 at $DIR/invalid_constant.rs:42:1: 42:2\n+          return;                          // scope 0 at $DIR/invalid_constant.rs:42:2: 42:2\n       }\n   }\n   "}, {"sha": "492ef404916d49f9f04d62b909e042875357cdc2", "filename": "src/test/mir-opt/const_prop/invalid_constant.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1,6 +1,8 @@\n // Verify that we can pretty print invalid constants.\n \n+#![feature(adt_const_params)]\n #![feature(inline_const)]\n+#![allow(incomplete_features)]\n \n #[derive(Copy, Clone)]\n #[repr(u32)]\n@@ -31,4 +33,10 @@ fn main() {\n         empty: Empty,\n     }\n     let _enum_without_variants = [NoVariants { int: 0 }];\n+\n+    // A non-UTF-8 string slice. Regression test for #75763 and #78520.\n+    struct Str<const S: &'static str>;\n+    let _non_utf8_str: Str::<{\n+        unsafe { std::mem::transmute::<&[u8], &str>(&[0xC0, 0xC1, 0xF5]) }\n+    }>;\n }"}, {"sha": "214a04b8a6bed5786e5c28951a038dea9063f1a7", "filename": "src/test/ui/const-generics/issues/issue-75763.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75763.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1,16 +0,0 @@\n-// ignore-test\n-// FIXME(const_generics): This test causes an ICE after reverting #76030.\n-#![feature(adt_const_params)]\n-#![allow(incomplete_features)]\n-\n-\n-struct Bug<const S: &'static str>;\n-\n-fn main() {\n-    let b: Bug::<{\n-        unsafe {\n-            // FIXME(adt_const_params): Decide on how to deal with invalid values as const params.\n-            std::mem::transmute::<&[u8], &str>(&[0xC0, 0xC1, 0xF5])\n-        }\n-    }>;\n-}"}, {"sha": "9a09c414ac80fb1790d17cb3ad85400dc2051055", "filename": "src/test/ui/let-else/let-else-destructuring.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui%2Flet-else%2Flet-else-destructuring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui%2Flet-else%2Flet-else-destructuring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-destructuring.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -0,0 +1,18 @@\n+#![feature(let_else)]\n+#[derive(Debug)]\n+enum Foo {\n+    Done,\n+    Nested(Option<&'static Foo>),\n+}\n+\n+fn walk(mut value: &Foo) {\n+    loop {\n+        println!(\"{:?}\", value);\n+        &Foo::Nested(Some(value)) = value else { break }; //~ ERROR invalid left-hand side of assignment\n+        //~^ERROR <assignment> ... else { ... } is not allowed\n+    }\n+}\n+\n+fn main() {\n+    walk(&Foo::Done);\n+}"}, {"sha": "95efb7116829e6252303834987765942dd2a8167", "filename": "src/test/ui/let-else/let-else-destructuring.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui%2Flet-else%2Flet-else-destructuring.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui%2Flet-else%2Flet-else-destructuring.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-destructuring.stderr?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -0,0 +1,17 @@\n+error: <assignment> ... else { ... } is not allowed\n+  --> $DIR/let-else-destructuring.rs:11:9\n+   |\n+LL |         &Foo::Nested(Some(value)) = value else { break };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/let-else-destructuring.rs:11:35\n+   |\n+LL |         &Foo::Nested(Some(value)) = value else { break };\n+   |         ------------------------- ^\n+   |         |\n+   |         cannot assign to this expression\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0070`."}]}