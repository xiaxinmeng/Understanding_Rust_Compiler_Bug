{"sha": "488d0c9efd355f712db4ea34856ddbeea26a7049", "node_id": "C_kwDOAAsO6NoAKDQ4OGQwYzllZmQzNTVmNzEyZGI0ZWEzNDg1NmRkYmVlYTI2YTcwNDk", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "liehr.exchange@gmx.net", "date": "2022-12-08T12:31:21Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-02-19T17:35:28Z"}, "message": "Type-directed probing for inherent associated types", "tree": {"sha": "c511853a9220830ec04ec73d814eb38df1dd485c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c511853a9220830ec04ec73d814eb38df1dd485c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/488d0c9efd355f712db4ea34856ddbeea26a7049", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmPyXeAACgkQ0XoHIV9o\n5xNcEQ/+LFkfa3R7UQ2/3ogwTgtus/t1k73W1fK3MVVarJM5oNt3JhZK4HrrGdJn\nXyBXIgbjdcGmRKbo82s1H2hrFBOiqvb860SkbFjBs8MiknM0QEk7Z+1NItOZ0bWk\ng7AO/XtUbwaPV2s6qJpE11pt/QRRXss9ecgO3HFr+MYIpSfma+wiFHKoDRnDJH2v\n8bLJ/HzQ1cUzqeq117rseUnuVvlPgm8zRy5NVCAI3P3CIS/wwZJmgig/NTEn5rPq\nWnW9+ButyFVp1V9fdWsqJ8tZJ4VAowjq/whLTnjZjNBcYqtYgUPcEOkgVqS/K1B2\nqUClZXRsn9tcRLA3Ci4mM5HWlBEEzbloYmW7kLX7wD7Dv6BKiShbVrIBIe4x91+7\nC/2gfoaWdntD9QJp0dTn98Yi5pXHGp73Pwdn00GSnmDkq2wlnHi2L3f1eUZhQsoY\njGKgujA6u97q1ZB54OwQye5EUk4pxrwlRBgs4qyoVBGA6xAW/rOqe+5/8QGOiGNM\nTs/VHqEOAdYsqpcelnBdQ9ecpw+K0ZDXust1M34RqqXzgJqUWJafgqUe3hxa0pth\ng7++Iv79rWUiRrzQnOtDd5VpJXVMon6mqglziuKWakSl2TpYc+xdFnzzERAkl5/X\nYB+yqgclTSvCkDI6R0qJ/p5J4ExBv6tWZByPZqW/P9DphCNLAV0=\n=gG5Y\n-----END PGP SIGNATURE-----", "payload": "tree c511853a9220830ec04ec73d814eb38df1dd485c\nparent eebdfb55fce148676c24555505aebf648123b2de\nauthor Le\u00f3n Orell Valerian Liehr <liehr.exchange@gmx.net> 1670502681 +0100\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1676828128 +0100\n\nType-directed probing for inherent associated types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/488d0c9efd355f712db4ea34856ddbeea26a7049", "html_url": "https://github.com/rust-lang/rust/commit/488d0c9efd355f712db4ea34856ddbeea26a7049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/488d0c9efd355f712db4ea34856ddbeea26a7049/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eebdfb55fce148676c24555505aebf648123b2de", "url": "https://api.github.com/repos/rust-lang/rust/commits/eebdfb55fce148676c24555505aebf648123b2de", "html_url": "https://github.com/rust-lang/rust/commit/eebdfb55fce148676c24555505aebf648123b2de"}], "stats": {"total": 635, "additions": 581, "deletions": 54}, "files": [{"sha": "191f4f0f910ad9fe48f8866ceed927adc22e8935", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 164, "deletions": 2, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -1,10 +1,10 @@\n use crate::astconv::AstConv;\n use crate::errors::{ManualImplementation, MissingTypeParams};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n@@ -221,6 +221,168 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.emit()\n     }\n \n+    // FIXME(inherent_associated_types): Find similarly named associated types and suggest them.\n+    pub(crate) fn complain_about_inherent_assoc_type_not_found(\n+        &self,\n+        name: Ident,\n+        self_ty: Ty<'tcx>,\n+        candidates: &[DefId],\n+        unsatisfied_predicates: Vec<ty::Predicate<'tcx>>,\n+        span: Span,\n+    ) -> ErrorGuaranteed {\n+        let tcx = self.tcx();\n+\n+        let adt_did = self_ty.ty_adt_def().map(|def| def.did());\n+        let add_def_label = |err: &mut Diagnostic| {\n+            if let Some(did) = adt_did {\n+                err.span_label(\n+                    tcx.def_span(did),\n+                    format!(\n+                        \"associated item `{name}` not found for this {}\",\n+                        tcx.def_kind(did).descr(did)\n+                    ),\n+                );\n+            }\n+        };\n+\n+        if unsatisfied_predicates.is_empty() {\n+            // FIXME(fmease): Copied from `rustc_hir_typeck::method::probe`. Deduplicate.\n+\n+            let limit = if candidates.len() == 5 { 5 } else { 4 };\n+            let type_candidates = candidates\n+                .iter()\n+                .take(limit)\n+                .map(|candidate| {\n+                    format!(\"- `{}`\", tcx.at(span).type_of(candidate).subst_identity())\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+            let additional_types = if candidates.len() > limit {\n+                format!(\"\\nand {} more types\", candidates.len() - limit)\n+            } else {\n+                String::new()\n+            };\n+\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                name.span,\n+                E0220,\n+                \"associated type `{name}` not found for `{self_ty}` in the current scope\"\n+            );\n+            err.span_label(name.span, format!(\"associated item not found in `{self_ty}`\"));\n+            err.note(&format!(\n+                \"the associated type was found for\\n{type_candidates}{additional_types}\",\n+            ));\n+            add_def_label(&mut err);\n+            return err.emit();\n+        }\n+\n+        let mut bound_spans = Vec::new();\n+\n+        // FIXME(fmease): Copied from `rustc_hir_typeck::method::probe`. Deduplicate.\n+        let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n+            let msg = format!(\n+                \"doesn't satisfy `{}`\",\n+                if obligation.len() > 50 { quiet } else { obligation }\n+            );\n+            match &self_ty.kind() {\n+                // Point at the type that couldn't satisfy the bound.\n+                ty::Adt(def, _) => bound_spans.push((tcx.def_span(def.did()), msg)),\n+                // Point at the trait object that couldn't satisfy the bound.\n+                ty::Dynamic(preds, _, _) => {\n+                    for pred in preds.iter() {\n+                        match pred.skip_binder() {\n+                            ty::ExistentialPredicate::Trait(tr) => {\n+                                bound_spans.push((tcx.def_span(tr.def_id), msg.clone()))\n+                            }\n+                            ty::ExistentialPredicate::Projection(_)\n+                            | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                        }\n+                    }\n+                }\n+                // Point at the closure that couldn't satisfy the bound.\n+                ty::Closure(def_id, _) => {\n+                    bound_spans.push((tcx.def_span(*def_id), format!(\"doesn't satisfy `{quiet}`\")))\n+                }\n+                _ => {}\n+            }\n+        };\n+\n+        // FIXME(fmease): Copied from `rustc_hir_typeck::method::probe`. Deduplicate.\n+        let format_pred = |pred: ty::Predicate<'tcx>| {\n+            let bound_predicate = pred.kind();\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n+                    let pred = bound_predicate.rebind(pred);\n+                    // `<Foo as Iterator>::Item = String`.\n+                    let projection_ty = pred.skip_binder().projection_ty;\n+\n+                    let substs_with_infer_self = tcx.mk_substs(\n+                        std::iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n+                            .chain(projection_ty.substs.iter().skip(1)),\n+                    );\n+\n+                    let quiet_projection_ty =\n+                        tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n+\n+                    let term = pred.skip_binder().term;\n+\n+                    let obligation = format!(\"{projection_ty} = {term}\");\n+                    let quiet = format!(\"{quiet_projection_ty} = {term}\");\n+\n+                    bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                    Some((obligation, projection_ty.self_ty()))\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n+                    let p = poly_trait_ref.trait_ref;\n+                    let self_ty = p.self_ty();\n+                    let path = p.print_only_trait_path();\n+                    let obligation = format!(\"{self_ty}: {path}\");\n+                    let quiet = format!(\"_: {path}\");\n+                    bound_span_label(self_ty, &obligation, &quiet);\n+                    Some((obligation, self_ty))\n+                }\n+                _ => None,\n+            }\n+        };\n+\n+        // FIXME(fmease): `rustc_hir_typeck::method::suggest` uses a `skip_list` to filter out some bounds.\n+        // I would do the same here if it didn't mean more code duplication.\n+        let mut bounds: Vec<_> = unsatisfied_predicates\n+            .into_iter()\n+            .filter_map(format_pred)\n+            .map(|(p, _)| format!(\"`{}`\", p))\n+            .collect();\n+        bounds.sort();\n+        bounds.dedup();\n+\n+        let mut err = tcx.sess.struct_span_err(\n+            name.span,\n+            &format!(\"the associated type `{name}` exists for `{self_ty}`, but its trait bounds were not satisfied\")\n+        );\n+        if !bounds.is_empty() {\n+            err.note(&format!(\n+                \"the following trait bounds were not satisfied:\\n{}\",\n+                bounds.join(\"\\n\")\n+            ));\n+        }\n+        err.span_label(\n+            name.span,\n+            format!(\"associated type cannot be referenced on `{self_ty}` due to unsatisfied trait bounds\")\n+        );\n+\n+        bound_spans.sort();\n+        bound_spans.dedup();\n+        for (span, msg) in bound_spans {\n+            if !tcx.sess.source_map().is_span_accessible(span) {\n+                continue;\n+            }\n+            err.span_label(span, &msg);\n+        }\n+        add_def_label(&mut err);\n+        err.emit()\n+    }\n+\n     /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n     /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n     /// same trait bound have the same name (as they come from different supertraits), we instead"}, {"sha": "92bff68cdbce3aa4acbe2d172a173cfd56ac92f3", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 205, "deletions": 52, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -27,7 +27,10 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n@@ -40,11 +43,12 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n-use rustc_trait_selection::traits::astconv_object_safety_violations;\n use rustc_trait_selection::traits::error_reporting::{\n     report_object_safety_error, suggestions::NextTypeParamName,\n };\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::wf::object_region_bounds;\n+use rustc_trait_selection::traits::{astconv_object_safety_violations, NormalizeExt};\n \n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n@@ -2043,23 +2047,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             }\n \n-            // see if we can satisfy using an inherent associated type\n-            for &impl_ in tcx.inherent_impls(adt_def.did()) {\n-                let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n-                    continue;\n-                };\n-                let ty::Adt(_, adt_substs) = qself_ty.kind() else {\n-                    // FIXME(inherent_associated_types)\n-                    bug!(\"unimplemented: non-adt self of inherent assoc ty\");\n-                };\n-                let item_substs = self.create_substs_for_associated_item(\n-                    span,\n-                    assoc_ty_did,\n-                    assoc_segment,\n-                    adt_substs,\n-                );\n-                let ty = tcx.type_of(assoc_ty_did).subst(tcx, item_substs);\n-                return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n+            if let Some((ty, did)) = self.lookup_inherent_assoc_ty(\n+                assoc_ident,\n+                assoc_segment,\n+                adt_def.did(),\n+                qself_ty,\n+                hir_ref_id,\n+                span,\n+            )? {\n+                return Ok((ty, DefKind::AssocTy, did));\n             }\n         }\n \n@@ -2202,6 +2198,196 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok((ty, DefKind::AssocTy, assoc_ty_did))\n     }\n \n+    fn lookup_inherent_assoc_ty(\n+        &self,\n+        name: Ident,\n+        segment: &hir::PathSegment<'_>,\n+        adt_did: DefId,\n+        self_ty: Ty<'tcx>,\n+        block: hir::HirId,\n+        span: Span,\n+    ) -> Result<Option<(Ty<'tcx>, DefId)>, ErrorGuaranteed> {\n+        let tcx = self.tcx();\n+\n+        let candidates: Vec<_> = tcx\n+            .inherent_impls(adt_did)\n+            .iter()\n+            .filter_map(|&impl_| Some((impl_, self.lookup_assoc_ty_unchecked(name, block, impl_)?)))\n+            .collect();\n+\n+        if candidates.is_empty() {\n+            return Ok(None);\n+        }\n+\n+        let cause = ObligationCause::misc(span, block.owner.def_id);\n+        let mut unsatisfied_predicates = Vec::new();\n+\n+        for &(impl_, (assoc_item, def_scope)) in &candidates {\n+            let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+            let param_env = tcx.param_env(impl_);\n+\n+            let impl_ty = tcx.type_of(impl_);\n+            let impl_substs = self.fresh_item_substs(impl_, &infcx);\n+            let impl_ty = impl_ty.subst(tcx, impl_substs);\n+\n+            let InferOk { value: impl_ty, obligations } =\n+                infcx.at(&cause, param_env).normalize(impl_ty);\n+\n+            // Check that the Self-types can be related.\n+            let Ok(InferOk { obligations: sub_obligations, value: () }) = infcx\n+                .at(&ObligationCause::dummy(), param_env)\n+                .define_opaque_types(false)\n+                .sup(impl_ty, self_ty)\n+            else {\n+                continue;\n+            };\n+\n+            // Check whether the impl imposes obligations we have to worry about.\n+            let impl_bounds = tcx.predicates_of(impl_);\n+            let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+\n+            let InferOk { value: impl_bounds, obligations: norm_obligations } =\n+                infcx.at(&cause, param_env).normalize(impl_bounds);\n+\n+            let impl_obligations =\n+                traits::predicates_for_generics(|_, _| cause.clone(), param_env, impl_bounds);\n+\n+            let candidate_obligations = impl_obligations\n+                .chain(norm_obligations.into_iter())\n+                .chain(obligations.iter().cloned());\n+\n+            let mut matches = true;\n+\n+            // Evaluate those obligations to see if they might possibly hold.\n+            for o in candidate_obligations {\n+                let o = infcx.resolve_vars_if_possible(o);\n+                if !infcx.predicate_may_hold(&o) {\n+                    matches = false;\n+                    unsatisfied_predicates.push(o.predicate);\n+                }\n+            }\n+\n+            // Evaluate those obligations to see if they might possibly hold.\n+            for o in sub_obligations {\n+                let o = infcx.resolve_vars_if_possible(o);\n+                if !infcx.predicate_may_hold(&o) {\n+                    matches = false;\n+                    unsatisfied_predicates.push(o.predicate);\n+                }\n+            }\n+\n+            if !matches {\n+                continue;\n+            }\n+\n+            self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n+\n+            let ty::Adt(_, adt_substs) = self_ty.kind() else {\n+                bug!(\"unreachable: `lookup_inherent_assoc_ty` is only called on ADTs\");\n+            };\n+\n+            let item_substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, adt_substs);\n+            // FIXME(inherent_associated_types): Check if the obligations arising from the\n+            // where-clause & the bounds on the associated type and its parameters hold.\n+            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+            return Ok(Some((ty, assoc_item)));\n+        }\n+\n+        Err(self.complain_about_inherent_assoc_type_not_found(\n+            name,\n+            self_ty,\n+            &candidates.into_iter().map(|(impl_, _)| impl_).collect::<Vec<_>>(),\n+            unsatisfied_predicates,\n+            span,\n+        ))\n+    }\n+\n+    // FIXME(fmease): Copied from `rustc_hir_typeck::method::probe`. Deduplicate.\n+    fn fresh_item_substs(&self, def_id: DefId, infcx: &InferCtxt<'tcx>) -> SubstsRef<'tcx> {\n+        let tcx = self.tcx();\n+\n+        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+            GenericParamDefKind::Type { .. } => infcx\n+                .next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::SubstitutionPlaceholder,\n+                    span: tcx.def_span(def_id),\n+                })\n+                .into(),\n+            GenericParamDefKind::Const { .. } => {\n+                let span = tcx.def_span(def_id);\n+                let origin = ConstVariableOrigin {\n+                    kind: ConstVariableOriginKind::SubstitutionPlaceholder,\n+                    span,\n+                };\n+                infcx\n+                    .next_const_var(\n+                        tcx.type_of(param.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\"),\n+                        origin,\n+                    )\n+                    .into()\n+            }\n+        })\n+    }\n+\n+    fn lookup_assoc_ty(\n+        &self,\n+        name: Ident,\n+        block: hir::HirId,\n+        span: Span,\n+        scope: DefId,\n+    ) -> Option<DefId> {\n+        let (item, def_scope) = self.lookup_assoc_ty_unchecked(name, block, scope)?;\n+        self.check_assoc_ty(item, name, def_scope, block, span);\n+        Some(item)\n+    }\n+\n+    fn lookup_assoc_ty_unchecked(\n+        &self,\n+        name: Ident,\n+        block: hir::HirId,\n+        scope: DefId,\n+    ) -> Option<(DefId, DefId)> {\n+        let tcx = self.tcx();\n+        let (ident, def_scope) = tcx.adjust_ident_and_get_scope(name, scope, block);\n+\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n+        // of calling `find_by_name_and_kind`.\n+        let item = tcx.associated_items(scope).in_definition_order().find(|i| {\n+            i.kind.namespace() == Namespace::TypeNS\n+                && i.ident(tcx).normalize_to_macros_2_0() == ident\n+        })?;\n+\n+        Some((item.def_id, def_scope))\n+    }\n+\n+    fn check_assoc_ty(\n+        &self,\n+        item: DefId,\n+        name: Ident,\n+        def_scope: DefId,\n+        block: hir::HirId,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+        let kind = DefKind::AssocTy;\n+\n+        if !tcx.visibility(item).is_accessible_from(def_scope, tcx) {\n+            let kind = kind.descr(item);\n+            let msg = format!(\"{kind} `{name}` is private\");\n+            let def_span = tcx.def_span(item);\n+            tcx.sess\n+                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n+                .span_label(span, &format!(\"private {kind}\"))\n+                .span_label(def_span, &format!(\"{kind} defined here\"))\n+                .emit();\n+        }\n+        tcx.check_stability(item, Some(block), span, None);\n+    }\n+\n     fn probe_traits_that_match_assoc_ty(\n         &self,\n         qself_ty: Ty<'tcx>,\n@@ -2255,39 +2441,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .collect()\n     }\n \n-    fn lookup_assoc_ty(\n-        &self,\n-        ident: Ident,\n-        block: hir::HirId,\n-        span: Span,\n-        scope: DefId,\n-    ) -> Option<DefId> {\n-        let tcx = self.tcx();\n-        let (ident, def_scope) = tcx.adjust_ident_and_get_scope(ident, scope, block);\n-\n-        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n-        // of calling `find_by_name_and_kind`.\n-        let item = tcx.associated_items(scope).in_definition_order().find(|i| {\n-            i.kind.namespace() == Namespace::TypeNS\n-                && i.ident(tcx).normalize_to_macros_2_0() == ident\n-        })?;\n-\n-        let kind = DefKind::AssocTy;\n-        if !item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n-            let kind = kind.descr(item.def_id);\n-            let msg = format!(\"{kind} `{ident}` is private\");\n-            let def_span = self.tcx().def_span(item.def_id);\n-            tcx.sess\n-                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n-                .span_label(span, &format!(\"private {kind}\"))\n-                .span_label(def_span, &format!(\"{kind} defined here\"))\n-                .emit();\n-        }\n-        tcx.check_stability(item.def_id, Some(block), span, None);\n-\n-        Some(item.def_id)\n-    }\n-\n     fn qpath_to_ty(\n         &self,\n         span: Span,"}, {"sha": "191ce23efa6d11f7d1e3fcbdbf6ea098dcddd3f7", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-0.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Check that inherent associated types are dispatched on the concrete Self type.\n+\n+struct Select<T>(T);\n+\n+impl Select<u8> {\n+    type Projection = ();\n+}\n+\n+impl Select<String> {\n+    type Projection = bool;\n+}\n+\n+struct Choose<T>(T);\n+struct NonCopy;\n+\n+impl<T: Copy> Choose<T> {\n+    type Result = Vec<T>;\n+}\n+\n+impl Choose<NonCopy> {\n+    type Result = ();\n+}\n+\n+fn main() {\n+    let _: Select<String>::Projection = false;\n+    let _: Select<u8>::Projection = ();\n+\n+    let _: Choose<NonCopy>::Result = ();\n+    let _: Choose<&str>::Result = vec![\"...\"];\n+}"}, {"sha": "9b0fa8dc6f32cf9c606eaf98a27afdb4b8d628de", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types, auto_traits, negative_impls)]\n+#![allow(incomplete_features)]\n+\n+use std::cmp::Ordering;\n+\n+// Check that inherent associated types are dispatched on the concrete Self type.\n+\n+struct Select<T, U>(T, U);\n+\n+impl<T: Ordinary, U: Ordinary> Select<T, U> {\n+    type Type = ();\n+}\n+\n+impl<T: Ordinary> Select<T, Special> {\n+    type Type = bool;\n+}\n+\n+impl<T: Ordinary> Select<Special, T> {\n+    type Type = Ordering;\n+}\n+\n+impl Select<Special, Special> {\n+    type Type = (bool, bool);\n+}\n+\n+fn main() {\n+    let _: Select<String, Special>::Type = false;\n+    let _: Select<Special, Special>::Type = (true, false);\n+    let _: Select<Special, u8>::Type = Ordering::Equal;\n+    let _: Select<i128, ()>::Type = ();\n+}\n+\n+enum Special {}\n+\n+impl !Ordinary for Special {}\n+\n+auto trait Ordinary {}"}, {"sha": "7b205952f52bcee72b0e11fb029ede4d555331a6", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,17 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Parameterized<T, U>(T, U);\n+\n+impl Parameterized<(), ()> {\n+    type Output = bool;\n+}\n+\n+impl<T> Parameterized<bool, T> {\n+    type Result = T;\n+}\n+\n+fn main() {\n+    let _: Parameterized<(), ()>::Output = String::new(); //~ ERROR mismatched types\n+    let _: Parameterized<bool, u32>::Result = (); //~ ERROR mismatched types\n+}"}, {"sha": "1c77688b45ac016e0fb65f391071d3dc0cf78514", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dispatch-on-self-type-2.rs:15:44\n+   |\n+LL |     let _: Parameterized<(), ()>::Output = String::new();\n+   |            -----------------------------   ^^^^^^^^^^^^^ expected `bool`, found `String`\n+   |            |\n+   |            expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dispatch-on-self-type-2.rs:16:47\n+   |\n+LL |     let _: Parameterized<bool, u32>::Result = ();\n+   |            --------------------------------   ^^ expected `bool`, found `()`\n+   |            |\n+   |            expected due to this\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4396435a6ddc5d2a583478c197b90269ed4a8420", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.alias.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,16 @@\n+error[E0220]: associated type `Proj` not found for `Family<Option<()>>` in the current scope\n+  --> $DIR/not-found-self-type-differs.rs:17:34\n+   |\n+LL | struct Family<T>(T);\n+   | ---------------- associated item `Proj` not found for this struct\n+...\n+LL | type Alias = Family<Option<()>>::Proj;\n+   |                                  ^^^^ associated item not found in `Family<Option<()>>`\n+   |\n+   = note: the associated type was found for\n+           - `Family<()>`\n+           - `Family<Result<T, ()>>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "d527db022172fd3935f495f62cd4dd2d8eeb3ea1", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.local.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,16 @@\n+error[E0220]: associated type `Proj` not found for `Family<PathBuf>` in the current scope\n+  --> $DIR/not-found-self-type-differs.rs:21:40\n+   |\n+LL | struct Family<T>(T);\n+   | ---------------- associated item `Proj` not found for this struct\n+...\n+LL |     let _: Family<std::path::PathBuf>::Proj = ();\n+   |                                        ^^^^ associated item not found in `Family<PathBuf>`\n+   |\n+   = note: the associated type was found for\n+           - `Family<()>`\n+           - `Family<Result<T, ()>>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "93f58dcb6e61a7585f22eb1464a049f88e5350fb", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,22 @@\n+// revisions: local alias\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Family<T>(T);\n+\n+impl Family<()> {\n+    type Proj = ();\n+}\n+\n+impl<T> Family<Result<T, ()>> {\n+    type Proj = Self;\n+}\n+\n+#[cfg(alias)]\n+type Alias = Family<Option<()>>::Proj; //[alias]~ ERROR associated type `Proj` not found for `Family<Option<()>>`\n+\n+fn main() {\n+    #[cfg(local)]\n+    let _: Family<std::path::PathBuf>::Proj = (); //[local]~ ERROR associated type `Proj` not found for `Family<PathBuf>`\n+}"}, {"sha": "b00830fa1c15c6d2edd9aa2881f90e97195737f0", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds.rs?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for issue #104251.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Container<T: ?Sized>(T);\n+\n+impl<T> Container<T> {\n+    type Yield = i32;\n+}\n+\n+struct Duple<T, U>(T, U);\n+\n+impl<T: Copy, U: Send> Duple<T, U> {\n+    type Combination = (T, U);\n+}\n+\n+fn main() {\n+    let _: Container<[u8]>::Yield = 1; //~ ERROR the associated type `Yield` exists for `Container<[u8]>`, but its trait bounds were not satisfied\n+    let _: Duple<String, std::rc::Rc<str>>::Combination; //~ ERROR the associated type `Combination` exists for `Duple<String, Rc<str>>`, but its trait bounds were not satisfied\n+}"}, {"sha": "8b13b6852374fbee01eab4f141ff04ba0e4ca7cc", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488d0c9efd355f712db4ea34856ddbeea26a7049/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds.stderr?ref=488d0c9efd355f712db4ea34856ddbeea26a7049", "patch": "@@ -0,0 +1,27 @@\n+error: the associated type `Yield` exists for `Container<[u8]>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds.rs:19:29\n+   |\n+LL | struct Container<T: ?Sized>(T);\n+   | --------------------------- associated item `Yield` not found for this struct\n+...\n+LL |     let _: Container<[u8]>::Yield = 1;\n+   |                             ^^^^^ associated type cannot be referenced on `Container<[u8]>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `[u8]: Sized`\n+\n+error: the associated type `Combination` exists for `Duple<String, Rc<str>>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds.rs:20:45\n+   |\n+LL | struct Duple<T, U>(T, U);\n+   | ------------------ associated item `Combination` not found for this struct\n+...\n+LL |     let _: Duple<String, std::rc::Rc<str>>::Combination;\n+   |                                             ^^^^^^^^^^^ associated type cannot be referenced on `Duple<String, Rc<str>>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `Rc<str>: Send`\n+           `String: Copy`\n+\n+error: aborting due to 2 previous errors\n+"}]}