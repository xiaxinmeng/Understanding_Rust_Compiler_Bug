{"sha": "c4574dde8dbd3f996418927a3edc8a83e9709f9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NTc0ZGRlOGRiZDNmOTk2NDE4OTI3YTNlZGM4YTgzZTk3MDlmOWM=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-26T22:52:45Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Many small changes to clean up code.", "tree": {"sha": "178c5d84dc1487adc5e20ac15cc9564f664b7ef3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/178c5d84dc1487adc5e20ac15cc9564f664b7ef3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4574dde8dbd3f996418927a3edc8a83e9709f9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4574dde8dbd3f996418927a3edc8a83e9709f9c", "html_url": "https://github.com/rust-lang/rust/commit/c4574dde8dbd3f996418927a3edc8a83e9709f9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4574dde8dbd3f996418927a3edc8a83e9709f9c/comments", "author": null, "committer": null, "parents": [{"sha": "6842eb2b84337ff01158ca7c0eee669b0d1e061f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6842eb2b84337ff01158ca7c0eee669b0d1e061f", "html_url": "https://github.com/rust-lang/rust/commit/6842eb2b84337ff01158ca7c0eee669b0d1e061f"}], "stats": {"total": 59, "additions": 23, "deletions": 36}, "files": [{"sha": "c2ef2722378080f6282aa82beeb7e84a68561fad", "filename": "src/shims/thread.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c4574dde8dbd3f996418927a3edc8a83e9709f9c/src%2Fshims%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4574dde8dbd3f996418927a3edc8a83e9709f9c/src%2Fshims%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthread.rs?ref=c4574dde8dbd3f996418927a3edc8a83e9709f9c", "patch": "@@ -1,5 +1,4 @@\n use crate::*;\n-use rustc_index::vec::Idx;\n use rustc_target::abi::LayoutOf;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -19,33 +18,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         );\n \n         let new_thread_id = this.create_thread()?;\n+        // Also switch to new thread so that we can push the first stackframe.\n         let old_thread_id = this.set_active_thread(new_thread_id)?;\n \n         let thread_info_place = this.deref_operand(thread)?;\n-        let thread_info_type = thread.layout.ty\n-            .builtin_deref(true)\n-            .ok_or_else(|| err_ub_format!(\n-                \"wrong signature used for `pthread_create`: first argument must be a raw pointer.\"\n-            ))?\n-            .ty;\n-        let thread_info_layout = this.layout_of(thread_info_type)?;\n         this.write_scalar(\n-            Scalar::from_uint(new_thread_id.index() as u128, thread_info_layout.size),\n+            Scalar::from_uint(new_thread_id.to_u128(), thread_info_place.layout.size),\n             thread_info_place.into(),\n         )?;\n \n         let fn_ptr = this.read_scalar(start_routine)?.not_undef()?;\n         let instance = this.memory.get_fn(fn_ptr)?.as_instance()?;\n \n         let func_arg = this.read_immediate(arg)?;\n-        let func_args = [*func_arg];\n \n         let ret_place =\n             this.allocate(this.layout_of(this.tcx.types.usize)?, MiriMemoryKind::Machine.into());\n \n         this.call_function(\n             instance,\n-            &func_args[..],\n+            &[*func_arg],\n             Some(ret_place.into()),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n@@ -66,7 +58,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"Miri supports pthread_join only with retval==NULL\");\n         }\n \n-        let thread_id = this.read_scalar(thread)?.not_undef()?.to_machine_usize(this)?;\n+        let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n         this.join_thread(thread_id.into())?;\n \n         Ok(0)\n@@ -75,7 +67,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_detach(&mut self, thread: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let thread_id = this.read_scalar(thread)?.not_undef()?.to_machine_usize(this)?;\n+        let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n         this.detach_thread(thread_id.into())?;\n \n         Ok(0)\n@@ -85,34 +77,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread()?;\n-        this.write_scalar(Scalar::from_uint(thread_id.index() as u128, dest.layout.size), dest)\n+        this.write_scalar(Scalar::from_uint(thread_id.to_u128(), dest.layout.size), dest)\n     }\n \n     fn prctl(\n         &mut self,\n         option: OpTy<'tcx, Tag>,\n         arg2: OpTy<'tcx, Tag>,\n-        arg3: OpTy<'tcx, Tag>,\n-        arg4: OpTy<'tcx, Tag>,\n-        arg5: OpTy<'tcx, Tag>,\n+        _arg3: OpTy<'tcx, Tag>,\n+        _arg4: OpTy<'tcx, Tag>,\n+        _arg5: OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        // prctl last 5 arguments are declared as variadic. Therefore, we need\n-        // to check their types manually.\n-        let c_long_size = this.libc_ty_layout(\"c_long\")?.size.bytes();\n-        let check_arg = |arg: OpTy<'tcx, Tag>| -> InterpResult<'tcx> {\n-            match this.read_scalar(arg)?.not_undef()? {\n-                Scalar::Raw { size, .. } if u64::from(size) == c_long_size => Ok(()),\n-                _ => throw_ub_format!(\"an argument of unsupported type was passed to prctl\"),\n-            }\n-        };\n-        check_arg(arg2)?;\n-        check_arg(arg3)?;\n-        check_arg(arg4)?;\n-        check_arg(arg5)?;\n-\n-        let option = this.read_scalar(option)?.not_undef()?.to_i32()?;\n+        let option = this.read_scalar(option)?.to_i32()?;\n         if option == this.eval_libc_i32(\"PR_SET_NAME\")? {\n             let address = this.read_scalar(arg2)?.not_undef()?;\n             let name = this.memory.read_c_str(address)?.to_owned();\n@@ -122,7 +100,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let name = this.get_active_thread_name()?.to_vec();\n             this.memory.write_bytes(address, name)?;\n         } else {\n-            throw_unsup_format!(\"Unsupported prctl option.\");\n+            throw_unsup_format!(\"unsupported prctl option {}\", option);\n         }\n \n         Ok(0)"}, {"sha": "087b44af2f58ff53bb929308f1189c63aa604c5a", "filename": "src/shims/tls.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4574dde8dbd3f996418927a3edc8a83e9709f9c/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4574dde8dbd3f996418927a3edc8a83e9709f9c/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=c4574dde8dbd3f996418927a3edc8a83e9709f9c", "patch": "@@ -20,7 +20,6 @@ pub type TlsKey = u128;\n pub struct TlsEntry<'tcx> {\n     /// The data for this key. None is used to represent NULL.\n     /// (We normalize this early to avoid having to do a NULL-ptr-test each time we access the data.)\n-    /// Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n     data: BTreeMap<ThreadId, Scalar<Tag>>,\n     dtor: Option<ty::Instance<'tcx>>,\n }\n@@ -89,7 +88,7 @@ impl<'tcx> TlsData<'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         match self.keys.get(&key) {\n             Some(TlsEntry { data, .. }) => {\n-                let value = data.get(&thread_id).cloned();\n+                let value = data.get(&thread_id).copied();\n                 trace!(\"TLS key {} for thread {:?} loaded: {:?}\", key, thread_id, value);\n                 Ok(value.unwrap_or_else(|| Scalar::null_ptr(cx).into()))\n             }\n@@ -99,7 +98,10 @@ impl<'tcx> TlsData<'tcx> {\n \n     pub fn store_tls(\n         &mut self,\n-         key: TlsKey, thread_id: ThreadId, new_data: Option<Scalar<Tag>>) -> InterpResult<'tcx> {\n+        key: TlsKey,\n+        thread_id: ThreadId,\n+        new_data: Option<Scalar<Tag>>\n+    ) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(TlsEntry { data, .. }) => {\n                 match new_data {"}, {"sha": "f9094d771e6dd87cfbb19833ad48916f69ff1fba", "filename": "src/thread.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4574dde8dbd3f996418927a3edc8a83e9709f9c/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4574dde8dbd3f996418927a3edc8a83e9709f9c/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=c4574dde8dbd3f996418927a3edc8a83e9709f9c", "patch": "@@ -1,5 +1,6 @@\n //! Implements threads.\n \n+use std::convert::TryInto;\n use std::cell::RefCell;\n use std::convert::TryFrom;\n use std::num::NonZeroU32;\n@@ -34,6 +35,12 @@ pub struct ThreadId(usize);\n /// The main thread. When it terminates, the whole application terminates.\n const MAIN_THREAD: ThreadId = ThreadId(0);\n \n+impl ThreadId {\n+    pub fn to_u128(self) -> u128 {\n+        self.0.try_into().unwrap()\n+    }\n+}\n+\n impl Idx for ThreadId {\n     fn new(idx: usize) -> Self {\n         ThreadId(idx)"}]}