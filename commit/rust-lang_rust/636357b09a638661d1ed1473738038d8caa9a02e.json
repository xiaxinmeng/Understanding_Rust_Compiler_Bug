{"sha": "636357b09a638661d1ed1473738038d8caa9a02e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNjM1N2IwOWE2Mzg2NjFkMWVkMTQ3MzczODAzOGQ4Y2FhOWEwMmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-10T15:44:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-17T19:12:21Z"}, "message": "Cleanup import parsing\n\nFix spans of root segments", "tree": {"sha": "004ccb375cf07bcfbaf2dc31c430a373ac5dab51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/004ccb375cf07bcfbaf2dc31c430a373ac5dab51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/636357b09a638661d1ed1473738038d8caa9a02e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/636357b09a638661d1ed1473738038d8caa9a02e", "html_url": "https://github.com/rust-lang/rust/commit/636357b09a638661d1ed1473738038d8caa9a02e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/636357b09a638661d1ed1473738038d8caa9a02e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f88162654df187923d87254cbb36806976f81771", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88162654df187923d87254cbb36806976f81771", "html_url": "https://github.com/rust-lang/rust/commit/f88162654df187923d87254cbb36806976f81771"}], "stats": {"total": 77, "additions": 23, "deletions": 54}, "files": [{"sha": "f7e5d40b52468821e79a28e324a01cdd866fdb1f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/636357b09a638661d1ed1473738038d8caa9a02e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/636357b09a638661d1ed1473738038d8caa9a02e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=636357b09a638661d1ed1473738038d8caa9a02e", "patch": "@@ -713,7 +713,7 @@ mod tests {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Path(None, ast::Path {\n                             span: sp(0, 6),\n-                            segments: vec![ast::PathSegment::crate_root(sp(0, 2)),\n+                            segments: vec![ast::PathSegment::crate_root(sp(0, 0)),\n                                         str2seg(\"a\", 2, 3),\n                                         str2seg(\"b\", 5, 6)]\n                         }),"}, {"sha": "f1967ebf590d60f19f8f1f4e800ece76ce3a46f7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 53, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/636357b09a638661d1ed1473738038d8caa9a02e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/636357b09a638661d1ed1473738038d8caa9a02e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=636357b09a638661d1ed1473738038d8caa9a02e", "patch": "@@ -1990,7 +1990,7 @@ impl<'a> Parser<'a> {\n         let lo = self.meta_var_span.unwrap_or(self.span);\n         let mut segments = Vec::new();\n         if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::crate_root(lo));\n+            segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n         }\n         self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n@@ -2025,7 +2025,7 @@ impl<'a> Parser<'a> {\n         loop {\n             segments.push(self.parse_path_segment(style, enable_warning)?);\n \n-            if self.is_import_coupler(false) || !self.eat(&token::ModSep) {\n+            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n                 return Ok(());\n             }\n         }\n@@ -6483,9 +6483,8 @@ impl<'a> Parser<'a> {\n             let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n             self.expect(&token::Semi)?;\n \n-            let prev_span = self.prev_span;\n-            let invalid = keywords::Invalid.ident();\n-            let item = self.mk_item(lo.to(prev_span), invalid, item_, visibility, attrs);\n+            let span = lo.to(self.prev_span);\n+            let item = self.mk_item(span, keywords::Invalid.ident(), item_, visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -6960,83 +6959,53 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// `{` or `::{` or `*` or `::*`\n-    /// `::{` or `::*` (also `{`  or `*` if unprefixed is true)\n-    fn is_import_coupler(&mut self, unprefixed: bool) -> bool {\n-        self.is_import_coupler_inner(&token::OpenDelim(token::Brace), unprefixed) ||\n-            self.is_import_coupler_inner(&token::BinOp(token::Star), unprefixed)\n-    }\n-\n-    fn is_import_coupler_inner(&mut self, token: &token::Token, unprefixed: bool) -> bool {\n-        if self.check(&token::ModSep) {\n-            self.look_ahead(1, |t| t == token)\n-        } else if unprefixed {\n-            self.check(token)\n-        } else {\n-            false\n-        }\n+    /// `::{` or `::*`\n+    fn is_import_coupler(&mut self) -> bool {\n+        self.check(&token::ModSep) &&\n+            self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n+                                   *t == token::BinOp(token::Star))\n     }\n \n     /// Parse UseTree\n     ///\n-    /// USE_TREE = `*` |\n-    ///            `{` USE_TREE_LIST `}` |\n+    /// USE_TREE = [`::`] `*` |\n+    ///            [`::`] `{` USE_TREE_LIST `}` |\n     ///            PATH `::` `*` |\n     ///            PATH `::` `{` USE_TREE_LIST `}` |\n     ///            PATH [`as` IDENT]\n     fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n         let lo = self.span;\n \n-        let mut prefix = ast::Path {\n-            segments: vec![],\n-            span: lo.to(self.span),\n-        };\n-\n-        let kind = if self.is_import_coupler(true) {\n-            // `use *;` or `use ::*;` or `use {...};` `use ::{...};`\n-\n-            // Remove the first `::`\n+        let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo() };\n+        let kind = if self.check(&token::OpenDelim(token::Brace)) ||\n+                      self.check(&token::BinOp(token::Star)) ||\n+                      self.is_import_coupler() {\n+            // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n             if self.eat(&token::ModSep) {\n-                prefix.segments.push(PathSegment::crate_root(self.prev_span));\n+                prefix.segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n             }\n \n             if self.eat(&token::BinOp(token::Star)) {\n-                // `use *;`\n                 UseTreeKind::Glob\n-            } else if self.check(&token::OpenDelim(token::Brace)) {\n-                // `use {...};`\n-                UseTreeKind::Nested(self.parse_use_tree_list()?)\n             } else {\n-                return self.unexpected();\n+                UseTreeKind::Nested(self.parse_use_tree_list()?)\n             }\n         } else {\n-            // `use path::...;`\n-            let mut parsed = self.parse_path(PathStyle::Mod)?;\n-\n-            prefix.segments.append(&mut parsed.segments);\n-            prefix.span = prefix.span.to(parsed.span);\n+            // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n+            prefix = self.parse_path(PathStyle::Mod)?;\n \n             if self.eat(&token::ModSep) {\n                 if self.eat(&token::BinOp(token::Star)) {\n-                    // `use path::*;`\n                     UseTreeKind::Glob\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    // `use path::{...};`\n-                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n                 } else {\n-                    return self.unexpected();\n+                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n                 }\n             } else {\n-                // `use path::foo;` or `use path::foo as bar;`\n                 UseTreeKind::Simple(self.parse_rename()?)\n             }\n         };\n \n-        Ok(UseTree {\n-            span: lo.to(self.prev_span),\n-            kind,\n-            prefix,\n-        })\n+        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n     }\n \n     /// Parse UseTreeKind::Nested(list)"}]}