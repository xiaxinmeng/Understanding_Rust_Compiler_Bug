{"sha": "2f1dfe615d479f19fa1b989e014eb8d4d516a23a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMWRmZTYxNWQ0NzlmMTlmYTFiOTg5ZTAxNGViOGQ0ZDUxNmEyM2E=", "commit": {"author": {"name": "Leo Testard", "email": "leo.testard@gmail.com", "date": "2016-04-07T09:15:32Z"}, "committer": {"name": "Leo Testard", "email": "leo.testard@gmail.com", "date": "2016-04-21T12:00:11Z"}, "message": "Rewrite the feature-gate checks to use a structure instead of a list of strings.", "tree": {"sha": "05a5f2270aa0562a63b0f2fad1c7ec5b42cec44d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a5f2270aa0562a63b0f2fad1c7ec5b42cec44d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1dfe615d479f19fa1b989e014eb8d4d516a23a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1dfe615d479f19fa1b989e014eb8d4d516a23a", "html_url": "https://github.com/rust-lang/rust/commit/2f1dfe615d479f19fa1b989e014eb8d4d516a23a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1dfe615d479f19fa1b989e014eb8d4d516a23a/comments", "author": {"login": "LeoTestard", "id": 907750, "node_id": "MDQ6VXNlcjkwNzc1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/907750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeoTestard", "html_url": "https://github.com/LeoTestard", "followers_url": "https://api.github.com/users/LeoTestard/followers", "following_url": "https://api.github.com/users/LeoTestard/following{/other_user}", "gists_url": "https://api.github.com/users/LeoTestard/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeoTestard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeoTestard/subscriptions", "organizations_url": "https://api.github.com/users/LeoTestard/orgs", "repos_url": "https://api.github.com/users/LeoTestard/repos", "events_url": "https://api.github.com/users/LeoTestard/events{/privacy}", "received_events_url": "https://api.github.com/users/LeoTestard/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeoTestard", "id": 907750, "node_id": "MDQ6VXNlcjkwNzc1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/907750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeoTestard", "html_url": "https://github.com/LeoTestard", "followers_url": "https://api.github.com/users/LeoTestard/followers", "following_url": "https://api.github.com/users/LeoTestard/following{/other_user}", "gists_url": "https://api.github.com/users/LeoTestard/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeoTestard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeoTestard/subscriptions", "organizations_url": "https://api.github.com/users/LeoTestard/orgs", "repos_url": "https://api.github.com/users/LeoTestard/repos", "events_url": "https://api.github.com/users/LeoTestard/events{/privacy}", "received_events_url": "https://api.github.com/users/LeoTestard/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95545e7adcf1715eff2a31a53fe25ce2b012e62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/95545e7adcf1715eff2a31a53fe25ce2b012e62b", "html_url": "https://github.com/rust-lang/rust/commit/95545e7adcf1715eff2a31a53fe25ce2b012e62b"}], "stats": {"total": 634, "additions": 411, "deletions": 223}, "files": [{"sha": "7b0a0f39b24cdd7c8a931409e69b23e321396f5b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 411, "deletions": 223, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/2f1dfe615d479f19fa1b989e014eb8d4d516a23a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1dfe615d479f19fa1b989e014eb8d4d516a23a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2f1dfe615d479f19fa1b989e014eb8d4d516a23a", "patch": "@@ -40,6 +40,18 @@ use parse::token::InternedString;\n use std::ascii::AsciiExt;\n use std::cmp;\n \n+enum Status {\n+    /// Represents an active feature that is currently being implemented or\n+    /// currently being considered for addition/removal.\n+    Active,\n+\n+    /// Represents a feature which has since been removed (it was once Active)\n+    Removed,\n+\n+    /// This language feature has since been Accepted (it was once Active)\n+    Accepted,\n+}\n+\n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n // Don't ever remove anything from this list; set them to 'Removed'.\n // The version numbers here correspond to the version in which the current status\n@@ -262,16 +274,47 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n-enum Status {\n-    /// Represents an active feature that is currently being implemented or\n-    /// currently being considered for addition/removal.\n-    Active,\n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub enum AttributeType {\n+    /// Normal, builtin attribute that is consumed\n+    /// by the compiler before the unused_attribute check\n+    Normal,\n \n-    /// Represents a feature which has since been removed (it was once Active)\n-    Removed,\n+    /// Builtin attribute that may not be consumed by the compiler\n+    /// before the unused_attribute check. These attributes\n+    /// will be ignored by the unused_attribute lint\n+    Whitelisted,\n \n-    /// This language feature has since been Accepted (it was once Active)\n-    Accepted,\n+    /// Builtin attribute that is only allowed at the crate level\n+    CrateLevel,\n+}\n+\n+pub enum AttributeGate {\n+    /// Is gated by a given feature gate, reason\n+    /// and function to check if enabled\n+    Gated(&'static str, &'static str, fn(&Features) -> bool),\n+\n+    /// Ungated attribute, can be used on all release channels\n+    Ungated,\n+}\n+\n+// fn() is not Debug\n+impl ::std::fmt::Debug for AttributeGate {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        match *self {\n+            Gated(ref name, ref expl, _) => write!(fmt, \"Gated({}, {})\", name, expl),\n+            Ungated => write!(fmt, \"Ungated\")\n+        }\n+    }\n+}\n+\n+macro_rules! cfg_fn {\n+    ($field: ident) => {{\n+        fn f(features: &Features) -> bool {\n+            features.$field\n+        }\n+        f as fn(&Features) -> bool\n+    }}\n }\n \n // Attributes that have a special meaning to rustc or rustdoc\n@@ -312,88 +355,112 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     // RFC #1445.\n     (\"structural_match\", Whitelisted, Gated(\"structural_match\",\n                                             \"the semantics of constant patterns is \\\n-                                             not yet settled\")),\n+                                             not yet settled\",\n+                                            cfg_fn!(structural_match))),\n \n     // Not used any more, but we can't feature gate it\n     (\"no_stack_check\", Normal, Ungated),\n \n     (\"plugin\", CrateLevel, Gated(\"plugin\",\n                                  \"compiler plugins are experimental \\\n-                                  and possibly buggy\")),\n+                                  and possibly buggy\",\n+                                 cfg_fn!(plugin))),\n+\n     (\"no_std\", CrateLevel, Ungated),\n     (\"no_core\", CrateLevel, Gated(\"no_core\",\n-                                  \"no_core is experimental\")),\n+                                  \"no_core is experimental\",\n+                                  cfg_fn!(no_core))),\n     (\"lang\", Normal, Gated(\"lang_items\",\n-                           \"language items are subject to change\")),\n+                           \"language items are subject to change\",\n+                           cfg_fn!(lang_items))),\n     (\"linkage\", Whitelisted, Gated(\"linkage\",\n                                    \"the `linkage` attribute is experimental \\\n-                                    and not portable across platforms\")),\n+                                    and not portable across platforms\",\n+                                   cfg_fn!(linkage))),\n     (\"thread_local\", Whitelisted, Gated(\"thread_local\",\n                                         \"`#[thread_local]` is an experimental feature, and does \\\n                                          not currently handle destructors. There is no \\\n                                          corresponding `#[task_local]` mapping to the task \\\n-                                         model\")),\n+                                         model\",\n+                                        cfg_fn!(thread_local))),\n \n     (\"rustc_on_unimplemented\", Normal, Gated(\"on_unimplemented\",\n                                              \"the `#[rustc_on_unimplemented]` attribute \\\n-                                              is an experimental feature\")),\n+                                              is an experimental feature\",\n+                                             cfg_fn!(on_unimplemented))),\n     (\"allocator\", Whitelisted, Gated(\"allocator\",\n-                                     \"the `#[allocator]` attribute is an experimental feature\")),\n+                                     \"the `#[allocator]` attribute is an experimental feature\",\n+                                     cfg_fn!(allocator))),\n     (\"needs_allocator\", Normal, Gated(\"needs_allocator\",\n                                       \"the `#[needs_allocator]` \\\n                                        attribute is an experimental \\\n-                                       feature\")),\n+                                       feature\",\n+                                      cfg_fn!(needs_allocator))),\n     (\"rustc_variance\", Normal, Gated(\"rustc_attrs\",\n                                      \"the `#[rustc_variance]` attribute \\\n                                       is just used for rustc unit tests \\\n-                                      and will never be stable\")),\n+                                      and will never be stable\",\n+                                     cfg_fn!(rustc_attrs))),\n     (\"rustc_error\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_error]` attribute \\\n                                         is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_if_this_changed\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"the `#[rustc_if_this_changed]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                                 \"the `#[rustc_if_this_changed]` attribute \\\n+                                                  is just used for rustc unit tests \\\n+                                                  and will never be stable\",\n+                                                 cfg_fn!(rustc_attrs))),\n     (\"rustc_then_this_would_need\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"the `#[rustc_if_this_changed]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                                      \"the `#[rustc_if_this_changed]` attribute \\\n+                                                       is just used for rustc unit tests \\\n+                                                       and will never be stable\",\n+                                                      cfg_fn!(rustc_attrs))),\n     (\"rustc_dirty\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_dirty]` attribute \\\n                                         is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_clean\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_clean]` attribute \\\n                                         is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"internal rustc attributes will never be stable\")),\n+                                             \"internal rustc attributes will never be stable\",\n+                                             cfg_fn!(rustc_attrs))),\n     (\"rustc_item_path\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"internal rustc attributes will never be stable\")),\n+                                           \"internal rustc attributes will never be stable\",\n+                                           cfg_fn!(rustc_attrs))),\n     (\"rustc_move_fragments\", Normal, Gated(\"rustc_attrs\",\n                                            \"the `#[rustc_move_fragments]` attribute \\\n                                             is just used for rustc unit tests \\\n-                                            and will never be stable\")),\n+                                            and will never be stable\",\n+                                           cfg_fn!(rustc_attrs))),\n     (\"rustc_mir\", Whitelisted, Gated(\"rustc_attrs\",\n                                      \"the `#[rustc_mir]` attribute \\\n                                       is just used for rustc unit tests \\\n-                                      and will never be stable\")),\n+                                      and will never be stable\",\n+                                     cfg_fn!(rustc_attrs))),\n     (\"rustc_no_mir\", Whitelisted, Gated(\"rustc_attrs\",\n                                         \"the `#[rustc_no_mir]` attribute \\\n                                          is just used to make tests pass \\\n-                                         and will never be stable\")),\n+                                         and will never be stable\",\n+                                        cfg_fn!(rustc_attrs))),\n \n     (\"allow_internal_unstable\", Normal, Gated(\"allow_internal_unstable\",\n-                                              EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),\n+                                              EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n+                                              cfg_fn!(allow_internal_unstable))),\n \n     (\"fundamental\", Whitelisted, Gated(\"fundamental\",\n                                        \"the `#[fundamental]` attribute \\\n-                                        is an experimental feature\")),\n+                                        is an experimental feature\",\n+                                       cfg_fn!(fundamental))),\n \n     (\"linked_from\", Normal, Gated(\"linked_from\",\n                                   \"the `#[linked_from]` attribute \\\n-                                   is an experimental feature\")),\n+                                   is an experimental feature\",\n+                                  cfg_fn!(linked_from))),\n \n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted, Ungated),\n@@ -403,7 +470,8 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"cold\", Whitelisted, Ungated),\n     (\"naked\", Whitelisted, Gated(\"naked_functions\",\n                                  \"the `#[naked]` attribute \\\n-                                  is an experimental feature\")),\n+                                  is an experimental feature\",\n+                                 cfg_fn!(naked))),\n     (\"export_name\", Whitelisted, Ungated),\n     (\"inline\", Whitelisted, Ungated),\n     (\"link\", Whitelisted, Ungated),\n@@ -413,24 +481,30 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"no_mangle\", Whitelisted, Ungated),\n     (\"no_debug\", Whitelisted, Gated(\"no_debug\",\n                                     \"the `#[no_debug]` attribute \\\n-                                     is an experimental feature\")),\n+                                     is an experimental feature\",\n+                                    cfg_fn!(no_debug))),\n     (\"omit_gdb_pretty_printer_section\", Whitelisted, Gated(\"omit_gdb_pretty_printer_section\",\n                                                        \"the `#[omit_gdb_pretty_printer_section]` \\\n                                                         attribute is just used for the Rust test \\\n-                                                        suite\")),\n+                                                        suite\",\n+                                                       cfg_fn!(omit_gdb_pretty_printer_section))),\n     (\"unsafe_no_drop_flag\", Whitelisted, Gated(\"unsafe_no_drop_flag\",\n                                                \"unsafe_no_drop_flag has unstable semantics \\\n-                                                and may be removed in the future\")),\n+                                                and may be removed in the future\",\n+                                               cfg_fn!(unsafe_no_drop_flag))),\n     (\"unsafe_destructor_blind_to_params\",\n      Normal,\n      Gated(\"dropck_parametricity\",\n            \"unsafe_destructor_blind_to_params has unstable semantics \\\n-            and may be removed in the future\")),\n-    (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\")),\n+            and may be removed in the future\",\n+           cfg_fn!(dropck_parametricity))),\n+    (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\",\n+                                  cfg_fn!(unwind_attributes))),\n \n     // used in resolve\n     (\"prelude_import\", Whitelisted, Gated(\"prelude_import\",\n-                                          \"`#[prelude_import]` is for use by rustc only\")),\n+                                          \"`#[prelude_import]` is for use by rustc only\",\n+                                          cfg_fn!(prelude_import))),\n \n     // FIXME: #14407 these are only looked at on-demand so we can't\n     // guarantee they'll have already been checked\n@@ -441,9 +515,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"deprecated\", Normal, Ungated),\n \n     (\"rustc_paren_sugar\", Normal, Gated(\"unboxed_closures\",\n-                                        \"unboxed_closures are still evolving\")),\n+                                        \"unboxed_closures are still evolving\",\n+                                        cfg_fn!(unboxed_closures))),\n     (\"rustc_reflect_like\", Whitelisted, Gated(\"reflect\",\n-                                              \"defining reflective traits is still evolving\")),\n+                                              \"defining reflective traits is still evolving\",\n+                                              cfg_fn!(reflect))),\n \n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n@@ -456,21 +532,12 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"recursion_limit\", CrateLevel, Ungated),\n ];\n \n-macro_rules! cfg_fn {\n-    (|$x: ident| $e: expr) => {{\n-        fn f($x: &Features) -> bool {\n-            $e\n-        }\n-        f as fn(&Features) -> bool\n-    }}\n-}\n // cfg(...)'s that are feature gated\n const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n-    (\"target_feature\", \"cfg_target_feature\", cfg_fn!(|x| x.cfg_target_feature)),\n-    (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(|x| x.cfg_target_vendor)),\n-    (\"target_thread_local\", \"cfg_target_thread_local\",\n-     cfg_fn!(|x| x.cfg_target_thread_local)),\n+    (\"target_feature\", \"cfg_target_feature\", cfg_fn!(cfg_target_feature)),\n+    (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(cfg_target_vendor)),\n+    (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n ];\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -551,31 +618,6 @@ impl GatedCfg {\n     }\n }\n \n-\n-#[derive(PartialEq, Copy, Clone, Debug)]\n-pub enum AttributeType {\n-    /// Normal, builtin attribute that is consumed\n-    /// by the compiler before the unused_attribute check\n-    Normal,\n-\n-    /// Builtin attribute that may not be consumed by the compiler\n-    /// before the unused_attribute check. These attributes\n-    /// will be ignored by the unused_attribute lint\n-    Whitelisted,\n-\n-    /// Builtin attribute that is only allowed at the crate level\n-    CrateLevel,\n-}\n-\n-#[derive(PartialEq, Copy, Clone, Debug)]\n-pub enum AttributeGate {\n-    /// Is gated by a given feature gate and reason\n-    Gated(&'static str, &'static str),\n-\n-    /// Ungated attribute, can be used on all release channels\n-    Ungated,\n-}\n-\n /// A set of features to be used by later passes.\n pub struct Features {\n     pub unboxed_closures: bool,\n@@ -612,6 +654,53 @@ pub struct Features {\n     pub question_mark: bool,\n     pub specialization: bool,\n     pub pub_restricted: bool,\n+    pub structural_match: bool,\n+    pub plugin: bool,\n+    pub lang_items: bool,\n+    pub linkage: bool,\n+    pub thread_local: bool,\n+    pub on_unimplemented: bool,\n+    pub allocator: bool,\n+    pub needs_allocator: bool,\n+    pub fundamental: bool,\n+    pub linked_from: bool,\n+    pub naked: bool,\n+    pub no_debug: bool,\n+    pub omit_gdb_pretty_printer_section: bool,\n+    pub dropck_parametricity: bool,\n+    pub unwind_attributes: bool,\n+    pub prelude_import: bool,\n+    pub reflect: bool,\n+    pub no_core: bool,\n+    pub unsafe_no_drop_flag: bool,\n+    pub custom_derive: bool,\n+    pub custom_attribute: bool,\n+    pub asm: bool,\n+    pub log_syntax: bool,\n+    pub trace_macros: bool,\n+    pub concat_idents: bool,\n+    pub box_syntax: bool,\n+    pub placement_in_syntax: bool,\n+    pub non_ascii_idents: bool,\n+    pub macro_reexport: bool,\n+    pub link_args: bool,\n+    pub intrinsics: bool,\n+    pub platform_intrinsics: bool,\n+    pub abi_vectorcall: bool,\n+    pub plugin_registrar: bool,\n+    pub start: bool,\n+    pub main: bool,\n+    pub simd: bool,\n+    pub repr_simd: bool,\n+    pub optin_builtin_traits: bool,\n+    pub link_llvm_intrinsics: bool,\n+    pub type_ascription: bool,\n+    pub inclusive_range_syntax: bool,\n+    pub advanced_slice_patterns: bool,\n+    pub slice_patterns: bool,\n+    pub box_patterns: bool,\n+    pub associated_consts: bool,\n+    pub associated_type_defaults: bool\n }\n \n impl Features {\n@@ -649,6 +738,53 @@ impl Features {\n             question_mark: false,\n             specialization: false,\n             pub_restricted: false,\n+            structural_match: false,\n+            plugin: false,\n+            lang_items: false,\n+            linkage: false,\n+            thread_local: false,\n+            on_unimplemented: false,\n+            allocator: false,\n+            needs_allocator: false,\n+            fundamental: false,\n+            linked_from: false,\n+            naked: false,\n+            no_debug: false,\n+            omit_gdb_pretty_printer_section: false,\n+            dropck_parametricity: false,\n+            unwind_attributes: false,\n+            prelude_import: false,\n+            reflect: false,\n+            no_core: false,\n+            unsafe_no_drop_flag: false,\n+            custom_derive: false,\n+            custom_attribute: false,\n+            asm: false,\n+            log_syntax: false,\n+            trace_macros: false,\n+            concat_idents: false,\n+            box_syntax: false,\n+            placement_in_syntax: false,\n+            non_ascii_idents: false,\n+            macro_reexport: false,\n+            link_args: false,\n+            intrinsics: false,\n+            platform_intrinsics: false,\n+            abi_vectorcall: false,\n+            plugin_registrar: false,\n+            start: false,\n+            main: false,\n+            simd: false,\n+            repr_simd: false,\n+            optin_builtin_traits: false,\n+            link_llvm_intrinsics: false,\n+            type_ascription: false,\n+            inclusive_range_syntax: false,\n+            advanced_slice_patterns: false,\n+            slice_patterns: false,\n+            box_patterns: false,\n+            associated_consts: false,\n+            associated_type_defaults: false,\n         }\n     }\n }\n@@ -687,36 +823,37 @@ pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &Handler, span: Span\n }\n \n struct Context<'a> {\n-    features: Vec<&'static str>,\n+    features: Features,\n     span_handler: &'a Handler,\n     cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n \n-impl<'a> Context<'a> {\n-    fn enable_feature(&mut self, feature: &'static str) {\n-        debug!(\"enabling feature: {}\", feature);\n-        self.features.push(feature);\n-    }\n-\n-    fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n-        let has_feature = self.has_feature(feature);\n-        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", feature, span, has_feature);\n-        if !has_feature && !self.cm.span_allows_unstable(span) {\n-            emit_feature_err(self.span_handler, feature, span, GateIssue::Language, explain);\n+macro_rules! gate_feature_fn {\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (cx, has_feature, span, name, explain) = ($cx, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(&$cx.features);\n+        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n+        if !has_feature && !cx.cm.span_allows_unstable(span) {\n+            emit_feature_err(cx.span_handler, name, span, GateIssue::Language, explain);\n         }\n+    }}\n+}\n+\n+macro_rules! gate_feature {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span, stringify!($feature), $explain)\n     }\n-    fn has_feature(&self, feature: &str) -> bool {\n-        self.features.iter().any(|&n| n == feature)\n-    }\n+}\n \n+impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n         let name = &*attr.name();\n-        for &(n, ty, gateage) in KNOWN_ATTRIBUTES {\n+        for &(n, ty, ref gateage) in KNOWN_ATTRIBUTES {\n             if n == name {\n-                if let Gated(gate, desc) = gateage {\n-                    self.gate_feature(gate, attr.span, desc);\n+                if let &Gated(ref name, ref desc, ref has_feature) = gateage {\n+                    gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n                 debug!(\"check_attribute: {:?} is known, {:?}, {:?}\", name, ty, gateage);\n                 return;\n@@ -732,26 +869,26 @@ impl<'a> Context<'a> {\n             }\n         }\n         if name.starts_with(\"rustc_\") {\n-            self.gate_feature(\"rustc_attrs\", attr.span,\n-                              \"unless otherwise specified, attributes \\\n-                               with the prefix `rustc_` \\\n-                               are reserved for internal compiler diagnostics\");\n+            gate_feature!(self, rustc_attrs, attr.span,\n+                          \"unless otherwise specified, attributes \\\n+                           with the prefix `rustc_` \\\n+                           are reserved for internal compiler diagnostics\");\n         } else if name.starts_with(\"derive_\") {\n-            self.gate_feature(\"custom_derive\", attr.span,\n-                              \"attributes of the form `#[derive_*]` are reserved \\\n-                               for the compiler\");\n+            gate_feature!(self, custom_derive, attr.span,\n+                          \"attributes of the form `#[derive_*]` are reserved \\\n+                           for the compiler\");\n         } else {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs\n             // before the plugin attributes are registered\n             // so we skip this then\n             if !is_macro {\n-                self.gate_feature(\"custom_attribute\", attr.span,\n-                           &format!(\"The attribute `{}` is currently \\\n-                                    unknown to the compiler and \\\n-                                    may have meaning \\\n-                                    added to it in the future\",\n-                                    name));\n+                gate_feature!(self, custom_attribute, attr.span,\n+                              &format!(\"The attribute `{}` is currently \\\n+                                        unknown to the compiler and \\\n+                                        may have meaning \\\n+                                        added to it in the future\",\n+                                       name));\n             }\n         }\n     }\n@@ -833,19 +970,19 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         // code, e.g. `#[cfg]`-guarded functions.\n \n         if name == \"asm\" {\n-            self.context.gate_feature(\"asm\", path.span, EXPLAIN_ASM);\n+            gate_feature!(self.context, asm, path.span, EXPLAIN_ASM);\n         }\n \n         else if name == \"log_syntax\" {\n-            self.context.gate_feature(\"log_syntax\", path.span, EXPLAIN_LOG_SYNTAX);\n+            gate_feature!(self.context, log_syntax, path.span, EXPLAIN_LOG_SYNTAX);\n         }\n \n         else if name == \"trace_macros\" {\n-            self.context.gate_feature(\"trace_macros\", path.span, EXPLAIN_TRACE_MACROS);\n+            gate_feature!(self.context, trace_macros, path.span, EXPLAIN_TRACE_MACROS);\n         }\n \n         else if name == \"concat_idents\" {\n-            self.context.gate_feature(\"concat_idents\", path.span, EXPLAIN_CONCAT_IDENTS);\n+            gate_feature!(self.context, concat_idents, path.span, EXPLAIN_CONCAT_IDENTS);\n         }\n     }\n \n@@ -863,11 +1000,11 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         // uses in e.g. conditionalized code.\n \n         if let ast::ExprKind::Box(_) = e.node {\n-            self.context.gate_feature(\"box_syntax\", e.span, EXPLAIN_BOX_SYNTAX);\n+            gate_feature!(self.context, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n         }\n \n         if let ast::ExprKind::InPlace(..) = e.node {\n-            self.context.gate_feature(\"placement_in_syntax\", e.span, EXPLAIN_PLACEMENT_IN);\n+            gate_feature!(self.context, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n         }\n \n         visit::walk_expr(self, e);\n@@ -878,12 +1015,13 @@ struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }\n \n-impl<'a> PostExpansionVisitor<'a> {\n-    fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n-        if !self.context.cm.span_allows_unstable(span) {\n-            self.context.gate_feature(feature, span, explain)\n+macro_rules! gate_feature_post {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !cx.context.cm.span_allows_unstable(span) {\n+            gate_feature!(cx.context, $feature, span, $explain)\n         }\n-    }\n+    }}\n }\n \n impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n@@ -895,69 +1033,68 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n         if !name.as_str().is_ascii() {\n-            self.gate_feature(\"non_ascii_idents\", sp,\n-                              \"non-ascii idents are not fully supported.\");\n+            gate_feature_post!(&self, non_ascii_idents, sp,\n+                               \"non-ascii idents are not fully supported.\");\n         }\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) {\n         match i.node {\n             ast::ItemKind::ExternCrate(_) => {\n                 if attr::contains_name(&i.attrs[..], \"macro_reexport\") {\n-                    self.gate_feature(\"macro_reexport\", i.span,\n-                                      \"macros reexports are experimental \\\n-                                       and possibly buggy\");\n+                    gate_feature_post!(&self, macro_reexport, i.span,\n+                                       \"macros reexports are experimental \\\n+                                        and possibly buggy\");\n                 }\n             }\n \n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[..], \"link_args\") {\n-                    self.gate_feature(\"link_args\", i.span,\n+                    gate_feature_post!(&self, link_args, i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n                                        use `#[link(name = \\\"foo\\\")]` instead\")\n                 }\n-                let maybe_feature = match foreign_module.abi {\n-                    Abi::RustIntrinsic => Some((\"intrinsics\", \"intrinsics are subject to change\")),\n+                match foreign_module.abi {\n+                    Abi::RustIntrinsic =>\n+                        gate_feature_post!(&self, intrinsics, i.span,\n+                                           \"intrinsics are subject to change\"),\n                     Abi::PlatformIntrinsic => {\n-                        Some((\"platform_intrinsics\",\n-                              \"platform intrinsics are experimental and possibly buggy\"))\n+                        gate_feature_post!(&self, platform_intrinsics, i.span,\n+                                           \"platform intrinsics are experimental \\\n+                                            and possibly buggy\")\n                     },\n                     Abi::Vectorcall => {\n-                        Some((\"abi_vectorcall\",\n-                            \"vectorcall is experimental and subject to change\"\n-                        ))\n+                        gate_feature_post!(&self, abi_vectorcall, i.span,\n+                                           \"vectorcall is experimental and subject to change\")\n                     }\n-                    _ => None\n-                };\n-                if let Some((feature, msg)) = maybe_feature {\n-                    self.gate_feature(feature, i.span, msg)\n+                    _ => ()\n                 }\n             }\n \n             ast::ItemKind::Fn(..) => {\n                 if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n-                    self.gate_feature(\"plugin_registrar\", i.span,\n-                                      \"compiler plugins are experimental and possibly buggy\");\n+                    gate_feature_post!(&self, plugin_registrar, i.span,\n+                                       \"compiler plugins are experimental and possibly buggy\");\n                 }\n                 if attr::contains_name(&i.attrs[..], \"start\") {\n-                    self.gate_feature(\"start\", i.span,\n+                    gate_feature_post!(&self, start, i.span,\n                                       \"a #[start] function is an experimental \\\n                                        feature whose signature may change \\\n                                        over time\");\n                 }\n                 if attr::contains_name(&i.attrs[..], \"main\") {\n-                    self.gate_feature(\"main\", i.span,\n-                                      \"declaration of a nonstandard #[main] \\\n-                                       function may change over time, for now \\\n-                                       a top-level `fn main()` is required\");\n+                    gate_feature_post!(&self, main, i.span,\n+                                       \"declaration of a nonstandard #[main] \\\n+                                        function may change over time, for now \\\n+                                        a top-level `fn main()` is required\");\n                 }\n             }\n \n             ast::ItemKind::Struct(..) => {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n-                    self.gate_feature(\"simd\", i.span,\n-                                      \"SIMD types are experimental and possibly buggy\");\n+                    gate_feature_post!(&self, simd, i.span,\n+                                       \"SIMD types are experimental and possibly buggy\");\n                     self.context.span_handler.span_warn(i.span,\n                                                         \"the `#[simd]` attribute is deprecated, \\\n                                                          use `#[repr(simd)]` instead\");\n@@ -966,8 +1103,9 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                     if attr.name() == \"repr\" {\n                         for item in attr.meta_item_list().unwrap_or(&[]) {\n                             if item.name() == \"simd\" {\n-                                self.gate_feature(\"repr_simd\", i.span,\n-                                                  \"SIMD types are experimental and possibly buggy\");\n+                                gate_feature_post!(&self, repr_simd, i.span,\n+                                                   \"SIMD types are experimental \\\n+                                                    and possibly buggy\");\n \n                             }\n                         }\n@@ -976,19 +1114,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::DefaultImpl(..) => {\n-                self.gate_feature(\"optin_builtin_traits\",\n-                                  i.span,\n-                                  \"default trait implementations are experimental \\\n-                                   and possibly buggy\");\n+                gate_feature_post!(&self, optin_builtin_traits,\n+                                   i.span,\n+                                   \"default trait implementations are experimental \\\n+                                    and possibly buggy\");\n             }\n \n             ast::ItemKind::Impl(_, polarity, _, _, _, _) => {\n                 match polarity {\n                     ast::ImplPolarity::Negative => {\n-                        self.gate_feature(\"optin_builtin_traits\",\n-                                          i.span,\n-                                          \"negative trait bounds are not yet fully implemented; \\\n-                                          use marker types for now\");\n+                        gate_feature_post!(&self, optin_builtin_traits,\n+                                           i.span,\n+                                           \"negative trait bounds are not yet fully implemented; \\\n+                                            use marker types for now\");\n                     },\n                     _ => {}\n                 }\n@@ -1001,7 +1139,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_variant_data(&mut self, s: &'v ast::VariantData, _: ast::Ident,\n-                        _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n+                          _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n         if s.fields().is_empty() {\n             if s.is_tuple() {\n                 self.context.span_handler.struct_span_err(span, \"empty tuple structs and enum \\\n@@ -1023,7 +1161,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             _ => false\n         };\n         if links_to_llvm {\n-            self.gate_feature(\"link_llvm_intrinsics\", i.span,\n+            gate_feature_post!(&self, link_llvm_intrinsics, i.span,\n                               \"linking to LLVM intrinsics is experimental\");\n         }\n \n@@ -1033,22 +1171,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprKind::Box(_) => {\n-                self.gate_feature(\"box_syntax\",\n-                                  e.span,\n-                                  \"box expression syntax is experimental; \\\n-                                   you can call `Box::new` instead.\");\n+                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n             }\n             ast::ExprKind::Type(..) => {\n-                self.gate_feature(\"type_ascription\", e.span,\n+                gate_feature_post!(&self, type_ascription, e.span,\n                                   \"type ascription is experimental\");\n             }\n             ast::ExprKind::Range(_, _, ast::RangeLimits::Closed) => {\n-                self.gate_feature(\"inclusive_range_syntax\",\n+                gate_feature_post!(&self, inclusive_range_syntax,\n                                   e.span,\n                                   \"inclusive range syntax is experimental\");\n             }\n             ast::ExprKind::Try(..) => {\n-                self.gate_feature(\"question_mark\", e.span, \"the `?` operator is not stable\");\n+                gate_feature_post!(&self, question_mark, e.span, \"the `?` operator is not stable\");\n             }\n             _ => {}\n         }\n@@ -1058,19 +1193,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match pattern.node {\n             PatKind::Vec(_, Some(_), ref last) if !last.is_empty() => {\n-                self.gate_feature(\"advanced_slice_patterns\",\n+                gate_feature_post!(&self, advanced_slice_patterns,\n                                   pattern.span,\n                                   \"multiple-element slice matches anywhere \\\n                                    but at the end of a slice (e.g. \\\n                                    `[0, ..xs, 0]`) are experimental\")\n             }\n             PatKind::Vec(..) => {\n-                self.gate_feature(\"slice_patterns\",\n+                gate_feature_post!(&self, slice_patterns,\n                                   pattern.span,\n                                   \"slice pattern syntax is experimental\");\n             }\n             PatKind::Box(..) => {\n-                self.gate_feature(\"box_patterns\",\n+                gate_feature_post!(&self, box_patterns,\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n@@ -1088,7 +1223,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         // check for const fn declarations\n         match fn_kind {\n             FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {\n-                self.gate_feature(\"const_fn\", span, \"const fn is unstable\");\n+                gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n             }\n             _ => {\n                 // stability of const fn methods are covered in\n@@ -1100,18 +1235,18 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n         match fn_kind {\n             FnKind::ItemFn(_, _, _, _, abi, _) if abi == Abi::RustIntrinsic => {\n-                self.gate_feature(\"intrinsics\",\n+                gate_feature_post!(&self, intrinsics,\n                                   span,\n                                   \"intrinsics are subject to change\")\n             }\n             FnKind::ItemFn(_, _, _, _, abi, _) |\n             FnKind::Method(_, &ast::MethodSig { abi, .. }, _) => match abi {\n                 Abi::RustCall => {\n-                    self.gate_feature(\"unboxed_closures\", span,\n+                    gate_feature_post!(&self, unboxed_closures, span,\n                         \"rust-call ABI is subject to change\");\n                 },\n                 Abi::Vectorcall => {\n-                    self.gate_feature(\"abi_vectorcall\", span,\n+                    gate_feature_post!(&self, abi_vectorcall, span,\n                         \"vectorcall is experimental and subject to change\");\n                 },\n                 _ => {}\n@@ -1124,17 +1259,17 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n         match ti.node {\n             ast::TraitItemKind::Const(..) => {\n-                self.gate_feature(\"associated_consts\",\n+                gate_feature_post!(&self, associated_consts,\n                                   ti.span,\n                                   \"associated constants are experimental\")\n             }\n             ast::TraitItemKind::Method(ref sig, _) => {\n                 if sig.constness == ast::Constness::Const {\n-                    self.gate_feature(\"const_fn\", ti.span, \"const fn is unstable\");\n+                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n                 }\n             }\n             ast::TraitItemKind::Type(_, Some(_)) => {\n-                self.gate_feature(\"associated_type_defaults\", ti.span,\n+                gate_feature_post!(&self, associated_type_defaults, ti.span,\n                                   \"associated type defaults are unstable\");\n             }\n             _ => {}\n@@ -1144,20 +1279,20 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n         if ii.defaultness == ast::Defaultness::Default {\n-            self.gate_feature(\"specialization\",\n+            gate_feature_post!(&self, specialization,\n                               ii.span,\n                               \"specialization is unstable\");\n         }\n \n         match ii.node {\n             ast::ImplItemKind::Const(..) => {\n-                self.gate_feature(\"associated_consts\",\n+                gate_feature_post!(&self, associated_consts,\n                                   ii.span,\n                                   \"associated constants are experimental\")\n             }\n             ast::ImplItemKind::Method(ref sig, _) => {\n                 if sig.constness == ast::Constness::Const {\n-                    self.gate_feature(\"const_fn\", ii.span, \"const fn is unstable\");\n+                    gate_feature_post!(&self, const_fn, ii.span, \"const fn is unstable\");\n                 }\n             }\n             _ => {}\n@@ -1171,7 +1306,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             ast::Visibility::Restricted { ref path, .. } => path.span,\n             _ => return,\n         };\n-        self.gate_feature(\"pub_restricted\", span, \"`pub(restricted)` syntax is experimental\");\n+        gate_feature_post!(&self, pub_restricted, span, \"`pub(restricted)` syntax is experimental\");\n     }\n }\n \n@@ -1182,15 +1317,9 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n                        -> Features\n     where F: FnOnce(&mut Context, &ast::Crate)\n {\n-    let mut cx = Context {\n-        features: Vec::new(),\n-        span_handler: span_handler,\n-        cm: cm,\n-        plugin_attributes: plugin_attributes,\n-    };\n-\n     let mut accepted_features = Vec::new();\n     let mut unknown_features = Vec::new();\n+    let mut enabled_features = Vec::new();\n \n     for attr in &krate.attrs {\n         if !attr.check_name(\"feature\") {\n@@ -1216,7 +1345,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n                     match KNOWN_FEATURES.iter()\n                                         .find(|& &(n, _, _, _)| name == n) {\n                         Some(&(name, _, _, Active)) => {\n-                            cx.enable_feature(name);\n+                            enabled_features.push(name);\n                         }\n                         Some(&(_, _, _, Removed)) => {\n                             span_handler.span_err(mi.span, \"feature has been removed\");\n@@ -1233,45 +1362,104 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         }\n     }\n \n-    check(&mut cx, krate);\n+    let has_feature = |feature: &str| -> bool {\n+        enabled_features.iter().any(|&n| n == feature)\n+    };\n \n     // FIXME (pnkfelix): Before adding the 99th entry below, change it\n     // to a single-pass (instead of N calls to `.has_feature`).\n \n-    Features {\n-        unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n-        rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n-        allow_quote: cx.has_feature(\"quote\"),\n-        allow_asm: cx.has_feature(\"asm\"),\n-        allow_log_syntax: cx.has_feature(\"log_syntax\"),\n-        allow_concat_idents: cx.has_feature(\"concat_idents\"),\n-        allow_trace_macros: cx.has_feature(\"trace_macros\"),\n-        allow_internal_unstable: cx.has_feature(\"allow_internal_unstable\"),\n-        allow_custom_derive: cx.has_feature(\"custom_derive\"),\n-        allow_placement_in: cx.has_feature(\"placement_in_syntax\"),\n-        allow_box: cx.has_feature(\"box_syntax\"),\n-        allow_pushpop_unsafe: cx.has_feature(\"pushpop_unsafe\"),\n-        allow_inclusive_range: cx.has_feature(\"inclusive_range_syntax\"),\n-        simd_ffi: cx.has_feature(\"simd_ffi\"),\n-        unmarked_api: cx.has_feature(\"unmarked_api\"),\n+    let features = Features {\n+        unboxed_closures: has_feature(\"unboxed_closures\"),\n+        rustc_diagnostic_macros: has_feature(\"rustc_diagnostic_macros\"),\n+        allow_quote: has_feature(\"quote\"),\n+        allow_asm: has_feature(\"asm\"),\n+        allow_log_syntax: has_feature(\"log_syntax\"),\n+        allow_concat_idents: has_feature(\"concat_idents\"),\n+        allow_trace_macros: has_feature(\"trace_macros\"),\n+        allow_internal_unstable: has_feature(\"allow_internal_unstable\"),\n+        allow_custom_derive: has_feature(\"custom_derive\"),\n+        allow_placement_in: has_feature(\"placement_in_syntax\"),\n+        allow_box: has_feature(\"box_syntax\"),\n+        allow_pushpop_unsafe: has_feature(\"pushpop_unsafe\"),\n+        allow_inclusive_range: has_feature(\"inclusive_range_syntax\"),\n+        simd_ffi: has_feature(\"simd_ffi\"),\n+        unmarked_api: has_feature(\"unmarked_api\"),\n         declared_stable_lang_features: accepted_features,\n         declared_lib_features: unknown_features,\n-        const_fn: cx.has_feature(\"const_fn\"),\n-        const_indexing: cx.has_feature(\"const_indexing\"),\n-        static_recursion: cx.has_feature(\"static_recursion\"),\n-        default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n-        rustc_attrs: cx.has_feature(\"rustc_attrs\"),\n-        type_macros: cx.has_feature(\"type_macros\"),\n-        cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n-        cfg_target_vendor: cx.has_feature(\"cfg_target_vendor\"),\n-        cfg_target_thread_local: cx.has_feature(\"cfg_target_thread_local\"),\n-        staged_api: cx.has_feature(\"staged_api\"),\n-        stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n-        deprecated: cx.has_feature(\"deprecated\"),\n-        question_mark: cx.has_feature(\"question_mark\"),\n-        specialization: cx.has_feature(\"specialization\"),\n-        pub_restricted: cx.has_feature(\"pub_restricted\"),\n-    }\n+        const_fn: has_feature(\"const_fn\"),\n+        const_indexing: has_feature(\"const_indexing\"),\n+        static_recursion: has_feature(\"static_recursion\"),\n+        default_type_parameter_fallback: has_feature(\"default_type_parameter_fallback\"),\n+        rustc_attrs: has_feature(\"rustc_attrs\"),\n+        type_macros: has_feature(\"type_macros\"),\n+        cfg_target_feature: has_feature(\"cfg_target_feature\"),\n+        cfg_target_vendor: has_feature(\"cfg_target_vendor\"),\n+        cfg_target_thread_local: has_feature(\"cfg_target_thread_local\"),\n+        staged_api: has_feature(\"staged_api\"),\n+        stmt_expr_attributes: has_feature(\"stmt_expr_attributes\"),\n+        deprecated: has_feature(\"deprecated\"),\n+        question_mark: has_feature(\"question_mark\"),\n+        specialization: has_feature(\"specialization\"),\n+        pub_restricted: has_feature(\"pub_restricted\"),\n+        structural_match: has_feature(\"bool\"),\n+        plugin: has_feature(\"plugin\"),\n+        lang_items: has_feature(\"lang_items\"),\n+        linkage: has_feature(\"linkage\"),\n+        thread_local: has_feature(\"thread_local\"),\n+        on_unimplemented: has_feature(\"on_unimplemented\"),\n+        allocator: has_feature(\"allocator\"),\n+        needs_allocator: has_feature(\"needs_allocator\"),\n+        fundamental: has_feature(\"fundamental\"),\n+        linked_from: has_feature(\"linked_from\"),\n+        naked: has_feature(\"naked\"),\n+        no_debug: has_feature(\"no_debug\"),\n+        omit_gdb_pretty_printer_section: has_feature(\"omit_gdb_pretty_printer_section\"),\n+        dropck_parametricity: has_feature(\"dropck_parametricity\"),\n+        unwind_attributes: has_feature(\"unwind_attributes\"),\n+        prelude_import: has_feature(\"prelude_import\"),\n+        reflect: has_feature(\"reflect\"),\n+        no_core: has_feature(\"no_core\"),\n+        unsafe_no_drop_flag: has_feature(\"unsafe_no_drop_flag\"),\n+        custom_derive: has_feature(\"custom_derive\"),\n+        custom_attribute: has_feature(\"custom_attribute\"),\n+        asm: has_feature(\"asm\"),\n+        log_syntax: has_feature(\"log_syntax\"),\n+        trace_macros: has_feature(\"trace_macros\"),\n+        concat_idents: has_feature(\"concat_idents\"),\n+        box_syntax: has_feature(\"box_syntax\"),\n+        placement_in_syntax: has_feature(\"placement_in_syntax\"),\n+        non_ascii_idents: has_feature(\"non_ascii_idents\"),\n+        macro_reexport: has_feature(\"macro_reexport\"),\n+        link_args: has_feature(\"link_args\"),\n+        intrinsics: has_feature(\"intrinsics\"),\n+        platform_intrinsics: has_feature(\"platform_intrinsics\"),\n+        abi_vectorcall: has_feature(\"abi_vectorcall\"),\n+        plugin_registrar: has_feature(\"plugin_registrar\"),\n+        start: has_feature(\"start\"),\n+        main: has_feature(\"main\"),\n+        simd: has_feature(\"simd\"),\n+        repr_simd: has_feature(\"repr_simd\"),\n+        optin_builtin_traits: has_feature(\"optin_builtin_traits\"),\n+        link_llvm_intrinsics: has_feature(\"link_llvm_intrinsics\"),\n+        type_ascription: has_feature(\"type_ascription\"),\n+        inclusive_range_syntax: has_feature(\"inclusive_range_syntax\"),\n+        advanced_slice_patterns: has_feature(\"advanced_slice_patterns\"),\n+        slice_patterns: has_feature(\"slice_patterns\"),\n+        box_patterns: has_feature(\"box_patterns\"),\n+        associated_consts: has_feature(\"associated_consts\"),\n+        associated_type_defaults: has_feature(\"associated_type_defaults\"),\n+    };\n+\n+    let mut cx = Context {\n+        features: features,\n+        span_handler: span_handler,\n+        cm: cm,\n+        plugin_attributes: plugin_attributes,\n+    };\n+\n+    check(&mut cx, krate);\n+    cx.features\n }\n \n pub fn check_crate_macros(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate)"}]}